[{"methodBody": ["METHOD_START", "{", "for    ( PathElement   path    :    paths )     {", "context . addStep ( Util . createAddOperation ( context . getCurrentAddress (  )  . append ( path )  )  ,    new   AddIfAbsent ( present )  ,    MODEL )  ;", "}", "}", "METHOD_END"], "methodName": ["addRequiredChildren"], "fileName": "org.jboss.as.clustering.controller.AddStepHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . getDefinition (  )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.clustering.controller.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   this . getDefinition (  )  . resolveModelAttribute ( resolver ,    model )  ;", "}", "METHOD_END"], "methodName": ["resolveModelAttribute"], "fileName": "org.jboss.as.clustering.controller.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   AttributeTranslation . IDENTITY _ ADDRESS _ TRANSFORMATION ;", "}", "METHOD_END"], "methodName": ["getPathAddressTransformation"], "fileName": "org.jboss.as.clustering.controller.AttributeTranslation"}, {"methodBody": ["METHOD_START", "{", "return   AttributeTranslation . IDENTITY _ TRANSLATOR ;", "}", "METHOD_END"], "methodName": ["getReadTranslator"], "fileName": "org.jboss.as.clustering.controller.AttributeTranslation"}, {"methodBody": ["METHOD_START", "{", "return   AttributeTranslation . IDENTITY _ RESOURCE _ REGISTRATION _ TRANSFORMATION ;", "}", "METHOD_END"], "methodName": ["getResourceRegistrationTransformation"], "fileName": "org.jboss.as.clustering.controller.AttributeTranslation"}, {"methodBody": ["METHOD_START", "{", "return   AttributeTranslation . IDENTITY _ TRANSLATOR ;", "}", "METHOD_END"], "methodName": ["getWriteTranslator"], "fileName": "org.jboss.as.clustering.controller.AttributeTranslation"}, {"methodBody": ["METHOD_START", "{", "RuntimeCapability <  ?  >    definition    =    this . getDefinition (  )  ;", "return   definition . isDynamicallyNamed (  )     ?    definition . fromBaseCapability ( address )     :    definition ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.jboss.as.clustering.controller.Capability"}, {"methodBody": ["METHOD_START", "{", "return   this . configure ( context . getCapabilityServiceSupport (  )  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.clustering.controller.CapabilityServiceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.clustering.controller.CapabilityServiceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . getDefinition (  )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.clustering.controller.Metric"}, {"methodBody": ["METHOD_START", "{", "return    ( ModelVersion . compare ( this . getVersion (  )  ,    version )  )     <     0  ;", "}", "METHOD_END"], "methodName": ["requiresTransformation"], "fileName": "org.jboss.as.clustering.controller.Model"}, {"methodBody": ["METHOD_START", "{", "return   this . getDefinition (  )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.clustering.controller.Operation"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getCapabilities"], "fileName": "org.jboss.as.clustering.controller.OperationStepHandlerDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createAddOperation ( address ,    index ,    Collections . emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["createAddOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operation . get ( ADD _ INDEX )  . set ( index )  ;", "for    ( Map . Entry < Attribute ,    ModelNode >    entry    :    parameters . entrySet (  )  )     {", "operation . get ( entry . getKey (  )  . getName (  )  )  . set ( entry . getValue (  )  )  ;", "}", "return   operation ;", "}", "METHOD_END"], "methodName": ["createAddOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "for    ( Map . Entry < Attribute ,    ModelNode >    entry    :    parameters . entrySet (  )  )     {", "operation . get ( entry . getKey (  )  . getName (  )  )  . set ( entry . getValue (  )  )  ;", "}", "return   operation ;", "}", "METHOD_END"], "methodName": ["createAddOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createOperation ( operationName ,    address )  ;", "operation . get ( NAME )  . set ( attribute . getName (  )  )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createAttributeOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createOperation ( COMPOSITE ,    EMPTY _ ADDRESS )  ;", "ModelNode   steps    =    operation . get ( STEPS )  ;", "for    ( ModelNode   step    :    operations )     {", "steps . add ( step )  ;", "}", "return   operation ;", "}", "METHOD_END"], "methodName": ["createCompositeOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createCompositeOperation ( Arrays . asList ( operations )  )  ;", "}", "METHOD_END"], "methodName": ["createCompositeOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Util . createOperation ( DESCRIBE ,    address )  ;", "}", "METHOD_END"], "methodName": ["createDescribeOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createListElementOperation ( LIST _ ADD _ DEFINITION ,    address ,    attribute ,    value )  ;", "}", "METHOD_END"], "methodName": ["createListAddOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Operations . createAttributeOperation ( definition . getName (  )  ,    address ,    attribute )  ;", "operation . get ( Operations . INDEX )  . set ( new   ModelNode ( index )  )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createListElementOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Operations . createAttributeOperation ( definition . getName (  )  ,    address ,    attribute )  ;", "operation . get ( VALUE )  . set ( value )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createListElementOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createListElementOperation ( LIST _ GET _ DEFINITION ,    address ,    attribute ,    index )  ;", "}", "METHOD_END"], "methodName": ["createListGetOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createListElementOperation ( LIST _ REMOVE _ DEFINITION ,    address ,    attribute ,    index )  ;", "}", "METHOD_END"], "methodName": ["createListRemoveOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createListElementOperation ( LIST _ REMOVE _ DEFINITION ,    address ,    attribute ,    value )  ;", "}", "METHOD_END"], "methodName": ["createListRemoveOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createOperation ( MAP _ CLEAR _ DEFINITION ,    address )  ;", "operation . get ( NAME )  . set ( attribute . getName (  )  )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createMapClearOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Operations . createAttributeOperation ( definition . getName (  )  ,    address ,    attribute )  ;", "operation . get ( Operations . KEY )  . set ( key )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createMapEntryOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapEntryOperation ( MAP _ GET _ DEFINITION ,    address ,    attribute ,    key )  ;", "}", "METHOD_END"], "methodName": ["createMapGetOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Operations . createMapEntryOperation ( MAP _ PUT _ DEFINITION ,    address ,    attribute ,    key )  ;", "operation . get ( VALUE )  . set ( value )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createMapPutOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapEntryOperation ( MAP _ REMOVE _ DEFINITION ,    address ,    attribute ,    key )  ;", "}", "METHOD_END"], "methodName": ["createMapRemoveOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createAttributeOperation ( READ _ ATTRIBUTE _ OPERATION ,    address ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["createReadAttributeOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Util . createOperation ( READ _ RESOURCE _ OPERATION ,    address )  ;", "}", "METHOD_END"], "methodName": ["createReadResourceOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createAttributeOperation ( UNDEFINE _ ATTRIBUTE _ OPERATION ,    address ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["createUndefineAttributeOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Operations . createAttributeOperation ( WRITE _ ATTRIBUTE _ OPERATION ,    address ,    attribute )  ;", "operation . get ( VALUE )  . set ( value )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createWriteAttributeOperation"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "Set < String >    writeAttributeOperations    =    new   HashSet <  >  (  )  ;", "writeAttributeOperations . addAll ( MAP _ OPERATION _ NAMES )  ;", "writeAttributeOperations . remove ( MAP _ GET _ DEFINITION . getName (  )  )  ;", "writeAttributeOperations . add ( WRITE _ ATTRIBUTE _ OPERATION )  ;", "writeAttributeOperations . add ( UNDEFINE _ ATTRIBUTE _ OPERATION )  ;", "return   writeAttributeOperations ;", "}", "METHOD_END"], "methodName": ["getAllWriteAttributeOperationNames"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   operation . require ( NAME )  . asString (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeName"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   operation . hasDefined ( VALUE )     ?    operation . get ( VALUE )     :    new   ModelNode (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeValue"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   operation . require ( OP )  . asString (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  ;", "}", "METHOD_END"], "methodName": ["getPathAddress"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "return   operation . hasDefined ( INCLUDE _ DEFAULTS )     ?    operation . get ( INCLUDE _ DEFAULTS )  . asBoolean (  )     :    true ;", "}", "METHOD_END"], "methodName": ["isIncludeDefaults"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPathAddress"], "fileName": "org.jboss.as.clustering.controller.Operations"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  0  ,     (  ( properties . length )     %     2  )  )  ;", "ModelNode   props    =    model . get (  \" property \"  )  ;", "Assert . assertEquals (  (  ( properties . length )     /     2  )  ,     ( props . isDefined (  )     ?    props . keys (  )  . size (  )     :     0  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( properties . length )  ;    i    +  =     2  )     {", "ModelNode   property    =    props . get ( properties [ i ]  )  ;", "Assert . assertTrue ( property . isDefined (  )  )  ;", "Assert . assertEquals (  1  ,    property . keys (  )  . size (  )  )  ;", "Assert . assertEquals ( properties [  ( i    +     1  )  ]  ,    property . get (  \" value \"  )  . asString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkLegacyChildResourceModel"], "fileName": "org.jboss.as.clustering.controller.PropertiesTestUtil"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  0  ,     (  ( properties . length )     %     2  )  )  ;", "ModelNode   props    =    model . get (  \" properties \"  )  ;", "Assert . assertEquals (  (  ( properties . length )     /     2  )  ,     ( props . isDefined (  )     ?    props . keys (  )  . size (  )     :     0  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( properties . length )  ;    i    +  =     2  )     {", "Assert . assertEquals ( properties [  ( i    +     1  )  ]  ,    props . get ( properties [ i ]  )  . asString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkMainMapModel"], "fileName": "org.jboss.as.clustering.controller.PropertiesTestUtil"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   readResource    =    Util . createEmptyOperation ( ModelDescriptionConstants . READ _ RESOURCE _ OPERATION ,    address )  ;", "readResource . get ( ModelDescriptionConstants . RECURSIVE )  . set ( true )  ;", "readResource . get ( ModelDescriptionConstants . INCLUDE _ DEFAULTS )  . set ( false )  ;", "ModelNode   mainModel    =    services . executeForResult ( readResource . clone (  )  )  ;", ". checkMainMapModel ( mainModel ,    properties )  ;", "final   ModelNode   legacyModel ;", "if    ( address . getLastElement (  )  . getKey (  )  . equals (  \" transport \"  )  )     {", "readResource . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . subAddress (  0  ,     (  ( address . size (  )  )     -     1  )  )  . append (  \" transport \"  ,     \" TRANSPORT \"  )  . toModelNode (  )  )  ;", "legacyModel    =    services . getLegacyServices ( version )  . executeForResult ( readResource )  ;", "} else    {", "legacyModel    =    ModelTestUtils . checkResultAndGetContents ( services . executeOperation ( version ,    services . transformOperation ( version ,    readResource . clone (  )  )  )  )  ;", "}", ". checkLegacyChildResourceModel ( legacyModel ,    properties )  ;", "}", "METHOD_END"], "methodName": ["checkMapModels"], "fileName": "org.jboss.as.clustering.controller.PropertiesTestUtil"}, {"methodBody": ["METHOD_START", "{", "ModelNode   main    =    ModelTestUtils . checkOutcome ( services . executeOperation ( operation . clone (  )  )  )  . get ( RESULT )  ;", "ModelNode   legacyResult    =    services . executeOperation ( version ,    services . transformOperation ( version ,    operation . clone (  )  )  )  ;", "ModelNode   legacy ;", "if    ( expected . isDefined (  )  )     {", "legacy    =    ModelTestUtils . checkOutcome ( legacyResult )  . get ( RESULT )  ;", "} else    {", "ModelTestUtils . checkFailed ( legacyResult )  ;", "legacy    =    new   ModelNode (  )  ;", "}", "Assert . assertEquals ( main ,    legacy )  ;", "Assert . assertEquals ( expected ,    legacy )  ;", "}", "METHOD_END"], "methodName": ["checkMapResults"], "fileName": "org.jboss.as.clustering.controller.PropertiesTestUtil"}, {"methodBody": ["METHOD_START", "{", "OperationTransformer . TransformedOperation   op    =    services . executeInMainAndGetTheTransformedOperation ( operation ,    version )  ;", "Assert . assertFalse ( op . rejectOperation (  . success (  )  )  )  ;", "if    (  ( op . getTransformedOperation (  )  )     !  =    null )     {", "return   ModelTestUtils . checkOutcome ( services . getLegacyServices ( version )  . executeOperation ( op . getTransformedOperation (  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["executeOpInBothControllersWithAttachments"], "fileName": "org.jboss.as.clustering.controller.PropertiesTestUtil"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   result    =    new   ModelNode (  )  ;", "result . get ( ModelDescriptionConstants . OUTCOME )  . set ( ModelDescriptionConstants . SUCCESS )  ;", "result . get ( ModelDescriptionConstants . RESULT )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["success"], "fileName": "org.jboss.as.clustering.controller.PropertiesTestUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( String   childType    :    resource . getChildTypes (  )  )     {", "for    ( Resource . ResourceEntry   entry    :    resource . getChildren ( childType )  )     {", "if    (  (  !  ( entry . isRuntime (  )  )  )     &  &     ( resource . hasChild ( entry . getPathElement (  )  )  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["removeInCurrentStep"], "fileName": "org.jboss.as.clustering.controller.RemoveStepHandler"}, {"methodBody": ["METHOD_START", "{", "return   UnaryOperator . identity (  )  ;", "}", "METHOD_END"], "methodName": ["getOperationTransformation"], "fileName": "org.jboss.as.clustering.controller.RemoveStepHandlerDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceCapabilityReferences"], "fileName": "org.jboss.as.clustering.controller.RemoveStepHandlerDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getRuntimeResourceRegistrations"], "fileName": "org.jboss.as.clustering.controller.RemoveStepHandlerDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . attributeTranslations . put ( alias . getDefinition (  )  ,     (  )     -  >    target )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAlias"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . attributeTranslations . put ( sourceAttribute . getDefinition (  )  ,    translation )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAttributeTranslation"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addAttributes ( EnumSet . allOf ( enumClass )  )  ;", "}", "METHOD_END"], "methodName": ["addAttributes"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute   attribute    :    attributes )     {", "thittributedd ( attribute . getDefinition (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addAttributes"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addAttributes ( Arrays . asList ( attributes )  )  ;", "}", "METHOD_END"], "methodName": ["addAttributes"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addCapabilities ( Predicates . always (  )  ,    enumClass )  ;", "}", "METHOD_END"], "methodName": ["addCapabilities"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addCapabilities ( Predicates . always (  )  ,    capabilities )  ;", "}", "METHOD_END"], "methodName": ["addCapabilities"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addCapabilities ( predicate ,    EnumSet . allOf ( enumClass )  )  ;", "}", "METHOD_END"], "methodName": ["addCapabilities"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( Capability   capability    :    capabilities )     {", "thiapabilities . put ( capability ,    predicate )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addCapabilities"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addCapabilities ( predicate ,    Arrays . asList ( capabilities )  )  ;", "}", "METHOD_END"], "methodName": ["addCapabilities"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addCapabilities ( Predicates . always (  )  ,    capabilities )  ;", "}", "METHOD_END"], "methodName": ["addCapabilities"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addExtraParameters ( EnumSet . allOf ( enumClass )  )  ;", "}", "METHOD_END"], "methodName": ["addExtraParameters"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute   parameter    :    parameters )     {", "this . parameters . add ( parameter . getDefinition (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addExtraParameters"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . addExtraParameters ( Arrays . asList ( parameters )  )  ;", "}", "METHOD_END"], "methodName": ["addExtraParameters"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . parameters . addAll ( Arrays . asList ( parameters )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addExtraParameters"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( ResourceDefinition   definition    :    EnumSet . allOf ( enumClass )  )     {", "this . requiredChildren . add ( definition . getPathElement (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addRequiredChildren"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . requiredChildren . addAll ( Arrays . asList ( paths )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addRequiredChildren"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( ResourceDefinition   definition    :    EnumSet . allOf ( enumClass )  )     {", "this . requiredSingletonChildren . add ( definition . getPathElement (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addRequiredSingletonChildren"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . requiredSingletonChildren . addAll ( Arrays . asList ( paths )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addRequiredSingletonChildren"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . resourceCapabilityReferences . put ( reference ,    resolver )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addResourceCapabilityReference"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . runtimeResourceRegistrations . add ( registration )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addRuntimeResourceRegistration"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . addOperationTransformer    =    transformation ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAddOperationTransformation"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . operationTransformer    =    transformation ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOperationTransformation"], "fileName": "org.jboss.as.clustering.controller.ResourceDescriptor"}, {"methodBody": ["METHOD_START", "{", "OperationStepHandler   transformedHandler    =    this . descriptor . getOperationTransformation (  )  . apply ( handler )  ;", "if    ( handler    !  =    transformedHandler )     {", "r . registerOperationHandler ( definition ,    transformedHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["registerTransformedOperation"], "fileName": "org.jboss.as.clustering.controller.ResourceRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.clustering.controller.ResourceServiceBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . major (  )  )     >     ( schema . major (  )  )  )     |  |     (  (  ( this . major (  )  )     =  =     ( schema . major (  )  )  )     &  &     (  ( this . minor (  )  )     >  =     ( schema . minor (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["since"], "fileName": "org.jboss.as.clustering.controller.Schema"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement ( SUBSYSTEM ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.controller.SubsystemResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "this . handler . removeServices ( context ,    context . getOriginalRootResource (  )  . navigate ( context . getCurrentAddress (  )  )  . getModel (  )  )  ;", "this . handler . installServices ( context ,    context . readResource ( EMPTY _ ADDRESS )  . getModel (  )  )  ;", "}", "METHOD_END"], "methodName": ["restartServices"], "fileName": "org.jboss.as.clustering.controller.WriteAttributeStepHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . getBundleKey ( path ,    new   String [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getBundleKey"], "fileName": "org.jboss.as.clustering.controller.descriptions.ChildResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . getBundleKey ( path ,    new   String [  ]  {    key    }  ,    suffixes )  ;", "}", "METHOD_END"], "methodName": ["getBundleKey"], "fileName": "org.jboss.as.clustering.controller.descriptions.ChildResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder ( this . prefix )  ;", "for    ( String   value    :    path . isWildcard (  )     ?    new   String [  ]  {    path . getKey (  )     }     :    path . getKeyValuePair (  )  )     {", "builder . append (  '  .  '  )  . append ( value )  ;", "}", "for    ( String   key    :    keys )     {", "builder . append (  '  .  '  )  . append ( key )  ;", "}", "for    ( String   suffix    :    suffixes )     {", "builder . append (  '  .  '  )  . append ( suffix )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getBundleKey"], "fileName": "org.jboss.as.clustering.controller.descriptions.ChildResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "this . descriptions . put ( String . join (  \"  .  \"  ,    this . getKeyPrefix (  )  ,    key )  ,    description )  ;", "}", "METHOD_END"], "methodName": ["addDescription"], "fileName": "org.jboss.as.clustering.controller.descriptions.SimpleResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   ChildResourceDescriptionResolver ( this ,    this . getKeyPrefix (  )  ,    Arrays . asList ( paths )  )  ;", "}", "METHOD_END"], "methodName": ["createChildResolver"], "fileName": "org.jboss.as.clustering.controller.descriptions.SubsystemResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . initialValues . get ( InitialAttributeValueOperationContextAttachment . keyFor ( address ,    attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["getInitialValue"], "fileName": "org.jboss.as.clustering.controller.transform.InitialAttributeValueOperationContextAttachment"}, {"methodBody": ["METHOD_START", "{", "return   address . append ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["keyFor"], "fileName": "org.jboss.as.clustering.controller.transform.InitialAttributeValueOperationContextAttachment"}, {"methodBody": ["METHOD_START", "{", "return   this . initialValues . putIfAbsent ( InitialAttributeValueOperationContextAttachment . keyFor ( address ,    attributeName )  ,    initialValue . clone (  )  )  ;", "}", "METHOD_END"], "methodName": ["putIfAbsentInitialValue"], "fileName": "org.jboss.as.clustering.controller.transform.InitialAttributeValueOperationContextAttachment"}, {"methodBody": ["METHOD_START", "{", "if    ( properties . isDefined (  )  )     {", "for    ( final   Property   property    :    properties . asPropertyList (  )  )     {", "String   key    =    property . getName (  )  ;", "ModelNode   value    =    property . getValue (  )  ;", "Resource   p    =    Factory . create (  )  ;", "p . getModel (  )  . get ( ModelDescriptionConstants . VALUE )  . set ( value )  ;", "PathAddress   absoluteAddress    =    address . append ( ModelDescriptionConstants . PROPERTY ,    key )  ;", "parentContext . addTransformedResourceFromRoot ( absoluteAddress ,    p )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["transformPropertiesToChildrenResources"], "fileName": "org.jboss.as.clustering.controller.transform.LegacyPropertyResourceTransformer"}, {"methodBody": ["METHOD_START", "{", "return   this . addAttributes ( EnumSet . allOf ( enumClass )  )  ;", "}", "METHOD_END"], "methodName": ["addAttributes"], "fileName": "org.jboss.as.clustering.controller.transform.SimpleAddOperationTransformer"}, {"methodBody": ["METHOD_START", "{", "this . attributes . addAll ( attributes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAttributes"], "fileName": "org.jboss.as.clustering.controller.transform.SimpleAddOperationTransformer"}, {"methodBody": ["METHOD_START", "{", "return   this . addAttributes ( Arrays . asList ( attributes )  )  ;", "}", "METHOD_END"], "methodName": ["addAttributes"], "fileName": "org.jboss.as.clustering.controller.transform.SimpleAddOperationTransformer"}, {"methodBody": ["METHOD_START", "{", "this . lowerBound    =    new   DoubleRangeValidatorBuilder . Bound ( value ,    false )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["lowerBound"], "fileName": "org.jboss.as.clustering.controller.validation.DoubleRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "this . lowerBound    =    new   DoubleRangeValidatorBuilder . Bound ( value ,    true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["lowerBoundExclusive"], "fileName": "org.jboss.as.clustering.controller.validation.DoubleRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "this . upperBound    =    new   DoubleRangeValidatorBuilder . Bound ( value ,    false )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["upperBound"], "fileName": "org.jboss.as.clustering.controller.validation.DoubleRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "this . upperBound    =    new   DoubleRangeValidatorBuilder . Bound ( value ,    true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["upperBoundExclusive"], "fileName": "org.jboss.as.clustering.controller.validation.DoubleRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "validatoeParameter (  \" test \"  ,    value )  ;", "return   true ;", "}    catch    ( OperationFailedException   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.jboss.as.clustering.controller.validation.DoubleRangeValidatorTestCase"}, {"methodBody": ["METHOD_START", "{", "int   lower    =     0  ;", "ParameterValidator   validator    =    new   DoubleRangeValidatorBuilder (  )  . lowerBoundExclusive ( lower )  . build (  )  ;", "assertFalse (  . isValid ( validator ,    new   ModelNode (  0  )  )  )  ;", "assertTrue (  . isValid ( validator ,    new   ModelNode (  0  .  1  )  )  )  ;", "assertTrue (  . isValid ( validator ,    new   ModelNode ( Double . MAX _ VALUE )  )  )  ;", "int   upper    =     1  ;", "validator    =    new   DoubleRangeValidatorBuilder (  )  . upperBoundExclusive ( upper )  . build (  )  ;", "assertTrue (  . isValid ( validator ,    new   ModelNode ( Double . MIN _ VALUE )  )  )  ;", "assertTrue (  . isValid ( validator ,    new   ModelNode (  0  .  9  9  )  )  )  ;", "assertFalse (  . isValid ( validator ,    new   ModelNode (  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testExclusive"], "fileName": "org.jboss.as.clustering.controller.validation.DoubleRangeValidatorTestCase"}, {"methodBody": ["METHOD_START", "{", "ParameterValidator   validator    =    new   DoubleRangeValidatorBuilder (  )  . lowerBound ( Float . MIN _ VALUE )  . upperBound ( Float . MAX _ VALUE )  . build (  )  ;", "assertFalse (  . isValid ( validator ,    new   ModelNode ( Double . MAX _ VALUE )  )  )  ;", "assertFalse (  . isValid ( validator ,    new   ModelNode ( Double . MIN _ VALUE )  )  )  ;", "assertTrue (  . isValid ( validator ,    new   ModelNode ( Float . MAX _ VALUE )  )  )  ;", "assertTrue (  . isValid ( validator ,    new   ModelNode ( Float . MIN _ VALUE )  )  )  ;", "}", "METHOD_END"], "methodName": ["testFloat"], "fileName": "org.jboss.as.clustering.controller.validation.DoubleRangeValidatorTestCase"}, {"methodBody": ["METHOD_START", "{", "this . max    =    max ;", "return   this ;", "}", "METHOD_END"], "methodName": ["max"], "fileName": "org.jboss.as.clustering.controller.validation.IntRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "this . min    =    min ;", "return   this ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "org.jboss.as.clustering.controller.validation.IntRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "this . max    =    max ;", "return   this ;", "}", "METHOD_END"], "methodName": ["max"], "fileName": "org.jboss.as.clustering.controller.validation.LongRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "this . min    =    min ;", "return   this ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "org.jboss.as.clustering.controller.validation.LongRangeValidatorBuilder"}, {"methodBody": ["METHOD_START", "{", "return   Enum . valueOf ( targetClass ,    value . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["asEnum"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   Double . valueOf ( value . asDouble (  )  )  . floatValue (  )  ;", "}", "METHOD_END"], "methodName": ["asFloat"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    Optional . of ( value . asBoolean (  )  )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalBoolean"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    OptionalDouble . of ( value . asDouble (  )  )     :    OptionalDouble . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalDouble"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    Optional . of ( ModelNodes . asEnum ( value ,    targetClass )  )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalEnum"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    Optional . of ( ModelNodes . asFloat ( value )  )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalFloat"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    OptionalInt . of ( value . asInt (  )  )     :    OptionalInt . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalInt"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    Optional . of ( value . asList (  )  )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalList"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    OptionalLong . of ( value . asInt (  )  )     :    OptionalLong . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalLong"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    Optional . of ( value . asProperty (  )  )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalProperty"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    Optional . of ( value . asPropertyList (  )  )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalPropertyList"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   value . isDefined (  )     ?    Optional . of ( value . asString (  )  )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["optionalString"], "fileName": "org.jboss.as.clustering.dmr.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return    (    value )     -  >     {", "try    {", "value . close (  )  ;", "}    catch    ( Throwable   e )     {", "CLogger . ROOT _ LOGGER . failedToClose ( e ,    value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.jboss.as.clustering.function.Consumers"}, {"methodBody": ["METHOD_START", "{", "return    (    value )     -  >    value ;", "}", "METHOD_END"], "methodName": ["identity"], "fileName": "org.jboss.as.clustering.function.Functions"}, {"methodBody": ["METHOD_START", "{", "return   Predicates . when ( true )  ;", "}", "METHOD_END"], "methodName": ["always"], "fileName": "org.jboss.as.clustering.function.Predicates"}, {"methodBody": ["METHOD_START", "{", "return   Predicates . when ( false )  ;", "}", "METHOD_END"], "methodName": ["never"], "fileName": "org.jboss.as.clustering.function.Predicates"}, {"methodBody": ["METHOD_START", "{", "return    (    test )     -  >    test    =  =    object ;", "}", "METHOD_END"], "methodName": ["same"], "fileName": "org.jboss.as.clustering.function.Predicates"}, {"methodBody": ["METHOD_START", "{", "return    (    test )     -  >    condition ;", "}", "METHOD_END"], "methodName": ["when"], "fileName": "org.jboss.as.clustering.function.Predicates"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.jboss.as.clustering.infinispan.DataSourceConnectionFactoryConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . dependency    =    dependency ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDataSourceDependency"], "fileName": "org.jboss.as.clustering.infinispan.DataSourceConnectionFactoryConfigurationBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCache ( this ,    this . batcherFactory ,    cache . getAdvancedCache (  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainer"}, {"methodBody": ["METHOD_START", "{", "Object   listener    =    new   Object (  )  ;", "this . subject . addListener ( listener )  ;", "verify ( this . manager )  . addListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "reset ( this . manager )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "ConfigurationBuilder   builder    =    new   ConfigurationBuilder (  )  ;", "Configuration   config    =    builder . build (  )  ;", "when ( this . manager . definfiguration (  \" other \"  ,    config )  )  . thenReturn ( config )  ;", "Configuration   result    =    this . subject . definfiguration (  \" other \"  ,    config )  ;", "assertSame ( config ,    result )  ;", "}", "METHOD_END"], "methodName": ["defineConfiguration"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Address   expected    =    mock ( Address . class )  ;", "when ( this . manager . getAddress (  )  )  . thenReturn ( expected )  ;", "Address   result    =    this . subject . getAddress (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "AdvancedCache < Object ,    Object >    cache    =    mock ( AdvancedCache . class )  ;", "when ( this . manager . ge (  \" other \"  )  )  . thenReturn ( cache )  ;", "when ( cache . getAdvancedCache (  )  )  . thenReturn ( cache )  ;", "Cache < Object ,    Object >    result    =    this . subject . ge (  \" other \"  )  ;", "assertNotSame ( cache ,    result )  ;", "assertEquals ( result ,    cache )  ;", "assertSame ( this . subject ,    result . geManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   config    =    new   ConfigurationBuilder (  )  . build (  )  ;", "when ( this . manager . gefiguration (  \" cache \"  )  )  . thenReturn ( config )  ;", "Configuration   result    =    this . subject . gefiguration (  \" cache \"  )  ;", "assertSame ( config ,    result )  ;", "}", "METHOD_END"], "methodName": ["getCacheConfiguration"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "AdvancedCache < Object ,    Object >    cache    =    mock ( AdvancedCache . class )  ;", "String   templateName    =     \" template \"  ;", "when ( this . manager . ge (  \" other \"  ,    templateName )  )  . thenReturn ( cache )  ;", "when ( cache . getAdvancedCache (  )  )  . thenReturn ( cache )  ;", "Cache < Object ,    Object >    result    =    this . subject . ge (  \" other \"  ,    templateName )  ;", "assertNotSame ( cache ,    result )  ;", "assertEquals ( result ,    cache )  ;", "assertSame ( this . subject ,    result . geManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheFromTemplate"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "GlobalConfiguration   global    =    new   GlobalConfigurationBuilder (  )  . build (  )  ;", "when ( this . manager . geManagerConfiguration (  )  )  . thenReturn ( global )  ;", "GlobalConfiguration   result    =    this . subject . geManagerConfiguration (  )  ;", "assertSame ( global ,    result )  ;", "}", "METHOD_END"], "methodName": ["getCacheManagerConfiguration"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Set < String >    caches    =    Collections . singleton (  \" other \"  )  ;", "when ( this . manager . geNames (  )  )  . thenReturn ( caches )  ;", "Set < String >    result    =    this . subject . geNames (  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "assertTrue ( result . contains (  \" other \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheNames"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" cluster \"  ;", "when ( this . manager . getClusterName (  )  )  . thenReturn ( expected )  ;", "String   result    =    this . subject . getClusterName (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getClusterName"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Address   expected    =    mock ( Address . class )  ;", "when ( this . manager . getCoordinator (  )  )  . thenReturn ( expected )  ;", "Address   result    =    this . subject . getCoordinator (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getCoordinator"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "AdvancedCache < Object ,    Object >    cache    =    mock ( AdvancedCache . class )  ;", "when ( this . manager . ge (  )  )  . thenReturn ( cache )  ;", "when ( cache . getAdvancedCache (  )  )  . thenReturn ( cache )  ;", "Cache < Object ,    Object >    result    =    this . subject . ge (  )  ;", "assertNotSame ( cache ,    result )  ;", "assertEquals ( result ,    cache )  ;", "assertSame ( this . subject ,    result . geManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCache"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   config    =    new   ConfigurationBuilder (  )  . build (  )  ;", "when ( this . manager . getfiguration (  )  )  . thenReturn ( config )  ;", "Configuration   result    =    this . subject . getfiguration (  )  ;", "assertSame ( config ,    result )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCacheConfiguration"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   defaultCache    =     \" default \"  ;", "GlobalConfiguration   global    =    new   GlobalConfigurationBuilder (  )  . defaultCacheName ( defaultCache )  . build (  )  ;", "when ( this . manager . getCacheManagerConfiguration (  )  )  . thenReturn ( global )  ;", "assertSame ( defaultCache ,    this . subject . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCacheName"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Set < Object >    expected    =    Collections . singleton ( new   Object (  )  )  ;", "when ( this . manager . getListeners (  )  )  . thenReturn ( expected )  ;", "Set < Object >    result    =    this . subject . getListeners (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getListeners"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "List < Address >    expected    =    Collections . singletonList ( mock ( Address . class )  )  ;", "when ( this . manager . getMembers (  )  )  . thenReturn ( expected )  ;", "List < Address >    result    =    this . subject . getMembers (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getMembers"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "GlobalConfiguration   global    =    new   GlobalConfigurationBuilder (  )  . globalJmxStatistics (  )  . cacheManagerName ( name )  . build (  )  ;", "when ( this . manager . geManagerConfiguration (  )  )  . thenReturn ( global )  ;", "assertSame ( name ,    this . subject . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "ComponentStatus   expected    =    ComponentStatus . INITIALIZING ;", "when ( this . manager . getStatus (  )  )  . thenReturn ( expected )  ;", "ComponentStatus   res    =    this . subject . getStatus (  )  ;", "assertSame ( expected ,    res )  ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . manager . isDefaultRunning (  )  )  . thenReturn ( true )  ;", "boolean   result    =    this . subject . isDefaultRunning (  )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["isDefaultRunning"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . manager . isRunning (  \" other \"  )  )  . thenReturn ( true )  ;", "boolean   result    =    this . subject . isRunning (  \" other \"  )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["isRunning"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Object   listener    =    new   Object (  )  ;", "this . subject . removeListener ( listener )  ;", "verify ( this . manager )  . removeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . subject . start (  )  ;", "vfy ( this . manager ,    never (  )  )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . manager . startCaches (  \" other \"  )  )  . thenReturn ( this . manager )  ;", "EmbeddedCacheManager   result    =    this . subject . startCaches (  \" other \"  )  ;", "assertSame ( this . subject ,    result )  ;", "}", "METHOD_END"], "methodName": ["startCaches"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . subject . stop (  )  ;", "vfy ( this . manager ,    never (  )  )  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . subject . undefineConfiguration (  \" test \"  )  ;", "verify ( this . manager )  . undefineConfiguration (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["undefineConfiguration"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheContainerTestCase"}, {"methodBody": ["METHOD_START", "{", "Batcher < TransactionBatch >    batcher    =    mock ( Batcher . class )  ;", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", "when ( this . batcherFactory . createBatcher ( this . cache )  )  . thenReturn ( batcher )  ;", "AdvancedCache < Object ,    Object >    subject    =    new    ( this . manager ,    this . batcherFactory ,    this . cache )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "boolean   started    =    subject . startBatch (  )  ;", "assertTrue ( started )  ;", "started    =    subject . startBatch (  )  ;", "assertFalse ( started )  ;", "subject . endBatch ( true )  ;", "verify ( batch ,    never (  )  )  . discard (  )  ;", "verify ( batch )  . close (  )  ;", "reset ( batch )  ;", "subject . endBatch ( true )  ;", "verify ( batch ,    never (  )  )  . close (  )  ;", "verify ( batch ,    never (  )  )  . discard (  )  ;", "started    =    subject . startBatch (  )  ;", "assertTrue ( started )  ;", "subject . endBatch ( false )  ;", "verify ( batch )  . discard (  )  ;", "verify ( batch )  . close (  )  ;", "reset ( batch )  ;", "subject . endBatch ( true )  ;", "verify ( batch ,    never (  )  )  . close (  )  ;", "verify ( batch ,    never (  )  )  . discard (  )  ;", "}", "METHOD_END"], "methodName": ["batcher"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheTestCase"}, {"methodBody": ["METHOD_START", "{", "reset ( this . manager ,    this . batcherFactory ,    this . cache )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . batcherFactory . createBatcher ( this . cache )  )  . thenReturn ( null )  ;", "AdvancedCache < Object ,    Object >    subject    =    new    ( this . manager ,    this . batcherFactory ,    this . cache )  ;", "boolean   started    =    subject . startBatch (  )  ;", "assertFalse ( started )  ;", "verify ( this . cache ,    never (  )  )  . startBatch (  )  ;", "subject . endBatch ( false )  ;", "verify ( this . cache ,    never (  )  )  . endBatch ( false )  ;", "}", "METHOD_END"], "methodName": ["noBatcher"], "fileName": "org.jboss.as.clustering.infinispan.DefaultCacheTestCase"}, {"methodBody": ["METHOD_START", "{", "AdvancedCache < Object ,    Object >    cache    =    mock ( AdvancedCache . class )  ;", "Configuration   configuration    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( NON _ TRANSACTIONAL )  . build (  )  ;", "when ( cache . getAdvancedCache (  )  )  . thenReturn ( cache )  ;", "when ( cache . getCacheConfiguration (  )  )  . thenReturn ( configuration )  ;", "< TransactionBatch >    batcher    =    this . factory . create ( cache )  ;", "assertNull ( batcher )  ;", "}", "METHOD_END"], "methodName": ["nonTransactional"], "fileName": "org.jboss.as.clustering.infinispan.InfinispanBatcherFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "AdvancedCache < Object ,    Object >    cache    =    mock ( AdvancedCache . class )  ;", "Configuration   configuration    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( TRANSACTIONAL )  . build (  )  ;", "when ( cache . getAdvancedCache (  )  )  . thenReturn ( cache )  ;", "when ( cache . getCacheConfiguration (  )  )  . thenReturn ( configuration )  ;", "< TransactionBatch >    batcher    =    this . factory . create ( cache )  ;", "assertNotNull ( batcher )  ;", "}", "METHOD_END"], "methodName": ["transactional"], "fileName": "org.jboss.as.clustering.infinispan.InfinispanBatcherFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . addChildRedirection (  . PATH ,     . LEGACY _ PATH )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.BackupForResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.BackupResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" backup \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.BackupResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "PathAddressTransformer   addressTransformer    =    new   PathAddressTransformer (  )     {", "@ Override", "public   PathAddress   transform ( PathElement   current ,    Builder   builder )     {", "return   builder . next (  )  ;", "}", "}  ;", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection (  . PATH ,    addressTransformer ,    RequiredChildResourceDiscardPolicy . REJECT _ AND _ WARN )     :    parent . addChildResource (  . PATH )  ;", "BackupResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.BackupsResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( BinaryKeyedJDBCStoreResourceDefinition . PATH ,    BinaryKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( BinaryKeyedJDBCStoreResourceDefinition . PATH )  ;", "JDBCStoreResourceDefinition . buildTransformation ( version ,    builder ,    BinaryKeyedJDBCStoreResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . setCustomResourceTransformer ( new   ResourceTransformer (  )     {", "@ SuppressWarnings (  \" deprecation \"  )", "@ Override", "public   void   transformResource ( ResourceTransformationContext   context ,    PathAddress   address ,    Resource   resource )    throws   OperationFailedException    {", "final   ModelNode   model    =    resource . getModel (  )  ;", "final   ModelNode   maxBatchSize    =    model . remove ( StoreResourceDefinition . Attribute . MAX _ BATCH _ SIZE . getName (  )  )  ;", "final   ModelNode   binaryTableModel    =    Tools . readModel ( resource . removeChild ( BinaryTableResourceDefinition . PATH )  )  ;", "if    (  ( binaryTableModel    !  =    null )     &  &     ( binaryTableModel . isDefined (  )  )  )     {", "model . get ( BinaryKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE . getName (  )  )  . set ( binaryTableModel )  ;", "model . get ( BinaryKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE . getName (  )  )  . get ( TableResourceDefinition . DeprecatedAttribute . BATCH _ SIZE . getName (  )  )  . set (  ( maxBatchSize    !  =    null    ?    maxBatchSize    :    new   ModelNode (  )  )  )  ;", "}", "final   ModelNode   properties    =    model . remove ( StoreResourceDefinition . Attribute . PROPERTIES . getName (  )  )  ;", "final   ResourceTransformationContext   childContext    =    context . addTransformedResource ( EMPTY _ ADDRESS ,    resource )  ;", "LegacyPropertyResourceTransformer . transformPropertiesToChildrenResources ( properties ,    address ,    childContext )  ;", "context . processChildren ( resource )  ;", "}", "}  )  ;", "}", "BinaryTableResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.BinaryKeyedJDBCStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . rejectChildResource (  . PATH )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.BinaryMemoryResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( BinaryTableResourceDefinition . PATH )  ;", "TableResourceDefinition . buildTransformation ( version ,    builder )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "OperationTransformer   addTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   storeAddress    =    Operations . getPathAddress ( operation )  . getParent (  )  ;", "ModelNode   value    =    new   ModelNode (  )  ;", "for    ( Class <  ?    extends   Attribute >    attributeClass    :    Arrays . asList ( BinaryTableResourceDefinition . Attribute . class ,    TableResourceDefinition . Attribute . class ,    TableResourceDefinition . ColumnAttribute . class )  )     {", "for    ( Attribute   attribute    :    attributeClass . getEnumConstants (  )  )     {", "String   name    =    attribute . getName (  )  ;", "if    ( operation . hasDefined ( name )  )     {", "value . get ( name )  . set ( operation . get ( name )  )  ;", "}", "}", "}", "return   value . isDefined (  )     ?    Operations . createWriteAttributeOperation ( storeAddress ,    BinaryKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE ,    value )     :    Operations . createUndefineAttributeOperation ( storeAddress ,    BinaryKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE )  ;", "}", "}  ;", "builder . addRawOperationTransformationOverride ( ADD ,    new   SimpleOperationTransformer ( addTransformer )  )  ;", "OperationTransformer   removeTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   storeAddress    =    Operations . getPathAddress ( operation )  . getParent (  )  ;", "return   Operations . createUndefineAttributeOperation ( storeAddress ,    BinaryKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE )  ;", "}", "}  ;", "builder . addRawOperationTransformationOverride ( REMOVE ,    new   SimpleOperationTransformer ( removeTransformer )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.BinaryTableResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "InfinispanLogger . ROOT _ LOGGER . cacheStarted ( event . getCacheName (  )  ,    this . name )  ;", "}", "METHOD_END"], "methodName": ["cacheStarted"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheContainerBuilder"}, {"methodBody": ["METHOD_START", "{", "InfinispanLogger . ROOT _ LOGGER . cacheStopped ( event . getCacheName (  )  ,    this . name )  ;", "}", "METHOD_END"], "methodName": ["cacheStopped"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheContainerBuilder"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( CacheContainerResourceDefinition . WILDCARD _ PATH )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . discardChildResource ( NoTransportResourceDefinition . PATH )  ;", "for    ( ThreadPoolResourceDefinition   pool    :    EnumSet . allOf ( ThreadPoolResourceDefinition . class )  )     {", "builder . addChildResource ( pool . getPathElement (  )  ,    pool . getDiscardPolicy (  )  )  ;", "}", "for    ( ScheduledThreadPoolResourceDefinition   pool    :    EnumSet . allOf ( ScheduledThreadPoolResourceDefinition . class )  )     {", "builder . addChildResource ( pool . getPathElement (  )  ,    pool . getDiscardPolicy (  )  )  ;", "}", "} else    {", "NoTransportResourceDefinition . buildTransformation ( version ,    builder )  ;", "for    ( ThreadPoolResourceDefinition   pool    :    EnumSet . allOf ( ThreadPoolResourceDefinition . class )  )     {", "pool . buildTransformation ( version ,    parent )  ;", "}", "for    ( ScheduledThreadPoolResourceDefinition   pool    :    EnumSet . allOf ( ScheduledThreadPoolResourceDefinition . class )  )     {", "pool . buildTransformation ( version ,    parent )  ;", "}", "}", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "OperationTransformer   addAliasTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "String   attributeName    =    Operations . getAttributeName ( operation )  ;", "if    ( CacheContainerResourceDefinition . Attribute . ALIASES . getName (  )  . equals ( attributeName )  )     {", "ModelNode   value    =    Operations . getAttributeValue ( operation )  ;", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "ModelNode   transformedOperation    =    Util . createOperation ( CacheContainerResourceDefinition . ALIAS _ ADD ,    address )  ;", "transformedOperation . get ( CacheContainerResourceDefinition . ALIAS . getName (  )  )  . set ( value )  ;", "return   transformedOperation ;", "}", "return   operation ;", "}", "}  ;", "builder . addRawOperationTransformationOverride ( LIST _ ADD _ DEFINITION . getName (  )  ,    new   SimpleOperationTransformer ( addAliasTransformer )  )  ;", "OperationTransformer   removeAliasTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "String   attributeName    =    Operations . getAttributeName ( operation )  ;", "if    ( CacheContainerResourceDefinition . Attribute . ALIASES . getName (  )  . equals ( attributeName )  )     {", "ModelNode   value    =    Operations . getAttributeValue ( operation )  ;", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "ModelNode   transformedOperation    =    Util . createOperation ( CacheContainerResourceDefinition . ALIAS _ REMOVE ,    address )  ;", "transformedOperation . get ( CacheContainerResourceDefinition . ALIAS . getName (  )  )  . set ( value )  ;", "return   transformedOperation ;", "}", "return   operation ;", "}", "}  ;", "builder . addRawOperationTransformationOverride ( LIST _ REMOVE _ DEFINITION . getName (  )  ,    new   SimpleOperationTransformer ( removeAliasTransformer )  )  ;", "}", "JGroupsTransportResourceDefinition . buildTransformation ( version ,    builder )  ;", "DistributedCacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "ReplicatedCacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "InvalidationCacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "LocalCacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheContainerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheContainerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" cache - container \"  ,    containerName )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheContainerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   context . readResourceFromRoot ( PathAddrepathAddrepath )  ,    false )  ;", "}    catch    ( RuntimeException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["safeGetResource"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheContainerServiceHandler"}, {"methodBody": ["METHOD_START", "{", "return   cache . getAdvancedCache (  )  . getAsyncInterceptorChain (  )  . findInterceptorExtending ( interceptorClass )  ;", "}", "METHOD_END"], "methodName": ["findInterceptor"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheMetric"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . discardChildResource ( NoStoreResourceDefinition . PATH )  ;", "} else    {", "NoStoreResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "ResourceTransformer   batchingTransformer    =    new   ResourceTransformer (  )     {", "@ Override", "public   void   transformResource ( ResourceTransformationContext   context ,    PathAddress   address ,    Resource   resource )    throws   OperationFailedException    {", "PathAddress   transactionAddress    =    address . append ( TransactionResourceDefinition . PATH )  ;", "try    {", "ModelNode   transaction    =    context . readResourceFromRoot ( transactionAddress )  . getModel (  )  ;", "if    ( transaction . hasDefined ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  )     {", "ModelNode   mode    =    transaction . get ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  ;", "if    (  (  ( mode . getType (  )  )     =  =     ( ModelType . STRING )  )     &  &     (  ( TransactionMode . valueOf ( mode . asString (  )  )  )     =  =     ( TransactionMode . BATCH )  )  )     {", "resource . getModel (  )  . get (  . DeprecatedAttribute . BATCHING . getName (  )  )  . set ( true )  ;", "}", "}", "}    catch    ( NoSuchElementException   e )     {", "}", "context . addTransformedResource ( EMPTY _ ADDRESS ,    resource )  . processChildren ( resource )  ;", "}", "}  ;", "builder . setCustomResourceTransformer ( batchingTransformer )  ;", "}", "BinaryMemoryResourceDefinition . buildTransformation ( version ,    builder )  ;", "ObjectMemoryResourceDefinition . buildTransformation ( version ,    builder )  ;", "OffHeapMemoryResourceDefinition . buildTransformation ( version ,    builder )  ;", "LockingResourceDefinition . buildTransformation ( version ,    builder )  ;", "ExpirationResourceDefinition . buildTransformation ( version ,    builder )  ;", "TransactionResourceDefinition . buildTransformation ( version ,    builder )  ;", "FileStoreResourceDefinition . buildTransformation ( version ,    builder )  ;", "BinaryKeyedJDBCStoreResourceDefinition . buildTransformation ( version ,    builder )  ;", "MixedKeyedJDBCStoreResourceDefinition . buildTransformation ( version ,    builder )  ;", "StringKeyedJDBCStoreResourceDefinition . buildTransformation ( version ,    builder )  ;", "RemoteStoreResourceDefinition . buildTransformation ( version ,    builder )  ;", "CustomStoreResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( Factory . createHardCoded ( new   ModelNode ( Mode . SYNC . name (  )  )  )  ,     . DeprecatedAttribute . MODE . getDefinition (  )  )  . end (  )  ;", "}", "if    ( InfinispanModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter (  . Attribute . REMOTE _ TIMEOUT . getDefinition (  )  )  ,     . Attribute . REMOTE _ TIMEOUT . getDefinition (  )  )  . end (  )  ;", "}", "CacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ClusteredCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired (  ( defaultValue    =  =    null )  )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ClusteredCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" component \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ComponentResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( CustomStoreResourceDefinition . PATH ,    CustomStoreResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( CustomStoreResourceDefinition . PATH )  ;", "StoreResourceDefinition . buildTransformation ( version ,    builder ,    CustomStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.CustomStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( DistributedCacheResourceDefinition . WILDCARD _ PATH )  ;", "if    ( InfinispanModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( DistributedCacheResourceDefinition . Attribute . L 1  _ LIFESPAN . getDefinition (  )  )  ,    DistributedCacheResourceDefinition . Attribute . L 1  _ LIFESPAN . getDefinition (  )  )  . end (  )  ;", "}", "if    ( InfinispanModel . VERSION _  4  _  1  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( DistributedCacheResourceDefinition . Attribute . CONSISTENT _ HASH _ STRATEGY . getDefinition (  )  )  ,    DistributedCacheResourceDefinition . Attribute . CONSISTENT _ HASH _ STRATEGY . getDefinition (  )  )  . setValueConverter ( new   DefaultValueAttributeConverter ( DistributedCacheResourceDefinition . Attribute . SEGMENTS . getDefinition (  )  )  ,    DistributedCacheResourceDefinition . Attribute . SEGMENTS . getDefinition (  )  )  . end (  )  ;", "}", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( DistributedCacheResourceDefinition . Attribute . CAPACITY _ FACTOR . getDefinition (  )  . getDefaultValue (  )  )  ,    DistributedCacheResourceDefinition . Attribute . CAPACITY _ FACTOR . getDefinition (  )  )  . addRejectCheck ( DEFINED ,    DistributedCacheResourceDefinition . Attribute . CAPACITY _ FACTOR . getDefinition (  )  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( ConsistentHashStrategy . INTRA _ CACHE . name (  )  )  )  ,    DistributedCacheResourceDefinition . Attribute . CONSISTENT _ HASH _ STRATEGY . getDefinition (  )  )  . addRejectCheck ( DEFINED ,    DistributedCacheResourceDefinition . Attribute . CONSISTENT _ HASH _ STRATEGY . getDefinition (  )  )  . end (  )  ;", "}", "SharedStateCacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.DistributedCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" distributed - cache \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.DistributedCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . addChildRedirection (  . PATH ,     . LEGACY _ PATH ,    RequiredChildResourceDiscardPolicy . NEVER )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ExpirationResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( FileStoreResourceDefinition . PATH ,    FileStoreResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( FileStoreResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,    FileStoreResourceDefinition . Attribute . RELATIVE _ TO . getName (  )  )  ;", "}", "StoreResourceDefinition . buildTransformation ( version ,    builder ,    FileStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.FileStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . bindInfoFor ( JndiNameFactory . createJndiName ( JndiNameFactory . DEFAULT _ JNDI _ NAMESPACE ,    InfinispanExtension . SUBSYSTEM _ NAME ,     \" cache \"  ,    containerName ,    cacheName )  . getAbsoluteName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCacheBinding"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanBindingFactory"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . bindInfoFor ( JndiNameFactory . createJndiName ( JndiNameFactory . DEFAULT _ JNDI _ NAMESPACE ,    InfinispanExtension . SUBSYSTEM _ NAME ,     \" configuration \"  ,    containerName ,    cacheName )  . getAbsoluteName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCacheConfigurationBinding"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanBindingFactory"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . bindInfoFor ( JndiNameFactory . createJndiName ( JndiNameFactory . DEFAULT _ JNDI _ NAMESPACE ,    InfinispanExtension . SUBSYSTEM _ NAME ,     \" container \"  ,    containerName )  . getAbsoluteName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCacheContainerBinding"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanBindingFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . schema . since ( InfinispanSchema . VERSION _  1  _  5  )  )  )     {", "ModelNode   model    =    services . readWholeModel (  )  ;", "Assert . assertTrue ( model . get ( ResourceDefinition . PATH . getKey (  )  )  . hasDefined ( ResourceDefinition . PATH . getValue (  )  )  )  ;", "ModelNode   subsystem    =    model . get ( ResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "for    ( Property   containerProp    :    subsystem . get ( CacheContainerResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . asPropertyList (  )  )     {", "Assert . assertTrue (  (  \" cache - container =  \"     +     ( containerProp . getName (  )  )  )  ,    containerProp . getValue (  )  . get ( CacheContainerResourceDefinition . Attribute . STATISTICS _ ENABLED . getName (  )  )  . asBoolean (  )  )  ;", "for    ( String   key    :    containerProp . getValue (  )  . keys (  )  )     {", "if    (  ( key . endsWith (  \"  - cache \"  )  )     &  &     (  !  ( key . equals (  \" default - cache \"  )  )  )  )     {", "ModelNode   caches    =    containerProp . getValue (  )  . get ( key )  ;", "if    ( caches . isDefined (  )  )     {", "for    ( Property   cacheProp    :    caches . asPropertyList (  )  )     {", "Assert . assertTrue (  (  (  (  (  (  \" cache - container =  \"     +     ( containerProp . getName (  )  )  )     +     \"  ,  \"  )     +    key )     +     \"  =  \"  )     +     ( cacheProp . getName (  )  )  )  ,    containerProp . getValue (  )  . get ( CacheResourceDefinition . Attribute . STATISTICS _ ENABLED . getName (  )  )  . asBoolean (  )  )  ;", "}", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkLegacyParserStatisticsTrue"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "Object [  ]  [  ]    data    =    new   Object [  ]  [  ]  {    new   Object [  ]  {    InfinispanSchema . VERSION _  1  _  0  ,     3  3     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  1  _  1  ,     3  3     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  1  _  2  ,     3  7     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  1  _  3  ,     3  7     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  1  _  4  ,     3  7     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  1  _  5  ,     3  7     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  2  _  0  ,     4  1     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  3  _  0  ,     4  1     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  4  _  0  ,     5  0     }  ,    new   Object [  ]  {    InfinispanSchema . VERSION _  5  _  0  ,     4  9     }     }  ;", "return   Arrays . asList ( data )  ;", "}", "METHOD_END"], "methodName": ["data"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "model . get ( JGroupsSubsystemResourceDefinition . PATH . getKey (  )  )  . remove ( JGroupsSubsystemResourceDefinition . PATH . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["purgeJGroupsModel"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    operations    =    this . parse ( this . createAdditionalInitialization (  )  ,    getSubsystemXml (  )  )  ;", "Assert . assertEquals ( operations . toString (  )  ,    this . operations ,    operations . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseSubsystem"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", "CacheContainer . buildTransformation ( version ,    builder )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "String   site    =    InfinispanSubsystemXMLReader . require ( reader ,    XMLAttribute . SITE )  ;", "PathAddress   address    =    backupsAddress . append ( BackupResourceDefinition . pathElement ( site )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   SITE    :", "{", "break ;", "}", "case   STRATEGY    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    BackupResourceDefinition . Attribute . STRATEGY )  ;", "break ;", "}", "case   BACKUP _ FAILURE _ POLICY    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    BackupResourceDefinition . Attribute . FAILURE _ POLICY )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    BackupResourceDefinition . Attribute . TIMEOUT )  ;", "break ;", "}", "case   ENABLED    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    BackupResourceDefinition . Attribute . ENABLED )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   TAKE _ OFFLINE    :", "{", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   TAKE _ OFFLINE _ AFTER _ FAILURES    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    BackupResourceDefinition . TakeOfflineAttribute . AFTER _ FAILURES )  ;", "break ;", "}", "case   TAKE _ OFFLINE _ MIN _ WAIT    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    BackupResourceDefinition . TakeOfflineAttribute . MIN _ WAIT )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBackup"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( BackupForResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   REMOTE _ CACHE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    BackupForResourceDefinition . Attribute . CACHE )  ;", "break ;", "}", "case   REMOTE _ SITE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    BackupForResourceDefinition . Attribute . SITE )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseBackupFor"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( BackupsResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "while    (  ( r . hasNext (  )  )     &  &     (  ( r . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( r . getLocalName (  )  )  ;", "switch    ( element )     {", "case   BACKUP    :", "{", "this . parseBackup ( r ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( r )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBackups"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( BinaryKeyedJDBCStoreResourceDefinition . PATH )  ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( r )  ;", "}", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( operationKey ,    operation )  ;", "this . parseJDBCStoreAttributes ( r ,    operation )  ;", "while    (  ( r . hasNext (  )  )     &  &     (  ( r . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( r . getLocalName (  )  )  ;", "switch    ( element )     {", "case   BINARY _ KEYED _ TABLE    :", "{", "this . parseJDBCStoreBinaryTable ( r ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "this . parseStoreElement ( r ,    address ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBinaryKeyedJDBCStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( BinaryMemoryResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( r . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseBinaryMemoryAttribute ( r ,    i ,    operation )  ;", "}", "ParseUtils . requireNoContent ( r )  ;", "}", "METHOD_END"], "methodName": ["parseBinaryMemory"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   EVICTION _ TYPE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    BinaryMemoryResourceDefinition . Attribute . EVICTION _ TYPE )  ;", "break ;", "}", "default    :", "{", "this . parseMemoryAttribute ( reader ,    index ,    operation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseBinaryMemoryAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "break ;", "}", "case   START    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "case   BATCHING    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "PathAddress   transactionAddress    =    address . append ( TransactionResourceDefinition . PATH )  ;", "ModelNode   transactionOperation    =    Util . createAddOperation ( transactionAddress )  ;", "transactionOperation . get ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  . set ( new   ModelNode ( TransactionMode . BATCH . name (  )  )  )  ;", "operations . put ( transactionAddress ,    transactionOperation )  ;", "break ;", "}", "case   INDEXING    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  4  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", ". readAttribute ( reader ,    index ,    operation ,    CacheResourceDefinition . DeprecatedAttribute . INDEXING )  ;", "break ;", "}", "case   JNDI _ NAME    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  5  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", ". readAttribute ( reader ,    index ,    operation ,    CacheResourceDefinition . DeprecatedAttribute . JNDI _ NAME )  ;", "break ;", "}", "}", "case   MODULE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  3  )  )     {", ". readAttribute ( reader ,    index ,    operation ,    CacheResourceDefinition . Attribute . MODULE )  ;", "break ;", "}", "}", "case   STATISTICS _ ENABLED    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  5  )  )     {", ". readAttribute ( reader ,    index ,    operation ,    CacheResourceDefinition . Attribute . STATISTICS _ ENABLED )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "}", "if    (  !  ( this . schema . since ( InfinispanSchema . VERSION _  1  _  5  )  )  )     {", "operation . get ( CacheResourceDefinition . Attribute . STATISTICS _ ENABLED . getName (  )  )  . set ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["parseCacheAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   EVICTION    :", "{", "if    ( this . schema . since ( chema . VERSION _  5  _  0  )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "this . parseEviction ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "case   EXPIRATION    :", "{", "this . parseExpiration ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "case   LOCKING    :", "{", "this . parseLocking ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "case   TRANSACTION    :", "{", "this . parseTransaction ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "case   STORE    :", "{", "this . parseCustomStore ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "case   FILE _ STORE    :", "{", "this . parseFileStore ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "case   REMOTE _ STORE    :", "{", "this . parseRemoteStore ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "case   JDBC _ STORE    :", "{", "if    (  ( this . schema . since ( chema . VERSION _  1  _  2  )  )     &  &     (  !  ( this . schema . since ( chema . VERSION _  5  _  0  )  )  )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( this . schema . since ( chema . VERSION _  5  _  0  )  )     {", "this . parseJDBCStore ( reader ,    cacheAddress ,    operations )  ;", "} else    {", "this . parseLegacyJDBCStore ( reader ,    cacheAddress ,    operations )  ;", "}", "break ;", "}", "case   STRING _ KEYED _ JDBC _ STORE    :", "{", "if    ( this . schema . since ( chema . VERSION _  5  _  0  )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( this . schema . since ( chema . VERSION _  1  _  2  )  )     {", "this . parseStringKeyedJDBCStore ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "}", "case   BINARY _ KEYED _ JDBC _ STORE    :", "{", "if    ( this . schema . since ( chema . VERSION _  1  _  2  )  )     {", "this . parseBinaryKeyedJDBCStore ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "}", "case   MIXED _ KEYED _ JDBC _ STORE    :", "{", "if    ( this . schema . since ( chema . VERSION _  1  _  2  )  )     {", "this . parseMixedKeyedJDBCStore ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "}", "case   INDEXING    :", "{", "if    (  ( this . schema . since ( chema . VERSION _  1  _  4  )  )     &  &     (  !  ( this . schema . since ( chema . VERSION _  4  _  0  )  )  )  )     {", "this . parseIndexing ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "}", "case   OBJECT _ MEMORY    :", "{", "if    ( this . schema . since ( chema . VERSION _  5  _  0  )  )     {", "this . parseObjectMemory ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "}", "case   BINARY _ MEMORY    :", "{", "if    ( this . schema . since ( chema . VERSION _  5  _  0  )  )     {", "this . parseBinaryMemory ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "}", "case   OFF _ HEAP _ MEMORY    :", "{", "if    ( this . schema . since ( chema . VERSION _  5  _  0  )  )     {", "this . parseOffHeapMemory ( reader ,    cacheAddress ,    operations )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseCacheElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   MODE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  5  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "break ;", "}", "case   QUEUE _ SIZE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    ClusteredCacheResourceDefinition . DeprecatedAttribute . QUEUE _ SIZE )  ;", "break ;", "}", "case   QUEUE _ FLUSH _ INTERVAL    :", "{", ". readAttribute ( reader ,    index ,    operation ,    ClusteredCacheResourceDefinition . DeprecatedAttribute . QUEUE _ FLUSH _ INTERVAL )  ;", "break ;", "}", "case   REMOTE _ TIMEOUT    :", "{", ". readAttribute ( reader ,    index ,    operation ,    ClusteredCacheResourceDefinition . Attribute . REMOTE _ TIMEOUT )  ;", "break ;", "}", "case   ASYNC _ MARSHALLING    :", "{", "if    (  (  !  ( this . schema . since ( InfinispanSchema . VERSION _  1  _  2  )  )  )     &  &     ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "default    :", "{", "this . parseCacheAttribute ( reader ,    index ,    address ,    operations )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseClusteredCacheAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    InfinispanSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    subsystemAddress . append ( CacheContainerResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "ParseUtils . requireNoNamespaceAttribute ( reader ,    i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "break ;", "}", "case   DEFAULT _ CACHE    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . Attribute . DEFAULT _ CACHE )  ;", "break ;", "}", "case   JNDI _ NAME    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  5  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . DeprecatedAttribute . JNDI _ NAME )  ;", "break ;", "}", "case   LISTENER _ EXECUTOR    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . ExecutorAttribute . LISTENER )  ;", "InfinispanLogger . ROOT _ LOGGER . executorIgnored ( CacheContainerResourceDefinition . ExecutorAttribute . LISTENER . getName (  )  )  ;", "break ;", "}", "case   EVICTION _ EXECUTOR    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . ExecutorAttribute . EVICTION )  ;", "InfinispanLogger . ROOT _ LOGGER . executorIgnored ( CacheContainerResourceDefinition . ExecutorAttribute . EVICTION . getName (  )  )  ;", "break ;", "}", "case   REPLICATION _ QUEUE _ EXECUTOR    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . ExecutorAttribute . REPLICATION _ QUEUE )  ;", "InfinispanLogger . ROOT _ LOGGER . executorIgnored ( CacheContainerResourceDefinition . ExecutorAttribute . REPLICATION _ QUEUE . getName (  )  )  ;", "break ;", "}", "case   START    :", "{", "if    (  ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     &  &     (  !  ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )  )  )     {", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "break ;", "}", "case   ALIASES    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . Attribute . ALIASES )  ;", "break ;", "}", "}", "case   MODULE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  3  )  )     {", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . Attribute . MODULE )  ;", "break ;", "}", "}", "case   STATISTICS _ ENABLED    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  5  )  )     {", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    CacheContainerResourceDefinition . Attribute . STATISTICS _ ENABLED )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    (  !  ( this . schema . since ( InfinispanSchema . VERSION _  1  _  5  )  )  )     {", "operation . get ( CacheContainerResourceDefinition . Attribute . STATISTICS _ ENABLED . getName (  )  )  . set ( true )  ;", "}", "List < String >    aliases    =    new   LinkedList <  >  (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ALIAS    :", "{", "if    ( InfinispanSchema . VERSION _  1  _  0  . since ( this . schema )  )     {", "aliases . add ( reader . getElementText (  )  )  ;", "break ;", "}", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "case   TRANSPORT    :", "{", "this . parseTransport ( reader ,    address ,    operations )  ;", "break ;", "}", "case   LOCAL _ CACHE    :", "{", "this . parseLocalCache ( reader ,    address ,    operations )  ;", "break ;", "}", "case   INVALIDATION _ CACHE    :", "{", "this . parseInvalidationCache ( reader ,    address ,    operations )  ;", "break ;", "}", "case   REPLICATED _ CACHE    :", "{", "this . parseReplicatedCache ( reader ,    address ,    operations )  ;", "break ;", "}", "case   DISTRIBUTED _ CACHE    :", "{", "this . parseDistributedCache ( reader ,    address ,    operations )  ;", "break ;", "}", "case   EXPIRATION _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "this . parseScheduledThreadPool ( ScheduledThreadPoolResourceDefinition . EXPIRATION ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   ASYNC _ OPERATIONS _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . ASYNC _ OPERATIONS ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   LISTENER _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . LISTENER ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   PERSISTENCE _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . PERSISTENCE ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   REMOTE _ COMMAND _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . REMOTE _ COMMAND ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   STATE _ TRANSFER _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . STATE _ TRANSFER ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   TRANSPORT _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . TRANSPORT ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    (  !  ( aliases . isEmpty (  )  )  )     {", "InfinispanSubsystemXMLReader . setAttribute ( reader ,    String . join (  \"     \"  ,    aliases )  ,    operation ,    CacheContainerResourceDefinition . Attribute . ALIASES )  ;", "}", "}", "METHOD_END"], "methodName": ["parseContainer"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( CustomStoreResourceDefinition . PATH )  ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( operationKey ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   CLASS    :", "{", ". readAttribute ( reader ,    i ,    operation ,    CustomStoreResourceDefinition . Attribute . CLASS )  ;", "break ;", "}", "default    :", "{", "this . parseStoreAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "if    (  !  ( operation . hasDefined ( CustomStoreResourceDefinition . Attribute . CLASS . getName (  )  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( XMLAttribute . CLASS )  )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseStoreElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseCustomStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    InfinispanSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    containerAddress . append ( DistributedCacheResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   OWNERS    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    DistributedCacheResourceDefinition . Attribute . OWNERS )  ;", "break ;", "}", "case   L 1  _ LIFESPAN    :", "{", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    DistributedCacheResourceDefinition . Attribute . L 1  _ LIFESPAN )  ;", "break ;", "}", "case   VIRTUAL _ NODES    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  4  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "String   virtualNodes    =    InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    DistributedCacheResourceDefinition . Attribute . SEGMENTS )  . asString (  )  ;", "String   segments    =    SegmentsAndVirtualNodeConverter . virtualNodesToSegments ( virtualNodes )  ;", "InfinispanSubsystemXMLReader . setAttribute ( reader ,    segments ,    operation ,    DistributedCacheResourceDefinition . Attribute . SEGMENTS )  ;", "break ;", "}", "case   SEGMENTS    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  4  )  )     {", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    DistributedCacheResourceDefinition . Attribute . SEGMENTS )  ;", "break ;", "}", "}", "case   CAPACITY _ FACTOR    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )     {", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    DistributedCacheResourceDefinition . Attribute . CAPACITY _ FACTOR )  ;", "break ;", "}", "}", "case   CONSISTENT _ HASH _ STRATEGY    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )     {", "InfinispanSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    DistributedCacheResourceDefinition . Attribute . CONSISTENT _ HASH _ STRATEGY )  ;", "break ;", "}", "}", "default    :", "{", "this . parseClusteredCacheAttribute ( reader ,    i ,    address ,    operations )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "this . parseSharedStateCacheElement ( reader ,    address ,    operations )  ;", "} else    {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   REHASHING    :", "{", "this . parseStateTransfer ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "this . parseCacheElement ( reader ,    address ,    operations )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseDistributedCache"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( ObjectMemoryResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   STRATEGY    :", "{", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "case   MAX _ ENTRIES    :", "{", ". readAttribute ( reader ,    i ,    operation ,    ObjectMemoryResourceDefinition . DeprecatedAttribute . MAX _ ENTRIES )  ;", "break ;", "}", "case   INTERVAL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseEviction"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( ExpirationResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   MAX _ IDLE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    ExpirationResourceDefinition . Attribute . MAX _ IDLE )  ;", "break ;", "}", "case   LIFESPAN    :", "{", ". readAttribute ( reader ,    i ,    operation ,    ExpirationResourceDefinition . Attribute . LIFESPAN )  ;", "break ;", "}", "case   INTERVAL    :", "{", ". readAttribute ( reader ,    i ,    operation ,    ExpirationResourceDefinition . Attribute . INTERVAL )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseExpiration"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( FileStoreResourceDefinition . PATH )  ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( operationKey ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   RELATIVE _ TO    :", "{", ". readAttribute ( reader ,    i ,    operation ,    FileStoreResourceDefinition . Attribute . RELATIVE _ TO )  ;", "break ;", "}", "case   PATH    :", "{", ". readAttribute ( reader ,    i ,    operation ,    FileStoreResourceDefinition . Attribute . RELATIVE _ PATH )  ;", "break ;", "}", "default    :", "{", "this . parseStoreAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseStoreElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseFileStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( cacheAddress )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   INDEX    :", "{", ". readAttribute ( reader ,    i ,    operation ,    CacheResourceDefinition . DeprecatedAttribute . INDEXING )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "{", "ParseUtils . requireSingleAttribute ( reader ,    XMLAttribute . NAME . getLocalName (  )  )  ;", ". readElement ( reader ,    operation ,    CacheResourceDefinition . DeprecatedAttribute . INDEXING _ PROPERTIES )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseIndexing"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    InfinispanSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    containerAddress . append ( InvalidationCacheResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseClusteredCacheAttribute ( reader ,    i ,    address ,    operations )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseCacheElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseInvalidationCache"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( JDBCStoreResourceDefinition . PATH )  ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( r )  ;", "}", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( operationKey ,    operation )  ;", "this . parseJDBCStoreAttributes ( r ,    operation )  ;", "while    (  ( r . hasNext (  )  )     &  &     (  ( r . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( r . getLocalName (  )  )  ;", "switch    ( element )     {", "case   TABLE    :", "{", "this . parseJDBCStoreStringTable ( r ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "this . parseStoreElement ( r ,    address ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseJDBCStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   DATASOURCE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", ". readAttribute ( reader ,    i ,    operation ,    JDBCStoreResourceDefinition . DeprecatedAttribute . DATASOURCE )  ;", "break ;", "}", "case   DIALECT    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  2  _  0  )  )     {", ". readAttribute ( reader ,    i ,    operation ,    JDBCStoreResourceDefinition . Attribute . DIALECT )  ;", "break ;", "}", "}", "case   DATA _ SOURCE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", ". readAttribute ( reader ,    i ,    operation ,    JDBCStoreResourceDefinition . Attribute . DATA _ SOURCE )  ;", "break ;", "}", "}", "default    :", "{", "this . parseStoreAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "Attribute   requiredAttribute    =     ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     ?    JDBCStoreResourceDefinition . Attribute . DATA _ SOURCE    :    JDBCStoreResourceDefinition . DeprecatedAttribute . DATASOURCE ;", "if    (  !  ( operation . hasDefined ( requiredAttribute . getName (  )  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    requiredAttribute . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseJDBCStoreAttributes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    storeAddress . append ( BinaryTableResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( storeAddress . getParent (  )  . append ( StoreResourceDefinition . WILDCARD _ PATH )  . append ( BinaryTableResourceDefinition . PATH )  ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PREFIX    :", "{", ". readAttribute ( reader ,    i ,    operation ,    BinaryTableResourceDefinition . Attribute . PREFIX )  ;", "break ;", "}", "default    :", "{", "this . parseJDBCStoreTableAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "this . parseJDBCStoreTableElements ( reader ,    operation )  ;", "}", "METHOD_END"], "methodName": ["parseJDBCStoreBinaryTable"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", ". readAttribute ( reader ,    i ,    column ,    columnAttribute . getColumnName (  )  )  ;", "break ;", "}", "case   TYPE    :", "{", ". readAttribute ( reader ,    i ,    column ,    columnAttribute . getColumnType (  )  )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseJDBCStoreColumn"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    storeAddress . append ( StringTableResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( storeAddress . getParent (  )  . append ( StoreResourceDefinition . WILDCARD _ PATH )  . append ( StringTableResourceDefinition . PATH )  ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PREFIX    :", "{", ". readAttribute ( reader ,    i ,    operation ,    StringTableResourceDefinition . Attribute . PREFIX )  ;", "break ;", "}", "default    :", "{", "this . parseJDBCStoreTableAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "this . parseJDBCStoreTableElements ( reader ,    operation )  ;", "}", "METHOD_END"], "methodName": ["parseJDBCStoreStringTable"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   FETCH _ SIZE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    TableResourceDefinition . Attribute . FETCH _ SIZE )  ;", "break ;", "}", "case   BATCH _ SIZE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  5  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", ". readAttribute ( reader ,    index ,    operation ,    TableResourceDefinition . DeprecatedAttribute . BATCH _ SIZE )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseJDBCStoreTableAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ID _ COLUMN    :", "{", "this . parseJDBCStoreColumn ( reader ,    TableResourceDefinition . ColumnAttribute . ID ,    operation . get ( TableResourceDefinition . ColumnAttribute . ID . getName (  )  )  . setEmptyObject (  )  )  ;", "break ;", "}", "case   DATA _ COLUMN    :", "{", "this . parseJDBCStoreColumn ( reader ,    TableResourceDefinition . ColumnAttribute . DATA ,    operation . get ( TableResourceDefinition . ColumnAttribute . DATA . getName (  )  )  . setEmptyObject (  )  )  ;", "break ;", "}", "case   TIMESTAMP _ COLUMN    :", "{", "this . parseJDBCStoreColumn ( reader ,    TableResourceDefinition . ColumnAttribute . TIMESTAMP ,    operation . get ( TableResourceDefinition . ColumnAttribute . TIMESTAMP . getName (  )  )  . setEmptyObject (  )  )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseJDBCStoreTableElements"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    null ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( r )  ;", "}", "ModelNode   operation    =    Util . createAddOperation (  )  ;", "operations . put ( operationKey ,    operation )  ;", "this . parseJDBCStoreAttributes ( r ,    operation )  ;", "while    (  ( r . hasNext (  )  )     &  &     (  ( r . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( r . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ENTRY _ TABLE    :", "{", "if    ( address    !  =    null )     {", "this . removeStoreOperations ( address ,    operations )  ;", "}", "address    =    cacheAddress . append (  ( address    =  =    null    ?    StringKeyedJDBCStoreResourceDefinition . PATH    :    MixedKeyedJDBCStoreResourceDefinition . PATH )  )  ;", "Operations . setPathAddress ( operation ,    address )  ;", "ModelNode   binaryTableOperation    =    operations . get ( operationKey . append ( BinaryTableResourceDefinition . PATH )  )  ;", "if    ( binaryTableOperation    !  =    null )     {", "Operations . setPathAddress ( binaryTableOperation ,    address . append ( BinaryTableResourceDefinition . PATH )  )  ;", "}", "this . parseJDBCStoreStringTable ( r ,    address ,    operations )  ;", "break ;", "}", "case   BUCKET _ TABLE    :", "{", "if    ( address    !  =    null )     {", "this . removeStoreOperations ( address ,    operations )  ;", "}", "address    =    cacheAddress . append (  ( address    =  =    null    ?    BinaryKeyedJDBCStoreResourceDefinition . PATH    :    MixedKeyedJDBCStoreResourceDefinition . PATH )  )  ;", "Operations . setPathAddress ( operation ,    address )  ;", "ModelNode   stringTableOperation    =    operations . get ( operationKey . append ( StringTableResourceDefinition . PATH )  )  ;", "if    ( stringTableOperation    !  =    null )     {", "Operations . setPathAddress ( stringTableOperation ,    address . append ( StringTableResourceDefinition . PATH )  )  ;", "}", "this . parseJDBCStoreBinaryTable ( r ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "this . parseStoreElement ( r ,    address ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseLegacyJDBCStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    InfinispanSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    containerAddress . append ( LocalCacheResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseCacheAttribute ( reader ,    i ,    address ,    operations )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseCacheElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseLocalCache"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( LockingResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   ISOLATION    :", "{", ". readAttribute ( reader ,    i ,    operation ,    LockingResourceDefinition . Attribute . ISOLATION )  ;", "break ;", "}", "case   STRIPING    :", "{", ". readAttribute ( reader ,    i ,    operation ,    LockingResourceDefinition . Attribute . STRIPING )  ;", "break ;", "}", "case   ACQUIRE _ TIMEOUT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    LockingResourceDefinition . Attribute . ACQUIRE _ TIMEOUT )  ;", "break ;", "}", "case   CONCURRENCY _ LEVEL    :", "{", ". readAttribute ( reader ,    i ,    operation ,    LockingResourceDefinition . Attribute . CONCURRENCY )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseLocking"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   SIZE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    MemoryResourceDefinition . Attribute . SIZE )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseMemoryAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( MixedKeyedJDBCStoreResourceDefinition . PATH )  ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( r )  ;", "}", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( operationKey ,    operation )  ;", "this . parseJDBCStoreAttributes ( r ,    operation )  ;", "while    (  ( r . hasNext (  )  )     &  &     (  ( r . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( r . getLocalName (  )  )  ;", "switch    ( element )     {", "case   BINARY _ KEYED _ TABLE    :", "{", "this . parseJDBCStoreBinaryTable ( r ,    address ,    operations )  ;", "break ;", "}", "case   STRING _ KEYED _ TABLE    :", "{", "this . parseJDBCStoreStringTable ( r ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "this . parseStoreElement ( r ,    address ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseMixedKeyedJDBCStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( ObjectMemoryResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( r . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseMemoryAttribute ( r ,    i ,    operation )  ;", "}", "ParseUtils . requireNoContent ( r )  ;", "}", "METHOD_END"], "methodName": ["parseObjectMemory"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( OffHeapMemoryResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   CAPACITY    :", "{", ". readAttribute ( reader ,    i ,    operation ,    OffHeapMemoryResourceDefinition . Attribute . CAPACITY )  ;", "break ;", "}", "default    :", "{", "this . parseBinaryMemoryAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseOffHeapMemory"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( PartitionHandlingResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   ENABLED    :", "{", ". readAttribute ( reader ,    i ,    operation ,    PartitionHandlingResourceDefinition . Attribute . ENABLED )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parsePartitionHandling"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( RemoteStoreResourceDefinition . PATH )  ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( operationKey ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   CACHE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    RemoteStoreResourceDefinition . Attribute . CACHE )  ;", "break ;", "}", "case   SOCKET _ TIMEOUT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    RemoteStoreResourceDefinition . Attribute . SOCKET _ TIMEOUT )  ;", "break ;", "}", "case   TCP _ NO _ DELAY    :", "{", ". readAttribute ( reader ,    i ,    operation ,    RemoteStoreResourceDefinition . Attribute . TCP _ NO _ DELAY )  ;", "break ;", "}", "case   REMOTE _ SERVERS    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", ". readAttribute ( reader ,    i ,    operation ,    RemoteStoreResourceDefinition . Attribute . SOCKET _ BINDINGS )  ;", "break ;", "}", "}", "default    :", "{", "this . parseStoreAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   REMOTE _ SERVER    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   OUTBOUND _ SOCKET _ BINDING    :", "{", ". readAttribute ( reader ,    i ,    operation ,    RemoteStoreResourceDefinition . Attribute . SOCKET _ BINDINGS )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "this . parseStoreElement ( reader ,    address ,    operations )  ;", "}", "}", "}", "if    (  !  ( operation . hasDefined ( RemoteStoreResourceDefinition . Attribute . SOCKET _ BINDINGS . getName (  )  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    Collections . singleton ( XMLAttribute . REMOTE _ SERVERS . getLocalName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseRemoteStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    InfinispanSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    containerAddress . append ( ReplicatedCacheResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseClusteredCacheAttribute ( reader ,    i ,    address ,    operations )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseSharedStateCacheElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseReplicatedCache"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    parentAddress . append ( pool . getPathElement (  )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   MAX _ THREADS    :", "{", ". readAttribute ( reader ,    i ,    operation ,    pool . getMaxThreads (  )  )  ;", "break ;", "}", "case   KEEPALIVE _ TIME    :", "{", ". readAttribute ( reader ,    i ,    operation ,    pool . getKeepAliveTime (  )  )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseScheduledThreadPool"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   STATE _ TRANSFER    :", "{", "this . parseStateTransfer ( reader ,    address ,    operations )  ;", "break ;", "}", "case   BACKUPS    :", "{", "if    ( this . schema . since ( chema . VERSION _  2  _  0  )  )     {", "this . parseBackups ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   BACKUP _ FOR    :", "{", "if    (  ( this . schema . since ( chema . VERSION _  2  _  0  )  )     &  &     (  !  ( this . schema . since ( chema . VERSION _  5  _  0  )  )  )  )     {", "this . parseBackupFor ( reader ,    address ,    operations )  ;", "break ;", "}", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "case   PARTITION _ HANDLING    :", "{", "if    ( this . schema . since ( chema . VERSION _  4  _  0  )  )     {", "this . parsePartitionHandling ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "default    :", "{", "this . parseCacheElement ( reader ,    address ,    operations )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseSharedStateCacheElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( StateTransferResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   ENABLED    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "case   TIMEOUT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    StateTransferResourceDefinition . Attribute . TIMEOUT )  ;", "break ;", "}", "case   FLUSH _ TIMEOUT    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "case   CHUNK _ SIZE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", ". readAttribute ( reader ,    i ,    operation ,    StateTransferResourceDefinition . Attribute . CHUNK _ SIZE )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseStateTransfer"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   SHARED    :", "{", ". readAttribute ( reader ,    index ,    operation ,    StoreResourceDefinition . Attribute . SHARED )  ;", "break ;", "}", "case   PRELOAD    :", "{", ". readAttribute ( reader ,    index ,    operation ,    StoreResourceDefinition . Attribute . PRELOAD )  ;", "break ;", "}", "case   PASSIVATION    :", "{", ". readAttribute ( reader ,    index ,    operation ,    StoreResourceDefinition . Attribute . PASSIVATION )  ;", "break ;", "}", "case   FETCH _ STATE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    StoreResourceDefinition . Attribute . FETCH _ STATE )  ;", "break ;", "}", "case   PURGE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    StoreResourceDefinition . Attribute . PURGE )  ;", "break ;", "}", "case   SINGLETON    :", "{", ". readAttribute ( reader ,    index ,    operation ,    StoreResourceDefinition . Attribute . SINGLETON )  ;", "break ;", "}", "case   MAX _ BATCH _ SIZE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  5  _  0  )  )     {", ". readAttribute ( reader ,    index ,    operation ,    StoreResourceDefinition . Attribute . MAX _ BATCH _ SIZE )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseStoreAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( storeAddress . getParent (  )  . append ( StoreResourceDefinition . WILDCARD _ PATH )  )  ;", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "{", "ParseUtils . requireSingleAttribute ( reader ,    XMLAttribute . NAME . getLocalName (  )  )  ;", ". readElement ( reader ,    operation ,    StoreResourceDefinition . Attribute . PROPERTIES )  ;", "break ;", "}", "case   WRITE _ BEHIND    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  2  )  )     {", "this . parseStoreWriteBehind ( reader ,    storeAddress ,    operations )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseStoreElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    storeAddress . append ( StoreWriteBehindResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( storeAddress . append ( StoreWriteResourceDefinition . WILDCARD _ PATH )  ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   FLUSH _ LOCK _ TIMEOUT    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "case   MODIFICATION _ QUEUE _ SIZE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    StoreWriteBehindResourceDefinition . Attribute . MODIFICATION _ QUEUE _ SIZE )  ;", "break ;", "}", "case   SHUTDOWN _ TIMEOUT    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "case   THREAD _ POOL _ SIZE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    StoreWriteBehindResourceDefinition . Attribute . THREAD _ POOL _ SIZE )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseStoreWriteBehind"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( StringKeyedJDBCStoreResourceDefinition . PATH )  ;", "PathAddress   operationKey    =    cacheAddress . append ( StoreResourceDefinition . WILDCARD _ PATH )  ;", "if    ( operations . containsKey ( operationKey )  )     {", "throw   ParseUtils . unexpectedElement ( r )  ;", "}", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( operationKey ,    operation )  ;", "this . parseJDBCStoreAttributes ( r ,    operation )  ;", "while    (  ( r . hasNext (  )  )     &  &     (  ( r . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( r . getLocalName (  )  )  ;", "switch    ( element )     {", "case   STRING _ KEYED _ TABLE    :", "{", "this . parseJDBCStoreStringTable ( r ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "this . parseStoreElement ( r ,    address ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseStringKeyedJDBCStore"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    parentAddress . append ( pool . getPathElement (  )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   MIN _ THREADS    :", "{", ". readAttribute ( reader ,    i ,    operation ,    pool . getMinThreads (  )  )  ;", "break ;", "}", "case   MAX _ THREADS    :", "{", ". readAttribute ( reader ,    i ,    operation ,    pool . getMaxThreads (  )  )  ;", "break ;", "}", "case   QUEUE _ LENGTH    :", "{", ". readAttribute ( reader ,    i ,    operation ,    pool . getQueueLength (  )  )  ;", "break ;", "}", "case   KEEPALIVE _ TIME    :", "{", ". readAttribute ( reader ,    i ,    operation ,    pool . getKeepAliveTime (  )  )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseThreadPool"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    cacheAddress . append ( TransactionResourceDefinition . PATH )  ;", "ModelNode   operation    =    operations . get ( address )  ;", "if    ( operation    =  =    null )     {", "operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   STOP _ TIMEOUT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    TransactionResourceDefinition . Attribute . STOP _ TIMEOUT )  ;", "break ;", "}", "case   MODE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    TransactionResourceDefinition . Attribute . MODE )  ;", "break ;", "}", "case   LOCKING    :", "{", ". readAttribute ( reader ,    i ,    operation ,    TransactionResourceDefinition . Attribute . LOCKING )  ;", "break ;", "}", "case   EAGER _ LOCKING    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . attributeDeprecated ( attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseTransaction"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    containerAddress . append ( JGroupsTransportResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( containerAddress . append ( TransportResourceDefinition . WILDCARD _ PATH )  ,    operation )  ;", "String   stack    =    null ;", "String   cluster    =    null ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "String   value    =    reader . getAttributeValue ( i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   STACK    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "stack    =    value ;", "break ;", "}", "case   EXECUTOR    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  4  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", ". readAttribute ( reader ,    i ,    operation ,    JGroupsTransportResourceDefinition . ExecutorAttribute . TRANSPORT )  ;", "InfinispanLogger . ROOT _ LOGGER . executorIgnored ( JGroupsTransportResourceDefinition . ExecutorAttribute . TRANSPORT . getName (  )  )  ;", "break ;", "}", "case   LOCK _ TIMEOUT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    JGroupsTransportResourceDefinition . Attribute . LOCK _ TIMEOUT )  ;", "break ;", "}", "case   SITE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . topologyAttributeDeprecated ( XMLAttribute . SITE . getLocalName (  )  )  ;", "break ;", "}", "case   RACK    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . topologyAttributeDeprecated ( XMLAttribute . RACK . getLocalName (  )  )  ;", "break ;", "}", "case   MACHINE    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  1  _  1  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "InfinispanLogger . ROOT _ LOGGER . topologyAttributeDeprecated ( XMLAttribute . MACHINE . getLocalName (  )  )  ;", "break ;", "}", "case   CLUSTER    :", "{", "if    (  ( this . schema . since ( InfinispanSchema . VERSION _  1  _  2  )  )     &  &     (  !  ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )  )  )     {", "cluster    =    value ;", "break ;", "}", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "case   CHANNEL    :", "{", "if    ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )     {", ". readAttribute ( reader ,    i ,    operation ,    JGroupsTransportResourceDefinition . Attribute . CHANNEL )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    (  !  ( this . schema . since ( InfinispanSchema . VERSION _  3  _  0  )  )  )     {", "String   channel    =     ( cluster    !  =    null )     ?    cluster    :     \" ee -  \"     +     ( containerAddress . getLastElement (  )  . getValue (  )  )  ;", ". setAttribute ( reader ,    channel ,    operation ,    JGroupsTransportResourceDefinition . Attribute . CHANNEL )  ;", "PathAddress   channelAddress    =    PathAddress . pathAddress ( JGroupsSubsystemResourceDefinition . PATH ,    ChannelResourceDefinition . pathElement ( channel )  )  ;", "ModelNode   channelOperation    =    Util . createAddOperation ( channelAddress )  ;", "if    ( stack    !  =    null )     {", ". setAttribute ( reader ,    stack ,    channelOperation ,    ChannelResourceDefinition . Attribute . STACK )  ;", "}", "operations . put ( channelAddress ,    channelOperation )  ;", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseTransport"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition   definition    =    attribute . getDefinition (  )  ;", "return   definition . getParser (  )  . parse ( definition ,    r . getAttributeValue ( index )  ,    r )  ;", "}", "METHOD_END"], "methodName": ["readAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "InfinispanSubsystemXMLReader . setAttribute ( reader ,    reader . getAttributeValue ( index )  ,    operation ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["readAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition   definition    =    attribute . getDefinition (  )  ;", "AttributeParser   parser    =    definition . getParser (  )  ;", "if    ( parser . isParseAsElement (  )  )     {", "parser . parseElement ( definition ,    r ,    operation )  ;", "} else    {", "parser . parseAndSetParameter ( definition ,    r . getElementText (  )  ,    operation ,    r )  ;", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "operations . remove ( storeAddress . append ( StoreWriteResourceDefinition . WILDCARD _ PATH )  )  ;", "}", "METHOD_END"], "methodName": ["removeStoreOperations"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   value    =    reader . getAttributeValue ( null ,    attribute . getLocalName (  )  )  ;", "if    ( value    =  =    null )     {", "throw   ParseUtils . missingRequired ( reader ,    attribute . getLocalName (  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition   definition    =    attribute . getDefinition (  )  ;", "definition . getParser (  )  . parseAndSetParameter ( definition ,    value ,    operation ,    r )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute   attribute    :    attributes )     {", "if    ( model . hasDeed ( attribute . getName (  )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasDefined"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getMarshaller (  )  . marshallAsAttribute ( attribute . getDefinition (  )  ,    model ,    true ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeAttribute"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "InfinispanSubsystemXMLWriter . writeAttributes ( writer ,    model ,    EnumSet . allOf ( attributeClass )  )  ;", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute   attribute    :    attributes )     {", ". writeAttribute ( writer ,    model ,    attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeAttribute ( XMLAttribute . NAME . getLocalName (  )  ,    name )  ;", ". writeAttributes ( writer ,    cache ,    EnumSet . allOf ( CacheResourceDefinition . Attribute . class )  )  ;", "}", "METHOD_END"], "methodName": ["writeCacheAttributes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( cache . hasDefined ( LockingResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   locking    =    cache . get ( LockingResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "Set < LockingResourceDefinition . Attribute >    attributes    =    EnumSet . allOf ( LockingResourceDefinition . Attribute . class )  ;", "if    (  . hasDefined ( locking ,    attributes )  )     {", "writer . writeStartElement ( XMLElement . LOCKING . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    locking ,    attributes )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( cache . hasDefined ( TransactionResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   transaction    =    cache . get ( TransactionResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "Set < TransactionResourceDefinition . Attribute >    attributes    =    EnumSet . allOf ( TransactionResourceDefinition . Attribute . class )  ;", "if    (  . hasDefined ( transaction ,    attributes )  )     {", "writer . writeStartElement ( XMLElement . TRANSACTION . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    transaction ,    attributes )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( cache . hasDefined ( ObjectMemoryResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   memory    =    cache . get ( ObjectMemoryResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "Set < MemoryResourceDefinition . Attribute >    attributes    =    EnumSet . allOf ( MemoryResourceDefinition . Attribute . class )  ;", "if    (  . hasDefined ( memory ,    attributes )  )     {", "writer . writeStartElement ( XMLElement . OBJECT _ MEMORY . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    memory ,    attributes )  ;", "writer . writeEndElement (  )  ;", "}", "} else", "if    ( cache . hasDefined ( BinaryMemoryResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   memory    =    cache . get ( BinaryMemoryResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . BINARY _ MEMORY . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    memory ,    MemoryResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    memory ,    BinaryMemoryResourceDefinition . Attribute . class )  ;", "writer . writeEndElement (  )  ;", "} else", "if    ( cache . hasDefined ( OffHeapMemoryResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   memory    =    cache . get ( OffHeapMemoryResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . OFF _ HEAP _ MEMORY . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    memory ,    MemoryResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    memory ,    BinaryMemoryResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    memory ,    OffHeapMemoryResourceDefinition . Attribute . class )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( cache . hasDefined ( ExpirationResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   expiration    =    cache . get ( ExpirationResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "Set < ExpirationResourceDefinition . Attribute >    attributes    =    EnumSet . allOf ( ExpirationResourceDefinition . Attribute . class )  ;", "if    (  . hasDefined ( expiration ,    attributes )  )     {", "writer . writeStartElement ( XMLElement . EXPIRATION . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    expiration ,    attributes )  ;", "writer . writeEndElement (  )  ;", "}", "}", "Set < StoreResourceDefinition . Attribute >    storeAttributes    =    EnumSet . complementOf ( EnumSet . of ( StoreResourceDefinition . Attribute . PROPERTIES )  )  ;", "if    ( cache . hasDefined ( CustomStoreResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   store    =    cache . get ( CustomStoreResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . STORE . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    store ,    CustomStoreResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    store ,    JDBCStoreResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    store ,    storeAttributes )  ;", ". writeStoreElements ( writer ,    store )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( cache . hasDefined ( FileStoreResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   store    =    cache . get ( FileStoreResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . FILE _ STORE . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    store ,    FileStoreResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    store ,    storeAttributes )  ;", ". writeStoreElements ( writer ,    store )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( cache . hasDefined ( BinaryKeyedJDBCStoreResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   store    =    cache . get ( BinaryKeyedJDBCStoreResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . BINARY _ KEYED _ JDBC _ STORE . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    store ,    JDBCStoreResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    store ,    storeAttributes )  ;", ". writeStoreElements ( writer ,    store )  ;", ". writeJDBCStoreTable ( writer ,    XMLElement . BINARY _ KEYED _ TABLE ,    store ,    BinaryTableResourceDefinition . PATH ,    BinaryTableResourceDefinition . Attribute . PREFIX )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( cache . hasDefined ( StringKeyedJDBCStoreResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   store    =    cache . get ( StringKeyedJDBCStoreResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . JDBC _ STORE . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    store ,    JDBCStoreResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    store ,    storeAttributes )  ;", ". writeStoreElements ( writer ,    store )  ;", ". writeJDBCStoreTable ( writer ,    XMLElement . TABLE ,    store ,    StringTableResourceDefinition . PATH ,    StringTableResourceDefinition . Attribute . PREFIX )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( cache . hasDefined ( MixedKeyedJDBCStoreResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   store    =    cache . get ( MixedKeyedJDBCStoreResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . MIXED _ KEYED _ JDBC _ STORE . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    store ,    JDBCStoreResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    store ,    storeAttributes )  ;", ". writeStoreElements ( writer ,    store )  ;", ". writeJDBCStoreTable ( writer ,    XMLElement . BINARY _ KEYED _ TABLE ,    store ,    BinaryTableResourceDefinition . PATH ,    BinaryTableResourceDefinition . Attribute . PREFIX )  ;", ". writeJDBCStoreTable ( writer ,    XMLElement . STRING _ KEYED _ TABLE ,    store ,    StringTableResourceDefinition . PATH ,    StringTableResourceDefinition . Attribute . PREFIX )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( cache . hasDefined ( RemoteStoreResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   store    =    cache . get ( RemoteStoreResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( XMLElement . REMOTE _ STORE . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    store ,    RemoteStoreResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    store ,    storeAttributes )  ;", ". writeStoreElements ( writer ,    store )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( cache . hasDefined ( PartitionHandlingResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   partitionHandling    =    cache . get ( PartitionHandlingResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "EnumSet < PartitionHandlingResourceDefinition . Attribute >    attributes    =    EnumSet . allOf ( PartitionHandlingResourceDefinition . Attribute . class )  ;", "if    (  . hasDefined ( partitionHandling ,    attributes )  )     {", "writer . writeStartElement ( XMLElement . PARTITION _ HANDLING . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    partitionHandling ,    attributes )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( cache . hasDefined ( StateTransferResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   stateTransfer    =    cache . get ( StateTransferResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "EnumSet < StateTransferResourceDefinition . Attribute >    attributes    =    EnumSet . allOf ( StateTransferResourceDefinition . Attribute . class )  ;", "if    (  . hasDefined ( stateTransfer ,    attributes )  )     {", "writer . writeStartElement ( XMLElement . STATE _ TRANSFER . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    stateTransfer ,    attributes )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( cache . hasDefined ( BackupsResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   backups    =    cache . get ( BackupsResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "if    ( backups . hasDefined ( BackupResourceDefinition . WILDCARD _ PATH . getKey (  )  )  )     {", "writer . writeStartElement ( XMLElement . BACKUPS . getLocalName (  )  )  ;", "for    ( Property   property    :    backups . get ( BackupResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . asPropertyList (  )  )     {", "writer . writeStartElement ( XMLElement . BACKUP . getLocalName (  )  )  ;", "writer . writeAttribute ( XMLAttribute . SITE . getLocalName (  )  ,    property . getName (  )  )  ;", "ModelNode   backup    =    property . getValue (  )  ;", ". writeAttributes ( writer ,    backup ,    EnumSet . allOf ( BackupResourceDefinition . Attribute . class )  )  ;", "EnumSet < BackupResourceDefinition . TakeOfflineAttribute >    takeOfflineAttributes    =    EnumSet . allOf ( BackupResourceDefinition . TakeOfflineAttribute . class )  ;", "if    (  . hasDefined ( backup ,    takeOfflineAttributes )  )     {", "writer . writeStartElement ( XMLElement . TAKE _ OFFLINE . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    backup ,    takeOfflineAttributes )  ;", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeCacheElements"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "InfinispanSubsystemXMLWriter . writeCacheAttributes ( writer ,    name ,    cache )  ;", "InfinispanSubsystemXMLWriter . writeAttributes ( writer ,    cache ,    ClusteredCacheResourceDefinition . Attribute . class )  ;", "}", "METHOD_END"], "methodName": ["writeClusteredCacheAttributes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getMarshaller (  )  . marshallAsElement ( attribute . getDefinition (  )  ,    model ,    true ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( store . hasDefined ( path . getKeyValuePair (  )  )  )     {", "ModelNode   table    =    store . get ( path . getKeyValuePair (  )  )  ;", "writer . writeStartElement ( element . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    table ,    TableResourceDefinition . Attribute . class )  ;", ". writeAttribute ( writer ,    table ,    prefixAttribute )  ;", "for    ( TableResourceDefinition . ColumnAttribute   attribute    :    TableResourceDefinition . ColumnAttribute . values (  )  )     {", "if    ( table . hasDefined ( attribute . getName (  )  )  )     {", "ModelNode   column    =    table . get ( attribute . getName (  )  )  ;", "writer . writeStartElement ( attribute . getDefinition (  )  . getXmlName (  )  )  ;", ". writeAttribute ( writer ,    column ,    attribute . getColumnName (  )  )  ;", ". writeAttribute ( writer ,    column ,    attribute . getColumnType (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeJDBCStoreTable"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( container . get ( pool . getPathElement (  )  . getKey (  )  )  . hasDefined ( pool . getPathElement (  )  . getValue (  )  )  )     {", "ModelNode   threadPool    =    container . get ( pool . getPathElement (  )  . getKeyValuePair (  )  )  ;", "if    (  . hasDefined ( threadPool ,    pool . getAttributes (  )  )  )     {", "writer . writeStartElement ( element . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    threadPool ,    pool . getAttributes (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeScheduledThreadPoolElements"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( store . hasDefined ( StoreWriteBehindResourceDefinition . PATH . getKeyValuePair (  )  )  )     {", "ModelNode   writeBehind    =    store . get ( StoreWriteBehindResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "Set < StoreWriteBehindResourceDefinition . Attribute >    attributes    =    EnumSet . allOf ( StoreWriteBehindResourceDefinition . Attribute . class )  ;", "if    (  . hasDefined ( writeBehind ,    attributes )  )     {", "writer . writeStartElement ( XMLElement . WRITE _ BEHIND . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    writeBehind ,    attributes )  ;", "writer . writeEndElement (  )  ;", "}", "}", ". writeElement ( writer ,    store ,    StoreResourceDefinition . Attribute . PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["writeStoreElements"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( container . get ( pool . getPathElement (  )  . getKey (  )  )  . hasDefined ( pool . getPathElement (  )  . getValue (  )  )  )     {", "ModelNode   threadPool    =    container . get ( pool . getPathElement (  )  . getKeyValuePair (  )  )  ;", "if    (  . hasDefined ( threadPool ,    pool . getAttributes (  )  )  )     {", "writer . writeStartElement ( element . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    threadPool ,    pool . getAttributes (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeThreadPoolElements"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( xml )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    version )  . addMavenResourceURL ( mavenResourceURLs )  . addSingleChildFirstClass ( SubsystemInitialization . class )  . addSingleChildFirstClass ( JGroupsSubsystemInitialization . class )  . addSingleChildFirstClass ( AdditionalInitialization . class )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   services    =    builder . build (  )  ;", "Assert . assertTrue (  (  ( ModelTestControllerVersion . MASTER )     +     \"    boot   failed \"  )  ,    services . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue (  (  ( controllerVersion . getMavenGavVersion (  )  )     +     \"    boot   failed \"  )  ,    services . getLegacyServices ( version )  . isSuccessfulBoot (  )  )  ;", "return   services ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . buildKernelServices ( this . getSubsystemXml (  )  ,    controllerVersion ,    version ,    mavenResourceURLs )  ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( InfinispanSubsystemResourceDefinition . PATH )  ;", "PathAddress   containerAddress    =    subsystemAddress . append ( CacheContainerResourceDefinition . WILDCARD _ PATH )  ;", "if    ( InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "config . addFailedAttribute ( containerAddress . append ( ReplicatedCacheResourceDefinition . WILDCARD _ PATH ,    BinaryMemoryResourceDefinition . PATH )  ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( containerAddress . append ( DistributedCacheResourceDefinition . WILDCARD _ PATH ,    OffHeapMemoryResourceDefinition . PATH )  ,    REJECTED _ RESOURCE )  ;", "}", "if    ( InfinispanModel . VERSION _  2  _  0  _  0  . requiresTransformation ( version )  )     {", "for    ( PathElement   path    :    Arrays . asList ( DistributedCacheResourceDefinition . WILDCARD _ PATH ,    ReplicatedCacheResourceDefinition . WILDCARD _ PATH )  )     {", "PathAddress   cacheAddress    =    containerAddress . append ( path )  ;", "config . addFailedAttribute ( cacheAddress . append ( BackupsResourceDefinition . PATH )  ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( cacheAddress . append ( BackupsResourceDefinition . PATH ,    BackupResourceDefinition . WILDCARD _ PATH )  ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( cacheAddress . append ( BackupForResourceDefinition . PATH )  ,    REJECTED _ RESOURCE )  ;", "}", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["createFailedOperationConfig"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (    model )     -  >     {", "final   ModelNode   maximal    =    model . get (  \" cache - container \"  ,     \" maximal \"  )  ;", "maximal . asPropertyList (  )  . stream (  )  . filter (  (    caches )     -  >     ( caches . getName (  )  . equals (  \" distributed - cache \"  )  )     |  |     ( caches . getName (  )  . equals (  \" replicated - cache \"  )  )  )  . forEach (  (    p )     -  >     {", "ModelNode   caches    =    maximal . get ( p . getName (  )  )  ;", "final   List < Property >    cachesModel    =    caches . asPropertyList (  )  ;", "for    ( Property   cacheName    :    cachesModel )     {", "final   ModelNode   cache    =    caches . get ( cacheName . getName (  )  )  ;", "if    ( cache . hasDefined (  \" component \"  )  )     {", "cache . get (  \" component \"  ,     \" backups \"  )  . set ( new   ModelNode (  )  )  ;", "}", "}", "}  )  ;", "if    ( Model . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "Arrays . asList (  \" cache - with - string - keyed - store \"  ,     \" cache - with - binary - keyed - store \"  )  . forEach (  (    cacheName )     -  >     {", "ModelNode   cache    =    model . get (  \" cache - container \"  ,     \" maximal \"  ,     \" replicated - cache \"  ,    cacheName )  ;", "assertFalse ( cache . hasDefined ( StateTransferResourceDefinition . LEGACY _ PATH . getKeyValuePair (  )  )  )  ;", "ModelNode   stateTransfer    =    cache . get ( StateTransferResourceDefinition . LEGACY _ PATH . getKeyValuePair (  )  )  ;", "stateTransfer . get ( StateTransferResourceDefinition . Attribute . CHUNK _ SIZE . getDefinition (  )  . getName (  )  )  . set ( StateTransferResourceDefinition . Attribute . CHUNK _ SIZE . getDefinition (  )  . getDefaultValue (  )  )  ;", "stateTransfer . get ( StateTransferResourceDefinition . Attribute . TIMEOUT . getDefinition (  )  . getName (  )  )  . set ( StateTransferResourceDefinition . Attribute . TIMEOUT . getDefinition (  )  . getDefaultValue (  )  )  ;", "}  )  ;", "}", "return   model ;", "}  ;", "}", "METHOD_END"], "methodName": ["createModelFixer"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   String . format ( pattern ,    version . getMavenGavVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["formatArtifact"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   InfinispanTransformersTestCase . formatArtifact (  \" as : jboss - as - clustering - infinispan :  % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["formatEAP6SubsystemArtifact"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   InfinispanTransformersTestCase . formatArtifact (  \" eap : wildfly - clustering - infinispan - extension :  % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["formatEAP7SubsystemArtifact"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "switch    ( version )     {", "case   EAP _  6  _  4  _  0     :", "case   EAP _  6  _  4  _  7     :", "return   new   String [  ]  {     . formatEAP 6 SubsystemArtifact ( version )  ,     \" infinispan : infinispan - core :  5  .  2  .  1  1  . Final - redhat -  2  \"  ,     \" infinispan : infinispan - cachestore - jdbc :  5  .  2  .  1  1  . Final - redhat -  2  \"     }  ;", "case   EAP _  7  _  0  _  0     :", "return   new   String [  ]  {     . formatEAP 7 SubsystemArtifact ( version )  ,     \" infinispan : infinispan - core :  8  .  1  .  2  . Final - redhat -  1  \"  ,     \" infinispan : infinispan - cachestore - jdbc :  8  .  1  .  2  . Final - redhat -  1  \"  ,     . formatArtifact (  \" eap : wildfly - clustering - common :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - service :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - jgroups - spi :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - jgroups - extension :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - connector :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - infinispan - spi :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - spi :  % s \"  ,    version )     }  ;", "case   EAP _  7  _  1  _  0     :", "return   new   String [  ]  {     . formatEAP 7 SubsystemArtifact ( version )  ,     \" infinispan : infinispan - core :  8  .  2  .  8  . Final - redhat -  1  \"  ,     \" infinispan : infinispan - cachestore - jdbc :  8  .  2  .  8  . Final - redhat -  1  \"  ,     . formatArtifact (  \" eap : wildfly - clustering - common :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - service :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - jgroups - spi :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - jgroups - extension :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - connector :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - infinispan - spi :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - singleton - api :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - spi :  % s \"  ,    version )     }  ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "switch    ( controllerVersion )     {", "case   EAP _  6  _  4  _  0     :", "case   EAP _  6  _  4  _  7     :", "return   Model . VERSION _  1  _  6  _  0  ;", "case   EAP _  7  _  0  _  0     :", "return   Model . VERSION _  4  _  0  _  0  ;", "case   EAP _  7  _  1  _  0     :", "return   Model . VERSION _  5  _  0  _  0  ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getModelVersion"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   String   cacheContainer    =     \" maximal \"  ;", "final   String   testProperty 1     =     \" testProperty 1  \"  ;", "final   String   testProperty 2     =     \" testProperty 2  \"  ;", "final   String   testProperty 3     =     \" testProperty 3  \"  ;", "final   String   testProperty 4     =     \" testProperty 4  \"  ;", "final   List < PathAddress >    cacheStoreAddresses    =    new   LinkedList <  >  (  )  ;", "cacheStoreAddresses . add ( OperationBase . getBinaryKeyedJDBCCacheStoreAddress ( cacheContainer ,    ReplicatedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" cache - with - binary - keyed - store \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getCustomCacheStoreAddress ( cacheContainer ,    ReplicatedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" repl \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getFileCacheStoreAddress ( cacheContainer ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" local \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getMixedKeyedJDBCCacheStoreAddress ( cacheContainer ,    DistributedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" dist \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getRemoteCacheStoreAddress ( cacheContainer ,    InvalidationCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" invalid \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getStringKeyedJDBCCacheStoreAddress ( cacheContainer ,    ReplicatedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" cache - with - string - keyed - store \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getBinaryKeyedJDBCCacheStoreLegacyAddress ( cacheContainer ,    ReplicatedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" cache - with - binary - keyed - store \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getCustomCacheStoreLegacyAddress ( cacheContainer ,    ReplicatedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" repl \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getFileCacheStoreLegacyAddress ( cacheContainer ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" local \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getMixedKeyedJDBCCacheStoreLegacyAddress ( cacheContainer ,    DistributedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" dist \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getRemoteCacheStoreLegacyAddress ( cacheContainer ,    InvalidationCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" invalid \"  )  )  ;", "cacheStoreAddresses . add ( OperationBase . getStringKeyedJDBCCacheStoreLegacyAddress ( cacheContainer ,    ReplicatedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" cache - with - string - keyed - store \"  )  )  ;", "for    ( PathAddress   storeAddress    :    cacheStoreAddresses )     {", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationBase . getCacheStoreUndefinePropertiesOperation ( storeAddress )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 1  ,     \" true \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 1  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 2  ,     \" false \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 1  ,     \" true \"  ,    testProperty 2  ,     \" false \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 2  ,     \" true \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 1  ,     \" true \"  ,    testProperty 2  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationBase . getCacheStoreRemovePropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 2  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 1  ,     \" false \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 1  ,     \" false \"  ,    testProperty 2  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationBase . getCacheStoreClearPropertiesOperation ( storeAddress )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress )  ;", "ModelNode   composite    =    new   ModelNode (  )  ;", "composite . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . COMPOSITE )  ;", "composite . get ( ModelDescriptionConstants . OP _ ADDR )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 3  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 4  ,     \" true \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 1  ,     \" true \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 3  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 4  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 3  ,     \" true \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 4  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 1  ,     \" false \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 3  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 4  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 3  ,     \" true \"  ,    testProperty 4  ,     \" false \"  ,    testProperty 1  ,     \" false \"  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStoreRemovePropertyOperation ( storeAddress ,    testProperty 3  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStoreRemovePropertyOperation ( storeAddress ,    testProperty 4  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 2  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStoreRemovePropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 3  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 4  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 1  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 2  ,     \" false \"  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 3  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStorePutPropertyOperation ( storeAddress ,    testProperty 4  ,     \" true \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationBase . getCacheStoreRemovePropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 3  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 4  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationBase . getCacheStoreGetPropertyOperation ( storeAddress ,    testProperty 2  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    storeAddress ,    testProperty 3  ,     \" false \"  ,    testProperty 4  ,     \" true \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertiesMapOperationsTest"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelVersion   version    =    InfinispanTransformersTestCase . getModelVersion ( controller )  . getVersion (  )  ;", "final   String [  ]    dependencies    =    InfinispanTransformersTestCase . getDependencies ( controller )  ;", "KernelServicesBuilder   builder    =    this . createKernelServicesBuilder (  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controller ,    version )  . addSingleChildFirstClass ( InfinispanSubsystemInitialization . class )  . addSingleChildFirstClass ( JGroupsSubsystemInitialization . class )  . addSingleChildFirstClass ( AdditionalInitialization . class )  . addMavenResourceURL ( dependencies )  . dontPersistXml (  )  ;", "KernelServices   services    =    builder . build (  )  ;", "KernelServices   legacyServices    =    services . getLegacyServices ( version )  ;", "Assert . assertNotNull ( legacyServices )  ;", "Assert . assertTrue (  \" main   services   did   not   boot \"  ,    services . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    xmlOps    =    builder . parseXmlResource (  \" infinispan - transformer - reject . xml \"  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( services ,    version ,    xmlOps ,    InfinispanTransformersTestCase . createFailedOperationConfig ( version )  )  ;", "}", "METHOD_END"], "methodName": ["testRejections"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejections ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP640"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejections ( EAP _  7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP700"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejections ( EAP _  7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP710"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelVersion   version    =    InfinispanTransformersTestCase . getModelVersion ( controller )  . getVersion (  )  ;", "final   String [  ]    dependencies    =    InfinispanTransformersTestCase . getDependencies ( controller )  ;", "KernelServices   services    =    this . buildKernelServices ( controller ,    version ,    dependencies )  ;", "checkSubsystemModelTransformation ( services ,    version ,    InfinispanTransformersTestCase . createModelFixer ( version )  ,    false )  ;", "ModelNode   transformed    =    services . readTransformedModel ( version )  ;", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "ModelNode   cache    =    transformed . get ( InfinispanSubsystemResourceDefinition . PATH . getKeyValuePair (  )  )  . get ( CacheContainerResourceDefinition . pathElement (  \" maximal \"  )  . getKeyValuePair (  )  )  . get ( LocalCacheResourceDefinition . pathElement (  \" local \"  )  . getKeyValuePair (  )  )  ;", "Assert . assertTrue ( cache . hasDefined ( CacheResourceDefinition . DeprecatedAttribute . BATCHING . getName (  )  )  )  ;", "Assert . assertTrue ( cache . get ( CacheResourceDefinition . DeprecatedAttribute . BATCHING . getName (  )  )  . asBoolean (  )  )  ;", "ModelNode   transaction    =    cache . get ( TransactionResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "if    ( transaction . hasDefined ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  )     {", "Assert . assertEquals ( TransactionMode . NONE . name (  )  ,    transaction . get ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  . asString (  )  )  ;", "}", "InfinispanTransformersTestCase . propertiesMapOperationsTest ( services ,    version )  ;", "}", "}", "METHOD_END"], "methodName": ["testTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP640"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation ( EAP _  7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP700"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation ( EAP _  7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP710"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InfinispanTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( InvalidationCacheResourceDefinition . WILDCARD _ PATH )  ;", "ClusteredCacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InvalidationCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" invalidation - cache \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.InvalidationCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,     . Attribute . DIALECT . getDefinition (  )  )  . addRejectCheck ( new   RejectAttributeChecker . SimpleRejectAttributeChecker ( new   ModelNode ( MARIA _ DB . name (  )  )  )  ,     . Attribute . DIALECT . getDefinition (  )  )  ;", "if    (  !  ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )  )     {", "builder . getAttributeBuilder (  )  . setDiscard ( ALWAYS ,     . DeprecatedAttribute . DATASOURCE . getDefinition (  )  )  ;", "}", "}", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "SimpleAttributeConverter . Converter   converter    =    new   SimpleAttributeConverter . Converter (  )     {", "@ Override", "public   void   convert ( PathAddress   address ,    String   name ,    ModelNode   value ,    ModelNode   model ,    TransformationContext   context )     {", "if    ( value . isDefined (  )  )     {", "PathAddress   rootAddress    =    address . subAddress (  0  ,     (  ( address . size (  )  )     -     4  )  )  ;", "PathAddress   subsystemAddress    =    rootAddress . append ( PathElement . pathElement ( SUBSYSTEM ,     \" datasources \"  )  )  ;", "Resource   subsystem    =    context . readResourceFromRoot ( subsystemAddress )  ;", "String   poolName    =    value . asString (  )  ;", "for    ( String   type    :    Arrays . asList (  \" data - source \"  ,     \" xa - data - source \"  )  )     {", "if    ( subsystem . hasChildren ( type )  )     {", "for    ( Resource . ResourceEntry   entry    :    subsystem . getChildren ( type )  )     {", "if    ( entry . getName (  )  . equals ( poolName )  )     {", "value . set ( entry . getModel (  )  . get (  \" jndi - name \"  )  )  ;", "return ;", "}", "}", "}", "}", "}", "}", "}  ;", "builder . getAttributeBuilder (  )  . addRename (  . Attribute . DATA _ SOURCE . getName (  )  ,     . DeprecatedAttribute . DATASOURCE . getName (  )  )  . setValueConverter ( new   SimpleAttributeConverter ( converter )  ,     . Attribute . DATA _ SOURCE . getDefinition (  )  )  ;", "}", "StoreResourceDefinition . buildTransformation ( version ,    builder ,    path )  ;", "if    ( InfinispanModel . VERSION _  2  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setDiscard ( UNDEFINED ,     . Attribute . DIALECT . getDefinition (  )  )  . addRejectCheck ( DEFINED ,     . Attribute . DIALECT . getDefinition (  )  )  . end (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.JDBCStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . channel ;", "}", "METHOD_END"], "methodName": ["getChannel"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.JGroupsTransportBuilder"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( JGroupsTransportResourceDefinition . PATH ,    JGroupsTransportResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( JGroupsTransportResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "SimpleRejectAttributeChecker . Rejecter   stackRejecter    =    new   SimpleRejectAttributeChecker . Rejecter (  )     {", "@ Override", "public   boolean   reject ( PathAddress   address ,    String   name ,    ModelNode   value ,    ModelNode   model ,    TransformationContext   context )     {", "if    ( value . isDefined (  )  )", "return   false ;", "PathAddress   rootAddress    =    address . subAddress (  0  ,     (  ( address . size (  )  )     -     3  )  )  ;", "PathAddress   subsystemAddress    =    rootAddress . append ( JGroupsSubsystemResourceDefinition . PATH )  ;", "ModelNode   subsystemModel    =    context . readResourceFromRoot ( subsystemAddress )  . getModel (  )  ;", "String   channelName    =    null ;", "if    ( model . hasDefined ( JGroupsTransportResourceDefinition . Attribute . CHANNEL . getName (  )  )  )     {", "ModelNode   channel    =    model . get ( JGroupsTransportResourceDefinition . Attribute . CHANNEL . getName (  )  )  ;", "if    (  ( channel . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "channelName    =    channel . asString (  )  ;", "}", "} else", "if    ( subsystemModel . hasDefined ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL . getName (  )  )  )     {", "ModelNode   defaultChannel    =    subsystemModel . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL . getName (  )  )  ;", "if    (  ( defaultChannel . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "channelName    =    defaultChannel . asString (  )  ;", "}", "}", "if    ( channelName    =  =    null )", "return   true ;", "String   stackName    =    null ;", "PathAddress   channelAddress    =    subsystemAddress . append ( ChannelResourceDefinition . pathElement ( channelName )  )  ;", "try    {", "ModelNode   channel    =    context . readResourceFromRoot ( channelAddress )  . getModel (  )  ;", "if    ( channel . hasDefined ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  )     {", "ModelNode   stack    =    channel . get ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  ;", "if    (  ( stack . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "stackName    =    stack . asString (  )  ;", "}", "} else", "if    ( subsystemModel . hasDefined ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK . getName (  )  )  )     {", "ModelNode   defaultStack    =    subsystemModel . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK . getName (  )  )  ;", "if    (  ( defaultStack . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "stackName    =    defaultStack . asString (  )  ;", "}", "}", "}    catch    ( NoSuchResourceException   e )     {", "}", "return   stackName    =  =    null ;", "}", "@ Override", "public   String   getRejectedMessage ( Set < String >    attributes )     {", "return   InfinispanLogger . ROOT _ LOGGER . indeterminiteStack (  )  ;", "}", "}  ;", "SimpleAttributeConverter . Converter   stackConverter    =    new   SimpleAttributeConverter . Converter (  )     {", "@ Override", "public   void   convert ( PathAddress   address ,    String   name ,    ModelNode   value ,    ModelNode   model ,    TransformationContext   context )     {", "if    (  !  ( value . isDefined (  )  )  )     {", "PathAddress   rootAddress    =    address . subAddress (  0  ,     (  ( address . size (  )  )     -     3  )  )  ;", "PathAddress   subsystemAddress    =    rootAddress . append ( JGroupsSubsystemResourceDefinition . PATH )  ;", "ModelNode   subsystemModel    =    context . readResourceFromRoot ( subsystemAddress )  . getModel (  )  ;", "String   channelName    =    null ;", "if    ( model . hasDefined ( JGroupsTransportResourceDefinition . Attribute . CHANNEL . getName (  )  )  )     {", "ModelNode   channel    =    model . get ( JGroupsTransportResourceDefinition . Attribute . CHANNEL . getName (  )  )  ;", "if    (  ( channel . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "channelName    =    channel . asString (  )  ;", "}", "} else", "if    ( subsystemModel . hasDefined ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL . getName (  )  )  )     {", "ModelNode   defaultChannel    =    subsystemModel . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL . getName (  )  )  ;", "if    (  ( defaultChannel . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "channelName    =    defaultChannel . asString (  )  ;", "}", "}", "if    ( channelName    !  =    null )     {", "PathAddress   channelAddress    =    subsystemAddress . append ( ChannelResourceDefinition . pathElement ( channelName )  )  ;", "try    {", "ModelNode   channel    =    context . readResourceFromRoot ( channelAddress )  . getModel (  )  ;", "if    ( channel . hasDefined ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  )     {", "ModelNode   stack    =    channel . get ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  ;", "if    (  ( stack . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "value . set ( stack . asString (  )  )  ;", "}", "} else", "if    ( subsystemModel . hasDefined ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK . getName (  )  )  )     {", "ModelNode   defaultStack    =    subsystemModel . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK . getName (  )  )  ;", "if    (  ( defaultStack . getType (  )  )     =  =     ( ModelType . STRING )  )     {", "value . set ( defaultStack . asString (  )  )  ;", "}", "}", "}    catch    ( NoSuchResourceException   e )     {", "}", "}", "}", "}", "}  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( new   SimpleRejectAttributeChecker ( stackRejecter )  ,    JGroupsTransportResourceDefinition . DeprecatedAttribute . STACK . getDefinition (  )  )  . setValueConverter ( new   SimpleAttributeConverter ( stackConverter )  ,    JGroupsTransportResourceDefinition . DeprecatedAttribute . STACK . getDefinition (  )  )  . addRename ( JGroupsTransportResourceDefinition . Attribute . CHANNEL . getDefinition (  )  ,    JGroupsTransportResourceDefinition . DeprecatedAttribute . CLUSTER . getDefinition (  )  . getName (  )  )  . end (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.JGroupsTransportResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.JGroupsTransportResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "this . bufferSize    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setBufferSize"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.KeyAffinityServiceFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( LocalCacheResourceDefinition . WILDCARD _ PATH )  ;", "CacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.LocalCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" local - cache \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.LocalCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( LockingResourceDefinition . PATH ,    LockingResourceDefinition . LEGACY _ PATH ,    RequiredChildResourceDiscardPolicy . NEVER )     :    parent . addChildResource ( LockingResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( LockingResourceDefinition . Attribute . ISOLATION . getDefinition (  )  )  ,    LockingResourceDefinition . Attribute . ISOLATION . getDefinition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.LockingResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" memory \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.MemoryResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( MixedKeyedJDBCStoreResourceDefinition . PATH ,    MixedKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( MixedKeyedJDBCStoreResourceDefinition . PATH )  ;", "JDBCStoreResourceDefinition . buildTransformation ( version ,    builder ,    MixedKeyedJDBCStoreResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . setCustomResourceTransformer ( new   ResourceTransformer (  )     {", "@ SuppressWarnings (  \" deprecation \"  )", "@ Override", "public   void   transformResource ( ResourceTransformationContext   context ,    PathAddress   address ,    Resource   resource )    throws   OperationFailedException    {", "final   ModelNode   model    =    resource . getModel (  )  ;", "final   ModelNode   maxBatchSize    =    model . remove ( StoreResourceDefinition . Attribute . MAX _ BATCH _ SIZE . getName (  )  )  ;", "final   ModelNode   binaryTableModel    =    Tools . readModel ( resource . removeChild ( BinaryTableResourceDefinition . PATH )  )  ;", "if    (  ( binaryTableModel    !  =    null )     &  &     ( binaryTableModel . isDefined (  )  )  )     {", "model . get ( MixedKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . BINARY _ TABLE . getName (  )  )  . set ( binaryTableModel )  ;", "model . get ( MixedKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . BINARY _ TABLE . getName (  )  )  . get ( TableResourceDefinition . DeprecatedAttribute . BATCH _ SIZE . getName (  )  )  . set (  ( maxBatchSize    !  =    null    ?    maxBatchSize    :    new   ModelNode (  )  )  )  ;", "}", "final   ModelNode   stringTableModel    =    Tools . readModel ( resource . removeChild ( StringTableResourceDefinition . PATH )  )  ;", "if    (  ( stringTableModel    !  =    null )     &  &     ( stringTableModel . isDefined (  )  )  )     {", "model . get ( MixedKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . STRING _ TABLE . getName (  )  )  . set ( stringTableModel )  ;", "model . get ( MixedKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . STRING _ TABLE . getName (  )  )  . get ( TableResourceDefinition . DeprecatedAttribute . BATCH _ SIZE . getName (  )  )  . set (  ( maxBatchSize    !  =    null    ?    maxBatchSize    :    new   ModelNode (  )  )  )  ;", "}", "final   ModelNode   properties    =    model . remove ( StoreResourceDefinition . Attribute . PROPERTIES . getName (  )  )  ;", "final   ResourceTransformationContext   childContext    =    context . addTransformedResource ( EMPTY _ ADDRESS ,    resource )  ;", "LegacyPropertyResourceTransformer . transformPropertiesToChildrenResources ( properties ,    address ,    childContext )  ;", "context . processChildren ( resource )  ;", "}", "}  )  ;", "}", "BinaryTableResourceDefinition . buildTransformation ( version ,    builder )  ;", "StringTableResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.MixedKeyedJDBCStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . sync    ?    mode . toSync (  )     :    mode . toAsync (  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.Mode"}, {"methodBody": ["METHOD_START", "{", "return   mode . isSynchronous (  )     ?    Mode . SYNC    :    Mode . ASYNC ;", "}", "METHOD_END"], "methodName": ["forCacheMode"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.Mode"}, {"methodBody": ["METHOD_START", "{", "return   this . sync ;", "}", "METHOD_END"], "methodName": ["isSynchronous"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.Mode"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( ObjectMemoryResourceDefinition . PATH ,    ObjectMemoryResourceDefinition . LEGACY _ PATH ,    RequiredChildResourceDiscardPolicy . NEVER )     :    InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )     ?    parent . addChildRedirection ( ObjectMemoryResourceDefinition . PATH ,    ObjectMemoryResourceDefinition . EVICTION _ PATH ,    RequiredChildResourceDiscardPolicy . NEVER )     :    parent . addChildResource ( ObjectMemoryResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . addRename ( MemoryResourceDefinition . Attribute . SIZE . getDefinition (  )  ,    ObjectMemoryResourceDefinition . DeprecatedAttribute . MAX _ ENTRIES . getName (  )  )  . setValueConverter ( new   SimpleAttributeConverter (  (    address ,    name ,    value ,    model ,    context )     -  >     {", "if    (  ( model . hasDefined ( MemoryResourceDefinition . Attribute . SIZE . getName (  )  )  )     &  &     (  ( model . get ( MemoryResourceDefinition . Attribute . SIZE . getName (  )  )  . asLong (  )  )     <     0  )  )     {", "value . set ( NONE . name (  )  )  ;", "} else    {", "value . set ( LRU . name (  )  )  ;", "}", "}  )  ,    ObjectMemoryResourceDefinition . DeprecatedAttribute . STRATEGY . getDefinition (  )  )  . end (  )  ;", "}", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   SimpleAttributeConverter (  (    address ,    name ,    value ,    model ,    context )     -  >     {", "if    ( value . isDefined (  )  )     {", "value . set ( value . asInt (  )  )  ;", "}", "}  )  ,    MemoryResourceDefinition . Attribute . SIZE . getDefinition (  )  ,    ObjectMemoryResourceDefinition . DeprecatedAttribute . MAX _ ENTRIES . getDefinition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ObjectMemoryResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . rejectChildResource (  . PATH )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OffHeapMemoryResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    getSubsystemXml (  )  ;", "KernelServices   servicesA    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   addContainerOp    =    OperationTestCaseBase . getCacheContainerAddOperation (  \" maximal 2  \"  )  ;", "ModelNode   removeContainerOp    =    OperationTestCaseBase . getCacheContainerRemoveOperation (  \" maximal 2  \"  )  ;", "ModelNode   addCacheOp    =    OperationTestCaseBase . getCacheAddOperation (  \" maximal 2  \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" fred \"  )  ;", "ModelNode   result    =    servicesA . executeOperation ( addContainerOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( addCacheOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( removeContainerOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( addContainerOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( addCacheOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheContainerAddRemoveAddSequence"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    getSubsystemXml (  )  ;", "KernelServices   servicesA    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   addContainerOp    =    OperationTestCaseBase . getCacheContainerAddOperation (  \" maximal 2  \"  )  ;", "ModelNode   removeContainerOp    =    OperationTestCaseBase . getCacheContainerRemoveOperation (  \" maximal 2  \"  )  ;", "ModelNode   addCacheOp    =    OperationTestCaseBase . getCacheAddOperation (  \" maximal 2  \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" fred \"  )  ;", "ModelNode   result    =    servicesA . executeOperation ( addContainerOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( addCacheOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( removeContainerOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( removeContainerOp )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . FAILED ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheContainerRemoveRemoveSequence"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    getSubsystemXml (  )  ;", "KernelServices   servicesA    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   addOp    =    OperationTestCaseBase . getCacheAddOperation (  \" maximal \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" fred \"  )  ;", "ModelNode   removeOp    =    OperationTestCaseBase . getCacheRemoveOperation (  \" maximal \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" fred \"  )  ;", "ModelNode   result    =    servicesA . executeOperation ( addOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( removeOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( addOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalCacheAddRemoveAddSequence"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    getSubsystemXml (  )  ;", "KernelServices   servicesA    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   addOp    =    OperationTestCaseBase . getCacheAddOperation (  \" maximal \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" fred \"  )  ;", "ModelNode   removeOp    =    OperationTestCaseBase . getCacheRemoveOperation (  \" maximal \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" fred \"  )  ;", "ModelNode   result    =    servicesA . executeOperation ( addOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( removeOp )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( removeOp )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . FAILED ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalCacheRemoveRemoveSequence"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   JGroupsSubsystemInitialization (  )  . require ( CommonUnaryRequirement . OUTBOUND _ SOCKET _ BINDING ,     \" hotrod - server -  1  \"  ,     \" hotrod - server -  2  \"  )  . require ( CommonUnaryRequirement . DATA _ SOURCE ,     \" ExampleDS \"  ,     \" new - datasource \"  )  ;", "}", "METHOD_END"], "methodName": ["createAdditionalInitialization"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder ( this . createAdditionalInitialization (  )  )  ;", "}", "METHOD_END"], "methodName": ["createKernelServicesBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( BinaryKeyedJDBCStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["getBinaryKeyedJDBCCacheStoreAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( BinaryKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getBinaryKeyedJDBCCacheStoreLegacyAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  ;", "return   Operations . createAddOperation ( address ,    Collections . emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheAddOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheContainerAddress ( containerName )  . append ( cacheType ,    cacheName )  ;", "}", "METHOD_END"], "methodName": ["getCacheAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    OperationTestCaseBase . getCacheContainerAddress ( containerName )  ;", "return   Operations . createAddOperation ( address ,    Collections .  < Attribute ,    ModelNode > singletonMap ( CacheContainerResourceDefinition . Attribute . DEFAULT _ CACHE ,    new   ModelNode (  \" default \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheContainerAddOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   PathAddress . pathAddress ( InfinispanSubsystemResourceDefinition . PATH )  . append ( CacheContainerResourceDefinition . pathElement ( containerName )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheContainerAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getCacheContainerAddress ( containerName )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getCacheContainerReadOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "PathAddress   containerAddr    =    OperationTestCaseBase . getCacheContainerAddress ( containerName )  ;", "return   Util . createRemoveOperation ( containerAddr )  ;", "}", "METHOD_END"], "methodName": ["getCacheContainerRemoveOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "PathAddress   cacheAddress    =    OperationTestCaseBase . getCacheContainerAddress ( containerName )  ;", "return   Operations . createWriteAttributeOperation ( cacheAddress ,    attribute ,    new   ModelNode ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheContainerWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getCacheReadOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheRemoveOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapClearOperation ( cacheStoreAddress ,    StoreResourceDefinition . Attribute . PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["getCacheStoreClearPropertiesOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapGetOperation ( cacheStoreAddress ,    StoreResourceDefinition . Attribute . PROPERTIES ,    propertyName )  ;", "}", "METHOD_END"], "methodName": ["getCacheStoreGetPropertyOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createAddOperation ( OperationTestCaseBase . getCacheStorePropertyAddress ( containerName ,    cacheType ,    cacheName ,    propertyName )  )  ;", "operation . get ( ModelDescriptionConstants . VALUE )  . set ( value )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["getCacheStorePropertyAddOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCustomCacheStoreAddress ( containerName ,    cacheType ,    cacheName )  . append ( StorePropertyResourceDefinition . pathElement ( propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheStorePropertyAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . getWriteAttributeOperation ( OperationTestCaseBase . getCacheStorePropertyAddress ( containerName ,    cacheType ,    cacheName ,    propertyName )  ,    ModelDescriptionConstants . VALUE ,    new   ModelNode (  )  . set ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheStorePropertyWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapPutOperation ( cacheStoreAddress ,    StoreResourceDefinition . Attribute . PROPERTIES ,    propertyName ,    propertyValue )  ;", "}", "METHOD_END"], "methodName": ["getCacheStorePutPropertyOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getCustomCacheStoreAddress ( containerName ,    cacheType ,    cacheName )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getCacheStoreReadOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapRemoveOperation ( cacheStoreAddress ,    StoreResourceDefinition . Attribute . PROPERTIES ,    propertyName )  ;", "}", "METHOD_END"], "methodName": ["getCacheStoreRemovePropertyOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . getUndefineAttributeOperation ( cacheStoreAddress ,    StoreResourceDefinition . Attribute . PROPERTIES . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheStoreUndefinePropertiesOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getCustomCacheStoreAddress ( containerName ,    cacheType ,    cacheName )  ,    attribute ,    new   ModelNode ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheStoreWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  ,    attribute ,    new   ModelNode ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getCacheWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( CustomStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["getCustomCacheStoreAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( CustomStoreResourceDefinition . LEGACY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getCustomCacheStoreLegacyAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( FileStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["getFileCacheStoreAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( FileStoreResourceDefinition . LEGACY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getFileCacheStoreLegacyAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( JDBCStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["getJDBCCacheStoreAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getJDBCCacheStoreAddress ( containerName ,    cacheType ,    cacheName )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getJDBCCacheStoreReadOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getJDBCCacheStoreAddress ( containerName ,    cacheType ,    cacheName )  ,    attribute ,    new   ModelNode ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getJDBCCacheStoreWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( MixedKeyedJDBCStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["getMixedKeyedJDBCCacheStoreAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( MixedKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getMixedKeyedJDBCCacheStoreLegacyAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( RemoteStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["getRemoteCacheStoreAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( RemoteStoreResourceDefinition . LEGACY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getRemoteCacheStoreLegacyAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( StringKeyedJDBCStoreResourceDefinition . STRING _ JDBC _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getStringKeyedJDBCCacheStoreAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getCacheAddress ( containerName ,    cacheType ,    cacheName )  . append ( StringKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getStringKeyedJDBCCacheStoreLegacyAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   readResource ( OperationTestCaseBase . SUBSYSTEM _ XML _ FILE )  ;", "}", "METHOD_END"], "methodName": ["getSubsystemXml"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   stringKeyedTable    =    new   ModelNode (  )  . setEmptyObject (  )  ;", "stringKeyedTable . get ( StringTableResourceDefinition . Attribute . PREFIX . getName (  )  )  . set (  \" ispn _ bucket \"  )  ;", "stringKeyedTable . get ( TableResourceDefinition . DeprecatedAttribute . BATCH _ SIZE . getName (  )  )  . set (  1  0  0  )  ;", "stringKeyedTable . get ( TableResourceDefinition . Attribute . FETCH _ SIZE . getName (  )  )  . set (  1  0  0  )  ;", "ModelNode   idColumn    =    stringKeyedTable . get ( TableResourceDefinition . ColumnAttribute . ID . getName (  )  )  . setEmptyObject (  )  ;", "idColumn . get ( TableResourceDefinition . ColumnAttribute . ID . getColumnName (  )  . getName (  )  )  . set (  \" id \"  )  ;", "idColumn . get ( TableResourceDefinition . ColumnAttribute . ID . getColumnType (  )  . getName (  )  )  . set (  \" VARCHAR \"  )  ;", "ModelNode   dataColumn    =    stringKeyedTable . get ( TableResourceDefinition . ColumnAttribute . DATA . getName (  )  )  . setEmptyObject (  )  ;", "dataColumn . get ( TableResourceDefinition . ColumnAttribute . DATA . getColumnName (  )  . getName (  )  )  . set (  \" datum \"  )  ;", "dataColumn . get ( TableResourceDefinition . ColumnAttribute . DATA . getColumnType (  )  . getName (  )  )  . set (  \" BINARY \"  )  ;", "ModelNode   timestampColumn    =    stringKeyedTable . get ( TableResourceDefinition . ColumnAttribute . TIMESTAMP . getName (  )  )  . setEmptyObject (  )  ;", "timestampColumn . get ( TableResourceDefinition . ColumnAttribute . TIMESTAMP . getColumnName (  )  . getName (  )  )  . set (  \" version \"  )  ;", "timestampColumn . get ( TableResourceDefinition . ColumnAttribute . TIMESTAMP . getColumnType (  )  . getName (  )  )  . set (  \" BIGINT \"  )  ;", "return   stringKeyedTable ;", "}", "METHOD_END"], "methodName": ["createStringKeyedTable"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( this . getSubsystemXml (  )  )  . build (  )  ;", "PathAddress   address    =    OperationTestCaseBase . getCacheContainerAddress (  \" minimal \"  )  ;", "String   alias    =     \" alias 0  \"  ;", "ModelNode   operation    =     . createListAddOperation ( address ,    CacheContainerResourceDefinition . Attribute . ALIASES ,    alias )  ;", "ModelNode   result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =     . createListGetOperation ( address ,    CacheContainerResourceDefinition . Attribute . ALIASES ,     0  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals ( new   ModelNode ( alias )  ,    result . get ( ModelDescriptionConstants . RESULT )  )  ;", "operation    =     . createListRemoveOperation ( address ,    CacheContainerResourceDefinition . Attribute . ALIASES ,     0  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =     . createListGetOperation ( address ,    CacheContainerResourceDefinition . Attribute . ALIASES ,     0  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =    Util . createOperation (  \" add - alias \"  ,    address )  ;", "operation . get ( NAME )  . set ( alias )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =     . createListGetOperation ( address ,    CacheContainerResourceDefinition . Attribute . ALIASES ,     0  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "operation    =    Util . createOperation (  \" remove - alias \"  ,    address )  ;", "operation . get ( NAME )  . set ( alias )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =     . createListGetOperation ( address ,    CacheContainerResourceDefinition . Attribute . ALIASES ,     0  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAliases"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    getSubsystemXml (  )  ;", "KernelServices   servicesA    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   result    =    servicesA . executeOperation ( OperationTestCaseBase . getCacheContainerReadOperation (  \" maximal \"  ,    CacheContainerResourceDefinition . Attribute . DEFAULT _ CACHE )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" local \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( OperationTestCaseBase . getCacheContainerWriteOperation (  \" maximal \"  ,    CacheContainerResourceDefinition . Attribute . DEFAULT _ CACHE ,     \" new - default - cache \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( OperationTestCaseBase . getCacheContainerReadOperation (  \" maximal \"  ,    CacheContainerResourceDefinition . Attribute . DEFAULT _ CACHE )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" new - default - cache \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheContainerReadWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   stringKeyedTable    =    OperationsTestCase . createStringKeyedTable (  )  ;", "String   subsystemXml    =    getSubsystemXml (  )  ;", "KernelServices   servicesA    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   result    =    servicesA . executeOperation ( OperationTestCaseBase . getJDBCCacheStoreReadOperation (  \" maximal \"  ,    DistributedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" dist \"  ,    JDBCStoreResourceDefinition . Attribute . DATA _ SOURCE )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" ExampleDS \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( OperationTestCaseBase . getJDBCCacheStoreWriteOperation (  \" maximal \"  ,    DistributedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" dist \"  ,    JDBCStoreResourceDefinition . Attribute . DATA _ SOURCE ,     \" new - datasource \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( OperationTestCaseBase . getJDBCCacheStoreReadOperation (  \" maximal \"  ,    DistributedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" dist \"  ,    JDBCStoreResourceDefinition . Attribute . DATA _ SOURCE )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" new - datasource \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( OperationTestCaseBase . getJDBCCacheStoreReadOperation (  \" maximal \"  ,    DistributedCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" dist \"  ,    MixedKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . STRING _ TABLE )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals ( stringKeyedTable . asPropertyList (  )  . size (  )  ,    result . get ( ModelDescriptionConstants . RESULT )  . asPropertyList (  )  . size (  )  )  ;", "for    ( Property   property    :    stringKeyedTable . asPropertyList (  )  )     {", "Assert . assertTrue ( result . get ( ModelDescriptionConstants . RESULT )  . hasDefined ( property . getName (  )  )  )  ;", "Assert . assertEquals ( property . getValue (  )  ,    result . get ( ModelDescriptionConstants . RESULT )  . get ( property . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDistributedCacheJDBCStoreReadWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    getSubsystemXml (  )  ;", "KernelServices   servicesA    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   readOperation    =    OperationTestCaseBase . getCacheReadOperation (  \" maximal \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" local \"  ,    CacheResourceDefinition . Attribute . STATISTICS _ ENABLED )  ;", "ModelNode   result    =    servicesA . executeOperation ( readOperation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertTrue ( result . get ( ModelDescriptionConstants . RESULT )  . asBoolean (  )  )  ;", "ModelNode   writeOperation    =    OperationTestCaseBase . getCacheWriteOperation (  \" maximal \"  ,    LocalCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" local \"  ,    CacheResourceDefinition . Attribute . STATISTICS _ ENABLED ,     \" false \"  )  ;", "result    =    servicesA . executeOperation ( writeOperation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    servicesA . executeOperation ( readOperation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . asBoolean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalCacheReadWriteOperation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . createKernelServicesBuilder (  )  . setSubsystemXml ( this . getSubsystemXml (  )  )  . build (  )  ;", "PathAddress   address    =    OperationTestCaseBase . getRemoteCacheStoreAddress (  \" maximal \"  ,    InvalidationCacheResourceDefinition . WILDCARD _ PATH . getKey (  )  ,     \" invalid \"  )  ;", "String   key    =     \" infinispan . client . hotrod . ping _ on _ startup \"  ;", "String   value    =     \" true \"  ;", "ModelNode   operation    =    Operations . createMapPutOperation ( address ,    StoreResourceDefinition . Attribute . PROPERTIES ,    key ,    value )  ;", "ModelNode   result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =    Operations . createMapGetOperation ( address ,    StoreResourceDefinition . Attribute . PROPERTIES ,    key )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals ( value ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "operation    =    Operations . createMapRemoveOperation ( address ,    StoreResourceDefinition . Attribute . PROPERTIES ,    key )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =    Operations . createMapGetOperation ( address ,    StoreResourceDefinition . Attribute . PROPERTIES ,    key )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "PathAddress   propertyAddress    =    address . append ( StorePropertyResourceDefinition . pathElement ( key )  )  ;", "operation    =    Operations . createAddOperation ( propertyAddress ,    Collections .  < controller . Attribute ,    ModelNode > singletonMap ( new   SimpleAttribute ( StorePropertyResourceDefinition . VALUE )  ,    new   ModelNode ( value )  )  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =    Operations . createMapGetOperation ( address ,    StoreResourceDefinition . Attribute . PROPERTIES ,    key )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals ( value ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "value    =     \" false \"  ;", "operation    =    Operations . createWriteAttributeOperation ( propertyAddress ,    new   SimpleAttribute ( StorePropertyResourceDefinition . VALUE )  ,    new   ModelNode ( value )  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =    Operations . createMapGetOperation ( address ,    StoreResourceDefinition . Attribute . PROPERTIES ,    key )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals ( value ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "operation    =    Operations . createReadAttributeOperation ( propertyAddress ,    new   SimpleAttribute ( StorePropertyResourceDefinition . VALUE )  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals ( value ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "operation    =    Util . createRemoveOperation ( propertyAddress )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "operation    =    Operations . createMapGetOperation ( address ,    StoreResourceDefinition . Attribute . PROPERTIES ,    key )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStoreProperties"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( RemoteStoreResourceDefinition . PATH ,    RemoteStoreResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( RemoteStoreResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   AttributeConverter . DefaultAttributeConverter (  )     {", "@ Override", "protected   void   convertAttribute ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    TransformationContext   context )     {", "if    ( attributeValue . isDefined (  )  )     {", "List < ModelNode >    remoteServers    =    attributeValue . clone (  )  . asList (  )  ;", "ModelNode   legacyListObject    =    new   ModelNode (  )  ;", "for    ( ModelNode   server    :    remoteServers )     {", "ModelNode   legacyListItem    =    new   ModelNode (  )  ;", "legacyListItem . get (  \" outbound - socket - binding \"  )  . set ( server )  ;", "legacyListObject . add ( legacyListItem )  ;", "}", "attributeValue . set ( legacyListObject )  ;", "}", "}", "}  ,    RemoteStoreResourceDefinition . Attribute . SOCKET _ BINDINGS . getDefinition (  )  )  ;", "}", "StoreResourceDefinition . buildTransformation ( version ,    builder ,    RemoteStoreResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.RemoteStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( ReplicatedCacheResourceDefinition . WILDCARD _ PATH )  ;", "SharedStateCacheResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ReplicatedCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" replicated - cache \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ReplicatedCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "SimpleAttributeDefinitionBuilder   builder    =    new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "return   builder . setValidator ( validatorBuilder . configure ( builder )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ScheduledThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( this . maxThreads ,    this . keepAliveTime )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ScheduledThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   UndefinedAttributesDiscardPolicy ( this . getAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDiscardPolicy"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ScheduledThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" thread - pool \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ScheduledThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   segments    /     ( SegmentsAndVirtualNodeConverter . SEGMENTS _ PER _ VIRTUAL _ NODE )  ;", "}", "METHOD_END"], "methodName": ["segmentsToVirtualNodes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.SegmentsAndVirtualNodeConverter"}, {"methodBody": ["METHOD_START", "{", "int   virtualNodes    =    SegmentsAndVirtualNodeConverter . VIRTUAL _ NODES _ DEFAULT ;", "try    {", "virtualNodes    =    SegmentsAndVirtualNodeConverter . segmentsToVirtualNodes ( Integer . parseInt ( segmentsValue )  )  ;", "}    catch    ( NumberFormatException   nfe )     {", "}", "return   Integer . toString ( virtualNodes )  ;", "}", "METHOD_END"], "methodName": ["segmentsToVirtualNodes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.SegmentsAndVirtualNodeConverter"}, {"methodBody": ["METHOD_START", "{", "int   virtualNodes    =    SegmentsAndVirtualNodeConverter . VIRTUAL _ NODES _ DEFAULT ;", "if    ( segments . isDefined (  )  )     {", "virtualNodes    =    SegmentsAndVirtualNodeConverter . segmentsToVirtualNodes ( segments . asInt (  )  )  ;", "}", "return   new   ModelNode ( virtualNodes )  ;", "}", "METHOD_END"], "methodName": ["segmentsToVirtualNodes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.SegmentsAndVirtualNodeConverter"}, {"methodBody": ["METHOD_START", "{", "return   virtualNodes    *     ( SegmentsAndVirtualNodeConverter . SEGMENTS _ PER _ VIRTUAL _ NODE )  ;", "}", "METHOD_END"], "methodName": ["virtualNodesToSegments"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.SegmentsAndVirtualNodeConverter"}, {"methodBody": ["METHOD_START", "{", "int   segments    =    SegmentsAndVirtualNodeConverter . SEGMENTS _ DEFAULT ;", "try    {", "segments    =    SegmentsAndVirtualNodeConverter . virtualNodesToSegments ( Integer . parseInt ( virtualNodesValue )  )  ;", "}    catch    ( NumberFormatException   nfe )     {", "}", "return   Integer . toString ( segments )  ;", "}", "METHOD_END"], "methodName": ["virtualNodesToSegments"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.SegmentsAndVirtualNodeConverter"}, {"methodBody": ["METHOD_START", "{", "int   segments    =    SegmentsAndVirtualNodeConverter . SEGMENTS _ DEFAULT ;", "if    ( virtualNodes . isDefined (  )  )     {", "segments    =    SegmentsAndVirtualNodeConverter . virtualNodesToSegments ( virtualNodes . asInt (  )  )  ;", "}", "return   new   ModelNode ( segments )  ;", "}", "METHOD_END"], "methodName": ["virtualNodesToSegments"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.SegmentsAndVirtualNodeConverter"}, {"methodBody": ["METHOD_START", "{", "StateTransferResourceDefinition . buildTransformation ( version ,    builder )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . addChildResource ( PartitionHandlingResourceDefinition . PATH ,    RequiredChildResourceDiscardPolicy . REJECT _ AND _ WARN )  ;", "} else    {", "PartitionHandlingResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "if    ( InfinispanModel . VERSION _  2  _  0  _  0  . requiresTransformation ( version )  )     {", "final   ResourceTransformationDescriptionBuilder   backupsBuilder    =    builder . addChildResource ( BackupsResourceDefinition . PATH ,    RequiredChildResourceDiscardPolicy . REJECT _ AND _ WARN )  ;", "backupsBuilder . rejectChildResource ( BackupResourceDefinition . WILDCARD _ PATH )  ;", "builder . addChildResource ( BackupForResourceDefinition . PATH ,    RequiredChildResourceDiscardPolicy . REJECT _ AND _ WARN )  ;", "} else    {", "BackupsResourceDefinition . buildTransformation ( version ,    builder )  ;", "BackupForResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "Clustered . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.SharedStateCacheResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( StateTransferResourceDefinition . PATH ,    StateTransferResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( StateTransferResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( StateTransferResourceDefinition . Attribute . TIMEOUT . getDefinition (  )  )  ,    StateTransferResourceDefinition . Attribute . TIMEOUT . getDefinition (  )  )  . setValueConverter ( new   DefaultValueAttributeConverter ( StateTransferResourceDefinition . Attribute . CHUNK _ SIZE . getDefinition (  )  )  ,    StateTransferResourceDefinition . Attribute . CHUNK _ SIZE . getDefinition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StateTransferResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StateTransferResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "DEPRECATED _ LOGGER . operationDeprecated ( Operations . getName ( operation )  ,    context . getCurrentAddress (  )  . toCLIStyleString (  )  )  ;", "}", "METHOD_END"], "methodName": ["operationDeprecated"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StorePropertyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement ( PROPERTY ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StorePropertyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setDiscard ( ALWAYS ,     . Attribute . MAX _ BATCH _ SIZE . getDefinition (  )  )  ;", "}", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . addOperationTransformationOverride ( ADD )  . setCustomOperationTransformer ( new   SimpleOperationTransformer ( new   LegacyPropertyAddOperationTransformer (  )  )  )  . inheritResourceAttributeDefinitions (  )  . end (  )  ;", "builder . setCustomResourceTransformer ( new   LegacyPropertyResourceTransformer (  )  )  ;", "builder . addRawOperationTransformationOverride ( MAP _ GET _ DEFINITION . getName (  )  ,    new   SimpleOperationTransformer ( new   LegacyPropertyMapGetOperationTransformer (  )  )  )  ;", "for    ( String   name    :    Operations . getAllWriteAttributeOperationNames (  )  )     {", "builder . addOperationTransformationOverride ( name )  . inheritResourceAttributeDefinitions (  )  . setCustomOperationTransformer ( new   LegacyPropertyWriteOperationTransformer (  (    address )     -  >    address . getParent (  )  . append ( path )  )  )  . end (  )  ;", "}", "}", "StoreWriteThroughResourceDefinition . buildTransformation ( version ,    builder )  ;", "StoreWriteBehindResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" store \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( StoreWriteBehindResourceDefinition . PATH ,    StoreWriteBehindResourceDefinition . LEGACY _ PATH )     :    parent . addChildResource ( StoreWriteBehindResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( StoreWriteBehindResourceDefinition . DeprecatedAttribute . FLUSH _ LOCK _ TIMEOUT . getDefinition (  )  )  ,    StoreWriteBehindResourceDefinition . DeprecatedAttribute . FLUSH _ LOCK _ TIMEOUT . getDefinition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StoreWriteBehindResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StoreWriteBehindResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" write \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StoreWriteResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . discardChildResource (  . PATH )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StoreWriteThroughResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( StringKeyedJDBCStoreResourceDefinition . PATH ,    StringKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )     :    InfinispanModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )     ?    parent . addChildRedirection ( StringKeyedJDBCStoreResourceDefinition . PATH ,    StringKeyedJDBCStoreResourceDefinition . STRING _ JDBC _ PATH )     :    parent . addChildResource ( StringKeyedJDBCStoreResourceDefinition . PATH )  ;", "JDBCStoreResourceDefinition . buildTransformation ( version ,    builder ,    StringKeyedJDBCStoreResourceDefinition . PATH )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . setCustomResourceTransformer ( new   ResourceTransformer (  )     {", "@ SuppressWarnings (  \" deprecation \"  )", "@ Override", "public   void   transformResource ( ResourceTransformationContext   context ,    PathAddress   address ,    Resource   resource )    throws   OperationFailedException    {", "final   ModelNode   model    =    resource . getModel (  )  ;", "final   ModelNode   maxBatchSize    =    model . remove ( StoreResourceDefinition . Attribute . MAX _ BATCH _ SIZE . getName (  )  )  ;", "final   ModelNode   stringTableModel    =    Tools . readModel ( resource . removeChild ( StringTableResourceDefinition . PATH )  )  ;", "if    (  ( stringTableModel    !  =    null )     &  &     ( stringTableModel . isDefined (  )  )  )     {", "model . get ( StringKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE . getName (  )  )  . set ( stringTableModel )  ;", "model . get ( StringKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE . getName (  )  )  . get ( TableResourceDefinition . DeprecatedAttribute . BATCH _ SIZE . getName (  )  )  . set (  ( maxBatchSize    !  =    null    ?    maxBatchSize    :    new   ModelNode (  )  )  )  ;", "}", "final   ModelNode   properties    =    model . remove ( StoreResourceDefinition . Attribute . PROPERTIES . getName (  )  )  ;", "final   ResourceTransformationContext   childContext    =    context . addTransformedResource ( EMPTY _ ADDRESS ,    resource )  ;", "LegacyPropertyResourceTransformer . transformPropertiesToChildrenResources ( properties ,    address ,    childContext )  ;", "context . processChildren ( resource )  ;", "}", "}  )  ;", "}", "StringTableResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StringKeyedJDBCStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( StringTableResourceDefinition . PATH )  ;", "TableResourceDefinition . buildTransformation ( version ,    builder )  ;", "if    ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "OperationTransformer   addTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   storeAddress    =    Operations . getPathAddress ( operation )  . getParent (  )  ;", "ModelNode   value    =    new   ModelNode (  )  ;", "for    ( Class <  ?    extends   Attribute >    attributeClass    :    Arrays . asList ( StringTableResourceDefinition . Attribute . class ,    TableResourceDefinition . Attribute . class ,    TableResourceDefinition . ColumnAttribute . class )  )     {", "for    ( Attribute   attribute    :    attributeClass . getEnumConstants (  )  )     {", "String   name    =    attribute . getName (  )  ;", "if    ( operation . hasDefined ( name )  )     {", "value . get ( name )  . set ( operation . get ( name )  )  ;", "}", "}", "}", "return   value . isDefined (  )     ?    Operations . createWriteAttributeOperation ( storeAddress ,    StringKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE ,    value )     :    Operations . createUndefineAttributeOperation ( storeAddress ,    StringKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE )  ;", "}", "}  ;", "builder . addRawOperationTransformationOverride ( ADD ,    new   SimpleOperationTransformer ( addTransformer )  )  ;", "OperationTransformer   removeTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   storeAddress    =    Operations . getPathAddress ( operation )  . getParent (  )  ;", "return   Operations . createUndefineAttributeOperation ( storeAddress ,    StringKeyedJDBCStoreResourceDefinition . DeprecatedAttribute . TABLE )  ;", "}", "}  ;", "builder . addRawOperationTransformationOverride ( REMOVE ,    new   SimpleOperationTransformer ( removeTransformer )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.StringTableResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( InfinispanModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "SimpleAttributeConverter . Converter   converter    =     ( PathAddress   address , String   name , ModelNode   value , ModelNode   model , TransformationContext   context )     -  >     {", "PathAddress   storeAddress    =    address . getParent (  )  ;", "PathElement   storePath    =    storeAddress . getLastElement (  )  ;", "if    (  ( storePath . equals ( StringKeyedJDBCStoreResourceDefinition . STRING _ JDBC _ PATH )  )     |  |     ( storePath . equals ( StringKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )  )  )     {", "storeAddress    =    storeAddress . getParent (  )  . append ( StringKeyedJDBCStoreResourceDefinition . PATH )  ;", "} else", "if    ( storePath . equals ( BinaryKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )  )     {", "storeAddress    =    storeAddress . getParent (  )  . append ( BinaryKeyedJDBCStoreResourceDefinition . PATH )  ;", "} else", "if    ( storePath . equals ( MixedKeyedJDBCStoreResourceDefinition . LEGACY _ PATH )  )     {", "storeAddress    =    storeAddress . getParent (  )  . append ( MixedKeyedJDBCStoreResourceDefinition . PATH )  ;", "}", "ModelNode   store    =    context . readResourceFromRoot ( storeAddress )  . getModel (  )  ;", "value . set (  ( store . hasDefined ( StoreResourceDefinition . Attribute . MAX _ BATCH _ SIZE . getName (  )  )     ?    store . get ( StoreResourceDefinition . Attribute . MAX _ BATCH _ SIZE . getName (  )  )     :    StoreResourceDefinition . Attribute . MAX _ BATCH _ SIZE . getDefinition (  )  . getDefaultValue (  )  )  )  ;", "}  ;", "builder . getAttributeBuilder (  )  . setValueConverter ( new   SimpleAttributeConverter ( converter )  ,     . DeprecatedAttribute . BATCH _ SIZE . getDefinition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.TableResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" table \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.TableResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "SimpleAttributeDefinitionBuilder   builder    =    new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "return   builder . setValidator ( validatorBuilder . configure ( builder )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( this . minThreads ,    this . maxThreads ,    this . queueLength ,    this . keepAliveTime )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   UndefinedAttributesDiscardPolicy ( this . getAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDiscardPolicy"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" thread - pool \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( transformers . isEmpty (  )  )  )     {", "builder . addOperationTransformationOverride ( operationName )  . setCustomOperationTransformer ( new   ChainedOperationTransformer ( transformers )  )  . inheritResourceAttributs (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildOperationTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.TransactionResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( transformers . isEmpty (  )  )  )     {", "builder . addOperationTransformationOverride ( operationName )  . setCustomOperationTransformer ( new   AttributeOperationTransformer ( transformers )  )  . inheritResourceAttributs (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildOperationTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.TransactionResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =     ( InfinispanModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     ?    parent . addChildRedirection ( TransactionResourceDefinition . PATH ,    TransactionResourceDefinition . LEGACY _ PATH ,    RequiredChildResourceDiscardPolicy . NEVER )     :    parent . addChildResource ( TransactionResourceDefinition . PATH )  ;", "List < OperationTransformer >    addOperationTransformers    =    new   LinkedList <  >  (  )  ;", "List < OperationTransformer >    removeOperationTransformers    =    new   LinkedList <  >  (  )  ;", "Map < String ,    OperationTransformer >    readAttributeTransformers    =    new   HashMap <  >  (  )  ;", "Map < String ,    OperationTransformer >    writeAttributeTransformers    =    new   HashMap <  >  (  )  ;", "Map < String ,    OperationTransformer >    undefineAttributeTransformers    =    new   HashMap <  >  (  )  ;", "if    ( InfinispanModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "OperationTransformer   addTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "if    ( operation . hasDefined ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  )     {", "ModelNode   mode    =    operation . get ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  ;", "if    (  (  ( mode . getType (  )  )     =  =     ( ModelType . STRING )  )     &  &     (  ( TransactionMode . valueOf ( mode . asString (  )  )  )     =  =     ( TransactionMode . BATCH )  )  )     {", "mode . set ( TransactionMode . NONE . name (  )  )  ;", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "return   Operations . createCompositeOperation ( operation ,    Operations . createWriteAttributeOperation ( TransactionResourceDefinition . cacheAddress ( address )  ,    CacheResourceDefinition . DeprecatedAttribute . BATCHING ,    new   ModelNode ( true )  )  )  ;", "}", "}", "return   operation ;", "}", "}  ;", "addOperationTransformers . add ( new   SimpleOperationTransformer ( addTransformer )  )  ;", "OperationTransformer   removeTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "return   Operations . createCompositeOperation ( operation ,    Operations . createUndefineAttributeOperation ( TransactionResourceDefinition . cacheAddress ( address )  ,    CacheResourceDefinition . DeprecatedAttribute . BATCHING )  )  ;", "}", "}  ;", "removeOperationTransformers . add ( new   SimpleOperationTransformer ( removeTransformer )  )  ;", "OperationTransformer   readAttributeOperationTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "return   Operations . createCompositeOperation ( Operations . createReadAttributeOperation ( TransactionResourceDefinition . cacheAddress ( address )  ,    CacheResourceDefinition . DeprecatedAttribute . BATCHING )  ,    operation )  ;", "}", "}  ;", "OperationResultTransformer   readAttributeResultTransformer    =    new   OperationResultTransformer (  )     {", "@ Override", "public   ModelNode   transformResult ( ModelNode   result )     {", "ModelNode   readBatchingResult    =    result . get (  0  )  ;", "return   readBatchingResult . asBoolean (  )     ?    new   ModelNode ( TransactionMode . BATCH . name (  )  )     :    result . get (  1  )  ;", "}", "}  ;", "readAttributeTransformers . put ( TransactionResourceDefinition . Attribute . MODE . getName (  )  ,    new   SimpleOperationTransformer ( readAttributeOperationTransformer ,    readAttributeResultTransformer )  )  ;", "OperationTransformer   writeAttributeTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "ModelNode   mode    =    Operations . getAttributeValue ( operation )  ;", "boolean   batching    =     (  ( mode . isDefined (  )  )     &  &     (  ( mode . getType (  )  )     =  =     ( ModelType . STRING )  )  )     ?     ( TransactionMode . valueOf ( mode . asString (  )  )  )     =  =     ( TransactionMode . BATCH )     :    false ;", "if    ( batching )     {", "mode . set ( TransactionMode . NONE . name (  )  )  ;", "}", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "return   Operations . createCompositeOperation ( operation ,    Operations . createWriteAttributeOperation ( TransactionResourceDefinition . cacheAddress ( address )  ,    CacheResourceDefinition . DeprecatedAttribute . BATCHING ,    new   ModelNode ( batching )  )  )  ;", "}", "}  ;", "writeAttributeTransformers . put ( TransactionResourceDefinition . Attribute . MODE . getName (  )  ,    new   SimpleOperationTransformer ( writeAttributeTransformer )  )  ;", "OperationTransformer   undefineAttributeTransformer    =    new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "return   Operations . createCompositeOperation ( operation ,    Operations . createUndefineAttributeOperation ( TransactionResourceDefinition . cacheAddress ( address )  ,    CacheResourceDefinition . DeprecatedAttribute . BATCHING )  )  ;", "}", "}  ;", "undefineAttributeTransformers . put ( TransactionResourceDefinition . Attribute . MODE . getName (  )  ,    new   SimpleOperationTransformer ( undefineAttributeTransformer )  )  ;", "ResourceTransformer   modeTransformer    =    new   ResourceTransformer (  )     {", "@ Override", "public   void   transformResource ( ResourceTransformationContext   context ,    PathAddress   address ,    Resource   resource )    throws   OperationFailedException    {", "ModelNode   model    =    resource . getModel (  )  ;", "if    ( model . hasDefined ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  )     {", "ModelNode   value    =    model . get ( TransactionResourceDefinition . Attribute . MODE . getName (  )  )  ;", "if    (  (  ( value . getType (  )  )     =  =     ( ModelType . STRING )  )     &  &     (  ( TransactionMode . valueOf ( value . asString (  )  )  )     =  =     ( TransactionMode . BATCH )  )  )     {", "value . set ( TransactionMode . NONE . name (  )  )  ;", "}", "}", "context . addTransformedResource ( EMPTY _ ADDRESS ,    resource )  . processChildren ( resource )  ;", "}", "}  ;", "builder . setCustomResourceTransformer ( modeTransformer )  ;", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( TransactionResourceDefinition . Attribute . STOP _ TIMEOUT . getDefinition (  )  )  ,    TransactionResourceDefinition . Attribute . STOP _ TIMEOUT . getDefinition (  )  )  ;", "}", "TransactionResourceDefinition . buildOperationTransformation ( builder ,    ADD ,    addOperationTransformers )  ;", "TransactionResourceDefinition . buildOperationTransformation ( builder ,    REMOVE ,    removeOperationTransformers )  ;", "TransactionResourceDefinition . buildOperationTransformation ( builder ,    READ _ ATTRIBUTE _ OPERATION ,    readAttributeTransformers )  ;", "TransactionResourceDefinition . buildOperationTransformation ( builder ,    WRITE _ ATTRIBUTE _ OPERATION ,    writeAttributeTransformers )  ;", "TransactionResourceDefinition . buildOperationTransformation ( builder ,    UNDEFINE _ ATTRIBUTE _ OPERATION ,    undefineAttributeTransformers )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.TransactionResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   transactionAddress . subAddress (  0  ,     (  ( transactionAddress . size (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheAddress"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.TransactionResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" transport \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.TransportResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   XMLAttribute   attribute    =    XMLAttribute . attributes . get ( localName )  ;", "return   attribute    =  =    null    ?    XMLAttribute . UNKNOWN    :    attribute ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.XMLAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.XMLAttribute"}, {"methodBody": ["METHOD_START", "{", "final   XMLElement   element    =    XMLElement . elements . get ( localName )  ;", "return   element    =  =    null    ?    XMLElement . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.XMLElement"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.clustering.infinispan.subsystem.XMLElement"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < Thread >    action    =     (  )     -  >     {", "thread . setContext ( this . loader )  ;", "return   thread ;", "}  ;", "return   WildFlySecurityManager . doUnchecked ( action )  ;", "}", "METHOD_END"], "methodName": ["setContextClassLoader"], "fileName": "org.jboss.as.clustering.jgroups.ClassLoaderThreadFactory"}, {"methodBody": ["METHOD_START", "{", "DatagramSocket   socket    =    mock ( DatagramSocket . class )  ;", "this . subject . close ( socket )  ;", "verify ( socket )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["closeDatagramSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "MulticastSocket   socket    =    mock ( MulticastSocket . class )  ;", "this . subject . close ( socket )  ;", "verify ( socket )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["closeMulticastSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "ServerSocket   socket    =    mock ( ServerSocket . class )  ;", "this . subject . close ( socket )  ;", "verify ( socket )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["closeServerSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "Socket   socket    =    mock ( Socket . class )  ;", "this . subject . close ( socket )  ;", "verify ( socket )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["closeSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "DatagramSocket   socket 1     =    mock ( DatagramSocket . class )  ;", "DatagramSocket   socket 2     =    mock ( DatagramSocket . class )  ;", "DatagramSocket   socket 3     =    mock ( DatagramSocket . class )  ;", "DatagramSocket   socket 4     =    mock ( DatagramSocket . class )  ;", "DatagramSocket   socket 5     =    mock ( DatagramSocket . class )  ;", "InetAddress   localhost    =    InetAddress . getLocalHost (  )  ;", "SocketAddress   socketAddress    =    new   InetSocketAddress ( localhost ,     2  )  ;", "when ( this . manager . createDatagramSocket (  \" test \"  ,    new   InetSocketAddress (  0  )  )  )  . thenReturn ( socket 1  )  ;", "when ( this . manager . createDatagramSocket (  \" test \"  ,    new   InetSocketAddress (  1  )  )  )  . thenReturn ( socket 2  )  ;", "when ( this . manager . createDatagramSocket (  \" test \"  ,    socketAddress )  )  . thenReturn ( socket 3  )  ;", "when ( this . manager . createDatagramSocket (  \" test \"  ,    new   InetSocketAddress ( localhost ,     1  )  )  )  . thenReturn ( socket 4  )  ;", "when ( this . manager . createDatagramSocket (  \" test \"  )  )  . thenReturn ( socket 5  )  ;", "DatagramSocket   result 1     =    this . subject . createDatagramSocket (  \" test \"  )  ;", "DatagramSocket   result 2     =    this . subject . createDatagramSocket (  \" test \"  ,     1  )  ;", "DatagramSocket   result 3     =    this . subject . createDatagramSocket (  \" test \"  ,    socketAddress )  ;", "DatagramSocket   result 4     =    this . subject . createDatagramSocket (  \" test \"  ,     1  ,    localhost )  ;", "DatagramSocket   result 5     =    this . subject . createDatagramSocket (  \" test \"  ,    null )  ;", "assertSame ( socket 1  ,    result 1  )  ;", "assertSame ( socket 2  ,    result 2  )  ;", "assertSame ( socket 3  ,    result 3  )  ;", "assertSame ( socket 4  ,    result 4  )  ;", "assertSame ( socket 5  ,    result 5  )  ;", "}", "METHOD_END"], "methodName": ["createDatagramSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "MulticastSocket   socket 1     =    mock ( MulticastSocket . class )  ;", "MulticastSocket   socket 2     =    mock ( MulticastSocket . class )  ;", "MulticastSocket   socket 3     =    mock ( MulticastSocket . class )  ;", "MulticastSocket   socket 4     =    mock ( MulticastSocket . class )  ;", "SocketAddress   address    =    new   InetSocketAddress ( InetAddress . getLocalHost (  )  ,     1  )  ;", "when ( this . manager . createMulticastSocket (  \" test \"  ,    new   InetSocketAddress (  0  )  )  )  . thenReturn ( socket 1  )  ;", "when ( this . manager . createMulticastSocket (  \" test \"  ,    new   InetSocketAddress (  1  )  )  )  . thenReturn ( socket 2  )  ;", "when ( this . manager . createMulticastSocket (  \" test \"  ,    address )  )  . thenReturn ( socket 3  )  ;", "when ( this . manager . createMulticastSocket (  \" test \"  )  )  . thenReturn ( socket 4  )  ;", "MulticastSocket   result 1     =    this . subject . createMulticastSocket (  \" test \"  )  ;", "MulticastSocket   result 2     =    this . subject . createMulticastSocket (  \" test \"  ,     1  )  ;", "MulticastSocket   result 3     =    this . subject . createMulticastSocket (  \" test \"  ,    address )  ;", "MulticastSocket   result 4     =    this . subject . createMulticastSocket (  \" test \"  ,    null )  ;", "assertSame ( socket 1  ,    result 1  )  ;", "assertSame ( socket 2  ,    result 2  )  ;", "assertSame ( socket 3  ,    result 3  )  ;", "assertSame ( socket 4  ,    result 4  )  ;", "}", "METHOD_END"], "methodName": ["createMulticastSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "ManagedServerSocketFactory   factory    =    mock ( ManagedServerSocketFactory . class )  ;", "ServerSocket   socket 1     =    mock ( ServerSocket . class )  ;", "ServerSocket   socket 2     =    mock ( ServerSocket . class )  ;", "ServerSocket   socket 3     =    mock ( ServerSocket . class )  ;", "ServerSocket   socket 4     =    mock ( ServerSocket . class )  ;", "InetAddress   localhost    =    InetAddress . getLocalHost (  )  ;", "when ( this . manager . getServerSocketFactory (  )  )  . thenReturn ( factory )  ;", "when ( factory . createServerSocket (  \" test \"  )  )  . thenReturn ( socket 1  )  ;", "when ( factory . createServerSocket (  \" test \"  ,     1  )  )  . thenReturn ( socket 2  )  ;", "when ( factory . createServerSocket (  \" test \"  ,     1  ,     0  )  )  . thenReturn ( socket 3  )  ;", "when ( factory . createServerSocket (  \" test \"  ,     1  ,     0  ,    localhost )  )  . thenReturn ( socket 4  )  ;", "ServerSocket   result 1     =    this . subject . createServerSocket (  \" test \"  )  ;", "ServerSocket   result 2     =    this . subject . createServerSocket (  \" test \"  ,     1  )  ;", "ServerSocket   result 3     =    this . subject . createServerSocket (  \" test \"  ,     1  ,     0  )  ;", "ServerSocket   result 4     =    this . subject . createServerSocket (  \" test \"  ,     1  ,     0  ,    localhost )  ;", "assertSame ( socket 1  ,    result 1  )  ;", "assertSame ( socket 2  ,    result 2  )  ;", "assertSame ( socket 3  ,    result 3  )  ;", "assertSame ( socket 4  ,    result 4  )  ;", "}", "METHOD_END"], "methodName": ["createServerSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "ManagedSocketFactory   factory    =    mock ( ManagedSocketFactory . class )  ;", "Socket   socket 1     =    mock ( Socket . class )  ;", "Socket   socket 2     =    mock ( Socket . class )  ;", "Socket   socket 3     =    mock ( Socket . class )  ;", "Socket   socket 4     =    mock ( Socket . class )  ;", "Socket   socket 5     =    mock ( Socket . class )  ;", "InetAddress   localhost    =    InetAddress . getLocalHost (  )  ;", "when ( this . manager . getSocketFactory (  )  )  . thenReturn ( factory )  ;", "when ( factory . createSocket (  \" test \"  )  )  . thenReturn ( socket 1  )  ;", "when ( factory . createSocket (  \" test \"  ,    localhost ,     1  )  )  . thenReturn ( socket 2  )  ;", "when ( factory . createSocket (  \" test \"  ,     \" host \"  ,     1  )  )  . thenReturn ( socket 3  )  ;", "when ( factory . createSocket (  \" test \"  ,    localhost ,     1  ,    localhost ,     2  )  )  . thenReturn ( socket 4  )  ;", "when ( factory . createSocket (  \" test \"  ,     \" host \"  ,     1  ,    localhost ,     2  )  )  . thenReturn ( socket 5  )  ;", "Socket   result 1     =    this . subject . createSocket (  \" test \"  )  ;", "Socket   result 2     =    this . subject . createSocket (  \" test \"  ,    localhost ,     1  )  ;", "Socket   result 3     =    this . subject . createSocket (  \" test \"  ,     \" host \"  ,     1  )  ;", "Socket   result 4     =    this . subject . createSocket (  \" test \"  ,    localhost ,     1  ,    localhost ,     2  )  ;", "Socket   result 5     =    this . subject . createSocket (  \" test \"  ,     \" host \"  ,     1  ,    localhost ,     2  )  ;", "assertSame ( socket 1  ,    result 1  )  ;", "assertSame ( socket 2  ,    result 2  )  ;", "assertSame ( socket 3  ,    result 3  )  ;", "assertSame ( socket 4  ,    result 4  )  ;", "assertSame ( socket 5  ,    result 5  )  ;", "}", "METHOD_END"], "methodName": ["createSocket"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "reset ( this . manager )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.jboss.as.clustering.jgroups.ManagedSocketFactoryTest"}, {"methodBody": ["METHOD_START", "{", "return   this . sharedSecret ;", "}", "METHOD_END"], "methodName": ["getSharedSecret"], "fileName": "org.jboss.as.clustering.jgroups.auth.BinaryAuthToken"}, {"methodBody": ["METHOD_START", "{", "cipher . init ( Cipher . ENCRYPT _ MODE ,    key )  ;", "return   cipher . doFinal ( data )  ;", "}", "METHOD_END"], "methodName": ["encryptedSharedSecret"], "fileName": "org.jboss.as.clustering.jgroups.auth.CipherAuthToken"}, {"methodBody": ["METHOD_START", "{", "if    ( JGroupsModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setDiscard ( UNDEFINED ,     . Attribute . STATISTICS _ ENABLED . getDefinition (  )  )  . addRejectCheck ( DEFINED ,     . Attribute . STATISTICS _ ENABLED . getDefinition (  )  )  . end (  )  ;", "}", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "AttributeConverter   typeConverter    =    new   AttributeConverter . DefaultAttributeConverter (  )     {", "@ Override", "protected   void   convertAttribute ( PathAddress   address ,    String   name ,    ModelNode   value ,    TransformationContext   context )     {", "if    (  !  ( value . isDefined (  )  )  )     {", "value . set ( address . getLastElement (  )  . getValue (  )  )  ;", "}", "}", "}  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker (  . Attribute . MODULE . getDefinition (  )  . getDefaultValue (  )  )  ,     . Attribute . MODULE . getDefinition (  )  )  . addRejectCheck ( DEFINED ,     . Attribute . MODULE . getDefinition (  )  )  . setValueConverter ( typeConverter ,     . DeprecatedAttribute . TYPE . getDefinition (  )  )  . end (  )  ;", "builder . addRawOperationTransformationOverride ( MAP _ GET _ DEFINITION . getName (  )  ,    new   SimpleOperationTransformer ( new   LegacyPropertyMapGetOperationTransformer (  )  )  )  ;", "for    ( String   opName    :    Operations . getAllWriteAttributeOperationNames (  )  )     {", "builder . addOperationTransformationOverride ( opName )  . inheritResourceAttributeDefinitions (  )  . setCustomOperationTransformer ( new   LegacyPropertyWriteOperationTransformer (  )  )  ;", "}", "}", "PropertyResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.AbstractProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.AuthProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.AuthTokenResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" token \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.AuthTokenResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "this . statisticsEnabled    =    enabled ;", "return   this ;", "}", "METHOD_END"], "methodName": ["statisticsEnabled"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ChannelBuilder"}, {"methodBody": ["METHOD_START", "{", "DynamicDiscardPolicy   discardAutoGeneratedChannel    =    new   DynamicDiscardPolicy (  )     {", "@ Override", "public   DiscardPolicy   checkResource ( TransformationContext   context ,    PathAddress   address )     {", "@ SuppressWarnings (  \" deprecation \"  )", "ModelNode   defaultStack    =    context . readResourceFromRoot ( address . getParent (  )  )  . getModel (  )  . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK . getName (  )  )  ;", "return   context . readResourceFromRoot ( address )  . getModel (  )  . get (  . Attribute . STACK . getName (  )  )  . equals ( defaultStack )     ?    DiscardPolicy . SILENT    :    DiscardPolicy . NEVER ;", "}", "}  ;", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "DynamicDiscardPolicy   channelDiscardRejectPolicy    =    new   DynamicDiscardPolicy (  )     {", "@ Override", "public   DiscardPolicy   checkResource ( TransformationContext   context ,    PathAddress   address )     {", "DiscardPolicy   policy    =    discardAutoGeneratedChannel . checkResource ( context ,    address )  ;", "if    ( policy    !  =     ( DiscardPolicy . NEVER )  )", "return   policy ;", "String   channelName    =    address . getLastElement (  )  . getValue (  )  ;", "PathAddress   rootAddress    =    address . subAddress (  0  ,     (  ( address . size (  )  )     -     2  )  )  ;", "PathAddress   subsystemAddress    =    rootAddress . append ( PathElement . pathElement ( SUBSYSTEM ,     \" infinispan \"  )  )  ;", "Resource   infinispanResource ;", "try    {", "infinispanResource    =    context . readResourceFromRoot ( subsystemAddress )  ;", "}    catch    ( Resource   ex )     {", "return   DiscardPolicy . REJECT _ AND _ WARN ;", "}", "ModelNode   infinispanModel    =    Tools . readModel ( infinispanResource )  ;", "if    ( infinispanModel . hasDefined (  \" cache - container \"  )  )     {", "for    ( ModelNode   container    :    infinispanModel . get (  \" cache - container \"  )  . asList (  )  )     {", "ModelNode   cacheContainer    =    container . get (  0  )  ;", "if    ( cacheContainer . hasDefined (  \" transport \"  )  )     {", "ModelNode   transport    =    cacheContainer . get (  \" transport \"  )  . get (  \" jgroups \"  )  ;", "if    ( transport . hasDefined (  \" channel \"  )  )     {", "String   channel    =    transport . get (  \" channel \"  )  . asString (  )  ;", "if    ( channel . equals ( channelName )  )     {", "return   DiscardPolicy . SILENT ;", "}", "} else    {", "ModelNode   subsystem    =    context . readResourceFromRoot ( address . subAddress (  0  ,     (  ( address . size (  )  )     -     1  )  )  )  . getModel (  )  ;", "if    ( subsystem . hasDefined ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL . getName (  )  )  )     {", "if    ( subsystem . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL . getName (  )  )  . asString (  )  . equals ( channelName )  )     {", "return   DiscardPolicy . SILENT ;", "}", "}", "}", "}", "}", "}", "return   DiscardPolicy . REJECT _ AND _ WARN ;", "}", "}  ;", "parent . addChildResource (  . WILDCARD _ PATH ,    channelDiscardRejectPolicy )  ;", "} else    {", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource (  . WILDCARD _ PATH ,    discardAutoGeneratedChannel )  ;", "if    ( JGroupsModel . VERSION _  4  _  0  _  0  . requiresTransformation ( version )  )     {", "DiscardAttributeChecker   discarder    =    new   DefaultDiscardAttributeChecker ( false ,    true )     {", "@ Override", "protected   boolean   isValueDiscardable ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    TransformationContext   context )     {", "return    (  !  ( attributeValue . isDefined (  )  )  )     |  |     ( attributeValue . equals ( new   ModelNode ( address . getLastElement (  )  . getValue (  )  )  )  )  ;", "}", "}  ;", "builder . getAttributeBuilder (  )  . setDiscard ( discarder ,     . Attribute . CLUSTER . getDefinition (  )  )  . addRejectCheck ( DEFINED ,     . Attribute . CLUSTER . getDefinition (  )  )  ;", "}", "ForkResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ChannelResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" channel \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ChannelResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "String   className    =    protocolName ;", "if    (  ( moduleName . equals ( AbstractProtocolResourceDefinition . Attribute . MODULE . getDefinition (  )  . getDefaultValue (  )  . asString (  )  )  )     &  &     (  !  ( protocolName . startsWith ( orconf . ProtocolConfiguration )  )  )  )     {", "className    =    String . join (  \"  .  \"  ,    orconf . ProtocolConfiguration ,    protocolName )  ;", "}", "try    {", "ModuleLoader   loader    =     (  ( ModuleLoader )     ( context . getServiceRegistry ( false )  . getRequiredService ( JBOSS _ SERVICE _ MODULE _ LOADER )  . getValue (  )  )  )  ;", "return   loader . loadModule ( moduleName )  . getClassLoader (  )  . loadClass ( className )  . asSubclass ( Protocol . class )  ;", "}    catch    ( ClassNotFoundException    |    ModuleLoadException   e )     {", "throw   JGroupsLogger . ROOT _ LOGGER . unableToLoadProtocolClass ( className )  ;", "}", "}", "METHOD_END"], "methodName": ["findProtocolClass"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ChannelRuntimeResourceRegistration"}, {"methodBody": ["METHOD_START", "{", "ProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.EncryptProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( ForkResourceDefinition . WILDCARD _ PATH )  ;", "ProtocolRegistration . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ForkResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" fork \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ForkResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   ProtocolResourceDefinition . pathElement ( String . join (  \"  .  \"  ,    ProtocolConfiguration ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.GenericProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JDBCProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . bindInfoFor ( JndiNameFactory . createJndiName ( JndiNameFactory . DEFAULT _ JNDI _ NAMESPACE ,    JGroupsExtension . SUBSYSTEM _ NAME ,     \" channel \"  ,    channel )  . getAbsoluteName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createChannelBinding"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsBindingFactory"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . bindInfoFor ( JndiNameFactory . createJndiName ( JndiNameFactory . DEFAULT _ JNDI _ NAMESPACE ,    JGroupsExtension . SUBSYSTEM _ NAME ,     \" factory \"  ,    stack )  . getAbsoluteName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createChannelFactoryBinding"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsBindingFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . buildKernelServices ( this . getSubsystemXml (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder ( xml )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder ( this . createAdditionalInitialization (  )  )  ;", "}", "METHOD_END"], "methodName": ["createKernelServicesBuilder"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder (  )  . setSubsystemXml ( xml )  ;", "}", "METHOD_END"], "methodName": ["createKernelServicesBuilder"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "Object [  ]  [  ]    data    =    new   Object [  ]  [  ]  {    new   Object [  ]  {    JGroupsSchema . VERSION _  1  _  1  ,     2  0     }  ,    new   Object [  ]  {    JGroupsSchema . VERSION _  2  _  0  ,     2  2     }  ,    new   Object [  ]  {    JGroupsSchema . VERSION _  3  _  0  ,     2  9     }  ,    new   Object [  ]  {    JGroupsSchema . VERSION _  4  _  0  ,     2  9     }  ,    new   Object [  ]  {    JGroupsSchema . VERSION _  5  _  0  ,     3  3     }  ,    new   Object [  ]  {    JGroupsSchema . VERSION _  6  _  0  ,     3  0     }     }  ;", "return   Arrays . asList ( data )  ;", "}", "METHOD_END"], "methodName": ["data"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )  )", "return ;", "final   KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   originalSubsystemModel    =    services . readWholeModel (  )  . get ( ResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "ModelNode   originalChannelModel    =    originalSubsystemModel . get ( ChannelResourceDefinition . pathElement (  \" ee \"  )  . getKeyValuePair (  )  )  ;", "ModelNode   originalForkModel    =    originalChannelModel . get ( ForkResourceDefinition . pathElement (  \" web \"  )  . getKeyValuePair (  )  )  ;", "Assert . assertTrue ( originalForkModel . isDefined (  )  )  ;", "originalForkModel . protect (  )  ;", "Assert . assertTrue (  (  0     <     ( originalForkModel . get ( ProtocolResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . keys (  )  . size (  )  )  )  )  ;", "ModelNode   originalStackModel    =    originalSubsystemModel . get ( StackResourceDefinition . pathElement (  \" maximal \"  )  . getKeyValuePair (  )  )  ;", "Assert . assertTrue ( originalStackModel . isDefined (  )  )  ;", "originalStackModel . protect (  )  ;", "final   PathAddress   subsystemAddress    =    PathAddress . pathAddress ( ResourceDefinition . PATH )  ;", "final   PathAddress   forkAddress    =    subsystemAddress . append ( ChannelResourceDefinition . pathElement (  \" ee \"  )  )  . append ( ForkResourceDefinition . pathElement (  \" web \"  )  )  ;", "final   PathAddress   stackAddress    =    subsystemAddress . append ( StackResourceDefinition . pathElement (  \" maximal \"  )  )  ;", "ModelNode   add    =    Operations . createAddOperation ( forkAddress . append ( ProtocolResourceDefinition . pathElement (  \" MERGE 3  \"  )  )  ,     0  )  ;", "ModelTestUtils . checkOutcome ( services . executeOperation ( add )  )  ;", "ModelNode   subsystemModel    =    services . readWholeModel (  )  . get ( ResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "ModelNode   channelModel    =    subsystemModel . get ( ChannelResourceDefinition . pathElement (  \" ee \"  )  . getKeyValuePair (  )  )  ;", "ModelNode   forkModel    =    channelModel . get ( ForkResourceDefinition . pathElement (  \" web \"  )  . getKeyValuePair (  )  )  ;", "Assert . assertEquals (  (  ( originalForkModel . keys (  )  . size (  )  )     +     1  )  ,    forkModel . get ( ProtocolResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . keys (  )  . size (  )  )  ;", "Assert . assertEquals (  \" MERGE 3  \"  ,    forkModel . get ( ProtocolResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . keys (  )  . iterator (  )  . next (  )  )  ;", "ModelNode   remove    =    Util . createRemoveOperation ( stackAddress . append ( ProtocolResourceDefinition . pathElement (  \" FD \"  )  )  )  ;", "ModelTestUtils . checkOutcome ( services . executeOperation ( remove )  )  ;", "add    =    Operations . createAddOperation ( stackAddress . append ( ProtocolResourceDefinition . pathElement (  \" FD \"  )  )  ,     3  )  ;", "ModelTestUtils . checkOutcome ( services . executeOperation ( add )  )  ;", "subsystemModel    =    services . readWholeModel (  )  . get ( ResourceDefinition . PATH . getKeyValuePair (  )  )  ;", "ModelNode   stackModel    =    subsystemModel . get ( StackResourceDefinition . pathElement (  \" maximal \"  )  . getKeyValuePair (  )  )  ;", "Assert . assertEquals ( originalStackModel ,    stackModel )  ;", "}", "METHOD_END"], "methodName": ["testIndexedAdds"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    ops    =    new   LinkedList <  >  (  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( ResourceDefinition . PATH )  ;", "PathAddress   udpAddress    =    subsystemAddress . append ( StackResourceDefinition . pathElement (  \" udp \"  )  )  ;", "ModelNode   op    =    Util . createAddOperation ( subsystemAddress )  ;", "op . get (  \" default - stack \"  )  . set (  \" udp \"  )  ;", "ops . add ( op )  ;", "op    =    Util . createAddOperation ( udpAddress )  ;", "ModelNode   transport    =    new   ModelNode (  )  ;", "transport . get (  \" type \"  )  . set (  \" UDP \"  )  ;", "transport . get (  \" socket - binding \"  )  . set (  \" jgroups - udp \"  )  ;", "ModelNode   protocols    =    new   ModelNode (  )  ;", "String [  ]    protocolList    =    new   String [  ]  {     \" PING \"  ,     \" MERGE 3  \"  ,     \" FD _ SOCK \"  ,     \" FD \"  ,     \" VERIFY _ SUSPECT \"  ,     \" BARRIER \"  ,     \" pbcast . NAKACK 2  \"  ,     \" UNICAST 3  \"  ,     \" pbcast . STABLE \"  ,     \" pbcast . GMS \"  ,     \" UFC \"  ,     \" MFC \"  ,     \" FRAG 2  \"  ,     \" RSVP \"     }  ;", "for    ( int   i    =     0  ;    i    <     ( protocolList . length )  ;    i +  +  )     {", "ModelNode   protocol    =    new   ModelNode (  )  ;", "protocol . get (  \" type \"  )  . set ( protocolList [ i ]  )  ;", "protocols . add ( protocol )  ;", "}", "op . get (  \" transport \"  )  . set ( transport )  ;", "op . get (  \" protocols \"  )  . set ( protocols )  ;", "ops . add ( op )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setBootOperations ( ops )  . build (  )  ;", "Assert . assertTrue (  \" Subsystem   boot   failed !  \"  ,    servicesA . isSuccessfulBoot (  )  )  ;", "final   ModelNode   modelA    =    servicesA . readWholeModel (  )  ;", "validateModel ( modelA )  ;", "servicesA . shutdown (  )  ;", "final   ModelNode   operation    =    createDescribeOperation (  )  ;", "final   ModelNode   result    =    servicesA . executeOperation ( operation )  ;", "Assert . assertTrue (  \" the   subsystem   describe   operation   has   to   generate   a   list   of   operations   to   recreate   the   subsystem \"  ,     (  !  ( result . hasDefined ( FAILURE _ DESCRIPTION )  )  )  )  ;", "final   List < ModelNode >    operations    =    result . get ( RESULT )  . asList (  )  ;", "servicesA . shutdown (  )  ;", "final   KernelServices   servicesC    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setBootOperations ( operations )  . build (  )  ;", "final   ModelNode   modelC    =    servicesC . readWholeModel (  )  ;", "compare ( modelA ,    modelC )  ;", "assertRemoveSubsystemResources ( servicesC ,    getIgnoredChildResourcesForRemovalTest (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLegacyOperations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    operations    =    super . parse ( getSubsystemXml (  )  )  ;", "Assert . assertEquals ( this . expectedOperationCount ,    operations . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseSubsystem"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setDiscard ( ALWAYS ,     . Attribute . DEFAULT _ CHANNEL . getDefinition (  )  )  . end (  )  ;", "}", "ChannelResourceDefinition . buildTransformation ( version ,    builder )  ;", "StackResourceDefinition . buildTransformation ( version ,    builder )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildTransformers"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "String   type    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . TYPE )  ;", "PathAddress   address    =    stackAddress . append ( ProtocolResourceDefinition . pathElement ( type )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseProtocolAttribute ( reader ,    i ,    operation )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseAuthProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAuthProtocol"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PLAIN _ TOKEN    :", "{", "this . parsePlainAuthToken ( reader ,    address ,    operations )  ;", "break ;", "}", "case   DIGEST _ TOKEN    :", "{", "this . parseDigestAuthToken ( reader ,    address ,    operations )  ;", "break ;", "}", "case   CIPHER _ TOKEN    :", "{", "this . parseCipherAuthToken ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "this . parseProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseAuthProtocolElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   SHARED _ SECRET _ CREDENTIAL _ REFERENCE    :", "{", ". readElement ( reader ,    operation ,    AuthTokenResourceDefinition . Attribute . SHARED _ SECRET )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseAuthTokenElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    subsystemAddress . append ( ChannelResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "ParseUtils . requireNoNamespaceAttribute ( reader ,    i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "break ;", "}", "case   STACK    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    ChannelResourceDefinition . Attribute . STACK )  ;", "break ;", "}", "case   MODULE    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    ChannelResourceDefinition . Attribute . MODULE )  ;", "break ;", "}", "case   CLUSTER    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  4  _  0  )  )     {", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    ChannelResourceDefinition . Attribute . CLUSTER )  ;", "break ;", "}", "}", "case   STATISTICS _ ENABLED    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    ChannelResourceDefinition . Attribute . STATISTICS _ ENABLED )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   FORK    :", "{", "this . parseFork ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseChannel"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "ParseUtils . requireNoNamespaceAttribute ( reader ,    i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   DEFAULT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CHANNEL    :", "{", "this . parseChannel ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseChannels"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    protocolAddress . append ( CipherAuthTokenResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   KEY _ ALIAS    :", "{", ". readAttribute ( reader ,    i ,    operation ,    CipherAuthTokenResourceDefinition . Attribute . KEY _ ALIAS )  ;", "break ;", "}", "case   KEY _ STORE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    CipherAuthTokenResourceDefinition . Attribute . KEY _ STORE )  ;", "break ;", "}", "case   ALGORITHM    :", "{", ". readAttribute ( reader ,    i ,    operation ,    CipherAuthTokenResourceDefinition . Attribute . ALGORITHM )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   KEY _ CREDENTIAL _ REFERENCE    :", "{", ". readElement ( reader ,    operation ,    CipherAuthTokenResourceDefinition . Attribute . KEY _ CREDENTIAL )  ;", "break ;", "}", "default    :", "{", "this . parseAuthTokenElement ( reader ,    address ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseCipherAuthToken"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    protocolAddress . append ( DigestAuthTokenResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   ALGORITHM    :", "{", ". readAttribute ( reader ,    i ,    operation ,    DigestAuthTokenResourceDefinition . Attribute . ALGORITHM )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseAuthTokenElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDigestAuthToken"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   type    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . TYPE )  ;", "PathAddress   address    =    stackAddress . append ( ProtocolResourceDefinition . pathElement ( type )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseEncryptProtocolAttribute ( reader ,    i ,    operation )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseEncryptProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEncryptProtocol"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   KEY _ ALIAS    :", "{", ". readAttribute ( reader ,    index ,    operation ,    EncryptProtocolResourceDefinition . Attribute . KEY _ ALIAS )  ;", "break ;", "}", "case   KEY _ STORE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    EncryptProtocolResourceDefinition . Attribute . KEY _ STORE )  ;", "break ;", "}", "default    :", "{", "parseProtocolAttribute ( reader ,    index ,    operation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseEncryptProtocolAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   KEY _ CREDENTIAL _ REFERENCE    :", "{", ". readElement ( reader ,    operation ,    EncryptProtocolResourceDefinition . Attribute . KEY _ CREDENTIAL )  ;", "break ;", "}", "default    :", "{", "this . parseProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseEncryptProtocolElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    channelAddress . append ( ForkResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "ParseUtils . requireNoNamespaceAttribute ( reader ,    i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROTOCOL    :", "{", "this . parseProtocol ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseFork"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   type    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . TYPE )  ;", "PathAddress   address    =    stackAddress . append ( ProtocolResourceDefinition . pathElement ( type )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseJDBCProtocolAttribute ( reader ,    i ,    operation )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseJDBCProtocol"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   DATA _ SOURCE    :", "{", ". readAttribute ( reader ,    index ,    operation ,    JDBCProtocolResourceDefinition . Attribute . DATA _ SOURCE )  ;", "break ;", "}", "default    :", "{", "parseProtocolAttribute ( reader ,    index ,    operation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseJDBCProtocolAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    protocolAddress . append ( PlainAuthTokenResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "ParseUtils . requireNoAttributes ( r )  ;", "while    (  ( r . hasNext (  )  )     &  &     (  ( r . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseAuthTokenElement ( r ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parsePlainAuthToken"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "ParseUtils . requireSingleAttribute ( reader ,    XMLAttribute . NAME . getLocalName (  )  )  ;", ". readElement ( reader ,    operation ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["parseProperty"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   type    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . TYPE )  ;", "PathAddress   address    =    stackAddress . append ( ProtocolResourceDefinition . pathElement ( type )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseProtocolAttribute ( reader ,    i ,    operation )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseProtocol"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   TYPE    :", "{", "break ;", "}", "case   SOCKET _ BINDING    :", "{", "String   protocol    =    Operations . getPathAddress ( operation )  . getLastElement (  )  . getValue (  )  ;", "Attribute   socketBindingAttribute    =    GenericProtocolResourceDefinition . DeprecatedAttribute . SOCKET _ BINDING ;", "for    ( ProtocolRegistration . MulticastProtocol   multicastProtocol    :    EnumSet . allOf ( ProtocolRegistration . MulticastProtocol . class )  )     {", "if    ( protocol . equals ( multicastProtocol . name (  )  )  )     {", "socketBindingAttribute    =    SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING ;", "break ;", "}", "}", ". readAttribute ( reader ,    index ,    operation ,    socketBindingAttribute )  ;", "break ;", "}", "case   DATA _ SOURCE    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", ". readAttribute ( reader ,    index ,    operation ,    JDBCProtocolResourceDefinition . Attribute . DATA _ SOURCE )  ;", "break ;", "}", "case   MODULE    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", ". readAttribute ( reader ,    index ,    operation ,    AbstractProtocolResourceDefinition . Attribute . MODULE )  ;", "break ;", "}", "}", "case   STATISTICS _ ENABLED    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", ". readAttribute ( reader ,    index ,    operation ,    AbstractProtocolResourceDefinition . Attribute . STATISTICS _ ENABLED )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseProtocolAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "{", "this . parseProperty ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseProtocolElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    stackAddress . append ( RelayResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   SITE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    RelayResourceDefinition . Attribute . SITE )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    (  !  ( operation . hasDefined ( RelayResourceDefinition . Attribute . SITE . getName (  )  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( XMLAttribute . SITE )  )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   REMOTE _ SITE    :", "{", "this . parseRemoteSite ( reader ,    address ,    operations )  ;", "break ;", "}", "case   PROPERTY    :", "{", "this . parseProperty ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseRelay"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   site    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    relayAddress . append ( RemoteSiteResourceDefinition . pathElement ( site )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "String   cluster    =    null ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "String   value    =    reader . getAttributeValue ( i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "break ;", "}", "case   STACK    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    RemoteSiteResourceDefinition . DeprecatedAttribute . STACK )  ;", "break ;", "}", "case   CLUSTER    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "cluster    =    value ;", "break ;", "}", "case   CHANNEL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    RemoteSiteResourceDefinition . Attribute . CHANNEL )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( JGroupsSubsystemResourceDefinition . PATH )  ;", "PathAddress   channelAddress    =    subsystemAddress . append ( ChannelResourceDefinition . pathElement ( value )  )  ;", "ModelNode   channelOperation    =    operations . get ( channelAddress )  ;", "if    ( channelOperation    !  =    null )     {", "String   stack ;", "if    ( channelOperation . hasDefined ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  )     {", "stack    =    channelOperation . get ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  . asString (  )  ;", "} else    {", "stack    =    operations . get ( subsystemAddress )  . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK . getName (  )  )  . asString (  )  ;", "}", "JGroupsSubsystemXMLReader . setAttribute ( reader ,    stack ,    operation ,    RemoteSiteResourceDefinition . DeprecatedAttribute . STACK )  ;", "}", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "if    (  !  ( operation . hasDefined ( RemoteSiteResourceDefinition . Attribute . CHANNEL . getName (  )  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( XMLAttribute . CHANNEL )  )  ;", "}", "} else    {", "if    (  !  ( operation . hasDefined ( RemoteSiteResourceDefinition . DeprecatedAttribute . STACK . getName (  )  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( XMLAttribute . STACK )  )  ;", "}", "String   channel    =     ( cluster    !  =    null )     ?    cluster    :    site ;", "JGroupsSubsystemXMLReader . setAttribute ( reader ,    channel ,    operation ,    RemoteSiteResourceDefinition . Attribute . CHANNEL )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( JGroupsSubsystemResourceDefinition . PATH )  ;", "PathAddress   channelAddress    =    subsystemAddress . append ( ChannelResourceDefinition . pathElement ( channel )  )  ;", "ModelNode   channelOperation    =    Util . createAddOperation ( channelAddress )  ;", "String   stack    =    operation . get ( RemoteSiteResourceDefinition . DeprecatedAttribute . STACK . getName (  )  )  . asString (  )  ;", "JGroupsSubsystemXMLReader . setAttribute ( reader ,    stack ,    channelOperation ,    ChannelResourceDefinition . Attribute . STACK )  ;", "operations . put ( channelAddress ,    channelOperation )  ;", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseRemoteSite"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   type    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . TYPE )  ;", "PathAddress   address    =    stackAddress . append ( ProtocolResourceDefinition . pathElement ( type )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseSocketDiscoveryProtocolAttribute ( reader ,    i ,    operation )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseSocketDiscoveryProtocol"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   OUTBOUND _ SOCKET _ BINDINGS    :", "{", ". readAttribute ( reader ,    index ,    operation ,    SocketDiscoveryProtocolResourceDefinition . Attribute . OUTBOUND _ SOCKET _ BINDINGS )  ;", "break ;", "}", "default    :", "{", "parseProtocolAttribute ( reader ,    index ,    operation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseSocketDiscoveryProtocolAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   type    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . TYPE )  ;", "PathAddress   address    =    stackAddress . append ( ProtocolResourceDefinition . pathElement ( type )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "this . parseSocketProtocolAttribute ( reader ,    i ,    operation )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "this . parseProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseSocketProtocol"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( index )  )  ;", "switch    ( attribute )     {", "case   SOCKET _ BINDING    :", "{", ". readAttribute ( reader ,    index ,    operation ,    SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING )  ;", "break ;", "}", "default    :", "{", "parseProtocolAttribute ( reader ,    index ,    operation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseSocketProtocolAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . NAME )  ;", "PathAddress   address    =    subsystemAddress . append ( StackResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "ParseUtils . requireNoNamespaceAttribute ( reader ,    i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "break ;", "}", "case   STATISTICS _ ENABLED    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    StackResourceDefinition . Attribute . STATISTICS _ ENABLED )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   TRANSPORT    :", "{", "this . parseTransport ( reader ,    address ,    operations )  ;", "break ;", "}", "case   PROTOCOL    :", "{", "this . parseProtocol ( reader ,    address ,    operations )  ;", "break ;", "}", "case   RELAY    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  2  _  0  )  )     {", "this . parseRelay ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   SOCKET _ PROTOCOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "this . parseSocketProtocol ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   SOCKET _ DISCOVERY _ PROTOCOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "this . parseSocketDiscoveryProtocol ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   JDBC _ PROTOCOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "this . parseJDBCProtocol ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   ENCRYPT _ PROTOCOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "this . parseEncryptProtocol ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   AUTH _ PROTOCOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  5  _  0  )  )     {", "this . parseAuthProtocol ( reader ,    address ,    operations )  ;", "break ;", "}", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseStack"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "ParseUtils . requireNoNamespaceAttribute ( reader ,    i )  ;", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   DEFAULT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   STACK    :", "{", "this . parseStack ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseStacks"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    parentAddress . append ( pool . getPathElement (  )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   MIN _ THREADS    :", ". readAttribute ( reader ,    i ,    operation ,    pool . getMinThreads (  )  )  ;", "break ;", "case   MAX _ THREADS    :", ". readAttribute ( reader ,    i ,    operation ,    pool . getMaxThreads (  )  )  ;", "break ;", "case   QUEUE _ LENGTH    :", "if    ( this . schema . since ( JGroupsSchema . VERSION _  6  _  0  )  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", ". readAttribute ( reader ,    i ,    operation ,    pool . getQueueLength (  )  )  ;", "break ;", "case   KEEPALIVE _ TIME    :", ". readAttribute ( reader ,    i ,    operation ,    pool . getKeepAliveTime (  )  )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "ParseUtils . requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseThreadPool"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   type    =    JGroupsSubsystemXMLReader . require ( reader ,    XMLAttribute . TYPE )  ;", "PathAddress   address    =    stackAddress . append ( TransportResourceDefinition . pathElement ( type )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   SHARED    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . Attribute . SHARED )  ;", "break ;", "}", "case   SOCKET _ BINDING    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . Attribute . SOCKET _ BINDING )  ;", "break ;", "}", "case   DIAGNOSTICS _ SOCKET _ BINDING    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . Attribute . DIAGNOSTICS _ SOCKET _ BINDING )  ;", "break ;", "}", "case   DEFAULT _ EXECUTOR    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . ThreadingAttribute . DEFAULT _ EXECUTOR )  ;", "break ;", "}", "case   OOB _ EXECUTOR    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . ThreadingAttribute . OOB _ EXECUTOR )  ;", "break ;", "}", "case   TIMER _ EXECUTOR    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . ThreadingAttribute . TIMER _ EXECUTOR )  ;", "break ;", "}", "case   THREAD _ FACTORY    :", "{", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . ThreadingAttribute . THREAD _ FACTORY )  ;", "break ;", "}", "case   SITE    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  1  _  1  )  )     {", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . Attribute . SITE )  ;", "break ;", "}", "}", "case   RACK    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  1  _  1  )  )     {", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . Attribute . RACK )  ;", "break ;", "}", "}", "case   MACHINE    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  1  _  1  )  )     {", "JGroupsSubsystemXMLReader . readAttribute ( reader ,    i ,    operation ,    TransportResourceDefinition . Attribute . MACHINE )  ;", "break ;", "}", "}", "default    :", "{", "this . parseProtocolAttribute ( reader ,    i ,    operation )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   DEFAULT _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . DEFAULT ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   INTERNAL _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  6  _  0  )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . INTERNAL ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   OOB _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  6  _  0  )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . OOB ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "case   TIMER _ THREAD _ POOL    :", "{", "if    ( this . schema . since ( JGroupsSchema . VERSION _  6  _  0  )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( this . schema . since ( JGroupsSchema . VERSION _  3  _  0  )  )     {", "this . parseThreadPool ( ThreadPoolResourceDefinition . TIMER ,    reader ,    address ,    operations )  ;", "break ;", "}", "}", "default    :", "{", "this . parseProtocolElement ( reader ,    address ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTransport"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "JGroupsSubsystemXMLReader . setAttribute ( reader ,    reader . getAttributeValue ( index )  ,    operation ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["readAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition   definition    =    attribute . getDefinition (  )  ;", "AttributeParser   parser    =    definition . getParser (  )  ;", "if    ( parser . isParseAsElement (  )  )     {", "parser . parseElement ( definition ,    r ,    operation )  ;", "} else    {", "parser . parseAndSetParameter ( definition ,    r . getElementText (  )  ,    operation ,    r )  ;", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   value    =    reader . getAttributeValue ( null ,    attribute . getLocalName (  )  )  ;", "if    ( value    =  =    null )     {", "throw   ParseUtils . missingRequired ( reader ,    attribute . getLocalName (  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getParser (  )  . parseAndSetParameter ( attribute . getDefinition (  )  ,    value ,    operation ,    reader )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLReader"}, {"methodBody": ["METHOD_START", "{", "for    ( E   protocol    :    EnumSet . allOf ( enumClass )  )     {", "if    ( name . equals ( protocol . name (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsName"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute   attribute    :    attributes )     {", "if    ( model . hasDefined ( attribute . getName (  )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasDefined"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getMarshaller (  )  . marshallAsAttribute ( attribute . getDefinition (  )  ,    model ,    true ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "JGroupsSubsystemXMLWriter . writeAttributes ( writer ,    model ,    EnumSet . allOf ( attributeClass )  )  ;", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "JGroupsSubsystemXMLWriter . writeAttributes ( writer ,    model ,    attributes . stream (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "Stream . Builder < Attribute >    objectAttributes    =    Stream . builder (  )  ;", "Iterable < A >    attributes    =    stream :  : iterator ;", "for    ( Attribute   attribute    :    attributes )     {", "if    (  ( attribute . getDefinition (  )  . getType (  )  )     =  =     ( ModelType . OBJECT )  )     {", "objectAttributes . add ( attribute )  ;", "} else    {", ". writeAttribute ( writer ,    model ,    attribute )  ;", "}", "}", "Iterable < Attribute >    elementAttributes    =    objectAttributes . build (  )  :  : iterator ;", "for    ( Attribute   attribute    :    elementAttributes )     {", ". writeElement ( writer ,    model ,    attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( XMLElement . forAuthTokenName ( token . getName (  )  )  . getLocalName (  )  )  ;", "if    ( PlainAuthTokenResourceDefinition . PATH . getValue (  )  . equals ( token . getName (  )  )  )     {", ". writeAttributes ( writer ,    token . getValue (  )  ,    AuthTokenResourceDefinition . Attribute . class )  ;", "}", "if    ( DigestAuthTokenResourceDefinition . PATH . getValue (  )  . equals ( token . getName (  )  )  )     {", ". writeAttributes ( writer ,    token . getValue (  )  ,    Stream . concat ( EnumSet . allOf ( AuthTokenResourceDefinition . Attribute . class )  . stream (  )  ,    EnumSet . allOf ( DigestAuthTokenResourceDefinition . Attribute . class )  . stream (  )  )  )  ;", "}", "if    ( CipherAuthTokenResourceDefinition . PATH . getValue (  )  . equals ( token . getName (  )  )  )     {", ". writeAttributes ( writer ,    token . getValue (  )  ,    Stream . concat ( EnumSet . allOf ( AuthTokenResourceDefinition . Attribute . class )  . stream (  )  ,    EnumSet . allOf ( CipherAuthTokenResourceDefinition . Attribute . class )  . stream (  )  )  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeAuthToken"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getMarshaller (  )  . marshallAsElement ( attribute . getDefinition (  )  ,    model ,    true ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeAttribute ( XMLAttribute . TYPE . getLocalName (  )  ,    property . getName (  )  )  ;", ". writeAttributes ( writer ,    property . getValue (  )  ,    EnumSet . complementOf ( EnumSet . of ( AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeGenericProtocolAttributes"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( XMLElement . forProtocolName ( property . getName (  )  )  . getLocalName (  )  )  ;", ". writeProtocolAttributes ( writer ,    property )  ;", ". writeElement ( writer ,    property . getValue (  )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeProtocol"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "JGroupsSubsystemXMLWriter . writeGenericProtocolAttributes ( writer ,    property )  ;", "String   protocol    =    property . getName (  )  ;", "if    ( JGroupsSubsystemXMLWriter . containsName ( ProtocolRegistration . MulticastProtocol . class ,    protocol )  )     {", "JGroupsSubsystemXMLWriter . writeAttributes ( writer ,    property . getValue (  )  ,    SocketBindingProtocolResourceDefinition . Attribute . class )  ;", "} else", "if    ( JGroupsSubsystemXMLWriter . containsName ( ProtocolRegistration . JdbcProtocol . class ,    protocol )  )     {", "JGroupsSubsystemXMLWriter . writeAttributes ( writer ,    property . getValue (  )  ,    JDBCProtocolResourceDefinition . Attribute . class )  ;", "} else", "if    ( JGroupsSubsystemXMLWriter . containsName ( ProtocolRegistration . EncryptProtocol . class ,    protocol )  )     {", "JGroupsSubsystemXMLWriter . writeAttributes ( writer ,    property . getValue (  )  ,    EncryptProtocolResourceDefinition . Attribute . class )  ;", "} else", "if    ( JGroupsSubsystemXMLWriter . containsName ( ProtocolRegistration . InitialHostsProtocol . class ,    protocol )  )     {", "JGroupsSubsystemXMLWriter . writeAttributes ( writer ,    property . getValue (  )  ,    SocketDiscoveryProtocolResourceDefinition . Attribute . class )  ;", "} else", "if    ( JGroupsSubsystemXMLWriter . containsName ( ProtocolRegistration . AuthProtocol . class ,    protocol )  )     {", "JGroupsSubsystemXMLWriter . writeAuthToken ( writer ,    property . getValue (  )  . get ( AuthTokenResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . asProperty (  )  )  ;", "} else    {", "JGroupsSubsystemXMLWriter . writeAttributes ( writer ,    property . getValue (  )  ,    GenericProtocolResourceDefinition . DeprecatedAttribute . class )  ;", "}", "}", "METHOD_END"], "methodName": ["writeProtocolAttributes"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( XMLElement . RELAY . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    relay ,    RelayResourceDefinition . Attribute . class )  ;", "if    ( relay . hasDefined ( RemoteSiteResourceDefinition . WILDCARD _ PATH . getKey (  )  )  )     {", "for    ( Property   property    :    relay . get ( RemoteSiteResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . asPropertyList (  )  )     {", "writer . writeStartElement ( XMLElement . REMOTE _ SITE . getLocalName (  )  )  ;", "writer . writeAttribute ( XMLAttribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", ". writeAttributes ( writer ,    property . getValue (  )  ,    EnumSet . allOf ( RemoteSiteResourceDefinition . Attribute . class )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeRelay"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "PathElement   path    =    pool . getPathElement (  )  ;", "if    ( transport . get ( path . getKey (  )  )  . hasDefined ( path . getValue (  )  )  )     {", "ModelNode   threadPool    =    transport . get ( path . getKeyValuePair (  )  )  ;", "if    (  . hasDefined ( threadPool ,    pool . getAttributes (  )  )  )     {", "writer . writeStartElement ( element . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    threadPool ,    pool . getAttributes (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeThreadPoolElements"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( XMLElement . TRANSPORT . getLocalName (  )  )  ;", ". writeGenericProtocolAttributes ( writer ,    property )  ;", "ModelNode   transport    =    property . getValue (  )  ;", ". writeAttributes ( writer ,    transport ,    TransportResourceDefinition . Attribute . class )  ;", ". writeAttributes ( writer ,    transport ,    TransportResourceDefinition . ThreadingAttribute . class )  ;", ". writeElement ( writer ,    transport ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  ;", ". writeThreadPoolElements ( XMLElement . DEFAULT _ THREAD _ POOL ,    ThreadPoolResourceDefinition . DEFAULT ,    writer ,    transport )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeTransport"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsSubsystemXMLWriter"}, {"methodBody": ["METHOD_START", "{", "return   new   AdditionalInitialization (  )  . require ( CommonUnaryRequirement . SOCKET _ BINDING ,     \" jgroups - tcp \"  ,     \" jgroups - udp \"  ,     \" jgroups - udp - fd \"  ,     \" some - binding \"  ,     \" jgroups - diagnostics \"  ,     \" jgroups - mping \"  ,     \" jgroups - tcp - fd \"  ,     \" jgroups - state - xfr \"  )  ;", "}", "METHOD_END"], "methodName": ["createAdditionalInitialization"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( JGroupsSubsystemResourceDefinition . PATH )  ;", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requireation ( version )  )     {", "config . addFailedAttribute ( subsystemAddress . append ( ChannelResourceDefinition . WILDCARD _ PATH )  ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( subsystemAddress . append ( StackResourceDefinition . WILDCARD _ PATH )  . append ( TransportResourceDefinition . WILDCARD _ PATH )  . append ( ThreadPoolResourceDefinition . WILDCARD _ PATH )  ,    REJECTED _ RESOURCE )  ;", "}", "if    ( JGroupsModel . VERSION _  2  _  0  _  0  . requireation ( version )  )     {", "PathAddress   stackAddress    =    subsystemAddress . append ( StackResourceDefinition . WILDCARD _ PATH )  ;", "PathAddress   relayAddress    =    stackAddress . append ( RelayResourceDefinition . PATH )  ;", "config . addFailedAttribute ( relayAddress ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( relayAddress . append ( RemoteSiteResourceDefinition . WILDCARD _ PATH )  ,    REJECTED _ RESOURCE )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["createFailedOperationTransformationConfig"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   String . format ( pattern ,    version . getMavenGavVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["formatArtifact"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   JGroupsTransformersTestCase . formatArtifact (  \" as : jboss - as - clustering - jgroups :  % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["formatEAP6SubsystemArtifact"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   JGroupsTransformersTestCase . formatArtifact (  \" eap : wildfly - clustering - jgroups - extension :  % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["formatEAP7SubsystemArtifact"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "switch    ( version )     {", "case   EAP _  6  _  4  _  0     :", "case   EAP _  6  _  4  _  7     :", "return   new   String [  ]  {     . formatEAP 6 SubsystemArtifact ( version )     }  ;", "case   EAP _  7  _  0  _  0     :", "return   new   String [  ]  {     . formatEAP 7 SubsystemArtifact ( version )  ,     . formatArtifact (  \" eap : wildfly - clustering - common :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - service :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - jgroups - spi :  % s \"  ,    version )     }  ;", "case   EAP _  7  _  1  _  0     :", "return   new   String [  ]  {     . formatEAP 7 SubsystemArtifact ( version )  ,     . formatArtifact (  \" eap : wildfly - clustering - common :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - service :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - jgroups - spi :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - spi :  % s \"  ,    version )     }  ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "switch    ( controllerVersion )     {", "case   EAP _  6  _  4  _  0     :", "case   EAP _  6  _  4  _  7     :", "return   Model . VERSION _  1  _  3  _  0  ;", "case   EAP _  7  _  0  _  0     :", "return   Model . VERSION _  4  _  0  _  0  ;", "case   EAP _  7  _  1  _  0     :", "return   Model . VERSION _  5  _  0  _  0  ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getModelVersion"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getTransportUndefinePropertiesOperation (  \" maximal \"  ,     \" TCP \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getTransportPutPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  ,     \" true \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  ,     \" tcp _ nodelay \"  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getTransportPutPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  ,     \" false \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  ,     \" tcp _ nodelay \"  ,     \" true \"  ,     \" loopback \"  ,     \" false \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getTransportPutPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  ,     \" true \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  ,     \" tcp _ nodelay \"  ,     \" true \"  ,     \" loopback \"  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getTransportRemovePropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  ,     \" loopback \"  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getTransportPutPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  ,     \" false \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  ,     \" tcp _ nodelay \"  ,     \" false \"  ,     \" loopback \"  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getTransportClearPropertiesOperation (  \" maximal \"  ,     \" TCP \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolUndefinePropertiesOperation (  \" maximal \"  ,     \" MPING \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  ,     \" true \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  ,     \" send _ on _ all _ interfaces \"  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" false \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  ,     \" send _ on _ all _ interfaces \"  ,     \" true \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" false \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolRemovePropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  ,     \" send _ on _ all _ interfaces \"  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolRemovePropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" true \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  ,     \" receive _ on _ all _ interfaces \"  ,     \" true \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" false \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  ,     \" receive _ on _ all _ interfaces \"  ,     \" false \"  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    OperationTestCaseBase . getProtocolClearPropertiesOperation (  \" maximal \"  ,     \" MPING \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  )  ;", "ModelNode   composite    =    new   ModelNode (  )  ;", "composite . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . COMPOSITE )  ;", "composite . get ( ModelDescriptionConstants . OP _ ADDR )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" true \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getTransportPutPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  ,     \" true \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  ,     \" true \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getTransportPutPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  ,     \" false \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  ,     \" send _ on _ all _ interfaces \"  ,     \" true \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" false \"  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  ,     \" tcp _ nodelay \"  ,     \" false \"  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolRemovePropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolRemovePropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getTransportPutPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getTransportRemovePropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" tcp _ nodelay \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  ,     \" loopback \"  ,     \" false \"  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . setEmptyList (  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  ,     \" false \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getProtocolPutPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" true \"  )  )  ;", "composite . get ( ModelDescriptionConstants . STEPS )  . add ( OperationTestCaseBase . getTransportRemovePropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    composite )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" false \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" send _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  \" true \"  )  ,    version ,    OperationTestCaseBase . getProtocolGetPropertyOperation (  \" maximal \"  ,     \" MPING \"  ,     \" receive _ on _ all _ interfaces \"  )  )  ;", "PropertiesTestUtil . checkMapResults ( services ,    new   ModelNode (  )  ,    version ,    OperationTestCaseBase . getTransportGetPropertyOperation (  \" maximal \"  ,     \" TCP \"  ,     \" loopback \"  )  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getProtocolAddress (  \" maximal \"  ,     \" MPING \"  )  ,     \" send _ on _ all _ interfaces \"  ,     \" false \"  ,     \" receive _ on _ all _ interfaces \"  ,     \" true \"  )  ;", "PropertiesTestUtil . checkMapModels ( services ,    version ,    OperationTestCaseBase . getTransportAddress (  \" maximal \"  ,     \" TCP \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertiesMapOperationsTest"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   result    =    new   ModelNode (  )  ;", "result . get ( OUTCOME )  . set ( SUCCESS )  ;", "result . get ( RESULT )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["success"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   stackAddr    =    PathAddress . pathAddress ( ModelDescriptionConstants . SUBSYSTEM ,    getMainSubsystemName (  )  )  . append (  \" stack \"  ,     \" test \"  )  ;", "ModelNode   addStack    =    Util . createAddOperation ( stackAddr )  ;", "PropertiesTestUtil . executeOpInBothControllersWithAttachments ( services ,    version ,    addStack )  ;", "final   PathAddress   transportAddr    =    stackAddr . append (  \" transport \"  ,     \" tcp \"  )  ;", "ModelNode   addTransport    =    Util . createAddOperation ( transportAddr )  ;", "addTransport . get ( SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING . getName (  )  )  . set (  \" some - binding \"  )  ;", "addTransport . get ( ModelDescriptionConstants . MODULE )  . set (  \" do . reject \"  )  ;", "TransformedOperation   op    =    services . executeInMainAndGetTheTransformedOperation ( addTransport ,    version )  ;", "Assert . assertTrue ( op . rejectOperation (  . success (  )  )  )  ;", "final   PathAddress   protocolAddr    =    stackAddr . append (  \" protocol \"  ,     \" PING \"  )  ;", "ModelNode   addProtocol    =    Util . createAddOperation ( protocolAddr )  ;", "addProtocol . get ( ModelDescriptionConstants . MODULE )  . set (  \" do . reject \"  )  ;", "op    =    services . executeInMainAndGetTheTransformedOperation ( addProtocol ,    version )  ;", "Assert . assertTrue ( op . rejectOperation (  . success (  )  )  )  ;", "op    =    services . executeInMainAndGetTheTransformedOperation ( Util . getWriteAttributeOperation ( transportAddr ,    ModelDescriptionConstants . MODULE ,     \" reject . this \"  )  ,    version )  ;", "Assert . assertTrue ( op . rejectOperation (  . success (  )  )  )  ;", "op    =    services . executeInMainAndGetTheTransformedOperation ( Util . getWriteAttributeOperation ( protocolAddr ,    ModelDescriptionConstants . MODULE ,     \" reject . this \"  )  ,    version )  ;", "Assert . assertTrue ( op . rejectOperation (  . success (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonMapTransformersWork"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelVersion   version    =    JGroupsTransformersTestCase . getModelVersion ( controller )  . getVersion (  )  ;", "final   String [  ]    dependencies    =    JGroupsTransformersTestCase . getDependencies ( controller )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( JGroupsTransformersTestCase . createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( JGroupsTransformersTestCase . createAdditionalInitialization (  )  ,    controller ,    version )  . addSingleChildFirstClass ( AdditionalInitialization . class )  . addMavenResourceURL ( dependencies )  . dontPersistXml (  )  ;", "KernelServices   services    =    builder . build (  )  ;", "Assert . assertTrue ( services . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    services . getLegacyServices ( version )  ;", "Assert . assertNotNull ( legacyServices )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    operations    =    builder . parseXmlResource (  \" subsystem - jgroups - transform - reject . xml \"  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( services ,    version ,    operations ,    JGroupsTransformersTestCase . createFailedOperationTransformationConfig ( version )  )  ;", "}", "METHOD_END"], "methodName": ["testRejections"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejections ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP640"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejections ( EAP _  7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP700"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejections ( EAP _  7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP710"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelVersion   version    =    JGroupsTransformersTestCase . getModelVersion ( controller )  . getVersion (  )  ;", "final   String [  ]    dependencies    =    JGroupsTransformersTestCase . getDependencies ( controller )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( JGroupsTransformersTestCase . createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" subsystem - jgroups - transform . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( JGroupsTransformersTestCase . createAdditionalInitialization (  )  ,    controller ,    version )  . addMavenResourceURL ( dependencies )  . addSingleChildFirstClass ( AdditionalInitialization . class )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   services    =    builder . build (  )  ;", "Assert . assertTrue ( services . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( services . getLegacyServices ( version )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( services ,    version ,    null ,    false )  ;", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "JGroupsTransformersTestCase . propertiesMapOperationsTest ( services ,    version )  ;", "testNonMapTransformersWork ( services ,    version )  ;", "}", "}", "METHOD_END"], "methodName": ["testTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP640"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation ( EAP _  7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP700"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation ( EAP _  7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP710"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.JGroupsTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    buildKernelServices (  )  ;", "String   stackName    =     \" legacyStack \"  ;", "ModelNode   result    =    services . execute ( TestCaseBase . getProtocolStackAddWithParameters ( stackName )  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getLegacyThreadPoolAdd ( stackName ,     \" default \"  )  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "ModelNode   op    =    TestCaseBase . getLegacyThreadPoolAdd ( stackName ,     \" default \"  )  ;", "op . get (  \" operation \"  )  . set (  \" write - attribute \"  )  ;", "op . get (  \" name \"  )  . set (  \" keepalive - time \"  )  ;", "op . get (  \" value \"  )  . set (  9  9  9  )  ;", "result    =    services . execute ( op )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "op    =    s . createReadResource ( TestCaseBase . getSubsystemAddress (  )  )  ;", "op . get ( INCLUDE _ ALIASES )  . set (  \" true \"  )  ;", "op . get ( RECURSIVE )  . set (  \" true \"  )  ;", "result    =    services . execute ( op )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "op    =    Util . create ( READ _ RESOURCE _ DESCRIPTION _ OPERATION ,    TestCaseBase . getSubsystemAddress (  )  )  ;", "op . get ( INCLUDE _ ALIASES )  . set (  \" true \"  )  ;", "op . get ( RECURSIVE )  . set (  \" true \"  )  ;", "result    =    services . execute ( op )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getLegacyTransportRemove ( stackName )  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getLegacyTransportAdd ( stackName ,     \" TCP \"  )  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getLegacyTransportRemove ( stackName )  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getLegacyTransportRemove ( stackName )  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . FAILED ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLegacyTransportAliasSequence"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    buildKernelServices (  )  ;", "ModelNode   operation    =    Operations . createCompositeOperation (  . addStackOp ,     . addTransportOp ,     . addProtocolOp )  ;", "ModelNode   result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . executeOperation (  . removeStackOp )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtocolStackAddRemoveAddSequence"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    buildKernelServices (  )  ;", "ModelNode   result    =    services . executeOperation (  . addStackOpWithParams )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . executeOperation (  . removeStackOp )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . executeOperation (  . removeStackOp )  ;", "Assert . assertEquals ( ModelDescriptionConstants . FAILED ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtocolStackAddRemoveSequenceWithParameters"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    buildKernelServices (  )  ;", "ModelNode   operation    =    Operations . createCompositeOperation (  . addStackOp ,     . addTransportOp ,     . addProtocolOp )  ;", "ModelNode   result    =    services . executeOperation ( operation )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . executeOperation (  . removeStackOp )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . executeOperation (  . removeStackOp )  ;", "Assert . assertEquals ( ModelDescriptionConstants . FAILED ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtocolStackRemoveRemoveSequence"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationSequencesTestCase"}, {"methodBody": ["METHOD_START", "{", "return   createKernelServicesBuilder ( new   AdditionalInitialization (  )  . require ( CommonUnaryRequirement . SOCKET _ BINDING ,     \" some - binding \"  ,     \" jgroups - diagnostics \"  ,     \" jgroups - mping \"  ,     \" jgroups - tcp - fd \"  ,     \" new - socket - binding \"  )  )  . setSubsystemXml ( this . getSubsystemXml (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createAddOperation ( OperationTestCaseBase . getLegacyTransportAddress ( stackName )  . append (  \" thread - pool \"  ,    threadPoolName )  )  ;", "}", "METHOD_END"], "methodName": ["getLegacyThreadPoolAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   op    =    Util . createAddOperation ( OperationTestCaseBase . getLegacyTransportAddress ( stackName )  )  ;", "op . get ( AbstractProtocolResourceDefinition . DeprecatedAttribute . TYPE . getName (  )  )  . set ( protocol )  ;", "op . get ( SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING . getName (  )  )  . set (  \" some - binding \"  )  ;", "return   op ;", "}", "METHOD_END"], "methodName": ["getLegacyTransportAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getProtocolStackAddress ( stackName )  . append ( TransportResourceDefinition . LEGACY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getLegacyTransportAddress"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getLegacyTransportAddress ( stackName )  )  ;", "}", "METHOD_END"], "methodName": ["getLegacyTransportRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createAddOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode [  ]    operations    =    new   ModelNode [  ]  {    OperationTestCaseBase . getProtocolAddOperation ( stackName ,    type )  ,    OperationTestCaseBase . getProtocolPropertyAddOperation ( stackName ,    type ,     \" A \"  ,     \" a \"  )  ,    OperationTestCaseBase . getProtocolPropertyAddOperation ( stackName ,    type ,     \" B \"  ,     \" b \"  )     }  ;", "return   Operations . createCompositeOperation ( operations )  ;", "}", "METHOD_END"], "methodName": ["getProtocolAddOperationWithProperties"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getProtocolStackAddress ( stackName )  . append ( ProtocolResourceDefinition . pathElement ( type )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolAddress"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapClearOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["getProtocolClearPropertiesOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapGetOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    propertyName )  ;", "}", "METHOD_END"], "methodName": ["getProtocolGetPropertyOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createAddOperation ( OperationTestCaseBase . getProtocolPropertyAddress ( stackName ,    protocolName ,    propertyName )  )  ;", "operation . get ( PropertyResourceDefinition . VALUE . getName (  )  )  . set ( propertyValue )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["getProtocolPropertyAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getProtocolAddress ( stackName ,    type )  . append ( PropertyResourceDefinition . pathElement ( propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolPropertyAddress"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getProtocolPropertyAddress ( stackName ,    protocolName ,    propertyName )  ,    new   SimpleAttribute ( PropertyResourceDefinition . VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolPropertyReadOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getProtocolPropertyAddress ( stackName ,    protocolName ,    propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolPropertyRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getProtocolPropertyAddress ( stackName ,    protocolName ,    propertyName )  ,    new   SimpleAttribute ( PropertyResourceDefinition . VALUE )  ,    new   ModelNode ( propertyValue )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolPropertyWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapPutOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    propertyName ,    propertyValue )  ;", "}", "METHOD_END"], "methodName": ["getProtocolPutPropertyOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getProtocolReadOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapRemoveOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    propertyName )  ;", "}", "METHOD_END"], "methodName": ["getProtocolRemovePropertyOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    values )  ;", "}", "METHOD_END"], "methodName": ["getProtocolSetPropertiesOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createAddOperation ( OperationTestCaseBase . getProtocolStackAddress ( stackName )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolStackAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode [  ]    operations    =    new   ModelNode [  ]  {    OperationTestCaseBase . getProtocolStackAddOperation ( stackName )  ,    OperationTestCaseBase . getTransportAddOperation ( stackName ,     \" UDP \"  )  ,    OperationTestCaseBase . getProtocolAddOperation ( stackName ,     \" PING \"  )  ,    OperationTestCaseBase . getProtocolAddOperation ( stackName ,     \" pbcast . FLUSH \"  )     }  ;", "return   Operations . createCompositeOperation ( operations )  ;", "}", "METHOD_END"], "methodName": ["getProtocolStackAddOperationWithParameters"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getSubsystemAddress (  )  . append ( StackResourceDefinition . pathElement ( stackName )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolStackAddress"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getProtocolStackAddress ( stackName )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolStackRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createUndefineAttributeOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["getProtocolUndefinePropertiesOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getProtocolAddress ( stackName ,    protocolName )  ,    attribute ,    new   ModelNode ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getProtocolWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createAddOperation ( OperationTestCaseBase . getSubsystemAddress (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubsystemAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   PathAddress . pathAddress ( JGroupsSubsystemResourceDefinition . PATH )  ;", "}", "METHOD_END"], "methodName": ["getSubsystemAddress"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getSubsystemAddress (  )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getSubsystemReadOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getSubsystemAddress (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubsystemRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getSubsystemAddress (  )  ,    attribute ,    new   ModelNode ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getSubsystemWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   readResource ( OperationTestCaseBase . SUBSYSTEM _ XML _ FILE )  ;", "}", "METHOD_END"], "methodName": ["getSubsystemXml"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createAddOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    protocol )  )  ;", "operation . get ( SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING . getName (  )  )  . set (  \" some - binding \"  )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["getTransportAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode [  ]    operations    =    new   ModelNode [  ]  {    OperationTestCaseBase . getTransportAddOperation ( stackName ,    type )  ,    OperationTestCaseBase . getProtocolPropertyAddOperation ( stackName ,    type ,     \" A \"  ,     \" a \"  )  ,    OperationTestCaseBase . getProtocolPropertyAddOperation ( stackName ,    type ,     \" B \"  ,     \" b \"  )     }  ;", "return   Operations . createCompositeOperation ( operations )  ;", "}", "METHOD_END"], "methodName": ["getTransportAddOperationWithProperties"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getProtocolStackAddress ( stackName )  . append ( TransportResourceDefinition . pathElement ( type )  )  ;", "}", "METHOD_END"], "methodName": ["getTransportAddress"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapClearOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["getTransportClearPropertiesOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapGetOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    propertyName )  ;", "}", "METHOD_END"], "methodName": ["getTransportGetPropertyOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createAddOperation ( OperationTestCaseBase . getTransportPropertyAddress ( stackName ,    type ,    propertyName )  )  ;", "operation . get ( PropertyResourceDefinition . VALUE . getName (  )  )  . set ( propertyValue )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["getTransportPropertyAddOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   OperationTestCaseBase . getTransportAddress ( stackName ,    type )  . append ( PropertyResourceDefinition . pathElement ( propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getTransportPropertyAddress"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getTransportPropertyAddress ( stackName ,    type ,    propertyName )  ,    new   SimpleAttribute ( PropertyResourceDefinition . VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["getTransportPropertyReadOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getTransportPropertyAddress ( stackName ,    type ,    propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getTransportPropertyRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getTransportPropertyAddress ( stackName ,    type ,    propertyName )  ,    new   SimpleAttribute ( PropertyResourceDefinition . VALUE )  ,    new   ModelNode ( propertyValue )  )  ;", "}", "METHOD_END"], "methodName": ["getTransportPropertyWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapPutOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    propertyName ,    propertyValue )  ;", "}", "METHOD_END"], "methodName": ["getTransportPutPropertyOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createReadAttributeOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["getTransportReadOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Util . createRemoveOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["getTransportRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createMapRemoveOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    propertyName )  ;", "}", "METHOD_END"], "methodName": ["getTransportRemovePropertyOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES ,    values )  ;", "}", "METHOD_END"], "methodName": ["getTransportSetPropertiesOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createUndefineAttributeOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    AbstractProtocolResourceDefinition . Attribute . PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["getTransportUndefinePropertiesOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "return   Operations . createWriteAttributeOperation ( OperationTestCaseBase . getTransportAddress ( stackName ,    type )  ,    attribute ,    new   ModelNode ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getTransportWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationTestCaseBase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", ". testProtocolAddRemoveOperation ( services ,     \" MERGE 2  \"  )  ;", ". testProtocolAddRemoveOperation ( services ,     \" pbcast . NAKACK \"  )  ;", ". testProtocolAddRemoveOperation ( services ,     \" UNICAST 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLegacyProtocolAddRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   result    =    services . executeOperation ( OperationTestCaseBase . getProtocolAddOperation (  \" minimal \"  ,    protocol )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . executeOperation ( OperationTestCaseBase . getProtocolRemoveOperation (  \" minimal \"  ,    protocol )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtocolAddRemoveOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   result    =    services . execute ( TestCaseBase . getProtocolGetProperty (  \" maximal \"  ,     \" MPING \"  ,     \" name \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" value \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . resolve (  )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolPutProperty (  \" maximal \"  ,     \" MPING \"  ,     \" name \"  ,     \" new - value \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolGetProperty (  \" maximal \"  ,     \" MPING \"  ,     \" name \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" new - value \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolRemoveProperty (  \" maximal \"  ,     \" MPING \"  ,     \" name \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolGetProperty (  \" maximal \"  ,     \" MPING \"  ,     \" name \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolPropertyAdd (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  ,     \" false \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolPropertyRead (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" false \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolGetProperty (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" false \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolPropertyWrite (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  ,     \" true \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolPropertyRead (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolGetProperty (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolPropertyRemove (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolGetProperty (  \" maximal \"  ,     \" MPING \"  ,     \" async _ discovery \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtocolPropertyReadWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   result    =    services . execute ( TestCaseBase . getProtocolStackAddWithParameters (  \" maximal 2  \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolRead (  \" maximal \"  ,     \" MPING \"  ,    SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" jgroups - mping \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolWrite (  \" maximal \"  ,     \" MPING \"  ,    SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING ,     \" new - socket - binding \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getProtocolRead (  \" maximal \"  ,     \" MPING \"  ,    SocketBindingProtocolResourceDefinition . Attribute . SOCKET _ BINDING )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" new - socket - binding \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtocolReadWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   result    =    services . execute ( TestCaseBase . getSubsystemRead ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL )  )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" ee \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . resolve (  )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getSubsystemWrite ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL ,     \" bridge \"  )  )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getSubsystemRead ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ CHANNEL )  )  ;", "Assert . assertEquals ( result . get ( ModelDescriptionConstants . FAILURE _ DESCRIPTION )  . asString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" bridge \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystemReadWriteOperations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   result    =    services . execute ( TestCaseBase . getTransportGetProperty (  \" maximal \"  ,     \" TCP \"  ,     \" enable _ bundling \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . resolve (  )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportPutProperty (  \" maximal \"  ,     \" TCP \"  ,     \" enable _ bundling \"  ,     \" false \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportGetProperty (  \" maximal \"  ,     \" TCP \"  ,     \" enable _ bundling \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" false \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportRemoveProperty (  \" maximal \"  ,     \" TCP \"  ,     \" enable _ bundling \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportGetProperty (  \" maximal \"  ,     \" TCP \"  ,     \" enable _ bundling \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportPropertyAdd (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  ,     \" false \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportPropertyRead (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" false \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportGetProperty (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" false \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportPropertyWrite (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  ,     \" true \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportPropertyRead (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportGetProperty (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportPropertyRemove (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportGetProperty (  \" maximal \"  ,     \" TCP \"  ,     \" shared \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertFalse ( result . get ( ModelDescriptionConstants . RESULT )  . isDefined (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransportPropertyReadWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   result    =    services . execute ( TestCaseBase . getTransportRead (  \" maximal \"  ,     \" TCP \"  ,    TransportResourceDefinition . Attribute . RACK )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" rack 1  \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . resolve (  )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportWrite (  \" maximal \"  ,     \" TCP \"  ,    TransportResourceDefinition . Attribute . RACK ,     \" new - rack \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportRead (  \" maximal \"  ,     \" TCP \"  ,    TransportResourceDefinition . Attribute . RACK )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" new - rack \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransportReadWriteOperation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "Assert . assertTrue (  \" Could   not   create   services \"  ,    services . isSuccessfulBoot (  )  )  ;", "ModelNode   result    =    services . execute ( TestCaseBase . getProtocolStackAddWithParameters (  \" maximal 2  \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportWrite (  \" maximal \"  ,     \" TCP \"  ,    TransportResourceDefinition . Attribute . RACK ,     \" new - rack \"  )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "result    =    services . execute ( TestCaseBase . getTransportRead (  \" maximal \"  ,     \" TCP \"  ,    TransportResourceDefinition . Attribute . RACK )  )  ;", "Assert . assertEquals ( result . toString (  )  ,    ModelDescriptionConstants . SUCCESS ,    result . get ( ModelDescriptionConstants . OUTCOME )  . asString (  )  )  ;", "Assert . assertEquals (  \" new - rack \"  ,    result . get ( ModelDescriptionConstants . RESULT )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransportReadWriteWithParameters"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.OperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( PropertyResourceDefinition . WILDCARD _ PATH )  ;", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . setCustomResourceTransformer ( new   SimpleResourceTransformer ( PropertyResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "builder . addOperationTransformationOverride ( ADD )  . setCustomOperationTransformer ( new   SimpleAddOperationTransformer ( PropertyResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  . addAttributes ( new   SimpleAttribute ( PropertyResourceDefinition . VALUE )  )  )  . inheritResourceAttributeDefinitions (  )  ;", "builder . addOperationTransformationOverride ( REMOVE )  . setCustomOperationTransformer ( new   SimpleRemoveOperationTransformer ( PropertyResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "builder . addOperationTransformationOverride ( READ _ ATTRIBUTE _ OPERATION )  . setCustomOperationTransformer ( new   SimpleReadAttributeOperationTransformer ( PropertyResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "builder . addOperationTransformationOverride ( WRITE _ ATTRIBUTE _ OPERATION )  . setCustomOperationTransformer ( new   SimpleWriteAttributeOperationTransformer ( PropertyResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "builder . addOperationTransformationOverride ( UNDEFINE _ ATTRIBUTE _ OPERATION )  . setCustomOperationTransformer ( new   SimpleUndefineAttributeOperationTransformer ( PropertyResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "builder . addOperationTransformationOverride ( DESCRIBE )  . setCustomOperationTransformer ( new   SimpleDescribeOperationTransformer ( PropertyResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.PropertyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "DEPRECATED _ LOGGER . operationDeprecated ( Operations . getName ( operation )  ,    context . getCurrentAddress (  )  . toCLIStyleString (  )  )  ;", "}", "METHOD_END"], "methodName": ["operationDeprecated"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.PropertyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement ( PROPERTY ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.PropertyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "for    ( ClassLoader   loader    :    loaders )     {", "if    ( loader    !  =    null )     {", "URL   url    =    loader . getResource ( resource )  ;", "if    ( url    !  =    null )     {", "return   url ;", "}", "}", "}", "throw   new   IllegalArgumentException ( JGLogger . ROOT _ LOGGER . notFound ( resource )  )  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolDefaultsBuilder"}, {"methodBody": ["METHOD_START", "{", "URL   url    =    ProtocolDefaultsBuilder . find ( resource ,    JGroupsExtension . class . getClassLoader (  )  )  ;", "JGroupsLogger . ROOT _ LOGGER . debugf (  \" Loading   JGroups   protocol   defaults   from    % s \"  ,    url . toString (  )  )  ;", "try    {", "return   XmlConfigurator . getInstance ( url )  ;", "}    catch    ( IOException   e )     {", "throw   new   IllegalArgumentException ( JGroupsLogger . ROOT _ LOGGER . parserFailure ( url )  )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolDefaultsBuilder"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ProtocolMetricsHandler . Attribute >    attributes    =    new   HashMap <  >  (  )  ;", "Class <  ?  >    targetClass    =    protocolClass ;", "while    ( Protocol . class . isAssignableFrom ( targetClass )  )     {", "for    ( Method   method    :    targetClass . getDeclaredMethods (  )  )     {", "if    (  (  ( method . getParameterTypes (  )  . length )     =  =     0  )     &  &     ( ProtocolMetricsHandler . isManagedAttribute ( method )  )  )     {", "ProtocolMetricsHandler . putIfAbsent ( attributes ,    new   ProtocolMetricsHandler . MethodAttribute ( method )  )  ;", "}", "}", "for    ( Field   field    :    targetClass . getDeclaredFields (  )  )     {", "if    ( ProtocolMetricsHandler . isManagedAttribute ( field )  )     {", "ProtocolMetricsHandler . putIfAbsent ( attributes ,    new   ProtocolMetricsHandler . FieldAttribute ( field )  )  ;", "}", "}", "targetClass    =    targetClass . getSuperclass (  )  ;", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["findProtocolAttributes"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolMetricsHandler"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ProtocolMetricsHandler . Attribute >    attributes    =    ProtocolMetricsHandler . findProtocolAttributes ( targetClass )  ;", "return   attributes . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolMetricsHandler"}, {"methodBody": ["METHOD_START", "{", "return    ( object . isAnnotationPresent ( ManagedAttribute . class )  )     |  |     (  ( object . isAnnotationPresent ( Property . class )  )     &  &     ( object . getAnnotation ( Property . class )  . exposeAsManagedAttribute (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isManagedAttribute"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolMetricsHandler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    attribute . getName (  )  . replace (  '  .  '  ,     '  -  '  )  ;", "if    (  !  ( attributes . containsKey ( name )  )  )     {", "attributes . put ( name ,    attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["putIfAbsent"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolMetricsHandler"}, {"methodBody": ["METHOD_START", "{", "ProtocolResourceDefinition . addTransformations ( version ,    parent . addChildResource ( ProtocolResourceDefinition . WILDCARD _ PATH )  )  ;", "for    (  . MulticastProtocol   protocol    :    EnumSet . allOf (  . MulticastProtocol . class )  )     {", "PathElement   path    =    ProtocolResourceDefinition . pathElement ( protocol . name (  )  )  ;", "if    (  !  ( JGroupsModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )  )     {", "SocketBindingProtocolResourceDefinition . addTransformations ( version ,    parent . addChildResource ( path )  )  ;", "}", "}", "for    (  . JdbcProtocol   protocol    :    EnumSet . allOf (  . JdbcProtocol . class )  )     {", "PathElement   path    =    ProtocolResourceDefinition . pathElement ( protocol . name (  )  )  ;", "if    ( JGroupsModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . rejectChildResource ( path )  ;", "} else    {", "JDBCProtocolResourceDefinition . addTransformations ( version ,    parent . addChildResource ( path )  )  ;", "}", "}", "for    (  . EncryptProtocol   protocol    :    EnumSet . allOf (  . EncryptProtocol . class )  )     {", "PathElement   path    =    ProtocolResourceDefinition . pathElement ( protocol . name (  )  )  ;", "if    ( JGroupsModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . rejectChildResource ( path )  ;", "} else    {", "EncryptProtocolResourceDefinition . addTransformations ( version ,    parent . addChildResource ( path )  )  ;", "}", "}", "for    (  . InitialHostsProtocol   protocol    :    EnumSet . allOf (  . InitialHostsProtocol . class )  )     {", "PathElement   path    =    ProtocolResourceDefinition . pathElement ( protocol . name (  )  )  ;", "if    ( JGroupsModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . rejectChildResource ( path )  ;", "} else    {", "SocketDiscoveryProtocolResourceDefinition . addTransformations ( version ,    parent . addChildResource ( path )  )  ;", "}", "}", "for    (  . AuthProtocol   protocol    :    EnumSet . allOf (  . AuthProtocol . class )  )     {", "PathElement   path    =    ProtocolResourceDefinition . pathElement ( protocol . name (  )  )  ;", "if    ( JGroupsModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "parent . rejectChildResource ( path )  ;", "} else    {", "AuthProtocolResourceDefinition . addTransformations ( version ,    parent . addChildResource ( path )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolRegistration"}, {"methodBody": ["METHOD_START", "{", "AbstractProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "if    ( JGroupsModel . VERSION _  4  _  1  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    ADD _ INDEX )  ;", "}", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "OperationTransformer   addTransformer    =    new   OperationTransformer (  )     {", "@ SuppressWarnings (  \" deprecation \"  )", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "PathAddress   stackAddress    =    address . getParent (  )  ;", "ModelNode   addProtocolOp    =    operation . clone (  )  ;", "addProtocolOp . get ( OP _ ADDR )  . set ( stackAddress . toModelNode (  )  )  ;", "addProtocolOp . get ( OP )  . set (  \" add - protocol \"  )  ;", "addProtocolOp    =    new   LegacyPropertyAddOperationTransformer (  (    op )     -  >    Operations . getPathAddress ( op )  . append ( ProtocolResourceDefinition . pathElement ( op . get ( AbstractProtocolResourceDefinition . DeprecatedAttribute . TYPE . getName (  )  )  . asString (  )  )  )  )  . transformOperation ( addProtocolOp )  ;", "return   addProtocolOp ;", "}", "}  ;", "builder . addOperationTransformationOverride ( ADD )  . setCustomOperationTransformer ( new   SimpleOperationTransformer ( addTransformer )  )  . inheritResourceAttributeDefinitions (  )  ;", "OperationTransformer   removeTransformer    =    new   OperationTransformer (  )     {", "@ SuppressWarnings (  \" deprecation \"  )", "@ Override", "public   ModelNode   transformOperation ( ModelNode   operation )     {", "PathAddress   address    =    Operations . getPathAddress ( operation )  ;", "String   protocol    =    address . getLastElement (  )  . getValue (  )  ;", "PathAddress   stackAddress    =    address . getParent (  )  ;", "ModelNode   legacyOperation    =    Util . createOperation (  \" remove - protocol \"  ,    stackAddress )  ;", "legacyOperation . get ( AbstractProtocolResourceDefinition . DeprecatedAttribute . TYPE . getName (  )  )  . set ( protocol )  ;", "return   legacyOperation ;", "}", "}  ;", "builder . addOperationTransformationOverride ( REMOVE )  . setCustomOperationTransformer ( new   SimpleOperationTransformer ( removeTransformer )  )  ;", "builder . setCustomResourceTransformer ( new   LegacyPropertyResourceTransformer (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" protocol \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "this . keepAliveTime    =    keepAliveTime ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setKeepAliveTime"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.QueuelessThreadPoolFactory"}, {"methodBody": ["METHOD_START", "{", "this . maxThreads    =    maxThreads ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMaxThreads"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.QueuelessThreadPoolFactory"}, {"methodBody": ["METHOD_START", "{", "this . minThreads    =    minThreads ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMinThreads"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.QueuelessThreadPoolFactory"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( RelayResourceDefinition . PATH )  ;", "RemoteSiteResourceDefinition . buildTransformation ( version ,    builder )  ;", "PropertyResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.RelayResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" relay \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.RelayResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( RemoteSiteResourceDefinition . WILDCARD _ PATH )  ;", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "AttributeConverter   converter    =    new   AttributeConverter (  )     {", "@ Override", "public   void   convertOperationParameter ( PathAddress   address ,    String   name ,    ModelNode   value ,    ModelNode   operation ,    TransformationContext   context )     {", "}", "@ Override", "public   void   convertResourceAttribute ( PathAddress   address ,    String   name ,    ModelNode   value ,    TransformationContext   context )     {", "ModelNode   remoteSite    =    context . readResourceFromRoot ( address )  . getModel (  )  ;", "String   channelName    =    remoteSite . get ( RemoteSiteResourceDefinition . Attribute . CHANNEL . getName (  )  )  . asString (  )  ;", "if    ( RemoteSiteResourceDefinition . DeprecatedAttribute . STACK . getName (  )  . equals ( name )  )     {", "PathAddress   subsystemAddress    =    address . subAddress (  0  ,     (  ( address . size (  )  )     -     3  )  )  ;", "PathAddress   channelAddress    =    subsystemAddress . append ( ChannelResourceDefinition . pathElement ( channelName )  )  ;", "ModelNode   channel    =    context . readResourceFromRoot ( channelAddress )  . getModel (  )  ;", "if    ( channel . hasDefined ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  )     {", "value . set ( channel . get ( ChannelResourceDefinition . Attribute . STACK . getName (  )  )  . asString (  )  )  ;", "} else    {", "ModelNode   subsystem    =    context . readResourceFromRoot ( subsystemAddress )  . getModel (  )  ;", "value . set ( subsystem . get ( JGroupsSubsystemResourceDefinition . Attribute . DEFAULT _ STACK . getName (  )  )  . asString (  )  )  ;", "}", "} else", "if    ( RemoteSiteResourceDefinition . DeprecatedAttribute . CLUSTER . getName (  )  . equals ( name )  )     {", "value . set ( channelName )  ;", "} else    {", "throw   new   IllegalStateException (  )  ;", "}", "}", "}  ;", "builder . getAttributeBuilder (  )  . setValueConverter ( converter ,    RemoteSiteResourceDefinition . DeprecatedAttribute . STACK . getDefinition (  )  ,    RemoteSiteResourceDefinition . DeprecatedAttribute . CLUSTER . getDefinition (  )  )  . setDiscard ( ALWAYS ,    RemoteSiteResourceDefinition . Attribute . CHANNEL . getDefinition (  )  )  . end (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.RemoteSiteResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleAttributeDefinitionBuilder ( name ,    ModelType . STRING )  . setAllowExpression ( true )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.RemoteSiteResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" remote - site \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.RemoteSiteResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.SocketBindingProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["addTransformations"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.SocketDiscoveryProtocolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( StackResourceDefinition . WILDCARD _ PATH )  ;", "if    ( JGroupsModel . VERSION _  4  _  1  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( true )  )  ,    StackResourceDefinition . Attribute . STATISTICS _ ENABLED . getDefinition (  )  )  . addRejectCheck ( UNDEFINED ,    StackResourceDefinition . Attribute . STATISTICS _ ENABLED . getDefinition (  )  )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,    StackResourceDefinition . Attribute . STATISTICS _ ENABLED . getDefinition (  )  )  . addRejectCheck ( new   SimpleRejectAttributeChecker ( new   ModelNode ( false )  )  ,    StackResourceDefinition . Attribute . STATISTICS _ ENABLED . getDefinition (  )  )  . end (  )  ;", "}", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "ResourceTransformer   transformer    =    new   ResourceTransformer (  )     {", "@ Override", "public   void   transformResource ( ResourceTransformationContext   context ,    PathAddress   address ,    Resource   resource )    throws   OperationFailedException    {", "for    ( String   name    :    resource . getChildrenNames ( ProtocolResourceDefinition . WILDCARD _ PATH . getKey (  )  )  )     {", "resource . getModel (  )  . get ( StackResourceDefinition . PROTOCOLS . getName (  )  )  . add ( name )  ;", "}", "context . addTransformedResource ( EMPTY _ ADDRESS ,    resource )  . processChildren ( resource )  ;", "}", "}  ;", "builder . setCustomResourceTransformer ( transformer )  ;", "}", "if    ( JGroupsModel . VERSION _  2  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . rejectChildResource ( RelayResourceDefinition . PATH )  ;", "} else    {", "RelayResourceDefinition . buildTransformation ( version ,    builder )  ;", "}", "TransportResourceDefinition . buildTransformation ( version ,    builder )  ;", "ProtocolRegistration . buildTransformation ( version ,    builder )  ;", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.StackResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "DEPRECATED _ LOGGER . operationDeprecated ( Operations . getName ( operation )  ,    context . getCurrentAddress (  )  . toCLIStyleString (  )  )  ;", "}", "METHOD_END"], "methodName": ["operationDeprecated"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.StackResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" stack \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.StackResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( this . definition )  ;", "if    ( JGroupsModel . VERSION _  6  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   ontroller . transform . description . AttributeConverter . DefaultValueAttributeConverter ( this . queueLength . getDefinition (  )  )  ,    this . queueLength . getName (  )  )  ;", "}", "if    ( JGroupsModel . VERSION _  5  _  0  _  0  . requiresTransformation ( version )  )     {", "for    ( Attribute   attribute    :    Arrays . asList ( this . minThreads ,    this . maxThreads )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   ontroller . transform . description . AttributeConverter . DefaultValueAttributeConverter ( attribute . getDefinition (  )  )  ,    attribute . getName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "SimpleAttributeDefinitionBuilder   builder    =    new   SimpleAttributeDefinitionBuilder ( name ,    type )  . setAllowExpression ( true )  . setRequired ( false )  . setDefaultValue ( defaultValue )  . setFlags ( RESTART _ RESOURCE _ SERVICES )  . setMeasurementUnit (  ( type    =  =     ( ModelType . LONG )     ?    MeasurementUnit . MILLISECONDS    :    null )  )  ;", "if    ( deprecation    !  =    null )     {", "builder . setDeprecated ( deprecation . getVersion (  )  )  ;", "}", "return   builder . setValidator ( validatorBuilder . configure ( builder )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBuilder"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( this . minThreads ,    this . maxThreads ,    this . keepAliveTime )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . queueLength ;", "}", "METHOD_END"], "methodName": ["getQueueLength"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" thread - pool \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.ThreadPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( TransportResourceDefinition . WILDCARD _ PATH )  ;", "AbstractProtocolResourceDefinition . addTransformations ( version ,    builder )  ;", "if    ( JGroupsModel . VERSION _  3  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( TransportResourceDefinition . Attribute . SHARED . getDefinition (  )  )  ,    TransportResourceDefinition . Attribute . SHARED . getDefinition (  )  )  ;", "builder . setCustomResourceTransformer ( new   ResourceTransformer (  )     {", "@ Override", "public   void   transformResource ( ResourceTransformationContext   context ,    PathAddress   address ,    Resource   resource )    throws   OperationFailedException    {", "new   LegacyPropertyResourceTransformer (  )  . transformResource ( context ,    TransportResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER . transform ( address )  ,    resource )  ;", "}", "}  )  ;", "builder . addOperationTransformationOverride ( ADD )  . setCustomOperationTransformer ( new   SimpleOperationTransformer ( new   OperationTransformer (  )     {", "@ Override", "public   ModelNode   transformOperation ( final   ModelNode   operation )     {", "operation . get ( OP _ ADDR )  . set ( TransportResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER . transform ( Operations . getPathAddress ( operation )  )  . toModelNode (  )  )  ;", "return   new   LegacyPropertyAddOperationTransformer (  )  . transformOperation ( operation )  ;", "}", "}  )  )  . inheritResourceAttributeDefinitions (  )  ;", "builder . addOperationTransformationOverride ( REMOVE )  . setCustomOperationTransformer ( new   SimpleRemoveOperationTransformer ( TransportResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "builder . addOperationTransformationOverride ( READ _ ATTRIBUTE _ OPERATION )  . setCustomOperationTransformer ( new   SimpleReadAttributeOperationTransformer ( TransportResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "builder . addOperationTransformationOverride ( DESCRIBE )  . setCustomOperationTransformer ( new   SimpleDescribeOperationTransformer ( TransportResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "List < OperationTransformer >    getOpTransformerChain    =    new   LinkedList <  >  (  )  ;", "getOpTransformerChain . add ( new   SimplePathOperationTransformer ( TransportResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "getOpTransformerChain . add ( new   SimpleOperationTransformer ( new   LegacyPropertyMapGetOperationTransformer (  )  )  )  ;", "ChainedOperationTransformer   getOpChainedTransformer    =    new   ChainedOperationTransformer ( getOpTransformerChain ,    false )  ;", "builder . addRawOperationTransformationOverride ( MAP _ GET _ DEFINITION . getName (  )  ,    getOpChainedTransformer )  ;", "List < OperationTransformer >    writeOpTransformerChain    =    new   LinkedList <  >  (  )  ;", "writeOpTransformerChain . add ( new   SimplePathOperationTransformer ( TransportResourceDefinition . LEGACY _ ADDRESS _ TRANSFORMER )  )  ;", "writeOpTransformerChain . add ( new   LegacyPropertyWriteOperationTransformer (  )  )  ;", "ChainedOperationTransformer   writeOpChainedTransformer    =    new   ChainedOperationTransformer ( writeOpTransformerChain ,    false )  ;", "for    ( String   opName    :    Operations . getAllWriteAttributeOperationNames (  )  )     {", "builder . addOperationTransformationOverride ( opName )  . inheritResourceAttributeDefinitions (  )  . setCustomOperationTransformer ( writeOpChainedTransformer )  ;", "}", "builder . addChildResource ( ThreadPoolResourceDefinition . WILDCARD _ PATH ,    RequiredChildResourceDiscardPolicy . REJECT _ AND _ WARN )  ;", "} else    {", "for    ( ThreadPoolResourceDefinition   pool    :    EnumSet . allOf ( ThreadPoolResourceDefinition . class )  )     {", "pool . buildTransformation ( version ,    parent )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.TransportResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" transport \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.TransportResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . attributes . get ( localName )  ;", "return   attribute    !  =    null    ?    attribute    :    XMLAttribute . UNKNOWN ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.XMLAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.XMLAttribute"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . tokens . get ( token )  ;", "if    ( element    =  =    null )", "throw   new   IllegalArgumentException ( token )  ;", "return   element ;", "}", "METHOD_END"], "methodName": ["forAuthTokenName"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.XMLElement"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . elements . get ( localName )  ;", "return   element    !  =    null    ?    element    :    XMLElement . UNKNOWN ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.XMLElement"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . protocols . get ( protocol )  ;", "return   element    !  =    null    ?    element    :    XMLElement . PROTOCOL ;", "}", "METHOD_END"], "methodName": ["forProtocolName"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.XMLElement"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.clustering.jgroups.subsystem.XMLElement"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ServiceController < T >  )     ( registry . getService ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["findService"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "ServiceController < T >    service    =    ServiceContainerHelper . findService ( registry ,    name )  ;", "return    ( service    !  =    null )     &  &     (  ( service . getState (  )  )     =  =     ( State . UP )  )     ?    service . getValue (  )     :    null ;", "}", "METHOD_END"], "methodName": ["findValue"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ServiceController < T >  )     ( registry . getRequiredService ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["getService"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "ServiceContainerHelper . start ( controller )  ;", "return   controller . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "ServiceContainerHelper . transition ( controller ,    REMOVED )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "ServiceContainerHelper . transition ( controller ,    UP )  ;", "StartException   exception    =    controller . getStartException (  )  ;", "if    ( exception    !  =    null )     {", "throw   exception ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "ServiceContainerHelper . transition ( controller ,    DOWN )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( targetController . getState (  )  )     =  =    targetState )", "return ;", "StabilityMonitor   monitor    =    new   StabilityMonitor (  )  ;", "monitor . addController ( targetController )  ;", "try    {", "Mode   targetMode    =     . modeToggle . get ( targetState )  . get ( targetController . getMode (  )  )  ;", "if    ( targetMode    !  =    null )     {", "targetController . setMode ( targetMode )  ;", "}", "monitor . awaitStability (  )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}    finally    {", "monitor . removeController ( targetController )  ;", "}", "}", "METHOD_END"], "methodName": ["transition"], "fileName": "org.jboss.as.clustering.msc.ServiceContainerHelper"}, {"methodBody": ["METHOD_START", "{", "this . aliases . add ( alias )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["alias"], "fileName": "org.jboss.as.clustering.naming.BinderServiceBuilder"}, {"methodBody": ["METHOD_START", "{", "JndiName   name    =    JndiName . of ( namespace )  ;", "for    ( String   context    :    contexts )     {", "name    =    name . append (  ( context    !  =    null    ?    context    :     . DEFAULT _ LOCAL _ NAME )  )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["createJndiName"], "fileName": "org.jboss.as.clustering.naming.JndiNameFactory"}, {"methodBody": ["METHOD_START", "{", "return   value . startsWith (  \" java :  \"  )     ?    JndiName . of ( value )     :    JndiNameFactory . createJndiName ( JndiNameFactory . DEFAULT _ JNDI _ NAMESPACE ,     ( value . startsWith (  \"  /  \"  )     ?    value . substring (  1  )     :    value )  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.jboss.as.clustering.naming.JndiNameFactory"}, {"methodBody": ["METHOD_START", "{", "this . requirements . add ( requirement )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.jboss.as.clustering.subsystem.AdditionalInitialization"}, {"methodBody": ["METHOD_START", "{", "this . requirements . add ( requirement . resolve ( parent ,    child )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.jboss.as.clustering.subsystem.AdditionalInitialization"}, {"methodBody": ["METHOD_START", "{", "this . requirements . add ( requirement . getName (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.jboss.as.clustering.subsystem.AdditionalInitialization"}, {"methodBody": ["METHOD_START", "{", "Stream . of ( names )  . forEach (  (    name )     -  >    this . requirements . add ( requirement . resolve ( name )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.jboss.as.clustering.subsystem.AdditionalInitialization"}, {"methodBody": ["METHOD_START", "{", "Set < T >    result    =    Collections . newSetFromMap ( new   IdentityHashMap <  >  ( list . size (  )  )  )  ;", "result . addAll ( list )  ;", "return   Collections . unmodifiableSet ( result )  ;", "}", "METHOD_END"], "methodName": ["createIdentitySet"], "fileName": "org.wildfly.clustering.ee.Immutability"}, {"methodBody": ["METHOD_START", "{", "this . test ( Immutability . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ee.ImmutabilityTestCase"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( immutability . test ( new   Object (  )  )  )  ;", "assertFalse ( immutability . test ( new   Date (  )  )  )  ;", "assertFalse ( immutability . test ( new   AtomicInteger (  )  )  )  ;", "assertFalse ( immutability . test ( new   AtomicLong (  )  )  )  ;", "assertTrue ( immutability . test ( null )  )  ;", "assertTrue ( immutability . test ( Collections . emptyEnumeration (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptyIterator (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptyList (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptyListIterator (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptyMap (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptyNavigableMap (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptyNavigableSet (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptySet (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptySortedMap (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . emptySortedSet (  )  )  )  ;", "assertTrue ( immutability . test ( Boolean . TRUE )  )  ;", "assertTrue ( immutability . test ( Character . valueOf (  ' a '  )  )  )  ;", "assertTrue ( immutability . test ( this . getClass (  )  )  )  ;", "assertTrue ( immutability . test ( Currency . getInstance ( Locale . US )  )  )  ;", "assertTrue ( immutability . test ( Locale . getDefault (  )  )  )  ;", "assertTrue ( immutability . test ( Byte . valueOf ( Integer . valueOf (  1  )  . byteValue (  )  )  )  )  ;", "assertTrue ( immutability . test ( Short . valueOf ( Integer . valueOf (  1  )  . shortValue (  )  )  )  )  ;", "assertTrue ( immutability . test ( Integer . valueOf (  1  )  )  )  ;", "assertTrue ( immutability . test ( Long . valueOf (  1  )  )  )  ;", "assertTrue ( immutability . test ( Float . valueOf (  1  )  )  )  ;", "assertTrue ( immutability . test ( Double . valueOf (  1  )  )  )  ;", "assertTrue ( immutability . test ( BigInteger . valueOf (  1  )  )  )  ;", "assertTrue ( immutability . test ( BigDecimal . valueOf (  1  )  )  )  ;", "assertTrue ( immutability . test ( InetAddress . getLocalHost (  )  )  )  ;", "assertTrue ( immutability . test ( new   InetSocketAddress ( InetAddress . getLocalHost (  )  ,     8  0  )  )  )  ;", "assertTrue ( immutability . test ( MathContext . UNLIMITED )  )  ;", "assertTrue ( immutability . test (  \" test \"  )  )  ;", "assertTrue ( immutability . test ( TimeZone . getDefault (  )  )  )  ;", "assertTrue ( immutability . test ( UUID . randomUUID (  )  )  )  ;", "assertTrue ( immutability . test ( TimeUnit . DAYS )  )  ;", "File   file    =    new   File ( System . getProperty (  \" user . home \"  )  )  ;", "assertTrue ( immutability . test ( file )  )  ;", "assertTrue ( immutability . test ( file . toURI (  )  )  )  ;", "assertTrue ( immutability . test ( file . toURI (  )  . toURL (  )  )  )  ;", "assertTrue ( immutability . test ( FileSystems . getDefault (  )  . getRootDirectories (  )  . iterator (  )  . next (  )  )  )  ;", "assertTrue ( immutability . test ( new   AllPermission (  )  )  )  ;", "assertTrue ( immutability . test ( DateTimeFormatter . BASIC _ ISO _ DATE )  )  ;", "assertTrue ( immutability . test ( DecimalStyle . STANDARD )  )  ;", "assertTrue ( immutability . test ( Duration . ZERO )  )  ;", "assertTrue ( immutability . test ( Instant . now (  )  )  )  ;", "assertTrue ( immutability . test ( LocalDate . now (  )  )  )  ;", "assertTrue ( immutability . test ( LocalDateTime . now (  )  )  )  ;", "assertTrue ( immutability . test ( LocalTime . now (  )  )  )  ;", "assertTrue ( immutability . test ( MonthDay . now (  )  )  )  ;", "assertTrue ( immutability . test ( Period . ZERO )  )  ;", "assertTrue ( immutability . test ( ValueRange . of (  0 L ,     1  0 L )  )  )  ;", "assertTrue ( immutability . test ( WeekFields . ISO )  )  ;", "assertTrue ( immutability . test ( Year . now (  )  )  )  ;", "assertTrue ( immutability . test ( YearMonth . now (  )  )  )  ;", "assertTrue ( immutability . test ( ZoneOffset . UTC )  )  ;", "assertTrue ( immutability . test ( ZoneRules . of ( ZoneOffset . UTC )  . nextTransition ( Instant . now (  )  )  )  )  ;", "assertTrue ( immutability . test ( ZoneOffsetTransitionRule . of ( Month . JANUARY ,     1  ,    DayOfWeek . SUNDAY ,    LocalTime . MIDNIGHT ,    true ,    ZoneOffsetTransitionRule . TimeDefinition . STANDARD ,    ZoneOffset . UTC ,    ZoneOffset . ofHours (  1  )  ,    ZoneOffset . ofHours (  2  )  )  )  )  ;", "assertTrue ( immutability . test ( ZoneRules . of ( ZoneOffset . UTC )  )  )  ;", "assertTrue ( immutability . test ( ZonedDateTime . now (  )  )  )  ;", "assertTrue ( immutability . test ( new    . JCIPImmutableObject (  )  )  )  ;", "assertTrue ( immutability . test ( Collections . singleton (  \"  1  \"  )  )  )  ;", "assertTrue ( immutability . test ( Collections . singletonList (  \"  1  \"  )  )  )  ;", "assertTrue ( immutability . test ( Collections . singletonMap (  \"  1  \"  ,     \"  2  \"  )  )  )  ;", "assertTrue ( immutability . test ( Collections . singleton ( new    . JCIPImmutableObject (  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . singletonList ( new    . JCIPImmutableObject (  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . singletonMap (  \"  1  \"  ,    new    . JCIPImmutableObject (  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableCollection ( Arrays . asList (  \"  1  \"  ,     \"  2  \"  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableList ( Arrays . asList (  \"  1  \"  ,     \"  2  \"  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableMap ( Collections . singletonMap (  \"  1  \"  ,     \"  2  \"  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableNavigableMap ( new   TreeMap <  >  ( Collections . singletonMap (  \"  1  \"  ,     \"  2  \"  )  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableNavigableSet ( new   TreeSet <  >  ( Collections . singleton (  \"  1  \"  )  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableSet ( Collections . singleton (  \"  1  \"  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableSortedMap ( new   TreeMap <  >  ( Collections . singletonMap (  \"  1  \"  ,     \"  2  \"  )  )  )  )  )  ;", "assertTrue ( immutability . test ( Collections . unmodifiableSortedSet ( new   TreeSet <  >  ( Collections . singleton (  \"  1  \"  )  )  )  )  )  ;", "Object   mutableObject    =    new   AtomicInteger (  )  ;", "assertFalse ( immutability . test ( Collections . singletonList ( mutableObject )  )  )  ;", "assertFalse ( immutability . test ( Collections . singletonMap (  \"  1  \"  ,    mutableObject )  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ee.ImmutabilityTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . findValue ( key )  ;", "}", "METHOD_END"], "methodName": ["tryValue"], "fileName": "org.wildfly.clustering.ee.Locator"}, {"methodBody": ["METHOD_START", "{", "return   this . remove ( id )  ;", "}", "METHOD_END"], "methodName": ["purge"], "fileName": "org.wildfly.clustering.ee.Remover"}, {"methodBody": ["METHOD_START", "{", "AdvancedCache < Object ,    Object >    cache    =    mock ( AdvancedCache . class )  ;", "Object   id    =    new   Object (  )  ;", "Object   value    =    new   Object (  )  ;", "Configuration   config    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( NON _ TRANSACTIONAL )  . build (  )  ;", "when ( cache . getCacheConfiguration (  )  )  . thenReturn ( config )  ;", "Mutator   mutator    =    new    ( cache ,    id ,    value )  ;", "when ( cache . getAdvancedCache (  )  )  . thenReturn ( cache )  ;", "when ( cache . withFlags ( IGNORE _ RETURN _ VALUES ,    FAIL _ SILENTLY )  )  . thenReturn ( cache )  ;", "mutator . mutate (  )  ;", "verify ( cache )  . put ( same ( id )  ,    same ( value )  )  ;", "mutator . mutate (  )  ;", "verify ( cache ,    times (  2  )  )  . put ( same ( id )  ,    same ( value )  )  ;", "mutator . mutate (  )  ;", "verify ( cache ,    times (  3  )  )  . put ( same ( id )  ,    same ( value )  )  ;", "}", "METHOD_END"], "methodName": ["mutateNonTransactional"], "fileName": "org.wildfly.clustering.ee.infinispan.CacheEntryMutatorTestCase"}, {"methodBody": ["METHOD_START", "{", "AdvancedCache < Object ,    Object >    cache    =    mock ( AdvancedCache . class )  ;", "Object   id    =    new   Object (  )  ;", "Object   value    =    new   Object (  )  ;", "Configuration   config    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( TRANSACTIONAL )  . build (  )  ;", "when ( cache . getCacheConfiguration (  )  )  . thenReturn ( config )  ;", "Mutator   mutator    =    new    ( cache ,    id ,    value )  ;", "when ( cache . getAdvancedCache (  )  )  . thenReturn ( cache )  ;", "when ( cache . withFlags ( IGNORE _ RETURN _ VALUES ,    FAIL _ SILENTLY )  )  . thenReturn ( cache )  ;", "mutator . mutate (  )  ;", "verify ( cache )  . put ( same ( id )  ,    same ( value )  )  ;", "mutator . mutate (  )  ;", "verify ( cache ,    times (  1  )  )  . put ( same ( id )  ,    same ( value )  )  ;", "mutator . mutate (  )  ;", "verify ( cache ,    times (  1  )  )  . put ( same ( id )  ,    same ( value )  )  ;", "}", "METHOD_END"], "methodName": ["mutateTransactional"], "fileName": "org.wildfly.clustering.ee.infinispan.CacheEntryMutatorTestCase"}, {"methodBody": ["METHOD_START", "{", "return   InfinispanBatcher . CURRENT _ BATCH . get (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcher"}, {"methodBody": ["METHOD_START", "{", "if    ( batch    !  =    null )     {", ". CURRENT _ BATCH . set ( batch )  ;", "} else    {", ". CURRENT _ BATCH . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCurrentBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcher"}, {"methodBody": ["METHOD_START", "{", "Transaction   tx    =    mock ( Transaction . class )  ;", "ArgumentCaptor < Synchronization >    capturedSync    =    ArgumentCaptor . forClass ( Synchronization . class )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( TransactionBatch   batch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm )  . begin (  )  ;", "verify ( tx )  . registerSynchronization ( capturedSync . capture (  )  )  ;", "assertSame ( tx ,    batch . getTransaction (  )  )  ;", "}    finally    {", "capturedSync . getValue (  )  . afterCompletion ( STATUS _ COMMITTED )  ;", "}", "verify ( tx )  . commit (  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBatchClose"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "Transaction   tx    =    mock ( Transaction . class )  ;", "ArgumentCaptor < Synchronization >    capturedSync    =    ArgumentCaptor . forClass ( Synchronization . class )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( TransactionBatch   batch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm )  . begin (  )  ;", "verify ( tx )  . registerSynchronization ( capturedSync . capture (  )  )  ;", "assertSame ( tx ,    batch . getTransaction (  )  )  ;", "batch . discard (  )  ;", "}    finally    {", "capturedSync . getValue (  )  . afterCompletion ( STATUS _ ROLLEDBACK )  ;", "}", "verify ( tx ,    never (  )  )  . commit (  )  ;", "verify ( tx )  . rollback (  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBatchDiscard"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   existingBatch    =    mock ( TransactionBatch . class )  ;", ". setCurrentBatch ( existingBatch )  ;", "when ( existingBatch . getState (  )  )  . thenReturn ( Batch . State . ACTIVE )  ;", "when ( existingBatch . interpose (  )  )  . thenReturn ( existingBatch )  ;", "TransactionBatch   result    =    this . batcher . createBatch (  )  ;", "verify ( existingBatch )  . interpose (  )  ;", "verifyZeroInteractions ( this . tm )  ;", "assertSame ( existingBatch ,    result )  ;", "}", "METHOD_END"], "methodName": ["createExistingActiveBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   existingBatch    =    mock ( TransactionBatch . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "ArgumentCaptor < Synchronization >    capturedSync    =    ArgumentCaptor . forClass ( Synchronization . class )  ;", ". setCurrentBatch ( existingBatch )  ;", "when ( existingBatch . getState (  )  )  . thenReturn ( Batch . State . CLOSED )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( TransactionBatch   batch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm )  . begin (  )  ;", "verify ( tx )  . registerSynchronization ( capturedSync . capture (  )  )  ;", "assertSame ( tx ,    batch . getTransaction (  )  )  ;", "assertSame ( batch ,     . getCurrentBatch (  )  )  ;", "}    finally    {", "capturedSync . getValue (  )  . afterCompletion ( STATUS _ COMMITTED )  ;", "}", "verify ( tx )  . commit (  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["createExistingClosedBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "Transaction   tx    =    mock ( Transaction . class )  ;", "ArgumentCaptor < Synchronization >    capturedSync    =    ArgumentCaptor . forClass ( Synchronization . class )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( TransactionBatch   outerBatch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm )  . begin (  )  ;", "verify ( tx )  . registerSynchronization ( capturedSync . capture (  )  )  ;", "reset ( this . tm )  ;", "assertSame ( tx ,    outerBatch . getTransaction (  )  )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( TransactionBatch   innerBatch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm ,    never (  )  )  . begin (  )  ;", "verify ( this . tm ,    never (  )  )  . suspend (  )  ;", "}", "verify ( tx ,    never (  )  )  . rollback (  )  ;", "verify ( tx ,    never (  )  )  . commit (  )  ;", "}    finally    {", "capturedSync . getValue (  )  . afterCompletion ( STATUS _ COMMITTED )  ;", "}", "verify ( tx ,    never (  )  )  . rollback (  )  ;", "verify ( tx )  . commit (  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["createNestedBatchClose"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "Transaction   tx    =    mock ( Transaction . class )  ;", "ArgumentCaptor < Synchronization >    capturedSync    =    ArgumentCaptor . forClass ( Synchronization . class )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( TransactionBatch   outerBatch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm )  . begin (  )  ;", "verify ( tx )  . registerSynchronization ( capturedSync . capture (  )  )  ;", "reset ( this . tm )  ;", "assertSame ( tx ,    outerBatch . getTransaction (  )  )  ;", "when ( tx . getStatus (  )  )  . thenReturn ( STATUS _ ACTIVE )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( TransactionBatch   innerBatch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm ,    never (  )  )  . begin (  )  ;", "innerBatch . discard (  )  ;", "}", "verify ( tx ,    never (  )  )  . commit (  )  ;", "verify ( tx ,    never (  )  )  . rollback (  )  ;", "}    finally    {", "capturedSync . getValue (  )  . afterCompletion ( STATUS _ ROLLEDBACK )  ;", "}", "verify ( tx )  . rollback (  )  ;", "verify ( tx ,    never (  )  )  . commit (  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["createNestedBatchDiscard"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "Transaction   tx    =    mock ( Transaction . class )  ;", "ArgumentCaptor < Synchronization >    capturedSync    =    ArgumentCaptor . forClass ( Synchronization . class )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "TransactionBatch   batch    =    this . batcher . createBatch (  )  ;", "verify ( this . tm )  . begin (  )  ;", "verify ( tx )  . registerSynchronization ( capturedSync . capture (  )  )  ;", "reset ( this . tm )  ;", "try    {", "assertSame ( tx ,    batch . getTransaction (  )  )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "when ( tx . getStatus (  )  )  . thenReturn ( STATUS _ ACTIVE )  ;", "try    ( TransactionBatch   innerBatch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm ,    never (  )  )  . begin (  )  ;", "batch . close (  )  ;", "verify ( tx ,    never (  )  )  . rollback (  )  ;", "verify ( tx ,    never (  )  )  . commit (  )  ;", "}", "}    finally    {", "capturedSync . getValue (  )  . afterCompletion ( STATUS _ COMMITTED )  ;", "}", "verify ( tx ,    never (  )  )  . rollback (  )  ;", "verify ( tx )  . commit (  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["createOverlappingBatchClose"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "Transaction   tx    =    mock ( Transaction . class )  ;", "ArgumentCaptor < Synchronization >    capturedSync    =    ArgumentCaptor . forClass ( Synchronization . class )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "TransactionBatch   batch    =    this . batcher . createBatch (  )  ;", "verify ( this . tm )  . begin (  )  ;", "verify ( tx )  . registerSynchronization ( capturedSync . capture (  )  )  ;", "reset ( this . tm )  ;", "try    {", "assertSame ( tx ,    batch . getTransaction (  )  )  ;", "when ( this . tm . getTransaction (  )  )  . thenReturn ( tx )  ;", "when ( tx . getStatus (  )  )  . thenReturn ( STATUS _ ACTIVE )  ;", "try    ( TransactionBatch   innerBatch    =    this . batcher . createBatch (  )  )     {", "verify ( this . tm ,    never (  )  )  . begin (  )  ;", "innerBatch . discard (  )  ;", "batch . close (  )  ;", "verify ( tx ,    never (  )  )  . commit (  )  ;", "verify ( tx ,    never (  )  )  . rollback (  )  ;", "}", "}    finally    {", "capturedSync . getValue (  )  . afterCompletion ( STATUS _ ROLLEDBACK )  ;", "}", "verify ( tx )  . rollback (  )  ;", "verify ( tx ,    never (  )  )  . commit (  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["createOverlappingBatchDiscard"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "InfinispanBatcher . setCurrentBatch ( null )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "when ( batch . getTransaction (  )  )  . thenReturn ( tx )  ;", "try    ( BatchContext   context    =    this . batcher . resumeBatch ( batch )  )     {", "verify ( this . tm ,    never (  )  )  . suspend (  )  ;", "verify ( this . tm )  . resume ( tx )  ;", "reset ( this . tm )  ;", "assertSame ( batch ,     . getCurrentBatch (  )  )  ;", "}", "verify ( this . tm )  . suspend (  )  ;", "verify ( this . tm ,    never (  )  )  . resume ( any (  )  )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["resumeBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   existingBatch    =    mock ( TransactionBatch . class )  ;", "Transaction   existingTx    =    mock ( Transaction . class )  ;", ". setCurrentBatch ( existingBatch )  ;", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "when ( existingBatch . getTransaction (  )  )  . thenReturn ( existingTx )  ;", "when ( batch . getTransaction (  )  )  . thenReturn ( tx )  ;", "when ( this . tm . suspend (  )  )  . thenReturn ( existingTx )  ;", "try    ( BatchContext   context    =    this . batcher . resumeBatch ( batch )  )     {", "verify ( this . tm )  . resume ( tx )  ;", "reset ( this . tm )  ;", "assertSame ( batch ,     . getCurrentBatch (  )  )  ;", "when ( this . tm . suspend (  )  )  . thenReturn ( tx )  ;", "}", "verify ( this . tm )  . resume ( existingTx )  ;", "assertSame ( existingBatch ,     . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["resumeBatchExisting"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   existingBatch    =    mock ( TransactionBatch . class )  ;", ". setCurrentBatch ( existingBatch )  ;", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", "try    ( BatchContext   context    =    this . batcher . resumeBatch ( batch )  )     {", "verifyZeroInteractions ( this . tm )  ;", "assertSame ( batch ,     . getCurrentBatch (  )  )  ;", "}", "verifyZeroInteractions ( this . tm )  ;", "assertSame ( existingBatch ,     . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["resumeNonTxBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", ". setCurrentBatch ( batch )  ;", "try    ( BatchContext   context    =    this . batcher . resumeBatch ( null )  )     {", "verifyZeroInteractions ( this . tm )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "verifyZeroInteractions ( this . tm )  ;", "assertSame ( batch ,     . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["resumeNullBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", ". setCurrentBatch ( batch )  ;", "TransactionBatch   result    =    this . batcher . suspendBatch (  )  ;", "verify ( this . tm )  . suspend (  )  ;", "assertSame ( batch ,    result )  ;", "assertNull (  . getCurrentBatch (  )  )  ;", "}", "METHOD_END"], "methodName": ["suspendBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "TransactionBatch   result    =    this . batcher . suspendBatch (  )  ;", "verify ( this . tm ,    never (  )  )  . suspend (  )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["suspendNoBatch"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanBatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   config    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( TRANSACTIONAL )  . lockingMode ( PESSIMISTIC )  . locking (  )  . isolationLevel ( REPEATABLE _ READ )  . build (  )  ;", "Assert . assertTrue ( new    ( config )  . isLockOnRead (  )  )  ;", "Configuration   optimistic    =    config    =    new   ConfigurationBuilder (  )  . read ( config )  . transaction (  )  . lockingMode ( OPTIMISTIC )  . build (  )  ;", "Assert . assertFalse ( new    ( optimistic )  . isLockOnRead (  )  )  ;", "Configuration   nonTx    =    new   ConfigurationBuilder (  )  . read ( config )  . transaction (  )  . transactionMode ( NON _ TRANSACTIONAL )  . build (  )  ;", "Assert . assertFalse ( new    ( nonTx )  . isLockOnRead (  )  )  ;", "Configuration   readCommitted    =    config    =    new   ConfigurationBuilder (  )  . read ( config )  . locking (  )  . isolationLevel ( READ _ COMMITTED )  . build (  )  ;", "Assert . assertFalse ( new    ( readCommitted )  . isLockOnRead (  )  )  ;", "}", "METHOD_END"], "methodName": ["isLockOnRead"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanCachePropertiesTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   config    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( TRANSACTIONAL )  . lockingMode ( PESSIMISTIC )  . build (  )  ;", "Assert . assertTrue ( new    ( config )  . isLockOnWrite (  )  )  ;", "Configuration   optimistic    =    config    =    new   ConfigurationBuilder (  )  . read ( config )  . transaction (  )  . lockingMode ( OPTIMISTIC )  . build (  )  ;", "Assert . assertFalse ( new    ( optimistic )  . isLockOnWrite (  )  )  ;", "Configuration   nonTx    =    new   ConfigurationBuilder (  )  . read ( config )  . transaction (  )  . transactionMode ( NON _ TRANSACTIONAL )  . build (  )  ;", "Assert . assertFalse ( new    ( nonTx )  . isLockOnWrite (  )  )  ;", "}", "METHOD_END"], "methodName": ["isLockOnWrite"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanCachePropertiesTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( CacheMode   mode    :    EnumSet . allOf ( CacheMode . class )  )     {", "Configuration   config    =    new   ConfigurationBuilder (  )  . clustering (  )  . cacheMode ( mode )  . build (  )  ;", "CacheProperties   configuration    =    new    ( config )  ;", "if    (  (  ( mode . isDistributed (  )  )     |  |     ( mode . isReplicated (  )  )  )     |  |     ( mode . isScattered (  )  )  )     {", "Assert . assertTrue ( mode . name (  )  ,    configuration . isMarshalling (  )  )  ;", "} else    {", "Assert . assertFalse ( mode . name (  )  ,    configuration . isMarshalling (  )  )  ;", "}", "}", "Configuration   config    =    new   ConfigurationBuilder (  )  . clustering (  )  . cacheMode ( LOCAL )  . persistence (  )  . passivation ( false )  . addSingleFileStore (  )  . build (  )  ;", "Assert . assertTrue ( new    ( config )  . isMarshalling (  )  )  ;", "Configuration   passivating    =    new   ConfigurationBuilder (  )  . read ( config )  . persistence (  )  . passivation ( true )  . build (  )  ;", "Assert . assertTrue ( new    ( passivating )  . isMarshalling (  )  )  ;", "Configuration   noStore    =    new   ConfigurationBuilder (  )  . read ( config )  . persistence (  )  . clearStores (  )  . build (  )  ;", "Assert . assertFalse ( new    ( noStore )  . isMarshalling (  )  )  ;", "}", "METHOD_END"], "methodName": ["isMarshalling"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanCachePropertiesTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( CacheMode   mode    :    EnumSet . allOf ( CacheMode . class )  )     {", "Configuration   config    =    new   ConfigurationBuilder (  )  . clustering (  )  . cacheMode ( mode )  . build (  )  ;", "CacheProperties   configuration    =    new    ( config )  ;", "if    (  (  ( mode . isDistributed (  )  )     |  |     ( mode . isReplicated (  )  )  )     |  |     ( mode . isScattered (  )  )  )     {", "Assert . assertTrue ( mode . name (  )  ,    configuration . isPersistent (  )  )  ;", "} else    {", "Assert . assertFalse ( mode . name (  )  ,    configuration . isPersistent (  )  )  ;", "}", "}", "Configuration   config    =    new   ConfigurationBuilder (  )  . clustering (  )  . cacheMode ( LOCAL )  . persistence (  )  . passivation ( false )  . addSingleFileStore (  )  . build (  )  ;", "Assert . assertTrue ( new    ( config )  . isPersistent (  )  )  ;", "Configuration   passivating    =    new   ConfigurationBuilder (  )  . read ( config )  . persistence (  )  . passivation ( true )  . build (  )  ;", "Assert . assertFalse ( new    ( passivating )  . isPersistent (  )  )  ;", "Configuration   noStore    =    new   ConfigurationBuilder (  )  . read ( config )  . persistence (  )  . clearStores (  )  . build (  )  ;", "Assert . assertFalse ( new    ( noStore )  . isPersistent (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPersistent"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanCachePropertiesTestCase"}, {"methodBody": ["METHOD_START", "{", "Configuration   config    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( TRANSACTIONAL )  . build (  )  ;", "Assert . assertTrue ( new    ( config )  . isTransactional (  )  )  ;", "config    =    new   ConfigurationBuilder (  )  . transaction (  )  . transactionMode ( NON _ TRANSACTIONAL )  . build (  )  ;", "Assert . assertFalse ( new    ( config )  . isTransactional (  )  )  ;", "}", "METHOD_END"], "methodName": ["isTransactional"], "fileName": "org.wildfly.clustering.ee.infinispan.InfinispanCachePropertiesTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . mutator ;", "}", "METHOD_END"], "methodName": ["getMutator"], "fileName": "org.wildfly.clustering.ee.infinispan.MutableCacheEntry"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.clustering.ee.infinispan.MutableCacheEntry"}, {"methodBody": ["METHOD_START", "{", "return   unit . convert ( this . value ,    this . unit )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.wildfly.clustering.ejb.Time"}, {"methodBody": ["METHOD_START", "{", "return   this . unit ;", "}", "METHOD_END"], "methodName": ["getUnit"], "fileName": "org.wildfly.clustering.ejb.Time"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.clustering.ejb.Time"}, {"methodBody": ["METHOD_START", "{", "Batcher < TransactionBatch >    batcher    =    mock ( Batcher . class )  ;", "BeanRemover < String ,    Object >    remover    =    mock ( BeanRemover . class )  ;", "ExpirationConfiguration < Object >    config    =    mock ( ExpirationConfiguration . class )  ;", "RemoveListener < Object >    listener    =    mock ( RemoveListener . class )  ;", "String   beanId    =     \" canceled \"  ;", "when ( config . getExecutor (  )  )  . thenReturn ( Executors . newSingleThreadScheduledExecutor (  )  )  ;", "when ( config . getTimeout (  )  )  . thenReturn ( new   Time (  1  ,    TimeUnit . MINUTES )  )  ;", "when ( config . getRemoveListener (  )  )  . thenReturn ( listener )  ;", "try    ( Scheduler < String >    scheduler    =    new    <  >  ( batcher ,    remover ,    config )  )     {", "scheduler . schedule ( beanId )  ;", "Thread . sleep (  1  0  0  0  )  ;", "scheduler . cancel ( beanId )  ;", "scheduler . schedule ( beanId )  ;", "}", "verify ( remover ,    never (  )  )  . remove ( beanId ,    listener )  ;", "verify ( batcher ,    never (  )  )  . createBatch (  )  ;", "}", "METHOD_END"], "methodName": ["testCancel"], "fileName": "org.wildfly.clustering.ejb.infinispan.BeanExpirationSchedulerTestCase"}, {"methodBody": ["METHOD_START", "{", "Batcher < TransactionBatch >    batcher    =    mock ( Batcher . class )  ;", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", "BeanRemover < String ,    Object >    remover    =    mock ( BeanRemover . class )  ;", "ExpirationConfiguration < Object >    config    =    mock ( ExpirationConfiguration . class )  ;", "RemoveListener < Object >    listener    =    mock ( RemoveListener . class )  ;", "String   beanId    =     \" expiring \"  ;", "when ( config . getExecutor (  )  )  . thenReturn ( Executors . newSingleThreadScheduledExecutor (  )  )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( config . getTimeout (  )  )  . thenReturn ( new   Time (  1  ,    TimeUnit . MILLISECONDS )  )  ;", "when ( config . getRemoveListener (  )  )  . thenReturn ( listener )  ;", "try    ( Scheduler < String >    scheduler    =    new    <  >  ( batcher ,    remover ,    config )  )     {", "scheduler . schedule ( beanId )  ;", "Thread . sleep (  1  0  0  0  )  ;", "}", "verify ( remover )  . remove ( beanId ,    listener )  ;", "verify ( batch )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExpire"], "fileName": "org.wildfly.clustering.ejb.infinispan.BeanExpirationSchedulerTestCase"}, {"methodBody": ["METHOD_START", "{", "Batcher < TransactionBatch >    batcher    =    mock ( Batcher . class )  ;", "BeanRemover < String ,    Object >    remover    =    mock ( BeanRemover . class )  ;", "ExpirationConfiguration < Object >    config    =    mock ( ExpirationConfiguration . class )  ;", "RemoveListener < Object >    listener    =    mock ( RemoveListener . class )  ;", "String   beanId    =     \" immortal \"  ;", "when ( config . getExecutor (  )  )  . thenReturn ( Executors . newSingleThreadScheduledExecutor (  )  )  ;", "when ( config . getTimeout (  )  )  . thenReturn ( new   Time (  (  -  1  )  ,    TimeUnit . SECONDS )  )  ;", "when ( config . getRemoveListener (  )  )  . thenReturn ( listener )  ;", "try    ( Scheduler < String >    scheduler    =    new    <  >  ( batcher ,    remover ,    config )  )     {", "scheduler . schedule ( beanId )  ;", "Thread . sleep (  1  0  0  0  )  ;", "}", "verify ( batcher ,    never (  )  )  . createBatch (  )  ;", "verify ( remover ,    never (  )  )  . remove ( beanId ,    listener )  ;", "}", "METHOD_END"], "methodName": ["testImmortal"], "fileName": "org.wildfly.clustering.ejb.infinispan.BeanExpirationSchedulerTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( mapping 1  . getSourceNetworkAddress (  )  ,    mapping 2  . getSourceNetworkAddress (  )  )  ;", "Assert . assertEquals ( mapping 1  . getSourceNetworkMaskBits (  )  ,    mapping 2  . getSourceNetworkMaskBits (  )  )  ;", "Assert . assertEquals ( mapping 1  . getDestinationAddress (  )  ,    mapping 2  . getDestinationAddress (  )  )  ;", "Assert . assertEquals ( mapping 1  . getDestinationPort (  )  ,    mapping 2  . getDestinationPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.ejb.infinispan.ClientMappingExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "ClientMapping   mapping    =    new   ClientMapping ( InetAddress . getLoopbackAddress (  )  ,     1  6  ,     \" localhost \"  ,    Short . MAX _ VALUE )  ;", "new   ExternalizerTester ( new   ClientMappingExternalizer (  )  ,     :  : assertEquals )  . test ( mapping )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ejb.infinispan.ClientMappingExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . executeOnPrimaryOwner ( bean ,    new   CancelSchedulerCommand <  >  ( bean )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . ROOT _ LOGGER . failedToCancelBean ( e ,    bean . getId (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManager"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < ThreadFactory >    action    =     (  )     -  >    new   JBossThreadFactory ( new   ThreadGroup ( InfinispanBeanManager . class . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ;", "return   WildFlySecurityManager . doUnchecked ( action )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManager"}, {"methodBody": ["METHOD_START", "{", "Locality   newLocality    =    new   ConsistentHashLocality ( event . getCache (  )  ,    event . getConsistentHashAtEnd (  )  )  ;", "if    ( event . isPre (  )  )     {", "Future <  ?  >    future    =    this . rehashFuture . getAndSet ( null )  ;", "if    ( future    !  =    null )     {", "future . cancel ( true )  ;", "}", "try    {", "this . executor . submit (  (  )     -  >     {", "this . scheduler . cancel ( newLocality )  ;", "}  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "} else    {", "Locality   oldLocality    =    new   ConsistentHashLocality ( event . getCache (  )  ,    event . getConsistentHashAtStart (  )  )  ;", "try    {", "this . rehashFuture . set ( this . executor . submit (  (  )     -  >    this . schedule ( oldLocality ,    newLocality )  )  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["dataRehashed"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManager"}, {"methodBody": ["METHOD_START", "{", "this . invoker . invoke (  (  )     -  >     {", "Node   node    =    this . locatePrimaryOwner ( bean . getId (  )  )  ;", "return   this . dtcher . executeOnNode ( command ,    node )  ;", "}  )  . get (  )  ;", "}", "METHOD_END"], "methodName": ["executeOnPrimaryOwner"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManager"}, {"methodBody": ["METHOD_START", "{", "DistributionManager   dist    =    this . cache . getAdvancedCache (  )  . getDistributionManager (  )  ;", "Address   address    =     ( dist    !  =    null )     ?    dist . getCacheTopology (  )  . getDistribution ( id )  . primary (  )     :    null ;", "Node   member    =     ( address    !  =    null )     ?    this . nodeFactory . createNode ( address )     :    null ;", "return   member    !  =    null    ?    member    :    this . registry . getGroup (  )  . getLocalMember (  )  ;", "}", "METHOD_END"], "methodName": ["locatePrimaryOwner"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . executeOnPrimaryOwner ( bean ,    new   ScheduleSchedulerCommand <  >  ( bean )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . ROOT _ LOGGER . failedToScheduleBean ( e ,    bean . getId (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManager"}, {"methodBody": ["METHOD_START", "{", "try    ( Stream < Map . Entry < BeanKey < I >  ,    BeanEntry < I >  >  >    stream    =    this . cache . getAdvancedCache (  )  . withFlags ( CACHE _ MODE _ LOCAL ,    SKIP _ CACHE _ LOAD )  . entrySet (  )  . stream (  )  . filter ( this . filter )  )     {", "Iterator < Map . Entry < BeanKey < I >  ,    BeanEntry < I >  >  >    entries    =    stream . iterator (  )  ;", "while    ( entries . hasNext (  )  )     {", "if    ( Thread . currentThread (  )  . isInterrupted (  )  )", "break ;", "Map . Entry < BeanKey < I >  ,    BeanEntry < I >  >    entry    =    entries . next (  )  ;", "BeanKey < I >    key    =    entry . getKey (  )  ;", "if    (  (  ( this . filter . test ( entry )  )     &  &     (  !  ( oldLocality . isLocal ( key )  )  )  )     &  &     ( newLocality . isLocal ( key )  )  )     {", "this . scheduler . schedule ( key . getId (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManager"}, {"methodBody": ["METHOD_START", "{", "return   AccessController . doPrivileged ( new   PrivilegedAction < ThreadFactory >  (  )     {", "@ Override", "public   ThreadFactory   run (  )     {", "return   new   JBossThreadFactory ( new   ThreadGroup (  . class . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManagerFactoryBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( JBOSS _ DEPLOYMENT _ SUB _ UNIT . isParentOf ( deploymentUnitServiceName )  )     {", "return    (  ( deploymentUnitServiceName . getParent (  )  . getSimpleName (  )  )     +     \"  /  \"  )     +     ( deploymentUnitServiceName . getSimpleName (  )  )  ;", "}", "return   deploymentUnitServiceName . getSimpleName (  )  ;", "}", "METHOD_END"], "methodName": ["getCacheName"], "fileName": "org.wildfly.clustering.ejb.infinispan.InfinispanBeanManagerFactoryBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "KeyMapperTester   tester    =    new   KeyMapperTester ( new   KeyMapper (  )  )  ;", "SessionID   id    =    new   UUIDSessionID ( UUID . randomUUID (  )  )  ;", "tester . test ( new   bean . InfinispanBeanKey ( id )  )  ;", "tester . test ( new   group . InfinispanBeanGroupKey ( id )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ejb.infinispan.KeyMapperTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceLoaderTestCase . load ( Externalizer . class )  ;", "ServiceLoaderTestCase . load ( BeanManagerFactoryBuilderFactoryProvider . class )  ;", "ServiceLoaderTestCase . load ( DistributedCacheBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( LocalCacheBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( CacheAliasBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( TwoWayKey 2 StringMapper . class )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.wildfly.clustering.ejb.infinispan.ServiceLoaderTestCase"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  ( targetClass . getName (  )  )     +     \"  :  \"  )  )  ;", "ServiceLoader . load ( targetClass ,     . class . getClassLoader (  )  )  . forEach (  (    object )     -  >    System . out . println (  (  \"  \\ t \"     +     ( object . getClass (  )  . getName (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.wildfly.clustering.ejb.infinispan.ServiceLoaderTestCase"}, {"methodBody": ["METHOD_START", "{", "UUID   uuid    =    UUID . randomUUID (  )  ;", "new   ExternalizerTester <  >  ( new    . UUIDSessionIDExternalizer (  )  )  . test ( new   UUIDSessionID ( uuid )  )  ;", "ByteBuffer   buffer    =    ByteBuffer . wrap ( new   byte [  2  0  ]  )  ;", "buffer . putInt (  1  1  7  4  4  0  5  1  2  )  ;", "buffer . putLong ( uuid . getMostSignificantBits (  )  )  ;", "buffer . putLong ( uuid . getLeastSignificantBits (  )  )  ;", "new   ExternalizerTester <  >  ( new    . BasicSessionIDExternalizer (  )  )  . test ( SessionID . createSessionID ( buffer . array (  )  )  )  ;", "buffer    =    ByteBuffer . wrap ( new   byte [  1  6  ]  )  ;", "buffer . putLong ( uuid . getMostSignificantBits (  )  )  ;", "buffer . putLong ( uuid . getLeastSignificantBits (  )  )  ;", "new   ExternalizerTester <  >  ( new    . UnknownSessionIDExternalizer (  )  )  . test ( SessionID . createSessionID ( buffer . array (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ejb.infinispan.SessionIDSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( entry 1  . getBeanName (  )  ,    entry 2  . getBeanName (  )  )  ;", "Assert . assertEquals ( entry 1  . getGroupId (  )  ,    entry 2  . getGroupId (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "InfinispanBeanEntry < SessionID >    entry    =    new   InfinispanBeanEntry (  \" StatefulBean \"  ,    new   UUIDSessionID ( UUID . randomUUID (  )  )  )  ;", "new   ExternalizerTester ( new   InfinispanBeanEntryExternalizer (  )  ,     :  : assertEquals )  . test ( entry )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "InfinispanBeanKey < SessionID >    key    =    new   InfinispanBeanKey ( new   UUIDSessionID ( UUID . randomUUID (  )  )  )  ;", "new   ExternalizerTester <  >  ( new    . InfinispanBeanKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . InfinispanBeanKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanKeySerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    new   Object (  )  ;", "when ( this . group . getBean ( this . id ,    this . listener )  )  . thenReturn ( value )  ;", "Object   result    =    thisacquire (  )  ;", "Assert . assertSame ( value ,    result )  ;", "}", "METHOD_END"], "methodName": ["acquire"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . entry . getLastAccessedTime (  )  )  . thenReturn ( null )  ;", "when ( this . group . isCloseable (  )  )  . thenReturn ( false )  ;", "thisclose (  )  ;", "verify ( this . entry )  . setLastAccessedTime ( ArgumentMatchers .  < Date > any (  )  )  ;", "verify ( this . mutator ,    never (  )  )  . mutate (  )  ;", "verify ( this . group ,    never (  )  )  . close (  )  ;", "reset ( this . entry ,    this . mutator ,    this . group )  ;", "when ( this . entry . getLastAccessedTime (  )  )  . thenReturn ( new   Date (  )  )  ;", "when ( this . group . isCloseable (  )  )  . thenReturn ( true )  ;", "thisclose (  )  ;", "verify ( this . entry )  . setLastAccessedTime ( ArgumentMatchers .  < Date > any (  )  )  ;", "verify ( this . mutator )  . mutate (  )  ;", "verify ( this . group )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "String   groupId    =     \" group \"  ;", "when ( this . entry . getGroupId (  )  )  . thenReturn ( groupId )  ;", "String   result    =    thisgetGroupId (  )  ;", "Assert . assertSame ( groupId ,    result )  ;", "}", "METHOD_END"], "methodName": ["getGroupId"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . assertSame ( this . id ,    this . bean . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . entry . getLastAccessedTime (  )  )  . thenReturn ( null )  ;", "Assert . assertFalse ( thisisExpired (  )  )  ;", "long   now    =    System . currentTimeMillis (  )  ;", "when ( this . entry . getLastAccessedTime (  )  )  . thenReturn ( new   Date ( now )  )  ;", "Assert . assertFalse ( thisisExpired (  )  )  ;", "when ( this . entry . getLastAccessedTime (  )  )  . thenReturn ( new   Date (  (  ( now    -     ( this . timeout . convert ( TimeUnit . MILLISECONDS )  )  )     -     1  )  )  )  ;", "Assert . assertTrue ( thisisExpired (  )  )  ;", "}", "METHOD_END"], "methodName": ["isExpired"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "this . bean . release (  )  ;", "verify ( this . group )  . releaseBean ( this . id ,    this . listener )  ;", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "RemoveListener < Object >    listener    =    mock ( RemoveListener . class )  ;", "when ( this . group . isCloseable (  )  )  . thenReturn ( false )  ;", "thisremove ( listener )  ;", "verify ( this . remover )  . remove ( this . id ,    listener )  ;", "thisremove ( listener )  ;", "verifyNoMoreInteractions ( this . remover )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "reset ( this . entry ,    this . group ,    this . remover ,    this . listener )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.wildfly.clustering.ejb.infinispan.bean.InfinispanBeanTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   this . entry . getBeans (  )  . get ( this . context )  ;", "}    catch    ( IOException    |    ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . deserializationFailure ( e ,    this . id )  ;", "}", "}", "METHOD_END"], "methodName": ["beans"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroup"}, {"methodBody": ["METHOD_START", "{", "try    {", "Assert . assertEquals ( entry 1  . getBeans (  )  . get (  . context )  ,    entry 2  . getBeans (  )  . get (  . context )  )  ;", "}    catch    ( ClassNotFoundException    |    IOException   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionID   id    =    new   UUIDSessionID ( UUID . randomUUID (  )  )  ;", "Map < SessionID ,    String >    beans    =    Collections . singletonMap ( id ,     \" bean \"  )  ;", "InfinispanBeanGroupEntry < SessionID ,    String >    entry    =    new   InfinispanBeanGroupEntry ( new   SimpleMarshalledValue ( beans ,     . context )  )  ;", "new   ExternalizerTester ( new   InfinispanBeanGroupEntryExternalizer (  )  ,     :  : assertEquals )  . test ( entry )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( event . isPre (  )  )  )     {", "BeanGroupEntry < I ,    T >    entry    =    event . getValue (  )  ;", "try    ( BeanGroup < I ,    T >    group    =    new    ( event . getKey (  )  . getId (  )  ,    entry ,    this . context ,    Mutator . PASSIVE ,    this )  )     {", "for    ( I   beanId    :    group . getBeans (  )  )     {", "BeanKey < I >    beanKey    =    new   InfinispanBeanKey <  >  ( beanId )  ;", "BeanEntry < I >    beanEntry    =    this . beanCache . get ( beanKey )  ;", "if    (  ( beanEntry    !  =    null )     &  &     ( this . beanFilter . test ( new   AbstractMap . SimpleImmutableEntry <  >  ( beanKey ,    beanEntry )  )  )  )     {", "InfinispanEjbLogger . ROOT _ LOGGER . tracef (  \" Activating   bean    % s \"  ,    beanKey )  ;", "this . passiveCount . decrementAndGet (  )  ;", "group . postActivate ( beanId ,    this . passivationListener )  ;", "}", "}", "}    catch    ( Exception   e )     {", "InfinispanEjbLogger . ROOT _ LOGGER . warn ( e . getLocalizedMessage (  )  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["activated"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   InfinispanBeanGroup <  >  ( id ,    entry ,    this . context ,    mutator ,    this )  ;", "}", "METHOD_END"], "methodName": ["createGroup"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( event . isPre (  )  )     {", "BeanGroupEntry < I ,    T >    entry    =    event . getValue (  )  ;", "try    ( BeanGroup < I ,    T >    group    =    new    ( event . getKey (  )  . getId (  )  ,    entry ,    this . context ,    Mutator . PASSIVE ,    this )  )     {", "for    ( I   beanId    :    group . getBeans (  )  )     {", "BeanKey < I >    beanKey    =    new   InfinispanBeanKey <  >  ( beanId )  ;", "BeanEntry < I >    beanEntry    =    this . beanCache . getAdvancedCache (  )  . withFlags ( SKIP _ CACHE _ LOAD )  . get ( beanKey )  ;", "if    (  ( beanEntry    !  =    null )     &  &     ( this . beanFilter . test ( new   AbstractMap . SimpleImmutableEntry <  >  ( beanKey ,    beanEntry )  )  )  )     {", "InfinispanEjbLogger . ROOT _ LOGGER . tracef (  \" Passivating   bean    % s \"  ,    beanKey )  ;", "this . passiveCount . incrementAndGet (  )  ;", "group . prePassivate ( beanId ,    this . passivationListener )  ;", "this . beanCache . evict ( beanKey )  ;", "}", "}", "}    catch    ( Exception   e )     {", "InfinispanEjbLogger . ROOT _ LOGGER . warn ( e . getLocalizedMessage (  )  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["passivated"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupFactory"}, {"methodBody": ["METHOD_START", "{", "InfinispanBeanGroupKey < SessionID >    key    =    new   InfinispanBeanGroupKey ( new   UUIDSessionID ( UUID . randomUUID (  )  )  )  ;", "new   ExternalizerTester <  >  ( new    . InfinispanBeanGroupKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . InfinispanBeanGroupKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupKeySerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "Map < String ,    Object >    beans    =    mock ( Map . class )  ;", "String   id    =     \" id \"  ;", "Object   bean    =    new   Object (  )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( beans )  ;", "thisaddBean ( id ,    bean )  ;", "verify ( beans )  . put ( id ,    bean )  ;", "}", "METHOD_END"], "methodName": ["addBean"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( Collections .  < String ,    Object > emptyMap (  )  )  ;", "thisclose (  )  ;", "verify ( this . remover )  . remove ( this . id )  ;", "verify ( this . mutator ,    never (  )  )  . mutate (  )  ;", "reset ( this . remover ,    this . mutator )  ;", "when ( value . get ( this . context )  )  . thenReturn ( Collections . singletonMap (  \" id \"  ,    new   Object (  )  )  )  ;", "thisclose (  )  ;", "verify ( this . mutator )  . mutate (  )  ;", "verify ( this . remover ,    never (  )  )  . remove ( this . id )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "PassivationListener < Object >    listener    =    mock ( PassivationListener . class )  ;", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "Map < String ,    Object >    beans    =    mock ( Map . class )  ;", "String   id    =     \" id \"  ;", "Object   bean    =    new   Object (  )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( beans )  ;", "when ( beans . get ( id )  )  . thenReturn ( bean )  ;", "when ( this . entry . incrementUsage ( id )  )  . thenReturn (  1  )  ;", "Object   result    =    thisgetBean ( id ,    listener )  ;", "Assert . assertSame ( bean ,    result )  ;", "verifyZeroInteractions ( listener )  ;", "when ( this . entry . incrementUsage ( id )  )  . thenReturn (  0  )  ;", "result    =    thisgetBean ( id ,    listener )  ;", "Assert . assertSame ( bean ,    result )  ;", "verify ( listener )  . postActivate ( bean )  ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "Map < String ,    Object >    beans    =    Collections . singletonMap (  \" id \"  ,    new   Object (  )  )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( beans )  ;", "Assert . assertSame ( beans . keySet (  )  ,    thisgetBeans (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeans"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . assertSame ( this . id ,    this . group . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . entry . totalUsage (  )  )  . thenReturn (  1  )  ;", "Assert . assertFalse ( thisisCloseable (  )  )  ;", "when ( this . entry . totalUsage (  )  )  . thenReturn (  0  )  ;", "Assert . assertTrue ( thisisCloseable (  )  )  ;", "}", "METHOD_END"], "methodName": ["isCloseable"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "PassivationListener < Object >    listener    =    mock ( PassivationListener . class )  ;", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "Map < String ,    Object >    beans    =    mock ( Map . class )  ;", "String   id    =     \" id \"  ;", "Object   bean    =    new   Object (  )  ;", "thispostActivate ( id ,    null )  ;", "verifyZeroInteractions ( this . entry )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( beans )  ;", "when ( beans . get ( id )  )  . thenReturn ( bean )  ;", "thispostActivate ( id ,    listener )  ;", "verify ( listener )  . postActivate ( bean )  ;", "}", "METHOD_END"], "methodName": ["postActivate"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "PassivationListener < Object >    listener    =    mock ( PassivationListener . class )  ;", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "Map < String ,    Object >    beans    =    mock ( Map . class )  ;", "String   id    =     \" id \"  ;", "Object   bean    =    new   Object (  )  ;", "thisprePassivate ( id ,    null )  ;", "verifyZeroInteractions ( this . entry )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( beans )  ;", "when ( beans . get ( id )  )  . thenReturn ( bean )  ;", "thisprePassivate ( id ,    listener )  ;", "verify ( listener )  . prePassivate ( bean )  ;", "}", "METHOD_END"], "methodName": ["prePassivate"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "PassivationListener < Object >    listener    =    mock ( PassivationListener . class )  ;", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "Map < String ,    Object >    beans    =    mock ( Map . class )  ;", "String   id    =     \" id \"  ;", "Object   bean    =    new   Object (  )  ;", "when ( this . entry . decrementUsage ( id )  )  . thenReturn (  1  )  ;", "boolean   result    =    thisreleaseBean ( id ,    listener )  ;", "Assert . assertFalse ( result )  ;", "verifyZeroInteractions ( listener )  ;", "verify ( this . entry ,    never (  )  )  . getBeans (  )  ;", "when ( this . entry . decrementUsage ( id )  )  . thenReturn (  0  )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( beans )  ;", "when ( beans . get ( id )  )  . thenReturn ( bean )  ;", "result    =    thisreleaseBean ( id ,    listener )  ;", "Assert . assertTrue ( result )  ;", "verify ( listener )  . prePassivate ( bean )  ;", "}", "METHOD_END"], "methodName": ["releaseBean"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "MarshalledValue < Map < String ,    Object >  ,    MarshallingContext >    value    =    mock ( MarshalledValue . class )  ;", "Map < String ,    Object >    beans    =    mock ( Map . class )  ;", "String   id    =     \" id \"  ;", "Object   bean    =    new   Object (  )  ;", "when ( this . entry . getBeans (  )  )  . thenReturn ( value )  ;", "when ( value . get ( this . context )  )  . thenReturn ( beans )  ;", "when ( beans . remove ( id )  )  . thenReturn ( bean )  ;", "Object   result    =    thisremoveBean ( id )  ;", "Assert . assertSame ( bean ,    result )  ;", "}", "METHOD_END"], "methodName": ["removeBean"], "fileName": "org.wildfly.clustering.ejb.infinispan.group.InfinispanBeanGroupTestCase"}, {"methodBody": ["METHOD_START", "{", "this . register ( listener )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.wildfly.clustering.group.Group"}, {"methodBody": ["METHOD_START", "{", "return   this . getMembership (  )  . getCoordinator (  )  ;", "}", "METHOD_END"], "methodName": ["getCoordinatorNode"], "fileName": "org.wildfly.clustering.group.Group"}, {"methodBody": ["METHOD_START", "{", "return   this . getLocalMember (  )  ;", "}", "METHOD_END"], "methodName": ["getLocalNode"], "fileName": "org.wildfly.clustering.group.Group"}, {"methodBody": ["METHOD_START", "{", "return   this . getMembership (  )  . getMembers (  )  ;", "}", "METHOD_END"], "methodName": ["getNodes"], "fileName": "org.wildfly.clustering.group.Group"}, {"methodBody": ["METHOD_START", "{", "return   this . getMembership (  )  . isCoordinator (  )  ;", "}", "METHOD_END"], "methodName": ["isCoordinator"], "fileName": "org.wildfly.clustering.group.Group"}, {"methodBody": ["METHOD_START", "{", "return   this . isSingleton (  )  ;", "}", "METHOD_END"], "methodName": ["isLocal"], "fileName": "org.wildfly.clustering.group.Group"}, {"methodBody": ["METHOD_START", "{", "return   this . getCacheManagerConfiguration (  )  . defaultCacheName (  )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCacheName"], "fileName": "org.wildfly.clustering.infinispan.spi.CacheContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . getCacheManagerConfiguration (  )  . globalJmxStatistics (  )  . cacheManagerName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.clustering.infinispan.spi.CacheContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . value . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getGroup"], "fileName": "org.wildfly.clustering.infinispan.spi.distribution.Key"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.clustering.infinispan.spi.distribution.Key"}, {"methodBody": ["METHOD_START", "{", "List < KeyFormat <  ?  >  >    keyFormats    =    new   LinkedList <  >  (  )  ;", "for    ( KeyFormat <  ?  >    keyFormat    :    ServiceLoader . load ( KeyFormat . class ,    loader )  )     {", "keyFormats . add ( keyFormat )  ;", "}", "List < KeyFormat <  ?  >  >    result    =    new   ArrayList <  >  (  (  ( keyFormats . size (  )  )     +     6  )  )  ;", "result . add ( new   SimpleKeyFormat <  >  ( String . class ,    Function . identity (  )  )  )  ;", "result . add ( new   SimpleKeyFormat <  >  ( Byte . class ,    Byte :  : valueOf )  )  ;", "result . add ( new   SimpleKeyFormat <  >  ( Short . class ,    Short :  : valueOf )  )  ;", "result . add ( new   SimpleKeyFormat <  >  ( Integer . class ,    Integer :  : valueOf )  )  ;", "result . add ( new   SimpleKeyFormat <  >  ( Long . class ,    Long :  : valueOf )  )  ;", "result . add ( new   SimpleKeyFormat <  >  ( UUID . class ,    UUID :  : fromString )  )  ;", "result . addAll ( keyFormats )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.DynamicKeyFormatMapper"}, {"methodBody": ["METHOD_START", "{", "return   IntStream . range (  0  ,    size )  . mapToObj (  (    index )     -  >    new   SimpleKeyFormat <  >  (  (  ( Class < IndexedKeyFormatMapperTestCase . Type >  )     ( IndexedKeyFormatMapperTestCase . Type . values (  )  [ index ]  . getClass (  )  )  )  ,     (    value )     -  >    IndexedKeyFormatMapperTestCase . Type . valueOf ( value )  ,    IndexedKeyFormatMapperTestCase . Type :  : name )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPersistenceList"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.IndexedKeyFormatMapperTestCase"}, {"methodBody": ["METHOD_START", "{", "TwoWayKey 2 StringMapper   mapper    =    new   IndexedKeyFormatMapper ( IndexedKeyFormatMapperTestCase . createPersistenceList (  1  7  )  )  ;", "Assert . assertTrue ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 0  0  . getClass (  )  )  )  ;", "Assert . assertTrue ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  5  . getClass (  )  )  )  ;", "Assert . assertTrue ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  6  . getClass (  )  )  )  ;", "Assert . assertFalse ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  7  . getClass (  )  )  )  ;", "String   result    =    mapper . getStringMapping ( IndexedKeyFormatMapperTestCase . Type . TYPE 0  0  )  ;", "Assert . assertSame ( IndexedKeyFormatMapperTestCase . Type . TYPE 0  0  ,    mapper . getKeyMapping ( result )  )  ;", "Assert . assertEquals (  \"  0  0 TYPE 0  0  \"  ,    result )  ;", "result    =    mapper . getStringMapping ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  5  )  ;", "Assert . assertSame ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  5  ,    mapper . getKeyMapping ( result )  )  ;", "Assert . assertEquals (  \"  0 FTYPE 1  5  \"  ,    result )  ;", "result    =    mapper . getStringMapping ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  6  )  ;", "Assert . assertSame ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  6  ,    mapper . getKeyMapping ( result )  )  ;", "Assert . assertEquals (  \"  1  0 TYPE 1  6  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testDoublePadding"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.IndexedKeyFormatMapperTestCase"}, {"methodBody": ["METHOD_START", "{", "TwoWayKey 2 StringMapper   mapper    =    new   IndexedKeyFormatMapper ( IndexedKeyFormatMapperTestCase . createPersistenceList (  1  6  )  )  ;", "Assert . assertTrue ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 0  0  . getClass (  )  )  )  ;", "Assert . assertTrue ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  5  . getClass (  )  )  )  ;", "Assert . assertFalse ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  6  . getClass (  )  )  )  ;", "Assert . assertFalse ( mapper . isSupportedType ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  7  . getClass (  )  )  )  ;", "String   result    =    mapper . getStringMapping ( IndexedKeyFormatMapperTestCase . Type . TYPE 0  0  )  ;", "Assert . assertSame ( IndexedKeyFormatMapperTestCase . Type . TYPE 0  0  ,    mapper . getKeyMapping ( result )  )  ;", "Assert . assertEquals (  \"  0 TYPE 0  0  \"  ,    result )  ;", "result    =    mapper . getStringMapping ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  5  )  ;", "Assert . assertSame ( IndexedKeyFormatMapperTestCase . Type . TYPE 1  5  ,    mapper . getKeyMapping ( result )  )  ;", "Assert . assertEquals (  \" FTYPE 1  5  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testSinglePadding"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.IndexedKeyFormatMapperTestCase"}, {"methodBody": ["METHOD_START", "{", "KeyFormatTester . assertTrue ( this . format . getTargetClass (  )  . isInstance ( subject )  )  ;", "String   formatted    =    this . format . format ( subject )  ;", "K   result    =    this . format . parse ( formatted )  ;", "KeyFormatTester . assertTrue ( this . format . getTargetClass (  )  . isInstance ( result )  )  ;", "this . assertion . accept ( subject ,    result )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.KeyFormatTester"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . mapper . isSupportedType ( key . getClass (  )  )  )  ;", "String   mapping    =    this . mapper . getStringMapping ( key )  ;", "Object   result    =    this . mapper . geting ( mapping )  ;", "assertEquals ( key ,    result )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.KeyMapperTester"}, {"methodBody": ["METHOD_START", "{", "KeyFormat < Object >    keyFormat    =    mock ( KeyFormat . class )  ;", "TwoWayKey 2 StringMapper   mapper    =    new    ( keyFormat )  ;", "Object   key    =    new   Object (  )  ;", "String   formatted    =     \" foo \"  ;", "when ( keyFormat . getTargetClass (  )  )  . thenReturn ( Object . class )  ;", "when ( keyFormat . format ( key )  )  . thenReturn ( formatted )  ;", "when ( keyFormat . parse ( formatted )  )  . thenReturn ( key )  ;", "Assert . assertSame ( formatted ,    mapper . getStringMapping ( key )  )  ;", "Assert . assertSame ( key ,    mapper . getKeyMapping ( formatted )  )  ;", "Assert . assertTrue ( mapper . isSupportedType ( Object . class )  )  ;", "Assert . assertFalse ( mapper . isSupportedType ( Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.SimpleKeyFormatMapperTestCase"}, {"methodBody": ["METHOD_START", "{", "Function < String ,    Object >    parser    =    mock ( Function . class )  ;", "Function < Object ,    String >    formatter    =    mock ( Function . class )  ;", "KeyFormat < Object >    format    =    new    <  >  ( Object . class ,    parser ,    formatter )  ;", "Object   object    =    new   Object (  )  ;", "String   result    =     \" foo \"  ;", "when ( formatter . apply ( object )  )  . thenReturn ( result )  ;", "when ( parser . apply ( result )  )  . thenReturn ( object )  ;", "new   KeyFormatTester ( format ,    Assert :  : assertSame )  . test ( object )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.infinispan.spi.persistence.SimpleKeyFormatTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( E   value    :    EnumSet . allOf ( this . targetClass )  )     {", "this . test ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.EnumExternalizerTester"}, {"methodBody": ["METHOD_START", "{", "ExternalizerTester . assertTrue ( this . externalizer . getTargetClass (  )  . isInstance ( subject )  )  ;", "ByteArrayOutputStream   externalizedOutput    =    new   ByteArrayOutputStream (  )  ;", "try    ( ObjectOutputStream   output    =    new   ObjectOutputStream ( externalizedOutput )  )     {", "this . externalizer . writeObject ( output ,    subject )  ;", "}", "byte [  ]    externalizedBytes    =    externalizedOutput . toByteArray (  )  ;", "try    ( ObjectInputStream   input    =    new   ObjectInputStream ( new   ByteArrayInputStream ( externalizedBytes )  )  )     {", "T   result    =    this . externalizer . readObject ( input )  ;", "ExternalizerTester . assertTrue ( this . externalizer . getTargetClass (  )  . isInstance ( result )  )  ;", "this . assertion . accept ( subject ,    result )  ;", "}", "if    ( subject   instanceof   Serializable )     {", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "try    ( ObjectOutputStream   output    =    new   ObjectOutputStream ( out )  )     {", "output . writeObject ( subject )  ;", "}", "byte [  ]    bytes    =    out . toByteArray (  )  ;", "Assert . assertTrue (  (  ( externalizedBytes . length )     <     ( bytes . length )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.ExternalizerTester"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    knownClasses    =    new   LinkedList <  >  (  )  ;", "for    ( Contributor   contributor    :    ServiceLoader . load ( Contributor . class ,    loader )  )     {", "knownClasses . addAll ( contributor . getKnownClasses (  )  )  ;", "}", "List < Class <  ?  >  >    classes    =    new   ArrayList <  >  (  (  ( knownClasses . size (  )  )     +     3  0  )  )  ;", "classes . add ( Serializable . class )  ;", "classes . add ( Externalizable . class )  ;", "classes . add ( Clock . systemDefaultZone (  )  . getClass (  )  )  ;", "classes . add ( TimeZone . getDefault (  )  . getClass (  )  )  ;", "classes . add ( ZoneId . systemDefault (  )  . getClass (  )  )  ;", "classes . add ( Collections . checkedCollection ( Collections . emptyList (  )  ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedList ( Collections . emptyList (  )  ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedMap ( Collections . emptyMap (  )  ,    Void . class ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedNavigableMap ( Collections . emptyNavigableMap (  )  ,    Void . class ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedNavigableSet ( Collections . emptyNavigableSet (  )  ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedQueue ( new   LinkedList <  >  (  )  ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedSet ( Collections . emptySet (  )  ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedSortedMap ( Collections . emptySortedMap (  )  ,    Void . class ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . checkedSortedSet ( Collections . emptySortedSet (  )  ,    Void . class )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedCollection ( Collections . emptyList (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedList ( Collections . emptyList (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedMap ( Collections . emptyMap (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedNavigableMap ( Collections . emptyNavigableMap (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedNavigableSet ( Collections . emptyNavigableSet (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedSet ( Collections . emptySet (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedSortedMap ( Collections . emptySortedMap (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . synchronizedSortedSet ( Collections . emptySortedSet (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableCollection ( Collections . emptyList (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableList ( Collections . emptyList (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableMap ( Collections . emptyMap (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableNavigableMap ( Collections . emptyNavigableMap (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableNavigableSet ( Collections . emptyNavigableSet (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableSet ( Collections . emptySet (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableSortedMap ( Collections . emptySortedMap (  )  )  . getClass (  )  )  ;", "classes . add ( Collections . unmodifiableSortedSet ( Collections . emptySortedSet (  )  )  . getClass (  )  )  ;", "classes . addAll ( knownClasses )  ;", "return   classes ;", "}", "METHOD_END"], "methodName": ["findClasses"], "fileName": "org.wildfly.clustering.marshalling.jboss.DynamicClassTable"}, {"methodBody": ["METHOD_START", "{", "List < Externalizer < Object >  >    loadedExternalizers    =    new   LinkedList <  >  (  )  ;", "for    ( Externalizer < Object >    externalizer    :    ServiceLoader . load ( Externalizer . class ,    loader )  )     {", "loadedExternalizers . add ( externalizer )  ;", "}", "Set < DefaultExternalizer >    defaultExternalizers    =    EnumSet . allOf ( DefaultExternalizer . class )  ;", "List < Externalizer < Object >  >    result    =    new   ArrayList <  >  (  (  ( defaultExternalizers . size (  )  )     +     ( loadedExternalizers . size (  )  )  )  )  ;", "result . addAll ( defaultExternalizers )  ;", "result . addAll ( loadedExternalizers )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["loadExternalizers"], "fileName": "org.wildfly.clustering.marshalling.jboss.ExternalizerObjectTable"}, {"methodBody": ["METHOD_START", "{", "in . defaultReadObject (  )  ;", "this . hCode    =    in . readInt (  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.wildfly.clustering.marshalling.jboss.HashableMarshalledValue"}, {"methodBody": ["METHOD_START", "{", "out . defaultWriteObject (  )  ;", "out . writeInt ( this . hCode )  ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.wildfly.clustering.marshalling.jboss.HashableMarshalledValue"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    this . bytes ;", "if    ( bytes    !  =    null )", "return   bytes ;", "if    (  ( this . object )     =  =    null )", "return   null ;", "int   version    =    this . context . getCurrentVersion (  )  ;", "ByteArrayOutputStream   output    =    new   ByteArrayOutputStream (  )  ;", "ClassLoader   loader    =     . setThreadContextClassLoader ( this . context . getClassLoader (  )  )  ;", "try    ( SimpleDataOutput   data    =    new   SimpleDataOutput ( Marshalling . createByteOutput ( output )  )  )     {", "IndexSerializer . VARIABLE . writeInt ( data ,    version )  ;", "try    ( Marshaller   marshaller    =    this . context . createMarshaller ( version )  )     {", "marshaller . start ( data )  ;", "marshaller . writeObject ( this . object )  ;", "marshaller . finish (  )  ;", "return   output . toByteArray (  )  ;", "}", "}    finally    {", ". setThreadContextClassLoader ( loader )  ;", "}", "}", "METHOD_END"], "methodName": ["getBytes"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValue"}, {"methodBody": ["METHOD_START", "{", "return   this . object ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValue"}, {"methodBody": ["METHOD_START", "{", "in . defaultReadObject (  )  ;", "int   size    =    in . readInt (  )  ;", "byte [  ]    bytes    =    null ;", "if    ( size    >     0  )     {", "bytes    =    new   byte [ size ]  ;", "in . readFully ( bytes )  ;", "}", "this . bytes    =    bytes ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValue"}, {"methodBody": ["METHOD_START", "{", "return   loader    !  =    null    ?    WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( loader )     :    null ;", "}", "METHOD_END"], "methodName": ["setThreadContextClassLoader"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValue"}, {"methodBody": ["METHOD_START", "{", "out . defaultWriteObject (  )  ;", "byte [  ]    bytes    =    this . getBytes (  )  ;", "if    ( bytes    !  =    null )     {", "out . writeInt ( bytes . length )  ;", "out . write ( bytes )  ;", "} else    {", "out . writeInt (  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValue"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleMarshalledValueFactory ( context )  ;", "}", "METHOD_END"], "methodName": ["createFactory"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "UUID   uuid    =    UUID . randomUUID (  )  ;", "< UUID >    mv    =    this . factory . createMarshalledValue ( uuid )  ;", "assertTrue ( mv . equals ( mv )  )  ;", "assertFalse ( mv . equals ( null )  )  ;", "< UUID >    dup    =    this . factory . createMarshalledValue ( uuid )  ;", "assertTrue ( mv . equals ( dup )  )  ;", "assertTrue ( dup . equals ( mv )  )  ;", "< UUID >    replica    =    replicate ( mv )  ;", "assertTrue ( mv . equals ( replica )  )  ;", "assertTrue ( replica . equals ( mv )  )  ;", "< UUID >    nulled    =    this . factory . createMarshalledValue ( null )  ;", "assertFalse ( mv . equals ( nulled )  )  ;", "assertFalse ( nulled . equals ( mv )  )  ;", "assertFalse ( replica . equals ( nulled )  )  ;", "assertFalse ( nulled . equals ( replica )  )  ;", "assertTrue ( nulled . equals ( nulled )  )  ;", "assertFalse ( nulled . equals ( null )  )  ;", "assertTrue ( nulled . equals ( this . factory . createMarshalledValue ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "UUID   uuid    =    UUID . randomUUID (  )  ;", "< UUID >    mv    =    this . factory . createMarshalledValue ( uuid )  ;", "assertNotNull ( mv . peek (  )  )  ;", "assertSame ( uuid ,    mv . peek (  )  )  ;", "assertSame ( uuid ,    mv . get ( this . context )  )  ;", "< UUID >    copy    =    replicate ( mv )  ;", "assertNull ( copy . peek (  )  )  ;", "UUID   uuid 2     =    copy . get ( this . context )  ;", "assertNotSame ( uuid ,    uuid 2  )  ;", "assertEquals ( uuid ,    uuid 2  )  ;", "copy    =    replicate ( copy )  ;", "uuid 2     =    copy . get ( this . context )  ;", "assertEquals ( uuid ,    uuid 2  )  ;", "mv    =    this . factory . createMarshalledValue ( null )  ;", "assertNull ( mv . peek (  )  )  ;", "assertNull ( mv . getBytes (  )  )  ;", "assertNull ( mv . get ( this . context )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "try    ( ObjectOutputStream   oos    =    new   ObjectOutputStream ( baos )  )     {", "oos . writeObject ( mv )  ;", "}", "return   baos . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["marshall"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SimpleMarshalledValue < V >  )     ( SimpleMarshalledValueFactoryTestCase . unmarshall ( SimpleMarshalledValueFactoryTestCase . marshall ( mv )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["replicate"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "UUID   uuid    =    UUID . randomUUID (  )  ;", "< UUID >    mv    =    this . factory . createMarshalledValue ( uuid )  ;", "assertEquals ( uuid . hashCode (  )  ,    mv . hashCode (  )  )  ;", "< UUID >    copy    =    replicate ( mv )  ;", "this . validateHashCode ( uuid ,    copy )  ;", "mv    =    this . factory . createMarshalledValue ( null )  ;", "assertEquals (  0  ,    mv . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHashCode"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "ByteArrayInputStream   bais    =    new   ByteArrayInputStream ( bytes )  ;", "try    ( ObjectInputStream   ois    =    new   ObjectInputStream ( bais )  )     {", "return   ois . readObject (  )  ;", "}", "}", "METHOD_END"], "methodName": ["unmarshall"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    copy . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateHashCode"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshalledValueFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "List < Function < C ,    MarshallingConfiguration >  >    values    =    Arrays . asList ( enumClass . getEnumConstants (  )  )  ;", "MarshallingConfiguration [  ]    configurations    =    new   MarshallingConfiguration [ values . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( configurations . length )  ;     +  + i )     {", "configurations [ i ]     =    values . get ( i )  . apply ( context )  ;", "}", "return   configurations ;", "}", "METHOD_END"], "methodName": ["createConfigurations"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshallingConfigurationRepository"}, {"methodBody": ["METHOD_START", "{", "return   this . repository . getMarshallingConfiguration ( version )  ;", "}", "METHOD_END"], "methodName": ["getMarshallingConfiguration"], "fileName": "org.wildfly.clustering.marshalling.jboss.SimpleMarshallingContext"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( type . isAssignableFrom ( this . externalizer . getTargetClass (  )  )  )  )     {", "throw   new   IllegalArgumentException ( type . getName (  )  )  ;", "}", "return    (  (  < T >  )     ( this . externalizer )  )  ;", "}", "METHOD_END"], "methodName": ["cast"], "fileName": "org.wildfly.clustering.marshalling.spi.DefaultExternalizer"}, {"methodBody": ["METHOD_START", "{", "if    ( size    <     2  5  6  )", "return    . UNSIGNED _ BYTE ;", "if    ( size    <     6  5  5  3  6  )", "return    . UNSIGNED _ SHORT ;", "if    ( size    <     2  6  8  4  3  5  4  5  6  )", "return    . VARIABLE ;", "return    . INTEGER ;", "}", "METHOD_END"], "methodName": ["select"], "fileName": "org.wildfly.clustering.marshalling.spi.IndexSerializer"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   externalizedOutput    =    new   ByteArrayOutputStream (  )  ;", "try    ( DataOutputStream   output    =    new   DataOutputStream ( externalizedOutput )  )     {", "extern . writeInt ( output ,    index )  ;", "}", "byte [  ]    externalizedBytes    =    externalizedOutput . toByteArray (  )  ;", "try    ( DataInputStream   input    =    new   DataInputStream ( new   ByteArrayInputStream ( externalizedBytes )  )  )     {", "int   result    =    extern . readInt ( input )  ;", "assertEquals ( index ,    result )  ;", "}", "return   externalizedBytes . length ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.wildfly.clustering.marshalling.spi.IndexSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     (  ( Integer . SIZE )     -     2  )  ;     +  + i )     {", "int   index    =     2     <  <    i ;", ". test (  ( index    -     1  )  )  ;", ". test ( index )  ;", "}", ". test ( Integer . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.IndexSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "IntStream . Builder   builder    =    IntStream . builder (  )  ;", "try    {", "builder . add (  . size ( IndexSerializer . UNSIGNED _ BYTE ,    index )  )  ;", "}    catch    ( IndexOutOfBoundsException   e )     {", "assertTrue (  ( index    >     (  ( Byte . MAX _ VALUE )     -     ( Byte . MIN _ VALUE )  )  )  )  ;", "}", "try    {", "builder . add (  . size ( IndexSerializer . UNSIGNED _ SHORT ,    index )  )  ;", "}    catch    ( IndexOutOfBoundsException   e )     {", "assertTrue (  ( index    >     (  ( Short . MAX _ VALUE )     -     ( Short . MIN _ VALUE )  )  )  )  ;", "}", "builder . add (  . size ( IndexSerializer . VARIABLE ,    index )  )  ;", "builder . add (  . size ( IndexSerializer . INTEGER ,    index )  )  ;", "assertEquals ( builder . build (  )  . min (  )  . getAsInt (  )  ,     . size ( IndexSerializer . select ( index )  ,    index )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.IndexSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "return   input . readInt (  )  ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "org.wildfly.clustering.marshalling.spi.IntSerializer"}, {"methodBody": ["METHOD_START", "{", "output . writeInt ( value )  ;", "}", "METHOD_END"], "methodName": ["writeInt"], "fileName": "org.wildfly.clustering.marshalling.spi.IntSerializer"}, {"methodBody": ["METHOD_START", "{", "new   ExternalizerTester <  >  ( DefaultExternalizer . URI . cast ( URI . class )  )  . test ( URI . create (  \" http :  /  / wildfly . org / news /  \"  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . URL . cast ( URL . class )  )  . test ( new   URL (  \" http :  /  / wildfly . org / news /  \"  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . INET _ ADDRESS . cast ( InetAddress . class )  )  . test ( InetAddress . getLoopbackAddress (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . INET 4  _ ADDRESS . cast ( InetAddress . class )  )  . test ( InetAddress . getByName (  \"  1  2  7  .  0  .  0  .  1  \"  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . INET 6  _ ADDRESS . cast ( InetAddress . class )  )  . test ( InetAddress . getByName (  \"  :  :  1  \"  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . INET _ SOCKET _ ADDRESS . cast ( InetSocketAddress . class )  )  . test ( InetSocketAddress . createUnresolved (  \" hostname \"  ,     0  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . INET _ SOCKET _ ADDRESS . cast ( InetSocketAddress . class )  )  . test ( new   InetSocketAddress ( InetAddress . getLoopbackAddress (  )  ,    Short . MAX _ VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.net.NetExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "new   EnumExternalizerTester <  >  ( DefaultExternalizer . DAY _ OF _ WEEK . cast ( DayOfWeek . class )  )  . test (  )  ;", "new   EnumExternalizerTester <  >  ( DefaultExternalizer . MONTH . cast ( Month . class )  )  . test (  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . DURATION . cast ( Duration . class )  )  . test ( Duration . between ( Instant . EPOCH ,    Instant . now (  )  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . INSTANT . cast ( Instant . class )  )  . test ( Instant . now (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . LOCAL _ DATE . cast ( LocalDate . class )  )  . test ( LocalDate . now (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . LOCAL _ DATE _ TIME . cast ( LocalDateTime . class )  )  . test ( LocalDateTime . now (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . LOCAL _ TIME . cast ( LocalTime . class )  )  . test ( LocalTime . now (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . MONTH _ DAY . cast ( MonthDay . class )  )  . test ( MonthDay . now (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . PERIOD . cast ( Period . class )  )  . test ( Period . between ( LocalDate . ofEpochDay (  0  )  ,    LocalDate . now (  )  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . YEAR . cast ( Year . class )  )  . test ( Year . now (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . YEAR _ MONTH . cast ( YearMonth . class )  )  . test ( YearMonth . now (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . ZONE _ OFFSET . cast ( ZoneOffset . class )  )  . test ( ZoneOffset . UTC )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . ZONE _ ID . cast ( ZoneId . class )  )  . test ( ZoneId . of (  \" America / New _ York \"  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.time.TimeExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "new   ExternalizerTester <  >  ( DefaultExternalizer . ATOMIC _ BOOLEAN . cast ( AtomicBoolean . class )  ,     (    expected ,    actual )     -  >    assertEquals ( expected . get (  )  ,    actual . get (  )  )  )  . test ( new   AtomicBoolean ( true )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . ATOMIC _ INTEGER . cast ( AtomicInteger . class )  ,     (    expected ,    actual )     -  >    assertEquals ( expected . get (  )  ,    actual . get (  )  )  )  . test ( new   AtomicInteger ( Integer . MAX _ VALUE )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . ATOMIC _ LONG . cast ( AtomicLong . class )  ,     (    expected ,    actual )     -  >    assertEquals ( expected . get (  )  ,    actual . get (  )  )  )  . test ( new   AtomicLong ( Long . MAX _ VALUE )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . ATOMIC _ REFERENCE . cast ( AtomicReference . class )  ,     (    expected ,    actual )     -  >    assertEquals ( expected . get (  )  ,    actual . get (  )  )  )  . test ( new   AtomicReference < Object >  ( Boolean . TRUE )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.util.AtomicExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    size ;     +  + i )     {", "c . add ( input . readObject (  )  )  ;", "}", "return   c ;", "}", "METHOD_END"], "methodName": ["readCollection"], "fileName": "org.wildfly.clustering.marshalling.spi.util.CollectionExternalizer"}, {"methodBody": ["METHOD_START", "{", "IndexSerializer . VARIABLE . writeInt ( output ,    collection . size (  )  )  ;", "for    ( Object   element    :    collection )     {", "output . writeObject ( element )  ;", "}", "}", "METHOD_END"], "methodName": ["writeCollection"], "fileName": "org.wildfly.clustering.marshalling.spi.util.CollectionExternalizer"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( expected . size (  )  ,    actual . size (  )  )  ;", "Assert . assertTrue ( expected . containsAll ( actual )  )  ;", "}", "METHOD_END"], "methodName": ["assertCollectionEquals"], "fileName": "org.wildfly.clustering.marshalling.spi.util.CollectionExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "Collection < Object >    basis    =    Arrays .  < Object > asList (  1  ,     2  ,     3  ,     4  ,     5  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . ARRAY _ DEQUE . cast ( ArrayDeque . class )  ,     :  : assertCollectionEquals )  . test ( new   ArrayDeque <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . ARRAY _ LIST . cast ( ArrayList . class )  ,     :  : assertCollectionEquals )  . test ( new   ArrayList <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . CONCURRENT _ LINKED _ DEQUE . cast ( ConcurrentLinkedDeque . class )  ,     :  : assertCollectionEquals )  . test ( new   ConcurrentLinkedDeque <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . CONCURRENT _ LINKED _ QUEUE . cast ( ConcurrentLinkedQueue . class )  ,     :  : assertCollectionEquals )  . test ( new   ConcurrentLinkedQueue <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . HASH _ SET . cast ( HashSet . class )  ,     :  : assertCollectionEquals )  . test ( new   HashSet <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . LINKED _ HASH _ SET . cast ( LinkedHashSet . class )  ,     :  : assertCollectionEquals )  . test ( new   LinkedHashSet <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . LINKED _ LIST . cast ( LinkedList . class )  ,     :  : assertCollectionEquals )  . test ( new   LinkedList <  >  ( basis )  )  ;", "ConcurrentHashMap . KeySetView < Object ,    Boolean >    keySetView    =    ConcurrentHashMap . newKeySet (  )  ;", "keySetView . addAll ( basis )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . CONCURRENT _ HASH _ SET . cast ( ConcurrentHashMap . KeySetView . class )  ,     :  : assertCollectionEquals )  . test ( keySetView )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . COPY _ ON _ WRITE _ ARRAY _ LIST . cast ( CopyOnWriteArrayList . class )  ,     :  : assertCollectionEquals )  . test ( new   CopyOnWriteArrayList <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . COPY _ ON _ WRITE _ ARRAY _ SET . cast ( CopyOnWriteArraySet . class )  ,     :  : assertCollectionEquals )  . test ( new   CopyOnWriteArraySet <  >  ( basis )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ ENUMERATION . cast ( Enumeration . class )  ,    Assert :  : assertSame )  . test ( Collections . emptyEnumeration (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ ITERATOR . cast ( Iterator . class )  ,    Assert :  : assertSame )  . test ( Collections . emptyIterator (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ LIST . cast ( List . class )  ,    Assert :  : assertSame )  . test ( Collections . emptyList (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ LIST _ ITERATOR . cast ( ListIterator . class )  ,    Assert :  : assertSame )  . test ( Collections . emptyListIterator (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ NAVIGABLE _ SET . cast ( NavigableSet . class )  ,    Assert :  : assertSame )  . test ( Collections . emptyNavigableSet (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ SET . cast ( Set . class )  ,    Assert :  : assertSame )  . test ( Collections . emptySet (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ SORTED _ SET . cast ( SortedSet . class )  ,    Assert :  : assertSame )  . test ( Collections . emptySortedSet (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . SINGLETON _ LIST . cast ( List . class )  ,     :  : assertCollectionEquals )  . test ( Collections . singletonList (  1  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . SINGLETON _ SET . cast ( Set . class )  ,     :  : assertCollectionEquals )  . test ( Collections . singleton (  1  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . CONCURRENT _ SKIP _ LIST _ SET . cast ( ConcurrentSkipListSet . class )  ,     :  : assertCollectionEquals )  . test ( new   ConcurrentSkipListSet <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . TREE _ SET . cast ( TreeSet . class )  ,     :  : assertCollectionEquals )  . test ( new   TreeSet <  >  ( basis )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.util.CollectionExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "new   ExternalizerTester <  >  ( DefaultExternalizer . DATE . cast ( Date . class )  )  . test ( Date . from ( Instant . now (  )  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . SQL _ DATE . cast ( class )  )  . test ( valueOf ( LocalDate . now (  )  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . SQL _ TIME . cast ( Time . class )  )  . test ( Time . valueOf ( LocalTime . now (  )  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . SQL _ TIMESTAMP . cast ( Timestamp . class )  )  . test ( Timestamp . valueOf ( LocalDateTime . now (  )  )  )  ;", "ExternalizerTester < Calendar >    calendarTester    =    new   ExternalizerTester <  >  ( DefaultExternalizer . CALENDAR . cast ( Calendar . class )  )  ;", "calendarTester . test ( Calendar . getInstance (  )  )  ;", "calendarTester . test ( new   Calendar . Builder (  )  . setLenient ( false )  . setLocale ( Locale . FRANCE )  . build (  )  )  ;", "calendarTester . test ( Calendar . getInstance ( TimeZone . getTimeZone (  \" Asia / Tokyo \"  )  ,    Locale . JAPAN )  )  ;", "calendarTester . test ( Calendar . getInstance ( TimeZone . getTimeZone (  \" Asia / Bangkok \"  )  ,    Locale . forLanguageTag (  \" th _ TH \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.util.DateExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "Object   key    =     \" key \"  ;", "Object   value    =     \" value \"  ;", "new   er <  >  ( DefaultExternalizer . SIMPLE _ ENTRY . cast ( AbstractMap . SimpleEntry . class )  )  . test ( new   AbstractMap . SimpleEntry <  >  ( key ,    value )  )  ;", "new   er <  >  ( DefaultExternalizer . SIMPLE _ IMMUTABLE _ ENTRY . cast ( AbstractMap . SimpleImmutableEntry . class )  )  . test ( new   AbstractMap . SimpleImmutableEntry <  >  ( key ,    value )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.util.MapEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    size ;     +  + i )     {", "map . put ( input . readObject (  )  ,    input . readObject (  )  )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["readMap"], "fileName": "org.wildfly.clustering.marshalling.spi.util.MapExternalizer"}, {"methodBody": ["METHOD_START", "{", "IndexSerializer . VARIABLE . writeInt ( output ,    map . size (  )  )  ;", "for    ( Map . Entry < Object ,    Object >    entry    :    map . entrySet (  )  )     {", "output . writeObject ( entry . getKey (  )  )  ;", "output . writeObject ( entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeMap"], "fileName": "org.wildfly.clustering.marshalling.spi.util.MapExternalizer"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( expected . size (  )  ,    actual . size (  )  )  ;", "Assert . assertTrue ( expected . keySet (  )  . containsAll ( actual . keySet (  )  )  )  ;", "for    ( Map . Entry < Object ,    Object >    entry    :    expected . entrySet (  )  )     {", "Assert . assertEquals ( entry . getValue (  )  ,    actual . get ( entry . getKey (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertMapEquals"], "fileName": "org.wildfly.clustering.marshalling.spi.util.MapExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "Map < Object ,    Object >    basis    =    Stream . of (  1  ,     2  ,     3  ,     4  ,     5  )  . collect ( Collectors .  < Integer ,    Object ,    Object > toMap (  (    i )     -  >    i ,     (    i )     -  >    Integer . toString ( i )  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . CONCURRENT _ HASH _ MAP . cast ( ConcurrentHashMap . class )  ,     :  : assertMapEquals )  . test ( new   ConcurrentHashMap <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . HASH _ MAP . cast ( HashMap . class )  ,     :  : assertMapEquals )  . test ( new   HashMap <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . LINKED _ HASH _ MAP . cast ( LinkedHashMap . class )  ,     :  : assertMapEquals )  . test ( new   LinkedHashMap <  >  ( basis )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ MAP . cast ( Map . class )  ,    Assert :  : assertSame )  . test ( Collections . emptyMap (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ NAVIGABLE _ MAP . cast ( NavigableMap . class )  ,    Assert :  : assertSame )  . test ( Collections . emptyNavigableMap (  )  )  ;", "new   ExternalizerTester ( DefaultExternalizer . EMPTY _ SORTED _ MAP . cast ( SortedMap . class )  ,    Assert :  : assertSame )  . test ( Collections . emptySortedMap (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . SINGLETON _ MAP . cast ( Map . class )  ,     :  : assertMapEquals )  . test ( Collections . singletonMap (  1  ,     2  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . CONCURRENT _ SKIP _ LIST _ MAP . cast ( ConcurrentSkipListMap . class )  ,     :  : assertMapEquals )  . test ( new   ConcurrentSkipListMap <  >  ( basis )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . TREE _ MAP . cast ( TreeMap . class )  ,     :  : assertMapEquals )  . test ( new   TreeMap <  >  ( basis )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.util.MapExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "new   ExternalizerTester <  >  ( DefaultExternalizer . CURRENCY . cast ( Currency . class )  )  . test ( Currency . getInstance ( Locale . US )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . LOCALE . cast ( Locale . class )  )  . test ( Locale . US )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . NATURAL _ ORDER _ COMPARATOR . cast ( Comparator . class )  )  . test ( Comparator . naturalOrder (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . OPTIONAL . cast ( Optional . class )  )  . test ( Optional . empty (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . OPTIONAL . cast ( Optional . class )  )  . test ( Optional . of ( UUID . randomUUID (  )  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . REVERSE _ ORDER _ COMPARATOR . cast ( Comparator . class )  )  . test ( Comparator . reverseOrder (  )  )  ;", "new   EnumExternalizerTester <  >  ( DefaultExternalizer . TIME _ UNIT . cast ( TimeUnit . class )  )  . test (  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . TIME _ ZONE . cast ( TimeZone . class )  )  . test ( TimeZone . getDefault (  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . TIME _ ZONE . cast ( TimeZone . class )  )  . test ( TimeZone . getTimeZone (  \" America / New _ York \"  )  )  ;", "new   ExternalizerTester <  >  ( DefaultExternalizer . UUID . cast ( UUID . class )  )  . test ( UUID . randomUUID (  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.marshalling.spi.util.UtilExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . register ( listener )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.wildfly.clustering.registry.Registry"}, {"methodBody": ["METHOD_START", "{", "KeyMapperTester   tester    =    new   KeyMapperTester ( new   KeyMapper (  )  )  ;", "tester . test ( new   LocalNode (  \" node \"  )  )  ;", "tester . test ( new   AddressableNode ( UUID . randomUUID (  )  ,     \" node \"  ,    new   InetSocketAddress ( InetAddress . getLoopbackAddress (  )  ,    Short . MAX _ VALUE )  )  )  ;", "tester . test ( JBOSS . append (  \" service \"  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.KeyMapperTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceLoaderTestCase . load ( Externalizer . class )  ;", "ServiceLoaderTestCase . load ( ClassTableContributor . class )  ;", "ServiceLoaderTestCase . load ( GroupAliasBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( CacheAliasBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( DistributedGroupBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( DistributedCacheBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( LocalGroupBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( LocalCacheBuilderProvider . class )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.wildfly.clustering.server.ServiceLoaderTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceLoader . load ( targetClass ,    ServiceLoaderTestCase . class . getClassLoader (  )  )  . forEach (  (    object )     -  >    ServiceLoaderTestCase . LOGGER . trace (  (  \"  \\ t \"     +     ( object . getClass (  )  . getName (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.wildfly.clustering.server.ServiceLoaderTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Buffer ( this . marshaller . marshal ( c )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   IllegalArgumentException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createBuffer"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "Throwable   exception    =    response . getException (  )  ;", "return   exception    !  =    null    ?    new   SimpleResponse <  >  ( exception )     :    new   SimpleResponse ( response . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCommandResponse"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestOptions ( ResponseMode . GET _ ALL ,    this . timeout ,    false ,    ChannelCommandDispatcher . FILTER ,    Flag . DONT _ BUNDLE ,    Flag . OOB )  ;", "}", "METHOD_END"], "methodName": ["createRequestOptions"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "Address [  ]    excludedAddresses    =    new   Address [ excludedNodes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( excludedNodes . length )  ;     +  + i )     {", "excludedAddresses [ i ]     =    this . group . getAddress ( excludedNodes [ i ]  )  ;", "}", "return   this . createRequestOptions (  )  . exionList ( excludedAddresses )  ;", "}", "METHOD_END"], "methodName": ["createRequestOptions"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "return   this . dispatcher . getChannel (  )  . getAddress (  )  ;", "}", "METHOD_END"], "methodName": ["getLocalAddress"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "return   this . getLocalAddress (  )  . equals ( this . group . getAddress ( node )  )  ;", "}", "METHOD_END"], "methodName": ["isLocal"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   this . dispatcher . sendMessageWithFuture ( this . group . getAddress ( node )  ,    buffer ,    options )  ;", "}    catch    ( Exception   e )     {", "throw   new   Exception ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["submit"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < ThreadFactory >    action    =     (  )     -  >    new   ClassLoaderThreadFactory ( new   JBossThreadFactory ( new   ThreadGroup ( targetClass . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ,    targetClass . getClassLoader (  )  )  ;", "return   WildFlySecurityManager . doUnchecked ( action )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcherFactory"}, {"methodBody": ["METHOD_START", "{", "try    ( DataInputStream   input    =    new   DataInputStream ( new   ByteArrayInputStream ( message . getRawBuffer (  )  ,    message . getOffset (  )  ,    message . getLength (  )  )  )  )     {", "int   version    =    IndexSerializer . VARIABLE . readInt ( input )  ;", "try    ( Unmarshaller   unmarshaller    =    this . marshallingContext . createUnmarshaller ( version )  )     {", "unmarshaller . start ( Marshalling . createByteInput ( input )  )  ;", "Object   clientId    =    unmarshaller . readObject (  )  ;", "Optional < Object >    context    =    this . contexts . get ( clientId )  ;", "if    ( context    =  =    null )", "return    (  )     -  >    NoSuchService . INSTANCE ;", "@ SuppressWarnings (  \" unchecked \"  )", "< Object ,    Object >    command    =     (  (  < Object ,    Object >  )     ( unmarshaller . readObject (  )  )  )  ;", "ExceptionSupplier < Optional < Object >  ,    Exception >    task    =     (  )     -  >    Optional . ofNullable ( command . execute ( context . orElse ( null )  )  )  ;", "return    (  )     -  >    this . executor . execute ( task )  . orElse ( Optional . of ( NoSuchService . INSTANCE )  )  . orElse ( null )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcherFactory"}, {"methodBody": ["METHOD_START", "{", "ExecutorService   executor    =    this . listeners . remove ( listener )  ;", "if    ( executor    !  =    null )     {", "executor . shutdownNow (  )  ;", "try    {", "executor . awaitTermination ( this . timeout ,    TimeUnit . MILLISECONDS )  ;", "}    c    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["unregister"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcherFactory"}, {"methodBody": ["METHOD_START", "{", "this . timeout    =    unit . toMillis ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["timeout"], "fileName": "org.wildfly.clustering.server.dispatcher.ChannelCommandDispatcherFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < ThreadFactory >    action    =     (  )     -  >    new   JBossThreadFactory ( new   ThreadGroup ( LocalCommandDispatcher . class . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ;", "return   WildFlySecurityManager . doUnchecked ( action )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.server.dispatcher.LocalCommandDispatcher"}, {"methodBody": ["METHOD_START", "{", "AutoCloseableCommandDispatcherFactory   factory    =    mock ( AutoCloseableCommandDispatcherFactory . class )  ;", "try    ( AutoCloseableCommandDispatcherFactory   subject    =    new    ( factory )  )     {", "String   context    =     \" context \"  ;", "CommandDispatcher < String >    dispatcher    =    mock ( CommandDispatcher . class )  ;", "when ( factory . createCommandDispatcher (  \" foo \"  ,    context )  )  . thenReturn ( dispatcher )  ;", "when ( dispatcher . getContext (  )  )  . thenReturn ( context )  ;", "try    ( CommandDispatcher < String >    dispatcher 1     =    subject . createCommandDispatcher (  \" foo \"  ,    context )  )     {", "assertSame ( context ,    dispatcher 1  . getContext (  )  )  ;", "try    ( CommandDispatcher < String >    dispatcher 2     =    subject . createCommandDispatcher (  \" foo \"  ,    context )  )     {", "assertSame ( dispatcher 1  ,    dispatcher 2  )  ;", "String   otherContext    =     \" unexpected \"  ;", "try    {", "subject . createCommandDispatcher (  \" foo \"  ,    otherContext )  ;", "fail (  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "verify ( factory ,    never (  )  )  . createCommandDispatcher (  \" foo \"  ,    otherContext )  ;", "}", "}", "verify ( dispatcher ,    never (  )  )  . close (  )  ;", "}", "verify ( dispatcher )  . close (  )  ;", "}", "verify ( factory )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.dispatcher.ManagedCommandDispatcherFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "CommandDispatcher < String >    dispatcher    =    mock ( CommandDispatcher . class )  ;", "Runnable   closeTask    =    mock ( Runnable . class )  ;", "String   context    =     \" context \"  ;", "try    ( CommandDispatcher < String >    subject    =    new    <  >  ( dispatcher ,    closeTask )  )     {", "when ( dispatcher . getContext (  )  )  . thenReturn ( context )  ;", "assertSame ( context ,    subject . getContext (  )  )  ;", "Command < Void ,    String >    command    =    mock ( Command . class )  ;", "Node   node    =    mock ( Node . class )  ;", "Node [  ]    nodes    =    new   Node [  ]  {    node    }  ;", "CommandResponse < Void >    response    =    mock ( CommandResponse . class )  ;", "Future < Void >    future    =    mock ( Future . class )  ;", "Map < Node ,    CommandResponse < Void >  >    responses    =    Collections . singletonMap ( node ,    response )  ;", "Map < Node ,    Future < Void >  >    futures    =    Collections . singletonMap ( node ,    future )  ;", "when ( dispatcher . executeOnCluster ( command ,    nodes )  )  . thenReturn ( responses )  ;", "assertSame ( responses ,    subject . executeOnCluster ( command ,    nodes )  )  ;", "when ( dispatcher . executeOnNode ( command ,    node )  )  . thenReturn ( response )  ;", "assertSame ( response ,    subject . executeOnNode ( command ,    node )  )  ;", "when ( dispatcher . submitOnCluster ( command ,    nodes )  )  . thenReturn ( futures )  ;", "assertSame ( futures ,    subject . submitOnCluster ( command ,    nodes )  )  ;", "when ( dispatcher . submitOnNode ( command ,    node )  )  . thenReturn ( future )  ;", "assertSame ( future ,    subject . submitOnNode ( command ,    node )  )  ;", "}", "verify ( dispatcher ,    never (  )  )  . close (  )  ;", "verify ( closeTask )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.dispatcher.ManagedCommandDispatcherTestCase"}, {"methodBody": ["METHOD_START", "{", "new   ExternalizerTester <  >  ( new   AddressSerializer . UUIDExternalizer (  )  )  . test ( UUID . randomUUID (  )  )  ;", "new   ExternalizerTester <  >  ( new   AddressSerializer . SiteUUIDExternalizer (  )  )  . test ( new   SiteUUID ( UUID . randomUUID (  )  ,     \" name \"  ,     \" site \"  )  )  ;", "new   ExternalizerTester <  >  ( new   AddressSerializer . SiteMasterExternalizer (  )  )  . test ( new   SiteMaster (  \" test \"  )  )  ;", "Random   random    =    new   Random (  )  ;", "InetAddress   address    =    InetAddress . getLoopbackAddress (  )  ;", "int   bound    =     ( Short . MAX _ VALUE )     -     ( Short . MIN _ VALUE )  ;", "new   ExternalizerTester <  >  ( new   AddressSerializer . IpAddressExternalizer (  )  )  . test ( new   IpAddress ( new   InetSocketAddress ( address ,    random . nextInt ( bound )  )  )  )  ;", "new   ExternalizerTester <  >  ( new   AddressSerializer . IpAddressUUIDExternalizer (  )  )  . test ( new   IpAddressUUID ( new   InetSocketAddress ( address ,    random . nextInt ( bound )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.group.AddressSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.wildfly.clustering.server.group.AddressableNode"}, {"methodBody": ["METHOD_START", "{", "input . defaultReadObject (  )  ;", "this . address    =    Serializer . INSTANCE . read ( input )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.wildfly.clustering.server.group.AddressableNode"}, {"methodBody": ["METHOD_START", "{", "output . defaultWriteObject (  )  ;", "Serializer . INSTANCE . write ( output ,    this . address )  ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.wildfly.clustering.server.group.AddressableNode"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( node 1  ,    node 2  )  ;", "Assert . assertEquals ( node 1  . getName (  )  ,    node 2  . getName (  )  )  ;", "Assert . assertEquals ( node 1  . getSocket (  )  ,    node 2  . getSocket (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.server.group.AddressableNodeSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "AddressableNode   node    =    new   AddressableNode ( UUID . randomUUID (  )  ,     \" node 1  \"  ,    new   InetSocketAddress ( InetAddress . getLoopbackAddress (  )  ,    Short . MAX _ VALUE )  )  ;", "new   ExternalizerTester <  >  ( new   AddressableNodeSerializer . AddressableNodeExternalizer (  )  ,     :  : assertEquals )  . test ( node )  ;", "new   KeyFormatTester <  >  ( new   AddressableNodeSerializer . AddressableNodeKeyFormat (  )  ,     :  : assertEquals )  . test ( node )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.group.AddressableNodeSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < ThreadFactory >    action    =     (  )     -  >    new   JBossThreadFactory ( new   ThreadGroup ( targetClass . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ;", "return   new   ClassLoaderThreadFactory ( WildFlySecurityManager . doUnchecked ( action )  ,    targetClass . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.server.group.CacheGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( address    =  =    null )     |  |     ( address    =  =     ( LocalModeAddress . INSTANCE )  )  )", "return   null ;", "if    ( address   instanceof   JsAddress )     {", "JsAddress   jgroupsAddress    =     (  ( JsAddress )     ( address )  )  ;", "return   jgroupsAddress . getJsAddress (  )  ;", "}", "throw   new   IllegalArgumentException ( address . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toJGroupsAddress"], "fileName": "org.wildfly.clustering.server.group.CacheGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( event . isPre (  )  )", "return ;", "int   viewId    =    event . getCache (  )  . getCacheManager (  )  . getTransport (  )  . getViewId (  )  ;", "if    (  !  ( this . listeners . isEmpty (  )  )  )     {", "Address   localAddress    =    event . getCache (  )  . getCacheManager (  )  . getAddress (  )  ;", "Membership   previousMembership    =    new   CacheMembership ( localAddress ,    event . getWriteConsistentHashAtStart (  )  ,    this )  ;", "Membership   membership    =    new   CacheMembership ( localAddress ,    event . getWriteConsistentHashAtEnd (  )  ,    this )  ;", "Boolean   status    =    this . views . get ( viewId )  ;", "boolean   merged    =     ( status    !  =    null )     ?    status . booleanValue (  )     :    false ;", "for    ( Map . Entry < GroupListener ,    ExecutorService >    entry    :    this . listeners . entrySet (  )  )     {", "GroupListener   listener    =    entry . getKey (  )  ;", "ExecutorService   executor    =    entry . getValue (  )  ;", "try    {", "executor . submit (  (  )     -  >     {", "try    {", "listener . membershipChanged ( previousMembership ,    membership ,    merged )  ;", "}    catch    ( Throwable   e )     {", "CServerLogger . ROOT _ LOGGER . warn ( e . getLocalizedMessage (  )  ,    e )  ;", "}", "}  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "}", "}", "this . views . headMap ( viewId )  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["topologyChanged"], "fileName": "org.wildfly.clustering.server.group.CacheGroup"}, {"methodBody": ["METHOD_START", "{", "ExecutorService   executor    =    this . listeners . remove ( listener )  ;", "if    ( executor    !  =    null )     {", "PrivilegedAction < List < Runnable >  >    action    =     (  )     -  >    executor . shutdownNow (  )  ;", "WildFlySecurityManager . doUnchecked ( action )  ;", "try    {", "executor . awaitTermination ( this . cache . getConfiguration (  )  . transaction (  )  . cacheStopTimeout (  )  ,    TimeUnit . MILLISECONDS )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["unregister"], "fileName": "org.wildfly.clustering.server.group.CacheGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cache . getAdvancedCache (  )  . getDistributionManager (  )  )     !  =    null )     {", "this . views . put ( event . getViewId (  )  ,    event . isMergeView (  )  )  ;", "} else", "if    (  !  ( this . listeners . isEmpty (  )  )  )     {", "Membership   previousMembership    =    new   CacheMembership ( event . getLocalAddress (  )  ,    event . getOldMembers (  )  ,    this )  ;", "Membership   membership    =    new   CacheMembership ( event . getLocalAddress (  )  ,    event . getNewMembers (  )  ,    this )  ;", "for    ( Entry < GroupListener ,    ExecutorService >    entry    :    this . listeners . entrySet (  )  )     {", "GroupListener   listener    =    entry . getKey (  )  ;", "ExecutorService   executor    =    entry . getValue (  )  ;", "try    {", "executor . submit (  (  )     -  >     {", "try    {", "listener . membershipChanged ( previousMembership ,    membership ,    event . isMergeView (  )  )  ;", "}    catch    ( Throwable   e )     {", "logging . ClusteringServerLogger . ROOT _ LOGGER . warn ( e . getLocalizedMessage (  )  ,    e )  ;", "}", "}  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["viewChanged"], "fileName": "org.wildfly.clustering.server.group.CacheGroup"}, {"methodBody": ["METHOD_START", "{", "return   this . addresses . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getCoordinatorAddress"], "fileName": "org.wildfly.clustering.server.group.CacheMembership"}, {"methodBody": ["METHOD_START", "{", "new   ExternalizerTester <  >  ( new   LocalAddressSerializer . LocalAddressExternalizer (  )  )  . test ( INSTANCE )  ;", "new   KeyFormatTester <  >  ( new   LocalAddressSerializer . LocalAddressKeyFormat (  )  )  . test ( INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.group.LocalAddressSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "LocalNode   node    =    new   LocalNode (  \" name \"  )  ;", "new   ExternalizerTester <  >  ( new    . LocalNodeExternalizer (  )  )  . test ( node )  ;", "new   KeyFormatTester <  >  ( new    . LocalNodeKeyFormat (  )  )  . test ( node )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.group.LocalNodeResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < ThreadFactory >    action    =     (  )     -  >    new   ClassLoaderThreadFactory ( new   JBossThreadFactory ( new   ThreadGroup ( targetClass . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ,    targetClass . getClassLoader (  )  )  ;", "return   WildFlySecurityManager . doUnchecked ( action )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.server.provider.CacheServiceProviderRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( event . isPre (  )  )", "return ;", "Map . Entry < ation . Listener ,    ExecutorService >    entry    =    this . listeners . get ( event . getKey (  )  )  ;", "if    ( entry    !  =    null )     {", "ation . Listener   listener    =    entry . getKey (  )  ;", "if    ( listener    !  =    null )     {", "ExecutorService   executor    =    entry . getValue (  )  ;", "Set < Node >    members    =    new   TreeSet <  >  (  )  ;", "for    ( Address   address    :    event . getValue (  )  )     {", "members . add ( this . group . createNode ( address )  )  ;", "}", "try    {", "executor . submit (  (  )     -  >     {", "try    {", "listener . providersChanged ( members )  ;", "}    catch    ( Throwable   e )     {", "ClusteringServerLogger . ROOT _ LOGGER . serviceProviderRegistrationListenerFailed ( e ,    this . cache . getCacheManager (  )  . getCacheManagerConfiguration (  )  . globalJmxStatistics (  )  . cacheManagerName (  )  ,    this . cache . getName (  )  ,    members )  ;", "}", "}  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["modified"], "fileName": "org.wildfly.clustering.server.provider.CacheServiceProviderRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < Address >    addresses    =    this . cache . getAdvancedCache (  )  . withFlags ( FORCE _ SYNCHRONOUS ,    FORCE _ WRITE _ LOCK )  . computeIfAbsent ( service ,     (    key )     -  >    new   CopyOnWriteArraySet <  >  ( Collections . singleton ( address )  )  )  ;", "if    ( addresses . add ( address )  )     {", "this . cache . getAdvancedCache (  )  . withFlags ( IGNORE _ RETURN _ VALUES )  . replace ( service ,    addresses )  ;", "}", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.wildfly.clustering.server.provider.CacheServiceProviderRegistry"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < ThreadFactory >    action    =     (  )     -  >    new   ClassLoaderThreadFactory ( new   JBossThreadFactory ( new   ThreadGroup ( targetClass . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ,    targetClass . getClassLoader (  )  )  ;", "return   WFlySecurityManager . doUnchecked ( action )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( event . isOriginLocal (  )  )     |  |     ( event . isPre (  )  )  )", "return ;", "if    (  !  ( this . leners . isEmpty (  )  )  )     {", "Map . Entry < K ,    V >    entry    =    event . getValue (  )  ;", "if    ( entry    !  =    null )     {", "this . notifyLeners ( event . getType (  )  ,    entry )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["event"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "this . notifyListeners ( type ,    Collections . singletonMap ( entry . getKey (  )  ,    entry . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["notifyListeners"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < RegistryListener < K ,    V >  ,    ExecutorService >    entry    :    this . listeners . entrySet (  )  )     {", "RegistryListener < K ,    V >    listener    =    entry . getKey (  )  ;", "ExecutorService   executor    =    entry . getValue (  )  ;", "try    {", "executor . submit (  (  )     -  >     {", "try    {", "switch    ( type )     {", "case   CACHE _ ENTRY _ CREATED    :", "{", "listener . addedEntries ( entries )  ;", "break ;", "}", "case   CACHE _ ENTRY _ MODIFIED    :", "{", "listener . updatedEntries ( entries )  ;", "break ;", "}", "case   CACHE _ ENTRY _ REMOVED    :", "{", "listener . removedEntries ( entries )  ;", "break ;", "}", "default    :", "{", "throw   new   IllegalStateException ( type . name (  )  )  ;", "}", "}", "}    catch    ( Throwable   e )     {", "CServerLogger . ROOT _ LOGGER . registryListenerFailed ( e ,    this . cache . getCacheManager (  )  . getCacheManagerConfiguration (  )  . globalJmxStatistics (  )  . cacheManagerName (  )  ,    this . cache . getName (  )  ,    type ,    entries )  ;", "}", "}  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["notifyListeners"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "try    ( Batch   batch    =    this . batcher . createBatch (  )  )     {", "this . cache . getAdvanced (  )  . withFlags ( IGNORE _ RETURN _ VALUES )  . put ( this . group . getAddress ( this . group . getLocalMember (  )  )  ,    this . entry )  ;", "}", "}", "METHOD_END"], "methodName": ["populateRegistry"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( event . isOriginLocal (  )  )     |  |     ( event . isPre (  )  )  )", "return ;", "if    (  !  ( this . leners . isEmpty (  )  )  )     {", "Map . Entry < K ,    V >    entry    =    event . getOldValue (  )  ;", "if    ( entry    !  =    null )     {", "this . notifyLeners ( event . getType (  )  ,    entry )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removed"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < List < Runnable >  >    action    =     (  )     -  >    executor . shutdownNow (  )  ;", "WildFlySecurityManager . doUnchecked ( action )  ;", "try    {", "executor . awaitTermination ( this . cache . getConfiguration (  )  . transaction (  )  . cacheStopTimeout (  )  ,    TimeUnit . MILLISECONDS )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( event . isPre (  )  )", "return ;", "ConsistentHash   previousHash    =    event . getWriteConsistentHashAtStart (  )  ;", "List < Address >    previousMembers    =    previousHash . getMembers (  )  ;", "ConsistentHash   hash    =    event . getWriteConsistentHashAtEnd (  )  ;", "List < Address >    members    =    hash . getMembers (  )  ;", "Address   localAddress    =    this . group . getAddress ( this . group . getLocalMember (  )  )  ;", "Set < Address >    leftMembers    =    new   HashSet ( previousMembers )  ;", "leftMembers . removeAll ( members )  ;", "try    {", "this . topologyChangeExecutor . submit (  (  )     -  >     {", "if    (  !  ( leftMembers . isEmpty (  )  )  )     {", "Locality   locality    =    new   ConsistentHashLocality ( event . getCache (  )  ,    hash )  ;", "Iterator < Address >    addresses    =    leftMembers . iterator (  )  ;", "while    ( addresses . hasNext (  )  )     {", "if    (  !  ( locality . isLocal ( addresses . next (  )  )  )  )     {", "addresses . remove (  )  ;", "}", "}", "if    (  !  ( leftMembers . isEmpty (  )  )  )     {", "Cache < Address ,    Map . Entry < K ,    V >  >    cache    =    this . cache . getAdvancedCache (  )  . withFlags ( FORCE _ SYNCHRONOUS )  ;", "Map < K ,    V >    removed    =    new   HashMap <  >  (  )  ;", "try    ( Batch   batch    =    this . batcher . createBatch (  )  )     {", "for    ( Address   leftMember    :    leftMembers )     {", "Map . Entry < K ,    V >    old    =    cache . remove ( leftMember )  ;", "if    ( old    !  =    null )     {", "removed . put ( old . getKey (  )  ,    old . getValue (  )  )  ;", "}", "}", "}    catch    ( CacheException   e )     {", "CServerLogger . ROOT _ LOGGER . registryPurgeFailed ( e ,    this . cache . getCacheManager (  )  . toString (  )  ,    this . cache . getName (  )  ,    leftMembers )  ;", "}", "if    (  !  ( removed . isEmpty (  )  )  )     {", "this . notifyListeners ( CACHE _ ENTRY _ REMOVED ,    removed )  ;", "}", "}", "} else    {", "if    (  !  ( previousMembers . contains ( localAddress )  )  )     {", "try    {", "this . populateRegistry (  )  ;", "this . notifyListeners ( CACHE _ ENTRY _ CREATED ,    this . entry )  ;", "}    catch    ( CacheException   e )     {", "CServerLogger . ROOT _ LOGGER . failedToRestoreLocalRegistryEntry ( e ,    this . cache . getCacheManager (  )  . toString (  )  ,    this . cache . getName (  )  )  ;", "}", "}", "}", "}  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "}", "METHOD_END"], "methodName": ["topologyChanged"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "ExecutorService   executor    =    this . listeners . remove ( listener )  ;", "if    ( executor    !  =    null )     {", "this . shutdown ( executor )  ;", "}", "}", "METHOD_END"], "methodName": ["unregister"], "fileName": "org.wildfly.clustering.server.registry.CacheRegistry"}, {"methodBody": ["METHOD_START", "{", "ServiceContainerHelper . stop ( controllerToStop )  ;", "try    {", "ServiceContainerHelper . start ( controllerToStart )  ;", "}    catch    ( StartException   e )     {", "CServerLogger . ROOT _ LOGGER . serviceStartFailed ( e ,    controllerToStart . getName (  )  . getCanonicalName (  )  )  ;", "ServiceContainerHelper . stop ( controllerToStart )  ;", "}", "}", "METHOD_END"], "methodName": ["toggle"], "fileName": "org.wildfly.clustering.server.singleton.DistributedSingletonService"}, {"methodBody": ["METHOD_START", "{", "ServiceName   name    =    JBOSS . append (  \" service \"  )  ;", "new   ExternalizerTester <  >  ( new    . ServiceNameExternalizer (  )  )  . test ( name )  ;", "new   KeyFormatTester <  >  ( new    . ServiceNameKeyFormat (  )  )  . test ( name )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.singleton.ServiceNameResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "Preference   preference    =    new   NamePreference (  \" node 1  \"  )  ;", "Node   node 1     =    mock ( Node . class )  ;", "Node   node 2     =    mock ( Node . class )  ;", "when ( node 1  . getName (  )  )  . thenReturn (  \" node 1  \"  )  ;", "when ( node 2  . getName (  )  )  . thenReturn (  \" node 2  \"  )  ;", "assertTrue ( preference . preferred ( node 1  )  )  ;", "assertFalse ( preference . preferred ( node 2  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.singleton.election.NamePreferenceTestCase"}, {"methodBody": ["METHOD_START", "{", "SingletonElectionPolicy   policy    =    mock ( SingletonElectionPolicy . class )  ;", "Preference   preference 1     =    mock ( Preference . class )  ;", "Preference   preference 2     =    mock ( Preference . class )  ;", "Node   node 1     =    mock ( Node . class )  ;", "Node   node 2     =    mock ( Node . class )  ;", "Node   node 3     =    mock ( Node . class )  ;", "Node   node 4     =    mock ( Node . class )  ;", "when ( preference 1  . preferred ( same ( node 1  )  )  )  . thenReturn ( true )  ;", "when ( preference 1  . preferred ( same ( node 2  )  )  )  . thenReturn ( false )  ;", "when ( preference 1  . preferred ( same ( node 3  )  )  )  . thenReturn ( false )  ;", "when ( preference 1  . preferred ( same ( node 4  )  )  )  . thenReturn ( false )  ;", "when ( preference 2  . preferred ( same ( node 1  )  )  )  . thenReturn ( false )  ;", "when ( preference 2  . preferred ( same ( node 2  )  )  )  . thenReturn ( true )  ;", "when ( preference 2  . preferred ( same ( node 3  )  )  )  . thenReturn ( false )  ;", "when ( preference 2  . preferred ( same ( node 4  )  )  )  . thenReturn ( false )  ;", "assertSame ( node 1  ,    new    ( policy ,    preference 1  ,    preference 2  )  . elect ( Arrays . asList ( node 1  ,    node 2  ,    node 3  ,    node 4  )  )  )  ;", "assertSame ( node 1  ,    new    ( policy ,    preference 1  ,    preference 2  )  . elect ( Arrays . asList ( node 4  ,    node 3  ,    node 2  ,    node 1  )  )  )  ;", "assertSame ( node 2  ,    new    ( policy ,    preference 1  ,    preference 2  )  . elect ( Arrays . asList ( node 2  ,    node 3  ,    node 4  )  )  )  ;", "assertSame ( node 2  ,    new    ( policy ,    preference 1  ,    preference 2  )  . elect ( Arrays . asList ( node 4  ,    node 3  ,    node 2  )  )  )  ;", "List < Node >    nodes    =    Arrays . asList ( node 3  ,    node 4  )  ;", "when ( policy . elect ( nodes )  )  . thenReturn ( node 3  )  ;", "assertSame ( node 3  ,    new    ( policy ,    preference 1  ,    preference 2  )  . elect ( nodes )  )  ;", "when ( policy . elect ( nodes )  )  . thenReturn ( node 4  )  ;", "assertSame ( node 4  ,    new    ( policy ,    preference 1  ,    preference 2  )  . elect ( nodes )  )  ;", "when ( policy . elect ( nodes )  )  . thenReturn ( null )  ;", "assertNull ( new    ( policy ,    preference 1  ,    preference 2  )  . elect ( nodes )  )  ;", "}", "METHOD_END"], "methodName": ["elect"], "fileName": "org.wildfly.clustering.server.singleton.election.PreferredSingletonElectionPolicyTestCase"}, {"methodBody": ["METHOD_START", "{", "Node   node 1     =    mock ( Node . class )  ;", "Node   node 2     =    mock ( Node . class )  ;", "Node   node 3     =    mock ( Node . class )  ;", "List < Node >    nodes    =    Arrays . asList ( node 1  ,    node 2  ,    node 3  )  ;", "assertSame ( node 1  ,    new    (  )  . elect ( nodes )  )  ;", "assertSame ( node 1  ,    new    (  0  )  . elect ( nodes )  )  ;", "assertSame ( node 2  ,    new    (  1  )  . elect ( nodes )  )  ;", "assertSame ( node 3  ,    new    (  2  )  . elect ( nodes )  )  ;", "assertSame ( node 1  ,    new    (  3  )  . elect ( nodes )  )  ;", "assertNull ( new    (  )  . elect ( Collections .  < Node > emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["elect"], "fileName": "org.wildfly.clustering.server.singleton.election.SimpleSingletonElectionPolicyTestCase"}, {"methodBody": ["METHOD_START", "{", "InetSocketAddress   preferredAddress    =    new   InetSocketAddress ( InetAddress . getByName (  \"  1  2  7  .  0  .  0  .  1  \"  )  ,     1  )  ;", "InetSocketAddress   otherAddress 1     =    new   InetSocketAddress ( InetAddress . getByName (  \"  1  2  7  .  0  .  0  .  1  \"  )  ,     2  )  ;", "InetSocketAddress   otherAddress 2     =    new   InetSocketAddress ( InetAddress . getByName (  \"  1  2  7  .  0  .  0  .  2  \"  )  ,     1  )  ;", "Preference   preference    =    new    ( preferredAddress )  ;", "Node   preferredNode    =    mock ( Node . class )  ;", "Node   otherNode 1     =    mock ( Node . class )  ;", "Node   otherNode 2     =    mock ( Node . class )  ;", "when ( preferredNode . getSocketAddress (  )  )  . thenReturn ( preferredAddress )  ;", "when ( otherNode 1  . getSocketAddress (  )  )  . thenReturn ( otherAddress 1  )  ;", "when ( otherNode 2  . getSocketAddress (  )  )  . thenReturn ( otherAddress 2  )  ;", "assertTrue ( preference . preferred ( preferredNode )  )  ;", "assertFalse ( preference . preferred ( otherNode 1  )  )  ;", "assertFalse ( preference . preferred ( otherNode 2  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.server.singleton.election.SocketAddressPreferenceTestCase"}, {"methodBody": ["METHOD_START", "{", "this . startAsynchronously    =    false ;", "return   this ;", "}", "METHOD_END"], "methodName": ["startSynchronously"], "fileName": "org.wildfly.clustering.service.AsynchronousServiceBuilder"}, {"methodBody": ["METHOD_START", "{", "this . stopAsynchronously    =    false ;", "return   this ;", "}", "METHOD_END"], "methodName": ["stopSynchronously"], "fileName": "org.wildfly.clustering.service.AsynchronousServiceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   String . join (  \"  .  \"  ,    this . getName (  )  ,    parent ,    child )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.wildfly.clustering.service.BinaryRequirement"}, {"methodBody": ["METHOD_START", "{", "return   Optional . ofNullable ( this . getStoredValue (  )  )  . map ( Value :  : getValue )  ;", "}", "METHOD_END"], "methodName": ["getOptionalValue"], "fileName": "org.wildfly.clustering.service.OptionalInjectedValue"}, {"methodBody": ["METHOD_START", "{", "return   String . join (  \"  .  \"  ,    this . getName (  )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.wildfly.clustering.service.UnaryRequirement"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < Thread >    action    =     (  )     -  >     {", "thread . setContext ( this . loader )  ;", "return   thread ;", "}  ;", "return   AccessController . doPrivileged ( action )  ;", "}", "METHOD_END"], "methodName": ["setContextClassLoader"], "fileName": "org.wildfly.clustering.service.concurrent.ClassLoaderThreadFactory"}, {"methodBody": ["METHOD_START", "{", "this . size    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.wildfly.clustering.service.concurrent.RemoveOnCancelScheduledExecutorServiceBuilder"}, {"methodBody": ["METHOD_START", "{", "ServiceExecutor   executor    =    new   StampedLockServiceExecutor (  )  ;", "ExecutorService   service    =    Executors . newFixedThreadPool (  2  )  ;", "try    {", "CountDownLatch   executeLatch    =    new   CountDownLatch (  1  )  ;", "CountDownLatch   stopLatch    =    new   CountDownLatch (  1  )  ;", "Runnable   executeTask    =     (  )     -  >     {", "try    {", "executeLatch . countDown (  )  ;", "stopLatch . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}  ;", "Future <  ?  >    executeFuture    =    service . submit (  (  )     -  >    executor . execute ( executeTask )  )  ;", "executeLatch . await (  )  ;", "Runnable   closeTask    =    mock ( Runnable . class )  ;", "Future <  ?  >    closeFuture    =    service . submit (  (  )     -  >    executor . close ( closeTask )  )  ;", "Thread . yield (  )  ;", "verify ( closeTask ,    never (  )  )  . run (  )  ;", "stopLatch . countDown (  )  ;", "executeFuture . get (  )  ;", "closeFuture . get (  )  ;", "verify ( closeTask )  . run (  )  ;", "}    finally    {", "service . shutdownNow (  )  ;", "}", "}", "METHOD_END"], "methodName": ["concurrent"], "fileName": "org.wildfly.clustering.service.concurrent.StampedLockServiceExecutorTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceExecutor   executor    =    new   StampedLockServiceExecutor (  )  ;", "ExceptionRunnable < Exception >    executeTask    =    mock ( ExceptionRunnable . class )  ;", "executor . execute ( executeTask )  ;", "verify ( executeTask )  . run (  )  ;", "reset ( executeTask )  ;", "doThrow ( new   Exception (  )  )  . when ( executeTask )  . run (  )  ;", "try    {", "executor . execute ( executeTask )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( Exception   e )     {", "assertNotNull ( e )  ;", "}", "reset ( executeTask )  ;", "Runnable   closeTask    =    mock ( Runnable . class )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask )  . run (  )  ;", "reset ( closeTask )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask ,    never (  )  )  . run (  )  ;", "executor . execute ( executeTask )  ;", "verify ( executeTask ,    never (  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["testExecuteExceptionRunnable"], "fileName": "org.wildfly.clustering.service.concurrent.StampedLockServiceExecutorTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceExecutor   executor    =    new   StampedLockServiceExecutor (  )  ;", "Object   expected    =    new   Object (  )  ;", "ExceptionSupplier < Object ,    Exception >    executeTask    =    mock ( ExceptionSupplier . class )  ;", "when ( executeTask . get (  )  )  . thenReturn ( expected )  ;", "Optional < Object >    result    =    executor . execute ( executeTask )  ;", "assertTrue ( result . isPresent (  )  )  ;", "assertSame ( expected ,    result . get (  )  )  ;", "reset ( executeTask )  ;", "doThrow ( new   Exception (  )  )  . when ( executeTask )  . get (  )  ;", "try    {", "executor . execute ( executeTask )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( Exception   e )     {", "assertNotNull ( e )  ;", "}", "reset ( executeTask )  ;", "Runnable   closeTask    =    mock ( Runnable . class )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask )  . run (  )  ;", "reset ( closeTask )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask ,    never (  )  )  . run (  )  ;", "result    =    executor . execute ( executeTask )  ;", "assertFalse ( result . isPresent (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExecuteExceptionSupplier"], "fileName": "org.wildfly.clustering.service.concurrent.StampedLockServiceExecutorTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceExecutor   executor    =    new   StampedLockServiceExecutor (  )  ;", "Runnable   executeTask    =    mock ( Runnable . class )  ;", "executor . execute ( executeTask )  ;", "verify ( executeTask )  . run (  )  ;", "reset ( executeTask )  ;", "Runnable   closeTask    =    mock ( Runnable . class )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask )  . run (  )  ;", "reset ( closeTask )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask ,    never (  )  )  . run (  )  ;", "executor . execute ( executeTask )  ;", "verify ( executeTask ,    never (  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["testExecuteRunnable"], "fileName": "org.wildfly.clustering.service.concurrent.StampedLockServiceExecutorTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceExecutor   executor    =    new   StampedLockServiceExecutor (  )  ;", "Object   expected    =    new   Object (  )  ;", "Supplier < Object >    executeTask    =    mock ( Supplier . class )  ;", "when ( executeTask . get (  )  )  . thenReturn ( expected )  ;", "Optional < Object >    result    =    executor . execute ( executeTask )  ;", "assertTrue ( result . isPresent (  )  )  ;", "assertSame ( expected ,    result . get (  )  )  ;", "reset ( executeTask )  ;", "Runnable   closeTask    =    mock ( Runnable . class )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask )  . run (  )  ;", "reset ( closeTask )  ;", "executor . close ( closeTask )  ;", "verify ( closeTask ,    never (  )  )  . run (  )  ;", "result    =    executor . execute ( executeTask )  ;", "assertFalse ( result . isPresent (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExecuteSupplier"], "fileName": "org.wildfly.clustering.service.concurrent.StampedLockServiceExecutorTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . isPrimary (  )  ;", "}", "METHOD_END"], "methodName": ["isMaster"], "fileName": "org.wildfly.clustering.singleton.Singleton"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" id \"  ;", "Address   address    =    mock ( Address . class )  ;", "when ( this . manager . getAddress (  )  )  . thenReturn ( address )  ;", "when ( this . a . getKeyForAddress ( address )  )  . thenReturn ( new   Key ( expected )  )  ;", "String   result    =    this . subject . createIdentifier (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["createIdentifier"], "fileName": "org.wildfly.clustering.web.infinispan.AffinityIdentityFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "when ( this . affinityFactory . createService ( same ( this . cache )  ,    this . capturedGenerator . capture (  )  )  )  . thenReturn ( this . affinity )  ;", "when ( this . cache . getCacheManager (  )  )  . thenReturn ( this . manager )  ;", "this . subject    =    new   fierFactory ( this . factory ,    this . cache ,    this . affinityFactory )  ;", "KeyGenerator < Key < String >  >    generator    =    this . capturedGenerator . getValue (  )  ;", "assertSame ( generator ,    this . subject )  ;", "String   expected    =     \" id \"  ;", "when ( this . factory . createIdentifier (  )  )  . thenReturn ( expected )  ;", "Key < String >    result    =    generator . getKey (  )  ;", "assertSame ( expected ,    result . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.wildfly.clustering.web.infinispan.AffinityIdentityFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "KeyMapperTester   tester    =    new   KeyMapperTester ( new   KeyMapper (  )  )  ;", "String   id    =     \" ABC 1  2  3  \"  ;", "tester . test ( new   SessionCreationMetaDataKey ( id )  )  ;", "tester . test ( new   SessionAccessMetaDataKey ( id )  )  ;", "tester . test ( new   SessionAttributesKey ( id )  )  ;", "tester . test ( new   SessionAttributeNamesKey ( id )  )  ;", "IntStream . range (  0  ,     1  0  )  . mapToObj (  (    i )     -  >    new   SessionAttributeKey ( id ,    i )  )  . forEach (  (    key )     -  >    tester . test ( key )  )  ;", "tester . test ( new   AuthenticationKey ( id )  )  ;", "tester . test ( new   CoarseSessionsKey ( id )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.KeyMapperTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceLoaderTestCase . load ( Externalizer . class )  ;", "ServiceLoaderTestCase . load ( RouteLocatorBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( SessionManagerFactoryBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( SSOManagerFactoryBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( DistributedCacheBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( LocalCacheBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( CacheAliasBuilderProvider . class )  ;", "ServiceLoaderTestCase . load ( TwoWayKey 2 StringMapper . class )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.wildfly.clustering.web.infinispan.ServiceLoaderTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceLoader . load ( targetClass ,    ServiceLoaderTestCase . class . getClassLoader (  )  )  . forEach (  (    object )     -  >    ServiceLoaderTestCase . LOGGER . trace (  (  \"  \\ t \"     +     ( object . getClass (  )  . getName (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.wildfly.clustering.web.infinispan.ServiceLoaderTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( IdentifierSerializerProvider   provider    :    ServiceLoader . load ( IdentifierSerializerProvider . class ,    loader )  )     {", "return   provider . getSerializer (  )  ;", "}", "throw   new   IllegalStateException (  )  ;", "}", "METHOD_END"], "methodName": ["loadIdentifierSerializer"], "fileName": "org.wildfly.clustering.web.infinispan.SessionKeyExternalizer"}, {"methodBody": ["METHOD_START", "{", "SessionFactory < UUID ,    UUID ,    Object >    factory    =    mock ( SessionFactory . class )  ;", "SessionMetaDataFactory < UUID ,    Object >    metaDataFactory    =    mock ( SessionMetaDataFactory . class )  ;", "SessionAttributesFactory < UUID >    attributesFactory    =    mock ( SessionAttributesFactory . class )  ;", "SessionExpirationListener   listener    =    mock ( SessionExpirationListener . class )  ;", "ImmutableSessionAttributes   expiredAttributes    =    mock ( ImmutableSessionAttributes . class )  ;", "ImmutableSessionMetaData   validMetaData    =    mock ( ImmutableSessionMetaData . class )  ;", "ImmutableSessionMetaData   expiredMetaData    =    mock ( ImmutableSessionMetaData . class )  ;", "ImmutableSession   expiredSession    =    mock ( ImmutableSession . class )  ;", "String   missingSessionId    =     \" missing \"  ;", "String   expiredSessionId    =     \" expired \"  ;", "String   validSessionId    =     \" valid \"  ;", "UUID   expiredMetaDataValue    =    UUID . randomUUID (  )  ;", "UUID   expiredAttributesValue    =    UUID . randomUUID (  )  ;", "UUID   validMetaDataValue    =    UUID . randomUUID (  )  ;", "< UUID ,    UUID ,    Object >    subject    =    new    <  >  ( factory )  ;", "try    ( Registration   regisration    =    subject . register ( listener )  )     {", "when ( factory . getMetaDataFactory (  )  )  . thenReturn ( metaDataFactory )  ;", "when ( factory . getAttributesFactory (  )  )  . thenReturn ( attributesFactory )  ;", "when ( metaDataFactory . tryValue ( missingSessionId )  )  . thenReturn ( null )  ;", "when ( metaDataFactory . tryValue ( expiredSessionId )  )  . thenReturn ( expiredMetaDataValue )  ;", "when ( metaDataFactory . tryValue ( validSessionId )  )  . thenReturn ( validMetaDataValue )  ;", "when ( metaDataFactory . createImmutableSessionMetaData ( expiredSessionId ,    expiredMetaDataValue )  )  . thenReturn ( expiredMetaData )  ;", "when ( metaDataFactory . createImmutableSessionMetaData ( validSessionId ,    validMetaDataValue )  )  . thenReturn ( validMetaData )  ;", "when ( expiredMetaData . isExpired (  )  )  . thenReturn ( true )  ;", "when ( validMetaData . isExpired (  )  )  . thenReturn ( false )  ;", "when ( attributesFactory . findValue ( expiredSessionId )  )  . thenReturn ( expiredAttributesValue )  ;", "when ( attributesFactory . createImmutableSessionAttributes ( expiredSessionId ,    expiredAttributesValue )  )  . thenReturn ( expiredAttributes )  ;", "when ( factory . createImmutableSession ( same ( expiredSessionId )  ,    same ( expiredMetaData )  ,    same ( expiredAttributes )  )  )  . thenReturn ( expiredSession )  ;", "subject . remove ( missingSessionId )  ;", "subject . remove ( expiredSessionId )  ;", "subject . remove ( validSessionId )  ;", "verify ( factory )  . remove ( expiredSessionId )  ;", "verify ( factory ,    never (  )  )  . remove ( missingSessionId )  ;", "verify ( factory ,    never (  )  )  . remove ( validSessionId )  ;", "verify ( listener )  . sessionExpired ( expiredSession )  ;", "}", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.ExpiredSessionRemoverTestCase"}, {"methodBody": ["METHOD_START", "{", "Map . Entry < InfinispanSessionMetaData < Object >  ,    Object >    entry    =    mock ( Map . Entry . class )  ;", "SessionCreationMetaData   creationMetaData    =    mock ( SessionCreationMetaData . class )  ;", "SessionAccessMetaData   accessMetaData    =    mock ( SessionAccessMetaData . class )  ;", "InfinispanSessionMetaData < Object >    metaDataValue    =    new   InfinispanSessionMetaData <  >  ( creationMetaData ,    accessMetaData ,    null )  ;", "Object   attributesValue    =    new   Object (  )  ;", "ImmutableSessionMetaData   metaData    =    mock ( ImmutableSessionMetaData . class )  ;", "ImmutableSessionAttributes   attributes    =    mock ( ImmutableSessionAttributes . class )  ;", "String   id    =     \" id \"  ;", "when ( entry . getKey (  )  )  . thenReturn ( metaDataValue )  ;", "when ( entry . getValue (  )  )  . thenReturn ( attributesValue )  ;", "when ( this . metaDataFactory . createImmutableSessionMetaData ( id ,    metaDataValue )  )  . thenReturn ( metaData )  ;", "when ( this . attributesFactory . createImmutableSessionAttributes ( id ,    attributesValue )  )  . thenReturn ( attributes )  ;", "ImmutableSession   result    =    this . factory . createImmutableSession ( id ,    entry )  ;", "assertSame ( id ,    result . getId (  )  )  ;", "assertSame ( metaData ,    result . getMetaData (  )  )  ;", "assertSame ( attributes ,    result . getAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["createImmutableSession"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "Map . Entry < InfinispanSessionMetaData < Object >  ,    Object >    entry    =    mock ( Map . Entry . class )  ;", "SessionCreationMetaData   creationMetaData    =    mock ( SessionCreationMetaData . class )  ;", "SessionAccessMetaData   accessMetaData    =    mock ( SessionAccessMetaData . class )  ;", "Object   localContext    =    new   Object (  )  ;", "InfinispanSessionMetaData < Object >    metaDataValue    =    new   InfinispanSessionMetaData <  >  ( creationMetaData ,    accessMetaData ,    new   AtomicReference <  >  ( localContext )  )  ;", "Object   attributesValue    =    new   Object (  )  ;", "InvalidatableSessionMetaData   metaData    =    mock ( InvalidatableSessionMetaData . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "String   id    =     \" id \"  ;", "when ( entry . getKey (  )  )  . thenReturn ( metaDataValue )  ;", "when ( entry . getValue (  )  )  . thenReturn ( attributesValue )  ;", "when ( this . metaDataFactory . createSessionMetaData ( id ,    metaDataValue )  )  . thenReturn ( metaData )  ;", "when ( this . attributesFactory . createSessionAttributes ( id ,    attributesValue )  )  . thenReturn ( attributes )  ;", "Session < Object >    result    =    this . factory . createSession ( id ,    entry )  ;", "assertSame ( id ,    result . getId (  )  )  ;", "assertSame ( metaData ,    result . getMetaData (  )  )  ;", "assertSame ( attributes ,    result . getAttributes (  )  )  ;", "assertSame ( localContext ,    result . getLocalContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionCreationMetaData   creationMetaData    =    mock ( SessionCreationMetaData . class )  ;", "SessionAccessMetaData   accessMetaData    =    mock ( SessionAccessMetaData . class )  ;", "AtomicReference < Object >    localContext    =    new   AtomicReference <  >  (  )  ;", "MetaData < Object >    metaData    =    new   MetaData <  >  ( creationMetaData ,    accessMetaData ,    localContext )  ;", "Object   attributes    =    new   Object (  )  ;", "String   id    =     \" id \"  ;", "when ( this . metaDataFactory . createValue ( id ,    null )  )  . thenReturn ( metaData )  ;", "when ( this . attributesFactory . createValue ( id ,    null )  )  . thenReturn ( attributes )  ;", "Map . Entry < MetaData < Object >  ,    Object >    result    =    this . factory . createValue ( id ,    null )  ;", "assertNotNull ( result )  ;", "assertSame ( metaData ,    result . getKey (  )  )  ;", "assertSame ( attributes ,    result . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["createValue"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "String   missingMetaDataSessionId    =     \" no - meta - data \"  ;", "String   missingAttributesSessionId    =     \" no - attributes \"  ;", "String   existingSessionId    =     \" existing \"  ;", "SessionCreationMetaData   creationMetaData    =    mock ( SessionCreationMetaData . class )  ;", "SessionAccessMetaData   accessMetaData    =    mock ( SessionAccessMetaData . class )  ;", "AtomicReference < Object >    localContext    =    new   AtomicReference <  >  (  )  ;", "MetaData < Object >    metaData    =    new   MetaData <  >  ( creationMetaData ,    accessMetaData ,    localContext )  ;", "Object   attributes    =    new   Object (  )  ;", "when ( this . metaDataFactory . findValue ( missingMetaDataSessionId )  )  . thenReturn ( null )  ;", "when ( this . metaDataFactory . findValue ( missingAttributesSessionId )  )  . thenReturn ( metaData )  ;", "when ( this . metaDataFactory . findValue ( existingSessionId )  )  . thenReturn ( metaData )  ;", "when ( this . attributesFactory . findValue ( missingAttributesSessionId )  )  . thenReturn ( null )  ;", "when ( this . attributesFactory . findValue ( existingSessionId )  )  . thenReturn ( attributes )  ;", "Map . Entry < MetaData < Object >  ,    Object >    missingMetaDataResult    =    this . factory . findValue ( missingMetaDataSessionId )  ;", "Map . Entry < MetaData < Object >  ,    Object >    missingAttributesResult    =    this . factory . findValue ( missingAttributesSessionId )  ;", "Map . Entry < MetaData < Object >  ,    Object >    existingSessionResult    =    this . factory . findValue ( existingSessionId )  ;", "assertNull ( missingMetaDataResult )  ;", "assertNull ( missingAttributesResult )  ;", "assertNotNull ( existingSessionResult )  ;", "assertSame ( metaData ,    existingSessionResult . getKey (  )  )  ;", "assertSame ( attributes ,    existingSessionResult . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["findValue"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . metaDataFactory ,    this . factory . getMetaDataFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMetaDataFactory"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" id \"  ;", "when ( this . metaData . remove ( id )  )  . thenReturn ( false )  ;", "this . factory . remove ( id )  ;", "verify ( this . attributes ,    never (  )  )  . remove ( id )  ;", "when ( this . metaData . remove ( id )  )  . thenReturn ( true )  ;", "this . factory . remove ( id )  ;", "verify ( this . attributes )  . remove ( id )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( event . isPre (  )  )  )     &  &     (  !  ( this . properties . isPersistent (  )  )  )  )     {", "String   id    =    event . getKey (  )  . getValue (  )  ;", "WebLogger . ROOT _ LOGGER . tracef (  \" Session    % s   was   activated \"  ,    id )  ;", "Map . Entry < MV ,    AV >    value    =    this . factory . findValue ( id )  ;", "if    ( value    !  =    null )     {", "ImmutableSession   session    =    this . factory . createImmutableSession ( id ,    value )  ;", "this . triggerPostActivationEvents ( session )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["activated"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . executeOnPrimaryOwner ( sessionId ,    new   CancelSchedulerCommand ( sessionId )  )  ;", "}    catch    ( Exception   e )     {", "WebLogger . ROOT _ LOGGER . failedToCancelSession ( e ,    sessionId )  ;", "}", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "this . invoker . invoke (  (  )     -  >     {", "Node   node    =    this . locatePrimaryOwner ( Id )  ;", "return   this . dispatcher . executeOnNode ( command ,    node )  ;", "}  )  . get (  )  ;", "}", "METHOD_END"], "methodName": ["executeOnPrimaryOwner"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "ImmutableSessionAttributes   attributes    =    session . getAttributes (  )  ;", "List < HttpSessionActivationListener >    listeners    =    new   ArrayList <  >  ( attributes . getAttributeNames (  )  . size (  )  )  ;", "for    ( String   name    :    attributes . getAttributeNames (  )  )     {", "Object   attribute    =    attributes . getAttribute ( name )  ;", "if    ( attribute   instanceof   HttpSessionActivationListener )     {", "listeners . add (  (  ( HttpSessionActivationListener )     ( attribute )  )  )  ;", "}", "}", "return   listeners ;", "}", "METHOD_END"], "methodName": ["findListeners"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "Locality   locality    =    new   CacheLocality ( this . cache )  ;", "try    ( Stream < Key < St >  >    keys    =    this . cache . getAdvancedCache (  )  . withFlags ( flags )  . keySet (  )  . stream (  )  )     {", "return   keys . filter ( this . filter . and (  (    key )     -  >    locality . isLocal ( key )  )  )  . map (  (    key )     -  >    key . getValue (  )  )  . collect ( Collectors . toSet (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSessions"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . properties . isPersistent (  )  ;", "}", "METHOD_END"], "methodName": ["isPersistent"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "DistributionManager   dist    =    this . cache . getAdvancedCache (  )  . getDistributionManager (  )  ;", "Address   address    =     ( dist    !  =    null )     ?    dist . getCacheTopology (  )  . getDistribution ( new   Key ( sessionId )  )  . primary (  )     :    null ;", "Node   node    =     ( address    !  =    null )     ?    this . memberFactory . createNode ( address )     :    null ;", "return   node    !  =    null    ?    node    :    this . group . getLocalMember (  )  ;", "}", "METHOD_END"], "methodName": ["locatePrimaryOwner"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( event . isPre (  )  )     &  &     (  !  ( this . properties . isPersistent (  )  )  )  )     {", "String   id    =    event . getKey (  )  . getValue (  )  ;", "WebLogger . ROOT _ LOGGER . tracef (  \" Session    % s   will   be   passivated \"  ,    id )  ;", "Map . Entry < MV ,    AV >    value    =    this . factory . findValue ( id )  ;", "if    ( value    !  =    null )     {", "ImmutableSession   session    =    this . factory . createImmutableSession ( id ,    value )  ;", "this . triggerPrePassivationEvents ( session )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["passivated"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( event . isPre (  )  )     {", "String   id    =    event . getKey (  )  . getValue (  )  ;", "WebLogger . ROOT _ LOGGER . tracef (  \" Session    % s   will   be   removed \"  ,    id )  ;", "Map . Entry < MV ,    AV >    value    =    this . factory . findValue ( id )  ;", "if    ( value    !  =    null )     {", "ImmutableSession   session    =    this . factory . createImmutableSession ( id ,    value )  ;", "ImmutableSessionAttributes   attributes    =    session . getAttributes (  )  ;", "HttpSession   httpSession    =    new   ImmutableHttpSessionAdapter ( session ,    this . context )  ;", "for    ( String   name    :    attributes . getAttributeNames (  )  )     {", "Object   attribute    =    attributes . getAttribute ( name )  ;", "if    ( attribute   instanceof   HttpSessionBindingListener )     {", "HttpSessionBindingListener   listener    =     (  ( HttpSessionBindingListener )     ( attribute )  )  ;", "listener . valueUnbound ( new   HttpSessionBindingEvent ( httpSession ,    name ,    attribute )  )  ;", "}", "}", "if    (  ( this . recorder )     !  =    null )     {", "this . recorder . record ( session )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["removed"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . executeOnPrimaryOwner ( sessionId ,    new   ScheduleSchedulerCommand ( sessionId ,    metaData )  )  ;", "}    catch    ( Exception   e )     {", "WebLogger . ROOT _ LOGGER . failedToScheduleSession ( e ,    sessionId )  ;", "}", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "List < HttpSessionActivationListener >    listeners    =    InfinispanSessionManager . findListeners ( session )  ;", "if    (  !  ( listeners . isEmpty (  )  )  )     {", "HttpSessionEvent   event    =    new   HttpSessionEvent ( new   ImmutableHttpSessionAdapter ( session ,    this . context )  )  ;", "for    ( HttpSessionActivationListener   listener    :    listeners )     {", "listener . sessionDidActivate ( event )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["triggerPostActivationEvents"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "List < HttpSessionActivationListener >    listeners    =    InfinispanSessionManager . findListeners ( session )  ;", "if    (  !  ( listeners . isEmpty (  )  )  )     {", "HttpSessionEvent   event    =    new   HttpSessionEvent ( new   ImmutableHttpSessionAdapter ( session ,    this . context )  )  ;", "for    ( HttpSessionActivationListener   listener    :    listeners )     {", "listener . sessionWillPassivate ( event )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["triggerPrePassivationEvents"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManager"}, {"methodBody": ["METHOD_START", "{", "SessionManagerFactoryConfiguration < C ,    L >    config    =    configuration . getSessionManagerFactoryConfiguration (  )  ;", "MarshalledValueFactory < C >    factory    =    config . getMarshalledValueFactory (  )  ;", "C   context    =    config . getMarshallingContext (  )  ;", "switch    ( config . getAttributePersistenceStrategy (  )  )     {", "case   FINE    :", "{", "return   new   fine . FineSessionAttributesFactory ( configuration . getCache (  )  ,    configuration . getCache (  )  ,    new   MarshalledValueMarshaller ( factory ,    context )  ,    this . properties )  ;", "}", "case   COARSE    :", "{", "return   new   coarse . CoarseSessionAttributesFactory ( configuration . getCache (  )  ,    new   MarshalledValueMarshaller ( factory ,    context )  ,    this . properties )  ;", "}", "default    :", "{", "throw   new   IllegalStateException (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createSessionAttributesFactory"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManagerFactory"}, {"methodBody": ["METHOD_START", "{", "PrivilegedAction < ThreadFactory >    action    =     (  )     -  >    new   JBossThreadFactory ( new   ThreadGroup ( InfinispanSessionManager . class . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ;", "return   WildFlySecurityManager . doUnchecked ( action )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManagerFactory"}, {"methodBody": ["METHOD_START", "{", "Cache < SessionCreationMetaDataKey ,     ?  >    cache    =    event . getCache (  )  ;", "Locality   newLocality    =    new   ConsistentHashLocality ( cache ,    event . getConsistentHashAtEnd (  )  )  ;", "if    ( event . isPre (  )  )     {", "Future <  ?  >    future    =    this . rehashFuture . getAndSet ( null )  ;", "if    ( future    !  =    null )     {", "future . cancel ( true )  ;", "}", "try    {", "this . executor . submit (  (  )     -  >    this . dispatcher . getContext (  )  . cancel ( newLocality )  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "} else    {", "Locality   oldLocality    =    new   ConsistentHashLocality ( cache ,    event . getConsistentHashAtStart (  )  )  ;", "try    {", "this . rehashFuture . set ( this . executor . submit (  (  )     -  >    this . schedule ( oldLocality ,    newLocality )  )  )  ;", "}    catch    ( RejectedExecutionException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["dataRehashed"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManagerFactory"}, {"methodBody": ["METHOD_START", "{", "SessionMetaDataFactory < InfinispanSessionMetaData < L >  ,    L >    metaDataFactory    =    this . factory . getMetaDataFactory (  )  ;", "try    ( CloseableIterator < Key < String >  >    keys    =    this . cache . getAdvancedCache (  )  . withFlags ( CACHE _ MODE _ LOCAL ,    SKIP _ CACHE _ LOAD )  . keySet (  )  . iterator (  )  )     {", "while    ( keys . hasNext (  )  )     {", "if    ( Thread . currentThread (  )  . isInterrupted (  )  )", "break ;", "Key < String >    key    =    keys . next (  )  ;", "if    (  (  ( this . filter . test ( key )  )     &  &     (  !  ( oldLocality . isLocal ( key )  )  )  )     &  &     ( newLocality . isLocal ( key )  )  )     {", "String   id    =    key . getValue (  )  ;", "try    ( Batch   batch    =    this . batcher . createBatch (  )  )     {", "try    {", "InfinispanSessionMetaData < L >    value    =    metaDataFactory . tryValue ( id )  ;", "if    ( value    !  =    null )     {", "this . scheduler . schedule ( id ,    metaDataFactory . createImmutableSessionMetaData ( id ,    value )  )  ;", "}", "return ;", "}    catch    ( CacheException   e )     {", "batch . discard (  )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionManagerFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . accessMetaData ;", "}", "METHOD_END"], "methodName": ["getAccessMetaData"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . creationMetaData ;", "}", "METHOD_END"], "methodName": ["getCreationMetaData"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . localContext ;", "}", "METHOD_END"], "methodName": ["getLocalContext"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionMetaData"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( event . isPre (  )  )  )     {", "Cache < SessionAccessMetaDataKey ,    SessionAccessMetaData >    cache    =    this . accessMetaDataCache . getAdvancedCache (  )  . withFlags ( SKIP _ LISTENER _ NOTIFICATION )  ;", "for    ( Key < String >    key    :    event . getEntries (  )  . keySet (  )  )     {", "if    ( key   instanceof   SessionCreatKey )     {", "cache . evict ( new   SessionAccessMetaDataKey ( key . getValue (  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["evicted"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionMetaDataFactory"}, {"methodBody": ["METHOD_START", "{", "SessionCreationMetaDataKey   key    =    new   SessionCreationMetaDataKey ( id )  ;", "SessionCreationMetaDataEntry < L >    creationMetaDataEntry    =    creationMetaDataCache . get ( key )  ;", "if    ( creationMetaDataEntry    !  =    null )     {", "SessionAccessMetaData   accessMetaData    =    this . accessMetaDataCache . get ( new   SessionAccessMetaDataKey ( id )  )  ;", "if    ( accessMetaData    !  =    null )     {", "return   new    <  >  ( creationMetaDataEntry . getMetaData (  )  ,    accessMetaData ,    creationMetaDataEntry . getLocalContext (  )  )  ;", "}", "creationMetaDataCache . getAdvancedCache (  )  . withFlags ( IGNORE _ RETURN _ VALUES ,    SKIP _ LISTENER _ NOTIFICATION )  . remove ( key )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionMetaDataFactory"}, {"methodBody": ["METHOD_START", "{", "SessionCreationMetaDataKey   key    =    new   SessionCreationMetaDataKey ( id )  ;", "if    (  (  !  ( this . properties . isLockOnWrite (  )  )  )     |  |     ( creationMetaDataCache . getAdvancedCache (  )  . withFlags ( ZERO _ LOCK _ ACQUISITION _ TIMEOUT ,    FAIL _ SILENTLY )  . lock ( key )  )  )     {", "creationMetaDataCache . getAdvancedCache (  )  . withFlags ( IGNORE _ RETURN _ VALUES )  . remove ( key )  ;", "this . accessMetaDataCache . getAdvancedCache (  )  . withFlags ( IGNORE _ RETURN _ VALUES )  . remove ( new   SessionAccessMetaDataKey ( id )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionMetaDataFactory"}, {"methodBody": ["METHOD_START", "{", "when ( this . metaData . isValid (  )  )  . thenReturn ( true )  ;", "thisclose (  )  ;", "verify ( this . attributes )  . close (  )  ;", "verify ( this . metaData )  . setLastAccessedTime ( any ( Instant . class )  )  ;", "reset ( this . metaData ,    this . attributes )  ;", "when ( this . metaData . isValid (  )  )  . thenReturn ( false )  ;", "thisclose (  )  ;", "thisclose (  )  ;", "verify ( this . attributes ,    never (  )  )  . close (  )  ;", "verify ( this . metaData ,    never (  )  )  . setLastAccessedTime ( any ( Instant . class )  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . attributes ,    this . session . getAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . id ,    this . session . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "Object   expected    =    new   Object (  )  ;", "when ( this . localContextFactory . createLocalContext (  )  )  . thenReturn ( expected )  ;", "Object   result    =    thisgetLocalContext (  )  ;", "assertSame ( expected ,    result )  ;", "reset ( this . localContextFactory )  ;", "result    =    thisgetLocalContext (  )  ;", "verifyZeroInteractions ( this . localContextFactory )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getLocalContext"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . metaData ,    this . session . getMetaData (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMetaData"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . metaData . invalidate (  )  )  . thenReturn ( true )  ;", "thisinvalidate (  )  ;", "verify ( this . remover )  . remove ( this . id )  ;", "reset ( this . remover )  ;", "when ( this . metaData . invalidate (  )  )  . thenReturn ( false )  ;", "thisinvalidate (  )  ;", "verify ( this . remover ,    never (  )  )  . remove ( this . id )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . metaData . isValid (  )  )  . thenReturn ( true )  ;", "assertTrue ( thisisValid (  )  )  ;", "when ( this . metaData . isValid (  )  )  . thenReturn ( false )  ;", "assertFalse ( thisisValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.wildfly.clustering.web.infinispan.session.InfinispanSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "in . defaultReadObject (  )  ;", "Instant   creationTime    =     (  ( Instant )     ( in . readObject (  )  )  )  ;", "Duration   maxInactiveInterval    =     (  ( Duration )     ( in . readObject (  )  )  )  ;", "Duration   lastAccessedDuration    =     (  ( Duration )     ( in . readObject (  )  )  )  ;", "SCreationMetaData   creationMetaData    =    new   SimpleSCreationMetaData ( creationTime )  ;", "creationMetaData . setMaxInactiveInterval ( maxInactiveInterval )  ;", "SAccessMetaData   accessMetaData    =    new   SimpleSAccessMetaData (  )  ;", "accessMetaData . setLastAccessedDuration ( lastAccessedDuration )  ;", "this . metaData    =    new   SimpleSMetaData ( creationMetaData ,    accessMetaData )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.wildfly.clustering.web.infinispan.session.ScheduleSchedulerCommand"}, {"methodBody": ["METHOD_START", "{", "Instant   creatime    =    this . metaData . getCreatime (  )  ;", "DuratmaxInactiveInterval    =    this . metaData . getMaxInactiveInterval (  )  ;", "DuratlastAccessedDurat =    Duratbetween ( creatime ,    this . metaData . getLastAccessedTime (  )  )  ;", "out . defaultWriteObject (  )  ;", "out . writeObject ( creatime )  ;", "out . writeObject ( maxInactiveInterval )  ;", "out . writeObject ( lastAccessedDurat ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.wildfly.clustering.web.infinispan.session.ScheduleSchedulerCommand"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( metaData 1  . getLastAccessedDuration (  )  ,    metaData 2  . getLastAccessedDuration (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionAccessMetaDataExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "SimpleSessionAccessMetaData   metaData    =    new   SimpleSessionAccessMetaData (  )  ;", "metaData . setLastAccessedDuration ( Duration . ofMinutes (  1  )  )  ;", "new   ExternalizerTester <  >  ( new   SessionAccessMetaDataExternalizer (  )  ,     :  : assertEquals )  . test ( metaData )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionAccessMetaDataExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionAccessMetaDataKey   key    =    new   SessionAccessMetaDataKey (  \" ABC 1  2  3  \"  )  ;", "new   ExternalizerTester <  >  ( new    . SessionAccessMetaDataKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . SessionAccessMetaDataKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionAccessMetaDataKeyResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . localContext ;", "}", "METHOD_END"], "methodName": ["getLocalContext"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionCreationMetaDataEntry"}, {"methodBody": ["METHOD_START", "{", "return   this . metaData ;", "}", "METHOD_END"], "methodName": ["getMetaData"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionCreationMetaDataEntry"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( entry 1  . getMetaData (  )  . getCreationTime (  )  ,    entry 2  . getMetaData (  )  . getCreationTime (  )  )  ;", "Assert . assertEquals ( entry 1  . getMetaData (  )  . getMaxInactiveInterval (  )  ,    entry 2  . getMetaData (  )  . getMaxInactiveInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionCreationMetaDataEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionCreationMetaData   metaData    =    new   SimpleSessionCreationMetaData ( Instant . now (  )  )  ;", "metaData . setMaxInactiveInterval ( Duration . ofMinutes (  1  0  )  )  ;", "SessionCreationMetaDataEntry < Object >    entry    =    new   SessionCreationMetaDataEntry <  >  ( metaData )  ;", "new   ExternalizerTester <  >  ( new   SessionCreationMetaDataEntryExternalizer (  )  ,     :  : assertEquals )  . test ( entry )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionCreationMetaDataEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionCreationMetaDataKey   key    =    new   SessionCreationMetaDataKey (  \" ABC 1  2  3  \"  )  ;", "new   ExternalizerTester <  >  ( new    . SessionCreationMetaDataKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . SessionCreationMetaDataKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionCreationMetaDataKeyResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduledThreadPoolExecutor   executor    =    new   ScheduledThreadPoolExecutor (  1  ,    factory )  ;", "executor . setRemoveOnCancelPolicy ( true )  ;", "executor . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false )  ;", "return   executor ;", "}", "METHOD_END"], "methodName": ["createScheduledExecutor"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionExpirationScheduler"}, {"methodBody": ["METHOD_START", "{", "return   AccessController . doPrivileged ( new   PrivilegedAction < ThreadFactory >  (  )     {", "@ Override", "public   ThreadFactory   run (  )     {", "return   new   JBossThreadFactory ( new   ThreadGroup (  . class . getSimpleName (  )  )  ,    Boolean . FALSE ,    null ,     \"  % G    -     % t \"  ,    null ,    null )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createThreadFactory"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionExpirationScheduler"}, {"methodBody": ["METHOD_START", "{", "Batcher < TransactionBatch >    batcher    =    mock ( Batcher . class )  ;", "TransactionBatch   batch    =    mock ( TransactionBatch . class )  ;", "Remover < String >    remover    =    mock ( Remover . class )  ;", "ImmutableSessionMetaData   immortalSessionMetaData    =    mock ( ImmutableSessionMetaData . class )  ;", "ImmutableSessionMetaData   expiringSessionMetaData    =    mock ( ImmutableSessionMetaData . class )  ;", "ImmutableSessionMetaData   canceledSessionMetaData    =    mock ( ImmutableSessionMetaData . class )  ;", "String   immortalSessionId    =     \" immortal \"  ;", "String   expiringSessionId    =     \" expiring \"  ;", "String   canceledSessionId    =     \" canceled \"  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( immortalSessionMetaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ZERO )  ;", "when ( expiringSessionMetaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ofMillis (  1 L )  )  ;", "when ( canceledSessionMetaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ofSeconds (  1  0  0 L )  )  ;", "Instant   now    =    Instant . now (  )  ;", "when ( expiringSessionMetaData . getLastAccessedTime (  )  )  . thenReturn ( now )  ;", "when ( canceledSessionMetaData . getLastAccessedTime (  )  )  . thenReturn ( now )  ;", "try    ( Scheduler   scheduler    =    new    ( batcher ,    remover )  )     {", "scheduler . schedule ( immortalSessionId ,    immortalSessionMetaData )  ;", "scheduler . schedule ( canceledSessionId ,    canceledSessionMetaData )  ;", "scheduler . schedule ( expiringSessionId ,    expiringSessionMetaData )  ;", "TimeUnit . SECONDS . sleep (  1 L )  ;", "scheduler . cancel ( canceledSessionId )  ;", "scheduler . schedule ( canceledSessionId ,    canceledSessionMetaData )  ;", "}", "verify ( remover ,    never (  )  )  . remove ( immortalSessionId )  ;", "verify ( remover )  . remove ( expiringSessionId )  ;", "verify ( remover ,    never (  )  )  . remove ( canceledSessionId )  ;", "verify ( batch )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionExpirationSchedulerTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createImmutableSession ( id ,    this . getMetaDataFactory (  )  . createImmutableSessionMetaData ( id ,    entry . getKey (  )  )  ,    this . getAttributesFactory (  )  . createImmutableSessionAttributes ( id ,    entry . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createImmutableSession"], "fileName": "org.wildfly.clustering.web.infinispan.session.SessionFactory"}, {"methodBody": ["METHOD_START", "{", "Instant   expected    =    Instant . now (  )  ;", "when ( this . creat . getCreationTime (  )  )  . thenReturn ( expected )  ;", "Instant   result    =    this . metaData . getCreationTime (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getCreationTime"], "fileName": "org.wildfly.clustering.web.infinispan.session.SimpleSessionMetaDataTestCase"}, {"methodBody": ["METHOD_START", "{", "Instant   now    =    Instant . now (  )  ;", "Duration   lastAccessed    =    Duration . ofSeconds (  1  0 L )  ;", "when ( this . creat . getCreationTime (  )  )  . thenReturn ( now . minus ( lastAccessed )  )  ;", "when ( this . accessMetaData . getLastAccessedDuration (  )  )  . thenReturn ( lastAccessed )  ;", "Instant   result    =    this . metaData . getLastAccessedTime (  )  ;", "assertEquals ( now ,    result )  ;", "}", "METHOD_END"], "methodName": ["getLastAccessedTime"], "fileName": "org.wildfly.clustering.web.infinispan.session.SimpleSessionMetaDataTestCase"}, {"methodBody": ["METHOD_START", "{", "Duration   expected    =    Duration . ofMinutes (  3  0 L )  ;", "when ( this . creat . getMaxInactiveInterval (  )  )  . thenReturn ( expected )  ;", "Duration   result    =    this . metaData . getMaxInactiveInterval (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getMaxInactiveInterval"], "fileName": "org.wildfly.clustering.web.infinispan.session.SimpleSessionMetaDataTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . creationMetaData . getCreationTime (  )  )  . thenReturn ( Instant . now (  )  . minus ( Duration . ofMinutes (  1  0 L )  )  )  ;", "when ( this . creationMetaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ofMinutes (  1  0 L )  )  ;", "when ( this . accessMetaData . getLastAccessedDuration (  )  )  . thenReturn ( Duration . ofMinutes (  5 L )  )  ;", "assertFalse ( this . metaData . isExpired (  )  )  ;", "when ( this . creationMetaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ofMinutes (  5 L )  )  ;", "when ( this . accessMetaData . getLastAccessedDuration (  )  )  . thenReturn ( Duration . ofMinutes (  0 L )  )  ;", "assertTrue ( this . metaData . isExpired (  )  )  ;", "when ( this . creationMetaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ZERO )  ;", "assertFalse ( this . metaData . isExpired (  )  )  ;", "}", "METHOD_END"], "methodName": ["isExpired"], "fileName": "org.wildfly.clustering.web.infinispan.session.SimpleSessionMetaDataTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . accessMetaData . getLastAccessedDuration (  )  )  . thenReturn ( Duration . ZERO )  ;", "assertTrue ( this . metaData . isNew (  )  )  ;", "when ( this . accessMetaData . getLastAccessedDuration (  )  )  . thenReturn ( Duration . ofMillis (  1 L )  )  ;", "assertFalse ( this . metaData . isNew (  )  )  ;", "}", "METHOD_END"], "methodName": ["isNew"], "fileName": "org.wildfly.clustering.web.infinispan.session.SimpleSessionMetaDataTestCase"}, {"methodBody": ["METHOD_START", "{", "Instant   now    =    Instant . now (  )  ;", "Duration   sinceCreated    =    Duration . ofSeconds (  1  0 L )  ;", "when ( this . creat . getCreationTime (  )  )  . thenReturn ( now . minus ( sinceCreated )  )  ;", "this . metaData . setLastAccessedTime ( now )  ;", "verify ( this . accessMetaData )  . setLastAccessedDuration ( sinceCreated )  ;", "}", "METHOD_END"], "methodName": ["setLastAccessedTime"], "fileName": "org.wildfly.clustering.web.infinispan.session.SimpleSessionMetaDataTestCase"}, {"methodBody": ["METHOD_START", "{", "Duration   duration    =    Duration . ZERO ;", "this . metaData . setMaxInactiveInterval ( duration )  ;", "verify ( this . creat )  . setMaxInactiveInterval ( duration )  ;", "}", "METHOD_END"], "methodName": ["setMaxInactiveInterval"], "fileName": "org.wildfly.clustering.web.infinispan.session.SimpleSessionMetaDataTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( event . isPre (  )  )  )     {", "Cache < Key ,    V >    cache    =    this . cache . getAdvancedCache (  )  . withFlags ( SKIP _ LISTENER _ NOTIFICATION )  ;", "for    ( Key < String >    key    :    event . getEntries (  )  . keySet (  )  )     {", "if    ( key   instanceof   SessionCreationMetaDataKey )     {", "cache . evict ( new   Key ( key . getValue (  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["evicted"], "fileName": "org.wildfly.clustering.web.infinispan.session.coarse.CoarseSessionAttributesFactory"}, {"methodBody": ["METHOD_START", "{", "SessionAttributesKey   key    =    new   SessionAttributesKey (  \" ABC 1  2  3  \"  )  ;", "new   ExternalizerTester <  >  ( new    . SessionAttributesKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . SessionAttributesKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.coarse.SessionAttributesKeyResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   SessionAttributeKey ( this . id ,    attributeId )  ;", "}", "METHOD_END"], "methodName": ["createKey"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.FineImmutableSessionAttributes"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   this . marshaller . read ( value )  ;", "}    catch    ( InvalidSerializedFormException   e )     {", "throw   InfinispanWebLogger . ROOT _ LOGGER . failedToRead ( e ,    this . id ,    name )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.FineImmutableSessionAttributes"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( event . isPre (  )  )  )     {", "Set < NamesKey >    keys    =    new   HashSet <  >  (  )  ;", "for    ( Key < String >    key    :    event . getEntries (  )  . keySet (  )  )     {", "if    ( key   instanceof   SessionCreationMetaDataKey )     {", "keys . add ( new   NamesKey ( key . getValue (  )  )  )  ;", "}", "}", "if    (  !  ( keys . isEmpty (  )  )  )     {", "Cache < Key ,    V >    cache    =    this . attributeCache . getAdvancedCache (  )  . withFlags ( SKIP _ LISTENER _ NOTIFICATION )  ;", "for    ( Map . Entry < NamesKey ,    NamesEntry >    entry    :    this . namesCache . getAdvancedCache (  )  . withFlags ( CACHE _ MODE _ LOCAL ,    SKIP _ CACHE _ LOAD ,    ZERO _ LOCK _ ACQUISITION _ TIMEOUT ,    FAIL _ SILENTLY )  . getAll ( keys )  . entrySet (  )  )     {", "NamesEntry   namesEntry    =    entry . getValue (  )  ;", "if    ( namesEntry    !  =    null )     {", "String   sessionId    =    entry . getKey (  )  . getValue (  )  ;", "for    ( int   attributeId    :    namesEntry . getNames (  )  . values (  )  )     {", "cache . evict ( new   Key ( sessionId ,    attributeId )  )  ;", "}", "}", "this . namesCache . getAdvancedCache (  )  . withFlags ( SKIP _ LISTENER _ NOTIFICATION )  . evict ( entry . getKey (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["evicted"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.FineSessionAttributesFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . attributeId ;", "}", "METHOD_END"], "methodName": ["getAttributeId"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.SessionAttributeKey"}, {"methodBody": ["METHOD_START", "{", "SessionAttributeKey   key    =    new   SessionAttributeKey (  \" ABC 1  2  3  \"  ,     1  0  )  ;", "new   ExternalizerTester <  >  ( new    . SessionAttributeKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . SessionAttributeKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.SessionAttributeKeyResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . names ;", "}", "METHOD_END"], "methodName": ["getNames"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.SessionAttributeNamesEntry"}, {"methodBody": ["METHOD_START", "{", "return   this . sequence ;", "}", "METHOD_END"], "methodName": ["getSequence"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.SessionAttributeNamesEntry"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( entry 1  . getNames (  )  ,    entry 2  . getNames (  )  )  ;", "Assert . assertEquals ( entry 1  . getSequence (  )  . get (  )  ,    entry 2  . getSequence (  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.SessionAttributeNamesEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "ConcurrentMap < String ,    Integer >    attributes    =    new   ConcurrentHashMap <  >  (  )  ;", "attributes . put (  \" a \"  ,     1  )  ;", "attributes . put (  \" b \"  ,     2  )  ;", "attributes . put (  \" c \"  ,     3  )  ;", "SessionAttributeNamesEntry   entry    =    new   SessionAttributeNamesEntry ( new   AtomicInteger (  1  0  )  ,    attributes )  ;", "new   ExternalizerTester <  >  ( new   SessionAttributeNamesEntryExternalizer (  )  ,     :  : assertEquals )  . test ( entry )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.SessionAttributeNamesEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionAttributeNamesKey   key    =    new   SessionAttributeNamesKey (  \" ABC 1  2  3  \"  )  ;", "new   ExternalizerTester <  >  ( new    . SessionAttributeNamesKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . SessionAttributeNamesKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.session.fine.SessionAttributeNamesKeyResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . authentication ;", "}", "METHOD_END"], "methodName": ["getAuthentication"], "fileName": "org.wildfly.clustering.web.infinispan.sso.AuthenticationEntry"}, {"methodBody": ["METHOD_START", "{", "return   this . localContext ;", "}", "METHOD_END"], "methodName": ["getLocalContext"], "fileName": "org.wildfly.clustering.web.infinispan.sso.AuthenticationEntry"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( entry 1  . getAuthentication (  )  ,    entry 2  . getAuthentication (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.wildfly.clustering.web.infinispan.sso.AuthenticationEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "new   ExternalizerTester <  >  ( new   AuthenticationEntryExternalizer <  >  (  )  ,    AuthenticationEntryExternalizerTestCase :  : assertEquals )  . test ( new   AuthenticationEntry <  >  (  \" username \"  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.sso.AuthenticationEntryExternalizerTestCase"}, {"methodBody": ["METHOD_START", "{", "AuthenticationKey   key    =    new   AuthenticationKey (  \" ABC 1  2  3  \"  )  ;", "new   ExternalizerTester <  >  ( new    . AuthenticationKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . AuthenticationKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.sso.AuthenticationKeyResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . authentication ,    this . sso . getAuthentication (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAuthentication"], "fileName": "org.wildfly.clustering.web.infinispan.sso.InfinispanSSOTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . id ,    this . sso . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.wildfly.clustering.web.infinispan.sso.InfinispanSSOTestCase"}, {"methodBody": ["METHOD_START", "{", "Object   expected    =    new   Object (  )  ;", "when ( this . localContextFactory . createLocalContext (  )  )  . thenReturn ( expected )  ;", "Object   result    =    thisgetLocalContext (  )  ;", "assertSame ( expected ,    result )  ;", "reset ( this . localContextFactory )  ;", "result    =    thisgetLocalContext (  )  ;", "verifyZeroInteractions ( this . localContextFactory )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getLocalContext"], "fileName": "org.wildfly.clustering.web.infinispan.sso.InfinispanSSOTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . sessions ,    this . sso . getSessions (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessions"], "fileName": "org.wildfly.clustering.web.infinispan.sso.InfinispanSSOTestCase"}, {"methodBody": ["METHOD_START", "{", "this . sso . invalidate (  )  ;", "verify ( this . remover )  . remove ( this . id )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.wildfly.clustering.web.infinispan.sso.InfinispanSSOTestCase"}, {"methodBody": ["METHOD_START", "{", "CoarseSessionsKey   key    =    new   CoarseSessionsKey (  \" ABC 1  2  3  \"  )  ;", "new   ExternalizerTester <  >  ( new    . CoarseSessionsKeyExternalizer (  )  )  . test ( key )  ;", "new   KeyFormatTester <  >  ( new    . CoarseSessionsKeyFormat (  )  )  . test ( key )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.infinispan.sso.coarse.CoarseSessionsKeyResolverTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" id \"  ;", "String   deployment    =     \" deployment \"  ;", "when ( this . map . put ( deployment ,    id )  )  . thenReturn ( null )  ;", "this . s . addSession ( deployment ,    id )  ;", "verify ( this . mutator )  . mutate (  )  ;", "reset ( this . map ,    this . mutator )  ;", "when ( this . map . put ( deployment ,    id )  )  . thenReturn ( id )  ;", "this . s . addSession ( deployment ,    id )  ;", "verify ( this . mutator ,    never (  )  )  . mutate (  )  ;", "}", "METHOD_END"], "methodName": ["addSession"], "fileName": "org.wildfly.clustering.web.infinispan.sso.coarse.CoarseSessionsTestCase"}, {"methodBody": ["METHOD_START", "{", "Set < String >    expected    =    Collections . singleton (  \" deployment \"  )  ;", "when ( this . map . keySet (  )  )  . thenReturn ( expected )  ;", "Set < String >    result    =    this . s . getDeployments (  )  ;", "assertEquals ( expected ,    result )  ;", "verify ( this . mutator ,    never (  )  )  . mutate (  )  ;", "}", "METHOD_END"], "methodName": ["getApplications"], "fileName": "org.wildfly.clustering.web.infinispan.sso.coarse.CoarseSessionsTestCase"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" id \"  ;", "String   deployment    =     \" deployment 1  \"  ;", "String   missingDeployment    =     \" deployment 2  \"  ;", "when ( this . map . get ( deployment )  )  . thenReturn ( expected )  ;", "when ( this . map . get ( missingDeployment )  )  . thenReturn ( null )  ;", "assertSame ( expected ,    this . s . getSession ( deployment )  )  ;", "assertNull ( this . s . getSession ( missingDeployment )  )  ;", "verify ( this . mutator ,    never (  )  )  . mutate (  )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.wildfly.clustering.web.infinispan.sso.coarse.CoarseSessionsTestCase"}, {"methodBody": ["METHOD_START", "{", "String   deployment    =     \" deployment \"  ;", "when ( this . map . remove ( deployment )  )  . thenReturn (  \" id \"  )  ;", "this . sessions . remov ( deployment )  ;", "verify ( this . mutator )  . mutate (  )  ;", "reset ( this . map ,    this . mutator )  ;", "when ( this . map . remove ( deployment )  )  . thenReturn ( null )  ;", "this . sessions . remov ( deployment )  ;", "verify ( this . mutator ,    never (  )  )  . mutate (  )  ;", "}", "METHOD_END"], "methodName": ["removeSession"], "fileName": "org.wildfly.clustering.web.infinispan.sso.coarse.CoarseSessionsTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . session ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.wildfly.clustering.web.infinispan.sso.coarse.SessionFilter"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  ;     +  + i )     {", "String   id    =    generator . get (  )  ;", "ByteArrayOutputStream   bytes    =    new   ByteArrayOutputStream (  )  ;", "try    ( ObjectOutputStream   output    =    new   ObjectOutputStream ( bytes )  )     {", "extern . write ( output ,    id )  ;", "}", "try    ( ObjectInputStream   input    =    new   ObjectInputStream ( new   ByteArrayInputStream ( bytes . toByteArray (  )  )  )  )     {", "Assert . assertEquals ( id ,    extern . read ( input )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.session.IdentifierSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionIdGenerator   generator    =    new   SecureRandomSessionIdGenerator (  )  ;", ". test ( IdentifierSerializer . BASE 6  4  ,     (  )     -  >    generator . createSessionId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBase64"], "fileName": "org.wildfly.clustering.web.session.IdentifierSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "IdentifierSerializerTestCase . test ( IdentifierSerializer . HEX ,     (  )     -  >     {", "byte [  ]    buffer    =    new   byte [  1  6  ]  ;", "int   sessionIdLength    =     1  6  ;", "StringBuilder   builder    =    new   StringBuilder (  (  2     *    sessionIdLength )  )  ;", "int   resultLenBytes    =     0  ;", "Random   random    =    new   Random ( System . currentTimeMillis (  )  )  ;", "while    ( resultLenBytes    <    sessionIdLength )     {", "random . nextBytes ( buffer )  ;", "for    ( int   j    =     0  ;     ( j    <     ( buffer . length )  )     &  &     ( resultLenBytes    <    sessionIdLength )  ;    j +  +  )     {", "byte   b 1     =     (  ( byte )     (  (  ( buffer [ j ]  )     &     2  4  0  )     >  >     4  )  )  ;", "byte   b 2     =     (  ( byte )     (  ( buffer [ j ]  )     &     1  5  )  )  ;", "if    ( b 1     <     1  0  )", "builder . append (  (  ( char )     (  '  0  '     +    b 1  )  )  )  ;", "else", "builder . append (  (  ( char )     (  ' A '     +     ( b 1     -     1  0  )  )  )  )  ;", "if    ( b 2     <     1  0  )", "builder . append (  (  ( char )     (  '  0  '     +    b 2  )  )  )  ;", "else", "builder . append (  (  ( char )     (  ' A '     +     ( b 2     -     1  0  )  )  )  )  ;", "resultLenBytes +  +  ;", "}", "}", "return   builder . toString (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testHex"], "fileName": "org.wildfly.clustering.web.session.IdentifierSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "IdentifierSerializerTestCase . test ( IdentifierSerializer . UTF 8  ,     (  )     -  >    UUID . randomUUID (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUTF8"], "fileName": "org.wildfly.clustering.web.session.IdentifierSerializerTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "String   name    =     \" name \"  ;", "Object   expected    =    new   Object (  )  ;", "when ( this . session . getAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . getAttribute ( name )  )  . thenReturn ( expected )  ;", "Object   result    =    this . h . getAttribute ( name )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "Set < String >    expected    =    new   TreeSet <  >  (  )  ;", "when ( this . session . getAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . getAttributeNames (  )  )  . thenReturn ( expected )  ;", "Enumeration < String >    result    =    this . h . getAttributeNames (  )  ;", "assertEquals ( new   ArrayList ( expected )  ,    Collections . list ( result )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "Instant   now    =    Instant . now (  )  ;", "when ( this . session . getMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getCreationTime (  )  )  . thenReturn ( now )  ;", "long   result    =    this . h . getCreationTime (  )  ;", "assertEquals ( now . toEpochMilli (  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["getCreationTime"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" session \"  ;", "when ( this . session . getId (  )  )  . thenReturn ( expected )  ;", "String   result    =    this . h . getId (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "Instant   now    =    Instant . now (  )  ;", "when ( this . session . getMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getLastAccessedTime (  )  )  . thenReturn ( now )  ;", "long   result    =    this . h . getLastAccessedTime (  )  ;", "assertEquals ( now . toEpochMilli (  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["getLastAccessedTime"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "Duration   interval    =    Duration . of (  1  0  0 L ,    ChronoUnit . SECONDS )  ;", "when ( this . session . getMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getMaxInactiveInterval (  )  )  . thenReturn ( interval )  ;", "int   result    =    this . h . getMaxInactiveInterval (  )  ;", "assertEquals ( interval . getSeconds (  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["getMaxInactiveInterval"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . context ,    this . httpSession . getServletContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServletContext"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "this . httpSession . invalidate (  )  ;", "verifyZeroInteractions ( this . session )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "when ( this . session . getMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . isNew (  )  )  . thenReturn ( true ,    false )  ;", "assertTrue ( this . h . isNew (  )  )  ;", "assertFalse ( this . h . isNew (  )  )  ;", "}", "METHOD_END"], "methodName": ["isNew"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "this . httpSession . removeAttribute (  \" name \"  )  ;", "verifyZeroInteractions ( this . session )  ;", "}", "METHOD_END"], "methodName": ["removeAttribute"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "this . httpSession . setAttribute (  \" name \"  ,     \" value \"  )  ;", "verifyZeroInteractions ( this . session )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "this . httpSession . setMaxInactiveInterval (  1  0  )  ;", "verifyZeroInteractions ( this . session )  ;", "}", "METHOD_END"], "methodName": ["setMaxInactiveInterval"], "fileName": "org.wildfly.clustering.web.session.ImmutableHttpSessionAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" expected \"  ;", "when ( this . generator . createSessionId (  )  )  . thenReturn ( expected )  ;", "String   result    =    this . factory . create (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.undertow.IdentifierFactoryAdapterTestCase"}, {"methodBody": ["METHOD_START", "{", "LocalSessionContext   localContext    =    this . entry . getKey (  )  . getLocalContext (  )  ;", "AuthenticatedSession   old    =    localContext . getAuthenticatedSession (  )  ;", "localContext . setAuthenticatedSession ( auth )  ;", "return   old ;", "}", "METHOD_END"], "methodName": ["setLocalContext"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSession"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( session . isValid (  )  )  )     {", "throw   UndertowCLogger . ROOT _ LOGGER . sessionIsInvalid ( session . getId (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSession"}, {"methodBody": ["METHOD_START", "{", "for    ( RouteLocatorBuilderProvider   provider    :    ServiceLoader . load ( RouteLocatorBuilderProvider . class ,    RouteLocatorBuilderProvider . class . getClassLoader (  )  )  )     {", "return   provider ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["loadProvider"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionIdentifierCodecBuilderProvider"}, {"methodBody": ["METHOD_START", "{", "String   encodedSessionId    =     \" session . route \"  ;", "String   sessionId    =     \" session \"  ;", "String   route    =     \" route \"  ;", "when ( this . routing . parse ( encodedSessionId )  )  . thenReturn ( new   AbstractMap . SimpleImmutableEntry ( sessionId ,    route )  )  ;", "String   result    =    this . codec . decode ( encodedSessionId )  ;", "assertSame ( sessionId ,    result )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionIdentifierCodecTestCase"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" session \"  ;", "when ( this . locator . locate ( sessionId )  )  . thenReturn ( null )  ;", "String   result    =    this . codec . encode ( sessionId )  ;", "assertSame ( sessionId ,    result )  ;", "String   route    =     \" route \"  ;", "String   encoded    =     \" session . route \"  ;", "when ( this . locator . locate ( sessionId )  )  . thenReturn ( route )  ;", "when ( this . routing . format ( sessionId ,    route )  )  . thenReturn ( encoded )  ;", "result    =    this . codec . encode ( sessionId )  ;", "assertSame ( encoded ,    result )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionIdentifierCodecTestCase"}, {"methodBody": ["METHOD_START", "{", "long   stamp    =    this . lifecycleLock . tryReadLock (  )  ;", "if    ( stamp    =  =     0  )     {", "throw   UndertowClusteringLogger . ROOT _ LOGGER . sStopped (  )  ;", "}", "return    (  )     -  >    this . lifecycleLock . unlock ( stamp )  ;", "}", "METHOD_END"], "methodName": ["getSessionCloseTask"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManager"}, {"methodBody": ["METHOD_START", "{", "for    ( SessionManagerFactoryBuilderProvider < Batch >    provider    :    ServiceLoader . load ( SessionManagerFactoryBuilderProvider . class ,    SessionManagerFactoryBuilderProvider . class . getClassLoader (  )  )  )     {", "return   provider ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["loadProvider"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerFactoryBuilderProvider"}, {"methodBody": ["METHOD_START", "{", "when ( this . manager . getActiveSessions (  )  )  . thenReturn ( Collections . singleton (  \" expected \"  )  )  ;", "int   result    =    this . adapter . getActiveSessions (  )  . size (  )  ;", "assertEquals (  1  ,    result )  ;", "}", "METHOD_END"], "methodName": ["activeSessions"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "SessionConfig   config    =    mock ( SessionConfig . class )  ;", "String   sessionId    =     \" session \"  ;", "when ( config . findSessionId ( exchange )  )  . thenReturn ( sessionId )  ;", "when ( this . manager . creat ( sessionId )  )  . thenReturn ( null )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "IllegalStateException   exception    =    null ;", "try    {", "this . adapter . creat ( exchange ,    config )  ;", "}    catch    ( IllegalStateException   e )     {", "exception    =    e ;", "}", "assertNotNull ( exception )  ;", "verify ( batch )  . discard (  )  ;", "verify ( batch )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["createSessionAlreadyExists"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "SessionConfig   config    =    mock ( SessionConfig . class )  ;", "Session < LocalSessionContext >    session    =    mock ( Session . class )  ;", "String   sessionId    =     \" session \"  ;", "when ( this . manager . createIdentifier (  )  )  . thenReturn ( sessionId )  ;", "when ( this . manager . createSession ( sessionId )  )  . thenReturn ( session )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( session . getId (  )  )  . thenReturn ( sessionId )  ;", "iorver . session . Session   sessionAdapter    =    this . adapter . createSession ( exchange ,    config )  ;", "assertNotNull ( sessionAdapter )  ;", "verify ( this . listener )  . sessionCreated ( sessionAdapter ,    exchange )  ;", "verify ( config )  . setSessionId ( exchange ,    sessionId )  ;", "verify ( batcher )  . suspendBatch (  )  ;", "verify ( this . statistics )  . record ( sessionAdapter )  ;", "String   expected    =     \" expected \"  ;", "when ( session . getId (  )  )  . thenReturn ( expected )  ;", "String   result    =    sessionAdapter . getId (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["createSessionNoSessionId"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "SessionConfig   config    =    mock ( SessionConfig . class )  ;", "Session < LocalSessionContext >    session    =    mock ( Session . class )  ;", "String   sessionId    =     \" session \"  ;", "when ( config . findSessionId ( exchange )  )  . thenReturn ( sessionId )  ;", "when ( this . manager . createSession ( sessionId )  )  . thenReturn ( session )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( session . getId (  )  )  . thenReturn ( sessionId )  ;", "iorver . session . Session   sessionAdapter    =    this . adapter . createSession ( exchange ,    config )  ;", "assertNotNull ( sessionAdapter )  ;", "verify ( this . listener )  . sessionCreated ( sessionAdapter ,    exchange )  ;", "verify ( batcher )  . suspendBatch (  )  ;", "verify ( this . statistics )  . record ( sessionAdapter )  ;", "String   expected    =     \" expected \"  ;", "when ( session . getId (  )  )  . thenReturn ( expected )  ;", "String   result    =    sessionAdapter . getId (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["createSessionSpecifiedSessionId"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" expected \"  ;", "when ( this . manager . getActivs (  )  )  . thenReturn ( Collections . singleton ( expected )  )  ;", "Set < String >    result    =    this . adapter . getActivs (  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "assertSame ( expected ,    result . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["getActiveSessions"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" expected \"  ;", "when ( this . manager . getLocals (  )  )  . thenReturn ( Collections . singleton ( expected )  )  ;", "Set < String >    result    =    this . adapter . getAlls (  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "assertSame ( expected ,    result . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllSessions"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . deploymentName ,    this . adapter . getDeploymentName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDeploymentName"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "SessionConfig   config    =    mock ( SessionConfig . class )  ;", "Session < LocalSessionContext >    session    =    mock ( Session . class )  ;", "String   sessionId    =     \" session \"  ;", "when ( config . findSessionId ( exchange )  )  . thenReturn ( sessionId )  ;", "when ( this . manager . findSession ( sessionId )  )  . thenReturn ( session )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( session . getId (  )  )  . thenReturn ( sessionId )  ;", "iorver . session . Session   sessionAdapter    =    this . adapter . getSession ( exchange ,    config )  ;", "assertNotNull ( sessionAdapter )  ;", "verifyZeroInteractions ( this . statistics )  ;", "verify ( batcher )  . suspendBatch (  )  ;", "String   expected    =     \" expected \"  ;", "when ( session . getId (  )  )  . thenReturn ( expected )  ;", "String   result    =    sessionAdapter . getId (  )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "ImmutableSession   session    =    mock ( ImmutableSession . class )  ;", "ImmutableSessionAttributes   attributes    =    mock ( ImmutableSessionAttributes . class )  ;", "ImmetaData   metaData    =    mock ( ImmetaData . class )  ;", "String   id    =     \" session \"  ;", "String   name    =     \" name \"  ;", "Object   value    =    new   Object (  )  ;", "Set < String >    names    =    Collections . singleton ( name )  ;", "Instant   creationTime    =    Instant . now (  )  ;", "Instant   lastAccessedTime    =    Instant . now (  )  ;", "Duration   maxInactiveInterval    =    Duration . ofMinutes (  3  0 L )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( this . manager . viewSession ( id )  )  . thenReturn ( session )  ;", "when ( session . getId (  )  )  . thenReturn ( id )  ;", "when ( session . getAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . getAttributeNames (  )  )  . thenReturn ( names )  ;", "when ( attributes . getAttribute ( name )  )  . thenReturn ( value )  ;", "when ( session . getMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getCreationTime (  )  )  . thenReturn ( creationTime )  ;", "when ( metaData . getLastAccessedTime (  )  )  . thenReturn ( lastAccessedTime )  ;", "when ( metaData . getMaxInactiveInterval (  )  )  . thenReturn ( maxInactiveInterval )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "Session   result    =    this . adapter . getSession ( id )  ;", "assertSame ( this . adapter ,    result . getSessionManager (  )  )  ;", "assertSame ( id ,    result . getId (  )  )  ;", "assertEquals ( creationTime . toEpochMilli (  )  ,    result . getCreationTime (  )  )  ;", "assertEquals ( lastAccessedTime . toEpochMilli (  )  ,    result . getLastAccessedTime (  )  )  ;", "assertEquals ( maxInactiveInterval . getSeconds (  )  ,    result . getMaxInactiveInterval (  )  )  ;", "assertEquals ( names ,    result . getAttributeNames (  )  )  ;", "assertSame ( value ,    result . getAttribute ( name )  )  ;", "verify ( batch )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionByIdentifier"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" session \"  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( this . manager . viewSession ( id )  )  . thenReturn ( null )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "Session   result    =    this . adapter . getSession ( id )  ;", "assertNull ( result )  ;", "verify ( batch )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionByIdentifierNotExists"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Config   config    =    mock ( Config . class )  ;", "String   sessionId    =     \" session +  \"  ;", "when ( config . findId ( exchange )  )  . thenReturn ( sessionId )  ;", "sessionAdapter    =    this . adapter . get ( exchange ,    config )  ;", "assertNull ( sessionAdapter )  ;", "verify ( this . manager ,    never (  )  )  . find ( sessionId )  ;", "}", "METHOD_END"], "methodName": ["getSessionInvalidCharacters"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Config   config    =    mock ( Config . class )  ;", "when ( config . findId ( exchange )  )  . thenReturn ( null )  ;", "sessionAdapter    =    this . adapter . get ( exchange ,    config )  ;", "assertNull ( sessionAdapter )  ;", "}", "METHOD_END"], "methodName": ["getSessionNoSessionId"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "Config   config    =    mock ( Config . class )  ;", "String   sessionId    =     \" session \"  ;", "when ( config . findId ( exchange )  )  . thenReturn ( sessionId )  ;", "when ( this . manager . find ( sessionId )  )  . thenReturn ( null )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "sessionAdapter    =    this . adapter . get ( exchange ,    config )  ;", "assertNull ( sessionAdapter )  ;", "verify ( batch )  . close (  )  ;", "verify ( batcher ,    never (  )  )  . suspendBatch (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionNotExists"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . statistics ,    this . adapter . getStatistics (  )  )  ;", "}", "METHOD_END"], "methodName": ["getStatistics"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "Set < String >    result    =    this . adapter . getTransientSessions (  )  ;", "assertTrue ( result . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransientSessions"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . adapter . registerSessionListener ( this . listener )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . adapter . setDefaultSessionTimeout (  1  0  )  ;", "verify ( this . manager )  . setDefaultMaxInactiveInterval ( Duration . ofSeconds (  1  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultSessionTimeout"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . adapter . start (  )  ;", "verify ( this . m )  . start (  )  ;", "verify ( this . statistics )  . reset (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . adapter . stop (  )  ;", "verify ( this . m )  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "SessionConfig   config    =    mock ( SessionConfig . class )  ;", "this . validate (  (     -  > changeSessionId ( exchange ,    config )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "Session < LocalSessionContext >  =    mock ( Session . class )  ;", "SessionAttributes   oldAttributes    =    mock ( SessionAttributes . class )  ;", "SessionAttributes   newAttributes    =    mock ( SessionAttributes . class )  ;", "SessionMetaData   oldMetaData    =    mock ( SessionMetaData . class )  ;", "SessionMetaData   newMetaData    =    mock ( SessionMetaData . class )  ;", "LocalSessionContext   oldContext    =    mock ( LocalSessionContext . class )  ;", "LocalSessionContext   newContext    =    mock ( LocalSessionContext . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "String   oldSessionId    =     \" old \"  ;", "String   newSessionId    =     \" new \"  ;", "String   name    =     \" name \"  ;", "Object   value    =    new   Object (  )  ;", "Instant   now    =    Instant . now (  )  ;", "Duration   interval    =    Duration . ofSeconds (  1  0 L )  ;", "AuthenticatedSession   authenticatedSession    =    new   AuthenticatedSession ( null ,    null )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( manager . createIdentifier (  )  )  . thenReturn ( newSessionId )  ;", "when ( manager . createSession ( newSessionId )  )  . thenReturn ;", "when ( thisgetAttributes (  )  )  . thenReturn ( oldAttributes )  ;", "when ( thisgetMetaData (  )  )  . thenReturn ( oldMetaData )  ;", "whengetAttributes (  )  )  . thenReturn ( newAttributes )  ;", "whengetMetaData (  )  )  . thenReturn ( newMetaData )  ;", "when ( oldAttributes . getAttributeNames (  )  )  . thenReturn ( Collections . singleton ( name )  )  ;", "when ( oldAttributes . getAttribute ( name )  )  . thenReturn ( value )  ;", "when ( newAttributes . setAttribute ( name ,    value )  )  . thenReturn ( null )  ;", "when ( oldMetaData . getLastAccessedTime (  )  )  . thenReturn ( now )  ;", "when ( oldMetaData . getMaxInactiveInterval (  )  )  . thenReturn ( interval )  ;", "when ( thisgetId (  )  )  . thenReturn ( oldSessionId )  ;", "whengetId (  )  )  . thenReturn ( newSessionId )  ;", "when ( thisgetLocalContext (  )  )  . thenReturn ( oldContext )  ;", "whengetLocalContext (  )  )  . thenReturn ( newContext )  ;", "when ( oldContext . getAuthenticatedSession (  )  )  . thenReturn ( authenticatedSession )  ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "String   result    =    this . adapter . changeSessionId ( exchange ,    config )  ;", "assertSame ( newSessionId ,    result )  ;", "verify ( newMetaData )  . setLastAccessedTime ( now )  ;", "verify ( newMetaData )  . setMaxInactiveInterval ( interval )  ;", "verify ( config )  . setSessionId ( exchange ,    newSessionId )  ;", "verify ( newContext )  . setAuthenticatedSession ( same ( authenticatedSession )  )  ;", "verify ( listener ) dChanged ( this . adapter ,    oldSessionId )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["changeSessionId"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" name \"  ;", "this . validate (  (     -  > getAttribute ( name )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "Object   expected    =    new   Object (  )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . getAttribute ( name )  )  . thenReturn ( expected )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "Object   result    =    this . adapter . getAttribute ( name )  ;", "assertSame ( expected ,    result )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "this . validate (  (     -  > getAttributeNames (  )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "Set < String >    expected    =    Collections . singleton (  \" name \"  )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . getAttributeNames (  )  )  . thenReturn ( expected )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "Object   result    =    this . adapter . getAttributeNames (  )  ;", "assertSame ( expected ,    result )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     ( CachedAuthenticatedSessionHandler . class . getName (  )  )     +     \"  . AuthenticatedSession \"  ;", "this . validate (  (     -  > getAttribute ( name )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "Account   account    =    mock ( Account . class )  ;", "AuthenticatedSession   auth    =    new   AuthenticatedSession ( account ,    HttpServletRequest . FORM _ AUTH )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . getAttribute ( name )  )  . thenReturn ( auth )  ;", "AuthenticatedSession   result    =     (  ( AuthenticatedSession )     ( this . adapter . getAttribute ( name )  )  )  ;", "assertSame ( account ,    result . getAccount (  )  )  ;", "assertSame ( FORM _ AUTH ,    result . getMechanism (  )  )  ;", "verify ( context )  . close (  )  ;", "reset ( context )  ;", "LocalSessionContext   localContext    =    mock ( LocalSessionContext . class )  ;", "AuthenticatedSession   expected    =    new   AuthenticatedSession ( account ,    HttpServletRequest . BASIC _ AUTH )  ;", "when ( attributes . getAttribute ( name )  )  . thenReturn ( null )  ;", "when ( thisgetLocalContext (  )  )  . thenReturn ( localContext )  ;", "when ( localContext . getAuthenticatedSession (  )  )  . thenReturn ( expected )  ;", "result    =     (  ( AuthenticatedSession )     ( this . adapter . getAttribute ( name )  )  )  ;", "assertSame ( expected ,    result )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getAuthenticatedSessionAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "this . validate (  (     -  > getCreationTime (  )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "Instant   now    =    Instant . now (  )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getCreationTime (  )  )  . thenReturn ( now )  ;", "long   result    =    this . adapter . getCreationTime (  )  ;", "assertEquals ( now . toEpochMilli (  )  ,    result )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getCreationTime"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" id \"  ;", "when ( thisgetId (  )  )  . thenReturn ( id )  ;", "String   result    =    this . adapter . getId (  )  ;", "assertSame ( id ,    result )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "this . validate (  (     -  > getLastAccessedTime (  )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "Instant   now    =    Instant . now (  )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getLastAccessedTime (  )  )  . thenReturn ( now )  ;", "long   result    =    this . adapter . getLastAccessedTime (  )  ;", "assertEquals ( now . toEpochMilli (  )  ,    result )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getLastAccessedTime"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "this . validate (  (     -  > getMaxInactiveInterval (  )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "long   expected    =     3  6  0  0 L ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ofSeconds ( expected )  )  ;", "long   result    =    this . adapter . getMaxInactiveInterval (  )  ;", "assertEquals ( expected ,    result )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxInactiveInterval"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . manager ,    this . adapter . getSessionManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionManager"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "this . validate (  (     -  > invalidate ( exchange )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "Stringd    =     ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "when ( thisgetId (  )  )  . thenReturnd )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "this . adapter . invalidate ( exchange )  ;", "verify ( this . invalidate (  )  ;", "verify ( this . config )  . clearSession ( exchange , d )  ;", "verify ( listener ) estroyed ( this . adapter ,    exchange ,    INVALIDATED )  ;", "verify ( this . batch )  . close (  )  ;", "verify ( context )  . close (  )  ;", "verify ( this . closeTask )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" name \"  ;", "this . validate (  (     -  > removeAttribute ( name )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "Object   expected    =    new   Object (  )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . removeAttribute ( name )  )  . thenReturn ( expected )  ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "Object   result    =    this . adapter . removeAttribute ( name )  ;", "assertSame ( expected ,    result )  ;", "verify ( listener )  . attributeRemoved ( this . adapter ,    name ,    expected )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["removeAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" name \"  ;", "this . validate (  (     -  > removeAttribute ( name )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . removeAttribute ( name )  )  . thenReturn ( null )  ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "Object   result    =    this . adapter . removeAttribute ( name )  ;", "assertNull ( result )  ;", "verify ( listener ,    never (  )  )  . attributeRemoved ( same ( this . adapter )  ,    same ( name )  ,    any (  )  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["removeNonExistingAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "when ( thisisValid (  )  )  . thenReturn ( true )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "this . adapter . requestDone ( exchange )  ;", "verify ( this . close (  )  ;", "verify ( this . batch )  . close (  )  ;", "verify ( context )  . close (  )  ;", "verify ( this . closeTask )  . run (  )  ;", "reset ( this . batch ,    this   context ,    this . closeTask )  ;", "when ( thisisValid (  )  )  . thenReturn ( false )  ;", "this . adapter . requestDone ( exchange )  ;", "verify ( this   never (  )  )  . close (  )  ;", "verify ( this . batch ,    never (  )  )  . close (  )  ;", "verify ( context ,    never (  )  )  . close (  )  ;", "verify ( this . closeTask ,    never (  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["requestDone"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" name \"  ;", "Integer   value    =    Integer . valueOf (  1  )  ;", "this . validate (  (     -  > setAttribute ( name ,    value )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "Object   expected    =    new   Object (  )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . setAttribute ( name ,    value )  )  . thenReturn ( expected )  ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "Object   result    =    this . adapter . setAttribute ( name ,    value )  ;", "assertSame ( expected ,    result )  ;", "verify ( listener ,    never (  )  )  . attributeAdded ( this . adapter ,    name ,    value )  ;", "verify ( listener )  . attributeUpdated ( this . adapter ,    name ,    value ,    expected )  ;", "verify ( listener ,    never (  )  )  . attributeRemoved ( same ( this . adapter )  ,    same ( name )  ,    any (  )  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     ( CachedAuthenticatedSessionHandler . class . getName (  )  )     +     \"  . AuthenticatedSession \"  ;", "Account   account    =    mock ( Account . class )  ;", "AuthenticatedSession   auth    =    new   AuthenticatedSession ( account ,    HttpServletRequest . FORM _ AUTH )  ;", "this . validate (  (     -  > setAttribute ( name ,     \" bar \"  )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "Account   oldAccount    =    mock ( Account . class )  ;", "AuthenticatedSession   oldAuth    =    new   AuthenticatedSession ( oldAccount ,    HttpServletRequest . FORM _ AUTH )  ;", "ArgumentCaptor < AuthenticatedSession >    capturedAuth    =    ArgumentCaptor . forClass ( AuthenticatedSession . class )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . setAttribute ( same ( name )  ,    capturedAuth . capture (  )  )  )  . thenReturn ( oldAuth )  ;", "AuthenticatedSession   result    =     (  ( AuthenticatedSession )     ( this . adapter . setAttribute ( name ,    auth )  )  )  ;", "assertSame ( auth . getAccount (  )  ,    capturedAuth . getValue (  )  . getAccount (  )  )  ;", "assertSame ( auth . getMechanism (  )  ,    capturedAuth . getValue (  )  . getMechanism (  )  )  ;", "assertSame ( oldAccount ,    result . getAccount (  )  )  ;", "assertSame ( FORM _ AUTH ,    result . getMechanism (  )  )  ;", "verify ( context )  . close (  )  ;", "reset ( context ,    attributes )  ;", "capturedAuth    =    ArgumentCaptor . forClass ( AuthenticatedSession . class )  ;", "when ( attributes . setAttribute ( same ( name )  ,    capturedAuth . capture (  )  )  )  . thenReturn ( null )  ;", "result    =     (  ( AuthenticatedSession )     ( this . adapter . setAttribute ( name ,    auth )  )  )  ;", "assertSame ( auth . getAccount (  )  ,    capturedAuth . getValue (  )  . getAccount (  )  )  ;", "assertSame ( auth . getMechanism (  )  ,    capturedAuth . getValue (  )  . getMechanism (  )  )  ;", "assertNull ( result )  ;", "verify ( context )  . close (  )  ;", "reset ( context ,    attributes )  ;", "auth    =    new   AuthenticatedSession ( account ,    HttpServletRequest . BASIC _ AUTH )  ;", "AuthenticatedSession   oldSession    =    new   AuthenticatedSession ( oldAccount ,    HttpServletRequest . BASIC _ AUTH )  ;", "LocalSessionContext   localContext    =    mock ( LocalSessionContext . class )  ;", "when ( thisgetLocalContext (  )  )  . thenReturn ( localContext )  ;", "when ( localContext . getAuthenticatedSession (  )  )  . thenReturn ( oldSession )  ;", "result    =     (  ( AuthenticatedSession )     ( this . adapter . setAttribute ( name ,    auth )  )  )  ;", "verify ( localContext )  . setAuthenticatedSession ( same ( auth )  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["setAuthenticatedSessionAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "int   interval    =     3  6  0  0  ;", "this . validate (  (     -  > setMaxInactiveInterval ( interval )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionMetaData   metaData    =    mock ( SessionMetaData . class )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetMetaData (  )  )  . thenReturn ( metaData )  ;", "this . adapter . setMaxInactiveInterval ( interval )  ;", "verify ( metaData )  . setMaxInactiveInterval ( Duration . ofSeconds ( interval )  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["setMaxInactiveInterval"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" name \"  ;", "Integer   value    =    Integer . valueOf (  1  )  ;", "this . validate (  (     -  > setAttribute ( name ,    value )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "Object   expected    =    null ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . setAttribute ( name ,    value )  )  . thenReturn ( expected )  ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "Object   result    =    this . adapter . setAttribute ( name ,    value )  ;", "assertSame ( expected ,    result )  ;", "verify ( listener )  . attributeAdded ( this . adapter ,    name ,    value )  ;", "verify ( listener ,    never (  )  )  . attributeUpdated ( same ( this . adapter )  ,    same ( name )  ,    same ( value )  ,    any (  )  )  ;", "verify ( listener ,    never (  )  )  . attributeRemoved ( same ( this . adapter )  ,    same ( name )  ,    any (  )  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["setNewAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" name \"  ;", "Object   value    =    null ;", "this . validate (  (     -  > setAttribute ( name ,    value )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "Object   expected    =    new   Object (  )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . removeAttribute ( name )  )  . thenReturn ( expected )  ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "Object   result    =    this . adapter . setAttribute ( name ,    value )  ;", "assertSame ( expected ,    result )  ;", "verify ( listener ,    never (  )  )  . attributeAdded ( this . adapter ,    name ,    value )  ;", "verify ( listener ,    never (  )  )  . attributeUpdated ( same ( this . adapter )  ,    same ( name )  ,    same ( value )  ,    any (  )  )  ;", "verify ( listener )  . attributeRemoved ( this . adapter ,    name ,    expected )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["setNullAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" name \"  ;", "Integer   value    =    Integer . valueOf (  1  )  ;", "this . validate (  (     -  > setAttribute ( name ,    value )  )  ;", "SessionManager < LocalSessionContext ,    Batch >    manager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionAttributes   attributes    =    mock ( SessionAttributes . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "Object   expected    =    value ;", "when ( this . manager . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . setAttribute ( name ,    value )  )  . thenReturn ( expected )  ;", "when ( this . manager . getSessionListeners (  )  )  . thenReturn ( listeners )  ;", "Object   result    =    this . adapter . setAttribute ( name ,    value )  ;", "assertSame ( expected ,    result )  ;", "verify ( listener ,    never (  )  )  . attributeAdded ( this . adapter ,    name ,    value )  ;", "verify ( listener ,    never (  )  )  . attributeUpdated ( same ( this . adapter )  ,    same ( name )  ,    same ( value )  ,    any (  )  )  ;", "verify ( listener ,    never (  )  )  . attributeRemoved ( same ( this . adapter )  ,    same ( name )  ,    any (  )  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["setSameAttribute"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "when ( this . session . isValid (  )  )  . thenReturn ( false ,    true )  ;", "try    {", "consumer . accept ( this . adapter )  ;", "fail (  \" Invalid   session   should   throw   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.wildfly.clustering.web.undertow.session.DistributableSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "Duration   totalLifetime    =    totals . getKey (  )  ;", "long   totals    =    totals . getValue (  )  ;", "return   new   AbstractMap . SimpleImmutableEntry <  >  ( totalLifetime . plus ( lifetime )  ,     ( totals    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["createNewTotals"], "fileName": "org.wildfly.clustering.web.undertow.session.RecordableInactiveSessionStatistics"}, {"methodBody": ["METHOD_START", "{", "ImmutableSession   session    =    mock ( ImmutableSession . class )  ;", "ImmutableSessionMetaData   metaData    =    mock ( ImmutableSessionMetaData . class )  ;", "Instant   now    =    Instant . now (  )  ;", "Instant   created    =    now . minus ( Duration . ofMinutes (  2  0 L )  )  ;", "when ( session . getMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . isExpired (  )  )  . thenReturn ( false )  ;", "when ( metaData . getCreationTime (  )  )  . thenReturn ( created )  ;", "this . s . record ( session )  ;", "assertEquals (  0 L ,    this . s . getExpiredSessionCount (  )  )  ;", "assertEquals (  2  0 L ,    this . s . getMaxSessionLifetime (  )  . toMinutes (  )  )  ;", "assertEquals (  2  0 L ,    this . s . getMeanSessionLifetime (  )  . toMinutes (  )  )  ;", "now    =    Instant . now (  )  ;", "created    =    now . minus ( Duration . ofMinutes (  1  0 L )  )  ;", "when ( metaData . isExpired (  )  )  . thenReturn ( true )  ;", "when ( metaData . getCreationTime (  )  )  . thenReturn ( created )  ;", "this . s . record ( session )  ;", "assertEquals (  1 L ,    this . s . getExpiredSessionCount (  )  )  ;", "assertEquals (  2  0 L ,    this . s . getMaxSessionLifetime (  )  . toMinutes (  )  )  ;", "assertEquals (  1  5 L ,    this . s . getMeanSessionLifetime (  )  . toMinutes (  )  )  ;", "this . s . reset (  )  ;", "assertEquals (  0 L ,    this . s . getExpiredSessionCount (  )  )  ;", "assertEquals (  0 L ,    this . s . getMaxSessionLifetime (  )  . toMinutes (  )  )  ;", "assertEquals (  0 L ,    this . s . getMeanSessionLifetime (  )  . toMinutes (  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.clustering.web.undertow.session.RecordableInactiveSessionStatisticsTestCase"}, {"methodBody": ["METHOD_START", "{", "Deployment   deployment    =    mock ( Deployment . class )  ;", "UndertowSessionManager   manager    =    mock ( UndertowSessionManager . class )  ;", "SessionManager < LocalSessionContext ,    Batch >    delegateManager    =    mock ( SessionManager . class )  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "SessionListener   listener    =    mock ( SessionListener . class )  ;", "ImmutableSession   session    =    mock ( ImmutableSession . class )  ;", "ImmutableSessionAttributes   attributes    =    mock ( ImmutableSessionAttributes . class )  ;", "ImmutableSessionMetaData   metaData    =    mock ( ImmutableSessionMetaData . class )  ;", "ArgumentCaptor < Session >    capturedSession    =    ArgumentCaptor . forClass ( Session . class )  ;", "String   expectedSessionId    =     \" session \"  ;", "SessionListeners   listeners    =    new   SessionListeners (  )  ;", "listeners . addSessionListener ( listener )  ;", "SessionExpirationListener   expirationListener    =    new    ( deployment ,    listeners )  ;", "when ( deployment . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getSessionManager (  )  )  . thenReturn ( delegateManager )  ;", "when ( delegateManager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . suspendBatch (  )  )  . thenReturn ( batch )  ;", "when ( session . getId (  )  )  . thenReturn ( expectedSessionId )  ;", "when ( session . getAttributes (  )  )  . thenReturn ( attributes )  ;", "when ( attributes . getAttributeNames (  )  )  . thenReturn ( Collections . emptySet (  )  )  ;", "when ( session . getMetaData (  )  )  . thenReturn ( metaData )  ;", "when ( metaData . getCreationTime (  )  )  . thenReturn ( Instant . now (  )  )  ;", "when ( metaData . getLastAccessedTime (  )  )  . thenReturn ( Instant . now (  )  )  ;", "when ( metaData . getMaxInactiveInterval (  )  )  . thenReturn ( Duration . ZERO )  ;", "expirationListener . sessionExpired ( session )  ;", "verify ( batcher )  . suspendBatch (  )  ;", "verify ( listener )  . sessionDestroyed ( capturedSession . capture (  )  ,    isNull (  )  ,    same ( TIMEOUT )  )  ;", "verify ( batcher )  . resumeBatch ( batch )  ;", "assertSame ( expectedSessionId ,    capturedSession . getValue (  )  . getId (  )  )  ;", "assertSame ( manager ,    capturedSession . getValue (  )  . getSessionManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["sessionExpired"], "fileName": "org.wildfly.clustering.web.undertow.session.UndertowSessionExpirationListenerTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( SSOManagerFactoryBuilderProvider < Batch >    provider    :    ServiceLoader . load ( SSOManagerFactoryBuilderProvider . class ,    SSOManagerFactoryBuilderProvider . class . getClassLoader (  )  )  )     {", "return   provider ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["loadProvider"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnManagerBuilderProvider"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" sso \"  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "Account   account    =    mock ( Account . class )  ;", "String   mechanism    =    HttpServletRequest . BASIC _ AUTH ;", "SSO < AuthenticatedSession ,    String ,    String ,    Void >    sso    =    mock ( SSO . class )  ;", "ArgumentCaptor < AuthenticatedSession >    authenticationCaptor    =    ArgumentCaptor . forClass ( AuthenticatedSession . class )  ;", "when ( this . manager . createIdentifier (  )  )  . thenReturn ( id )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( this . manager . createSSO ( same ( id )  ,    authenticationCaptor . capture (  )  )  )  . thenReturn ( sso )  ;", "SingleSignOn   result    =    this . subject . creat ( account ,    mechanism )  ;", "verify ( batcher )  . suspendBatch (  )  ;", "assertNotNull ( result )  ;", "AuthenticatedSession   capturedAuthentication    =    authenticationCaptor . getValue (  )  ;", "assertNotNull ( capturedAuthentication )  ;", "assertSame ( capturedAuthentication . getAccount (  )  ,    account )  ;", "assertSame ( capturedAuthentication . getMechanism (  )  ,    mechanism )  ;", "}", "METHOD_END"], "methodName": ["createSingleSignOn"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" sso \"  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "SSO < AuthenticatedSession ,    String ,    String ,    Void >    sso    =    mock ( SSO . class )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( this . manager . findSSO ( id )  )  . thenReturn ( sso )  ;", "result    =    this . subject . find ( id )  ;", "assertNotNull ( result )  ;", "verify ( batcher )  . suspendBatch (  )  ;", "}", "METHOD_END"], "methodName": ["findSingleSignOn"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" sso +  \"  ;", "result    =    this . subject . find ( id )  ;", "assertNull ( result )  ;", "verifyZeroInteractions ( this . manager )  ;", "}", "METHOD_END"], "methodName": ["findSingleSignOnInvalidCharacters"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" sso \"  ;", "Batcher < Batch >    batcher    =    mock ( Batcher . class )  ;", "Batch   batch    =    mock ( Batch . class )  ;", "when ( this . manager . getBatcher (  )  )  . thenReturn ( batcher )  ;", "when ( batcher . createBatch (  )  )  . thenReturn ( batch )  ;", "when ( this . manager . findSSO ( id )  )  . thenReturn ( null )  ;", "result    =    this . subject . find ( id )  ;", "assertNull ( result )  ;", "verify ( batch )  . close (  )  ;", "verify ( batcher ,    never (  )  )  . suspendBatch (  )  ;", "}", "METHOD_END"], "methodName": ["findSingleSignOnNotExists"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "InvalidatableSingleSignOn   sso    =    mock ( InvalidatableSingleSignOn . class )  ;", "this . subject . removeSingleSignOn ( sso )  ;", "verify ( sso )  . invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["removeSingleSignOn"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnManagerTestCase"}, {"methodBody": ["METHOD_START", "{", "String   deployment    =     \" deployment \"  ;", "String   sessionId    =     \" session \"  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "Session   session    =    mock ( Session . class )  ;", "SessionManager   manager    =    mock ( SessionManager . class )  ;", "Sessions < String ,    String >    sessions    =    mock ( Sessions . class )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( session . getId (  )  )  . thenReturn ( sessionId )  ;", "when ( session . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getDeploymentName (  )  )  . thenReturn ( deployment )  ;", "when ( thisgetSessions (  )  )  . thenReturn ( sessions )  ;", "this . subject . add ( session )  ;", "verify ( sessions )  . addSession ( deployment ,    sessionId )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "BatchContext   context    =    mock ( BatchContext . class )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "this . subject . close (  )  ;", "verify ( this . batch )  . close (  )  ;", "verify ( context )  . close (  )  ;", "reset ( this . batch )  ;", "this . subject . close (  )  ;", "verify ( this . batch ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "String   deployment    =     \" deployment \"  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "Session   session    =    mock ( Session . class )  ;", "SessionManager   manager    =    mock ( SessionManager . class )  ;", "Sessions < String ,    String >    sessions    =    mock ( Sessions . class )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( session . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getDeploymentName (  )  )  . thenReturn ( deployment )  ;", "when ( thisgetSessions (  )  )  . thenReturn ( sessions )  ;", "when ( sessions . getDeployments (  )  )  . thenReturn ( Collections .  < String > emptySet (  )  )  ;", "boolean   result    =    this . subject . contains ( session )  ;", "assertFalse ( result )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "reset ( context )  ;", "when ( sessions . getDeployments (  )  )  . thenReturn ( Collections . singleton ( deployment )  )  ;", "result    =    this . subject . contains ( session )  ;", "assertTrue ( result )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "BatchContext   context    =    mock ( BatchContext . class )  ;", "Account   account    =    mock ( Account . class )  ;", "String   mechanism    =    HttpServletRequest . BASIC _ AUTH ;", "AuthenticatedSession   authentication    =    new   AuthenticatedSession ( account ,    mechanism )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetAuthentication (  )  )  . thenReturn ( authentication )  ;", "Account   result    =    this . subject . getAccount (  )  ;", "assertSame ( account ,    result )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getAccount"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "String   id    =     ;", "when ( thisgetId (  )  )  . thenReturn ( id )  ;", "String   result    =    this . subject . getId (  )  ;", "assertSame ( id ,    result )  ;", "verifyZeroInteractions ( this . batch )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "BatchContext   context    =    mock ( BatchContext . class )  ;", "Account   account    =    mock ( Account . class )  ;", "String   mechanism    =    HttpServletRequest . CLIENT _ CERT _ AUTH ;", "AuthenticatedSession   authentication    =    new   AuthenticatedSession ( account ,    mechanism )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( thisgetAuthentication (  )  )  . thenReturn ( authentication )  ;", "String   result    =    this . subject . getMechanismName (  )  ;", "assertEquals ( CLIENT _ CERT _ AUTH ,    result )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getMechanismName"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "String   deployment    =     \" deployment \"  ;", "String   sessionId    =     \" session \"  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "SessionManager   manager    =    mock ( SessionManager . class )  ;", "Sessions < String ,    String >    sessions    =    mock ( Sessions . class )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( manager . getDeploymentName (  )  )  . thenReturn ( deployment )  ;", "when ( thisgetSessions (  )  )  . thenReturn ( sessions )  ;", "when ( sessions . getSession ( deployment )  )  . thenReturn ( sessionId )  ;", "Session   result    =    this . subject . getSession ( manager )  ;", "assertSame ( sessionId ,    result . getId (  )  )  ;", "assertSame ( manager ,    result . getSessionManager (  )  )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "BatchContext   context    =    mock ( BatchContext . class )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "this . subject . invalidate (  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "BatchContext   context    =    mock ( BatchContext . class )  ;", "Sessions < String ,    String >    sessions    =    mock ( Sessions . class )  ;", "SessionManager   manager    =    mock ( SessionManager . class )  ;", "Session   session    =    mock ( Session . class )  ;", "String   deployment    =     \" deployment \"  ;", "String   sessionId    =     \" session \"  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( this . sso . getSessions (  )  )  . thenReturn ( sessions )  ;", "when ( sessions . getDeployments (  )  )  . thenReturn ( Collections . singleton ( deployment )  )  ;", "when ( sessions . getSession ( deployment )  )  . thenReturn ( sessionId )  ;", "when ( this . registry . getSessionManager ( deployment )  )  . thenReturn ( manager )  ;", "when ( manager . getSession ( sessionId )  )  . thenReturn ( session )  ;", "when ( session . getId (  )  )  . thenReturn ( sessionId )  ;", "Iterator < Session >    results    =    this . subject . iterator (  )  ;", "assertTrue ( results . hasNext (  )  )  ;", "Session   result    =    results . next (  )  ;", "assertEquals ( session . getId (  )  ,    result . getId (  )  )  ;", "assertFalse ( results . hasNext (  )  )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "Session   mession    =    mock ( Session . class )  ;", "when ( session . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getSession ( same ( exchange )  ,    any (  )  )  )  . thenReturn ( mession )  ;", "result . invalidate ( exchange )  ;", "verify ( mession )  . invalidate ( same ( exchange )  )  ;", "verifyZeroInteractions ( this . batch )  ;", "verifyNoMoreInteractions ( context )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "String   deployment    =     \" deployment \"  ;", "BatchContext   context    =    mock ( BatchContext . class )  ;", "Session   session    =    mock ( Session . class )  ;", "SessionManager   manager    =    mock ( SessionManager . class )  ;", "Sessions < String ,    String >    sessions    =    mock ( Sessions . class )  ;", "when ( this . batcher . resumeBatch ( this . batch )  )  . thenReturn ( context )  ;", "when ( session . getSessionManager (  )  )  . thenReturn ( manager )  ;", "when ( manager . getDeploymentName (  )  )  . thenReturn ( deployment )  ;", "when ( thisgetSessions (  )  )  . thenReturn ( sessions )  ;", "this . subject . remove ( session )  ;", "verify ( sessions )  . removeSession ( deployment )  ;", "verifyZeroInteractions ( this . batch )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.wildfly.clustering.web.undertow.sso.DistributableSingleSignOnTestCase"}, {"methodBody": ["METHOD_START", "{", "SessionManager   manager    =    deployment . getSessionManager (  )  ;", "if    (  ( this . managers . putIfAbsent ( deployment . getDeploymentInfo (  )  . getDeploymentName (  )  ,    deployment . getSessionManager (  )  )  )     =  =    null )     {", "manager . registerSessionListener ( this . listener . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addDeployment"], "fileName": "org.wildfly.clustering.web.undertow.sso.SessionManagerRegistryBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . managers . remove ( deployment . getDeploymentInfo (  )  . getDeploymentName (  )  )  )     !  =    null )     {", "deployment . get (  )  . removeSessionListener ( this . listener . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["removeDeployment"], "fileName": "org.wildfly.clustering.web.undertow.sso.SessionManagerRegistryBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( SSOManagerFactoryBuilderProvider < Batch >    provider    :    ServiceLoader . load ( SSOManagerFactoryBuilderProvider . class ,    SSOManagerFactoryBuilderProvider . class . getClassLoader (  )  )  )     {", "return   provider ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["loadProvider"], "fileName": "org.wildfly.clustering.web.undertow.sso.elytron.DistributableSingleSignOnManagerBuilderProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . mechanism ;", "}", "METHOD_END"], "methodName": ["getMechanism"], "fileName": "org.wildfly.clustering.web.undertow.sso.elytron.ElytronAuthentication"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.clustering.web.undertow.sso.elytron.ElytronAuthentication"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" election - policy \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.wildfly.extension.clustering.singleton.ElectionPolicyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parent . addChildResource ( SingletonPolicyResourceDefinition . WILDCARD _ PATH )  ;", "if    ( SingletonModel . VERSION _  2  _  0  _  0  . requiresTransformation ( version )  )     {", "builder . getAttributeBuilder (  )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,    SingletonPolicyResourceDefinition . Attribute . CACHE . getDefinition (  )  ,    SingletonPolicyResourceDefinition . Attribute . CACHE _ CONTAINER . getDefinition (  )  )  . end (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildTransformation"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonPolicyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   PathElement . pathElement (  \" singleton - policy \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["pathElement"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonPolicyResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", "SingletonPolicy . buildTransformation ( version ,    builder )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildTransformers"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . buildKernelServices ( this . getSubsystemXml (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder ( xml )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder ( this . createAdditionalInitialization (  )  )  ;", "}", "METHOD_END"], "methodName": ["createKernelServicesBuilder"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder (  )  . setSubsystemXml ( xml )  ;", "}", "METHOD_END"], "methodName": ["createKernelServicesBuilder"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "Object [  ]  [  ]    data    =    new   Object [  ]  [  ]  {    new   Object [  ]  {    SingletonSchema . VERSION _  1  _  0  ,     5     }     }  ;", "return   Arrays . asList ( data )  ;", "}", "METHOD_END"], "methodName": ["data"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   modelA    =    services . readWholeModel (  )  ;", "ModelNode   operation    =    Operations . createDescribeOperation ( PathAddress . pathAddress ( ResourceDefinition . PATH )  )  ;", "List < ModelNode >    operations    =    checkResultAndGetContents ( services . executeOperation ( operation )  )  . asList (  )  ;", "ModelNode   modelB    =    this . createKernelServicesBuilder (  )  . setBootOperations ( operations )  . build (  )  . readWholeModel (  )  ;", "this . compare ( modelA ,    modelB )  ;", "}", "METHOD_END"], "methodName": ["testDescribeHandler"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    this . buildKernelServices (  )  ;", "ModelNode   modelA    =    services . readWholeModel (  )  ;", "String   marshalled    =    services . getPersistedXml (  )  ;", "ModelNode   modelB    =    this . buildKernelServices ( marshalled )  . readWholeModel (  )  ;", "this . compare ( modelA ,    modelB )  ;", "}", "METHOD_END"], "methodName": ["testParseAndMarshalModel"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    operations    =    this . parse ( this . getSubsystemXml (  )  )  ;", "Assert . assertEquals ( this . expectedOperationCount ,    operations . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseSubsystem"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    this . createKernelServicesBuilder (  )  . setSubsystemXmlResource ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( this . createAdditionalInitialization (  )  ,    controllerVersion ,    version )  . addSingleChildFirstClass ( AdditionalInitializatass )  . addMavenResourceURL ( mavenResourceURLs )  . skipReverseControllerCheck (  )  ;", "KernelServices   services    =    builder . build (  )  ;", "Assert . assertTrue (  (  ( ModelTestControllerVersion . MASTER )     +     \"    boot   failed \"  )  ,    services . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue (  (  ( controllerVersion . getMavenGavVersion (  )  )     +     \"    boot   failed \"  )  ,    services . getLegacyServices ( version )  . isSuccessfulBoot (  )  )  ;", "return   services ;", "}", "METHOD_END"], "methodName": ["buildKernelServices"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   AdditionalInitialization (  )  . require ( CommonUnaryRequirement . OUTBOUND _ SOCKET _ BINDING ,     \" binding 0  \"  ,     \" binding 1  \"  )  . require ( SingletonDefaultCacheRequirement . SINGLETON _ SERVICE _ BUILDER _ FACTORY ,     \" singleton - container \"  )  . require ( SingletonCacheRequirement . SINGLETON _ SERVICE _ BUILDER _ FACTORY ,     \" singleton - container \"  ,     \" singleton - cache \"  )  ;", "}", "METHOD_END"], "methodName": ["createAdditionalInitialization"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   FailedOperationTransformationConfig (  )  ;", "}", "METHOD_END"], "methodName": ["createFailedOperationConfig"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   this . createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "}", "METHOD_END"], "methodName": ["createKernelServicesBuilder"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   String . format ( pattern ,    version . getMavenGavVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["formatArtifact"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   SingletonTransformersTestCase . formatArtifact (  \" eap : wildfly - clustering - singleton - extension :  % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["formatEAP7SubsystemArtifact"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "switch    ( version )     {", "case   EAP _  7  _  0  _  0     :", "case   EAP _  7  _  1  _  0     :", "return   new   String [  ]  {     . formatEAP 7 SubsystemArtifact ( version )  ,     . formatArtifact (  \" eap : wildfly - clustering - singleton - api :  % s \"  ,    version )  ,     . formatArtifact (  \" eap : wildfly - clustering - common :  % s \"  ,    version )     }  ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "switch    ( controllerVersion )     {", "case   EAP _  7  _  0  _  0     :", "return   Model . VERSION _  1  _  0  _  0  ;", "case   EAP _  7  _  1  _  0     :", "return   Model . VERSION _  2  _  0  _  0  ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getModelVersion"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   version    =    SingletonTransformersTestCase . getModelVersion ( controller )  . getVersion (  )  ;", "String [  ]    dependencies    =    SingletonTransformersTestCase . getDependencies ( controller )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder (  )  ;", "builder . createLegacyKernelServicesBuilder ( this . createAdditionalInitialization (  )  ,    controller ,    version )  . addSingleChildFirstClass ( AdditionalInitialization . class )  . addMavenResourceURL ( dependencies )  ;", "KernelServices   services    =    builder . build (  )  ;", "KernelServices   legacyServices    =    services . getLegacyServices ( version )  ;", "Assert . assertNotNull ( legacyServices )  ;", "Assert . assertTrue ( services . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    xmlOps    =    builder . parseXmlResource (  \" subsystem - reject . xml \"  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( services ,    version ,    xmlOps ,    SingletonTransformersTestCase . createFailedOperationConfig ( version )  )  ;", "}", "METHOD_END"], "methodName": ["testRejections"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "this . testRejections ( EAP _  7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP700"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "this . testRejections ( EAP _  7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP710"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelVersion   version    =    SingletonTransformersTestCase . getModelVersion ( controller )  . getVersion (  )  ;", "final   String [  ]    dependencies    =    SingletonTransformersTestCase . getDependencies ( controller )  ;", "KernelServices   services    =    this . buildKernelServices (  \" subsystem - transform . xml \"  ,    controller ,    version ,    dependencies )  ;", "checkSubsystemModelTransformation ( services ,    version ,    null ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransformation"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "this . testTransformation ( EAP _  7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP700"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "this . testTransformation ( EAP _  7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP710"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader )  ;", "switch    ( element )     {", "case   NAME _ PREFERENCES    :", "{", ". readElement ( reader ,    operation ,    ElectionPolicyResourceDefinition . Attribute . NAME _ PREFERENCES )  ;", "break ;", "}", "case   SOCKET _ BINDING _ PREFERENCES    :", "{", ". readElement ( reader ,    operation ,    ElectionPolicyResourceDefinition . Attribute . SOCKET _ BINDING _ PREFERENCES )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parsePreferences"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    policyAddress . append ( RandomElectionPolicyResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "ParseUtils . requireNoAttributes ( r )  ;", "this . parsePreferences ( r ,    operation )  ;", "}", "METHOD_END"], "methodName": ["parseRandomElectionPolicy"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLReader"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    policyAddress . append ( SimpleElectionPolicyResourceDefinition . PATH )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;     +  + i )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader ,    i )  ;", "switch    ( attribute )     {", "case   POSITION    :", "{", ". readAttribute ( reader ,    i ,    operation ,    SimpleElectionPolicyResourceDefinition . Attribute . POSITION )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "this . parsePreferences ( reader ,    operation )  ;", "}", "METHOD_END"], "methodName": ["parseSimpleElectionPolicy"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    operations . get ( address )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;     +  + i )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader ,    i )  ;", "switch    ( attribute )     {", "case   DEFAULT    :", "{", ". readAttribute ( reader ,    i ,    operation ,    SingletonResourceDefinition . Attribute . DEFAULT )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader )  ;", "switch    ( element )     {", "case   SINGLETON _ POLICY    :", "{", "this . parseSingletonPolicy ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseSingletonPolicies"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    XMLAttribute . NAME . require ( reader )  ;", "PathAddress   address    =    subsystemAddress . append ( SingletonPolicyResourceDefinition . pathElement ( name )  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operations . put ( address ,    operation )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;     +  + i )     {", "XMLAttribute   attribute    =    XMLAttribute . forName ( reader ,    i )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "break ;", "}", "case   CACHE _ CONTAINER    :", "{", ". readAttribute ( reader ,    i ,    operation ,    SingletonPolicyResourceDefinition . Attribute . CACHE _ CONTAINER )  ;", "break ;", "}", "case   CACHE    :", "{", ". readAttribute ( reader ,    i ,    operation ,    SingletonPolicyResourceDefinition . Attribute . CACHE )  ;", "break ;", "}", "case   QUORUM    :", "{", ". readAttribute ( reader ,    i ,    operation ,    SingletonPolicyResourceDefinition . Attribute . QUORUM )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader )  ;", "switch    ( element )     {", "case   RANDOM _ ELECTION _ POLICY    :", "{", "this . parseRandomElectionPolicy ( reader ,    address ,    operations )  ;", "break ;", "}", "case   SIMPLE _ ELECTION _ POLICY    :", "{", "this . parseSimpleElectionPolicy ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseSingletonPolicy"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLReader"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getParser (  )  . parseAndSetParameter ( attribute . getDefinition (  )  ,    reader . getAttributeValue ( index )  ,    operation ,    reader )  ;", "}", "METHOD_END"], "methodName": ["readAttribute"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLReader"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getParser (  )  . parseAndSetParameter ( attribute . getDefinition (  )  ,    reader . getElementText (  )  ,    operation ,    reader )  ;", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLReader"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getMarshaller (  )  . marshallAsAttribute ( attribute . getDefinition (  )  ,    model ,    false ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeAttribute"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "SingletonXMLWriter . writeAttributes ( writer ,    model ,    EnumSet . allOf ( attributeClass )  )  ;", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute   attribute    :    attributes )     {", ". writeAttribute ( writer ,    model ,    attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( name )     {", "case   RandomElectionPolicyResourceDefinition . PATH _ VALUE    :", "{", "writer . writeStartElement ( XMLElement . RANDOM _ ELECTION _ POLICY . getLocalName (  )  )  ;", "break ;", "}", "case   SimpleElectionPolicyResourceDefinition . PATH _ VALUE    :", "{", "writer . writeStartElement ( XMLElement . SIMPLE _ ELECTION _ POLICY . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    policy ,    SimpleElectionPolicyResourceDefinition . Attribute . class )  ;", "break ;", "}", "default    :", "{", "throw   new   IllegalArgumentException ( name )  ;", "}", "}", ". writeElements ( writer ,    policy ,    ElectionPolicyResourceDefinition . Attribute . class )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeElectionPolicy"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "attribute . getDefinition (  )  . getMarshaller (  )  . marshallAsElement ( attribute . getDefinition (  )  ,    model ,    false ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeElement"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "SingletonXMLWriter . writeElements ( writer ,    model ,    EnumSet . allOf ( attributeClass )  )  ;", "}", "METHOD_END"], "methodName": ["writeElements"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute   attribute    :    attributes )     {", ". writeElement ( writer ,    model ,    attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["writeElements"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( XMLElement . SINGLETON _ POLICIES . getLocalName (  )  )  ;", ". writeAttributes ( writer ,    model ,    SingletonResourceDefinition . Attribute . class )  ;", "for    ( Property   property    :    model . get ( SingletonPolicyResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . asPropertyList (  )  )     {", ". writeSingletonPolicy ( writer ,    property . getName (  )  ,    property . getValue (  )  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeSingletonPolicies"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( XMLElement . SINGLETON _ POLICY . getLocalName (  )  )  ;", "writer . writeAttribute ( XMLAttribute . NAME . getLocalName (  )  ,    name )  ;", ". writeAttributes ( writer ,    policy ,    SingletonPolicyResourceDefinition . Attribute . class )  ;", "if    ( policy . hasDefined ( ElectionPolicyResourceDefinition . WILDCARD _ PATH . getKey (  )  )  )     {", "Property   property    =    policy . get ( ElectionPolicyResourceDefinition . WILDCARD _ PATH . getKey (  )  )  . asProperty (  )  ;", ". writeElectionPolicy ( writer ,    property . getName (  )  ,    property . getValue (  )  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeSingletonPolicy"], "fileName": "org.wildfly.extension.clustering.singleton.SingletonXMLWriter"}, {"methodBody": ["METHOD_START", "{", "XMLAttribute   attribute    =    XMLAttribute . map . get ( reader . getAttributeLocalName ( index )  )  ;", "if    ( attribute    =  =    null )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,    index )  ;", "}", "return   attribute ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.wildfly.extension.clustering.singleton.XMLAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . localName ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.wildfly.extension.clustering.singleton.XMLAttribute"}, {"methodBody": ["METHOD_START", "{", "String   value    =    reader . getAttributeValue ( null ,    this . localName )  ;", "if    ( value    =  =    null )     {", "throw   ParseUtils . missingRequired ( reader ,    this . localName )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.wildfly.extension.clustering.singleton.XMLAttribute"}, {"methodBody": ["METHOD_START", "{", "XMLElement   element    =    XMLElement . map . get ( reader . getLocalName (  )  )  ;", "if    ( element    =  =    null )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "return   element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.wildfly.extension.clustering.singleton.XMLElement"}, {"methodBody": ["METHOD_START", "{", "return   this . localName ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.wildfly.extension.clustering.singleton.XMLElement"}, {"methodBody": ["METHOD_START", "{", "this . policy    =     (  ( this . replacer )     !  =    null )     ?    this . replacer . replaceProperties ( value )     :    value ;", "}", "METHOD_END"], "methodName": ["setPolicy"], "fileName": "org.wildfly.extension.clustering.singleton.deployment.MutableSingletonDeploymentConfiguration"}, {"methodBody": ["METHOD_START", "{", "try    ( FileReader   reader    =    new   FileReader ( file )  )     {", "XMLStreamReader   xmlReader    =     . XML _ INPUT _ FACTORY . createXMLStreamReader ( reader )  ;", "try    {", "MutableSingletonDeploymentConfiguration   config    =    new   MutableSingletonDeploymentConfiguration ( unit )  ;", "this . mapper . parseDocument ( config ,    xmlReader )  ;", "return   config ;", "}    finally    {", "xmlReader . close (  )  ;", "}", "}    catch    ( XMLStreamException   e )     {", "throw   ROOT _ LOGGER . errorLoadingDeploymentStructureFile ( file . getPath (  )  ,    e )  ;", "}    catch    ( FileNotFoundException   e )     {", "throw   ROOT _ LOGGER . deploymentStructureFileNotFound ( file )  ;", "}    catch    ( IOException   e )     {", "throw   ROOT _ LOGGER . deploymentStructureFileNotFound ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.wildfly.extension.clustering.singleton.deployment.SingletonDeploymentParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "return   new   QName ( this . getNamespaceUri (  )  ,    this . root )  ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.wildfly.extension.clustering.singleton.deployment.SingletonDeploymentSchema"}]