[{"methodBody": ["METHOD_START", "{", "updater . set ( instance ,    Collections .  < K ,    V > emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "return   updater . get ( subregistry )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "return   updater . get ( instance )  . get ( key )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "final   Map < K ,    V >    snapshot    =    updater . get ( subregistry )  ;", "return   snapshot   instanceof   FastCopyHashMap    ?    Collections . unmodifiableMap ( snapshot )     :    snapshot ;", "}", "METHOD_END"], "methodName": ["getReadOnly"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "return   new   AtomicMapFieldUpdater < C ,    K ,    V >  ( updater )  ;", "}", "METHOD_END"], "methodName": ["newMapUpdater"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )     {", "throw   NamingLogger . ROOT _ LOGGER . nullVar (  \" key \"  )  ;", "}", "for    (  ;     ;  )     {", "final   Map < K ,    V >    oldMap    =    updater . get ( instance )  ;", "final   Map < K ,    V >    newMap ;", "final   V   oldValue ;", "final   int   oldSize    =    oldMap . size (  )  ;", "if    ( oldSize    =  =     0  )     {", "oldValue    =    null ;", "newMap    =    Collections . singletonMap ( key ,    value )  ;", "} else", "if    ( oldSize    =  =     1  )     {", "final   Map . Entry < K ,    V >    entry    =    oldMap . entrySet (  )  . iterator (  )  . next (  )  ;", "final   K   oldKey    =    entry . getKey (  )  ;", "if    ( oldKey . equals ( key )  )     {", "newMap    =    Collections . singletonMap ( key ,    value )  ;", "oldValue    =    entry . getValue (  )  ;", "} else    {", "newMap    =    new   util . FastCopyHashMap < K ,    V >  ( oldMap )  ;", "oldValue    =    newMap . put ( key ,    value )  ;", "}", "} else    {", "newMap    =    new   util . FastCopyHashMap < K ,    V >  ( oldMap )  ;", "oldValue    =    newMap . put ( key ,    value )  ;", "}", "final   boolean   result    =    updater . compareAndSet ( instance ,    oldMap ,    newMap )  ;", "if    ( result )     {", "return   oldValue ;", "}", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )     {", "throw   NamingLogger . ROOT _ LOGGER . nullVar (  \" key \"  )  ;", "}", "final   Map < K ,    V >    newMap ;", "final   int   oldSize    =    snapshot . size (  )  ;", "if    ( oldSize    =  =     0  )     {", "newMap    =    Collections . singletonMap ( key ,    value )  ;", "} else", "if    ( oldSize    =  =     1  )     {", "final   Map . Entry < K ,    V >    entry    =    snapshot . entrySet (  )  . iterator (  )  . next (  )  ;", "final   K   oldKey    =    entry . getKey (  )  ;", "if    ( oldKey . equals ( key )  )     {", "return   entry . getValue (  )  ;", "} else    {", "newMap    =    new   util . FastCopyHashMap < K ,    V >  ( snapshot )  ;", "newMap . put ( key ,    value )  ;", "}", "} else    {", "newMap    =    new   util . FastCopyHashMap < K ,    V >  ( snapshot )  ;", "newMap . put ( key ,    value )  ;", "}", "if    ( updater . compareAndSet ( instance ,    snapshot ,    newMap )  )     {", "return   null ;", "} else    {", "return   value ;", "}", "}", "METHOD_END"], "methodName": ["putAtomic"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )     {", "throw   NamingLogger . ROOT _ LOGGER . nullVar (  \" key \"  )  ;", "}", "for    (  ;     ;  )     {", "final   Map < K ,    V >    oldMap    =    updater . get ( instance )  ;", "final   Map < K ,    V >    newMap ;", "final   int   oldSize    =    oldMap . size (  )  ;", "if    ( oldSize    =  =     0  )     {", "newMap    =    Collections . singletonMap ( key ,    value )  ;", "} else", "if    ( oldSize    =  =     1  )     {", "final   Map . Entry < K ,    V >    entry    =    oldMap . entrySet (  )  . iterator (  )  . next (  )  ;", "final   K   oldKey    =    entry . getKey (  )  ;", "if    ( oldKey . equals ( key )  )     {", "return   entry . getValue (  )  ;", "} else    {", "newMap    =    new   util . FastCopyHashMap < K ,    V >  ( oldMap )  ;", "newMap . put ( key ,    value )  ;", "}", "} else    {", "if    ( oldMap . containsKey ( key )  )     {", "return   oldMap . get ( key )  ;", "}", "newMap    =    new   util . FastCopyHashMap < K ,    V >  ( oldMap )  ;", "newMap . put ( key ,    value )  ;", "}", "if    ( updater . compareAndSet ( instance ,    oldMap ,    newMap )  )     {", "return   null ;", "}", "}", "}", "METHOD_END"], "methodName": ["putIfAbsent"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )     {", "return   null ;", "}", "for    (  ;     ;  )     {", "final   Map < K ,    V >    oldMap    =    updater . get ( instance )  ;", "final   Map < K ,    V >    newMap ;", "final   V   oldValue ;", "final   int   oldSize    =    oldMap . size (  )  ;", "if    ( oldSize    =  =     0  )     {", "return   null ;", "} else", "if    ( oldSize    =  =     1  )     {", "final   Map . Entry < K ,    V >    entry    =    oldMap . entrySet (  )  . iterator (  )  . next (  )  ;", "if    ( entry . getKey (  )  . equals ( key )  )     {", "newMap    =    emptyMap (  )  ;", "oldValue    =    entry . getValue (  )  ;", "} else    {", "return   null ;", "}", "} else", "if    ( oldSize    =  =     2  )     {", "final   Iterator < Map . Entry < K ,    V >  >    i    =    oldMap . entrySet (  )  . iterator (  )  ;", "final   Map . Entry < K ,    V >    entry    =    i . next (  )  ;", "final   Map . Entry < K ,    V >    next    =    i . next (  )  ;", "if    ( entry . getKey (  )  . equals ( key )  )     {", "newMap    =    singletonMap ( next . getKey (  )  ,    next . getValue (  )  )  ;", "oldValue    =    entry . getValue (  )  ;", "} else", "if    ( next . getKey (  )  . equals ( key )  )     {", "newMap    =    singletonMap ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "oldValue    =    next . getValue (  )  ;", "} else    {", "return   null ;", "}", "} else    {", "if    (  !  ( oldMap . containsKey ( key )  )  )     {", "return   null ;", "}", "newMap    =    new   util . FastCopyHashMap < K ,    V >  ( oldMap )  ;", "oldValue    =    newMap . remove ( key )  ;", "}", "if    ( updater . compareAndSet ( instance ,    oldMap ,    newMap )  )     {", "return   oldValue ;", "}", "}", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.naming.AtomicMapFieldUpdater"}, {"methodBody": ["METHOD_START", "{", "return   namingStoreInjectedValue ;", "}", "METHOD_END"], "methodName": ["getNamingStoreInjectedValue"], "fileName": "org.jboss.as.naming.ContextManagedReferenceFactory"}, {"methodBody": ["METHOD_START", "{", "String   initialContextClassName    =     (  ( String )     ( environment . get ( ExternalContextObjectFactory . INITIAL _ CONTEXT _ CLASS )  )  )  ;", "String   initialContextModule    =     (  ( String )     ( environment . get ( ExternalContextObjectFactory . INITIAL _ CONTEXT _ MODULE )  )  )  ;", "final   boolean   useStringLokup    =    ExternalContextObjectFactory . useStringLookup ( environment )  ;", "final   Hashtable <  ?  ,     ?  >    newEnvironment    =    new   Hashtable <  >  ( environment )  ;", "newEnvironment . remove ( ExternalContextObjectFactory . CACHE _ CONTEXT )  ;", "newEnvironment . remove ( ExternalContextObjectFactory . INITIAL _ CONTEXT _ CLASS )  ;", "newEnvironment . remove ( ExternalContextObjectFactory . INITIAL _ CONTEXT _ MODULE )  ;", "newEnvironment . remove ( ExternalContextObjectFactory . LOOKUP _ BY _ STRING )  ;", "ClassLoader   loader ;", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "loader    =    getClass (  )  . getClassLoader (  )  ;", "} else    {", "loader    =    AccessController . doPrivileged ( new   PrivilegedAction < ClassLoader >  (  )     {", "@ Override", "public   ClassLoader   run (  )     {", "return   getClass (  )  . getClassLoader (  )  ;", "}", "}  )  ;", "}", "Class   initialContextClass    =    null ;", "final   Context   loadedContext ;", "if    ( initialContextModule    =  =    null )     {", "initialContextClass    =    Class . forName ( initialContextClassName )  ;", "Constructor   ctor    =    initialContextClass . getConstructor ( Hashtable . class )  ;", "loadedContext    =     (  ( Context )     ( ctor . newInstance ( newEnvironment )  )  )  ;", "} else    {", "Module   module    =    Module . getBootModuleLoader (  )  . loadModule ( ModuleIdentifier . fromString ( initialContextModule )  )  ;", "loader    =    module . getClassLoader (  )  ;", "final   ClassLoader   currentClassLoader    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( loader )  ;", "initialContextClass    =    Class . forName ( initialContextClassName ,    true ,    loader )  ;", "Constructor   ctor    =    initialContextClass . getConstructor ( Hashtable . class )  ;", "loadedContext    =     (  ( Context )     ( ctor . newInstance ( newEnvironment )  )  )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( currentClassLoader )  ;", "}", "}", "final   Context   context ;", "if    ( useStringLokup )     {", "context    =    new   ExternalContextObjectFactory . LookupByStringContext ( loadedContext )  ;", "} else    {", "context    =    loadedContext ;", "}", "if    (  ! useProxy )     {", "return   context ;", "}", "ProxyConfiguration   config    =    new   ProxyConfiguration (  )  ;", "config . setClassLoader ( loader )  ;", "config . setSuperClass ( initialContextClass )  ;", "config . setProxyName (  (  ( initialContextClassName    +     \"  $  $  $  $ Proxy \"  )     +     ( ExternalContextObjectFactory . PROXY _ ID . incrementAndGet (  )  )  )  )  ;", "config . setProtectionDomain ( context . getClass (  )  . getProtectionDomain (  )  )  ;", "ProxyFactory <  ?  >    factory    =    new   ProxyFactory < Object >  ( config )  ;", "return    (  ( Context )     ( factory . newInstance ( new   ExternalContextObjectFactory . CachedContext ( context )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createContext"], "fileName": "org.jboss.as.naming.ExternalContextObjectFactory"}, {"methodBody": ["METHOD_START", "{", "Object   val    =    environment . get ( ExternalContextObjectFactory . LOOKUP _ BY _ STRING )  ;", "if    ( val   instanceof   String )     {", "return   Boolean . valueOf (  (  ( String )     ( val )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["useStringLookup"], "fileName": "org.jboss.as.naming.ExternalContextObjectFactory"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   nameA    =    JBOSS . append (  \" a \"  )  ;", "final   ServiceName   nameP    =    JBOSS . append (  \" p \"  )  ;", "final   ServiceName   namePC    =    JBOSS . append (  \" p \"  ,     \" c \"  )  ;", "final   ServiceName   nameZ    =    JBOSS . append (  \" z \"  )  ;", "set    =    new    (  )  ;", "set . addExternalContext ( nameP )  ;", "assertNull ( set . getParentExternalContext ( nameA )  )  ;", "assertNull ( set . getParentExternalContext ( nameP )  )  ;", "assertNotNull ( set . getParentExternalContext ( namePC )  )  ;", "assertEquals ( nameP ,    set . getParentExternalContext ( namePC )  )  ;", "assertNull ( set . getParentExternalContext ( nameZ )  )  ;", "}", "METHOD_END"], "methodName": ["testGetParentContext"], "fileName": "org.jboss.as.naming.ExternalContextsNavigableSetTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    eventCoordinator ;", "if    ( coordinator    !  =    null )     {", "coordinator . addListener ( target . toString (  )  ,    scope ,    listener )  ;", "}", "}", "METHOD_END"], "methodName": ["addNamingListener"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "bind ( name ,    object ,    object . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( NamingUtils . isLastComponentEmpty ( name )  )     {", "throw   NamingUtils . emptyNameException (  )  ;", "}", "writeLock . lock (  )  ;", "try    {", "root . accept ( new    . BindVisitor ( true ,    name ,    object ,    bindType . getName (  )  )  )  ;", "}    finally    {", "writeLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( object   instanceof   Reference )     {", "if    (  (  (  ( Reference )     ( object )  )  . get (  \" nns \"  )  )     !  =    null )     {", "throw   Utils . cannotProceedException ( object ,    name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkReferenceForContinuation"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "writeLock . lock (  )  ;", "t    {", "root . clear (  )  ;", "}    finally    {", "writeLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( NamingUtils . isLastComponentEmpty ( name )  )     {", "throw   NamingUtils . emptyNameException (  )  ;", "}", "return   root . accept ( new    . CreateSubContextVisitor ( name )  )  ;", "}", "METHOD_END"], "methodName": ["createSubcontext"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    eventCoordinator ;", "if    (  ( eventCoordinator )     !  =    null )     {", "final   Context   context    =    Context . class . cast ( contextNode . binding . getObject (  )  )  ;", "if    ( context   instanceof   EventContext )     {", "coordinator . fireEvent ( EventContext . class . cast ( context )  ,    name ,    existingBinding ,    newBinding ,    type ,    changeInfo ,    NamingEventCoordinator . DEFAULT _ SCOPES )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["fireEvent"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   Name   nodeName    =     ( name . isEmpty (  )  )     ?    new   CompositeName (  \"  \"  )     :    name ;", "return   root . accept ( new    . ListVisitor ( nodeName )  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   Name   nodeName    =     ( name . isEmpty (  )  )     ?    new   CompositeName (  \"  \"  )     :    name ;", "return   root . accept ( new    . ListBindingsVisitor ( nodeName )  )  ;", "}", "METHOD_END"], "methodName": ["listBindings"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( NamingUtils . isEmpty ( name )  )     {", "final   Name   emptyName    =    new   CompositeName (  \"  \"  )  ;", "return   new   NamingContext ( emptyName ,    this ,    new   Hashtable < String ,    Object >  (  )  )  ;", "}", "return   root . accept ( new    . LookupVisitor ( name )  )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "rebind ( name ,    object ,    object . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( NamingUtils . isLastComponentEmpty ( name )  )     {", "throw   NamingUtils . emptyNameException (  )  ;", "}", "writeLock . lock (  )  ;", "try    {", "root . accept ( new    . RebindVisitor ( name ,    object ,    bindType . getName (  )  )  )  ;", "}    finally    {", "writeLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    eventCoordinator ;", "if    ( coordinator    !  =    null )     {", "coordinator . removeListener ( listener )  ;", "}", "}", "METHOD_END"], "methodName": ["removeNamingListener"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( NamingUtils . isLastComponentEmpty ( name )  )     {", "throw   NamingUtils . emptyNameException (  )  ;", "}", "writeLock . lock (  )  ;", "try    {", "root . accept ( new    . UnbindVisitor ( name )  )  ;", "}    finally    {", "writeLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.jboss.as.naming.InMemoryNamingStore"}, {"methodBody": ["METHOD_START", "{", "nameStore . close (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "nameStore . bind ( new   CompositeName (  \" test / item \"  )  ,    new   Object (  )  )  ;", "assertNotNull ( nameStore . lookup ( new   CompositeName (  \" test / item \"  )  )  )  ;", "assertNotNull ( nameStore . lookup ( new   CompositeName (  \" test \"  )  )  )  ;", "nameStore . unbind ( new   CompositeName (  \" test / item \"  )  )  ;", "try    {", "nameStore . lookup ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   throw   name   not   found   exception \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testAutoRemove"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "name . bind ( name ,    object ,    Object . class )  ;", "final   Object   result    =    name . lookup ( name )  ;", "assertEquals ( object ,    result )  ;", "}", "METHOD_END"], "methodName": ["testBindAndLookup"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Reference   reference    =    new   Reference ( Context . class . getName (  )  )  ;", "name . bind ( name ,    reference ,    Context . class )  ;", "final   Object   result    =    name . lookup ( new   CompositeName (  \" test / value \"  )  )  ;", "assertTrue (  ( result   instanceof   ResolveResult )  )  ;", "}", "METHOD_END"], "methodName": ["testBindAndLookupResolveResult"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "name . bind ( name ,    object ,    Object . class )  ;", "assertEquals ( object ,    name . lookup ( name )  )  ;", "final   Object   objectTwo    =    new   Object (  )  ;", "name . rebind ( name ,    objectTwo ,    Object . class )  ;", "assertEquals ( objectTwo ,    name . lookup ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testBindAndRebind"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "name . bind ( new   CompositeName (  )  ,    new   Object (  )  ,    Object . class )  ;", "fail (  \" Should   have   thrown   and   InvalidNameException \"  )  ;", "}    catch    ( InvalidNameException   expected )     {", "}", "try    {", "name . bind ( new   CompositeName (  \"  \"  )  ,    new   Object (  )  ,    Object . class )  ;", "fail (  \" Should   have   thrown   and   InvalidNameException \"  )  ;", "}    catch    ( InvalidNameException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testBindEmptyName"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "name . bind ( name ,    object ,    Object . class )  ;", "final   Object   result    =    name . lookup ( name )  ;", "assertEquals ( object ,    result )  ;", "name . unbind ( name )  ;", "try    {", "name . lookup ( name )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testBindUnbindLookup"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "nameStore . bind ( name ,    object ,    Object . class )  ;", "final   Name   nameTwo    =    new   CompositeName (  \" testTwo \"  )  ;", "final   Object   objectTwo    =    new   Object (  )  ;", "nameStore . bind ( nameTwo ,    objectTwo ,    Object . class )  ;", "final   Name   nameThree    =    new   CompositeName (  \" testThree \"  )  ;", "final   Object   objectThree    =    new   Object (  )  ;", "nameStore . bind ( nameThree ,    objectThree ,    Object . class )  ;", "nameStore . bind ( new   CompositeName (  \" testContext / test \"  )  ,     \" test \"  )  ;", "final   List < NameClassPair >    results    =    nameStore . list ( new   CompositeName (  )  )  ;", "assertEquals (  4  ,    results . size (  )  )  ;", "final   Set < String >    expected    =    new   HashSet < String >  ( Arrays . asList (  \" test \"  ,     \" testTwo \"  ,     \" testThree \"  ,     \" testContext \"  )  )  ;", "for    ( NameClassPair   result    :    results )     {", "final   String   resultName    =    result . getName (  )  ;", "if    (  (  (  \" test \"  . equals ( resultName )  )     |  |     (  \" testTwo \"  . equals ( resultName )  )  )     |  |     (  \" testThree \"  . equals ( resultName )  )  )     {", "assertEquals ( Object . class . getName (  )  ,    result . getClassName (  )  )  ;", "} else", "if    (  \" testContext \"  . equals ( resultName )  )     {", "assertEquals ( getName (  )  ,    result . getClassName (  )  )  ;", "} else    {", "fail (  (  \" Unknown   result   name :     \"     +    resultName )  )  ;", "}", "expected . remove ( resultName )  ;", "}", "assertTrue (  \" Not   all   expected   results   were   returned \"  ,    expected . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testList"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "nameStore . bind ( name ,    object )  ;", "final   Name   nameTwo    =    new   CompositeName (  \" testTwo \"  )  ;", "final   Object   objectTwo    =    new   Object (  )  ;", "nameStore . bind ( nameTwo ,    objectTwo )  ;", "final   Name   nameThree    =    new   CompositeName (  \" testThree \"  )  ;", "final   Object   objectThree    =    new   Object (  )  ;", "nameStore . bind ( nameThree ,    objectThree )  ;", "nameStore . bind ( new   CompositeName (  \" testContext / test \"  )  ,     \" test \"  )  ;", "final   List < Binding >    results    =    nameStore . listBindings ( new   CompositeName (  )  )  ;", "assertEquals (  4  ,    results . size (  )  )  ;", "final   Set < String >    expected    =    new   HashSet < String >  ( Arrays . asList (  \" test \"  ,     \" testTwo \"  ,     \" testThree \"  ,     \" testContext \"  )  )  ;", "for    ( Binding   result    :    results )     {", "final   String   resultName    =    result . getName (  )  ;", "if    (  \" test \"  . equals ( resultName )  )     {", "assertEquals ( Object . class . getName (  )  ,    result . getClassName (  )  )  ;", "assertEquals ( object ,    result . getObject (  )  )  ;", "} else", "if    (  \" testTwo \"  . equals ( resultName )  )     {", "assertEquals ( Object . class . getName (  )  ,    result . getClassName (  )  )  ;", "assertEquals ( objectTwo ,    result . getObject (  )  )  ;", "} else", "if    (  \" testThree \"  . equals ( resultName )  )     {", "assertEquals ( Object . class . getName (  )  ,    result . getClassName (  )  )  ;", "assertEquals ( objectThree ,    result . getObject (  )  )  ;", "} else", "if    (  \" testContext \"  . equals ( resultName )  )     {", "assertEquals ( getName (  )  ,    result . getClassName (  )  )  ;", "} else    {", "fail (  (  \" Unknown   result   name :     \"     +    resultName )  )  ;", "}", "expected . remove ( resultName )  ;", "}", "assertTrue (  \" Not   all   expected   results   were   returned \"  ,    expected . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testListBindings"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "name . listBindings ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testListBindingsNameNotFound"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "name . list ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testListNameNotFound"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    nameStore . lookup ( new   CompositeName (  )  )  ;", "assertTrue (  ( result   instanceof   Context )  )  ;", "result    =    nameStore . lookup ( new   CompositeName (  \"  \"  )  )  ;", "assertTrue (  ( result   instanceof   Context )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupEmptyName"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "name . lookup ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testLookupNameNotFound"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "name . rebind ( name ,    object ,    Object . class )  ;", "final   Object   result    =    name . lookup ( name )  ;", "assertEquals ( object ,    result )  ;", "}", "METHOD_END"], "methodName": ["testRebindAndLookup"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "name . rebind ( new   CompositeName (  )  ,    new   Object (  )  ,    Object . class )  ;", "fail (  \" Should   have   thrown   and   InvalidNameException \"  )  ;", "}    catch    ( InvalidNameException   expected )     {", "}", "try    {", "name . rebind ( new   CompositeName (  \"  \"  )  ,    new   Object (  )  ,    Object . class )  ;", "fail (  \" Should   have   thrown   and   InvalidNameException \"  )  ;", "}    catch    ( InvalidNameException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testRebindEmptyName"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "name . rebind ( new   CompositeName (  \" subcontext / test \"  )  ,    new   Object (  )  ,    Object . class )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testRebindInvalidContext"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "name . unbind ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testUnbindNotFound"], "fileName": "org.jboss.as.naming.InMemoryNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ObjectFactory >    factories    =    new   HashMap < String ,    ObjectFactory >  ( InitialContext . urlContextFactories )  ;", "factories . put ( scheme ,    factory )  ;", "InitialContext . urlContextFactories    =    Collections . unmodifiableMap ( factories )  ;", "}", "METHOD_END"], "methodName": ["addUrlContextFactory"], "fileName": "org.jboss.as.naming.InitialContext"}, {"methodBody": ["METHOD_START", "{", "int   colon _ posn    =    str . indexOf (  '  :  '  )  ;", "int   slash _ posn    =    str . indexOf (  '  /  '  )  ;", "if    (  ( colon _ posn    >     0  )     &  &     (  ( slash _ posn    =  =     (  -  1  )  )     |  |     ( colon _ posn    <    slash _ posn )  )  )", "return   str . substr (  0  ,    colon _ posn )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getURLScheme"], "fileName": "org.jboss.as.naming.InitialContext"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ObjectFactory >    factories    =    new   HashMap < String ,    ObjectFactory >  ( InitialContext . urlContextFactories )  ;", "ObjectFactory   f    =    factories . get ( scheme )  ;", "if    ( f    =  =    factory )     {", "factories . remove ( scheme )  ;", "InitialContext . urlContextFactories    =    Collections . unmodifiableMap ( factories )  ;", "return ;", "} else    {", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["removeUrlContextFactory"], "fileName": "org.jboss.as.naming.InitialContext"}, {"methodBody": ["METHOD_START", "{", "return   new   InitialContext ( environment )  ;", "}", "METHOD_END"], "methodName": ["getInitialContext"], "fileName": "org.jboss.as.naming.InitialContextFactory"}, {"methodBody": ["METHOD_START", "{", "return   InitialContextFactoryBuilder . DEFAULT _ FACTORY ;", "}", "METHOD_END"], "methodName": ["createInitialContextFactory"], "fileName": "org.jboss.as.naming.InitialContextFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "NamingContext . setActiveNamingStore ( new   InMemoryNamingStore (  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jboss.as.naming.InitialContextFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( Context . INITIAL _ CONTEXT _ FACTORY ,    InitialContextFactory . class . getName (  )  )  ;", "InitialContext   initialContext    =    new   InitialContext (  )  ;", "Context   context    =     (  ( Context )     ( initialContext . lookup (  \"  \"  )  )  )  ;", "assertTrue (  ( context   instanceof   NamingContext )  )  ;", "if    (  !  ( NamingManager . hasInitialContextFactoryBuilder (  )  )  )     {", "NamingManager . setInitialContextFactoryBuilder ( new   InitialContextFactoryBuilder (  )  )  ;", "}", "initialContext    =    new   InitialContext (  )  ;", "context    =     (  ( Context )     ( initialContext . lookup (  \"  \"  )  )  )  ;", "assertTrue (  ( context   instanceof   NamingContext )  )  ;", "}", "METHOD_END"], "methodName": ["testInitialFactory"], "fileName": "org.jboss.as.naming.InitialContextFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( Context . INITIAL _ CONTEXT _ FACTORY ,    InitialContextFactory . class . getName (  )  )  ;", "System . setProperty ( Context . URL _ PKG _ PREFIXES ,     \" interfaces \"  )  ;", "InitialContext   initialContext    =    new   InitialContext (  )  ;", "Context   context    =     (  ( Context )     ( initialContext . lookup (  \" java :  \"  )  )  )  ;", "assertTrue (  ( context   instanceof   NamingContext )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaContext"], "fileName": "org.jboss.as.naming.InitialContextFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "NamingContext . setActiveNamingStore ( new   InMemoryNamingStore (  )  )  ;", "}", "METHOD_END"], "methodName": ["before"], "fileName": "org.jboss.as.naming.InitialContextTestCase"}, {"methodBody": ["METHOD_START", "{", "InitialContext   ictx    =    new   InitialContext ( null )  ;", "try    {", "ictx . lookup (  \" foobar : something \"  )  ;", "Assert . fail (  \" Precondition :    the   foobar :    scheme   should   not   yet   be   registered \"  )  ;", "}    catch    ( NamingException   ne )     {", "}", "ObjectFactory   tof    =    new    . TestObjectFactory (  )  ;", "InitialContext . addUrlContextFactory (  \" foobar \"  ,    tof )  ;", "String   something    =     (  ( String )     ( ictx . lookup (  \" foobar : something \"  )  )  )  ;", "Assert . assertTrue (  \" The   object   should   now   be   provided   by   our   TestObjectFactory \"  ,    something . startsWith (  \" TestObject :  \"  )  )  ;", "try    {", "InitialContext . removeUrlContextFactory (  \" foobar :  \"  ,    new    . TestObjectFactory (  )  )  ;", "Assert . fail (  \" Should   throw   an   IllegalArgumentException   since   the   associated   factory   object   doesn ' t   match   the   registration \"  )  ;", "}    catch    ( IllegalArgumentException   iae )     {", "}", "Assert . assertEquals (  \" The   foobar :    scheme   should   still   be   registered \"  ,    something ,    ictx . lookup (  \" foobar : something \"  )  )  ;", "InitialContext . removeUrlContextFactory (  \" foobar \"  ,    tof )  ;", "try    {", "ictx . lookup (  \" foobar : something \"  )  ;", "Assert . fail (  \" The   foobar :    scheme   should   not   be   registered   any   more \"  )  ;", "}    catch    ( NamingException   ne )     {", "}", "}", "METHOD_END"], "methodName": ["testRegisterURLSchemeHandler"], "fileName": "org.jboss.as.naming.InitialContextTestCase"}, {"methodBody": ["METHOD_START", "{", "return   ServiceReferenceObjectFactory . createReference ( serviceName ,    ManagedReferenceObjectFactory . class )  ;", "}", "METHOD_END"], "methodName": ["createReference"], "fileName": "org.jboss.as.naming.ManagedReferenceObjectFactory"}, {"methodBody": ["METHOD_START", "{", "final   ManagedReferenceFactory   managedReferenceFactory    =    ManagedReferenceFactory . class . cast ( serviceValue )  ;", "return   managedReferenceFactory . getReference (  )  . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getObjectInstance"], "fileName": "org.jboss.as.naming.ManagedReferenceObjectFactory"}, {"methodBody": ["METHOD_START", "{", "addNamingListener ( parseName ( target )  ,    scope ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addNamingListener"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( target ,    JndiPermission . ACTION _ ADD _ NAMING _ LISTENER )  ;", "Store . addNamingListener ( target ,    scope ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addNamingListener"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "final   Object   existing    =    environment . get ( propName )  ;", "environment . put ( propName ,    propVal )  ;", "return   existing ;", "}", "METHOD_END"], "methodName": ["addToEnvironment"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "bind ( parseName ( name )  ,    obj )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ BIND )  ;", "if    (  ( namingStore )    instanceof   WritableNamingStore )     {", "final   Name   absoluteName    =    getAbsoluteName ( name )  ;", "final   Object   value ;", "if    ( object   instanceof   Referenceable )     {", "value    =     (  ( Referenceable )     ( object )  )  . getReference (  )  ;", "} else    {", "value    =    object ;", "}", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "getWritableNamingStore (  )  . bind ( absoluteName ,    value )  ;", "} else    {", "final   NamingException   e    =    AccessController . doPrivileged ( new   PrivilegedAction < NamingException >  (  )     {", "@ Override", "public   NamingException   run (  )     {", "try    {", "getWritableNamingStore (  )  . bind ( absoluteName ,    value )  ;", "}    catch    ( NamingException   e )     {", "return   e ;", "}", "return   null ;", "}", "}  )  ;", "if    ( e    !  =    null )     {", "throw   e ;", "}", "}", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . readOnly (  )  ;", "}", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "final   SecurityManager   sm    =    System . getSecurityManager (  )  ;", "if    (  ( sm    !  =    null )     &  &     ( WildFlySecurityManager . isChecking (  )  )  )     {", "Name   absoluteName    =     (  ( Name )    tore . getBaseName (  )  . clone (  )  )  )  ;", "if    ( name . isEmpty (  )  )     {", "absoluteName . addAll ( prefix )  ;", "} else    {", "final   String   firstComponent    =    name . get (  0  )  ;", "if    ( firstComponent . startsWith (  \" java :  \"  )  )     {", "absoluteName    =    name ;", "} else", "if    ( firstComponent . isEmpty (  )  )     {", "absoluteName . addAll ( name . getSuffix (  1  )  )  ;", "} else    {", "absoluteName . addAll ( prefix )  ;", "if    ( name   instanceof   javaxCompositeName )     {", "if    (  ( name . size (  )  )     =  =     1  )     {", "absoluteName . addAll ( parseName ( firstComponent )  )  ;", "} else    {", "absoluteName . addAll ( name )  ;", "}", "} else    {", "absoluteName . addAll ( new   javaxCompositeName ( name . toString (  )  )  )  ;", "}", "}", "}", "sm . checkPermission ( new   JndiPermission ( absoluteName . toString (  )  ,    actions )  )  ;", "}", "}", "METHOD_END"], "methodName": ["check"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   composeName ( parseName ( name )  ,    parseName ( prefix )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["composeName"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "final   Name   result    =     (  ( Name )     ( prefix . clone (  )  )  )  ;", "if    ( name   instanceof   CompositeName )     {", "if    (  ( name . size (  )  )     =  =     1  )     {", "final   String   firstComponent    =    name . get (  0  )  ;", "result . addAll ( parseName ( firstComponent )  )  ;", "} else    {", "result . addAll ( name )  ;", "}", "} else    {", "result . addAll ( new   CompositeName ( name . toString (  )  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["composeName"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   createSubcontext ( parseName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["createSubcontext"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ CREATE _ SUBCONTEXT )  ;", "if    (  ( namingStore )    instanceof   WritableNamingStore )     {", "final   Name   absoluteName    =    getAbsoluteName ( name )  ;", "return   getWritableNamingStore (  )  . createSubcontext ( absoluteName )  ;", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . readOnly (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createSubcontext"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "destroySubcontext ( parseName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["destroySubcontext"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ DESTROY _ SUBCONTEXT )  ;", "if    (  !  (  ( namingStore )    instanceof   WritableNamingStore )  )     {", "throw   NamingLogger . ROOT _ LOGGER . readOnly (  )  ;", "}", "}", "METHOD_END"], "methodName": ["destroySubcontext"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "if    ( name . isEmpty (  )  )     {", "return   composeName ( name ,    prefix )  ;", "}", "final   String   firstComponent    =    name . get (  0  )  ;", "if    ( firstComponent . startsWith (  \" java :  \"  )  )     {", "final   String   cleaned    =    firstComponent . substring (  5  )  ;", "final   Name   suffix    =    name . getSuffix (  1  )  ;", "if    ( cleaned . isEmpty (  )  )     {", "return   suffix ;", "}", "return   suffix . add (  0  ,    cleaned )  ;", "} else", "if    ( firstComponent . isEmpty (  )  )     {", "return   name . getSuffix (  1  )  ;", "} else    {", "return   composeName ( name ,    prefix )  ;", "}", "}", "METHOD_END"], "methodName": ["getAbsoluteName"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   environment ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   prefix . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getNameInNamespace"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   NameParser . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getNameParser"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   NameParser . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getNameParser"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   namingStore ;", "}", "METHOD_END"], "methodName": ["getNamingStore"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ObjectFactoryBuilder   factoryBuilder    =    ObjectFactoryBuilder . INSTANCE ;", "final   ObjectFactory   objectFactory    =    factoryBuilder . createObjectFactory ( object ,    environment )  ;", "return   objectFactory    =  =    null    ?    null    :    objectFactory . getObjectInstance ( object ,    name ,    this ,    environment )  ;", "}    catch    ( Exception   e )     {", "throw   e ;", "}    catch    ( Throwable   t )     {", "throw   Logger . ROOT _ LOGGER . cannotDeferenceObject ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["getObjectInstance"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   prefix ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   WritableNamingStore . class . cast ( getNamingStore (  )  )  ;", "}", "METHOD_END"], "methodName": ["getWritableNamingStore"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "final   String   property    =    WildFlySecurityManager . getPropertyPrivileged ( Context . URL _ PKG _ PREFIXES ,    null )  ;", "if    (  ( property    =  =    null )     |  |     ( property . isEmpty (  )  )  )     {", "WildFlySecurityManager . setPropertyPrivileged ( Context . URL _ PKG _ PREFIXES ,     . PACKAGE _ PREFIXES )  ;", "} else", "if    (  !  ( asList ( property . split (  \"  :  \"  )  )  . contains (  . PACKAGE _ PREFIXES )  )  )     {", "WildFlySecurityManager . setPropertyPrivileged ( Context . URL _ PKG _ PREFIXES ,     (  (  (  . PACKAGE _ PREFIXES )     +     \"  :  \"  )     +    property )  )  ;", "}", "try    {", "if    (  !  ( NamingManager . hasInitialContextFactoryBuilder (  )  )  )", "NamingManager . setInitialContextFactoryBuilder ( new   InitialContextFactoryBuilder (  )  )  ;", "}    catch    ( NamingException   e )     {", "NamingLogger . ROOT _ LOGGER . failedToSet ( e ,     \" InitialContextFactoryBuilder \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeNamingManager"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   list ( parseName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ LIST )  ;", "try    {", "return   NamingUtilEnumeration ( namingStore . list ( getAbsoluteName ( name )  )  )  ;", "}    catch    ( CannotProceedException   cpe )     {", "final   Context   continuationContext    =    NamingManager . getContinuationContext ( cpe )  ;", "return   continuationContext . list ( cpe . getRemainingName (  )  )  ;", "}    catch    ( RequireResolveException   r )     {", "final   Object   o    =    lookup ( r . getResolve (  )  )  ;", "if    ( o   instanceof   Context )     {", "return    (  ( Context )     ( o )  )  . list ( name . getSuffix ( r . getResolve (  )  . size (  )  )  )  ;", "}", "throw   NamingUtils . notAContextException ( r . getResolve (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   listBindings ( parseName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["listBindings"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ LIST _ BINDINGS )  ;", "try    {", "return   NamingUtilEnumeration ( namingStore . listBindings ( getAbsoluteName ( name )  )  )  ;", "}    catch    ( CannotProceedException   cpe )     {", "final   Context   continuationContext    =    NamingManager . getContinuationContext ( cpe )  ;", "return   continuationContext . listBindings ( cpe . getRemainingName (  )  )  ;", "}    catch    ( RequireResolveException   r )     {", "final   Object   o    =    lookup ( r . getResolve (  )  )  ;", "if    ( o   instanceof   Context )     {", "return    (  ( Context )     ( o )  )  . listBindings ( name . getSuffix ( r . getResolve (  )  . size (  )  )  )  ;", "}", "throw   NamingUtils . notAContextException ( r . getResolve (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["listBindings"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   lookup ( name ,    true )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   lookup ( parseName ( name )  ,    dereference )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   lookup ( name ,    true )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ LOOKUP )  ;", "if    ( NamingUtils . isEmpty ( name )  )     {", "return   new    ( prefix ,    namingStore ,    environment )  ;", "}", "final   Name   absoluteName    =    getAbsoluteName ( name )  ;", "Object   result ;", "try    {", "result    =    namingStore . lookup ( absoluteName ,    dereference )  ;", "}    catch    ( CannotProceedException   cpe )     {", "final   Context   continuationContext    =    NamingManager . getContinuationContext ( cpe )  ;", "if    ( continuationContext   instanceof    )     {", "result    =     (  (  )     ( continuationContext )  )  . lookup ( cpe . getRemainingName (  )  ,    dereference )  ;", "} else    {", "result    =    continuationContext . lookup ( cpe . getRemainingName (  )  )  ;", "}", "}", "if    ( result   instanceof   ResolveResult )     {", "final   ResolveResult   resolveResult    =     (  ( ResolveResult )     ( result )  )  ;", "final   Object   resolvedObject    =    resolveResult . getResolvedObj (  )  ;", "Object   context ;", "if    ( resolvedObject   instanceof   Context )     {", "context    =    resolvedObject ;", "} else", "if    ( resolvedObject   instanceof   LinkRef )     {", "context    =    resolveLink ( resolvedObject ,    dereference )  ;", "} else    {", "context    =    getObjectInstance ( resolvedObject ,    absoluteName ,    environment )  ;", "}", "if    (  !  ( context   instanceof   Context )  )     {", "throw   NamingUtils . notAContextException ( absoluteName . getPrefix (  (  ( absoluteName . size (  )  )     -     ( resolveResult . getRemainingName (  )  . size (  )  )  )  )  )  ;", "}", "final   Context   namingContext    =     (  ( Context )     ( context )  )  ;", "if    ( namingContext   instanceof    )     {", "return    (  (  )     ( namingContext )  )  . lookup ( resolveResult . getRemainingName (  )  ,    dereference )  ;", "} else    {", "return   namingContext . lookup ( resolveResult . getRemainingName (  )  )  ;", "}", "} else", "if    ( result   instanceof   LinkRef )     {", "result    =    resolveLink ( result ,    dereference )  ;", "} else", "if    ( result   instanceof   Reference )     {", "result    =    getObjectInstance ( result ,    absoluteName ,    environment )  ;", "if    ( result   instanceof   LinkRef )     {", "result    =    resolveLink ( result ,    dereference )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   lookupLink ( parseName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["lookupLink"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ LOOKUP )  ;", "if    ( name . isEmpty (  )  )     {", "return   lookup ( name )  ;", "}", "try    {", "final   Name   absoluteName    =    getAbsoluteName ( name )  ;", "Object   link    =    namingStore . lookup ( absoluteName )  ;", "if    (  (  !  ( link   instanceof   LinkRef )  )     &  &     ( link   instanceof   Reference )  )     {", "link    =    getObjectInstance ( link ,    name ,    null )  ;", "}", "return   link ;", "}    catch    ( Exception   e )     {", "throw   NamingUtilException ( NamingLogger . ROOT _ LOGGER . cannotLookupLink (  )  ,    e ,    name )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupLink"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   getNameParser ( name )  . parse ( name )  ;", "}", "METHOD_END"], "methodName": ["parseName"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "rebind ( parseName ( name )  ,    object )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ REBIND )  ;", "if    (  ( namingStore )    instanceof   WritableNamingStore )     {", "final   Name   absoluteName    =    getAbsoluteName ( name )  ;", "if    ( object   instanceof   Referenceable )     {", "object    =     (  ( Referenceable )     ( object )  )  . getReference (  )  ;", "}", "getWritableNamingStore (  )  . rebind ( absoluteName ,    object )  ;", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . readOnly (  )  ;", "}", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   environment . remove ( propName )  ;", "}", "METHOD_END"], "methodName": ["removeFromEnvironment"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "namingStore . removeNamingListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeNamingListener"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "rename ( parseName ( oldName )  ,    parseName ( newName )  )  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( oldName ,     (  ( JndiPermission . ACTION _ LOOKUP )     |     ( JndiPermission . ACTION _ UNBIND )  )  )  ;", "check ( newName ,    JndiPermission . ACTION _ BIND )  ;", "if    (  ( namingStore )    instanceof   WritableNamingStore )     {", "bind ( newName ,    lookup ( oldName )  )  ;", "unbind ( oldName )  ;", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . readOnly (  )  ;", "}", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "final   Object   linkResult ;", "try    {", "final   LinkRef   linkRef    =     (  ( LinkRef )     ( result )  )  ;", "final   String   referenceName    =    linkRef . getLinkName (  )  ;", "if    ( referenceName . startsWith (  \"  .  /  \"  )  )     {", "linkResult    =    lookup ( parseName ( referenceName . substring (  2  )  )  ,    dereference )  ;", "} else    {", "linkResult    =    new   Initial (  )  . lookup ( referenceName )  ;", "}", "}    catch    ( Throwable   t )     {", "throw   NamingLogger . ROOT _ LOGGER . cannotDeferenceObject ( t )  ;", "}", "return   linkResult ;", "}", "METHOD_END"], "methodName": ["resolveLink"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "System . getSecurityManager (  )  . checkPermission (  . SET _ ACTIVE _ NAMING _ STORE )  ;", "}", ". ACTIVE _ NAMING _ STORE    =    namingStore ;", "}", "METHOD_END"], "methodName": ["setActiveNamingStore"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["targetMustExist"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "unbind ( parseName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "check ( name ,    JndiPermission . ACTION _ UNBIND )  ;", "if    (  ( namingStore )    instanceof   WritableNamingStore )     {", "final   Name   absoluteName    =    getAbsoluteName ( name )  ;", "getWritableNamingStore (  )  . unbind ( absoluteName )  ;", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . readOnly (  )  ;", "}", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.jboss.as.naming.NamingContext"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "namingStore . bind ( name ,    object )  ;", "final   Name   nameTwo    =    new   CompositeName (  \" testTwo \"  )  ;", "final   Object   objectTwo    =    new   Object (  )  ;", "namingStore . bind ( nameTwo ,    objectTwo )  ;", "final   Name   nameThree    =    new   CompositeName (  \" testThree \"  )  ;", "final   Object   objectThree    =    new   Object (  )  ;", "namingStore . bind ( nameThree ,    objectThree )  ;", "namingStore . bind ( new   CompositeName (  \" test / test \"  )  ,     \" testNested \"  )  ;", "}", "METHOD_END"], "methodName": ["bindList"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test / test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "namingStore . bind ( name ,    object )  ;", "final   Name   nameTwo    =    new   CompositeName (  \" test / testTwo \"  )  ;", "final   Object   objectTwo    =    new   Object (  )  ;", "namingStore . bind ( nameTwo ,    objectTwo )  ;", "final   Name   nameThree    =    new   CompositeName (  \" test / testThree \"  )  ;", "final   Object   objectThree    =    new   Object (  )  ;", "namingStore . bind ( nameThree ,    objectThree )  ;", "final   Reference   reference    =    new   Reference ( String . class . getName (  )  ,    new   StringRefAddr (  \" nns \"  ,     \" test \"  )  ,     . TestObjectFactoryWithNameResolution . class . getName (  )  ,    null )  ;", "namingStore . bind ( new   CompositeName (  \" comp \"  )  ,    reference )  ;", "}", "METHOD_END"], "methodName": ["bindListWithContinuations"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    expected    =    new   HashSet < String >  ( Arrays . asList (  \" test \"  ,     \" testTwo \"  ,     \" testThree \"  ,     \" testContext \"  )  )  ;", "while    ( results . hasMore (  )  )     {", "NameClassPair   result    =    results . next (  )  ;", "final   String   resultName    =    result . getName (  )  ;", "if    (  (  (  \" test \"  . equals ( resultName )  )     |  |     (  \" testTwo \"  . equals ( resultName )  )  )     |  |     (  \" testThree \"  . equals ( resultName )  )  )     {", "assertEquals ( Object . class . getName (  )  ,    result . getClassName (  )  )  ;", "} else", "if    (  \" testContext \"  . equals ( resultName )  )     {", "assertEquals ( getName (  )  ,    result . getClassName (  )  )  ;", "} else    {", "fail (  (  \" Unknown   result   name :     \"     +    resultName )  )  ;", "}", "expected . remove ( resultName )  ;", "}", "assertTrue (  \" Not   all   expected   results   were   returned \"  ,    expected . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkListResults"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    expected    =    new   HashSet < String >  ( Arrays . asList (  \" test \"  ,     \" testTwo \"  ,     \" testThree \"  )  )  ;", "while    ( results . hasMore (  )  )     {", "NameClassPair   result    =    results . next (  )  ;", "final   String   resultName    =    result . getName (  )  ;", "if    (  (  (  \" test \"  . equals ( resultName )  )     |  |     (  \" testTwo \"  . equals ( resultName )  )  )     |  |     (  \" testThree \"  . equals ( resultName )  )  )     {", "assertEquals ( Object . class . getName (  )  ,    result . getClassName (  )  )  ;", "} else    {", "fail (  (  \" Unknown   result   name :     \"     +    resultName )  )  ;", "}", "expected . remove ( resultName )  ;", "}", "assertTrue (  \" Not   all   expected   results   were   returned \"  ,    expected . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkListWithContinuationsResults"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "namingStore . close (  )  ;", ". setActiveNamingStore ( new   InMemoryNamingStore (  )  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "namingStore    =    new   InMemoryNamingStore (  )  ;", ". setActiveNamingStore ( namingStore )  ;", "namingContext    =    new    ( namingStore ,    null )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "NamingContext . initializeNamingManager (  )  ;", "}", "METHOD_END"], "methodName": ["setupObjectFactoryBuilder"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "n . bind ( name ,    value )  ;", "assertEquals ( value ,    namingStore . lookup ( name )  )  ;", "name    =    new   CompositeName (  \" securitytest \"  )  ;", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ BIND ,    n ,     \" securitytest \"  ,    value )  ;", "assertEquals ( value ,    namingStore . lookup ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testBind"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "Name   name    =    new   CompositeName (  \" test \"  )  ;", "final    . TestObjectReferenceable   referenceable    =    new    . TestObjectReferenceable (  \" addr \"  )  ;", "namingContext . bind ( name ,    referenceable )  ;", "Object   result    =    namingContext . lookup ( name )  ;", "assertEquals ( referenceable . addr ,    result )  ;", "name    =    new   CompositeName (  \" securitytest \"  )  ;", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ BIND ,    namingContext ,     \" securitytest \"  ,    referenceable )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    namingContext ,     \" securitytest \"  )  ;", "assertEquals ( referenceable . addr ,    result )  ;", "}", "METHOD_END"], "methodName": ["testBindReferenceable"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( namingContext . createSubcontext ( new   CompositeName (  \" test \"  )  )  )    instanceof   NamingContext )  )  ;", "assertTrue (  (  ( SecurityHelper . testActionPermission ( JndiPermission . ACTION _ CREATE _ SUBCONTEXT ,    namingContext ,     \" securitytest \"  )  )    instanceof   NamingContext )  )  ;", "}", "METHOD_END"], "methodName": ["testCreateSubcontext"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "bindList (  )  ;", "NamingEnumeration < NameClassPair >    results    =    n . list ( new   CompositeName (  )  )  ;", "checkListResults ( results )  ;", "results    =     (  ( NamingEnumeration < NameClassPair >  )     ( SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LIST ,    n ,    null )  )  )  ;", "checkListResults ( results )  ;", "}", "METHOD_END"], "methodName": ["testList"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "bindList (  )  ;", "NamingEnumeration < Binding >    results    =    n . listBindings ( new   CompositeName (  )  )  ;", "checkListResults ( results )  ;", "results    =     (  ( NamingEnumeration < Binding >  )     ( SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LIST _ BINDINGS ,    n ,    null )  )  )  ;", "checkListResults ( results )  ;", "}", "METHOD_END"], "methodName": ["testListBindings"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "n . listBindings ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "try    {", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LIST _ BINDINGS ,    n ,     \" test \"  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException   with   appropriate   permissions \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testListBindingsNameNotFound"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "bindListWithContinuations (  )  ;", "NamingEnumeration < Binding >    results    =    n . listBindings ( new   CompositeName (  \" comp \"  )  )  ;", "checkListWithContinuationsResults ( results )  ;", "results    =     (  ( NamingEnumeration < Binding >  )     ( SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LIST _ BINDINGS ,    Arrays . asList ( new   JndiPermission (  \" test \"  ,     \" listBindings \"  )  )  ,    n ,     \" comp \"  )  )  )  ;", "checkListWithContinuationsResults ( results )  ;", "}", "METHOD_END"], "methodName": ["testListBindingsWithContinuation"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "n . list ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "try    {", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LIST ,    n ,     \" test \"  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException   with   appropriate   permissions \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testListNameNotFound"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "bindListWithContinuations (  )  ;", "NamingEnumeration < NameClassPair >    results    =    n . list ( new   CompositeName (  \" comp \"  )  )  ;", "checkListWithContinuationsResults ( results )  ;", "results    =     (  ( NamingEnumeration < NameClassPair >  )     ( SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LIST ,    Arrays . asList ( new   JndiPermission (  \" test \"  ,     \" list \"  )  )  ,    n ,     \" comp \"  )  )  )  ;", "checkListWithContinuationsResults ( results )  ;", "}", "METHOD_END"], "methodName": ["testListWithContinuation"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   object    =    new   Object (  )  ;", "namingStore . bind ( name ,    object )  ;", "Object   result    =    n . lookup ( name )  ;", "assertEquals ( object ,    result )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    n ,     \" test \"  )  ;", "assertEquals ( object ,    result )  ;", "}", "METHOD_END"], "methodName": ["testLookup"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test / value \"  )  ;", "namingStore . bind ( name ,     \" testValue \"  )  ;", "final   Name   linkName    =    new   CompositeName (  \" link \"  )  ;", "namingStore . bind ( linkName ,    new   LinkRef (  \"  .  / test \"  )  )  ;", "Object   result    =    n . lookup (  \" link / value \"  )  ;", "assertEquals (  \" testValue \"  ,    result )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    Arrays . asList ( new   JndiPermission (  \" test \"  ,     \" lookup \"  )  ,    new   JndiPermission (  \" test / value \"  ,     \" lookup \"  )  )  ,    n ,     \" link / value \"  )  ;", "assertEquals (  \" testValue \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testLookupContextLink"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    namingContext . lookup ( new   CompositeName (  )  )  ;", "assertTrue (  ( result   instanceof    )  )  ;", "result    =    namingContext . lookup ( new   CompositeName (  \"  \"  )  )  ;", "assertTrue (  ( result   instanceof    )  )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    namingContext ,    null )  ;", "assertTrue (  ( result   instanceof    )  )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    namingContext ,     \"  \"  )  ;", "assertTrue (  ( result   instanceof    )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupEmptyName"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "namingStore . bind ( name ,     \" testValue \"  ,    String . class )  ;", "final   Name   linkName    =    new   CompositeName (  \" link \"  )  ;", "namingStore . bind ( linkName ,    new   LinkRef (  \"  .  / test \"  )  )  ;", "Object   result    =    n . lookup ( linkName )  ;", "assertEquals (  \" testValue \"  ,    result )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    Arrays . asList ( new   JndiPermission (  \" test \"  ,     \" lookup \"  )  )  ,    n ,     \" link \"  )  ;", "assertEquals (  \" testValue \"  ,    result )  ;", "System . setProperty ( Context . INITIAL _ CONTEXT _ FACTORY ,    InitialContextFactory . class . getName (  )  )  ;", "namingStore . rebind ( linkName ,    new   LinkRef ( name )  )  ;", "result    =    n . lookup ( linkName )  ;", "assertEquals (  \" testValue \"  ,    result )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    Arrays . asList ( new   JndiPermission (  \" test \"  ,     \" lookup \"  )  )  ,    n ,     \" link \"  )  ;", "assertEquals (  \" testValue \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testLookupLink"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "n . lookup ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "try    {", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    n ,     \" test \"  )  ;", "fail (  \" Should   have   thrown   and   NameNotFoundException   with   appropriate   permissions \"  )  ;", "}    catch    ( NameNotFoundException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testLookupNameNotFound"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Reference   reference    =    new   Reference ( String . class . getName (  )  ,    new   StringRefAddr (  \" blah \"  ,     \" test \"  )  ,     . TestObjectFactory . class . getName (  )  ,    null )  ;", "namingStore . bind ( name ,    reference )  ;", "Object   result    =    namingContext . lookup ( name )  ;", "assertEquals (  \" test \"  ,    result )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    namingContext ,     \" test \"  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testLookupReference"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "namingStore . bind ( new   CompositeName (  \" test / nested \"  )  ,     \" test \"  )  ;", "final   Reference   reference    =    new   Reference ( String . class . getName (  )  ,    new   StringRefAddr (  \" blahh \"  ,     \" test \"  )  ,     . TestObjectFactoryWithNameResolution . class . getName (  )  ,    null )  ;", "namingStore . bind ( new   CompositeName (  \" comp \"  )  ,    reference )  ;", "Object   result    =    namingContext . lookup ( new   CompositeName (  \" comp / nested \"  )  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    Arrays . asList ( new   JndiPermission (  \" test / nested \"  ,     \" lookup \"  )  )  ,    namingContext ,     \" comp / nested \"  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testLookupWitResolveResult"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "namingStore . bind ( new   CompositeName (  \" comp / nested \"  )  ,     \" test \"  )  ;", "final   Reference   reference    =    new   Reference ( String . class . getName (  )  ,    new   StringRefAddr (  \" nns \"  ,     \" comp \"  )  ,     . TestObjectFactoryWithNameResolution . class . getName (  )  ,    null )  ;", "namingStore . bind ( new   CompositeName (  \" test \"  )  ,    reference )  ;", "Object   result    =    namingContext . lookup ( new   CompositeName (  \" test / nested \"  )  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "result    =    SecurityHelper . testActionPermission ( JndiPermission . ACTION _ LOOKUP ,    Arrays . asList ( new   JndiPermission (  \" comp / nested \"  ,     \" lookup \"  )  )  ,    namingContext ,     \" test / nested \"  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithContinuation"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "namingStore . bind ( name ,    value )  ;", "Object   newValue    =    new   Object (  )  ;", "n . rebind ( name ,    newValue )  ;", "assertEquals ( newValue ,    namingStore . lookup ( name )  )  ;", "newValue    =    new   Object (  )  ;", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ REBIND ,    n ,     \" test \"  ,    newValue )  ;", "assertEquals ( newValue ,    namingStore . lookup ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testRebind"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final    . TestObjectReferenceable   referenceable    =    new    . TestObjectReferenceable (  \" addr \"  )  ;", "namingContext . bind ( name ,    referenceable )  ;", ". TestObjectReferenceable   newReferenceable    =    new    . TestObjectReferenceable (  \" newAddr \"  )  ;", "namingContext . rebind ( name ,    newReferenceable )  ;", "Object   result    =    namingContext . lookup ( name )  ;", "assertEquals ( newReferenceable . addr ,    result )  ;", "newReferenceable    =    new    . TestObjectReferenceable (  \" yetAnotherNewAddr \"  )  ;", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ REBIND ,    namingContext ,     \" test \"  ,    newReferenceable )  ;", "result    =    namingContext . lookup ( name )  ;", "assertEquals ( newReferenceable . addr ,    result )  ;", "}", "METHOD_END"], "methodName": ["testRebindReferenceable"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "namingStore . bind ( name ,    value )  ;", "n . unbind ( name )  ;", "try    {", "namingStore . lookup ( name )  ;", "fail (  \" Should   have   thrown   name   not   found \"  )  ;", "}    catch    ( NameNotFoundException   expect )     {", "}", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ BIND ,    n ,     \" test \"  ,    value )  ;", "SecurityHelper . testActionPermission ( JndiPermission . ACTION _ UNBIND ,    n ,     \" test \"  )  ;", "try    {", "namingStore . lookup ( name )  ;", "fail (  \" Should   have   thrown   name   not   found \"  )  ;", "}    catch    ( NameNotFoundException   expect )     {", "}", "}", "METHOD_END"], "methodName": ["testUnbind"], "fileName": "org.jboss.as.naming.NamingContextTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator . TargetScope   targetScope    =    new   NamingEventCoordinator . TargetScope ( target ,    scope )  ;", "NamingEventCoordinator . ListenerHolder   holder    =    holdersByListener . get ( namingListener )  ;", "if    ( holder    =  =    null )     {", "holder    =    new   NamingEventCoordinator . ListenerHolder ( namingListener ,    targetScope )  ;", "final   Map < NamingListener ,    NamingEventCoordinator . ListenerHolder >    byListenerCopy    =    new   FastCopyHashMap < NamingListener ,    NamingEventCoordinator . ListenerHolder >  ( holdersByListener )  ;", "byListenerCopy . put ( namingListener ,    holder )  ;", "holdersByListener    =    byListenerCopy ;", "} else    {", "holder . addTarget ( targetScope )  ;", "}", "List < NamingEventCoordinator . ListenerHolder >    holdersForTarget    =    holdersByTarget . get ( targetScope )  ;", "if    ( holdersForTarget    =  =    null )     {", "holdersForTarget    =    new   CopyOnWriteArrayList < NamingEventCoordinator . ListenerHolder >  (  )  ;", "final   Map < NamingEventCoordinator . TargetScope ,    List < NamingEventCoordinator . ListenerHolder >  >    byTargetCopy    =    new   FastCopyHashMap < NamingEventCoordinator . TargetScope ,    List < NamingEventCoordinator . ListenerHolder >  >  ( holdersByTarget )  ;", "byTargetCopy . put ( targetScope ,    holdersForTarget )  ;", "holdersByTarget    =    byTargetCopy ;", "}", "holdersForTarget . add ( holder )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.jboss.as.naming.NamingEventCoordinator"}, {"methodBody": ["METHOD_START", "{", "final   String   target    =    name . toString (  )  ;", "final   Set < Integer >    scopeSet    =    new   HashSet < Integer >  ( Arrays . asList ( scopes )  )  ;", "final   NamingEvent   event    =    new   NamingEvent ( context ,    type ,    newBinding ,    existingBinding ,    changeInfo )  ;", "final   Set <  . ListenerHolder >    holdersToFire    =    new   HashSet <  . ListenerHolder >  (  )  ;", "if    ( scopeSet . contains ( EventContext . OBJECT _ SCOPE )  )     {", "final    . TargetScope   targetScope    =    new    . TargetScope ( target ,    EventContext . OBJECT _ SCOPE )  ;", "final   List <  . ListenerHolder >    holders    =    holdersByTarget . get ( targetScope )  ;", "if    ( holders    !  =    null )     {", "for    (  . ListenerHolder   holder    :    holders )     {", "holdersToFire . add ( holder )  ;", "}", "}", "}", "if    (  ( scopeSet . contains ( EventContext . ONELEVEL _ SCOPE )  )     &  &     (  !  ( name . isEmpty (  )  )  )  )     {", "final    . TargetScope   targetScope    =    new    . TargetScope ( name . getPrefix (  (  ( name . size (  )  )     -     1  )  )  . toString (  )  ,    EventContext . ONELEVEL _ SCOPE )  ;", "final   List <  . ListenerHolder >    holders    =    holdersByTarget . get ( targetScope )  ;", "if    ( holders    !  =    null )     {", "for    (  . ListenerHolder   holder    :    holders )     {", "holdersToFire . add ( holder )  ;", "}", "}", "}", "if    (  ( scopeSet . contains ( EventContext . SUBTREE _ SCOPE )  )     &  &     (  !  ( name . isEmpty (  )  )  )  )     {", "for    ( int   i    =     1  ;    i    <     ( name . size (  )  )  ;    i +  +  )     {", "final   Name   parentName    =    name . getPrefix ( i )  ;", "final    . TargetScope   targetScope    =    new    . TargetScope ( parentName . toString (  )  ,    EventContext . SUBTREE _ SCOPE )  ;", "final   List <  . ListenerHolder >    holders    =    holdersByTarget . get ( targetScope )  ;", "if    ( holders    !  =    null )     {", "for    (  . ListenerHolder   holder    :    holders )     {", "holdersToFire . add ( holder )  ;", "}", "}", "}", "}", "executor . execute ( new    . FireEventTask ( holdersToFire ,    event )  )  ;", "}", "METHOD_END"], "methodName": ["fireEvent"], "fileName": "org.jboss.as.naming.NamingEventCoordinator"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator . ListenerHolder   holder    =    holdersByListener . get ( namingListener )  ;", "if    ( holder    =  =    null )     {", "return ;", "}", "final   Map < NamingListener ,    NamingEventCoordinator . ListenerHolder >    byListenerCopy    =    new   FastCopyHashMap < NamingListener ,    NamingEventCoordinator . ListenerHolder >  ( holdersByListener )  ;", "byListenerCopy . remove ( namingListener )  ;", "holdersByListener    =    byListenerCopy ;", "final   Map < NamingEventCoordinator . TargetScope ,    List < NamingEventCoordinator . ListenerHolder >  >    byTargetCopy    =    new   FastCopyHashMap < NamingEventCoordinator . TargetScope ,    List < NamingEventCoordinator . ListenerHolder >  >  ( holdersByTarget )  ;", "for    ( NamingEventCoordinator . TargetScope   targetScope    :    holder . targets )     {", "final   List < NamingEventCoordinator . ListenerHolder >    holders    =    holdersByTarget . get ( targetScope )  ;", "holders . remove ( holder )  ;", "if    ( holders . isEmpty (  )  )     {", "byTargetCopy . remove ( targetScope )  ;", "}", "}", "holdersByTarget    =    byTargetCopy ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "org.jboss.as.naming.NamingEventCoordinator"}, {"methodBody": ["METHOD_START", "{", "NamingContext . setActiveNamingStore ( new   InMemoryNamingStore (  )  )  ;", "context    =    new   NamingContext ( null )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.jboss.as.naming.NamingEventCoordinatorTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    new   NamingEventCoordinator (  )  ;", "final    . CollectingListener   objectListener    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" test / path \"  ,    EventContext . OBJECT _ SCOPE ,    objectListener )  ;", "final    . CollectingListener   subtreeListener    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . SUBTREE _ SCOPE ,    subtreeListener )  ;", "final    . CollectingListener   oneLevelListener    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . ONELEVEL _ SCOPE ,    oneLevelListener )  ;", "coordinator . fireEvent ( context ,    new   CompositeName (  \" test / path \"  )  ,    null ,    null ,    NamingEvent . OBJECT _ ADDED ,     \" bind \"  ,    EventContext . OBJECT _ SCOPE ,    EventContext . ONELEVEL _ SCOPE ,    EventContext . SUBTREE _ SCOPE )  ;", "objectListener . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "oneLevelListener . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "subtreeListener . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "assertEquals (  1  ,    objectListener . capturedEvents . size (  )  )  ;", "assertEquals (  1  ,    subtreeListener . capturedEvents . size (  )  )  ;", "assertEquals (  1  ,    oneLevelListener . capturedEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFireAllEvent"], "fileName": "org.jboss.as.naming.NamingEventCoordinatorTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    new   NamingEventCoordinator (  )  ;", "final    . CollectingListener   subtreeListener    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" foo \"  ,    EventContext . SUBTREE _ SCOPE ,    subtreeListener )  ;", "final    . CollectingListener   subtreeListenerTwo    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" foo / bar \"  ,    EventContext . SUBTREE _ SCOPE ,    subtreeListenerTwo )  ;", "final    . CollectingListener   subtreeListenerThree    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" foo / bar / baz \"  ,    EventContext . SUBTREE _ SCOPE ,    subtreeListenerThree )  ;", "coordinator . fireEvent ( context ,    new   CompositeName (  \" foo / bar / baz / boo \"  )  ,    null ,    null ,    NamingEvent . OBJECT _ ADDED ,     \" bind \"  ,    EventContext . OBJECT _ SCOPE ,    EventContext . ONELEVEL _ SCOPE ,    EventContext . SUBTREE _ SCOPE )  ;", "subtreeListener . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "subtreeListenerTwo . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "subtreeListenerThree . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "assertEquals (  1  ,    subtreeListener . capturedEvents . size (  )  )  ;", "assertEquals (  1  ,    subtreeListenerTwo . capturedEvents . size (  )  )  ;", "assertEquals (  1  ,    subtreeListenerThree . capturedEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFireMultiLevelEvent"], "fileName": "org.jboss.as.naming.NamingEventCoordinatorTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    new   NamingEventCoordinator (  )  ;", "final    . CollectingListener   objectListener    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" test / path \"  ,    EventContext . OBJECT _ SCOPE ,    objectListener )  ;", "final    . CollectingListener   subtreeListener    =    new    . CollectingListener (  0  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . SUBTREE _ SCOPE ,    subtreeListener )  ;", "final    . CollectingListener   oneLevelListener    =    new    . CollectingListener (  0  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . ONELEVEL _ SCOPE ,    oneLevelListener )  ;", "coordinator . fireEvent ( context ,    new   CompositeName (  \" test / path \"  )  ,    null ,    null ,    NamingEvent . OBJECT _ ADDED ,     \" bind \"  ,    EventContext . OBJECT _ SCOPE )  ;", "objectListener . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "assertEquals (  1  ,    objectListener . capturedEvents . size (  )  )  ;", "assertTrue ( oneLevelListener . capturedEvents . isEmpty (  )  )  ;", "assertTrue ( subtreeListener . capturedEvents . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFireObjectEvent"], "fileName": "org.jboss.as.naming.NamingEventCoordinatorTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    new   NamingEventCoordinator (  )  ;", "final    . CollectingListener   objectListener    =    new    . CollectingListener (  0  )  ;", "coordinator . addListener (  \" test / path \"  ,    EventContext . OBJECT _ SCOPE ,    objectListener )  ;", "final    . CollectingListener   subtreeListener    =    new    . CollectingListener (  0  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . SUBTREE _ SCOPE ,    subtreeListener )  ;", "final    . CollectingListener   oneLevelListener    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . ONELEVEL _ SCOPE ,    oneLevelListener )  ;", "coordinator . fireEvent ( context ,    new   CompositeName (  \" test / path \"  )  ,    null ,    null ,    NamingEvent . OBJECT _ ADDED ,     \" bind \"  ,    EventContext . ONELEVEL _ SCOPE )  ;", "oneLevelListener . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "assertTrue ( objectListener . capturedEvents . isEmpty (  )  )  ;", "assertTrue ( subtreeListener . capturedEvents . isEmpty (  )  )  ;", "assertEquals (  1  ,    oneLevelListener . capturedEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFireOneLevelEvent"], "fileName": "org.jboss.as.naming.NamingEventCoordinatorTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingEventCoordinator   coordinator    =    new   NamingEventCoordinator (  )  ;", "final    . CollectingListener   objectListener    =    new    . CollectingListener (  0  )  ;", "coordinator . addListener (  \" test / path \"  ,    EventContext . OBJECT _ SCOPE ,    objectListener )  ;", "final    . CollectingListener   subtreeListener    =    new    . CollectingListener (  1  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . SUBTREE _ SCOPE ,    subtreeListener )  ;", "final    . CollectingListener   oneLevelListener    =    new    . CollectingListener (  0  )  ;", "coordinator . addListener (  \" test \"  ,    EventContext . ONELEVEL _ SCOPE ,    oneLevelListener )  ;", "coordinator . fireEvent ( context ,    new   CompositeName (  \" test / path \"  )  ,    null ,    null ,    NamingEvent . OBJECT _ ADDED ,     \" bind \"  ,    EventContext . SUBTREE _ SCOPE )  ;", "subtreeListener . latch . await (  1  ,    TimeUnit . SECONDS )  ;", "assertTrue ( objectListener . capturedEvents . isEmpty (  )  )  ;", "assertTrue ( oneLevelListener . capturedEvents . isEmpty (  )  )  ;", "assertEquals (  1  ,    subtreeListener . capturedEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFireSubTreeEvent"], "fileName": "org.jboss.as.naming.NamingEventCoordinatorTestCase"}, {"methodBody": ["METHOD_START", "{", "NamingContext . setActiveNamingStore ( new   InMemoryNamingStore (  )  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.jboss.as.naming.ObjectFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "NamingContext . initializeNamingManager (  )  ;", "}", "METHOD_END"], "methodName": ["initNamingManager"], "fileName": "org.jboss.as.naming.ObjectFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "namingStore    =    new   InMemoryNamingStore (  )  ;", "NamingContext . setActiveNamingStore ( namingStore )  ;", "namingContext    =    new   NamingContext ( namingStore ,    null )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.jboss.as.naming.ObjectFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Reference   reference    =    new   Reference (  \" String \"  ,    ObjectFactoryTestCase . TestObjectFactory . class . getName (  )  ,    null )  ;", "namingStore . bind ( new   CompositeName (  \" test \"  )  ,    reference )  ;", "final   InitialContext   initialContext    =    new   InitialContext (  )  ;", "final   Object   result    =    initialContext . lookup (  \" test \"  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" Test   ParsedResult \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testBindAndRetrieveObjectFactoryFromInitialContext"], "fileName": "org.jboss.as.naming.ObjectFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Reference   reference    =    new   Reference (  \" String \"  ,    ObjectFactoryTestCase . TestObjectFactory . class . getName (  )  ,    null )  ;", "namingStore . bind ( new   CompositeName (  \" test \"  )  ,    reference )  ;", "final   Object   result    =    namingContext . lookup (  \" test \"  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" Test   ParsedResult \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testBindAndRetrieveObjectFactoryFromNamingContext"], "fileName": "org.jboss.as.naming.ObjectFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "return   resolve ;", "}", "METHOD_END"], "methodName": ["getResolve"], "fileName": "org.jboss.as.naming.RequireResolveException"}, {"methodBody": ["METHOD_START", "{", "CodeSource   src    =    new   CodeSource ( null ,     (  ( Certificate [  ]  )     ( null )  )  )  ;", "Permissions   ms    =    new   Permissions (  )  ;", "for    ( JndiPermission   p    :    jndiPermissions )     {", "ms . add ( p )  ;", "}", "ProtectionDomain   domain    =    new   ProtectionDomain ( src ,    ms )  ;", "AccessControlContext   ctx    =    new   AccessControlContext ( new   ProtectionDomain [  ]  {    domain    }  )  ;", "return   ctx ;", "}", "METHOD_END"], "methodName": ["getSecurityContextForJNDILookup"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "return    (  ~ action )     &     ( JndiPermission . ACTION _ ALL )  ;", "}", "METHOD_END"], "methodName": ["not"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "switch    ( action )     {", "case   JndiPermission . ACTION _ BIND    :", "if    (  ( params . length )     =  =     1  )     {", "Context . bind ( name ,    params [  0  ]  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Invalid   number   of   arguments   passed   to   bind (  )  \"  )  ;", "}", "return   null ;", "case   JndiPermission . ACTION _ CREATE _ SUBCONTEXT    :", "return   Context . createSubcontext ( name )  ;", "case   JndiPermission . ACTION _ LIST    :", "return   Context . list ( name )  ;", "case   JndiPermission . ACTION _ LIST _ BINDINGS    :", "return   Context . listBindings ( name )  ;", "case   JndiPermission . ACTION _ LOOKUP    :", "if    (  ( params . length )     =  =     0  )     {", "return   Context . lookup ( name )  ;", "} else", "if    (  ( params . length )     =  =     1  )     {", "return   Context . lookup ( name ,     (  ( Boolean )     ( params [  0  ]  )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Invalid   number   of   arguments   passed   to   lookup (  )  \"  )  ;", "}", "case   JndiPermission . ACTION _ REBIND    :", "if    (  ( params . length )     =  =     1  )     {", "Context . rebind ( name ,    params [  0  ]  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Invalid   number   of   arguments   passed   to   rebind (  )  \"  )  ;", "}", "return   null ;", "case   JndiPermission . ACTION _ UNBIND    :", "Context . unbind ( name )  ;", "return   null ;", "default    :", "throw   new   IllegalArgumentException (  (  (  \" Action    \"     +    action )     +     \"    not   supported   by   the   generic   testActionPermission   test \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["performAction"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "Policy   previousPolicy    =    Policy . getPolicy (  )  ;", "Manager   previousSM    =    System . getManager (  )  ;", "Policy . setPolicy ( new   Policy (  )     {", "@ Override", "public   boolean   implies ( ProtectionDomain   domain ,    Permission   permission )     {", "return   true ;", "}", "}  )  ;", "System . setManager ( new   Manager (  )  )  ;", "try    {", "return   AccessController . doPrivileged ( new   PrivilegedExceptionAction < T >  (  )     {", "@ Override", "public   T   run (  )    throws   Exception    {", "return   action . call (  )  ;", "}", "}  ,    securityContext )  ;", "}    catch    ( PrivilegedActionException   e )     {", "throw   e . getException (  )  ;", "}    finally    {", "System . setManager ( previousSM )  ;", "Policy . setPolicy ( previousPolicy )  ;", "}", "}", "METHOD_END"], "methodName": ["runWithSecurityManager"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "Exception   positiveTestCaseException    =    null ;", "try    {", "return    . testActionWithPermission ( action ,    additionalRequiredPerms ,    namingContext ,    name ,    params )  ;", "}    catch    ( Exception   e )     {", "positiveTestCaseException    =    e ;", "return   null ;", "}    finally    {", "try    {", ". testActionWithoutPermission ( action ,    additionalRequiredPerms ,    namingContext ,    name ,    params )  ;", "}    catch    ( Exception   e )     {", "if    ( positiveTestCaseException    =  =    null )     {", "throw   e ;", "} else    {", "throw   new   Exception (  (  (  (  (  (  (  (  (  (  \" Both   positive   and   negative   permission   test   for   JNDI   action    \"     +    action )     +     \"    failed .    The   negative   test   case    ( which   should   have   resulted   in   a   security   exception )  \"  )     +     \"    failed   with   a   message :     \"  )     +     \"  (  \"  )     +     ( e . getClass (  )  . getName (  )  )  )     +     \"  )  :     \"  )     +     ( e . getMessage (  )  )  )     +     \"  .    The   exception   of   the   positive   testcase \"  )     +     \"    is   set   up   as   the   cause   of   this   exception .  \"  )  ,    positiveTestCaseException )  ;", "}", "}", "if    ( positiveTestCaseException    !  =    null )     {", "throw   positiveTestCaseException ;", "}", "}", "}", "METHOD_END"], "methodName": ["testActionPermission"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "return   SecurityHelper . testActionPermission ( action ,    Collections .  < JndiPermission > emptyList (  )  ,    namingContext ,    name ,    params )  ;", "}", "METHOD_END"], "methodName": ["testActionPermission"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "final   CompositeName   n    =     ( name    =  =    null )     ?    new   CompositeName (  )     :    new   CompositeName ( name )  ;", "final   String   sn    =     ( name    =  =    null )     ?     \"  \"     :    name ;", "ArrayList < JndiPermission >    allPerms    =    new   ArrayList < JndiPermission >  ( additionalRequiredPerms )  ;", "allPerms . add ( new   JndiPermission ( sn ,    action )  )  ;", "return    . runWithSecurityManager ( new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return    . performAction ( action ,    namingContext ,    n ,    params )  ;", "}", "}  ,     . getSecurityContextForJNDILookup ( allPerms )  )  ;", "}", "METHOD_END"], "methodName": ["testActionWithPermission"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "final   CompositeName   n    =     ( name    =  =    null )     ?    new   CompositeName (  )     :    new   CompositeName ( name )  ;", "final   String   sn    =     ( name    =  =    null )     ?     \"  \"     :    name ;", "ArrayList < JndiPermission >    allPerms    =    new   ArrayList < JndiPermission >  ( additionalRequiredPerms )  ;", "allPerms . add ( new   JndiPermission ( sn ,     . not ( action )  )  )  ;", "try    {", ". runWithSecurityManager ( new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return    . performAction ( action ,    namingContext ,    n ,    params )  ;", "}", "}  ,     . getSecurityContextForJNDILookup ( allPerms )  )  ;", "fail (  (  (  \" Naming   operation    \"     +    action )     +     \"    should   not   have   been   permitted \"  )  )  ;", "}    catch    ( SecurityException   e )     {", "}", "}", "METHOD_END"], "methodName": ["testActionWithoutPermission"], "fileName": "org.jboss.as.naming.SecurityHelper"}, {"methodBody": ["METHOD_START", "{", "final   ConcurrentSkipListSet < ServiceName >    boundServices    =    this . boundServices ;", "if    ( boundServices . contains ( serviceName )  )     {", "throw   NamingLogger . ROOT _ LOGGER . serviceAlreadyBound ( serviceName )  ;", "}", "boundServices . add ( serviceName )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   Enumeration < String >    parts    =    name . getAll (  )  ;", "Name   current    =    serviceNameBase ;", "while    ( parts . hasMoreElements (  )  )     {", "final   String   currentPart    =    parts . nextElement (  )  ;", "if    (  !  ( currentPart . isEmpty (  )  )  )     {", "current    =    current . append ( currentPart )  ;", "}", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["buildServiceName"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   CannotProceedException   cpe    =    new   CannotProceedException (  )  ;", "cpe . setResolvedObj ( resolvedObject )  ;", "cpe . setRemainName ( remainName )  ;", "return   cpe ;", "}", "METHOD_END"], "methodName": ["cannotProceedException"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( object   instanceof   Reference )     {", "if    (  (  (  ( Reference )     ( object )  )  . get (  \" nns \"  )  )     !  =    null )     {", "throw    . cannotProceedException ( object ,    name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkReferenceForContinuation"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "boundServices . clear (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "String [  ]    c    =    serviceName . toArray (  )  ;", "CompositeName   name    =    new   CompositeName (  )  ;", "int   baseIndex    =    serviceNameBase . toArray (  )  . length ;", "for    ( int   i    =    baseIndex ;    i    <     ( c . length )  ;    i +  +  )     {", "try    {", "name . add ( c [ i ]  )  ;", "}    catch    ( InvalidNameException   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "return   serviceNameBase ;", "}", "METHOD_END"], "methodName": ["getServiceNameBase"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "return   serviceRegistry ;", "}", "METHOD_END"], "methodName": ["getServiceRegistry"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   lookupName    =    buildServiceName ( name )  ;", "final   ServiceName   floor    =    boundServices . floor ( lookupName )  ;", "boolean   isContextBinding    =    false ;", "if    (  ( floor    !  =    null )     &  &     ( floor . isParentOf ( lookupName )  )  )     {", "Object   obj    =    lookup ( name . toString (  )  ,    floor ,    true )  ;", "if    ( obj   instanceof   NamingContext )     {", "isContextBinding    =    true ;", "} else", "if    ( obj    !  =    null )     {", "throw   new   RequireResolveException ( convert ( floor )  )  ;", "}", "}", "final   List < ServiceName >    children    =    listChildren ( lookupName ,    isContextBinding )  ;", "final   String [  ]    lookupParts    =    lookupName . toArray (  )  ;", "final   Set < String >    childContexts    =    new   HashSet < String >  (  )  ;", "final   List < NameClassPair >    results    =    new   ArrayList < NameClassPair >  (  )  ;", "for    ( ServiceName   child    :    children )     {", "final   String [  ]    childParts    =    child . toArray (  )  ;", "if    (  ( childParts . length )     >     (  ( lookupParts . length )     +     1  )  )     {", "childContexts . add ( childParts [ lookupParts . length ]  )  ;", "} else    {", "final   Object   binding    =    lookup ( name . toString (  )  ,    child ,    false )  ;", "final   String   bindingType ;", "if    ( binding   instanceof   ContextListManagedReferenceFactory )     {", "bindingType    =    ContextListManagedReferenceFactory . class . cast ( binding )  . getInstanceClassName (  )  ;", "} else    {", "if    ( binding   instanceof   ManagedReferenceFactory )     {", "bindingType    =    ContextListManagedReferenceFactory . DEFAULT _ INSTANCE _ CLASS _ NAME ;", "} else    {", "bindingType    =    binding . getClass (  )  . getName (  )  ;", "}", "}", "results . add ( new   NameClassPair ( childParts [  (  ( childParts . length )     -     1  )  ]  ,    bindingType )  )  ;", "}", "}", "for    ( String   contextName    :    childContexts )     {", "results . add ( new   NameClassPair ( contextName ,    Context . class . getName (  )  )  )  ;", "}", "return   results ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   lookupName    =    buildServiceName ( name )  ;", "final   ServiceName   floor    =    boundServices . floor ( lookupName )  ;", "boolean   isContextBinding    =    false ;", "if    (  ( floor    !  =    null )     &  &     ( floor . isParentOf ( lookupName )  )  )     {", "Object   obj    =    lookup ( name . toString (  )  ,    floor ,    true )  ;", "if    ( obj   instanceof   NamingContext )     {", "isContextBinding    =    true ;", "} else", "if    ( obj    !  =    null )     {", "throw   new   RequireResolveException ( convert ( floor )  )  ;", "}", "}", "final   List < ServiceName >    children    =    listChildren ( lookupName ,    isContextBinding )  ;", "final   String [  ]    lookupParts    =    lookupName . toArray (  )  ;", "final   Set < String >    childContexts    =    new   HashSet < String >  (  )  ;", "final   List < Binding >    results    =    new   ArrayList < Binding >  (  )  ;", "for    ( ServiceName   child    :    children )     {", "final   String [  ]    childParts    =    child . toArray (  )  ;", "if    (  ( childParts . length )     >     (  ( lookupParts . length )     +     1  )  )     {", "childContexts . add ( childParts [ lookupParts . length ]  )  ;", "} else    {", "final   Object   binding    =    lookup ( name . toString (  )  ,    child ,    true )  ;", "results . add ( new   Binding ( childParts [  (  ( childParts . length )     -     1  )  ]  ,    binding )  )  ;", "}", "}", "for    ( String   contextName    :    childContexts )     {", "results . add ( new   Binding ( contextName ,    new   NamingContext (  (  ( Name )     ( name . clone (  )  )  )  . add ( contextName )  ,    this ,    null )  )  )  ;", "}", "return   results ;", "}", "METHOD_END"], "methodName": ["listBindings"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   ConcurrentSkipListSet < ServiceName >    boundServices    =    this . boundServices ;", "if    (  (  ! isContextBinding )     &  &     ( boundServices . contains ( name )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . cannotListNonContextBinding (  )  ;", "}", "final   NavigableSet < ServiceName >    tail    =    boundServices . tailSet ( name )  ;", "final   List < ServiceName >    children    =    new   ArrayList < ServiceName >  (  )  ;", "for    ( ServiceName   next    :    tail )     {", "if    ( name . isParentOf ( next )  )     {", "if    (  !  ( name . equals ( next )  )  )     {", "children . add ( next )  ;", "}", "} else    {", "break ;", "}", "}", "return   children ;", "}", "METHOD_END"], "methodName": ["listChildren"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Controller <  ?  >    controller    =    serviceRegistry . get ( lookupName )  ;", "if    ( controller    !  =    null )     {", "final   Object   object    =    controller . getValue (  )  ;", "if    ( dereference    &  &     ( object   instanceof   ManagedReferenceFactory )  )     {", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < Object >  (  )     {", "@ Override", "public   Object   run (  )     {", "final   ManagedReference   managedReference    =    ManagedReferenceFactory . class . cast ( object )  . getReference (  )  ;", "return   managedReference    !  =    null    ?    managedReference . getInstance (  )     :    null ;", "}", "}  )  ;", "} else    {", "final   ManagedReference   managedReference    =    ManagedReferenceFactory . class . cast ( object )  . getReference (  )  ;", "return   managedReference    !  =    null    ?    managedReference . getInstance (  )     :    null ;", "}", "} else    {", "return   object ;", "}", "} else    {", "return   null ;", "}", "}    catch    ( IllegalStateException   e )     {", "NameNotFoundException   n    =    new   NameNotFoundException ( name )  ;", "n . initCause ( e )  ;", "throw   n ;", "}    catch    ( SecurityException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   t )     {", "throw   NamingLogger . ROOT _ LOGGER . lookupError ( t ,    name )  ;", "}", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    ( name . isEmpty (  )  )     {", "return   new   NamingContext ( EMPTY _ NAME ,    this ,    null )  ;", "}", "final   Name   lookupName    =    buildName ( name )  ;", "Object   obj    =    lookup ( name . toString (  )  ,    lookupName ,    dereference )  ;", "if    ( obj    =  =    null )     {", "final   Name   lower    =    bounds . lower ( lookupName )  ;", "if    (  ( lower    !  =    null )     &  &     ( lower . isParentOf ( lookupName )  )  )     {", "obj    =    lookup ( name . toString (  )  ,    lower ,    dereference )  ;", "if    (  !  ( obj   instanceof   NamingContext )  )     {", "checkReferenceForContinuation ( name ,    obj )  ;", "return   new   ResolveResult ( obj ,    suffix ( lower ,    lookupName )  )  ;", "}", "}", "final   Name   ceiling    =    bounds . ceiling ( lookupName )  ;", "if    (  ( ceiling    !  =    null )     &  &     ( lookupName . isParentOf ( ceiling )  )  )     {", "if    ( lookupName . equals ( ceiling )  )     {", "return   null ;", "}", "return   new   NamingContext (  (  ( Name )     ( name . clone (  )  )  )  ,    this ,    null )  ;", "}", "throw   new   NameNotFoundException (  (  (  ( name . toString (  )  )     +     \"     -  -     \"  )     +    lookupName )  )  ;", "}", "return   obj ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "boundServices . remove ( serviceName )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "if    (  ( serviceNameBase . equals ( ContextNames . EXPORTED _ CONTEXT _ SERVICE _ NAME )  )     |  |     ( ContextNames . EXPORTED _ CONTEXT _ SERVICE _ NAME . isParentOf ( serviceNameBase )  )  )     {", "return   new   CompositeName (  \" java : jboss / exported \"  )  ;", "}", "if    (  ( serviceNameBase . equals ( ContextNames . JBOSS _ CONTEXT _ SERVICE _ NAME )  )     |  |     ( ContextNames . JBOSS _ CONTEXT _ SERVICE _ NAME . isParentOf ( serviceNameBase )  )  )     {", "return   new   CompositeName (  \" java : jboss \"  )  ;", "}", "if    (  ( serviceNameBase . equals ( ContextNames . APPLICATION _ CONTEXT _ SERVICE _ NAME )  )     |  |     ( ContextNames . APPLICATION _ CONTEXT _ SERVICE _ NAME . isParentOf ( serviceNameBase )  )  )     {", "return   new   CompositeName (  \" java : app \"  )  ;", "}", "if    (  ( serviceNameBase . equals ( ContextNames . MODULE _ CONTEXT _ SERVICE _ NAME )  )     |  |     ( ContextNames . MODULE _ CONTEXT _ SERVICE _ NAME . isParentOf ( serviceNameBase )  )  )     {", "return   new   CompositeName (  \" java : module \"  )  ;", "}", "if    (  ( serviceNameBase . equals ( ContextNames . COMPONENT _ CONTEXT _ SERVICE _ NAME )  )     |  |     ( ContextNames . COMPONENT _ CONTEXT _ SERVICE _ NAME . isParentOf ( serviceNameBase )  )  )     {", "return   new   CompositeName (  \" java : comp \"  )  ;", "}", "if    (  ( serviceNameBase . equals ( ContextNames . GLOBAL _ CONTEXT _ SERVICE _ NAME )  )     |  |     ( ContextNames . GLOBAL _ CONTEXT _ SERVICE _ NAME . isParentOf ( serviceNameBase )  )  )     {", "return   new   CompositeName (  \" java : global \"  )  ;", "}", "if    (  ( serviceNameBase . equals ( ContextNames . JAVA _ CONTEXT _ SERVICE _ NAME )  )     |  |     ( ContextNames . JAVA _ CONTEXT _ SERVICE _ NAME . isParentOf ( serviceNameBase )  )  )     {", "return   new   CompositeName (  \" java :  \"  )  ;", "}", "return   new   CompositeName (  )  ;", "}", "METHOD_END"], "methodName": ["setBaseName"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "String [  ]    p    =    parent . toArray (  )  ;", "String [  ]    c    =    child . toArray (  )  ;", "CompositeName   name    =    new   CompositeName (  )  ;", "for    ( int   i    =    p . length ;    i    <     ( c . length )  ;    i +  +  )     {", "try    {", "name . add ( c [ i ]  )  ;", "}    catch    ( InvalieException   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["suffix"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "for    ( NameClassPair   value    :    list )     {", "if    ( value   instanceof   Bind    {", "assertNotNull ( Bindclass . cast ( value )  . getObject (  )  )  ;", "}", "if    (  ( value . getName (  )  . equals ( name )  )     &  &     ( value . getClassName (  )  . equals ( type . getName (  )  )  )  )     {", "return ;", "}", "}", "fail (  (  (  (  (  \" Child    [  \"     +    name )     +     \"  ]    not   found   in    [  \"  )     +    list )     +     \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertContains"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "container . addService ( serviceName ,    new   msc . service . Service < ManagedReferenceFactory >  (  )     {", "public   void   start ( StartContext   context )    throws   StartException    {", "store . add ( serviceName )  ;", "latch . countDown (  )  ;", "}", "public   void   stop ( StopContext   context )     {", "}", "public   ManagedReferenceFactory   getValue (  )    throws   IllegalArgumentException ,    IllegalStateException    {", "return   new   ValueManagedReferenceFactory ( Values . immediateValue ( value )  )  ;", "}", "}  )  . install (  )  ;", "latch . await (  )  ;", "}", "METHOD_END"], "methodName": ["bindObject"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "container    =    Factory . create (  )  ;", "store    =    new    ( container ,    ServiceName . JBOSS )  ;", "}", "METHOD_END"], "methodName": ["setupServiceContainer"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( container )     !  =    null )     {", "container . shutdown (  )  ;", "try    {", "container . awaitTermination (  5  ,    TimeUnit . SECONDS )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}    finally    {", "container    =    null ;", "}", "}", "s    =    null ;", "}", "METHOD_END"], "methodName": ["shutdownServiceContainer"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Object   value    =    new   Object (  )  ;", "bindObject ( JBOSS . append (  \" Bean \"  )  ,    value )  ;", "bindObject ( JBOSS . append (  \" foo \"  ,     \" Bean \"  )  ,    value )  ;", "bindObject ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" Bean \"  )  ,    value )  ;", "bindObject ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" baz \"  ,     \" Bean \"  )  ,    value )  ;", "store . add ( JBOSS . append (  \" foos \"  ,     \" bar \"  )  )  ;", "store . add ( JBOSS . append (  \" fo \"  ,     \" bar \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" ba \"  ,     \" baz \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bart \"  ,     \" baz \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" ba \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" bazt \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" art \"  )  )  ;", "store . add ( JBOSS . append (  \" other \"  ,     \" one \"  )  )  ;", "List < NameClassPair >    list    =    store . list ( new   CompositeName (  \"  \"  )  )  ;", "assertEquals (  5  ,    list . size (  )  )  ;", "assertContains ( list ,     \" Bean \"  ,    Object . class )  ;", "assertContains ( list ,     \" foo \"  ,    Context . class )  ;", "assertContains ( list ,     \" fo \"  ,    Context . class )  ;", "assertContains ( list ,     \" foos \"  ,    Context . class )  ;", "assertContains ( list ,     \" other \"  ,    Context . class )  ;", "list    =    store . list ( new   CompositeName (  \" foo \"  )  )  ;", "assertEquals (  4  ,    list . size (  )  )  ;", "assertContains ( list ,     \" Bean \"  ,    Object . class )  ;", "assertContains ( list ,     \" ba \"  ,    Context . class )  ;", "assertContains ( list ,     \" bart \"  ,    Context . class )  ;", "assertContains ( list ,     \" bar \"  ,    Context . class )  ;", "}", "METHOD_END"], "methodName": ["testList"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Object   value    =    new   Object (  )  ;", "bindObject ( JBOSS . append (  \" TestBean \"  )  ,    value )  ;", "bindObject ( JBOSS . append (  \" foo \"  ,     \" TestBean \"  )  ,    value )  ;", "bindObject ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" TestBean \"  )  ,    value )  ;", "bindObject ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" baz \"  ,     \" TestBean \"  )  ,    value )  ;", "store . add ( JBOSS . append (  \" foos \"  ,     \" bar \"  )  )  ;", "store . add ( JBOSS . append (  \" fo \"  ,     \" bar \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" ba \"  ,     \" baz \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bart \"  ,     \" baz \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" ba \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" bazt \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" art \"  )  )  ;", "store . add ( JBOSS . append (  \" other \"  ,     \" one \"  )  )  ;", "List < Binding >    list    =    store . listBindings ( new   CompositeName (  \"  \"  )  )  ;", "assertEquals (  5  ,    list . size (  )  )  ;", "assertContains ( list ,     \" TestBean \"  ,    Object . class )  ;", "assertContains ( list ,     \" foo \"  ,    Context . class )  ;", "assertContains ( list ,     \" fo \"  ,    Context . class )  ;", "assertContains ( list ,     \" foos \"  ,    Context . class )  ;", "assertContains ( list ,     \" other \"  ,    Context . class )  ;", "list    =    store . listBindings ( new   CompositeName (  \" foo \"  )  )  ;", "assertEquals (  4  ,    list . size (  )  )  ;", "assertContains ( list ,     \" TestBean \"  ,    Object . class )  ;", "assertContains ( list ,     \" ba \"  ,    Context . class )  ;", "assertContains ( list ,     \" bart \"  ,    Context . class )  ;", "assertContains ( list ,     \" bar \"  ,    Context . class )  ;", "for    ( Binding   binding    :    list )     {", "if    ( binding . getName (  )  . equals (  \" bar \"  )  )     {", "final   Object   bean    =    Context . class . cast ( binding . getObject (  )  )  . lookup (  \" TestBean \"  )  ;", "assertNotNull ( bean )  ;", "assertEquals ( value ,    bean )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testListBindings"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Object   obj    =    store . lookup ( new   CompositeName (  )  )  ;", "assertNotNull ( obj )  ;", "}", "METHOD_END"], "methodName": ["testLookupBase"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   bindingName    =    JBOSS . append (  \" foo \"  ,     \" bar \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "bindObject ( bindingName ,    value )  ;", "final   Object   obj    =    store . lookup ( new   CompositeName (  \" foo / bar \"  )  )  ;", "assertNotNull ( obj )  ;", "assertEquals ( value ,    obj )  ;", "}", "METHOD_END"], "methodName": ["testLookupBinding"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   bindingName    =    JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" baz \"  ,     \" TestBean \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "bindObject ( bindingName ,    value )  ;", "Object   context    =    store . lookup ( new   CompositeName (  \" foo \"  )  )  ;", "assertNotNull ( context )  ;", "assertTrue (  ( context   instanceof   Context )  )  ;", "Object   obj    =    Context . class . cast ( context )  . lookup ( new   CompositeName (  \" bar / baz / TestBean \"  )  )  ;", "assertNotNull ( obj )  ;", "assertEquals ( value ,    obj )  ;", "context    =    Context . class . cast ( context )  . lookup ( new   CompositeName (  \" bar \"  )  )  ;", "obj    =    Context . class . cast ( context )  . lookup ( new   CompositeName (  \" baz / TestBean \"  )  )  ;", "assertNotNull ( obj )  ;", "assertEquals ( value ,    obj )  ;", "context    =    Context . class . cast ( context )  . lookup ( new   CompositeName (  \" baz \"  )  )  ;", "obj    =    Context . class . cast ( context )  . lookup ( new   CompositeName (  \" TestBean \"  )  )  ;", "assertNotNull ( obj )  ;", "assertEquals ( value ,    obj )  ;", "}", "METHOD_END"], "methodName": ["testLookupBindingUsingNestedContext"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   bindingName    =    JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" baz \"  ,     \" TestBean \"  )  ;", "store . add ( bindingName )  ;", "store . add ( JBOSS . append (  \" foos \"  ,     \" bar \"  )  )  ;", "store . add ( JBOSS . append (  \" fo \"  ,     \" bar \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" ba \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bart \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" ba \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" bazt \"  )  )  ;", "store . add ( JBOSS . append (  \" foo \"  ,     \" bar \"  ,     \" art \"  )  )  ;", "Object   obj    =    store . lookup ( new   CompositeName (  \" foo \"  )  )  ;", "assertNotNull ( obj )  ;", "assertTrue (  ( obj   instanceof   Context )  )  ;", "obj    =    Context . class . cast ( obj )  . lookup ( new   CompositeName (  \" bar \"  )  )  ;", "assertNotNull ( obj )  ;", "assertTrue (  ( obj   instanceof   Context )  )  ;", "obj    =    Context . class . cast ( obj )  . lookup ( new   CompositeName (  \" baz \"  )  )  ;", "assertNotNull ( obj )  ;", "assertTrue (  ( obj   instanceof   Context )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupNestedContext"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   bindingName    =    JBOSS . append (  \" foo \"  ,     \" bar \"  )  ;", "store . add ( bindingName )  ;", "final   Object   obj    =    store . lookup ( new   CompositeName (  \" foo \"  )  )  ;", "assertNotNull ( obj )  ;", "assertTrue (  ( obj   instanceof   Context )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupParentContext"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   bindingName    =    JBOSS . append (  \" foo - stored \"  )  . append (  \" again \"  )  ;", "bindObject ( bindingName ,    new   Context (  )     {", "@ Override", "public   Object   lookup ( Name   name )    throws   NamingException    {", "if    (  \" blah / blah 2  \"  . equals ( name . toString (  )  )  )     {", "return   new   Integer (  5  )  ;", "}", "return   null ;", "}", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "return   lookup ( new   CompositeName ( name )  )  ;", "}", "@ Override", "public   void   bind ( Name   name ,    Object   obj )    throws   NamingException    {", "}", "@ Override", "public   void   bind ( String   name ,    Object   obj )    throws   NamingException    {", "}", "@ Override", "public   void   rebind ( Name   name ,    Object   obj )    throws   NamingException    {", "}", "@ Override", "public   void   rebind ( String   name ,    Object   obj )    throws   NamingException    {", "}", "@ Override", "public   void   unbind ( Name   name )    throws   NamingException    {", "}", "@ Override", "public   void   unbind ( String   name )    throws   NamingException    {", "}", "@ Override", "public   void   rename ( Name   oldName ,    Name   newName )    throws   NamingException    {", "}", "@ Override", "public   void   rename ( String   oldName ,    String   newName )    throws   NamingException    {", "}", "@ Override", "public   NamingEnumeration < NameClassPair >    list ( Name   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   NamingEnumeration < NameClassPair >    list ( String   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   NamingEnumeration < Binding >    listBindings ( Name   name )    throws   NamingException    {", "if    (  !  (  \" hi / there \"  . equals ( name . toString (  )  )  )  )", "throw   new   IllegalArgumentException (  \" Expected   hi / there \"  )  ;", "return   null ;", "}", "@ Override", "public   NamingEnumeration < Binding >    listBindings ( String   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   void   destroySubcontext ( Name   name )    throws   NamingException    {", "}", "@ Override", "public   void   destroySubcontext ( String   name )    throws   NamingException    {", "}", "@ Override", "public   Context   createSubcontext ( Name   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   Context   createSubcontext ( String   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   Object   lookupLink ( Name   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   Object   lookupLink ( String   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   NameParser   getNameParser ( Name   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   NameParser   getNameParser ( String   name )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   Name   composeName ( Name   name ,    Name   prefix )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   String   composeName ( String   name ,    String   prefix )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   Object   addToEnvironment ( String   propName ,    Object   propVal )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   Object   removeFromEnvironment ( String   propName )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   Hashtable <  ?  ,     ?  >    getEnvironment (  )    throws   NamingException    {", "return   null ;", "}", "@ Override", "public   void   close (  )    throws   NamingException    {", "}", "@ Override", "public   String   getNameInNamespace (  )    throws   NamingException    {", "return   null ;", "}", "}  )  ;", "final   NamingContext   ctx    =    new   NamingContext ( new   CompositeName (  )  ,    store ,    null )  ;", "final   Object   obj    =    ctx . lookup ( new   CompositeName (  \" foo - stored / again / blah / blah 2  \"  )  )  ;", "ctx . listBindings (  \" foo - stored / again / hi / there \"  )  ;", "assertNotNull ( obj )  ;", "assertEquals ( new   Integer (  5  )  ,    obj )  ;", "}", "METHOD_END"], "methodName": ["testStoredContext"], "fileName": "org.jboss.as.naming.ServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "return   ModularReference . create ( Context . class ,    new   ServiceReferenceObjectFactory . ServiceNameRefAdr (  \" srof \"  ,    service )  ,    factory )  ;", "}", "METHOD_END"], "methodName": ["createReference"], "fileName": "org.jboss.as.naming.ServiceReferenceObjectFactory"}, {"methodBody": ["METHOD_START", "{", "return   serviceValue ;", "}", "METHOD_END"], "methodName": ["getObjectInstance"], "fileName": "org.jboss.as.naming.ServiceReferenceObjectFactory"}, {"methodBody": ["METHOD_START", "{", "final   Object   owner    =    requireOwner (  )  ;", "final   Name   bindName    =    buildName ( name )  ;", "bind ( name ,    object ,    owner ,    bindName )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "bind ( name ,    object )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "ServiceTarget   serviceTarget    =    this . serviceTarget ;", "ServiceName   deploymentUnitServiceName    =    null ;", "if    ( owner   instanceof   ServiceName )     {", "deploymentUnitServiceName    =     (  ( ServiceName )     ( owner )  )  ;", "} else    {", "serviceTarget    =     (  ( ServiceTarget )     ( owner )  )  ;", "}", "try    {", "final   BinderService   binderService    =    new   BinderService ( name . toString (  )  ,    null ,     ( deploymentUnitServiceName    !  =    null )  )  ;", "final   ServiceBuilder <  ?  >    builder    =    serviceTarget . addService ( bindName ,    binderService )  . addDependency ( getServiceNameBase (  )  ,     . class ,    binderService . getNamingStoreInjector (  )  )  . addInjection ( binderService . getManagedObjectInjector (  )  ,    new   ImmediateManagedReferenceFactory ( object )  )  . setInitialMode ( ACTIVE )  ;", "final   ServiceController <  ?  >    binderServiceController    =    builder . install (  )  ;", "final   StabilityMonitor   monitor    =    new   StabilityMonitor (  )  ;", "monitor . addController ( binderServiceController )  ;", "try    {", "monitor . awaitStability (  )  ;", "}    finally    {", "monitor . removeController ( binderServiceController )  ;", "}", "final   Exception   startException    =    binderServiceController . getStartException (  )  ;", "if    ( startException    !  =    null )     {", "throw   startException ;", "}", "if    ( deploymentUnitServiceName    !  =    null )     {", "binderService . acquire (  )  ;", "final   RuntimeBindReleaseService . References   duBindingReferences    =     (  ( RuntimeBindReleaseService . References )     ( binderServiceController . getServiceContainer (  )  . getService ( JndiNamingDependencyProcessor . serviceName ( deploymentUnitServiceName )  )  . getValue (  )  )  )  ;", "duBindingReferences . add ( binderService )  ;", "}", "}    catch    ( Exception   e )     {", "throw   NamingUtils . namingException (  (  (  (  (  \" Failed   to   bind    [  \"     +    object )     +     \"  ]    at   location    [  \"  )     +    bindName )     +     \"  ]  \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "requireOwner (  )  ;", "if    ( Utils . isLastComponentEmpty ( name )  )     {", "throw   Logger . ROOT _ LOGGER . emptyNameNotAllowed (  )  ;", "}", "return   new   Context ( name ,    this ,    new   Hashtable < String ,    Object >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSubcontext"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "WritableServiceBasedNamingStore . WRITE _ OWNER . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "WritableServiceBasedNamingStore . WRITE _ OWNER . push ( deploymentUnitServiceName )  ;", "}", "METHOD_END"], "methodName": ["pushOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "WritableServiceBasedNamingStore . WRITE _ OWNER . push ( serviceTarget )  ;", "}", "METHOD_END"], "methodName": ["pushOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   Object   owner    =    requireOwner (  )  ;", "final   ServiceName   bindName    =    buildServiceName ( name )  ;", "final   ServiceController <  ?  >    controller    =    getServiceRegistry (  )  . getService ( bindName )  ;", "if    ( controller    =  =    null )     {", "bind ( name ,    object ,    owner ,    bindName )  ;", "} else    {", "final   BinderService   binderService    =     (  ( BinderService )     ( controller . getService (  )  )  )  ;", "if    ( owner   instanceof   ServiceName )     {", "final   ServiceName   deploymentUnitServiceName    =     (  ( ServiceName )     ( owner )  )  ;", "binderService . acquire (  )  ;", "final   RuntimeBindReleas . References   duBindingReferences    =     (  ( RuntimeBindReleas . References )     ( controller . getServiceContainer (  )  . getService ( JndiNamingDependencyProcessor . serviceName ( deploymentUnitServiceName )  )  . getValue (  )  )  )  ;", "duBindingReferences . add ( binderService )  ;", "}", "binderService . getManagedObjectInjector (  )  . setValue ( new   ImmediateValue ( new   ImmediateManagedReferenceFactory ( object )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "rebind ( name ,    object )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   Object   owner    =    WritableServiceBasedNamingStore . WRITE _ OWNER . peek (  )  ;", "if    ( owner    =  =    null )     {", "throw   NamingLogger . ROOT _ LOGGER . readOnlyNamingContext (  )  ;", "}", "return   owner ;", "}", "METHOD_END"], "methodName": ["requireOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "requireOwner (  )  ;", "final   ServiceName   bindName    =    buildServiceName ( name )  ;", "final   ServiceController <  ?  >    controller    =    getServiceRegistry (  )  . getService ( bindName )  ;", "if    ( controller    =  =    null )     {", "throw   NamingLogger . ROOT _ LOGGER . cannotResolv ( bindName )  ;", "}", "controller . setMode ( REMOVE )  ;", "final   StabilityMonitor   monitor    =    new   StabilityMonitor (  )  ;", "monitor . addController ( controller )  ;", "try    {", "monitor . awaitStability (  )  ;", "}    catch    ( Exception   e )     {", "throw   NamingUtils . namingException (  (  (  \" Failed   to   unbind    [  \"     +    bindName )     +     \"  ]  \"  )  ,    e )  ;", "}    finally    {", "monitor . removeController ( controller )  ;", "}", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStore"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch 1     =    new   CountDownLatch (  1  )  ;", "container . addService ( JndiNamingDependencyProcessor . serviceName ( owner )  ,    new   RuntimeBindReleaseService (  )  )  . setInitialMode ( ACTIVE )  . addListener ( new   msc . service . AbstractServiceListener < Object >  (  )     {", "public   void   transition ( ServiceController <  ?  >    controller ,    ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "latch 1  . countDown (  )  ;", "break ;", "}", "case   STARTING _ to _ START _ FAILED    :", "{", "latch 1  . countDown (  )  ;", "fail (  (  \" Did   not   install   store   service    -     \"     +     ( controller . getStartException (  )  . getMessage (  )  )  )  )  ;", "break ;", "}", "default    :", "break ;", "}", "}", "}  )  . install (  )  ;", "latch 1  . await (  1  0  ,    TimeUnit . SECONDS )  ;", "}", "METHOD_END"], "methodName": ["installOwnerService"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "container    =    Factory . create (  )  ;", "installOwnerService (  . OWNER _ FOO )  ;", "installOwnerService (  . OWNER _ BAR )  ;", "final   CountDownLatch   latch 2     =    new   CountDownLatch (  1  )  ;", "final   NamingStoreService   namingStoreService    =    new   NamingStoreService (  )  ;", "container . addService ( ContextNames . JAVA _ CONTEXT _ SERVICE _ NAME ,    namingStoreService )  . setInitialMode ( ACTIVE )  . addListener ( new   AbstractServiceListener < NamingStore >  (  )     {", "public   void   transition ( ServiceController <  ?    extends   NamingStore >    controller ,    ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "latch 2  . countDown (  )  ;", "break ;", "}", "case   STARTING _ to _ START _ FAILED    :", "{", "latch 2  . countDown (  )  ;", "fail (  (  \" Did   not   install   store   service    -     \"     +     ( controller . getStartException (  )  . getMessage (  )  )  )  )  ;", "break ;", "}", "default    :", "break ;", "}", "}", "}  )  . install (  )  ;", "latch 2  . await (  1  0  ,    TimeUnit . SECONDS )  ;", "store    =     (  ( WritableServiceBasedNamingStore )     ( namingStoreService . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( container )     !  =    null )     {", "container . shutdown (  )  ;", "try    {", "container . awaitTermination (  5  ,    TimeUnit . SECONDS )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}    finally    {", "container    =    null ;", "}", "}", "s    =    null ;", "}", "METHOD_END"], "methodName": ["shutdownServiceContainer"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "store . bind ( name ,    value )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "assertEquals ( value ,    store . lookup ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testBind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" nested / test \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "store . bind ( name ,    value )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "assertEquals ( value ,    store . lookup ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testBindNested"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "s . bind ( new   CompositeName (  \" test \"  )  ,    new   Object (  )  )  ;", "fail (  \" Should   have   failed   with   a   read - only   context   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testBindNoOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "s . createSubcontext ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   failed   with   a   read - only   context   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCreateSubContextNoOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "WritableServiceBasedNamingStore . pushOwner ( WritableServiceBasedNamingStoreTestCase . OWNER _ FOO )  ;", "try    {", "assertTrue (  (  (  (  ( NamingContext )     ( store . createSubcontext ( new   CompositeName (  \" test \"  )  )  )  )  . getNamingStore (  )  )    instanceof   WritableServiceBasedNamingStore )  )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreateSubcontext"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   ServiceName   serviceName    =    store . buildServiceName ( name )  ;", "final   Object   value    =    new   Object (  )  ;", "try    {", "store . lookup ( name )  ;", "fail (  \" Should   have   thrown   name   not   found \"  )  ;", "}    catch    ( NameNotFoundException   expect )     {", "}", "final   RuntimeBindReleaseService . References   fooDuBindingReferences    =     (  ( RuntimeBindReleaseService . References )     ( container . getService ( JndiNamingDependencyProcessor . serviceName (  . OWNER _ FOO )  )  . getValue (  )  )  )  ;", "assertFalse ( fooDuBindingReferences . contains ( serviceName )  )  ;", "final   RuntimeBindReleaseService . References   barDuBindingReferences    =     (  ( RuntimeBindReleaseService . References )     ( container . getService ( JndiNamingDependencyProcessor . serviceName (  . OWNER _ BAR )  )  . getValue (  )  )  )  ;", "assertFalse ( barDuBindingReferences . contains ( serviceName )  )  ;", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "store . bind ( name ,    value )  ;", "assertTrue ( fooDuBindingReferences . contains ( serviceName )  )  ;", "assertFalse ( barDuBindingReferences . contains ( serviceName )  )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ BAR )  ;", "try    {", "store . rebind ( name ,    value )  ;", "assertTrue ( fooDuBindingReferences . contains ( serviceName )  )  ;", "assertTrue ( barDuBindingReferences . contains ( serviceName )  )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "store . unbind ( name )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMultipleOwnersBindingReferences"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   ServiceName   serviceName    =    store . buildServiceName ( name )  ;", "final   Object   value    =    new   Object (  )  ;", "try    {", "store . lookup ( name )  ;", "fail (  \" Should   have   thrown   name   not   found \"  )  ;", "}    catch    ( NameNotFoundException   expect )     {", "}", "final   RuntimeBindReleaseService . References   duBindingReferences    =     (  ( RuntimeBindReleaseService . References )     ( container . getService ( JndiNamingDependencyProcessor . serviceName (  . OWNER _ FOO )  )  . getValue (  )  )  )  ;", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "store . bind ( name ,    value )  ;", "assertTrue ( duBindingReferences . contains ( serviceName )  )  ;", "store . rebind ( name ,    value )  ;", "assertTrue ( duBindingReferences . contains ( serviceName )  )  ;", "store . unbind ( name )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testOwnerBindingReferences"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingContext   namingContext    =    new   NamingContext ( store ,    null )  ;", "final   String   name    =     \" a / b \"  ;", "final   Object   value    =    new   Object (  )  ;", "ArrayList < JndiPermission >    permissions    =    new   ArrayList < JndiPermission >  (  )  ;", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "permissions . add ( new   JndiPermission (  (  (  ( store . getBaseName (  )  )     +     \"  /  \"  )     +    name )  ,     \" bind , list , listBindings \"  )  )  ;", "store . bind ( new   CompositeName ( name )  ,    value )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "permissions . set (  0  ,    new   JndiPermission (  (  (  ( store . getBaseName (  )  )     +     \"  /  \"  )     +    name )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "assertEquals ( value ,    SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  )  ;", "permissions . set (  0  ,    new   JndiPermission (  (  ( store . getBaseName (  )  )     +     \"  /  -  \"  )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "assertEquals ( value ,    SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  )  ;", "permissions . set (  0  ,    new   JndiPermission (  (  ( store . getBaseName (  )  )     +     \"  / a /  *  \"  )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "assertEquals ( value ,    SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  )  ;", "permissions . set (  0  ,    new   JndiPermission (  (  ( store . getBaseName (  )  )     +     \"  / a /  -  \"  )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "assertEquals ( value ,    SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  )  ;", "permissions . set (  0  ,    new   JndiPermission (  \"  <  < ALL   BINDINGS >  >  \"  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "assertEquals ( value ,    SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  )  ;", "permissions . set (  0  ,    new   JndiPermission (  (  (  ( store . getBaseName (  )  )     +     \"  /  \"  )     +    name )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "assertEquals ( value ,    SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,     (  (  ( store . getBaseName (  )  )     +     \"  /  \"  )     +    name )  )  )  ;", "NamingContext   aNamingContext    =     (  ( NamingContext )     ( namingContext . lookup (  \" a \"  )  )  )  ;", "permissions . set (  0  ,    new   JndiPermission (  (  (  ( store . getBaseName (  )  )     +     \"  /  \"  )     +    name )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "assertEquals ( value ,    SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    aNamingContext ,     \" b \"  )  )  ;", "try    {", "SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    Collections .  < JndiPermission > emptyList (  )  ,    namingContext ,    name )  ;", "fail (  \" Should   have   failed   due   to   missing   permission \"  )  ;", "}    catch    ( AccessControlException   e )     {", "}", "try    {", "permissions . set (  0  ,    new   JndiPermission (  (  ( store . getBaseName (  )  )     +     \"  /  *  \"  )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  ;", "fail (  \" Should   have   failed   due   to   missing   permission \"  )  ;", "}    catch    ( AccessControlException   e )     {", "}", "try    {", "permissions . set (  0  ,    new   JndiPermission ( name ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  ;", "fail (  \" Should   have   failed   due   to   missing   permission \"  )  ;", "}    catch    ( AccessControlException   e )     {", "}", "if    (  !  (  \" java :  \"  . equals ( store . getBaseName (  )  . toString (  )  )  )  )     {", "try    {", "permissions . set (  0  ,    new   JndiPermission (  (  \"  /  \"     +    name )  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  ;", "fail (  \" Should   have   failed   due   to   missing   permission \"  )  ;", "}    catch    ( AccessControlException   e )     {", "}", "try    {", "permissions . set (  0  ,    new   JndiPermission (  \"  /  -  \"  ,    JndiPermission . ACTION _ LOOKUP )  )  ;", "SecurityHelper . testActionWithPermission ( JndiPermission . ACTION _ LOOKUP ,    permissions ,    namingContext ,    name )  ;", "fail (  \" Should   have   failed   due   to   missing   permission \"  )  ;", "}    catch    ( AccessControlException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["testPermissions"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "final   Object   newValue    =    new   Object (  )  ;", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "store . bind ( name ,    value )  ;", "store . rebind ( name ,    newValue )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "assertEquals ( newValue ,    store . lookup ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testRebind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "s . rebind ( new   CompositeName (  \" test \"  )  ,    new   Object (  )  )  ;", "fail (  \" Should   have   failed   with   a   read - only   context   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testRebindNoOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "s . unbind ( new   CompositeName (  \" test \"  )  )  ;", "fail (  \" Should   have   failed   with   a   read - only   context   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testUnBindNoOwner"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Name   name    =    new   CompositeName (  \" test \"  )  ;", "final   Object   value    =    new   Object (  )  ;", "WritableServiceBasedNamingStore . pushOwner (  . OWNER _ FOO )  ;", "try    {", "store . bind ( name ,    value )  ;", "store . unbind ( name )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "try    {", "store . lookup ( name )  ;", "fail (  \" Should   have   thrown   name   not   found \"  )  ;", "}    catch    ( NameNotFoundException   expect )     {", "}", "}", "METHOD_END"], "methodName": ["testUnbind"], "fileName": "org.jboss.as.naming.WritableServiceBasedNamingStoreTestCase"}, {"methodBody": ["METHOD_START", "{", "return   ModularReference . create ( type . getName (  )  ,    factoryClass )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.naming.context.ModularReference"}, {"methodBody": ["METHOD_START", "{", "return   ModularReference . create ( type . getName (  )  ,    addr ,    factoryClass )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.naming.context.ModularReference"}, {"methodBody": ["METHOD_START", "{", "return   new   ModularReference ( className ,    factoryClass . getName (  )  ,    Module . forClass ( factoryClass )  . getIdentifier (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.naming.context.ModularReference"}, {"methodBody": ["METHOD_START", "{", "return   new   ModularReference ( className ,    addr ,    factoryClass . getName (  )  ,    Module . forClass ( factoryClass )  . getIdentifier (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.naming.context.ModularReference"}, {"methodBody": ["METHOD_START", "{", "return   moduleIdentifier ;", "}", "METHOD_END"], "methodName": ["getModuleIdentifier"], "fileName": "org.jboss.as.naming.context.ModularReference"}, {"methodBody": ["METHOD_START", "{", "NamespaceContextSelector   selector    =    NamespaceContextSelector . currentSelector . peek (  )  ;", "if    ( selector    !  =    null )     {", "return   selector ;", "}", "return   NamespaceContextSelector . defaultSelector ;", "}", "METHOD_END"], "methodName": ["getCurrentSelector"], "fileName": "org.jboss.as.naming.context.NamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "return   NamespaceContextSelector . currentSelector . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popCurrentSelector"], "fileName": "org.jboss.as.naming.context.NamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "NamespaceContextSelector . currentSelector . push ( selector )  ;", "}", "METHOD_END"], "methodName": ["pushCurrentSelector"], "fileName": "org.jboss.as.naming.context.NamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "NamespaceContextSelector . defaultSelector    =    selector ;", "}", "METHOD_END"], "methodName": ["setDefault"], "fileName": "org.jboss.as.naming.context.NamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( obj   instanceof   Reference )     {", "return   fFromReference (  (  ( Reference )     ( obj )  )  ,    environment )  ;", "}", "}    catch    ( Throwable   ignored )     {", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["createObjectFactory"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrentServiceCainer . getServiceCainer (  )  ;", "}", "return   AccessCroller . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Module   module    =    Module . getCallerModuleLoader (  )  . loadModule ( modularReference . getModuleIdentifier (  )  )  ;", "final   ClassLoader   classLoader    =    module . getClassLoader (  )  ;", "return   fFromReference ( modularReference ,    classLoader ,    environment )  ;", "}", "METHOD_END"], "methodName": ["factoryFromModularReference"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Class <  ?  >    factoryClass    =    classLoader . loadClass ( reference . getFactoryClassName (  )  )  ;", "ObjectFactory   factory    =    ObjectFactory . class . cast ( factoryClass . newInstance (  )  )  ;", "if    ( factory   instanceof   ServiceAwareObjectFactory )     {", "(  ( ServiceAwareObjectFactory )     ( factory )  )  . injectServiceRegistry (  . currentServiceContainer (  )  )  ;", "}", "return   factory ;", "}    catch    ( Throwable   t )     {", "throw   NamingLogger . ROOT _ LOGGER . objectFactoryCreationFailure ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["factoryFromReference"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( reference . getFactoryClassName (  )  )     =  =    null )     {", "return    . lookForURLs ( reference ,    environment )  ;", "}", "if    ( reference   instanceof   ModularReference )     {", "return   factoryFromModularReference ( ModularReference . class . cast ( reference )  ,    environment )  ;", "}", "return   factoryFromReference ( reference ,    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ,    environment )  ;", "}", "METHOD_END"], "methodName": ["factoryFromReference"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   classLoader    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "if    ( classLoader    =  =    null )     {", "return   ref ;", "}", "final   String   factoriesProp    =     (  ( String )     ( environment . get ( Context . OBJECT _ FACTORIES )  )  )  ;", "if    ( factoriesProp    !  =    null )     {", "final   String [  ]    classes    =    factoriesProp . split (  \"  :  \"  )  ;", "for    ( String   className    :    classes )     {", "try    {", "final   Class <  ?  >    factoryClass    =    classLoader . loadClass ( className )  ;", "final      objectFactory    =     . class . cast ( factoryClass . newInstance (  )  )  ;", "final   Object   result    =    objectFactory . getObjectInstance ( ref ,    name ,    nameCtx ,    environment )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}    catch    ( Throwable   ignored )     {", "}", "}", "}", "return   ref ;", "}", "METHOD_END"], "methodName": ["getObjectInstance"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   classLoader    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "if    ( classLoader    =  =    null )     {", "return   ref ;", "}", "final   String   factoriesProp    =     (  ( String )     ( environment . get ( Context . OBJECT _ FACTORIES )  )  )  ;", "if    ( factoriesProp    !  =    null )     {", "final   String [  ]    classes    =    factoriesProp . split (  \"  :  \"  )  ;", "for    ( String   className    :    classes )     {", "try    {", "final   Class <  ?  >    factoryClass    =    classLoader . loadClass ( className )  ;", "final      objectFactory    =     . class . cast ( factoryClass . newInstance (  )  )  ;", "final   Object   result ;", "if    ( objectFactory   instanceof   Dir )     {", "result    =    Dir . class . cast ( objectFactory )  . getObjectInstance ( ref ,    name ,    nameCtx ,    environment ,    attributes )  ;", "} else    {", "result    =    objectFactory . getObjectInstance ( ref ,    name ,    nameCtx ,    environment )  ;", "}", "if    ( result    !  =    null )     {", "return   result ;", "}", "}    catch    ( Throwable   ignored )     {", "}", "}", "}", "return   ref ;", "}", "METHOD_END"], "methodName": ["getObjectInstance"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "String   facProp    =     (  ( String )     ( environment . get ( Context . URL _ PKG _ PREFIXES )  )  )  ;", "if    ( facProp    !  =    null )     {", "facProp    +  =     \"  :  \"     +     \" com . sun . jndi . url \"  ;", "} else    {", "facProp    =     \" com . sun . jndi . url \"  ;", "}", "ClassLoader   loader    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "String   suffix    =     (  (  (  \"  .  \"     +    scheme )     +     \"  .  \"  )     +    scheme )     +     \" URLContextFactory \"  ;", "StringTokenizer   parser    =    new   StringTokenizer ( facProp ,     \"  :  \"  )  ;", "String   className ;", "ObjectFactory   factory    =    null ;", "while    ( parser . hasMoreTokens (  )  )     {", "className    =     ( parser . nextToken (  )  )     +    suffix ;", "try    {", "Class <  ?  >    clazz ;", "if    ( loader    =  =    null )     {", "clazz    =    Class . forName ( className )  ;", "} else    {", "clazz    =    Class . forName ( className ,    true ,    loader )  ;", "}", "return   new    . ReferenceUrlContextFactoryWrapper (  (  ( ObjectFactory )     ( clazz . newInstance (  )  )  )  ,    url )  ;", "}    catch    ( InstantiationException    |    IllegalAccessException   e )     {", "NamingException   ne    =    new   NamingException ( className )  ;", "ne . setRootCause ( e )  ;", "throw   ne ;", "}    catch    ( Exception   e )     {", "}", "}", "return   factory ;", "}", "METHOD_END"], "methodName": ["getURLObjectFactory"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "int   colon    =    str . indexOf (  '  :  '  )  ;", "int   slash    =    str . indexOf (  '  /  '  )  ;", "if    (  ( colon    >     0  )     &  &     (  ( slash    =  =     (  -  1  )  )     |  |     (  ( colon    +     1  )     =  =    slash )  )  )", "return   str . substr (  0  ,    colon )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getURLScheme"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( ref . size (  )  )  ;    i +  +  )     {", "RefAddr   addr    =    ref . get ( i )  ;", "if    (  ( addr   instanceof   StringRefAddr )     &  &     ( addr . getType (  )  . equalsIgnoreCase (  \" URL \"  )  )  )     {", "String   url    =     (  ( String )     ( addr . getContent (  )  )  )  ;", "ObjectFactory   answer    =     . processURL ( url ,    environment )  ;", "if    ( answer    !  =    null )     {", "return   answer ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["lookForURLs"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( refInfo   instanceof   String )     {", "String   url    =     (  ( String )     ( refInfo )  )  ;", "String   scheme    =     . getURLScheme ( url )  ;", "if    ( scheme    !  =    null )     {", "ObjectFactory   answer    =     . getURLObjectFactory ( scheme ,    url ,    environment )  ;", "if    ( answer    !  =    null )     {", "return   answer ;", "}", "}", "}", "if    ( refInfo   instanceof   String [  ]  )     {", "String [  ]    urls    =     (  ( String [  ]  )     ( refInfo )  )  ;", "for    ( int   i    =     0  ;    i    <     ( urls . length )  ;    i +  +  )     {", "String   scheme    =     . getURLScheme ( urls [ i ]  )  ;", "if    ( scheme    !  =    null )     {", "ObjectFactory   answer    =     . getURLObjectFactory ( scheme ,    urls [ i ]  ,    environment )  ;", "if    ( answer    !  =    null )     {", "return   answer ;", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["processURL"], "fileName": "org.jboss.as.naming.context.ObjectFactoryBuilder"}, {"methodBody": ["METHOD_START", "{", "String   bindName ;", "if    ( jndiName . startsWith (  \" java :  \"  )  )     {", "bindName    =    jndiName . substring (  5  )  ;", "} else", "if    (  (  (  !  ( jndiName . startsWith (  \" jboss \"  )  )  )     &  &     (  !  ( jndiName . startsWith (  \" global \"  )  )  )  )     &  &     (  !  ( jndiName . startsWith (  \"  /  \"  )  )  )  )     {", "bindName    =     \"  /  \"     +    jndiName ;", "} else    {", "bindName    =    jndiName ;", "}", "final   ServiceName   parentContextName ;", "if    ( bindName . startsWith (  \" jboss / exported /  \"  )  )     {", "parentContextName    =    ContextNames . EXPORTED _ CONTEXT _ SERVICE _ NAME ;", "bindName    =    bindName . substring (  1  5  )  ;", "} else", "if    ( bindName . startsWith (  \" jboss /  \"  )  )     {", "parentContextName    =    ContextNames . JBOSS _ CONTEXT _ SERVICE _ NAME ;", "bindName    =    bindName . substring (  6  )  ;", "} else", "if    ( bindName . startsWith (  \" global /  \"  )  )     {", "parentContextName    =    ContextNames . GLOBAL _ CONTEXT _ SERVICE _ NAME ;", "bindName    =    bindName . substring (  7  )  ;", "} else", "if    ( bindName . startsWith (  \"  /  \"  )  )     {", "parentContextName    =    ContextNames . JAVA _ CONTEXT _ SERVICE _ NAME ;", "bindName    =    bindName . substring (  1  )  ;", "} else    {", "throw   logging . NamingLogger . ROOT _ LOGGER . illegalContextInName ( jndiName )  ;", "}", "return   new   ContextNames . BindInfo ( parentContextName ,    bindName )  ;", "}", "METHOD_END"], "methodName": ["bindInfoFor"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "if    ( context . startsWith (  \" java :  \"  )  )     {", "final   String   namespace ;", "final   int   i    =    context . indexOf (  '  /  '  )  ;", "if    ( i    =  =     (  -  1  )  )     {", "namespace    =    context . substring (  5  )  ;", "} else", "if    ( i    =  =     5  )     {", "return   new    . BindInfo (  . JAVA _ CONTEXT _ SERVICE _ NAME ,    context . substring (  6  )  )  ;", "} else    {", "namespace    =    context . substring (  5  ,    i )  ;", "}", ". sanitazeNameSpace ( namespace ,    context )  ;", "if    ( namespace . equals (  \" global \"  )  )     {", "return   new    . BindInfo (  . GLOBAL _ CONTEXT _ SERVICE _ NAME ,    context . substring (  1  2  )  )  ;", "} else", "if    ( namespace . equals (  \" jboss \"  )  )     {", "String   rest    =    context . substring ( i )  ;", "if    ( rest . startsWith (  \"  / exported /  \"  )  )     {", "return   new    . BindInfo (  . EXPORTED _ CONTEXT _ SERVICE _ NAME ,    context . substring (  2  0  )  )  ;", "} else    {", "return   new    . BindInfo (  . JBOSS _ CONTEXT _ SERVICE _ NAME ,    context . substring (  1  1  )  )  ;", "}", "} else", "if    ( namespace . equals (  \" app \"  )  )     {", "return   new    . BindInfo (  . contextServiceNameOfApplication ( app )  ,    context . substring (  9  )  )  ;", "} else", "if    ( namespace . equals (  \" module \"  )  )     {", "return   new    . BindInfo (  . contextServiceNameOfModule ( app ,    module )  ,    context . substring (  1  2  )  )  ;", "} else", "if    ( namespace . equals (  \" comp \"  )  )     {", "return   new    . BindInfo (  . contextServiceNameOfComponent ( app ,    module ,    comp )  ,    context . substring (  1  0  )  )  ;", "} else    {", "return   new    . BindInfo (  . JBOSS _ CONTEXT _ SERVICE _ NAME ,    context )  ;", "}", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["bindInfoFor"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "if    ( envEntryName . startsWith (  \" java :  \"  )  )     {", "if    ( useCompNamespace )     {", "return    . bindInfoFor ( app ,    module ,    comp ,    envEntryName )  ;", "} else    {", "if    ( envEntryName . startsWith (  \" java : comp \"  )  )     {", "return    . bindInfoFor ( app ,    module ,    module ,     (  \" java : module \"     +     ( envEntryName . substring (  \" java : comp \"  . length (  )  )  )  )  )  ;", "} else    {", "return    . bindInfoFor ( app ,    module ,    module ,    envEntryName )  ;", "}", "}", "} else    {", "if    ( useCompNamespace )     {", "return    . bindInfoFor ( app ,    module ,    comp ,     (  \" java : comp / env /  \"     +    envEntryName )  )  ;", "} else    {", "return    . bindInfoFor ( app ,    module ,    module ,     (  \" java : module / env /  \"     +    envEntryName )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["bindInfoForEnvEntry"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "return   parentName . append ( relativeName . split (  \"  /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildServiceName"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . APPLICATION _ CONTEXT _ SERVICE _ NAME . append ( app )  ;", "}", "METHOD_END"], "methodName": ["contextServiceNameOfApplication"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . COMPONENT _ CONTEXT _ SERVICE _ NAME . append ( app ,    module ,    comp )  ;", "}", "METHOD_END"], "methodName": ["contextServiceNameOfComponent"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . MODULE _ CONTEXT _ SERVICE _ NAME . append ( app ,    module )  ;", "}", "METHOD_END"], "methodName": ["contextServiceNameOfModule"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "if    ( namespace . contains (  \"  :  \"  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . invalidJndiName ( in )  ;", "}", "}", "METHOD_END"], "methodName": ["sanitazeNameSpace"], "fileName": "org.jboss.as.naming.deployment.ContextNames"}, {"methodBody": ["METHOD_START", "{", "return   externalContexts ;", "}", "METHOD_END"], "methodName": ["getExternalContexts"], "fileName": "org.jboss.as.naming.deployment.ExternalContextsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   new   JndiName ( this ,    local )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.jboss.as.naming.deployment.JndiName"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   absolute    =    new   StringBuilder (  )  ;", "if    (  ( parent )     !  =    null )     {", "absolute . append ( parent )  . append (  . ENTRY _ SEPARATOR )  ;", "}", "absolute . append ( local )  ;", "return   absolute . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getAbsoluteName"], "fileName": "org.jboss.as.naming.deployment.JndiName"}, {"methodBody": ["METHOD_START", "{", "return   local ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.naming.deployment.JndiName"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.jboss.as.naming.deployment.JndiName"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name    =  =    null )     |  |     ( name . isEmpty (  )  )  )", "throw   logging . NamingLogger . ROOT _ LOGGER . invalidJndiName ( name )  ;", "final   String [  ]    parts    =    name . split ( JndiName . ENTRY _ SEPARATOR )  ;", "JndiName   current    =    null ;", "for    ( String   part    :    parts )     {", "current    =    new   JndiName ( current ,    part )  ;", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.jboss.as.naming.deployment.JndiName"}, {"methodBody": ["METHOD_START", "{", "return   getAbsoluteName (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.naming.deployment.JndiName"}, {"methodBody": ["METHOD_START", "{", "return   JndiNamingDependencyProcessor . serviceName ( deploymentUnit . getServiceName (  )  )  ;", "}", "METHOD_END"], "methodName": ["serviceName"], "fileName": "org.jboss.as.naming.deployment.JndiNamingDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnitServiceName . append ( JndiNamingDependencyProcessor . JNDI _ DEPENDENCY _ SERVICE )  ;", "}", "METHOD_END"], "methodName": ["serviceName"], "fileName": "org.jboss.as.naming.deployment.JndiNamingDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "return   contextValue ;", "}", "METHOD_END"], "methodName": ["getContextInjector"], "fileName": "org.jboss.as.naming.deployment.NamingLookupValue"}, {"methodBody": ["METHOD_START", "{", "final   Context   context    =    contextValue . getValue (  )  ;", "try    {", "return    (  ( T )     ( context . lookup ( contextName )  )  )  ;", "}    catch    ( NamingException   e )     {", "throw   gger . ROOT _ LOGGER . entryNotRegistered ( e ,    contextName ,    context )  ;", "}", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.naming.deployment.NamingLookupValue"}, {"methodBody": ["METHOD_START", "{", "return   new   NamingContext (  ( name    !  =    null    ?    name    :    new   CompositeName (  \"  \"  )  )  ,    environment )  ;", "}", "METHOD_END"], "methodName": ["getObjectInstance"], "fileName": "org.jboss.as.naming.interfaces.java.javaURLContextFactory"}, {"methodBody": ["METHOD_START", "{", "this . extensions . add ( extension )  ;", "}", "METHOD_END"], "methodName": ["addExtension"], "fileName": "org.jboss.as.naming.management.JndiViewExtensionRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . extensions ;", "}", "METHOD_END"], "methodName": ["getExtensions"], "fileName": "org.jboss.as.naming.management.JndiViewExtensionRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.naming.management.JndiViewExtensionRegistry"}, {"methodBody": ["METHOD_START", "{", "this . extensions . remove ( extension )  ;", "}", "METHOD_END"], "methodName": ["removeExtension"], "fileName": "org.jboss.as.naming.management.JndiViewExtensionRegistry"}, {"methodBody": ["METHOD_START", "{", "this . extensions    =    new   ArrayList < JndiViewExtension >  (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.naming.management.JndiViewExtensionRegistry"}, {"methodBody": ["METHOD_START", "{", "this . extensions    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.naming.management.JndiViewExtensionRegistry"}, {"methodBody": ["METHOD_START", "{", "final   NamingEnumeration < NameClassPair >    entries    =    context . list (  \"  \"  )  ;", "while    ( entries . hasMore (  )  )     {", "final   NameClassPair   pair    =    entries . next (  )  ;", "final   ModelNode   node    =    current . get ( pair . getName (  )  )  ;", "node . get (  \" class - name \"  )  . set ( pair . getClassName (  )  )  ;", "try    {", "final   Object   value ;", "if    ( context   instanceof   NamingContext )     {", "value    =     (  ( NamingContext )     ( context )  )  . lookup ( pair . getName (  )  ,    false )  ;", "} else    {", "value    =    context . lookup ( pair . getName (  )  )  ;", "}", "if    ( value   instanceof   Context )     {", "addEntries ( node . get (  \" children \"  )  ,    Context . class . cast ( value )  )  ;", "} else", "if    ( value   instanceof   Reference )     {", "} else    {", "String   jndiViewValue    =    JndiViewManagedReferenceFactory . DEFAULT _ JNDI _ VIEW _ INSTANCE _ VALUE ;", "if    ( value   instanceof   JndiViewManagedReferenceFactory )     {", "try    {", "jndiViewValue    =    JndiViewManagedReferenceFactory . class . cast ( value )  . getJndiViewInstanceValue (  )  ;", "}    catch    ( Throwable   e )     {", "NamingLogger . ROOT _ LOGGER . failedToLookupJndiViewValue ( pair . getName (  )  ,    e )  ;", "}", "} else", "if    (  !  ( value   instanceof   ManagedReferenceFactory )  )     {", "jndiViewValue    =    String . valueOf ( value )  ;", "}", "node . get (  \" value \"  )  . set ( jndiViewValue )  ;", "}", "}    catch    ( NamingException   e )     {", "NamingLogger . ROOT _ LOGGER . failedToLookupJndiViewValue ( pair . getName (  )  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addEntries"], "fileName": "org.jboss.as.naming.management.JndiViewOperation"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   resultNode    =    context . getResult (  )  ;", "if    ( context . isNormalServer (  )  )     {", "context . addStep ( new   OperationStepHandler (  )     {", "public   void   execute ( final   OperationContext   context ,    final   ModelNode   operation )    throws   OperationFailedException    {", "final   ServiceRegistry   serviceRegistry    =    context . getServiceRegistry ( false )  ;", "final   ModelNode   contextsNode    =    resultNode . get (  \" java :    contexts \"  )  ;", "final   ServiceController <  ?  >    javaContextService    =    serviceRegistry . getService ( ContextNames . JAVA _ CONTEXT _ SERVICE _ NAME )  ;", "final   NamingStore   javaContextNamingStore    =    NamingStore . class . cast ( getValue (  )  )  ;", "try    {", "addEntries ( contextsNode . get (  \" java :  \"  )  ,    new   NamingContext ( javaContextNamingStore ,    null )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   OperationFailedException ( e ,    new   ModelNode (  )  . set ( NamingLogger . ROOT _ LOGGER . failedToReadContextEntries (  \" java :  \"  )  )  )  ;", "}", "final   ServiceController <  ?  >    jbossContextService    =    serviceRegistry . getService ( ContextNames . JBOSS _ CONTEXT _ SERVICE _ NAME )  ;", "final   NamingStore   jbossContextNamingStore    =    NamingStore . class . cast ( jbossContextService . getValue (  )  )  ;", "try    {", "addEntries ( contextsNode . get (  \" java : jboss \"  )  ,    new   NamingContext ( jbossContextNamingStore ,    null )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   OperationFailedException ( e ,    new   ModelNode (  )  . set ( NamingLogger . ROOT _ LOGGER . failedToReadContextEntries (  \" java : jboss \"  )  )  )  ;", "}", "final   ServiceController <  ?  >    exportedContextService    =    serviceRegistry . getService ( ContextNames . EXPORTED _ CONTEXT _ SERVICE _ NAME )  ;", "final   NamingStore   exportedContextNamingStore    =    NamingStore . class . cast ( exportedContextService . getValue (  )  )  ;", "try    {", "addEntries ( contextsNode . get (  \" java : jboss / exported \"  )  ,    new   NamingContext ( exportedContextNamingStore ,    null )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   OperationFailedException ( e ,    new   ModelNode (  )  . set ( NamingLogger . ROOT _ LOGGER . failedToReadContextEntries (  \" java : jboss / exported \"  )  )  )  ;", "}", "final   ServiceController <  ?  >    globalContextService    =    serviceRegistry . getService ( ContextNames . GLOBAL _ CONTEXT _ SERVICE _ NAME )  ;", "final   NamingStore   globalContextNamingStore    =    NamingStore . class . cast ( globalContextService . getValue (  )  )  ;", "try    {", "addEntries ( contextsNode . get (  \" java : global \"  )  ,    new   NamingContext ( globalContextNamingStore ,    null )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   OperationFailedException ( e ,    new   ModelNode (  )  . set ( NamingLogger . ROOT _ LOGGER . failedToReadContextEntries (  \" java : global \"  )  )  )  ;", "}", "final   ServiceController <  ?  >    extensionRegistryController    =    serviceRegistry . getService ( JndiViewExtensionRegistry . SERVICE _ NAME )  ;", "if    ( extensionRegistryController    !  =    null )     {", "final   JndiViewExtensionRegistry   extensionRegistry    =    JndiViewExtensionRegistry . class . cast ( extensionRegistryController . getValue (  )  )  ;", "for    ( JndiViewExtension   extension    :    extensionRegistry . getExtensions (  )  )     {", "extension . execute ( new   JndiViewExtensionContext (  )     {", "public   OperationContext   getOperationContext (  )     {", "return   context ;", "}", "public   ModelNode   getResult (  )     {", "return   resultNode ;", "}", "public   void   addEntries ( ModelNode   current ,    Context   context )    throws   NamingException    {", ". this . addEntries ( current ,    context )  ;", "}", "}  )  ;", "}", "}", "context . completeStep ( NOOP _ ROLLBACK _ HANDLER )  ;", "}", "}  ,    RUNTIME )  ;", "} else    {", "throw   new   OperationFailedException ( NamingLogger . ROOT _ LOGGER . jndiViewNotAvailable (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.naming.management.JndiViewOperation"}, {"methodBody": ["METHOD_START", "{", "return   namingStore ;", "}", "METHOD_END"], "methodName": ["getNamingStore"], "fileName": "org.jboss.as.naming.remote.HttpRemoteNamingServerService"}, {"methodBody": ["METHOD_START", "{", "return   pathHandlerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getPathHandlerInjectedValue"], "fileName": "org.jboss.as.naming.remote.HttpRemoteNamingServerService"}, {"methodBody": ["METHOD_START", "{", "return   endpoint ;", "}", "METHOD_END"], "methodName": ["getEndpointInjector"], "fileName": "org.jboss.as.naming.remote.RemoteNamingServerService"}, {"methodBody": ["METHOD_START", "{", "return   namingStore ;", "}", "METHOD_END"], "methodName": ["getNamingStoreInjector"], "fileName": "org.jboss.as.naming.remote.RemoteNamingServerService"}, {"methodBody": ["METHOD_START", "{", "return   remoteNamingService ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.naming.remote.RemoteNamingServerService"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Context   namingContext    =    new   NamingContext ( namingStore . getValue (  )  ,    new   Hashtable < String ,    Object >  (  )  )  ;", "remoteNamingService    =    new   ice ( namingContext )  ;", "remoteNamingService . start ( endpoint . getValue (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   StartException (  \" Failed   to   start   remote   naming   service \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.naming.remote.RemoteNamingServerService"}, {"methodBody": ["METHOD_START", "{", "try    {", "rice . stop (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   IllegalStateException (  \" Failed   to   stop   remote   naming   service \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.naming.remote.RemoteNamingServerService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( refcnt )     !  =    null )     {", "refcnt . crementAndGet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["acquire"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "return   managedReferenceFactory ;", "}", "METHOD_END"], "methodName": ["getManagedObjectInjector"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "return   namingStoreValue ;", "}", "METHOD_END"], "methodName": ["getNamingStoreInjector"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "final   ServiceController <  ?  >    serviceController    =    this . controller ;", "return   serviceController    !  =    null    ?    serviceController . getName (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "return   managedReferenceFactory . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( refcnt )     !  =    null )     &  &     (  ( refcnt . decrementAndGet (  )  )     <  =     0  )  )     &  &     (  ( controller )     !  =    null )  )     {", "controllertMode ( REMOVE )  ;", "return   true ;", "}", "return   fa ;", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "final   ServiceBasedNamingStore   namingStore    =    namingStoreValue . getValue (  )  ;", "controller    =    context . getController (  )  ;", "namingStore . add ( controller . getName (  )  )  ;", "NamingLogger . ROOT _ LOGGER . tracef (  \" Bound   resource    % s   into   naming   store    % s    ( service   name    % s )  \"  ,    name ,    namingStore ,    controller . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "final   ServiceBasedNamingStore   namingStore    =    namingStoreValue . getValue (  )  ;", "namingStore . remove ( controller . getName (  )  )  ;", "NamingLogger . ROOT _ LOGGER . tracef (  \" Unbound   resource    % s   into   naming   store    % s    ( service   name    % s )  \"  ,    name ,    namingStore ,    context . getController (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.naming.service.BinderService"}, {"methodBody": ["METHOD_START", "{", "return   globalNamingStore ;", "}", "METHOD_END"], "methodName": ["getGlobalNamingStore"], "fileName": "org.jboss.as.naming.service.DefaultNamespaceContextSelectorService"}, {"methodBody": ["METHOD_START", "{", "return   jbossNamingStore ;", "}", "METHOD_END"], "methodName": ["getJbossNamingStore"], "fileName": "org.jboss.as.naming.service.DefaultNamespaceContextSelectorService"}, {"methodBody": ["METHOD_START", "{", "return   remoteExposedNamingStore ;", "}", "METHOD_END"], "methodName": ["getRemoteExposedNamingStore"], "fileName": "org.jboss.as.naming.service.DefaultNamespaceContextSelectorService"}, {"methodBody": ["METHOD_START", "{", "return   externalContextsInjectedValue ;", "}", "METHOD_END"], "methodName": ["getExternalContextsInjector"], "fileName": "org.jboss.as.naming.service.ExternalContextBinderService"}, {"methodBody": ["METHOD_START", "{", "return   namingStore ;", "}", "METHOD_END"], "methodName": ["getNamingStore"], "fileName": "org.jboss.as.naming.service.NamingService"}, {"methodBody": ["METHOD_START", "{", "return   namingStore . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.naming.service.NamingService"}, {"methodBody": ["METHOD_START", "{", "NamingLogger . ROOT _ LOGGER . startingService (  )  ;", "try    {", "NamingContext . setActiveNamingStore ( namingStore . getValue (  )  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   StartException ( NamingLogger . ROOT _ LOGGER . failedToStart (  \" naming   service \"  )  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.naming.service.NamingService"}, {"methodBody": ["METHOD_START", "{", "NamingContext . setActiveNamingStore ( null )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.naming.service.NamingService"}, {"methodBody": ["METHOD_START", "{", "return   store ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.naming.service.NamingStoreService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( store )     =  =    null )     {", "final   ServiceRegistry   serviceRegistry    =    context . getController (  )  . getServiceContainer (  )  ;", "final   ServiceName   serviceNameBase    =    context . getController (  )  . getName (  )  ;", "final   ServiceTarget   serviceTarget    =    context . getChildTarget (  )  ;", "store    =     ( readOnly )     ?    new   ServiceBased ( serviceRegistry ,    serviceNameBase )     :    new   WritableServiceBased ( serviceRegistry ,    serviceNameBase ,    serviceTarget )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.naming.service.NamingStoreService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( store )     !  =    null )     {", "try    {", "store . close (  )  ;", "store    =    null ;", "}    catch    ( Exception   e )     {", "throw   Logger . ROOT _ LOGGER . failedToDestroyRootContext ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.naming.service.NamingStoreService"}, {"methodBody": ["METHOD_START", "{", "if    ( localName    =  =    null )", "return   null ;", "final      directoryGrouping    =     . MAP . get ( localName . toLowerCase (  )  )  ;", "return   directoryGrouping    =  =    null    ?     . valueOf ( localName . toUpperCase (  )  )     :    directoryGrouping ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.naming.subsystem.BindingType"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelNode (  )  . set ( toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toModelNode"], "fileName": "org.jboss.as.naming.subsystem.BindingType"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type    =  =    null )     |  |     ( type . isEmpty (  )  )  )     |  |     ( type . equals ( String . class . getName (  )  )  )  )     {", "return   value ;", "} else", "if    (  ( type . equals (  \" char \"  )  )     |  |     ( type . equals (  \" Character \"  )  )  )     {", "return   value . charAt (  0  )  ;", "} else", "if    (  ( type . equals (  \" byte \"  )  )     |  |     ( type . equals (  \" Byte \"  )  )  )     {", "return   Byte . parseByte ( value )  ;", "} else", "if    (  ( type . equals (  \" short \"  )  )     |  |     ( type . equals (  \" Short \"  )  )  )     {", "return   Short . parseShort ( value )  ;", "} else", "if    (  ( type . equals (  \" int \"  )  )     |  |     ( type . equals (  \" Integer \"  )  )  )     {", "return   Integer . parseInt ( value )  ;", "} else", "if    (  ( type . equals (  \" long \"  )  )     |  |     ( type . equals (  \" Long \"  )  )  )     {", "return   Long . parseLong ( value )  ;", "} else", "if    (  ( type . equals (  \" float \"  )  )     |  |     ( type . equals (  \" Float \"  )  )  )     {", "return   Float . parseFloat ( value )  ;", "} else", "if    (  ( type . equals (  \" double \"  )  )     |  |     ( type . equals (  \" Double \"  )  )  )     {", "return   Double . parseDouble ( value )  ;", "} else", "if    (  ( type . equals (  \" boolean \"  )  )     |  |     ( type . equals (  \" Boolean \"  )  )  )     {", "return   Boolean . parseBoolean ( value )  ;", "} else", "if    ( type . equals ( getName (  )  )  )     {", "try    {", "return   new   URL ( value )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   logging . NamingLogger . ROOT _ LOGGER . unableToTransformURLBindingValue ( value ,    e )  ;", "}", "} else    {", "throw   logging . NamingLogger . ROOT _ LOGGER . unsupportedSimpleBindingType ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["coerceToType"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModuleIdentifier   moduleID    =    ModuleIdentifier . fromString ( NamingBindingResourceDefinition . MODULE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "final   String   className    =    NamingBindingResourceDefinition . CLASS . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   Module   module ;", "try    {", "module    =    Module . getBootModuleLoader (  )  . loadModule ( moduleID )  ;", "}    catch    ( ModuleLoadException   e )     {", "throw   NamingLogger . ROOT _ LOGGER . couldNotLoadModule ( moduleID )  ;", "}", "final   ObjectFactory   objectFactoryClassInstance ;", "final   ClassLoader   cl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( module . getClassLoader (  )  )  ;", "final   Class <  ?  >    clazz    =    module . getClassLoader (  )  . loadClass ( className )  ;", "objectFactoryClassInstance    =     (  ( ObjectFactory )     ( clazz . newInstance (  )  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   NamingLogger . ROOT _ LOGGER . couldNotLoadClassFromModule ( className ,    moduleID )  ;", "}    catch    ( InstantiationException   e )     {", "throw   NamingLogger . ROOT _ LOGGER . couldNotInstantiateClassInstanceFromModule ( className ,    moduleID )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   NamingLogger . ROOT _ LOGGER . couldNotInstantiateClassInstanceFromModule ( className ,    moduleID )  ;", "}    catch    ( ClassCastException   e )     {", "throw   NamingLogger . ROOT _ LOGGER . notAnInstanceOfObjectFactory ( className ,    moduleID )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( cl )  ;", "}", "return   objectFactoryClassInstance ;", "}", "METHOD_END"], "methodName": ["createObjectFactory"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   value    =    NamingBindingResourceDefinition . VALUE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   type ;", "if    ( model . hasDefined ( NamingSubsystemModel . TYPE )  )     {", "type    =    NamingBindingResourceDefinition . TYPE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "} else    {", "type    =    null ;", "}", "return   coerceToType ( value ,    type )  ;", "}", "METHOD_END"], "methodName": ["createSimpleBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "ManagedReferenceFactory   ref    =    service . getManagedObjectInjector (  )  . getValue (  )  ;", "if    ( ref   instanceof    . MutableManagedReferenceFactory )     {", ". MutableManagedReferenceFactory   factory    =     (  (  . MutableManagedReferenceFactory )     ( ref )  )  ;", "final   BindingType   type    =    BindingType . forName ( NamingBindingResourceDefinition . BINDING _ TYPE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "if    ( type    =  =     ( BindingType . SIMPLE )  )     {", "Object   bindValue    =    createSimpleBinding ( context ,    model )  ;", "factory . setFactory ( new   ValueManagedReferenceFactory ( new   ImmediateValue < Object >  ( bindValue )  )  )  ;", "service . setSource ( bindValue )  ;", "} else", "if    ( type    =  =     ( BindingType . OBJECT _ FACTORY )  )     {", "final   ObjectFactory   objectFactoryClassInstance    =    createObjectFactory ( context ,    model )  ;", "final   Hashtable < String ,    String >    environment    =    getObjectFactoryEnvironment ( context ,    model )  ;", "factory . setFactory ( new    . ObjectFactoryManagedReference ( objectFactoryClassInstance ,    service . getName (  )  ,    environment )  )  ;", "service . setSource ( objectFactoryClassInstance )  ;", "} else", "if    ( type    =  =     ( BindingType . LOOKUP )  )     {", "final   String   lookup    =    NamingBindingResourceDefinition . LOOKUP . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "factory . setFactory ( new    . LookupManagedReferenceFactory ( lookup )  )  ;", "service . setSource ( null )  ;", "} else", "if    ( type    =  =     ( BindingType . EXTERNAL _ CONTEXT )  )     {", "throw   NamingLogger . ROOT _ LOGGER . cannotRebindExternalContext (  )  ;", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . unknownBindingType ( type . toString (  )  )  ;", "}", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . cannotRebindExternalContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doRebind"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "Hashtable < String ,    String >    environment ;", "Map < String ,    String >    resolvedModelAttribute    =    ResourceDefinition . ENVIRONMENT . unwrap ( context ,    model )  ;", "environment    =    new   Hashtable < String ,    String >  ( resolvedModelAttribute )  ;", "return   environment ;", "}", "METHOD_END"], "methodName": ["getObjectFactoryEnvironment"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   moduleID    =    NamingBindingResourceDefinition . MODULE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   className    =    NamingBindingResourceDefinition . CLASS . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ModelNode   cacheNode    =    NamingBindingResourceDefinition . CACHE . resolveModelAttribute ( context ,    model )  ;", "boolean   cache    =     ( cacheNode . isDefined (  )  )     ?    cacheNode . asBoolean (  )     :    false ;", "final   ObjectFactory   objectFactoryClassInstance    =    new   ExternalContextObjectFactory (  )  ;", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( name )  ;", "final   Hashtable < String ,    String >    environment    =    getObjectFactoryEnvironment ( context ,    model )  ;", "environment . put ( ExternalContextObjectFactory . CACHE _ CONTEXT ,    Boolean . toString ( cache )  )  ;", "environment . put ( ExternalContextObjectFactory . INITIAL _ CONTEXT _ CLASS ,    className )  ;", "environment . put ( ExternalContextObjectFactory . INITIAL _ CONTEXT _ MODULE ,    moduleID )  ;", "final   ExternalContextBinderService   binderService    =    new   ExternalContextBinderService ( name ,    objectFactoryClassInstance )  ;", "binderService . getManagedObjectInjector (  )  . inject ( new   ContextListAndJndiViewManagedReferenceFactory (  )     {", "@ Override", "public   ManagedReference   getReference (  )     {", "try    {", "final   Object   value    =    objectFactoryClassInstance . getObjectInstance ( name ,    null ,    null ,    environment )  ;", "return   new   ImmediateManagedReference ( value )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "@ Override", "public   String   getInstanceClassName (  )     {", "return   className ;", "}", "@ Override", "public   String   getJndiViewInstanceValue (  )     {", "final   ClassLoader   cl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( objectFactoryClassInstance . getClass (  )  . getClassLoader (  )  )  ;", "return   String . valueOf ( getReference (  )  . getInstance (  )  )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( cl )  ;", "}", "}", "}  )  ;", "serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . addDependency ( ExternalContextsService . SERVICE _ NAME ,    ExternalContexts . class ,    binderService . getExternalContextsInjector (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installExternalContext"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   lookup    =    NamingBindingResourceDefinition . LOOKUP . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( name )  ;", "final   BinderService   binderService    =    new   BinderService ( name )  ;", "binderService . getManagedObjectInjector (  )  . inject ( new    . MutableManagedReferenceFactory ( new    . LookupManagedReferenceFactory ( lookup )  )  )  ;", "serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installLookup"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "final   ObjectFactory   objectFactoryClassInstance    =    createObjectFactory ( context ,    model )  ;", "final   Hashtable < String ,    String >    environment    =    getObjectFactoryEnvironment ( context ,    model )  ;", "ContextListAndJndiViewManagedReferenceFactory   factory    =    new    . ObjectFactoryManagedReference ( objectFactoryClassInstance ,    name ,    environment )  ;", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( name )  ;", "final   BinderService   binderService    =    new   BinderService ( name ,    objectFactoryClassInstance )  ;", "binderService . getManagedObjectInjector (  )  . inject ( new    . MutableManagedReferenceFactory ( factory )  )  ;", "serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installObjectFactory"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "boolean   allowed    =    false ;", "for    ( String   ns    :     . GLOBAL _ NAMESPACES )     {", "if    ( name . startsWith ( ns )  )     {", "allowed    =    true ;", "break ;", "}", "}", "if    (  ! allowed )     {", "throw   NamingLogger . ROOT _ LOGGER . invalidNamespaceForBinding ( name ,    Arrays . toString (  . GLOBAL _ NAMESPACES )  )  ;", "}", "final   BindingType   type    =    BindingType . forName ( NamingBindingResourceDefinition . BINDING _ TYPE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "if    ( type    =  =     ( BindingType . SIMPLE )  )     {", "installSimpleBinding ( context ,    name ,    model )  ;", "} else", "if    ( type    =  =     ( BindingType . OBJECT _ FACTORY )  )     {", "installObjectFactory ( context ,    name ,    model )  ;", "} else", "if    ( type    =  =     ( BindingType . LOOKUP )  )     {", "installLookup ( context ,    name ,    model )  ;", "} else", "if    ( type    =  =     ( BindingType . EXTERNAL _ CONTEXT )  )     {", "installExternalContext ( context ,    name ,    model )  ;", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . unknownBindingType ( type . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["installRuntimeServices"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "Object   bindValue    =    createSimpleBinding ( context ,    model )  ;", "ValueManagedReferenceFactory   referenceFactory    =    new   ValueManagedReferenceFactory ( new   ImmediateValue < Object >  ( bindValue )  )  ;", "final   BinderService   binderService    =    new   BinderService ( name ,    bindValue )  ;", "binderService . getManagedObjectInjector (  )  . inject ( new    . MutableManagedReferenceFactory ( referenceFactory )  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( name )  ;", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "ServiceBuilder < ManagedReferenceFactory >    builder    =    serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  ;", "builder . install (  )  ;", "}", "METHOD_END"], "methodName": ["installSimpleBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingAdd"}, {"methodBody": ["METHOD_START", "{", "final   BindingType   type    =    BindingType . forName ( modelNode . require ( NamingSubsystemModel . BINDING _ TYPE )  . asString (  )  )  ;", "if    ( type    =  =     ( BindingType . SIMPLE )  )     {", "if    (  !  ( modelNode . hasDefined (  . VALUE . getName (  )  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . bindingTypeRequiresAttributeDefined ( type ,     . VALUE . getName (  )  )  ;", "}", "if    (  ( modelNode . hasDefined (  . CACHE . getName (  )  )  )     &  &     ( modelNode . get (  . CACHE . getName (  )  )  . asBoolean (  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . cacheNotValidForBindingType ( type )  ;", "}", "} else", "if    ( type    =  =     ( BindingType . OBJECT _ FACTORY )  )     {", "if    (  !  ( modelNode . hasDefined (  . MODULE . getName (  )  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . bindingTypeRequiresAttributeDefined ( type ,     . MODULE . getName (  )  )  ;", "}", "if    (  !  ( modelNode . hasDefined (  . CLASS . getName (  )  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . bindingTypeRequiresAttributeDefined ( type ,     . CLASS . getName (  )  )  ;", "}", "if    (  ( modelNode . hasDefined (  . CACHE . getName (  )  )  )     &  &     ( modelNode . get (  . CACHE . getName (  )  )  . asBoolean (  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . cacheNotValidForBindingType ( type )  ;", "}", "} else", "if    ( type    =  =     ( BindingType . EXTERNAL _ CONTEXT )  )     {", "if    (  ! allowExternal )     {", "throw   NamingLogger . ROOT _ LOGGER . cannotRebindExternalContext (  )  ;", "}", "if    (  !  ( modelNode . hasDefined (  . MODULE . getName (  )  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . bindingTypeRequiresAttributeDefined ( type ,     . MODULE . getName (  )  )  ;", "}", "if    (  !  ( modelNode . hasDefined (  . CLASS . getName (  )  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . bindingTypeRequiresAttributeDefined ( type ,     . CLASS . getName (  )  )  ;", "}", "} else", "if    ( type    =  =     ( BindingType . LOOKUP )  )     {", "if    (  !  ( modelNode . hasDefined (  . LOOKUP . getName (  )  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . bindingTypeRequiresAttributeDefined ( type ,     . LOOKUP . getName (  )  )  ;", "}", "if    (  ( modelNode . hasDefined (  . CACHE . getName (  )  )  )     &  &     ( modelNode . get (  . CACHE . getName (  )  )  . asBoolean (  )  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . cacheNotValidForBindingType ( type )  ;", "}", "} else    {", "throw   NamingLogger . ROOT _ LOGGER . unknownBindingType ( type . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateResourceModel"], "fileName": "org.jboss.as.naming.subsystem.NamingBindingResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardResourceDescriptionResolver ( keyPrefix ,    NamingExtension . RESOURCE _ NAME ,    NamingExtension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.naming.subsystem.NamingExtension"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . SIMPLE    :", "{", "this . parseSimpleBinding ( reader ,    operations )  ;", "break ;", "}", "case   Model . OBJECT _ FACTORY    :", "{", "this . parseObjectFactoryBinding ( reader ,    operations )  ;", "break ;", "}", "case   Model . LOOKUP    :", "{", "this . parseLookupBinding ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBindings"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "String   lookup    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . LOOKUP )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   LOOKUP    :", "lookup    =    NamingBindingResourceDefinition . LOOKUP . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( ModelDescriptionConstants . SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . BINDING ,    name )  ;", "final   ModelNode   bindingAdd    =    new   ModelNode (  )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . LOOKUP )  ;", "bindingAdd . get ( Model . LOOKUP )  . set ( lookup )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseLookupBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "String   module    =    null ;", "String   factory    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . MODULE ,    XMLAttribute . CLASS )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   MODULE    :", "module    =    NamingBindingResourceDefinition . MODULE . parse ( value ,    reader )  . asString (  )  ;", "break ;", "case   CLASS    :", "factory    =    NamingBindingResourceDefinition . CLASS . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( ModelDescriptionConstants . SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . BINDING ,    name )  ;", "final   ModelNode   bindingAdd    =    new   ModelNode (  )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . OBJECT _ FACTORY )  ;", "bindingAdd . get ( Model . MODULE )  . set ( module )  ;", "bindingAdd . get ( Model . CLASS )  . set ( factory )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseObjectFactoryBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "String   bindingValue    =    null ;", "String   type    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   VALUE    :", "bindingValue    =    NamingBindingResourceDefinition . VALUE . parse ( value ,    reader )  . asString (  )  ;", "break ;", "case   TYPE    :", "type    =    NamingBindingResourceDefinition . TYPE . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( ModelDescriptionConstants . SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . BINDING ,    name )  ;", "final   ModelNode   bindingAdd    =    new   ModelNode (  )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . SIMPLE )  ;", "bindingAdd . get ( Model . VALUE )  . set ( bindingValue )  ;", "if    ( type    !  =    null )     {", "bindingAdd . get ( Model . TYPE )  . set ( type )  ;", "}", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseSimpleBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . SIMPLE    :", "{", "this . parseSimpleBinding ( reader ,    operations )  ;", "break ;", "}", "case   Model . OBJECT _ FACTORY    :", "{", "this . parseObjectFactoryBinding ( reader ,    operations )  ;", "break ;", "}", "case   Model . LOOKUP    :", "{", "this . parseLookupBinding ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBindings"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "String   lookup    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . LOOKUP )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   LOOKUP    :", "lookup    =    NamingBindingResourceDefinition . LOOKUP . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( ModelDescriptionConstants . SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . BINDING ,    name )  ;", "final   ModelNode   bindingAdd    =    new   ModelNode (  )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . LOOKUP )  ;", "bindingAdd . get ( Model . LOOKUP )  . set ( lookup )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseLookupBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "String   module    =    null ;", "String   factory    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . MODULE ,    XMLAttribute . CLASS )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   MODULE    :", "module    =    NamingBindingResourceDefinition . MODULE . parse ( value ,    reader )  . asString (  )  ;", "break ;", "case   CLASS    :", "factory    =    NamingBindingResourceDefinition . CLASS . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( ModelDescriptionConstants . SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . BINDING ,    name )  ;", "final   ModelNode   bindingAdd    =    new   ModelNode (  )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . OBJECT _ FACTORY )  ;", "bindingAdd . get ( Model . MODULE )  . set ( module )  ;", "bindingAdd . get ( Model . CLASS )  . set ( factory )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseObjectFactoryBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "requireNoContent ( reader )  ;", "final   ModelNode   remoteNamingAdd    =    new   ModelNode (  )  ;", "remoteNamingAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "remoteNamingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( ModelDescriptionConstants . SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME )  ;", "remoteNamingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( Model . SERVICE ,    Model . REMOTE _ NAMING )  ;", "operations . add ( remoteNamingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseRemoteNaming"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "String   bindingValue    =    null ;", "String   type    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   VALUE    :", "bindingValue    =    NamingBindingResourceDefinition . VALUE . parse ( value ,    reader )  . asString (  )  ;", "break ;", "case   TYPE    :", "type    =    NamingBindingResourceDefinition . TYPE . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( ModelDescriptionConstants . SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . BINDING ,    name )  ;", "final   ModelNode   bindingAdd    =    new   ModelNode (  )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . SIMPLE )  ;", "bindingAdd . get ( Model . VALUE )  . set ( bindingValue )  ;", "if    ( type    !  =    null )     {", "bindingAdd . get ( Model . TYPE )  . set ( type )  ;", "}", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseSimpleBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . SIMPLE    :", "{", "this . parseSimpleBinding ( reader ,    operations ,    address )  ;", "break ;", "}", "case   Model . OBJECT _ FACTORY    :", "{", "this . parseObjectFactoryBinding ( reader ,    operations ,    address )  ;", "break ;", "}", "case   Model . LOOKUP    :", "{", "this . parseLookupBinding ( reader ,    operations ,    address )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBindings"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "final   ModelNode   bindingAdd    =    Util . createAddOperation (  )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . LOOKUP )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . LOOKUP )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   LOOKUP    :", "NamingBindingResourceDefinition . LOOKUP . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( parentAddress . append ( Model . BINDING ,    name )  . toModelNode (  )  )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseLookupBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "final   ModelNode   bindingAdd    =    Util . createAddOperation (  )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . OBJECT _ FACTORY )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . MODULE ,    XMLAttribute . CLASS )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   MODULE    :", "NamingBindingResourceDefinition . MODULE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "case   CLASS    :", "NamingBindingResourceDefinition . CLASS . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( parentAddress . append ( Model . BINDING ,    name )  . toModelNode (  )  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   ENVIRONMENT    :", "{", "parseObjectFactoryBindingEnvironment ( reader ,    bindingAdd )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseObjectFactoryBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   ENVIRONMENT _ PROPERTY    :", "{", "final   String [  ]    array    =    requireAttributes ( reader ,    NAME . getLocalName (  )  ,    VALUE . getLocalName (  )  )  ;", "NamingBindingResourceDefinition . ENVIRONMENT . parseAndAddParameterElement ( array [  0  ]  ,    array [  1  ]  ,    bindingAdd ,    reader )  ;", "requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseObjectFactoryBindingEnvironment"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "requireNoContent ( reader )  ;", "operations . add ( Util . createAddOperation ( parent . append ( Model . SERVICE ,    Model . REMOTE _ NAMING )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseRemoteNaming"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "final   ModelNode   bindingAdd    =    Util . createAddOperation (  )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . SIMPLE )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   VALUE    :", "NamingBindingResourceDefinition . VALUE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "case   TYPE    :", "NamingBindingResourceDefinition . TYPE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   PathAddress   address    =    parentAddress . append ( Model . BINDING ,    name )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseSimpleBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . SIMPLE    :", "{", "this . parseSimpleBinding ( reader ,    operations ,    address )  ;", "break ;", "}", "case   Model . OBJECT _ FACTORY    :", "{", "this . parseObjectFactoryBinding ( reader ,    operations ,    address )  ;", "break ;", "}", "case   Model . LOOKUP    :", "{", "this . parseLookupBinding ( reader ,    operations ,    address )  ;", "break ;", "}", "case   Model . EXTERNAL _ CONTEXT    :", "{", "this . parseExternalContext ( reader ,    operations ,    address )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBindings"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "final   ModelNode   bindingAdd    =    Util . createAddOperation (  )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . EXTERNAL _ CONTEXT )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . CLASS ,    XMLAttribute . MODULE )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   MODULE    :", "NamingBindingResourceDefinition . MODULE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "case   CLASS    :", "NamingBindingResourceDefinition . CLASS . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "case   CACHE    :", "NamingBindingResourceDefinition . CACHE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( parentAddress . append ( Model . BINDING ,    name )  . toModelNode (  )  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   ENVIRONMENT    :", "{", "parseObjectFactoryBindingEnvironment ( reader ,    bindingAdd )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseExternalContext"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "final   ModelNode   bindingAdd    =    Util . createAddOperation (  )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . LOOKUP )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . LOOKUP )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   LOOKUP    :", "NamingBindingResourceDefinition . LOOKUP . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( parentAddress . append ( Model . BINDING ,    name )  . toModelNode (  )  )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseLookupBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "final   ModelNode   bindingAdd    =    Util . createAddOperation (  )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . OBJECT _ FACTORY )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . MODULE ,    XMLAttribute . CLASS )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   MODULE    :", "NamingBindingResourceDefinition . MODULE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "case   CLASS    :", "NamingBindingResourceDefinition . CLASS . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( parentAddress . append ( Model . BINDING ,    name )  . toModelNode (  )  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   ENVIRONMENT    :", "{", "parseObjectFactoryBindingEnvironment ( reader ,    bindingAdd )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseObjectFactoryBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   ENVIRONMENT _ PROPERTY    :", "{", "final   String [  ]    array    =    requireAttributes ( reader ,    NAME . getLocalName (  )  ,    VALUE . getLocalName (  )  )  ;", "NamingBindingResourceDefinition . ENVIRONMENT . parseAndAddParameterElement ( array [  0  ]  ,    array [  1  ]  ,    bindingAdd ,    reader )  ;", "requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseObjectFactoryBindingEnvironment"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "requireNoContent ( reader )  ;", "operations . add ( Util . createAddOperation ( parent . append ( Model . SERVICE ,    Model . REMOTE _ NAMING )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseRemoteNaming"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "final   ModelNode   bindingAdd    =    Util . createAddOperation (  )  ;", "bindingAdd . get ( Model . BINDING _ TYPE )  . set ( Model . SIMPLE )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value . trim (  )  ;", "break ;", "case   VALUE    :", "NamingBindingResourceDefinition . VALUE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "case   TYPE    :", "NamingBindingResourceDefinition . TYPE . parseAndSetParameter ( value ,    bindingAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "final   PathAddress   address    =    parentAddress . append ( Model . BINDING ,    name )  ;", "bindingAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( bindingAdd )  ;", "}", "METHOD_END"], "methodName": ["parseSimpleBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "final   NamingSubsystemNamespace   element    =    NamingSubsystemNamespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    NamingSubsystemNamespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemNamespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemNamespace"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   result    =    new   ModelNode (  )  ;", "result . get ( OUTCOME )  . set ( SUCCESS )  ;", "result . get ( RESULT )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["success"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   services    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXml ( getSubsystemXml (  )  )  . build (  )  ;", "final   ModelNode   addr    =    Operations . createAddress ( SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME ,    Model . BINDING ,     \" java : global / alookup \"  )  ;", "final   ModelNode   addOp    =    Operations . createAddOperation ( addr )  ;", "addOp . get ( Model . BINDING _ TYPE )  . set ( Model . LOOKUP )  ;", "final   ModelNode   compositeOp    =    CompositeOperationBuilder . create (  )  . addStep ( addOp )  . addStep ( Operations . createWriteAttributeOperation ( addr ,    Model . LOOKUP ,     \" java : global / a \"  )  )  . build (  )  . getOperation (  )  ;", "ModelTestUtils . checkOutcome ( services . executeOperation ( compositeOp )  )  ;", "}", "METHOD_END"], "methodName": ["testCompositeBindingOps"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   services    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXml ( getSubsystemXml (  )  )  . build (  )  ;", "final   ModelNode   addr    =    Operations . createAddress ( SUBSYSTEM ,    NamingExtension . SUBSYSTEM _ NAME ,    Model . BINDING ,     \" java : global / a \"  )  ;", "final   ModelNode   compositeOp    =    CompositeOperationBuilder . create (  )  . addStep ( Operations . createWriteAttributeOperation ( addr ,    Model . BINDING _ TYPE ,    Model . LOOKUP )  )  . addStep ( Operations . createWriteAttributeOperation ( addr ,    Model . LOOKUP ,     \" java : global / b \"  )  )  . build (  )  . getOperation (  )  ;", "ModelTestUtils . checkOutcome ( services . executeOperation ( compositeOp )  )  ;", "}", "METHOD_END"], "methodName": ["testCompositeBindingUpdate"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    createKernelServicesBuilder ( MANAGEMENT )  . build (  )  ;", "Assert . assertTrue ( services . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    list    =    parse ( ModelTestUtils . readResource ( this . getClass (  )  ,     \" subsystem . xml \"  )  )  ;", "for    ( ModelNode   addOp    :    list )     {", "PathAddress   addr    =    PathAddress . pathAddress ( addOp . require ( OP _ ADDR )  )  ;", "if    (  (  (  ( addr . size (  )  )     =  =     2  )     &  &     ( addr . getLastElement (  )  . getKey (  )  . equals ( Model . BINDING )  )  )     &  &     (  ( BindingType . forName ( addOp . get ( NamingBindingResourceDefinition . BINDING _ TYPE . getName (  )  )  . asString (  )  )  )     !  =     ( BindingType . EXTERNAL _ CONTEXT )  )  )     {", "addOp . get ( NamingBindingResourceDefinition . CACHE . getName (  )  )  . set ( true )  ;", "services . executeForFailure ( addOp )  ;", "addOp . remove ( NamingBindingResourceDefinition . CACHE . getName (  )  )  ;", "ModelTestUtils . checkOutcome ( services . executeOperation ( addOp )  )  ;", "ModelTestUtils . checkFailed ( services . executeOperation ( Util . getWriteAttributeOperation ( addr ,    NamingBindingResourceDefinition . CACHE . getName (  )  ,    new   ModelNode ( true )  )  )  )  ;", "} else    {", "ModelTestUtils . checkOutcome ( services . executeOperation ( addOp )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testOnlyExternalContextAllowsCache"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" subsystem . xml \"  ,    EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     3  )  ,     \" jboss - as - naming \"  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP6"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" subsystem . xml \"  ,    EAP _  7  _  0  _  0  ,    ModelVersion . create (  2  ,     0  )  ,     \" wildfly - naming \"  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP7"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    targetVersion )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . addMavenResourceURL ( String . format (  (  (  \"  % s :  \"     +    artifactId )     +     \"  :  % s \"  )  ,    controllerVersion . getMavenGroupId (  )  ,    controllerVersion . getMavenGavVersion (  )  )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( targetVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( subsystemXml )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( NamingExtension . SUBSYSTEM _ PATH )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    targetVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  )  ;", "OperationTransformer . TransformedOperation   transOp    =    mainServices . transformOperation ( targetVersion ,    Util . createOperation (  \" rebind \"  ,    subsystemAddress . append ( NamingSubsystemModel . BINDING _ PATH )  )  )  ;", "Assert . assertTrue ( transOp . getFailureDescription (  )  ,    transOp . rejectOperation (  . success (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformer"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "final   NamingSubsystemXMLAttribute   element    =    NamingSubsystemXMLAttribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    NamingSubsystemXMLAttribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLAttribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLAttribute"}, {"methodBody": ["METHOD_START", "{", "final   NamingSubsystemXMLElement   element    =    NamingSubsystemXMLElement . MAP . get ( localName )  ;", "return   element    =  =    null    ?    NamingSubsystemXMLElement . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLElement"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLElement"}, {"methodBody": ["METHOD_START", "{", "for    ( Property   binding    :    bindingModel . asPropertyList (  )  )     {", "final   String   type    =    binding . getValue (  )  . get ( Model . BINDING _ TYPE )  . asString (  )  ;", "if    ( type . equals ( Model . SIMPLE )  )     {", "writeSimpleBinding ( binding ,    writer )  ;", "} else", "if    ( type . equals ( Model . OBJECT _ FACTORY )  )     {", "writeObjectFactoryBinding ( binding ,    writer )  ;", "} else", "if    ( type . equals ( Model . LOOKUP )  )     {", "writeLookupBinding ( binding ,    writer )  ;", "} else", "if    ( type . equals ( Model . EXTERNAL _ CONTEXT )  )     {", "writeExternalContext ( binding ,    writer )  ;", "} else    {", "throw   new   XMLStreamException (  (  \" Unknown   binding   type    \"     +    type )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeBindings"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( NamingSubsystemXMLElement . EXTERNAL _ CONTEXT . getLocalName (  )  )  ;", "writer . writeAttribute ( NamingSubsystemXMLAttribute . NAME . getLocalName (  )  ,    binding . getName (  )  )  ;", "NamingBindingResourceDefinition . MODULE . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "NamingBindingResourceDefinition . CLASS . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "NamingBindingResourceDefinition . CACHE . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "NamingBindingResourceDefinition . ENVIRONMENT . marshallAsElement ( binding . getValue (  )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeExternalContext"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( NamingSubsystemXMLElement . LOOKUP . getLocalName (  )  )  ;", "writer . writeAttribute ( NamingSubsystemXMLAttribute . NAME . getLocalName (  )  ,    binding . getName (  )  )  ;", "NamingBindingResourceDefinition . LOOKUP . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeLookupBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( NamingSubsystemXMLElement . OBJECT _ FACTORY . getLocalName (  )  )  ;", "writer . writeAttribute ( NamingSubsystemXMLAttribute . NAME . getLocalName (  )  ,    binding . getName (  )  )  ;", "NamingBindingResourceDefinition . MODULE . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "NamingBindingResourceDefinition . CLASS . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "NamingBindingResourceDefinition . ENVIRONMENT . marshallAsElement ( binding . getValue (  )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeObjectFactoryBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( NamingSubsystemXMLElement . SIMPLE . getLocalName (  )  )  ;", "writer . writeAttribute ( NamingSubsystemXMLAttribute . NAME . getLocalName (  )  ,    binding . getName (  )  )  ;", "NamingBindingResourceDefinition . VALUE . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "NamingBindingResourceDefinition . TYPE . marshallAsAttribute ( binding . getValue (  )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeSimpleBinding"], "fileName": "org.jboss.as.naming.subsystem.NamingSubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "final   RemoteNamingServerService   remoteNamingServerService    =    new   RemoteNamingServerService (  )  ;", "final   ServiceBuilder < RemoteNamingService >    builder    =    context . getServiceTarget (  )  . addService ( RemoteNamingServerService . SERVICE _ NAME ,    remoteNamingServerService )  ;", "builder . addDependency ( SUBSYSTEM _ ENDPOINT ,    Endpoint . class ,    remoteNamingServerService . getEndpointInjector (  )  )  . addDependency ( ContextNames . EXPORTED _ CONTEXT _ SERVICE _ NAME ,    NamingStore . class ,    remoteNamingServerService . getNamingStoreInjector (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installRuntimeServices"], "fileName": "org.jboss.as.naming.subsystem.RemoteNamingAdd"}, {"methodBody": ["METHOD_START", "{", "( modCount )  +  +  ;", ". Entry < K ,    V >  [  ]    table    =    this . table ;", "for    ( int   i    =     0  ;    i    <     ( table . length )  ;    i +  +  )", "table [ i ]     =    null ;", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "try    {", "< K ,    V >    clone    =     (  (  < K ,    V >  )     ( super . clone (  )  )  )  ;", "clone . table    =    table . clone (  )  ;", "clone . entrySet    =    null ;", "clone . values    =    null ;", "clone . keySet    =    null ;", "return   clone ;", "}    catch    ( CloneNotSupportedException   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "key    =    FastCopyHashMap . maskNull ( key )  ;", "int   hash    =    FastCopyHashMap . hash ( key )  ;", "int   length    =    table . length ;", "int   index    =    FastCopyHashMap . index ( hash ,    length )  ;", "for    ( int   start    =    index ;     ;  )     {", "FastCopyHashMap . Entry < K ,    V >    e    =    table [ index ]  ;", "if    ( e    =  =    null )", "return   false ;", "if    (  (  ( e . hash )     =  =    hash )     &  &     ( FastCopyHashMap . eq ( key ,    e . key )  )  )", "return   true ;", "index    =    nextIndex ( index ,    length )  ;", "if    ( index    =  =    start )", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "for    ( FastCopyHashMap . Entry < K ,    V >    e    :    table )", "if    (  ( e    !  =    null )     &  &     ( FastCopyHashMap . eq ( value ,    e . value )  )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entrySet )     =  =    null )", "entrySet    =    new   EntrySet (  )  ;", "return   entrySet ;", "}", "METHOD_END"], "methodName": ["entrySet"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "return    ( o 1     =  =    o 2  )     |  |     (  ( o 1     !  =    null )     &  &     ( o 1  . equals ( o 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["eq"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "key    =    FastCopyHashMap . maskNull ( key )  ;", "int   hash    =    FastCopyHashMap . hash ( key )  ;", "int   length    =    table . length ;", "int   index    =    FastCopyHashMap . index ( hash ,    length )  ;", "for    ( int   start    =    index ;     ;  )     {", "FastCopyHashMap . Entry < K ,    V >    e    =    table [ index ]  ;", "if    ( e    =  =    null )", "return   null ;", "if    (  (  ( e . hash )     =  =    hash )     &  &     ( FastCopyHashMap . eq ( key ,    e . key )  )  )", "return   e . value ;", "index    =    nextIndex ( index ,    length )  ;", "if    ( index    =  =    start )", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =    key . hashCode (  )  ;", "h    ^  =     ( h    >  >  >     2  0  )     ^     ( h    >  >  >     1  2  )  ;", "return    ( h    ^     ( h    >  >  >     7  )  )     ^     ( h    >  >  >     4  )  ;", "}", "METHOD_END"], "methodName": ["hash"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "return   hashCode    &     ( length    -     1  )  ;", "}", "METHOD_END"], "methodName": ["index"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "int   c    =     1  ;", "while    ( c    <    initialCapacity )", "c    <  <  =     1  ;", "threshold    =     (  ( int )     ( c    *    loadFactor )  )  ;", "if    (  ( initialCapacity    >     ( threshold )  )     &  &     ( c    <     (  . MAXIMUM _ CAPACITY )  )  )     {", "c    <  <  =     1  ;", "threshold    =     (  ( int )     ( c    *    loadFactor )  )  ;", "}", "this . table    =     (  (  . Entry < K ,    V >  [  ]  )     ( new    . Entry [ c ]  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "return    ( size )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keySet )     =  =    null )", "keySet    =    new   KeySet (  )  ;", "return   keySet ;", "}", "METHOD_END"], "methodName": ["keySet"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "return   key    =  =    null    ?     (  ( K )     ( FastCopyHashMap . NULL )  )     :    key ;", "}", "METHOD_END"], "methodName": ["maskNull"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "index    =     ( index    >  =     ( length    -     1  )  )     ?     0     :    index    +     1  ;", "return   index ;", "}", "METHOD_END"], "methodName": ["nextIndex"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "int   optimal    =     0  ;", "int   total    =     0  ;", "int   totalSkew    =     0  ;", "int   maxSkew    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( table . length )  ;    i +  +  )     {", ". Entry < K ,    V >    e    =    table [ i ]  ;", "if    ( e    !  =    null )     {", "total +  +  ;", "int   target    =     . index ( e . hash ,    table . length )  ;", "if    ( i    =  =    target )", "optimal +  +  ;", "else    {", "int   skew    =    Math . abs (  ( i    -    target )  )  ;", "if    ( skew    >    maxSkew )", "maxSkew    =    skew ;", "totalSkew    +  =    skew ;", "}", "}", "}", "System . out . println (  (  \"    Size :                                      \"     +     ( size )  )  )  ;", "System . out . println (  (  \"    Real   Size :                       \"     +    total )  )  ;", "System . out . println (  (  (  (  (  \"    Optimal :                             \"     +    optimal )     +     \"     (  \"  )     +     (  (  (  ( float )     ( optimal )  )     *     1  0  0  )     /    total )  )     +     \"  %  )  \"  )  )  ;", "System . out . println (  (  \"    Average   Distnce :     \"     +     (  (  ( float )     ( totalSkew )  )     /     ( total    -    optimal )  )  )  )  ;", "System . out . println (  (  \"    Max   Distance :              \"     +    maxSkew )  )  ;", "}", "METHOD_END"], "methodName": ["printDebugStats"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "key    =    FastCopyHashMap . maskNull ( key )  ;", "FastCopyHashMap . Entry < K ,    V >  [  ]    table    =    this . table ;", "int   hash    =    FastCopyHashMap . hash ( key )  ;", "int   length    =    table . length ;", "int   index    =    FastCopyHashMap . index ( hash ,    length )  ;", "for    ( int   start    =    index ;     ;  )     {", "FastCopyHashMap . Entry < K ,    V >    e    =    table [ index ]  ;", "if    ( e    =  =    null )", "break ;", "if    (  (  ( e . hash )     =  =    hash )     &  &     ( FastCopyHashMap . eq ( key ,    e . key )  )  )     {", "table [ index ]     =    new   FastCopyHashMap . Entry < K ,    V >  ( e . key ,    e . hash ,    value )  ;", "return   e . value ;", "}", "index    =    nextIndex ( index ,    length )  ;", "if    ( index    =  =    start )", "throw   logging . NamingLogger . ROOT _ LOGGER . tableIsFull (  )  ;", "}", "( modCount )  +  +  ;", "table [ index ]     =    new   FastCopyHashMap . Entry < K ,    V >  ( key ,    hash ,    value )  ;", "if    (  (  +  +  ( size )  )     >  =     ( threshold )  )", "resize ( length )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "int   size    =    map . size (  )  ;", "if    ( size    =  =     0  )", "return ;", "if    ( size    >     ( threshold )  )     {", "if    ( size    >     (  . MAXIMUM _ CAPACITY )  )", "size    =     . MAXIMUM _ CAPACITY ;", "int   length    =    table . length ;", "while    ( length    <    size )", "length    <  <  =     1  ;", "resize ( length )  ;", "}", "for    ( Map . Entry <  ?    extends   K ,     ?    extends   V >    e    :    map . entrySet (  )  )", "put ( e . getKey (  )  ,    e . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "key    =    FastCopyHashMap . maskNull ( key )  ;", "FastCopyHashMap . Entry < K ,    V >  [  ]    table    =    this . table ;", "int   hash    =    FastCopyHashMap . hash ( key )  ;", "int   length    =    table . length ;", "int   index    =    FastCopyHashMap . index ( hash ,    length )  ;", "FastCopyHashMap . Entry < K ,    V >    e    =    table [ index ]  ;", "while    ( e    !  =    null )     {", "index    =    nextIndex ( index ,    length )  ;", "e    =    table [ index ]  ;", "}", "table [ index ]     =    new   FastCopyHashMap . Entry < K ,    V >  ( key ,    hash ,    value )  ;", "}", "METHOD_END"], "methodName": ["putForCreate"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "s . defaultReadObject (  )  ;", "int   size    =    s . readInt (  )  ;", "init ( size ,    loadFactor )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "K   key    =     (  ( K )     ( s . readObject (  )  )  )  ;", "V   value    =     (  ( V )     ( s . readObject (  )  )  )  ;", "putForCreate ( key ,    value )  ;", "}", "this . size    =    size ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "FastCopyHashMap . Entry < K ,    V >  [  ]    table    =    this . table ;", "int   length    =    table . length ;", "int   current    =    nextIndex ( start ,    length )  ;", "for    (  ;     ;  )     {", "FastCopyHashMap . Entry < K ,    V >    e    =    table [ current ]  ;", "if    ( e    =  =    null )", "return ;", "int   prefer    =    FastCopyHashMap . index ( e . hash ,    length )  ;", "if    (  (  ( current    <    prefer )     &  &     (  ( prefer    <  =    start )     |  |     ( start    <  =    current )  )  )     |  |     (  ( prefer    <  =    start )     &  &     ( start    <  =    current )  )  )     {", "table [ start ]     =    e ;", "table [ current ]     =    null ;", "start    =    current ;", "}", "current    =    nextIndex ( current ,    length )  ;", "}", "}", "METHOD_END"], "methodName": ["relocate"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "key    =    FastCopyHashMap . maskNull ( key )  ;", "FastCopyHashMap . Entry < K ,    V >  [  ]    table    =    this . table ;", "int   length    =    table . length ;", "int   hash    =    FastCopyHashMap . hash ( key )  ;", "int   start    =    FastCopyHashMap . index ( hash ,    length )  ;", "for    ( int   index    =    start ;     ;  )     {", "FastCopyHashMap . Entry < K ,    V >    e    =    table [ index ]  ;", "if    ( e    =  =    null )", "return   null ;", "if    (  (  ( e . hash )     =  =    hash )     &  &     ( FastCopyHashMap . eq ( key ,    e . key )  )  )     {", "table [ index ]     =    null ;", "relocate ( index )  ;", "( modCount )  +  +  ;", "( size )  -  -  ;", "return   e . value ;", "}", "index    =    nextIndex ( index ,    length )  ;", "if    ( index    =  =    start )", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "int   newLength    =    from    <  <     1  ;", "if    (  ( newLength    >     (  . MAXIMUM _ CAPACITY )  )     |  |     ( newLength    <  =    from )  )", "return ;", ". Entry < K ,    V >  [  ]    newTable    =    new    . Entry [ newLength ]  ;", ". Entry < K ,    V >  [  ]    old    =    table ;", "for    (  . Entry < K ,    V >    e    :    old )     {", "if    ( e    =  =    null )", "continue ;", "int   index    =     . index ( e . hash ,    newLength )  ;", "while    (  ( newTable [ index ]  )     !  =    null )", "index    =    nextIndex ( index ,    newLength )  ;", "newTable [ index ]     =    e ;", "}", "threshold    =     (  ( int )     (  ( loadFactor )     *    newLength )  )  ;", "table    =    newTable ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "return   size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "return   key    =  =     ( FastCopyHashMap . NULL )     ?    null    :    key ;", "}", "METHOD_END"], "methodName": ["unmaskNull"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values )     =  =    null )", "values    =    new   Values (  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "s . defaultWriteObject (  )  ;", "s . writeInt ( size )  ;", "for    (  . Entry < K ,    V >    e    :    table )     {", "if    ( e    !  =    null )     {", "s . writeObject (  . unmaskNull ( e . key )  )  ;", "s . writeObject ( e . value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.jboss.as.naming.util.FastCopyHashMap"}, {"methodBody": ["METHOD_START", "{", "return   new   CompositeName ( name )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.jboss.as.naming.util.NameParser"}, {"methodBody": ["METHOD_START", "{", "final   CannotProceedException   cpe    =    new   CannotProceedException (  )  ;", "cpe . setResolvedObj ( resolvedObject )  ;", "cpe . setRemainName ( remainName )  ;", "return   cpe ;", "}", "METHOD_END"], "methodName": ["cannotProceedException"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "Context   subctx    =    ctx ;", "for    ( int   pos    =     0  ;    pos    <     ( e . size (  )  )  ;    pos +  +  )     {", "final   String   ctxName    =    e . get ( pos )  ;", "try    {", "subctx    =     (  ( Context )     ( ctx . lookup ( ctxName )  )  )  ;", "}    catch    ( NameNotFoundException   e )     {", "subctx    =    ctx . createSubcontext ( ctxName )  ;", "}", "ctx    =    subctx ;", "}", "return   subctx ;", "}", "METHOD_END"], "methodName": ["createSubcontext"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "return   NamingLogger . ROOT _ LOGGER . emptyNameNotAllowed (  )  ;", "}", "METHOD_END"], "methodName": ["emptyNameException"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name . size (  )  )     >     0  )", "return   name . get (  (  ( name . size (  )  )     -     1  )  )  ;", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getLastComponent"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( name . isEmpty (  )  )     |  |     (  (  ( name . size (  )  )     =  =     1  )     &  &     (  \"  \"  . equals ( name . get (  0  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( name . isEmpty (  )  )     |  |     ( NamingUtils . getLastComponent ( name )  . equals (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isLastComponentEmpty"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   NameAlreadyBoundException ( name . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["nameAlreadyBoundException"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "return   NamingLogger . ROOT _ LOGGER . nameNotFoundInContext ( name ,    contextName )  ;", "}", "METHOD_END"], "methodName": ["nameNotFoundException"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "final   Iterator < T >    iterator    =    collection . iterator (  )  ;", "return   new   Enumeration < T >  (  )     {", "public   T   next (  )     {", "return   nextElement (  )  ;", "}", "public   boolean   hasMore (  )     {", "return   hasMoreElements (  )  ;", "}", "public   void   close (  )     {", "}", "public   boolean   hasMoreElements (  )     {", "return   iterator . hasNext (  )  ;", "}", "public   T   nextElement (  )     {", "return   iterator . next (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["namingEnumeration"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "final   NamingException   exception    =    new   NamingException ( message )  ;", "if    ( cause    !  =    null )", "exception . initCause ( cause )  ;", "return   exception ;", "}", "METHOD_END"], "methodName": ["namingException"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "final   NamingException   exception    =    NamingUtils . namingException ( message ,    cause )  ;", "exception . setRemainingName ( remainingName )  ;", "return   exception ;", "}", "METHOD_END"], "methodName": ["namingException"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   NotContextException ( name . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["notAContextException"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "final   Name   n    =    ctx . getNameParser (  \"  \"  )  . parse ( name )  ;", ". rebind ( ctx ,    n ,    value )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   size    =    name . size (  )  ;", "final   String   atom    =    name . get (  ( size    -     1  )  )  ;", "final   Context   parentCtx    =     . createSubcontext ( ctx ,    name . getPrefix (  ( size    -     1  )  )  )  ;", "parentCtx . rebind ( atom ,    value )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "NamingUtils . unbind ( ctx ,    ctx . getNameParser (  \"  \"  )  . parse ( name )  )  ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "ctx . unbind ( name )  ;", "int   sz    =    name . size (  )  ;", "while    (  (  -  - sz )     >     0  )     {", "Name   pname    =    name . getPrefix ( sz )  ;", "try    {", "ctx . destroySubcontext ( pname )  ;", "}    catch    ( Exception   e )     {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.jboss.as.naming.util.NamingUtils"}, {"methodBody": ["METHOD_START", "{", "return   deque . get (  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.naming.util.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "Object   o    =    st . peek (  )  ;", "if    ( o    =  =     (  . NULL _ VALUE )  )     {", "return   null ;", "} else    {", "return    (  ( E )     ( o )  )  ;", "}", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.jboss.as.naming.util.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "Object   o    =    st . pop (  )  ;", "if    ( o    =  =     (  . NULL _ VALUE )  )     {", "return   null ;", "} else    {", "return    (  ( E )     ( o )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jboss.as.naming.util.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "if    ( item    =  =    null )     {", "st . push (  . NULL _ VALUE )  ;", "} else    {", "st . push ( item )  ;", "}", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.naming.util.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Assert . checkNotNullParam (  \" name \"  ,    name )  ;", "return   name . equalsIgnoreCase (  \"  <  < ALL   BINDINGS >  >  \"  )     ?     \"  -  \"     :     . canonicalize 2  ( name )  ;", "}", "METHOD_END"], "methodName": ["canonicalize1"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   name . startsWith (  \" java :  \"  )     ?    name . substring (  5  )     :    name ;", "}", "METHOD_END"], "methodName": ["canonicalize2"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return    ( other   instanceof   JndiPermission )     &  &     ( equals (  (  ( JndiPermission )     ( other )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this )     =  =    other )     |  |     (  (  ( other    !  =    null )     &  &     ( getName (  )  . equals ( other . getName (  )  )  )  )     &  &     (  ( actionBits )     =  =     ( other . actionBits )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "switch    ( bit )     {", "case    . ACTION _ BIND    :", "return    \" bind \"  ;", "case    . ACTION _ REBIND    :", "return    \" rebind \"  ;", "case    . ACTION _ UNBIND    :", "return    \" unbind \"  ;", "case    . ACTION _ LOOKUP    :", "return    \" lookup \"  ;", "case    . ACTION _ LIST    :", "return    \" list \"  ;", "case    . ACTION _ LIST _ BINDINGS    :", "return    \" listBindings \"  ;", "case    . ACTION _ CREATE _ SUBCONTEXT    :", "return    \" createSubcontext \"  ;", "case    . ACTION _ DESTROY _ SUBCONTEXT    :", "return    \" destroySubcontext \"  ;", "case    . ACTION _ ADD _ NAMING _ LISTENER    :", "return    \" addNamingListener \"  ;", "default    :", "throw   Assert . impossibleSwitchCase ( bit )  ;", "}", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   actionBits ;", "}", "METHOD_END"], "methodName": ["getActionBits"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "final   String   actionString    =    this . actionString ;", "if    ( actionString    !  =    null )     {", "return   actionString ;", "}", "int   actionBits    =    this . actionBits ;", "if    ( actionBits    =  =     (  . ACTION _ ALL )  )     {", "return   this . actionString    =     \"  *  \"  ;", "}", "int   m    =    Integer . lowestOneBit ( actionBits )  ;", "if    ( m    !  =     0  )     {", "StringBuilder   b    =    new   StringBuilder (  )  ;", "b . append ( getAction ( m )  )  ;", "actionBits    &  =     ~ m ;", "while    ( actionBits    !  =     0  )     {", "m    =    Integer . lowestOneBit ( actionBits )  ;", "b . append (  '  ,  '  )  . append ( getAction ( m )  )  ;", "actionBits    &  =     ~ m ;", "}", "return   this . actionString    =    b . toString (  )  ;", "} else    {", "return   this . actionString    =     \"  \"  ;", "}", "}", "METHOD_END"], "methodName": ["getActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return    (  ( actionBits )     *     2  3  )     +     ( getName (  )  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "Assert . checkNotNullParam (  \" name \"  ,    name )  ;", "final   int   maskedBits    =    actionBits    &     (  . ACTION _ ALL )  ;", "return    (  (  ( this . actionBits )     &    maskedBits )     =  =    maskedBits )     &  &     ( impliesPath ( name )  )  ;", "}", "METHOD_END"], "methodName": ["implies"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   implies ( name ,    JndiPermission . parseActions ( actions )  )  ;", "}", "METHOD_END"], "methodName": ["implies"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return    ( permission   instanceof   JndiPermission )     &  &     ( implies (  (  ( JndiPermission )     ( permission )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["implies"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return    (  ( permission    !  =    null )     &  &     (  (  ( actionBits )     &     ( permission . actionBits )  )     =  =     ( permission . actionBits )  )  )     &  &     ( impliesPath ( permission . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["implies"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   yourName . startsWith (  \" java :  \"  )     ?    impliesPath 0  ( yourName . substring (  5  )  )     :    impliesPath 0  ( yourName )  ;", "}", "METHOD_END"], "methodName": ["impliesPath"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "final   String   myName    =    getName (  )  ;", "final   Iterator < String >    myIter    =    NameParser . nameIterator ( myName )  ;", "final   Iterator < String >    yourIter    =    NameParser . nameIterator ( yourName )  ;", "assert    ( myIter . hasNext (  )  )     &  &     ( yourIter . hasNext (  )  )  ;", "String   myNext ;", "String   yourNext ;", "for    (  ;     ;  )     {", "myNext    =    myIter . next (  )  ;", "yourNext    =    yourIter . next (  )  ;", "if    ( myNext . equals (  \"  -  \"  )  )     {", "return   true ;", "}", "if    (  (  !  ( myNext . equals (  \"  *  \"  )  )  )     &  &     (  !  ( myNext . equals ( yourNext )  )  )  )     {", "return   false ;", "}", "if    ( myIter . hasNext (  )  )     {", "if    (  !  ( yourIter . hasNext (  )  )  )     {", "return   false ;", "}", "} else    {", "return    !  ( yourIter . hasNext (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["impliesPath0"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   new   JndiPermissionCollection (  )  ;", "}", "METHOD_END"], "methodName": ["newPermissionCollection"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "switch    ( str )     {", "case    \"  *  \"     :", "case    \" all \"     :", "return    . ACTION _ ALL ;", "case    \" bind \"     :", "return    . ACTION _ BIND ;", "case    \" rebind \"     :", "return    . ACTION _ REBIND ;", "case    \" unbind \"     :", "return    . ACTION _ UNBIND ;", "case    \" lookup \"     :", "return    . ACTION _ LOOKUP ;", "case    \" list \"     :", "return    . ACTION _ LIST ;", "case    \" listBindings \"     :", "return    . ACTION _ LIST _ BINDINGS ;", "case    \" createSubcontext \"     :", "return    . ACTION _ CREATE _ SUBCONTEXT ;", "case    \" destroySubcontext \"     :", "return    . ACTION _ DESTROY _ SUBCONTEXT ;", "case    \" addNamingListener \"     :", "return    . ACTION _ ADD _ NAMING _ LISTENER ;", "default    :", "{", "throw   NamingLogger . ROOT _ LOGGER . invalidPermissionAction ( str )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseAction"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "int   actions    =     0  ;", "int   pos    =     0  ;", "int   idx    =    actionsString . indexOf (  '  ,  '  )  ;", "for    (  ;     ;  )     {", "String   str ;", "if    ( idx    =  =     (  -  1  )  )     {", "str    =    actionsString . substring ( pos ,    actionsString . length (  )  )  . trim (  )  ;", "if    (  !  ( str . isEmpty (  )  )  )", "actions    |  =     . parseAction ( str )  ;", "return   actions ;", "} else    {", "str    =    actionsString . substring ( pos ,    idx )  . trim (  )  ;", "pos    =    idx    +     1  ;", "if    (  !  ( str . isEmpty (  )  )  )", "actions    |  =     . parseAction ( str )  ;", "idx    =    actionsString . indexOf (  '  ,  '  ,    pos )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   withNewActions (  (  ( actionBits    &     ( JndiPermission . ACTION _ ALL )  )     |     ( this . actionBits )  )  )  ;", "}", "METHOD_END"], "methodName": ["withActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   withActions ( JndiPermission . parseActions ( Assert . checkNotNullParam (  \" actions \"  ,    actions )  )  )  ;", "}", "METHOD_END"], "methodName": ["withActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "actionBits    &  =    JndiPermission . ACTION _ ALL ;", "if    ( actionBits    =  =     ( this . actionBits )  )     {", "return   this ;", "} else    {", "return   new   JndiPermission ( getName (  )  ,    actionBits )  ;", "}", "}", "METHOD_END"], "methodName": ["withNewActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   withNewActions ( JndiPermission . parseActions ( Assert . checkNotNullParam (  \" actions \"  ,    actions )  )  )  ;", "}", "METHOD_END"], "methodName": ["withNewActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   withNewActions (  (  ( this . actionBits )     &     (  ~  ( actionBits    &     ( JndiPermission . ACTION _ ALL )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withoutActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   withoutActions ( JndiPermission . parseActions ( Assert . checkNotNullParam (  \" actions \"  ,    actions )  )  )  ;", "}", "METHOD_END"], "methodName": ["withoutActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "return   new   SerializedJndiPermission ( getName (  )  ,    getActions (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeReplace"], "fileName": "org.wildfly.naming.java.permission.JndiPermission"}, {"methodBody": ["METHOD_START", "{", "if    ( isReadOnly (  )  )     {", "throw   NamingLogger . ROOT _ LOGGER . cannotAddToReadOnlyPermissionCollection (  )  ;", "}", "if    (  !  ( permission   instanceof   JndiPermission )  )     {", "throw   NamingLogger . ROOT _ LOGGER . invalidPermission ( permission )  ;", "}", "final   AtomicReference < JndiPermission [  ]  >    permissions    =    this . permissions ;", "JndiPermission   jndiPermission    =     (  ( JndiPermission )     ( permission )  )  ;", "if    (  ( jndiPermission . getActionBits (  )  )     =  =     0  )     {", "return ;", "}", "JndiPermission [  ]    oldVal ;", "ArrayList < JndiPermission >    newVal ;", "boolean   added    =    false ;", "do    {", "oldVal    =    permissions . get (  )  ;", "newVal    =    new   ArrayList <  >  (  (  ( oldVal . length )     +     1  )  )  ;", "for    ( final   JndiPermission   testPerm    :    oldVal )     {", "if    ( testPerm . implies ( jndiPermission )  )     {", "return ;", "} else", "if    ( jndiPermission . implies ( testPerm )  )     {", "} else", "if    ( jndiPermission . getName (  )  . equals ( testPerm . getName (  )  )  )     {", "assert    ( jndiPermission . getActionBits (  )  )     !  =     ( testPerm . getActionBits (  )  )  ;", "jndiPermission    =    jndiPermission . withActions ( testPerm . getActionBits (  )  )  ;", "}", "}", "for    ( final   JndiPermission   testPerm    :    oldVal )     {", "if    (  !  ( jndiPermission . implies ( testPerm )  )  )     {", "newVal . add ( testPerm )  ;", "}", "}", "newVal . add ( jndiPermission )  ;", "}    while    (  !  ( permissions . compareAndSet ( oldVal ,    newVal . toArray (  . NO _ PERMISSIONS )  )  )     )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionCollection"}, {"methodBody": ["METHOD_START", "{", "final   JndiPermission [  ]    jndiPermissions    =    permissions . get (  )  ;", "return   new   Enumeration < Permission >  (  )     {", "int   i ;", "public   boolean   hasMoreElements (  )     {", "return    ( i )     <     ( jndiPermissions . length )  ;", "}", "public   Permission   nextElement (  )     {", "return   jndiPermissions [  (  ( i )  +  +  )  ]  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["elements"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionCollection"}, {"methodBody": ["METHOD_START", "{", "final   JndiPermission [  ]    jndiPermissions    =    permissions . get (  )  ;", "for    ( JndiPermission   jndiPermission    :    jndiPermissions )     {", "if    ( jndiPermission . implies ( permission )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["implies"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   SerializedJndiPermissionCollection ( isReadOnly (  )  ,    permissions . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeReplace"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   JndiPermissionNameParser . ParsingIterator ( string )  ;", "}", "METHOD_END"], "methodName": ["nameIterator"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionNameParser"}, {"methodBody": ["METHOD_START", "{", "return   new   JndiPermissionNameParser . SegmentsIterator ( segments )  ;", "}", "METHOD_END"], "methodName": ["segmentsIterator"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionNameParser"}, {"methodBody": ["METHOD_START", "{", "return   JndiPermissionNameParser . toArray ( iter ,     0  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionNameParser"}, {"methodBody": ["METHOD_START", "{", "if    ( iter . hasNext (  )  )     {", "String   next    =    iter . next (  )  ;", "String [  ]    array    =     . toArray ( iter ,     ( size    +     1  )  )  ;", "array [ size ]     =    next ;", "return   array ;", "} else    {", "return   new   String [ size ]  ;", "}", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionNameParser"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   JndiPermission (  \" foo \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \" foo \"  ,     \" all \"  )  )  ;", "assertEquals ( new   JndiPermission (  \" foo \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \" foo \"  ,     \" lookup , bind , rebind , unbind , list , listBindings , createSubcontext , destroySubcontext , addNamingListener \"  )  )  ;", "assertEquals ( new   JndiPermission (  \" foo \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \" foo \"  ,     \" unbind , list , listBindings , createSubcontext , destroySubcontext , addNamingListener , lookup , bind , rebind \"  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \" lookup \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo \"  ,     \"  \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \"  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \"  \"  )  )  )  ;", "assertFalse ( new   JndiPermission (  \" foo \"  ,     \"  \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \" bind \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo \"  ,     \"  \"  )  . withActions (  \" bind \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \" bind \"  )  )  )  ;", "assertFalse ( new   JndiPermission (  \" foo \"  ,     \" unbind \"  )  . withoutActions (  \" unbind \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \" unbind \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testActions"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionTestCase"}, {"methodBody": ["METHOD_START", "{", "final   PermissionCollection   permissionCollection    =    new   JndiPermission (  \"  \"  ,     \"  \"  )  . newPermissionCollection (  )  ;", "Enumeration < Permission >    e ;", "permissionCollection . add ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind \"  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind \"  )  )  )  ;", "assertFalse ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind , unbind \"  )  )  )  ;", "assertFalse ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" unbind \"  )  )  )  ;", "assertNotNull (  ( e    =    permissionCollection . elements (  )  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind \"  )  ,    e . nextElement (  )  )  ;", "assertFalse ( e . hasMoreElements (  )  )  ;", "permissionCollection . add ( new   JndiPermission (  \" foo / bar \"  ,     \" unbind \"  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind , unbind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" unbind \"  )  )  )  ;", "assertNotNull (  ( e    =    permissionCollection . elements (  )  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind , unbind \"  )  ,    e . nextElement (  )  )  ;", "assertFalse ( e . hasMoreElements (  )  )  ;", "permissionCollection . add ( new   JndiPermission (  \"  -  \"  ,     \" lookup \"  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind , unbind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" unbind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" baz / zap \"  ,     \" lookup \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \"  \"  ,     \" lookup \"  )  )  )  ;", "assertFalse ( permissionCollection . implies ( new   JndiPermission (  \" baz / zap \"  ,     \" lookup , bind , unbind \"  )  )  )  ;", "assertFalse ( permissionCollection . implies ( new   JndiPermission (  \" baz / zap \"  ,     \" unbind \"  )  )  )  ;", "assertNotNull (  ( e    =    permissionCollection . elements (  )  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind , unbind \"  )  ,    e . nextElement (  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \"  -  \"  ,     \" lookup \"  )  ,    e . nextElement (  )  )  ;", "assertFalse ( e . hasMoreElements (  )  )  ;", "permissionCollection . add ( new   JndiPermission (  \"  -  \"  ,     \" bind , unbind \"  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" lookup , bind , unbind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" foo / bar \"  ,     \" unbind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" baz / zap \"  ,     \" lookup \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \"  \"  ,     \" lookup \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" baz / zap \"  ,     \" lookup , bind , unbind \"  )  )  )  ;", "assertTrue ( permissionCollection . implies ( new   JndiPermission (  \" baz / zap \"  ,     \" unbind \"  )  )  )  ;", "assertNotNull (  ( e    =    permissionCollection . elements (  )  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \"  -  \"  ,     \" lookup , bind , unbind \"  )  ,    e . nextElement (  )  )  ;", "assertFalse ( e . hasMoreElements (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollection"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionTestCase"}, {"methodBody": ["METHOD_START", "{", "final   PermissionCollection   permissionCollection    =    new   JndiPermission (  \"  \"  ,     \"  \"  )  . newPermissionCollection (  )  ;", "permissionCollection . add ( new   JndiPermission (  \" foo / bar \"  ,     \" unbind , rebind \"  )  )  ;", "permissionCollection . setReadOnly (  )  ;", "try    {", "permissionCollection . add ( new   JndiPermission (  \" fob / baz \"  ,     \" unbind , rebind \"  )  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( SecurityException   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["testCollectionSecurity"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionTestCase"}, {"methodBody": ["METHOD_START", "{", "final   PermissionCollection   permissionCollection    =    new   JndiPermission (  \"  \"  ,     \"  \"  )  . newPermissionCollection (  )  ;", "permissionCollection . add ( new   JndiPermission (  \" foo / bar \"  ,     \" createSubcontext , rebind \"  )  )  ;", "permissionCollection . add ( new   JndiPermission (  \" foo \"  ,     \" addNamingListener \"  )  )  ;", "permissionCollection . add ( new   JndiPermission (  \"  -  \"  ,     \" lookup , rebind \"  )  )  ;", "final   PermissionCollection   other    =     (  ( PermissionCollection )     (  (  ( SerializedJndiPermissionCollection )     (  (  ( JndiPermissionCollection )     ( permissionCollection )  )  . writeReplace (  )  )  )  . readResolve (  )  )  )  ;", "Enumeration < Permission >    e ;", "assertNotNull (  ( e    =    other . elements (  )  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \" foo / bar \"  ,     \" createSubcontext , rebind \"  )  ,    e . nextElement (  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \" foo \"  ,     \" addNamingListener \"  )  ,    e . nextElement (  )  )  ;", "assertTrue ( e . hasMoreElements (  )  )  ;", "assertEquals ( new   JndiPermission (  \"  -  \"  ,     \" lookup , rebind \"  )  ,    e . nextElement (  )  )  ;", "assertFalse ( e . hasMoreElements (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionSerialization"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionTestCase"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   JndiPermission (  \"  <  < ALL   BINDINGS >  >  \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  )  ;", "assertTrue ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo /  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo / bar / baz / zap \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" java : foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  /  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  /  /  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  /  /  /  /  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo /  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo / bar / baz / zap \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" java :  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo /  -  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo / foo /  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo / foo / bar / baz / zap \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \" foo /  -  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" java : foo / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  *  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  *  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo \"  ,     \"  *  \"  )  )  )  ;", "assertFalse ( new   JndiPermission (  \"  *  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo / bar \"  ,     \"  *  \"  )  )  )  ;", "assertFalse ( new   JndiPermission (  \"  *  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \" foo /  \"  ,     \"  *  \"  )  )  )  ;", "assertFalse ( new   JndiPermission (  \"  *  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  *  /  *  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  /  *  \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( new   JndiPermission (  \"  *  / foo \"  ,     \"  *  \"  )  . implies ( new   JndiPermission (  \"  / foo \"  ,     \"  *  \"  )  )  )  ;", "assertEquals ( new   JndiPermission (  \" java :  \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \"  \"  ,     \"  *  \"  )  )  ;", "assertEquals ( new   JndiPermission (  \" java :  /  \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \"  /  \"  ,     \"  *  \"  )  )  ;", "assertEquals ( new   JndiPermission (  \" java :  -  \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  )  ;", "assertEquals ( new   JndiPermission (  \" java :  *  \"  ,     \"  *  \"  )  ,    new   JndiPermission (  \"  *  \"  ,     \"  *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNameImplies"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionTestCase"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   JndiPermission (  \"  -  \"  ,    Integer . MAX _ VALUE )  . getActionBits (  )  ,    JndiPermission . ACTION _ ALL )  ;", "assertEquals ( new   JndiPermission (  \"  -  \"  ,    Integer . MAX _ VALUE )  ,    new   JndiPermission (  \"  -  \"  ,     \"  *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSecurity"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionTestCase"}, {"methodBody": ["METHOD_START", "{", "final   JndiPermission   jndiPermission    =    new   JndiPermission (  \" foo / blap /  -  \"  ,     \" bind , lookup \"  )  ;", "assertEquals ( jndiPermission ,     (  ( SerializedJndiPermission )     ( jndiPermission . writeReplace (  )  )  )  . readResolve (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerialization"], "fileName": "org.wildfly.naming.java.permission.JndiPermissionTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   JndiPermission ( name ,    actions )  ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.wildfly.naming.java.permission.SerializedJndiPermission"}, {"methodBody": ["METHOD_START", "{", "final   JndiPermissionCollection   collection    =    new   JndiPermissionCollection ( permissions )  ;", "if    ( readOnly )", "collection . setReadOnly (  )  ;", "return   collection ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.wildfly.naming.java.permission.SerializedJndiPermissionCollection"}]