[{"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    ( JsfVersionMarker . isJsfDisabled ( deploymentUnit )  )     {", "return ;", "}", "final   Map < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >    instances    =    new   HashMap < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >  (  )  ;", "final   CompositeIndex   compositeIndex    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "if    ( compositeIndex    =  =    null )     {", "return ;", "}", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "if    ( module    =  =    null )     {", "return ;", "}", "final   ClassLoader   classLoader    =    module . getClassLoader (  )  ;", "for    (  . FacesAnnotation   annotation    :     . FacesAnnotation . values (  )  )     {", "final   List < AnnotationInstance >    annotationInstances    =    compositeIndex . getAnnotations ( annotation . indexName )  ;", "if    (  ( annotationInstances    =  =    null )     |  |     ( annotationInstances . isEmpty (  )  )  )     {", "continue ;", "}", "final   Set < Class <  ?  >  >    discoveredClasses    =    new   HashSet < Class <  ?  >  >  (  )  ;", "instances . put ( annotation . annotationClass ,    discoveredClasses )  ;", "for    ( AnnotationInstance   annotationInstance    :    annotationInstances )     {", "final   AnnotationTarget   target    =    annotationInstance . target (  )  ;", "if    ( target   instanceof   ClassInfo )     {", "final   DotName   className    =    ClassInfo . class . cast ( target )  . name (  )  ;", "final   Class <  ?  >    annotatedClass ;", "try    {", "annotatedClass    =    classLoader . loadClass ( className . toString (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   DeploymentUnitProcessingException ( JSFLogger . ROOT _ LOGGER . classLoadingFailed ( className )  )  ;", "}", "discoveredClasses . add ( annotatedClass )  ;", "} else    {", "throw   new   DeploymentUnitProcessingException ( JSFLogger . ROOT _ LOGGER . invalidAnnotationLocation ( annotation ,    target )  )  ;", "}", "}", "}", "deploymentUnit . addToAttachmentList ( ATTACHMENT _ KEY ,    new   ServletContextAttribute (  . FACES _ ANNOTATIONS _ SC _ ATTR ,    instances )  )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.jsf.deployment.JSFAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   DeploymentUnit   parent    =     (  ( deploymentUnit . getParent (  )  )     =  =    null )     ?    deploymentUnit    :    deploymentUnit . getParent (  )  ;", "if    ( JsfVersionMarker . isJsfDisabled ( deploymentUnit )  )     {", "return ;", "}", "if    ( WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit )  )     {", "WeldPortableExtensions   extensions    =    WeldPortableExtensions . getPortableExtensions ( parent )  ;", "extensions . registerExtensionInstance ( new   JSFPassivatingViewScoped (  )  ,    parent )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.jsf.deployment.JSFCdiExtensionDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Set < VirtualFile >    ret    =    new   HashSet < VirtualFile >  (  )  ;", "final   List < ResourceRoot >    resourceRoots    =    DeploymentUtils . allResourceRoots ( deploymentUnit )  ;", "for    ( final   ResourceRoot   resourceRoot    :    resourceRoots )     {", "final   VirtualFile   webInfFacesConfig    =    resourceRoot . getRoot (  )  . getChild (  . WEB _ INF _ FACES _ CONFIG )  ;", "if    ( webInfFacesConfig . exists (  )  )     {", "ret . add ( webInfFacesConfig )  ;", "}", "final   VirtualFile   metaInf    =    resourceRoot . getRoot (  )  . getChild (  \" META - INF \"  )  ;", "if    (  ( metaInf . exists (  )  )     &  &     ( metaInf . isDirectory (  )  )  )     {", "for    ( final   VirtualFile   file    :    metaInf . getChildren (  )  )     {", "if    (  ( file . getName (  )  . equals (  \" faces - config . xml \"  )  )     |  |     ( file . getName (  )  . endsWith (  \"  . faces - config . xml \"  )  )  )     {", "ret . add ( file )  ;", "}", "}", "}", "}", "String   configFiles    =    null ;", "final   WarMetaData   warMetaData    =    deploymentUnit . getAttachment ( ATTACHMENT _ KEY )  ;", "if    ( warMetaData    !  =    null )     {", "final   WebMetaData   webMetaData    =    warMetaData . getWebMetaData (  )  ;", "if    ( webMetaData    !  =    null )     {", "final   List < ParamValueMetaData >    contextParams    =    webMetaData . getContextParams (  )  ;", "if    ( contextParams    !  =    null )     {", "for    ( final   ParamValueMetaData   param    :    contextParams )     {", "if    ( param . getParamName (  )  . equals (  . CONFIG _ FILES )  )     {", "configFiles    =    param . getParamValue (  )  ;", "break ;", "}", "}", "}", "}", "}", "if    ( configFiles    !  =    null )     {", "final   String [  ]    files    =    configFiles . split (  \"  ,  \"  )  ;", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "if    ( deploymentRoot    !  =    null )     {", "for    ( final   String   file    :    files )     {", "final   VirtualFile   configFile    =    deploymentRoot . getRoot (  )  . getChild ( file )  ;", "if    ( configFile . exists (  )  )     {", "ret . add ( configFile )  ;", "}", "}", "}", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["getConfigurationFiles"], "fileName": "org.jboss.as.jsf.deployment.JSFComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < AnnotationInstance >    annotations    =    index . getAnnotations ( JSFComponentProcessor . MANAGED _ BEAN _ ANNOTATION )  ;", "if    ( annotations    !  =    null )     {", "for    ( final   AnnotationInstance   annotation    :    annotations )     {", "final   AnnotationTarget   target    =    annotation . target (  )  ;", "if    ( target   instanceof   ClassInfo )     {", "final   String   className    =     (  ( ClassInfo )     ( target )  )  . name (  )  . toString (  )  ;", "managedBeanClasses . add ( className )  ;", "} else    {", "throw   new   DeploymentUnitProcessingException ( JSFLogger . ROOT _ LOGGER . invalidManagedBeanAnnotation ( target )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleAnnotations"], "fileName": "org.jboss.as.jsf.deployment.JSFComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ComponentDescription   componentDescription    =    new   WebComponentDescription (  (  (  ( JSFComponentProcessor . MANAGED _ BEAN . toString (  )  )     +     \"  .  \"  )     +    className )  ,    className ,    moduleDescription ,    deploymentUnit . getServiceName (  )  ,    applicationClassesDescription )  ;", "moduleDescription . addComponent ( componentDescription )  ;", "deploymentUnit . addToAttachmentList ( WEB _ COMPONENTS ,    componentDescription . getStartServiceName (  )  )  ;", "}", "METHOD_END"], "methodName": ["installManagedBeanComponent"], "fileName": "org.jboss.as.jsf.deployment.JSFComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( final   VirtualFile   facesConfig    :    getConfigurationFiles ( deploymentUnit )  )     {", "InputStream   is    =    null ;", "try    {", "is    =    facesConfig . openStream (  )  ;", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( NoopXMLResolver . create (  )  )  ;", "XMLStreamReader   parser    =    inputFactory . createXMLStreamReader ( is )  ;", "StringBuilder   phaseListenerName    =    null ;", "int   indent    =     0  ;", "boolean   lifecycle    =    false ;", "boolean   phaseListener    =    false ;", "while    ( true )     {", "int   event    =    parser . next (  )  ;", "if    ( event    =  =     ( XMLStreamConstants . END _ DOCUMENT )  )     {", "parser . close (  )  ;", "break ;", "}", "if    ( event    =  =     ( XMLStreamConstants . START _ ELEMENT )  )     {", "indent +  +  ;", "if    ( indent    =  =     2  )     {", "if    ( parser . getLocalName (  )  . equals (  . LIFECYCLE )  )     {", "lifecycle    =    true ;", "}", "} else", "if    (  ( indent    =  =     3  )     &  &    lifecycle )     {", "if    ( parser . getLocalName (  )  . equals (  . PHASE _ LISTENER )  )     {", "phaseListener    =    true ;", "phaseListenerName    =    new   StringBuilder (  )  ;", "}", "}", "} else", "if    ( event    =  =     ( XMLStreamConstants . END _ ELEMENT )  )     {", "indent -  -  ;", "phaseListener    =    false ;", "if    ( indent    =  =     1  )     {", "lifecycle    =    false ;", "}", "if    ( phaseListenerName    !  =    null )     {", "managedBeanClasses . add ( phaseListenerName . toString (  )  . trim (  )  )  ;", "phaseListenerName    =    null ;", "}", "} else", "if    ( phaseListener    &  &     ( event    =  =     ( XMLStreamConstants . CHARACTERS )  )  )     {", "phaseListenerName . append ( parser . getText (  )  )  ;", "}", "}", "}    catch    ( Exception   e )     {", "JSFLogger . ROOT _ LOGGER . phaseListenersConfigParseFailed ( facesConfig )  ;", "}    finally    {", "try    {", "if    ( is    !  =    null )     {", "is . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processPhaseListeners"], "fileName": "org.jboss.as.jsf.deployment.JSFComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( final   VirtualFile   facesConfig    :    getConfigurationFiles ( deploymentUnit )  )     {", "InputStream   is    =    null ;", "try    {", "is    =    facesConfig . openStream (  )  ;", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( NoopXMLResolver . create (  )  )  ;", "XMLStreamReader   parser    =    inputFactory . createXMLStreamReader ( is )  ;", "StringBuilder   className    =    null ;", "int   indent    =     0  ;", "boolean   managedBean    =    false ;", "boolean   managedBeanClass    =    false ;", "while    ( true )     {", "int   event    =    parser . next (  )  ;", "if    ( event    =  =     ( XMLStreamConstants . END _ DOCUMENT )  )     {", "parser . close (  )  ;", "break ;", "}", "if    ( event    =  =     ( XMLStreamConstants . START _ ELEMENT )  )     {", "indent +  +  ;", "if    ( indent    =  =     2  )     {", "if    ( parser . getLocalName (  )  . equals (  . MANAGED _ BEAN )  )     {", "managedBean    =    true ;", "}", "} else", "if    (  ( indent    =  =     3  )     &  &    managedBean )     {", "if    ( parser . getLocalName (  )  . equals (  . MANAGED _ BEAN _ CLASS )  )     {", "managedBeanClass    =    true ;", "className    =    new   StringBuilder (  )  ;", "}", "}", "} else", "if    ( event    =  =     ( XMLStreamConstants . END _ ELEMENT )  )     {", "indent -  -  ;", "managedBeanClass    =    false ;", "if    ( indent    =  =     1  )     {", "managedBean    =    false ;", "}", "if    ( className    !  =    null )     {", "managedBeanClasses . add ( className . toString (  )  . trim (  )  )  ;", "className    =    null ;", "}", "} else", "if    ( managedBeanClass    &  &     ( event    =  =     ( XMLStreamConstants . CHARACTERS )  )  )     {", "className . append ( parser . getText (  )  )  ;", "}", "}", "}    catch    ( Exception   e )     {", "JSFLogger . ROOT _ LOGGER . managedBeansConfigParseFailed ( facesConfig )  ;", "}    finally    {", "try    {", "if    ( is    !  =    null )     {", "is . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processXmlManagedBeans"], "fileName": "org.jboss.as.jsf.deployment.JSFComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "JBossWebMetaData   webMetaData    =    warMetaData . getMergedJBossWebMetaData (  )  ;", "if    ( webMetaData    =  =    null )     {", "webMetaData    =    new   JBossWebMetaData (  )  ;", "warMetaData . setMergedJBossWebMetaData ( webMetaData )  ;", "}", "List < ParamValueMetaData >    contextParams    =    webMetaData . getContextParams (  )  ;", "if    ( contextParams    =  =    null )     {", "contextParams    =    new   ArrayList < ParamValueMetaData >  (  )  ;", "}", "boolean   isCDI    =    WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit )  ;", "ParamValueMetaData   param    =    new   ParamValueMetaData (  )  ;", "param . setParamName (  . IS _ CDI _ PARAM )  ;", "param . setParamValue ( Boolean . toString ( isCDI )  )  ;", "contextParams . add ( param )  ;", "webMetaData . setContextParams ( contextParams )  ;", "}", "METHOD_END"], "methodName": ["addCDIFlag"], "fileName": "org.jboss.as.jsf.deployment.JSFDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( jsfVersion . equals ( JsfVersionMarker . WAR _ BUNDLES _ JSF _ IMPL )  )", "return ;", "ModuleIdentifier   jsfModule    =    moduleIdFactory . getApiModId ( jsfVersion )  ;", "Module   jsfAPI    =    new   Module ( moduleLoader ,    jsfModule ,    false ,    false ,    false ,    false )  ;", "moduleSpecification . addSystem ( jsfAPI )  ;", "}", "METHOD_END"], "methodName": ["addJSFAPI"], "fileName": "org.jboss.as.jsf.deployment.JSFDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( jsfVersion . equals ( JsfVersionMarker . WAR _ BUNDLES _ JSF _ IMPL )  )", "return ;", "ModuleIdentifier   jsfModule    =    moduleIdFactory . getImplModId ( jsfVersion )  ;", "Module   jsfImpl    =    new   Module ( moduleLoader ,    jsfModule ,    false ,    false ,    true ,    false )  ;", "jsfImpl . addImportFilter ( PathFilters . getMetaInfFilter (  )  ,    true )  ;", "moduleSpecification . addSystem ( jsfImpl )  ;", "}", "METHOD_END"], "methodName": ["addJSFImpl"], "fileName": "org.jboss.as.jsf.deployment.JSFDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( jsfVersion . equals ( JsfVersionMarker . WAR _ BUNDLES _ JSF _ IMPL )  )", "return ;", "ModuleIdentifier   jsfInjectionModule    =    moduleIdFactory . getInjectionModId ( jsfVersion )  ;", "Module   jsfInjection    =    new   Module ( moduleLoader ,    jsfInjectionModule ,    false ,    true ,    true ,    false )  ;", "jsfInjection . addImportFilter ( PathFilters . getMetaInfFilter (  )  ,    true )  ;", "moduleSpecification . addSystem ( jsfInjection )  ;", "}", "METHOD_END"], "methodName": ["addJSFInjection"], "fileName": "org.jboss.as.jsf.deployment.JSFDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "List < ParamValueMetaData >    contextParams    =    webMetaData . getContextParams (  )  ;", "if    ( contextParams    =  =    null )     {", "contextParams    =    new   ArrayList (  )  ;", "webMetaData . setContextParams ( contextParams )  ;", "}", "for    ( ParamValueMetaData   param    :    contextParams )     {", "if    (  ( name . equals ( param . getParamName (  )  )  )     &  &     (  ( param . getParamValue (  )  )     !  =    null )  )     {", "return ;", "}", "}", "ParamValueMetaData   param    =    new   ParamValueMetaData (  )  ;", "param . setParamName ( name )  ;", "param . setParamValue ( value )  ;", "contextParams . add ( param )  ;", "}", "METHOD_END"], "methodName": ["setContextParameterIfAbsent"], "fileName": "org.jboss.as.jsf.deployment.JSFMetadataProcessor"}, {"methodBody": ["METHOD_START", "{", "activeVersions . addAll ( allVersions )  ;", "for    ( String   version    :    allVersions )     {", "if    (  !  ( apiIds . containsKey ( version )  )  )     {", "JSFLogger . ROOT _ LOGGER . missingJSFModule ( version ,     . API _ MODULE )  ;", "activeVersions . remove ( version )  ;", "}", "if    (  !  ( implIds . containsKey ( version )  )  )     {", "JSFLogger . ROOT _ LOGGER . missingJSFModule ( version ,     . IMPL _ MODULE )  ;", "activeVersions . remove ( version )  ;", "}", "if    (  !  ( injectionIds . containsKey ( version )  )  )     {", "JSFLogger . ROOT _ LOGGER . missingJSFModule ( version ,     . INJECTION _ MODULE )  ;", "activeVersions . remove ( version )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkVersionIntegrity"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( jsfVersion    =  =    null )", "return   defaultSlot ;", "if    ( JsfVersionMarker _  2  _  0  . equals ( jsfVersion )  )", "return   defaultSlot ;", "return   jsfVersion ;", "}", "METHOD_END"], "methodName": ["computeSlot"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( activeVersions )  ;", "}", "METHOD_END"], "methodName": ["getActiveJSFVersions"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . apiIds . get ( computeSlot ( jsfVersion )  )  ;", "}", "METHOD_END"], "methodName": ["getApiModId"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultSlot ;", "}", "METHOD_END"], "methodName": ["getDefaultSlot"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . implIds . get ( computeSlot ( jsfVersion )  )  ;", "}", "METHOD_END"], "methodName": ["getImplModId"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . injectionIds . get ( computeSlot ( jsfVersion )  )  ;", "}", "METHOD_END"], "methodName": ["getInjectionModId"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "return   JSFModuleIdFactory . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )", "return   true ;", "for    ( String   dir    :    path . split ( File . pathSepara )  )     {", "if    ( new   File ( dir )  . exists (  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isBogusPath"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "String   computedSlot    =    computeSlot ( slot )  ;", "return    (  ( apiIds . containsKey ( computedSlot )  )     &  &     ( implIds . containsKey ( computedSlot )  )  )     &  &     ( injectionIds . containsKey ( computedSlot )  )  ;", "}", "METHOD_END"], "methodName": ["isValidJSFSlot"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   baseDirBuilder    =    new   StringBuilder ( moduleRootDir )  ;", "baseDirBuilder . append ( File . separator )  ;", "baseDirBuilder . append ( moduleName . replace (  \"  .  \"  ,    File . separator )  )  ;", "File   moduleBaseDir    =    new   File ( baseDirBuilder . toString (  )  )  ;", "File [  ]    slots    =    moduleBaseDir . listFiles ( new   FileFilter (  )     {", "public   boolean   accept ( File   pathname )     {", "return   pathname . isDirectory (  )  ;", "}", "}  )  ;", "if    ( slots    =  =    null )", "return ;", "for    ( File   slot    :    slots )     {", "if    (  !  ( new   File ( slot ,     \" module . xml \"  )  . exists (  )  )  )", "continue ;", "String   slotName    =    slot . getName (  )  ;", "allVersions . add ( slotName )  ;", "idMap . put ( slotName ,    entifier . create ( moduleName ,    slotName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["loadIds"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( String   moduleRootDir    :    modulePath . split ( File . pathSeparator )  )     {", "loadIds ( moduleRootDir ,    apiIds ,     . API _ MODULE )  ;", "loadIds ( moduleRootDir ,    implIds ,     . IMPL _ MODULE )  ;", "loadIds ( moduleRootDir ,    injectionIds ,     . INJECTION _ MODULE )  ;", "}", "checkVersionIntegrity (  )  ;", "}", "METHOD_END"], "methodName": ["loadIdsFromModulePath"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "implIds . put (  \" main \"  ,    ModuleIdentifier . create ( JSFModuleIdFactory . IMPL _ MODULE )  )  ;", "apiIds . put (  \" main \"  ,    ModuleIdentifier . create ( JSFModuleIdFactory . API _ MODULE )  )  ;", "injectionIds . put (  \" main \"  ,    ModuleIdentifier . create ( JSFModuleIdFactory . INJECTION _ MODULE )  )  ;", "allVersions . add (  \" main \"  )  ;", "activeVersions . add (  \" main \"  )  ;", "}", "METHOD_END"], "methodName": ["loadIdsManually"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "this . defaultSlot    =    defaultSlot ;", "}", "METHOD_END"], "methodName": ["setDefaultSlot"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  \" main \"  ,    JSFModuleIdFactoryTestCase . factory . computeSlot (  \" main \"  )  )  ;", "Assert . assertEquals (  \" main \"  ,    JSFModuleIdFactoryTestCase . factory . computeSlot ( null )  )  ;", "Assert . assertEquals (  \" main \"  ,    JSFModuleIdFactoryTestCase . factory . computeSlot ( JsfVersionMarker . JSF _  2  _  0  )  )  ;", "Assert . assertEquals (  \" myfaces 2  \"  ,    JSFModuleIdFactoryTestCase . factory . computeSlot (  \" myfaces 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["computeSlotTest"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "List < String >    versions    =    JSFModuleIdFactoryTestCase . factory . getActiveJSFVersions (  )  ;", "Assert . assertEquals (  3  ,    versions . size (  )  )  ;", "Assert . assertTrue ( versions . contains (  \" main \"  )  )  ;", "Assert . assertFalse ( versions . contains (  \"  1  .  2  \"  )  )  ;", "Assert . assertTrue ( versions . contains (  \" myfaces \"  )  )  ;", "Assert . assertTrue ( versions . contains (  \" myfaces 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getActiveJSFVersionsTest"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . API _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getApiModId (  \" main \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" main \"  ,    JSFModuleIdFactoryTestCase . factory . getApiModId (  \" main \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . IMPL _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getImplModId (  \" main \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" main \"  ,    JSFModuleIdFactoryTestCase . factory . getImplModId (  \" main \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . INJECTION _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getInjectionModId (  \" main \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" main \"  ,    JSFModuleIdFactoryTestCase . factory . getInjectionModId (  \" main \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . API _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getApiModId (  \" myfaces \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" myfaces \"  ,    JSFModuleIdFactoryTestCase . factory . getApiModId (  \" myfaces \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . IMPL _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getImplModId (  \" myfaces \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" myfaces \"  ,    JSFModuleIdFactoryTestCase . factory . getImplModId (  \" myfaces \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . INJECTION _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getInjectionModId (  \" myfaces \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" myfaces \"  ,    JSFModuleIdFactoryTestCase . factory . getInjectionModId (  \" myfaces \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . API _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getApiModId (  \" myfaces 2  \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" myfaces 2  \"  ,    JSFModuleIdFactoryTestCase . factory . getApiModId (  \" myfaces 2  \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . IMPL _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getImplModId (  \" myfaces 2  \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" myfaces 2  \"  ,    JSFModuleIdFactoryTestCase . factory . getImplModId (  \" myfaces 2  \"  )  . getSlot (  )  )  ;", "Assert . assertEquals ( JSFModuleIdFactoryTestCase . INJECTION _ MODULE ,    JSFModuleIdFactoryTestCase . factory . getInjectionModId (  \" myfaces 2  \"  )  . getName (  )  )  ;", "Assert . assertEquals (  \" myfaces 2  \"  ,    JSFModuleIdFactoryTestCase . factory . getInjectionModId (  \" myfaces 2  \"  )  . getSlot (  )  )  ;", "}", "METHOD_END"], "methodName": ["modIdsTest"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot (  \" main \"  )  )  ;", "Assert . assertFalse ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot (  \"  1  .  2  \"  )  )  ;", "Assert . assertTrue ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot (  \" myfaces \"  )  )  ;", "Assert . assertTrue ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot (  \" myfaces 2  \"  )  )  ;", "Assert . assertTrue ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot ( JsfVersionMarker . JSF _  2  _  0  )  )  ;", "Assert . assertFalse ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot ( JsfVersionMarker . WAR _ BUNDLES _ JSF _ IMPL )  )  ;", "Assert . assertFalse ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot (  \" bogus \"  )  )  ;", "Assert . assertFalse ( JSFModuleIdFactoryTestCase . factory . isValidJSFSlot (  \" bogus 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["validSlotTest"], "fileName": "org.jboss.as.jsf.deployment.JSFModuleIdFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "event . addScope ( ViewScoped . class ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["beforeBeanDiscovery"], "fileName": "org.jboss.as.jsf.deployment.JSFPassivatingViewScopedCdiExtension"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   DeploymentUnit   topLevelDeployment    =     (  ( deploymentUnit . getParent (  )  )     =  =    null )     ?    deploymentUnit    :    deploymentUnit . getParent (  )  ;", "if    ( JsfVersionMarker . isJsfDisabled ( deploymentUnit )  )     {", "return ;", "}", "String   jsfVersion    =    JsfVersionMarker . getVersion ( topLevelDeployment )  ;", "if    ( jsfVersion . equals ( JsfVersionMarker . WAR _ BUNDLES _ JSF _ IMPL )  )     {", "return ;", "}", "List < TldMetaData >    tldsMetaData    =    deploymentUnit . getAttachment ( ATTACHMENT _ KEY )  ;", "if    ( tldsMetaData    =  =    null )", "tldsMetaData    =    new   ArrayList < TldMetaData >  (  )  ;", "String   slot    =    jsfVersion ;", "if    (  !  ( JSFModuleIdFactory . getInstance (  )  . isValidJSFSlot ( slot )  )  )     {", "slot    =    JSFModuleIdFactory . getInstance (  )  . getDefaultSlot (  )  ;", "}", "slot    =    JSFModuleIdFactory . getInstance (  )  . computeSlot ( slot )  ;", "List < TldMetaData >    jsfTlds    =    this . getMap (  )  . get ( slot )  ;", "if    ( jsfTlds    !  =    null )", "tldsMetaData . addAll ( jsfTlds )  ;", "deploymentUnit . putAttachment ( ATTACHMENT _ KEY ,    tldsMetaData )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.jsf.deployment.JSFSharedTldsProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    List < TldMetaData >  >    jsfTldMap    =    new   HashMap <  >  (  )  ;", "JSFModuleIdFactory   moduleFactory    =    JSFModuleIdFactory . getInstance (  )  ;", "List < String >    jsfSlotNames    =    moduleFactory . getActiveJSFVersions (  )  ;", "for    ( String   slot    :    jsfSlotNames )     {", "final   List < TldMetaData >    jsfTlds    =    new   ArrayList < TldMetaData >  (  )  ;", "try    {", "ModuleClassLoader   jsf    =    Module . getModuleFromCallerModuleLoader ( moduleFactory . getImplModId ( slot )  )  . getClassLoader (  )  ;", "for    ( String   tld    :     . JSF _ TAGLIBS )     {", "InputStream   is    =    jsf . getResourceAsStream (  (  \" META - INF /  \"     +    tld )  )  ;", "if    ( is    !  =    null )     {", "TldMetaData   tldMetaData    =    parseTLD ( is )  ;", "jsfTlds . add ( tldMetaData )  ;", "}", "}", "}    catch    ( ModuleLoadException   e )     {", "}    catch    ( Exception   e )     {", "}", "jsfTldMap . put ( slot ,    jsfTlds )  ;", "}", "return   jsfTldMap ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "org.jboss.as.jsf.deployment.JSFSharedTldsProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( NoopXMLResolver . create (  )  )  ;", "XMLStreamReader   xmlReader    =    inputFactory . createXMLStreamReader ( is )  ;", "return   MetaDataParser . parse ( xmlReader )  ;", "}    finally    {", "try    {", "if    ( is    !  =    null )     {", "is . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["parseTLD"], "fileName": "org.jboss.as.jsf.deployment.JSFSharedTldsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( jBossWebMetaData    !  =    null )     {", "ServletsMetaData   servlets    =    jBossWebMetaData . getServlets (  )  ;", "if    ( servlets    !  =    null )     {", "for    ( ServletMetaData   servlet    :    servlets )     {", "if    (  . JAVAX _ FACES _ WEBAPP _ FACES _ SERVLET . equals ( servlet . getServletClass (  )  )  )     {", "return   true ;", "}", "}", "}", "List < ParamValueMetaData >    sc    =    jBossWebMetaData . getContextParams (  )  ;", "if    ( sc    !  =    null )     {", "for    ( ParamValueMetaData   p    :    sc )     {", "if    (  . CONFIG _ FILES . equals ( p . getParamName (  )  )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isJsfDeclarationsPresent"], "fileName": "org.jboss.as.jsf.deployment.JSFVersionProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( warMetaData    !  =    null )     {", "WebCommonMetaData   jBossWebMetaData    =    warMetaData . getWebMetaData (  )  ;", "if    ( isJsfDeclarationsPresent ( jBossWebMetaData )  )     {", "return   true ;", "}", "if    (  ( warMetaData . getWebFragmentsMetaData (  )  )     !  =    null )     {", "for    ( WebFragmentMetaData   fragmentMetaData    :    warMetaData . getWebFragmentsMetaData (  )  . values (  )  )     {", "if    ( isJsfDeclarationsPresent ( fragmentMetaData )  )     {", "return   true ;", "}", "}", "}", "}", "Set < ResourceRoot >    roots    =    new   HashSet <  >  (  )  ;", "roots . add ( deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  )  ;", "roots . addAll ( deploymentUnit . getAttachmentList ( RESOURCE _ ROOTS )  )  ;", "for    ( ResourceRoot   root    :    roots )     {", "VirtualFile   c    =    root . getRoot (  )  . getChild (  . META _ INF _ FACES )  ;", "if    ( c . exists (  )  )     {", "return   true ;", "}", "c    =    root . getRoot (  )  . getChild (  . WEB _ INF _ FACES )  ;", "if    ( c . exists (  )  )     {", "return   true ;", "}", "}", "CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "for    ( DotName   annotation    :     . JSF _ ANNOTATIONS )     {", "List < AnnotationInstance >    annotations    =    index . getAnnotations ( annotation )  ;", "if    (  !  ( annotations . isEmpty (  )  )  )     {", "return   true ;", "}", "}", "for    ( DotName   annotation    :     . JSF _ INTERFACES )     {", "Set < ClassInfo >    implementors    =    index . getAllKnownImplementors ( annotation )  ;", "if    (  !  ( implementors . isEmpty (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldJsfActivate"], "fileName": "org.jboss.as.jsf.deployment.JSFVersionProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   version    =    deploymentUnit . getAttachment ( JsfVersionMarker . VERSION _ KEY )  ;", "return   version    =  =    null    ?    JsfVersionMarker . JSF _  2  _  0     :    version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.jboss.as.jsf.deployment.JsfVersionMarker"}, {"methodBody": ["METHOD_START", "{", "final   String   version    =    deploymentUnit . getAttachment ( JsfVersionMarker . VERSION _ KEY )  ;", "return   JsfVersionMarker . NONE . equals ( version )  ;", "}", "METHOD_END"], "methodName": ["isJsfDisabled"], "fileName": "org.jboss.as.jsf.deployment.JsfVersionMarker"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . putAttachment ( JsfVersionMarker . VERSION _ KEY ,    value )  ;", "}", "METHOD_END"], "methodName": ["setVersion"], "fileName": "org.jboss.as.jsf.deployment.JsfVersionMarker"}, {"methodBody": ["METHOD_START", "{", "final   Map < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >    convertedAnnotatedClasses    =    new   HashMap < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >  (  )  ;", "for    ( Map . Entry < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >    entry    :    annotations . entrySet (  )  )     {", "final   Class <  ?    extends   Annotation >    annotation    =    entry . getKey (  )  ;", "final   Set < Class <  ?  >  >    annotated    =    entry . getValue (  )  ;", "final   Class <  ?    extends   Annotation >    knownAnnotation    =     . stringToAnnoMap . get ( annotation . getName (  )  )  ;", "if    ( knownAnnotation    !  =    null )     {", "convertedAnnotatedClasses . put ( knownAnnotation ,    annotated )  ;", "} else    {", "convertedAnnotatedClasses . put ( annotation ,    annotated )  ;", "}", "}", "return   convertedAnnotatedClasses ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.jboss.as.jsf.injection.AnnotationMap"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    appMap    =    extContext . getApplicationMap (  )  ;", "if    (  ( appMap . get (  . ANNOTATION _ MAP _ CONVERTED )  )     !  =    null )     {", "return    (  ( Map < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >  )     ( appMap . get (  . FACES _ ANNOTATIONS _ SC _ ATTR )  )  )  ;", "} else    {", "appMap . put (  . ANNOTATION _ MAP _ CONVERTED ,    Boolean . TRUE )  ;", "return    . convert (  (  ( Map < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >  )     ( appMap . get (  . FACES _ ANNOTATIONS _ SC _ ATTR )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.jsf.injection.AnnotationMap"}, {"methodBody": ["METHOD_START", "{", "Map < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >    annotations    =     (  ( Map < Class <  ?    extends   Annotation >  ,    Set < Class <  ?  >  >  >  )     ( servletContext . getAttribute ( AnnotationMap . FACES _ ANNOTATIONS _ SC _ ATTR )  )  )  ;", "if    (  ( servletContext . getAttribute ( AnnotationMap . ANNOTATION _ MAP _ CONVERTED )  )     !  =    null )     {", "return   annotations ;", "} else    {", "servletContext . setAttribute ( AnnotationMap . ANNOTATION _ MAP _ CONVERTED ,    Boolean . TRUE )  ;", "return   AnnotationMap . convert ( annotations )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.jsf.injection.AnnotationMap"}, {"methodBody": ["METHOD_START", "{", "injectionContainer . destroyInstance ( obj )  ;", "}", "METHOD_END"], "methodName": ["destroyInstance"], "fileName": "org.jboss.as.jsf.injection.MyFacesLifecycleProvider"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    clazz    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  . loadClass ( className )  ;", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   clazz . newInstance (  )  ;", "} else    {", "try    {", "return   AccessController . doPrivileged ( new   PrivilegedExceptionA < Object >  (  )     {", "public   Object   run (  )    throws   IllegalAccessException ,    InstantiationException    {", "return   clazz . newInstance (  )  ;", "}", "}  )  ;", "}    catch    ( PrivilegedAException   pae )     {", "Exception   e    =    pae . getException (  )  ;", "if    ( e   instanceof   IllegalAccessException )     {", "throw    (  ( IllegalAccessException )     ( e )  )  ;", "} else", "if    ( e   instanceof   InstantiationException )     {", "throw    (  ( InstantiationException )     ( e )  )  ;", "} else    {", "throw   new   FacesException ( e )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.jboss.as.jsf.injection.MyFacesLifecycleProvider"}, {"methodBody": ["METHOD_START", "{", "try    {", "Container . newInstance ( obj )  ;", "}    catch    ( NamingException   e )     {", "throw   new   FacesException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["postConstruct"], "fileName": "org.jboss.as.jsf.injection.MyFacesLifecycleProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beanManager )     =  =    null )     {", "synchronized ( this )     {", "if    (  ( beanManager )     =  =    null )     {", "try    {", "beanManager    =     (  ( BeanManager )     ( new   InitialContext (  )  . lookup (  \" java : comp / BeanManager \"  )  )  )  ;", "}    catch    ( NamingExcep    |    IllegalArgumentExcep   e )     {", "return   null ;", "}", "}", "}", "}", "return   beanManager ;", "}", "METHOD_END"], "methodName": ["beanManager"], "fileName": "org.jboss.as.jsf.injection.weld.WeldApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initialized )  )     {", "synchronized ( this )     {", "if    (  !  ( initialized )  )     {", "if    (  ( beanManager (  )  )     !  =    null )     {", "elResolver . setDelegate ( beanManager (  )  . getELResolver (  )  )  ;", "}", "initialized    =    true ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jboss.as.jsf.injection.weld.WeldApplication"}, {"methodBody": ["METHOD_START", "{", "ServletContext   ctx    =     (  ( ServletContext )     ( FacesContext . getCurrentInstance (  )  . getExternalContext (  )  . getContext (  )  )  )  ;", "return   Boolean . parseBoolean ( ctx . getInitParameter ( JSFDependencyProcessor . IS _ CDI _ PARAM )  )  ;", "}", "METHOD_END"], "methodName": ["isCDIApp"], "fileName": "org.jboss.as.jsf.injection.weld.WildFlyConversationAwareViewHandler"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder ( JSFExtension . SUBSYSTEM _ NAME )  ;", "for    ( String   kp    :    keyPrefix )     {", "prefix . append (  '  .  '  )  . append ( kp )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,    JSFExtension . RESOURCE _ NAME ,    JSFExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.jsf.subsystem.JSFExtension"}, {"methodBody": ["METHOD_START", "{", "ModelNode   result    =    context . getResult (  )  ;", "result . setEmpty (  )  ;", "for    ( String   impl    :    JSFModuleIdFactory . getInstance (  )  . getActiveJSFVersions (  )  )     {", "result . add ( impl )  ;", "}", "context . completeStep ( NOOP _ ROLLBACK _ HANDLER )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.jsf.subsystem.JSFImplListHandler"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    targetVersion )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . addMavenResourceURL ( String . format (  \"  % s : wildfly - jsf :  % s \"  ,    controllerVersion . getMavenGroupId (  )  ,    controllerVersion . getMavenGavVersion (  )  )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( targetVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource (  \"  / jsf - t - reject . xml \"  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( PathElement . pathElement ( SUBSYSTEM ,    JSFExtension . SUBSYSTEM _ NAME )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    targetVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( JSFResourceDefinition . DISALLOW _ DOCTYPE _ DECL _ ATTR _ NAME )  )  )  ;", "}", "METHOD_END"], "methodName": ["doRejectTest"], "fileName": "org.jboss.as.jsf.subsystem.JSFSubsystemTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "doRejectTest ( EAP _  7  _  0  _  0  ,    JSFSubsystemTransformersTestCase . legacyVersion )  ;", "}", "METHOD_END"], "methodName": ["testRejectTransformersEAP700"], "fileName": "org.jboss.as.jsf.subsystem.JSFSubsystemTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource ( subsystemXmlResource )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL ( String . format (  \"  % s : wildfly - jsf :  % s \"  ,    controllerVersion . getMavenGroupId (  )  ,    controllerVersion . getMavenGavVersion (  )  )  )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( modelVersion )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion ,    null )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.jboss.as.jsf.subsystem.JSFSubsystemTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  0  _  0  ,    JSFSubsystemTransformersTestCase . legacyVersion ,     \"  / jsf - transformers . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP700"], "fileName": "org.jboss.as.jsf.subsystem.JSFSubsystemTransformersTestCase"}]