[{"methodBody": ["METHOD_START", "{", "if    ( name . equals ( void . class . getName (  )  )  )     {", "return   void . class ;", "}", "if    ( name . equals ( byte . class . getName (  )  )  )     {", "return   byte . class ;", "}", "if    ( name . equals ( short . class . getName (  )  )  )     {", "return   short . class ;", "}", "if    ( name . equals ( int . class . getName (  )  )  )     {", "return   int . class ;", "}", "if    ( name . equals ( long . class . getName (  )  )  )     {", "return   long . class ;", "}", "if    ( name . equals ( char . class . getName (  )  )  )     {", "return   char . class ;", "}", "if    ( name . equals ( boolean . class . getName (  )  )  )     {", "return   boolean . class ;", "}", "if    ( name . equals ( float . class . getName (  )  )  )     {", "return   float . class ;", "}", "if    ( name . equals ( double . class . getName (  )  )  )     {", "return   double . class ;", "}", "return    . forName ( name ,    false ,    cl )  ;", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.ejb3.PrimitiveClassLoaderUtil"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isRemotable"], "fileName": "org.jboss.as.ejb3.cache.Cache"}, {"methodBody": ["METHOD_START", "{", "return   target . addService ( CacheFactoryBuilderService . getServiceName ( this . name )  ,    new   ValueService ( this )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.jboss.as.ejb3.cache.CacheFactoryBuilderService"}, {"methodBody": ["METHOD_START", "{", "return   CacheFactoryBuilderService . BASE _ CACHE _ FACTORY _ SERVICE _ NAME . append ( name )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ejb3.cache.CacheFactoryBuilderService"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.ejb3.cache.CacheInfo"}, {"methodBody": ["METHOD_START", "{", "C   context    =    this . getCacheContext (  )  ;", "this . setCacheContext ( null )  ;", "return   context ;", "}", "METHOD_END"], "methodName": ["removeCacheContext"], "fileName": "org.jboss.as.ejb3.cache.Contextual"}, {"methodBody": ["METHOD_START", "{", "return   cacheName ;", "}", "METHOD_END"], "methodName": ["getCacheName"], "fileName": "org.jboss.as.ejb3.cache.EJBBoundCacheMetaData"}, {"methodBody": ["METHOD_START", "{", "this . cacheName    =    cacheName ;", "}", "METHOD_END"], "methodName": ["setCacheName"], "fileName": "org.jboss.as.ejb3.cache.EJBBoundCacheMetaData"}, {"methodBody": ["METHOD_START", "{", "return   target . addService ( DistributableCacheFactoryBuilderService . getServiceName ( this . name )  ,    this )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.jboss.as.ejb3.cache.distributable.DistributableCacheFactoryBuilderService"}, {"methodBody": ["METHOD_START", "{", "return   CacheFactoryBuilderService . BASE _ CACHE _ FACTORY _ SERVICE _ NAME . append (  \" distributable \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ejb3.cache.distributable.DistributableCacheFactoryBuilderService"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanManagerFactoryBuilderFactoryProvider < Batch >    provider    :    ServiceLoader . load ( BeanManagerFactoryBuilderFactoryProvider . class ,    BeanManagerFactoryBuilderFactoryProvider . class . getClassLoader (  )  )  )     {", "return   provider ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.jboss.as.ejb3.cache.distributable.DistributableCacheFactoryBuilderService"}, {"methodBody": ["METHOD_START", "{", "SimpleCacheFactoryService < K ,    V >    service    =    new   SimpleCacheFactoryService <  >  ( timeout )  ;", "return   target . addService ( serviceName ,    service )  . addDependency ( SERVICE _ NAME ,    ServerEnvironment . class ,    service . environment )  . addDependency ( context . getDeploymentUnitServiceName (  )  . append ( name ,     \" expiration \"  )  ,    ScheduledExecutorService . class ,    service . executor )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.jboss.as.ejb3.cache.simple.SimpleCacheFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   singletonPolicy ;", "}", "METHOD_END"], "methodName": ["getSingletonPolicy"], "fileName": "org.jboss.as.ejb3.clustering.ClusteredSingletonServiceCreator"}, {"methodBody": ["METHOD_START", "{", "return   singleton ;", "}", "METHOD_END"], "methodName": ["isClusteredSingleton"], "fileName": "org.jboss.as.ejb3.clustering.EJBBoundClusteringMetaData"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setClusteredSingleton"], "fileName": "org.jboss.as.ejb3.clustering.EJBBoundClusteringMetaData"}, {"methodBody": ["METHOD_START", "{", "return   new   ContainerInterceptorMethodInterceptorFactory . ContainerInterceptorMethodInterceptor ( this . interceptorInstanceRef ,    method )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.ejb3.component.ContainerInterceptorMethodInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.DefaultAccessTimeoutService"}, {"methodBody": ["METHOD_START", "{", "this . value    =    new   AccessTimeoutDetails ( value ,    TimeUnit . MILLISECONDS )  ;", "}", "METHOD_END"], "methodName": ["setDefaultAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.DefaultAccessTimeoutService"}, {"methodBody": ["METHOD_START", "{", "int   result    =    methodName . hashCode (  )  ;", "result    =     (  3  1     *    result )     +     ( Arrays . hashCode ( methodParamTypes )  )  ;", "result    =     (  3  1     *    result )     +     ( viewType . hashCode (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["generateHashCode"], "fileName": "org.jboss.as.ejb3.component.EJBBusinessMethod"}, {"methodBody": ["METHOD_START", "{", "final   SecurityIdentity   identity    =    getCallerSecurityIdentity (  )  ;", "if    (  \"  *  *  \"  . equals ( roleName )  )     {", "return    !  ( identity . isAnonymous (  )  )  ;", "}", "Roles   roles    =    identity . getRoles (  \" ejb \"  ,    true )  ;", "if    ( roles . contains ( roleName )  )     {", "return   true ;", "}", "if    (  ( securityMetaData . getSecurityRoleLinks (  )  )     !  =    null )     {", "Collection < String >    linked    =    securityMetaData . getSecurityRoleLinks (  )  . get ( roleName )  ;", "if    ( linked    !  =    null )     {", "for    ( String   role    :    roles )     {", "if    ( linked . contains ( role )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkCallerSecurityIdentityRole"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   EJBHomeLocator < T >  ( viewClass ,    appName ,    moduleName ,    beanName ,    distinctName ,    Affinity . LOCAL )  ;", "}", "METHOD_END"], "methodName": ["createHomeLocator"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( viewInterface    =  =    null )", "throw   EjbLogger . ROOT _ LOGGER . viewInterfaceCannotBeNull (  )  ;", "if    ( viewServices . containsKey ( viewInterface . getName (  )  )  )     {", "final   ServiceName   serviceName    =    viewServices . get ( viewInterface . getName (  )  )  ;", "return   createViewInstanceProxy ( viewInterface ,    contextData ,    serviceName )  ;", "} else    {", "throw   EjbLogger . ROOT _ LOGGER . viewNotFound ( viewInterface . getName (  )  ,    this . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createViewInstanceProxy"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "final   ServiceController <  ?  >    serviceController    =    EJBComponent . currentServiceContainer (  )  . getRequiredService ( serviceName )  ;", "final   ComponentView   view    =     (  ( ComponentView )     ( serviceController . getValue (  )  )  )  ;", "final   ManagedReference   instance ;", "try    {", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "instance    =    WildFlySecurityManager . doUnchecked ( new   PrivilegedExceptionAction < ManagedReference >  (  )     {", "@ Override", "public   ManagedReference   run (  )    throws   Exception    {", "return   view . createInstance ( contextData )  ;", "}", "}  )  ;", "} else    {", "instance    =    view . createInstance ( contextData )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "return   viewInterface . cast ( instance . getInstance (  )  )  ;", "}", "METHOD_END"], "methodName": ["createViewInstanceProxy"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   isBeanManagedTransaction (  )     ?    AllowedMethodsInformation . INSTANCE _ BMT    :    AllowedMethodsInformation . INSTANCE _ CMT ;", "}", "METHOD_END"], "methodName": ["getAllowedMethodsInformation"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "ApplicationExceptionDetails   applicationException    =    this . applicationExceptions . get ( exceptionClass )  ;", "if    ( applicationException    !  =    null )     {", "return   applicationException ;", "}", "Class <  ?  >    superClass    =    exceptionClass . getSuperclass (  )  ;", "while    (  ( superClass    !  =    null )     &  &     (  !  (  ( superClass . equals ( Exception . class )  )     |  |     ( superClass . equals ( Object . class )  )  )  )  )     {", "applicationException    =    this . applicationExceptions . get ( superClass )  ;", "if    ( applicationException    !  =    null )     {", "if    ( applicationException . isInherited (  )  )     {", "return   applicationException ;", "}", "return   null ;", "}", "superClass    =    superClass . getSuperclass (  )  ;", "}", "if    (  ( RuntimeException . class . isAssignableFrom ( exceptionClass )  )     |  |     ( Error . class . isAssignableFrom ( exceptionClass )  )  )", "return   null ;", "if    ( invokedMethod    !  =    null )     {", "final   Class <  ?  >  [  ]    exceptionTypes    =    invokedMethod . getExceptionTypes (  )  ;", "for    ( Class <  ?  >    type    :    exceptionTypes )     {", "if    ( type . isAssignableFrom ( exceptionClass )  )", "return    . APPLICATION _ EXCEPTION ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getApplicationException"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( isSecurityDomainKnown (  )  )     {", "return   getCallerSecurityIdentity (  )  . getPrincipal (  )  ;", "} else", "if    ( wildfly . security . manager . WildFlySecurityManager . isChecking (  )  )     {", "return   wildfly . security . manager . WildFlySecurityManager . doUnchecked ( getCaller )  ;", "} else    {", "return   this . serverSecurityManager . getCallerPrincipal (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCallerPrincipal"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( incomingRunAsIdentity )     !  =    null )     {", "return   incomingRunAsIdentity ;", "} else", "if    ( securityRequired )     {", "return   securityDomain . getCurrentSecurityIdentity (  )  ;", "} else    {", "return   securityDomain . getAnonymousSecurityIdentity (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCallerSecurityIdentity"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . controlPoint ;", "}", "METHOD_END"], "methodName": ["getControlPoint"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   invocation    =    CurrentInvocationContext . get (  )  ;", "final   MethodIntf   methodIntf    =    MethodIntfHelper . of ( invocation )  ;", "return   getTransactionAttributeType ( methodIntf ,    invocation . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentTransactionAttribute"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   distinctName ;", "}", "METHOD_END"], "methodName": ["getDistinctName"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ejbHomeViewServiceName )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . beanHomeInterfaceIsNull ( getComponentName (  )  )  ;", "}", "final   ServiceController <  ?  >    serviceController    =     . currentServiceContainer (  )  . getRequiredService ( ejbHomeViewServiceName )  ;", "final   ComponentView   view    =     (  ( ComponentView )     ( serviceController . getValue (  )  )  )  ;", "final   String   locatorAppName    =     (  ( earApplicationName )     =  =    null )     ?     \"  \"     :    earApplicationName ;", "return   EJBClient . createProxy (  . createHomeLocator ( view . getViewClass (  )  . asSubclass ( EJBHome . class )  ,    locatorAppName ,    moduleName ,    getComponentName (  )  ,    distinctName )  )  ;", "}", "METHOD_END"], "methodName": ["getEJBHome"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ejbLocalHomeViewServiceName )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . beanLocalHomeInterfaceIsNull ( getName (  )  )  ;", "}", "return   createViewInstanceProxy ( EJBLocalHome . class ,    Collections . emptyMap (  )  ,    ejbLocalHomeViewServiceName )  ;", "}", "METHOD_END"], "methodName": ["getEJBLocalHome"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . earApplicationName ;", "}", "METHOD_END"], "methodName": ["getEarApplicationName"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ejbLocalObjectViewServiceName )     =  =    null )     {", "return   null ;", "}", "final   ServiceController <  ?  >    serviceController    =     . currentServiceContainer (  )  . getRequiredService ( ejbLocalObjectViewServiceName )  ;", "final   ComponentView   view    =     (  ( ComponentView )     ( serviceController . getValue (  )  )  )  ;", "return   view . getViewClass (  )  ;", "}", "METHOD_END"], "methodName": ["getEjbLocalObjectType"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   ejbLocalObjectViewServiceName ;", "}", "METHOD_END"], "methodName": ["getEjbLocalObjectViewServiceName"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ejbObjectViewServiceName )     =  =    null )     {", "return   null ;", "}", "final   ServiceController <  ?  >    serviceController    =     . currentServiceContainer (  )  . getRequiredService ( ejbObjectViewServiceName )  ;", "final   ComponentView   view    =     (  ( ComponentView )     ( serviceController . getValue (  )  )  )  ;", "return   view . getViewClass (  )  ;", "}", "METHOD_END"], "methodName": ["getEjbObjectType"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   ejbObjectViewServiceName ;", "}", "METHOD_END"], "methodName": ["getEjbObjectViewServiceName"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . ejbSuspendHandlerService ;", "}", "METHOD_END"], "methodName": ["getEjbSuspendHandlerService"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   identityOutflowFunction ;", "}", "METHOD_END"], "methodName": ["getIdentityOutflowFunction"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   incomingRunAsIdentity ;", "}", "METHOD_END"], "methodName": ["getIncomingRunAsIdentity"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   invocationMetrics ;", "}", "METHOD_END"], "methodName": ["getInvocationMetrics"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( isBeanManagedTransaction (  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToCallgetRollbackOnly (  )  ;", "}", "try    {", "TransactionManager   tm    =    this . getTransactionManager (  )  ;", "if    (  ( tm . getTransaction (  )  )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . failToCallgetRollbackOnlyOnNoneTransaction (  )  ;", "}", "int   status    =    tm . getStatus (  )  ;", "EjbLogger . ROOT _ LOGGER . tracef (  \" Current   transaction   status   is    % d \"  ,    status )  ;", "switch    ( status )     {", "case   Status . STATUS _ COMMITTED    :", "case   Status . STATUS _ ROLLEDBACK    :", "throw   EjbLogger . ROOT _ LOGGER . failToCallgetRollbackOnlyAfterTxleted (  )  ;", "case   Status . STATUS _ MARKED _ ROLLBACK    :", "case   Status . STATUS _ ROLLING _ BACK    :", "return   true ;", "}", "return   false ;", "}    catch    ( SystemException   se )     {", "EjbLogger . ROOT _ LOGGER . getTxManagerStatusFailed ( se )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["getRollbackOnly"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   securityDomain ;", "}", "METHOD_END"], "methodName": ["getSecurityDomain"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . serverSecurityManager ;", "}", "METHOD_END"], "methodName": ["getSecurityManager"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . securityMetaData ;", "}", "METHOD_END"], "methodName": ["getSecurityMetaData"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   shutDownInterceptorFactory ;", "}", "METHOD_END"], "methodName": ["getShutDownInterceptorFactory"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   timeoutInterceptors ;", "}", "METHOD_END"], "methodName": ["getTimeoutInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   timeoutMethod ;", "}", "METHOD_END"], "methodName": ["getTimeoutMethod"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   timerService ;", "}", "METHOD_END"], "methodName": ["getTimerService"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   getTransactionAttributeType ( methodIntf ,    MethodIdentifier . getIdentifierForMethod ( method )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionAttributeType"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   getTransactionAttributeType ( methodIntf ,    method ,    REQUIRED )  ;", "}", "METHOD_END"], "methodName": ["getTransactionAttributeType"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeType   txAttr    =    txAttrs . get ( new   MethodTransactionAttributeKey ( methodIntf ,    method )  )  ;", "if    (  ( txAttr    =  =    null )     &  &     ( methodIntf    !  =     ( MethodIntf . BEAN )  )  )     {", "txAttr    =    txAttrs . get ( new   MethodTransactionAttributeKey ( MethodIntf . BEAN ,    method )  )  ;", "}", "if    ( txAttr    =  =    null )", "return   defaultType ;", "return   txAttr ;", "}", "METHOD_END"], "methodName": ["getTransactionAttributeType"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   ContextTransactionManager . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   ContextTransactionSynchronizationRegistry . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionSynchronizationRegistry"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   getTransactionTimeout ( methodIntf ,    MethodIdentifier . getIdentifierForMethod ( method )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionTimeout"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "Integer   txTimeout    =    txTimeouts . get ( new   MethodTransactionAttributeKey ( methodIntf ,    method )  )  ;", "if    (  ( txTimeout    =  =    null )     &  &     ( methodIntf    !  =     ( MethodIntf . BEAN )  )  )     {", "txTimeout    =    txTimeouts . get ( new   MethodTransactionAttributeKey ( MethodIntf . BEAN ,    method )  )  ;", "}", "if    ( txTimeout    =  =    null )", "return    -  1  ;", "return   txTimeout ;", "}", "METHOD_END"], "methodName": ["getTransactionTimeout"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . userTransaction ;", "}", "METHOD_END"], "methodName": ["getUserTransaction"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   isBeanManagedTransaction ;", "}", "METHOD_END"], "methodName": ["isBeanManagedTransaction"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( isSecurityDomainKnown (  )  )     {", "if    ( enableJacc )     {", "Policy   policy    =     ( WildFlySecurityManager . isChecking (  )  )     ?    AccessController . doPrivileged (  (  ( PrivilegedAction < Policy >  )     ( Policy :  : getPolicy )  )  )     :    Policy . getPolicy (  )  ;", "ProtectionDomain   domain    =    new   ProtectionDomain ( null ,    null ,    null ,    JaccInterceptor . getGrantedRoles ( getCallerSecurityIdentity (  )  )  )  ;", "return   policy . implies ( domain ,    new   EJBRoleRefPermission ( getName (  )  ,    roleName )  )  ;", "} else    {", "return   checkCallerSecurityIdentityRole ( roleName )  ;", "}", "} else", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   WildFlySecurityManager . doUnchecked (  (  ( PrivilegedAction < Boolean >  )     (  (  )     -  >    serverSecurityManager . isCallerInRole ( getName (  )  ,    policyContextID ,    securityMetaData . getSecurityRoles (  )  ,    securityMetaData . getSecurityRoleLinks (  )  ,    roleName )  )  )  )  ;", "} else    {", "return   this . serverSecurityManager . isCallerInRole ( getName (  )  ,    policyContextID ,    securityMetaData . getSecurityRoles (  )  ,    securityMetaData . getSecurityRoleLinks (  )  ,    roleName )  ;", "}", "}", "METHOD_END"], "methodName": ["isCallerInRole"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   exceptionLoggingEnabled . get (  )  ;", "}", "METHOD_END"], "methodName": ["isExceptionLoggingEnabled"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return    ( securityDomain )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSecurityDomainKnown"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   utilities . isStatisticsEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isStatisticsEnabled"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "Boolean   txAttr    =    txExplicitAttrs . get ( new   MethodTransactionAttributeKey ( methodIntf ,    method )  )  ;", "if    (  ( txAttr    =  =    null )     &  &     ( methodIntf    !  =     ( MethodIntf . BEAN )  )  )     {", "txAttr    =    txExplicitAttrs . get ( new   MethodTransactionAttributeKey ( MethodIntf . BEAN ,    method )  )  ;", "}", "if    ( txAttr    =  =    null )", "return   false ;", "return   txAttr ;", "}", "METHOD_END"], "methodName": ["isTransactionAttributeTypeExplicit"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . jndiNameCannotBeNull (  )  ;", "}", "final   NamespaceContextSelector   namespaceContextSelector    =    NamespaceContextSelector . getCurrentSelector (  )  ;", "if    ( namespaceContextSelector    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . noNamespaceContextSelectorAvailable ( name )  ;", "}", "Context   jndiContext    =    null ;", "String   namespaceStrippedJndiName    =    name ;", "if    ( name . startsWith (  \" java : app /  \"  )  )     {", "jndiContext    =    namespaceContextSelector . getContext (  \" app \"  )  ;", "namespaceStrippedJndiName    =    name . substring (  \" java : app /  \"  . length (  )  )  ;", "} else", "if    ( name . startsWith (  \" java : module /  \"  )  )     {", "jndiContext    =    namespaceContextSelector . getContext (  \" module \"  )  ;", "namespaceStrippedJndiName    =    name . substring (  \" java : module /  \"  . length (  )  )  ;", "} else", "if    ( name . startsWith (  \" java :  /  \"  )  )     {", "jndiContext    =    namespaceContextSelector . getContext (  \"  \"  )  ;", "namespaceStrippedJndiName    =    name . substring (  \" java :  /  \"  . length (  )  )  ;", "} else", "if    (  !  ( name . startsWith (  \" java :  \"  )  )  )     {", "jndiContext    =    namespaceContextSelector . getContext (  \"  \"  )  ;", "namespaceStrippedJndiName    =     \" env /  \"     +    name ;", "} else", "if    ( name . startsWith (  \" java : global /  \"  )  )     {", "try    {", "jndiContext    =    new   InitialContext (  )  ;", "}    catch    ( NamingException   ne )     {", "throw   EjbLogger . ROOT _ LOGGER . failToLookupJNDI ( name ,    ne )  ;", "}", "} else    {", "throw   EjbLogger . ROOT _ LOGGER . failToLookupJNDINameSpace ( name )  ;", "}", "EjbLogger . ROOT _ LOGGER . debugf (  \" Looking   up    % s   in   jndi   context :     % s \"  ,    namespaceStrippedJndiName ,    jndiContext )  ;", "try    {", "return   jndiContext . lookup ( namespaceStrippedJndiName )  ;", "}    catch    ( NamingException   ne )     {", "throw   EjbLogger . ROOT _ LOGGER . failToLookupStrippedJNDI ( namespaceContextSelector ,    jndiContext ,    ne )  ;", "}", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "this . incomingRunAsIdentity    =    identity ;", "}", "METHOD_END"], "methodName": ["setIncomingRunAsIdentity"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( isBeanManagedTransaction (  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToCallSetRollbackOnlyOnNCMB (  )  ;", "}", "try    {", "TransactionManager   tm    =    getTransactionManager (  )  ;", "if    (  ( tm . getTransaction (  )  )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . failToCallSetRollbackOnlyWithNoTx (  )  ;", "}", "tm . setRollbackOnly (  )  ;", "}    catch    ( SystemException   se )     {", "EjbLogger . ROOT _ LOGGER . setRollbackOnlyFailed ( se )  ;", "}", "}", "METHOD_END"], "methodName": ["setRollbackOnly"], "fileName": "org.jboss.as.ejb3.component.EJBComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationExceptions ;", "}", "METHOD_END"], "methodName": ["getApplicationExceptions"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   applicationSecurityDomain . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationSecurityDomain"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   applicationSecurityDomain ;", "}", "METHOD_END"], "methodName": ["getApplicationSecurityDomainInjector"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   componentConfiguration . getlass (  )  . getMethod ( name ,    parameterTypes )  ;", "}    catch    ( NoSuchMethodException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getComponentMethod"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . controlPoint . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getControlPoint"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . controlPoint ;", "}", "METHOD_END"], "methodName": ["getControlPointInjector"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   distinctName ;", "}", "METHOD_END"], "methodName": ["getDistinctName"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . ejbSuspendHandler . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getEJBSuspendHandler"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . ejbSuspendHandler ;", "}", "METHOD_END"], "methodName": ["getEJBSuspendHandlerInjector"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    getDeploymentUnitInjector (  )  . getValue (  )  ;", "final   Controller < EJBUtilities >    serviceController    =     (  ( Controller < EJBUtilities >  )     ( deploymentUnit . getRegistry (  )  . getRequired ( EJBUtilities . SERVICE _ NAME )  )  )  ;", "return   serviceController . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getEJBUtilities"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . earApplicationName ;", "}", "METHOD_END"], "methodName": ["getEarApplicationName"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   ejbHome ;", "}", "METHOD_END"], "methodName": ["getEjbHome"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   ejbLocalHome ;", "}", "METHOD_END"], "methodName": ["getEjbLocalHome"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   ejbLocalObject ;", "}", "METHOD_END"], "methodName": ["getEjbLocalObject"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   ejbObject ;", "}", "METHOD_END"], "methodName": ["getEjbObject"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   exceptionLoggingEnabled . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getExceptionLoggingEnabled"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   exceptionLoggingEnabled ;", "}", "METHOD_END"], "methodName": ["getExceptionLoggingEnabledInjector"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   txExplicitAttrs ;", "}", "METHOD_END"], "methodName": ["getExplicitTxAttrs"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   identityOutflowFunction . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getIdentityOutflowFunction"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   identityOutflowFunction ;", "}", "METHOD_END"], "methodName": ["getIdentityOutflowFunctionInjector"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . policyContextID ;", "}", "METHOD_END"], "methodName": ["getPolicyContextID"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "ApplicationSecurityDomainService . ApplicationSecurityDomain   applicationSecurityDomain    =    getApplicationSecurityDomain (  )  ;", "return   applicationSecurityDomain    !  =    null    ?    applicationSecurityDomain . getSecurityDomain (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getSecurityDomain"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . securityMetaData ;", "}", "METHOD_END"], "methodName": ["getSecurityMetaData"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . serverSecurityManagerInjectedValue . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getServerSecurityManager"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . serverSecurityManagerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getServerSecurityManagerInjector"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   shutDownInterceptorFactory ;", "}", "METHOD_END"], "methodName": ["getShutDownInterceptorFactory"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   timeoutInterceptors ;", "}", "METHOD_END"], "methodName": ["getTimeoutInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   timeoutMethod ;", "}", "METHOD_END"], "methodName": ["getTimeoutMethod"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   timerService ;", "}", "METHOD_END"], "methodName": ["getTimerService"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   transactionManagementType ;", "}", "METHOD_END"], "methodName": ["getTransactionManagementType"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   txAttrs ;", "}", "METHOD_END"], "methodName": ["getTxAttrs"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   txTimeouts ;", "}", "METHOD_END"], "methodName": ["getTxTimeouts"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . userTransactionInjectedValue . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getUserTransaction"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . userTransactionInjectedValue ;", "}", "METHOD_END"], "methodName": ["getUserTransactionInjector"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   viewServices ;", "}", "METHOD_END"], "methodName": ["getViewServices"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "ApplicationSecurityDomainService . ApplicationSecurityDomain   applicationSecurityDomain    =    getApplicationSecurityDomain (  )  ;", "return   applicationSecurityDomain    !  =    null    ?    applicationSecurityDomain . isEnableJacc (  )     :    false ;", "}", "METHOD_END"], "methodName": ["isEnableJacc"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   securityRequired ;", "}", "METHOD_END"], "methodName": ["isSecurityRequired"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "if    ( this . getTransactionManagementType (  )  . equals ( BEAN )  )     {", "return ;", "}", "MethodIntf   defaultMethodIntf    =     ( ejbDescription   instanceof   MessageDrivenDescription )     ?    MethodIntf . MESSAGE _ ENDPOINT    :    MethodIntf . BEAN ;", "TransactionAttributeType   txAttr    =    ejbDescription . getTransactionAttributes (  )  . getAttribute ( methodIntf ,    method ,    defaultMethodIntf )  ;", "MethodTransactionAttributeKey   key    =    new   MethodTransactionAttributeKey ( methodIntf ,    MethodIdentifier . getIdentifierForMethod ( method )  )  ;", "if    ( txAttr    !  =    null )     {", "txAttrs . put ( key ,    txAttr )  ;", "txExplicitAttrs . put ( key ,    ejbDescription . getTransactionAttributes (  )  . isMethodLevel ( methodIntf ,    method ,    defaultMethodIntf )  )  ;", "}", "Integer   txTimeout    =    ejbDescription . getTransactionTimeouts (  )  . getAttribute ( methodIntf ,    method ,    defaultMethodIntf )  ;", "if    ( txTimeout    !  =    null )     {", "txTimeouts . put ( key ,    txTimeout )  ;", "}", "}", "METHOD_END"], "methodName": ["processTxAttr"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "if    ( ejbJarConfiguration    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . EjbJarConfigurationIsNull (  )  ;", "}", "thiJarConfiguration    =    ejbJarConfiguration ;", "}", "METHOD_END"], "methodName": ["setEjbJarConfiguration"], "fileName": "org.jboss.as.ejb3.component.EJBComponentCreateServiceFactory"}, {"methodBody": ["METHOD_START", "{", "this . declaredRoles . addAll ( Arrays . asList ( roles )  )  ;", "}", "METHOD_END"], "methodName": ["addDeclaredRoles"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "getConfigurators (  )  . add ( new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final      description ,    final   ComponentConfiguration   componentConfiguration )    throws   DeploymentUnitProcessingException    {", "componentConfiguration . getCreateDependencies (  )  . add ( new   DependencyConfigurator < EJBComponentCreateService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    final   EJBComponentCreateService   ejbComponentCreateService )    throws   DeploymentUnitProcessingException    {", "serviceBuilder . addDependency ( EJBSuspendHandlerService . SERVICE _ NAME ,    EJBSuspendHandlerService . class ,    ejbComponentCreateService . getEJBSuspendHandlerInjector (  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addEJBSuspendHandlerDependency"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   EJBViewDescription   view    =    registerView ( viewClassName ,    MethodIntf . LOCAL ,    true )  ;", "view . getConfigurators (  )  . add ( new    . Ejb 2 ViewTypeConfigurator ( Ejb 2 xViewType . LOCAL )  )  ;", "this . ejbLocalView    =    view ;", "}", "METHOD_END"], "methodName": ["addEjbLocalObjectView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   EJBViewDescription   view    =    registerView ( viewClassName ,    MethodIntf . REMOTE ,    true )  ;", "view . getConfigurators (  )  . add ( new    . Ejb 2 ViewTypeConfigurator ( Ejb 2 xViewType . REMOTE )  )  ;", "this . ejbRemoteView    =    view ;", "}", "METHOD_END"], "methodName": ["addEjbObjectView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   EjbHomeViewDescription   view    =    new   EjbHomeViewDescription ( this ,    localHome ,    MethodIntf . LOCAL _ HOME )  ;", "view . getConfigurators (  )  . add ( new    . Ejb 2 ViewTypeConfigurator ( Ejb 2 xViewType . LOCAL _ HOME )  )  ;", "getViews (  )  . add ( view )  ;", "setupViewInterceptors ( view )  ;", "setupClientViewInterceptors ( view )  ;", "this . ejbLocalHomeView    =    view ;", "}", "METHOD_END"], "methodName": ["addLocalHome"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   EjbHomeViewDescription   view    =    new   EjbHomeViewDescription ( this ,    remoteHome ,    MethodIntf . HOME )  ;", "view . getConfigurators (  )  . add ( new    . Ejb 2 ViewTypeConfigurator ( Ejb 2 xViewType . HOME )  )  ;", "getViews (  )  . add ( view )  ;", "setupViewInterceptors ( view )  ;", "setupClientViewInterceptors ( view )  ;", "this . ejbHomeView    =    view ;", "}", "METHOD_END"], "methodName": ["addRemoteHome"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . getConfigurators (  )  . add ( new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentDescription   description ,    ComponentConfiguration   componentConfiguration )    throws   DeploymentUnitProcessingException    {", "if    ( this . hasRemoteView (  (  (  )     ( description )  )  )  )     {", "componentConfiguration . getCreateDependencies (  )  . add (  (    sb ,    cs )     -  >    sb . addDependency ( TxnServices . JBOSS _ TXN _ REMOTE _ TRANSACTION _ SERVICE )  )  ;", "}", "}", "private   boolean   hasRemoteView ( final      ejbComponentDescription )     {", "final   Set < ViewDescription >    views    =    ejbComponentDescription . getViews (  )  ;", "for    ( final   ViewDescription   view    :    views )     {", "if    (  !  ( view   instanceof   EJBViewDescription )  )     {", "continue ;", "}", "final   MethodIntf   viewType    =     (  ( EJBViewDescription )     ( view )  )  . getMethodIntf (  )  ;", "if    (  ( viewType    =  =     ( MethodIntf . REMOTE )  )     |  |     ( viewType    =  =     ( MethodIntf . HOME )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addRemoteTransactionsDependency"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "List < AutoTimer >    schedules    =    scheduleMethods . get ( method )  ;", "if    ( schedules    =  =    null )     {", "scheduleMethods . put ( method ,     ( schedules    =    new   ArrayList < AutoTimer >  (  1  )  )  )  ;", "}", "scheduledd ( timer )  ;", "}", "METHOD_END"], "methodName": ["addScheduleMethod"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "getConfigurators (  )  . add ( new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentDescription   description ,    final   ComponentConfiguration   componentConfiguration )    throws   DeploymentUnitProcessingException    {", "if    (  !  (  (  (  )     ( description )  )  . isSecurityDomainKnown (  )  )  )     {", "final   DeploymentUnit   deploymentUnit    =    context . getDeploymentUnit (  )  ;", "final   CapabilityServiceSupport   support    =    deploymentUnit . getAttachment ( CAPABILITY _ SERVICE _ SUPPORT )  ;", "componentConfiguration . getCreateDependencies (  )  . add ( new   DependencyConfigurator < EJBComponentCreateService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    final   EJBComponentCreateService   ejbComponentCreateService )    throws   DeploymentUnitProcessingException    {", "serviceBuilder . addDependency ( support . getCapabilityServiceName (  \" legacy - security . server - security - manager \"  )  ,    ServerSecurityManager . class ,    ejbComponentCreateService . getServerSecurityManagerInjector (  )  )  ;", "}", "}  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addServerSecurityManagerDependency"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentConfiguration   componentConfiguration ,    ViewDescription   description ,    ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final   Method   TO _ STRING _ METHOD ;", "try    {", "TO _ STRING _ METHOD    =    Object . class . getMethod (  \" toString \"  )  ;", "}    catch    ( NoSuchMethodException   nsme )     {", "throw   new   DeploymentUnitProcessingException ( nsme )  ;", "}", "List < Method >    methods    =    configuration . getProxyFactory (  )  . getCachedMethods (  )  ;", "for    ( Method   method    :    methods )     {", "if    ( TO _ STRING _ METHOD . equals ( method )  )     {", "configuration . addClientInterceptor ( method ,    new   ImmediateInterceptorFactory ( new    . ToStringMethodInterceptor (  . this . getComponentName (  )  )  )  ,    TO _ STRING )  ;", "return ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addToStringMethodInterceptor"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . getConfigurators (  )  . add ( new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final      description ,    final   ComponentConfiguration   componentConfiguration )    throws   DeploymentUnitProcessingException    {", "componentConfiguration . getCreateDependencies (  )  . add ( new   DependencyConfigurator < EJBComponentCreateService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    final   EJBComponentCreateService   ejbComponentCreateService )    throws   DeploymentUnitProcessingException    {", "serviceBuilder . addDependency ( JBOSS _ TXN _ TRANSACTION _ MANAGER )  ;", "serviceBuilder . addDependency ( JBOSS _ TXN _ USER _ TRANSACTION ,    UserTransaction . class ,    ejbComponentCreateService . getUserTransactionInjector (  )  )  ;", "serviceBuilder . addDependency ( JBOSS _ TXN _ SYNCHRONIZATION _ REGISTRY )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addTransactionManagerDependencies"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . excludeClassLevelContainerInterceptorsForMethod . put ( methodIdentifier ,    true )  ;", "}", "METHOD_END"], "methodName": ["excludeClassLevelContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . excludeDefaultContainerInterceptorsForMethod . put ( methodIdentifier ,    true )  ;", "}", "METHOD_END"], "methodName": ["excludeDefaultContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . allContainerInterceptors )     =  =    null )     {", "this . allContainerInterceptors    =    new   HashSet < Interceptor >  (  )  ;", "this . allContainerInterceptors . addAll ( this . classLevelContainerInterceptors )  ;", "if    (  !  ( this . excludeDefaultContainerInterceptors )  )     {", "this . allContainerInterceptors . addAll ( this . defaultContainerInterceptors )  ;", "}", "for    ( List < Interceptor >    interceptors    :    this . methodLevelContainerInterceptors . values (  )  )     {", "this . allContainerInterceptors . addAll ( interceptors )  ;", "}", "}", "return   this . allContainerInterceptors ;", "}", "METHOD_END"], "methodName": ["getAllContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   annotationMethodPermissions ;", "}", "METHOD_END"], "methodName": ["getAnnotationMethodPermissions"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . classLevelContainerInterceptors ;", "}", "METHOD_END"], "methodName": ["getClassLevelContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . declaredRoles )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredRoles"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultContainerInterceptors ;", "}", "METHOD_END"], "methodName": ["getDefaultContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   descriptorData ;", "}", "METHOD_END"], "methodName": ["getDescriptorData"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   descriptorMethodPermissions ;", "}", "METHOD_END"], "methodName": ["getDescriptorMethodPermissions"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . getComponentClassName (  )  ;", "}", "METHOD_END"], "methodName": ["getEJBClassName"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . getComponentName (  )  ;", "}", "METHOD_END"], "methodName": ["getEJBName"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   ejbHomeView ;", "}", "METHOD_END"], "methodName": ["getEjbHomeView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   ejbLocalHomeView ;", "}", "METHOD_END"], "methodName": ["getEjbLocalHomeView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   ejbLocalView ;", "}", "METHOD_END"], "methodName": ["getEjbLocalView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   ejbRemoteView ;", "}", "METHOD_END"], "methodName": ["getEjbRemoteView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   HashMap < Integer ,    InterceptorFactory >    interceptorFactories    =    new   HashMap <  >  (  2  )  ;", "final   Set < String >    roles    =    new   HashSet <  >  (  )  ;", "interceptorFactories . put ( SECURITY _ CONTEXT ,    SecurityDomainInterceptorFactory . INSTANCE )  ;", "if    ( enableJacc )     {", "interceptorFactories . put ( POLICY _ CONTEXT ,    new   ImmediateInterceptorFactory ( new   PolicyContextIdInterceptor ( policyContextID )  )  )  ;", "}", "if    (  ( securityRoles )     !  =    null )     {", "final   Map < String ,    Set < String >  >    principalVsRolesMap    =    securityRoles . getPrincipalVersusRolesMap (  )  ;", "if    (  !  ( principalVsRolesMap . isEmpty (  )  )  )     {", "interceptorFactories . put ( SECURITY _ ROLES ,    new   ImmediateInterceptorFactory ( new   SecurityRolesAddingInterceptor (  \" ejb \"  ,    principalVsRolesMap )  )  )  ;", "}", "}", "if    (  ( runAsPrincipal )     !  =    null )     {", "interceptorFactories . put ( RUN _ AS _ PRINCIPAL ,    new   ImmediateInterceptorFactory ( new   RunAsPrincipalInterceptor ( runAsPrincipal )  )  )  ;", "if    (  ( securityRoles )     !  =    null )     {", "final   Set < String >    extraRoles    =    securityRoles . getSecurityRoleNamesByPrincipal ( runAsPrincipal )  ;", "if    (  !  ( extraRoles . isEmpty (  )  )  )     {", "interceptorFactories . put ( EXTRA _ PRINCIPAL _ ROLES ,    new   ImmediateInterceptorFactory ( new   RoleAddingInterceptor (  \" ejb \"  ,    RoleMapper . constant ( Roles . fromSet ( extraRoles )  )  )  )  )  ;", "roles . addAll ( extraRoles )  ;", "}", "}", "} else", "if    (  ! propagateSecurity )     {", "interceptorFactories . put ( RUN _ AS _ PRINCIPAL ,    new   ImmediateInterceptorFactory ( new   RunAsPrincipalInterceptor ( RunAsPrincipalInterceptor . ANONYMOUS _ PRINCIPAL )  )  )  ;", "}", "if    (  ( runAsRole )     !  =    null )     {", "interceptorFactories . put ( RUN _ AS _ ROLE ,    new   ImmediateInterceptorFactory ( new   RoleAddingInterceptor (  \" ejb \"  ,    RoleMapper . constant ( Roles . fromSet ( Collecs . singleton ( runAsRole )  )  )  )  )  )  ;", "roles . add ( runAsRole )  ;", "}", "if    (  !  ( roles . isEmpty (  )  )  )     {", "interceptorFactories . put ( SECURITY _ IDENTITY _ OUTFLOW ,    new   IdentityOutflowInterceptorFactory (  \" ejb \"  ,    RoleMapper . constant ( Roles . fromSet ( roles )  )  )  )  ;", "} else    {", "interceptorFactories . put ( SECURITY _ IDENTITY _ OUTFLOW ,    IdentityOutflowInterceptorFactory . INSTANCE )  ;", "}", "RoleMapper . constant ( Roles . fromSet ( getDeclaredRoles (  )  )  )  ;", "return   interceptorFactories ;", "}", "METHOD_END"], "methodName": ["getElytronInterceptorFactories"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . methodLevelContainerInterceptors ;", "}", "METHOD_END"], "methodName": ["getMethodLevelContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   policyContextID ;", "}", "METHOD_END"], "methodName": ["getPolicyContextID"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . runAsRole ;", "}", "METHOD_END"], "methodName": ["getRunAs"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   runAsPrincipal ;", "}", "METHOD_END"], "methodName": ["getRunAsPrincipal"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( scheduleMethods )  ;", "}", "METHOD_END"], "methodName": ["getScheduleMethods"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . securityDomain )     =  =    null )     {", "return   this . defaultSecurityDomain ;", "}", "return   this . securityDomain ;", "}", "METHOD_END"], "methodName": ["getSecurityDomain"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . securityRoleLinks )  ;", "}", "METHOD_END"], "methodName": ["getSecurityRoleLinks"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   securityRoles ;", "}", "METHOD_END"], "methodName": ["getSecurityRoles"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   shutDownInterceptorFactory ;", "}", "METHOD_END"], "methodName": ["getShutDownInterceptorFactory"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   timeoutMethod ;", "}", "METHOD_END"], "methodName": ["getTimeoutMethod"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   Set < MethodIdentifier >    methods    =    new   HashSet < MethodIdentifier >  (  )  ;", "if    (  ( timeoutMethod )     !  =    null )     {", "methods . add ( MethodIdentifier . getIdentifierForMethod ( timeoutMethod )  )  ;", "}", "for    ( Method   method    :    scheduleMethods . keySet (  )  )     {", "methods . add ( MethodIdentifier . getIdentifierForMethod ( method )  )  ;", "}", "return   methods ;", "}", "METHOD_END"], "methodName": ["getTimerMethods"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   timerService ;", "}", "METHOD_END"], "methodName": ["getTimerService"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   transactionAttributes ;", "}", "METHOD_END"], "methodName": ["getTransactionAttributes"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   transactionManagementType ;", "}", "METHOD_END"], "methodName": ["getTransactionManagementType"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   transactionTimeouts ;", "}", "METHOD_END"], "methodName": ["getTransactionTimeouts"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( securityDomain )     !  =    null )     {", "return   true ;", "}", "if    (  ( runAsRole )     !  =    null )     {", "return   true ;", "}", "if    (  ( runAsPrincipal )     !  =    null )     {", "return   true ;", "}", "if    (  (  ( securityRoles )     !  =    null )     &  &     (  !  ( securityRoles . isEmpty (  )  )  )  )     {", "return   true ;", "}", "if    (  (  ( securityRoleLinks )     !  =    null )     &  &     (  !  ( securityRoleLinks . isEmpty (  )  )  )  )     {", "return   true ;", "}", "if    (  (  ( declaredRoles )     !  =    null )     &  &     (  !  ( declaredRoles . isEmpty (  )  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasBeanLevelSecurityMetadata"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "ApplicationSecurityDomainConfig   config    =     (  ( knownSecurityDomain )     =  =    null )     ?    null    :    knownSecurityDomain . apply ( getSecurityDomain (  )  )  ;", "if    ( config    !  =    null )     {", "return   config . isEnableJacc (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEnableJacc"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isEntity"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    ( this . excludeClassLevelContainerInterceptorsForMethod . get ( methodIdentifier )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isExcludeClassLevelContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . excludeDefaultContainerInterceptors ;", "}", "METHOD_END"], "methodName": ["isExcludeDefaultContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    ( this . excludeDefaultContainerInterceptorsForMethod . get ( methodIdentifier )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isExcludeDefaultContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    ( this . securityDomain )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isExplicitSecurityDomainConfigured"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   exposedViaIiop ;", "}", "METHOD_END"], "methodName": ["isExposedViaIiop"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isMessageDriven"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . missingMethodPermissionsDenyAccess ;", "}", "METHOD_END"], "methodName": ["isMissingMethodPermissionsDeniedAccess"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   outflowSecurityDomainsConfigured . getAsBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["isOutflowSecurityDomainsConfigured"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    ( knownSecurityDomain )     =  =    null    ?    false    :     ( knownSecurityDomain . apply ( getSecurityDomain (  )  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSecurityDomainKnown"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   securityRequired ;", "}", "METHOD_END"], "methodName": ["isSecurityRequired"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isSession"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isSingleton"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isStateful"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isStateless"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fromRole    =  =    null )     |  |     ( fromRole . trim (  )  . isEmpty (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToLinkFromEmptySecurityRole ( fromRole )  ;", "}", "if    (  ( toRole    =  =    null )     |  |     ( toRole . trim (  )  . isEmpty (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToLinkToEmptySecurityRole ( toRole )  ;", "}", "Collec < String >    roleLinks    =    this . securityRoleLinks . get ( fromRole )  ;", "if    ( roleLinks    =  =    null )     {", "roleLinks    =    new   HashSet < String >  (  )  ;", "this . securityRoleLinks . put ( fromRole ,    roleLinks )  ;", "}", "roleLinks . add ( toRole )  ;", "}", "METHOD_END"], "methodName": ["linkSecurityRoles"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   registerView ( viewClassName ,    viewType ,    false )  ;", "}", "METHOD_END"], "methodName": ["registerView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   EJBViewDescription   viewDescription    =    new   EJBViewDescription ( this ,    viewClassName ,    viewType ,    ejb 2 xView )  ;", "getViews (  )  . add ( viewDescription )  ;", "setupViewInterceptors ( viewDescription )  ;", "setupClientViewInterceptors ( viewDescription )  ;", "if    (  ( viewType    =  =     ( MethodIntf . REMOTE )  )     |  |     ( viewType    =  =     ( MethodIntf . HOME )  )  )     {", "setupRemoteView ( viewDescription )  ;", "}", "return   viewDescription ;", "}", "METHOD_END"], "methodName": ["registerView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . classLevelContainerInterceptors    =    containerInterceptors ;", "}", "METHOD_END"], "methodName": ["setClassLevelContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( roles    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . SecurityRolesIsNull (  )  ;", "}", "this . declaredRoles . clear (  )  ;", "this . declaredRoleddAll ( roles )  ;", "}", "METHOD_END"], "methodName": ["setDeclaredRoles"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . defaultContainerInterceptors    =    defaultInterceptors ;", "}", "METHOD_END"], "methodName": ["setDefaultContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . defaultSecurityDomain    =    defaultSecurityDomain ;", "}", "METHOD_END"], "methodName": ["setDefaultSecurityDomain"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . excludeDefaultContainerInterceptors    =    excludeDefaultContainerInterceptors ;", "}", "METHOD_END"], "methodName": ["setExcludeDefaultContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . exposedViaIiop    =    exposedViaIiop ;", "}", "METHOD_END"], "methodName": ["setExposedViaIiop"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . knownSecurityDomain    =    knownSecurityDomain ;", "}", "METHOD_END"], "methodName": ["setKnownSecurityDomainFunction"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . methodLevelContainerInterceptors . put ( methodIdentifier ,    containerInterceptors )  ;", "}", "METHOD_END"], "methodName": ["setMethodContainerInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . missingMethodPermissionsDenyAccess    =    missingMethodPermissionsDenyAccess ;", "}", "METHOD_END"], "methodName": ["setMissingMethodPermissionsDenyAccess"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . outflowSecurityDomainsConfigured    =    outflowSecurityDomainsConfigured ;", "}", "METHOD_END"], "methodName": ["setOutflowSecurityDomainsConfigured"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . policyContextID    =    policyContextID ;", "}", "METHOD_END"], "methodName": ["setPolicyContextID"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . runAsRole    =    role ;", "}", "METHOD_END"], "methodName": ["setRunAs"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . runAsPrincipal    =    principal ;", "}", "METHOD_END"], "methodName": ["setRunAsPrincipal"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . securityDomain    =    securityDomain ;", "}", "METHOD_END"], "methodName": ["setSecurityDomain"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . securityRequired    =    securityRequired ;", "}", "METHOD_END"], "methodName": ["setSecurityRequired"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . securityRoles    =    securityRoles ;", "}", "METHOD_END"], "methodName": ["setSecurityRoles"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . timeoutMethod    =    timeoutMethod ;", "}", "METHOD_END"], "methodName": ["setTimeoutMethod"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . timerService    =    timerService ;", "}", "METHOD_END"], "methodName": ["setTimerService"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . transactionManagementType    =    transactionManagementType ;", "}", "METHOD_END"], "methodName": ["setTransactionManagementType"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . addToStringMethodInterceptor ( view )  ;", "}", "METHOD_END"], "methodName": ["setupClientViewInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "viewDescription . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   ViewDescription   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "configuration . getDependencies (  )  . add ( new   e . component . DependencyConfigurator < ViewService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    final   ViewService   service )    throws   DeploymentUnitProcessingException    {", "CapabilityServiceSupport   support    =    context . getDeploymentUnit (  )  . getAttachment ( CAPABILITY _ SERVICE _ SUPPORT )  ;", "serviceBuilder . addDependency ( support . getCapabilityServiceName ( EJB 3 RemoteResourceDefinition . EJB _ REMOTE _ CAPABILITY _ NAME )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setupRemoteView"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( view . getMethodIntf (  )  )     =  =     ( MethodIntf . REMOTE )  )     |  |     (  ( view . getMethodIntf (  )  )     =  =     ( MethodIntf . HOME )  )  )     {", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   ViewDescription   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "if    ( Remote . class . isAssignableFrom ( configuration . getViewClass (  )  )  )     {", "configuration . addViewInterceptor ( EjbExceptionTransformingInterceptorFactories . REMOTE _ INSTANCE ,    REMOTE _ EXCEPTION _ TRANSFORMER )  ;", "}", "}", "}  )  ;", "if    (  ( view . getMethodIntf (  )  )     =  =     ( MethodIntf . HOME )  )     {", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   ViewDescription   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "if    ( Remote . class . isAssignableFrom ( configuration . getViewClass (  )  )  )     {", "final   String   earApplicationName    =    componentConfiguration . get (  )  . getModuleDescription (  )  . getEarApplicationName (  )  ;", "configuration . setViewInstanceFactory ( new   RemoteHomeViewInstanceFactory ( earApplicationName ,    componentConfiguration . getModuleName (  )  ,    componentConfiguration . get (  )  . getModuleDescription (  )  . getDistinctName (  )  ,    componentConfiguration . getComponentName (  )  )  )  ;", "}", "}", "}  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setupRemoteViewInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . getConfigurators (  )  . add ( new   EJBSecurityViewConfigurator (  )  )  ;", "}", "METHOD_END"], "methodName": ["setupSecurityInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentConfiguration   componentConfiguration ,    View   description ,    ViewConfiguration   viewConfiguration )    throws   DeploymentUnitProcessingException    {", "viewConfiguration . addViewInterceptor ( LoggingInterceptor . FACTORY ,    EJB _ EXCEPTION _ LOGGING _ INTERCEPTOR )  ;", "final   ClassLoader   classLoader    =    componentConfiguration . getModuleClassLoader (  )  ;", "viewConfiguration . addViewInterceptor ( AccessCheckingInterceptor . getFactory (  )  ,    CHECKING _ INTERCEPTOR )  ;", "viewConfiguration . addViewInterceptor ( new   ImmediateInterceptorFactory ( new   ContextClassLoaderInterceptor ( classLoader )  )  ,    TCCL _ INTERCEPTOR )  ;", "if    (  (  ( view . getMethodIntf (  )  )     =  =     ( MethodIntf . LOCAL )  )     &  &     ( EJBLocalObject . class . isAssignableFrom ( viewConfiguration . getViewClass (  )  )  )  )     {", "viewConfiguration . addViewInterceptor ( EjbExceptionTransformingInterceptorFactories . LOCAL _ INSTANCE ,    REMOTE _ EXCEPTION _ TRANSFORMER )  ;", "} else", "if    (  ( view . getMethodIntf (  )  )     =  =     ( MethodIntf . LOCAL _ HOME )  )     {", "viewConfiguration . addViewInterceptor ( EjbExceptionTransformingInterceptorFactories . LOCAL _ INSTANCE ,    REMOTE _ EXCEPTION _ TRANSFORMER )  ;", "}", "final   List < SetupAction >    ejbSetupActions    =    context . getDeploymentUnit (  )  . getAttachmentList ( OTHER _ EE _ SETUP _ ACTIONS )  ;", "if    (  !  ( ejbSetupActions . isEmpty (  )  )  )     {", "viewConfiguration . addViewInterceptor ( AdditionalSetupInterceptor . factory ( ejbSetupActions )  ,    EE _ SETUP )  ;", "}", "viewConfiguration . addViewInterceptor ( WaitTimeInterceptor . FACTORY ,    EJB _ WAIT _ TIME _ INTERCEPTOR )  ;", "viewConfiguration . addViewInterceptor ( shutDownInterceptorFactory ,    SHUTDOWN _ INTERCEPTOR )  ;", "}", "}  )  ;", "this . addCurrentInvocationContextFactory ( view )  ;", "this . setupSecurityInterceptors ( view )  ;", "this . setupRemoteViewInterceptors ( view )  ;", "view . getConfigurators (  )  . addFirst ( new   NamespaceViewConfigurator (  )  )  ;", "}", "METHOD_END"], "methodName": ["setupViewInterceptors"], "fileName": "org.jboss.as.ejb3.component.EJBComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    context . getDeploymentUnit (  )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   Map < String ,    List < InterceptorFactory >  >    userAroundInvokesByInterceptorClass    =    new   HashMap < String ,    List < InterceptorFactory >  >  (  )  ;", "final   Map < String ,    List < InterceptorFactory >  >    userAroundTimeoutsByInterceptorClass ;", "if    ( ejbComponentDescription . isTimerServiceRequired (  )  )     {", "userAroundTimeoutsByInterceptorClass    =    new   HashMap < String ,    List < InterceptorFactory >  >  (  )  ;", "} else    {", "userAroundTimeoutsByInterceptorClass    =    null ;", "}", "for    ( final   InterceptorDescription   interceptorDescription    :    ejbComponentDescription . getAllContainerInterceptors (  )  )     {", "final   String   interceptorClassName    =    interceptorDescription . getInterceptorClassName (  )  ;", "final   Class <  ?  >    intereptorClass ;", "try    {", "intereptorClass    =    ClassLoadingUtils . loadClass ( interceptorClassName ,    module )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   ROOT _ LOGGER . cannotLoadInterceptor ( e ,    interceptorClassName )  ;", "}", "final    . InterceptorClassDescriptionTraversal   interceptorClassDescriptionTraversal    =    new    . InterceptorClassDescriptionTraversal ( intereptorClass ,    applicationClasses ,    deploymentUnit ,    ejbComponentDescription )  ;", "interceptorClassDescriptionTraversal . run (  )  ;", "final   List < InterceptorFactory >    aroundInvokeInterceptorFactories    =    interceptorClassDescriptionTraversal . getAroundInvokeInterceptorFactories (  )  ;", "if    ( aroundInvokeInterceptorFactories    !  =    null )     {", "userAroundInvokesByInterceptorClass . put ( interceptorClassName ,    aroundInvokeInterceptorFactories )  ;", "}", "if    ( ejbComponentDescription . isTimerServiceRequired (  )  )     {", "final   List < InterceptorFactory >    aroundTimeoutInterceptorFactories    =    interceptorClassDescriptionTraversal . getAroundTimeoutInterceptorFactories (  )  ;", "if    ( aroundTimeoutInterceptorFactories    !  =    null )     {", "userAroundTimeoutsByInterceptorClass . put ( interceptorClassName ,    aroundTimeoutInterceptorFactories )  ;", "}", "}", "}", "final   List < InterceptorDescription >    classLevelContainerInterceptors    =    ejbComponentDescription . getClassLevelContainerInterceptors (  )  ;", "final   Map < MethodIdentifier ,    List < InterceptorDescription >  >    methodLevelContainerInterceptors    =    ejbComponentDescription . getMethodLevelContainerInterceptors (  )  ;", "final   List < Method >    viewMethods    =    viewConfiguration . getProxyFactory (  )  . getCachedMethods (  )  ;", "for    ( final   Method   method    :    viewMethods )     {", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( method . getReturnType (  )  ,    method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "final   List < InterceptorFactory >    aroundInvokesApplicableForMethod    =    new   ArrayList < InterceptorFactory >  (  )  ;", "final   List < InterceptorFactory >    aroundTimeoutsApplicableForMethod    =    new   ArrayList < InterceptorFactory >  (  )  ;", "if    (  (  !  ( ejbComponentDescription . isExcludeDefaultContainerInterceptors (  )  )  )     &  &     (  !  ( ejbComponentDescription . isExcludeDefaultContainerInterceptors ( methodIdentifier )  )  )  )     {", "for    ( final   InterceptorDescription   interceptorDescription    :    ejbComponentDescription . getDefaultContainerInterceptors (  )  )     {", "String   interceptorClassName    =    interceptorDescription . getInterceptorClassName (  )  ;", "final   List < InterceptorFactory >    aroundInvokesOnInterceptor    =    userAroundInvokesByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundInvokesOnInterceptor    !  =    null )     {", "aroundInvokesApplicableForMethod . addAll ( aroundInvokesOnInterceptor )  ;", "}", "if    ( ejbComponentDescription . isTimerServiceRequired (  )  )     {", "final   List < InterceptorFactory >    aroundTimeoutsOnInterceptor    =    userAroundTimeoutsByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundTimeoutsOnInterceptor    !  =    null )     {", "aroundTimeoutsApplicableForMethod . addAll ( aroundTimeoutsOnInterceptor )  ;", "}", "}", "}", "}", "if    (  !  ( ejbComponentDescription . isExcludeClassLevelContainerInterceptors ( methodIdentifier )  )  )     {", "for    ( final   InterceptorDescription   interceptorDescription    :    classLevelContainerInterceptors )     {", "String   interceptorClassName    =    interceptorDescription . getInterceptorClassName (  )  ;", "final   List < InterceptorFactory >    aroundInvokesOnInterceptor    =    userAroundInvokesByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundInvokesOnInterceptor    !  =    null )     {", "aroundInvokesApplicableForMethod . addAll ( aroundInvokesOnInterceptor )  ;", "}", "if    ( ejbComponentDescription . isTimerServiceRequired (  )  )     {", "final   List < InterceptorFactory >    aroundTimeoutsOnInterceptor    =    userAroundTimeoutsByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundTimeoutsOnInterceptor    !  =    null )     {", "aroundTimeoutsApplicableForMethod . addAll ( aroundTimeoutsOnInterceptor )  ;", "}", "}", "}", "}", "final   List < InterceptorDescription >    interceptorsForMethod    =    methodLevelContainerInterceptors . get ( methodIdentifier )  ;", "if    ( interceptorsForMethod    !  =    null )     {", "for    ( final   InterceptorDescription   methodLevelInterceptor    :    interceptorsForMethod )     {", "String   interceptorClassName    =    methodLevelInterceptor . getInterceptorClassName (  )  ;", "final   List < InterceptorFactory >    aroundInvokesOnInterceptor    =    userAroundInvokesByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundInvokesOnInterceptor    !  =    null )     {", "aroundInvokesApplicableForMethod . addAll ( aroundInvokesOnInterceptor )  ;", "}", "if    ( ejbComponentDescription . isTimerServiceRequired (  )  )     {", "final   List < InterceptorFactory >    aroundTimeoutsOnInterceptor    =    userAroundTimeoutsByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundTimeoutsOnInterceptor    !  =    null )     {", "aroundTimeoutsApplicableForMethod . addAll ( aroundTimeoutsOnInterceptor )  ;", "}", "}", "}", "}", "viewConfiguration . addViewInterceptor ( method ,    new   UserInterceptorFactory (  . weaved ( aroundInvokesApplicableForMethod )  ,     . weaved ( aroundTimeoutsApplicableForMethod )  )  ,    USER _ APP _ SPECIFIC _ CONTAINER _ INTERCEPTORS )  ;", "}", "}", "METHOD_END"], "methodName": ["doConfigure"], "fileName": "org.jboss.as.ejb3.component.EJBContainerInterceptorsViewConfigurator"}, {"methodBody": ["METHOD_START", "{", "return   new   InterceptorFactory (  )     {", "@ Override", "public   Interceptor   create ( InterceptorFactoryContext   context )     {", "final   Interceptor [  ]    interceptors    =    new   Interceptor [ interceptorFactories . size (  )  ]  ;", "final   Iterator < InterceptorFactory >    factories    =    interceptorFactories . iterator (  )  ;", "for    ( int   i    =     0  ;    i    <     ( interceptors . length )  ;    i +  +  )     {", "interceptors [ i ]     =    factories . next (  )  . create ( context )  ;", "}", "return    . getWeavedInterceptor ( interceptors )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["weaved"], "fileName": "org.jboss.as.ejb3.component.EJBContainerInterceptorsViewConfigurator"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   String   raIdentifier    =    ConnectorServices . getRegisteredResourceAdapterIdentifier ( resourceAdapterName )  ;", "if    ( raIdentifier    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . unknownResourceAdapter ( resourceAdapterName )  ;", "}", "final   ResourceAdapterRepository   resourceAdapterRepository    =    getResourceAdapterRepository (  )  ;", "if    ( resourceAdapterRepository    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . resourceAdapterRepositoryUnAvailable (  )  ;", "}", "final   List < MessageListener >    messageListeners    =    resourceAdapterRepository . getMessageListeners ( raIdentifier )  ;", "if    (  ( messageListeners    =  =    null )     |  |     ( messageListeners . isEmpty (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . unknownMessageListenerType ( messageListenerInterface . getName (  )  ,    resourceAdapterName )  ;", "}", "MessageListener   requiredMessageListener    =    null ;", "for    ( final   MessageListener   messageListener    :    messageListeners )     {", "if    ( messageListenerInterface . equals ( messageListener . getType (  )  )  )     {", "requiredMessageListener    =    messageListener ;", "break ;", "}", "}", "if    ( requiredMessageListener    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . unknownMessageListenerType ( messageListenerInterface . getName (  )  ,    resourceAdapterName )  ;", "}", "final   Activation   activation    =    requiredMessageListener . getActivation (  )  ;", "final   Proper   validActivationConfigProps    =    this . filterUnknownActivationConfigProper ( resourceAdapterName ,    activation ,    activationConfigProper )  ;", "final   ActivationSpec   activationSpec    =    activation . createInstance (  )  ;", "BeanUtils . mapJavaBeanProper ( activationSpec ,    validActivationConfigProps )  ;", "return   activationSpec ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( ResourceException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( InstantiationException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( NotFoundException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( IntrospectionException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createActivationSpecs"], "fileName": "org.jboss.as.ejb3.component.EJBUtilities"}, {"methodBody": ["METHOD_START", "{", "if    ( activationConfigProps    =  =    null )     {", "return   null ;", "}", "final   Map < String ,    Class <  ?  >  >    raActivationConfigProps    =    activation . getConfigProper (  )  ;", "final   Set < String >    raRequiredConfigProps    =    activation . getRequiredConfigProper (  )  ;", "final   Enumeration <  ?  >    propNames    =    activationConfigProps . propertyNames (  )  ;", "final   Proper   validActivationConfigProps    =    new   Proper (  )  ;", "validActivationConfigProps . putAll ( activationConfigProps )  ;", "while    ( propNames . hasMoreElements (  )  )     {", "final   Object   propName    =    propNames . nextElement (  )  ;", "if    (  (  ( raActivationConfigProps . containsKey ( propName )  )     =  =    false )     &  &     (  ( raRequiredConfigProps . contains ( propName )  )     =  =    false )  )     {", "validActivationConfigProps . remove ( propName )  ;", "EjbLogger . ROOT _ LOGGER . activationConfigPropertyIgnored ( propName ,    resourceAdapterName )  ;", "}", "}", "return   validActivationConfigProps ;", "}", "METHOD_END"], "methodName": ["filterUnknownActivationConfigProperties"], "fileName": "org.jboss.as.ejb3.component.EJBUtilities"}, {"methodBody": ["METHOD_START", "{", "final   String   raIdentifier    =    ConnectorServices . getRegisteredResourceAdapterIdentifier ( resourceAdapterName )  ;", "if    ( raIdentifier    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . unknownResourceAdapter ( resourceAdapterName )  ;", "}", "final   ResourceAdapterRepository   resourceAdapterRepository    =    getResourceAdapterRepository (  )  ;", "if    ( resourceAdapterRepository    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . resourceAdapterRepositoryUnAvailable (  )  ;", "}", "try    {", "return   resourceAdapterRepository . getEndpoint ( raIdentifier )  ;", "}    catch    ( NotFoundException   nfe )     {", "throw   EjbLogger . ROOT _ LOGGER . noSuchEndpointException ( resourceAdapterName ,    nfe )  ;", "}", "}", "METHOD_END"], "methodName": ["getEndpoint"], "fileName": "org.jboss.as.ejb3.component.EJBUtilities"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdapterRepositoryValue . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterRepository"], "fileName": "org.jboss.as.ejb3.component.EJBUtilities"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdapterRepositoryValue ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterRepositoryInjector"], "fileName": "org.jboss.as.ejb3.component.EJBUtilities"}, {"methodBody": ["METHOD_START", "{", "return   statisticsEnabled ;", "}", "METHOD_END"], "methodName": ["isStatisticsEnabled"], "fileName": "org.jboss.as.ejb3.component.EJBUtilities"}, {"methodBody": ["METHOD_START", "{", "this . statisticsEnabled    =    b ;", "}", "METHOD_END"], "methodName": ["setStatisticsEnabled"], "fileName": "org.jboss.as.ejb3.component.EJBUtilities"}, {"methodBody": ["METHOD_START", "{", "return   methodIntf ;", "}", "METHOD_END"], "methodName": ["getMethodIntf"], "fileName": "org.jboss.as.ejb3.component.EJBViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   methodIntf ;", "}", "METHOD_END"], "methodName": ["getMethodIntf"], "fileName": "org.jboss.as.ejb3.component.EJBViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   hasJNDIBindings ;", "}", "METHOD_END"], "methodName": ["hasJNDIBindings"], "fileName": "org.jboss.as.ejb3.component.EJBViewDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( methodIntf    =  =     ( MethodIntf . MESSAGE _ ENDPOINT )  )     {", "return   false ;", "}", "if    ( methodIntf    =  =     ( MethodIntf . SERVICE _ ENDPOINT )  )     {", "return   false ;", "}", "if    ( methodIntf    =  =     ( MethodIntf . TIMER )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["initHasJNDIBindings"], "fileName": "org.jboss.as.ejb3.component.EJBViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   ejb 2 xView ;", "}", "METHOD_END"], "methodName": ["isEjb2xView"], "fileName": "org.jboss.as.ejb3.component.EJBViewDescription"}, {"methodBody": ["METHOD_START", "{", "this . discarded    =    true ;", "}", "METHOD_END"], "methodName": ["discard"], "fileName": "org.jboss.as.ejb3.component.EjbComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   discarded ;", "}", "METHOD_END"], "methodName": ["isDiscarded"], "fileName": "org.jboss.as.ejb3.component.EjbComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   new   ImmediateInterceptorFactory ( new   InvokeMethodOnTargetInterceptor ( method )  )  ;", "}", "METHOD_END"], "methodName": ["factory"], "fileName": "org.jboss.as.ejb3.component.InvokeMethodOnTargetInterceptor"}, {"methodBody": ["METHOD_START", "{", "MethodIntf   methodIntf    =    invocation . getPrivateData ( MethodIntf . class )  ;", "if    ( methodIntf    =  =    null )     {", "final   ComponentView   componentView    =    invocation . getPrivateData ( ComponentView . class )  ;", "if    ( componentView    !  =    null )     {", "methodIntf    =    componentView . getPrivateData ( MethodIntf . class )  ;", "} else    {", "methodIntf    =    MethodIntf . BEAN ;", "}", "}", "return   methodIntf ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.jboss.as.ejb3.component.MethodIntfHelper"}, {"methodBody": ["METHOD_START", "{", "return   methodIdentifier ;", "}", "METHOD_END"], "methodName": ["getMethodIdentifier"], "fileName": "org.jboss.as.ejb3.component.MethodTransactionAttributeKey"}, {"methodBody": ["METHOD_START", "{", "return   methodIntf ;", "}", "METHOD_END"], "methodName": ["getMethodIntf"], "fileName": "org.jboss.as.ejb3.component.MethodTransactionAttributeKey"}, {"methodBody": ["METHOD_START", "{", "final   Collection < Timer >    activeTimers    =    new   HashSet <  >  (  )  ;", "synchronized ( timerServices )     {", "for    ( final      timerService    :    timerServices )     {", "activeTimers . addAll ( timerService . getTimers (  )  )  ;", "}", "}", "return   activeTimers ;", "}", "METHOD_END"], "methodName": ["getAllActiveTimers"], "fileName": "org.jboss.as.ejb3.component.TimerServiceRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( timerService    =  =    null )     {", "return ;", "}", "timerServices . add ( timerService )  ;", "}", "METHOD_END"], "methodName": ["registerTimerService"], "fileName": "org.jboss.as.ejb3.component.TimerServiceRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( timerService    =  =    null )     {", "return   false ;", "}", "return   timerServices . remove ( timerService )  ;", "}", "METHOD_END"], "methodName": ["unRegisterTimerService"], "fileName": "org.jboss.as.ejb3.component.TimerServiceRegistry"}, {"methodBody": ["METHOD_START", "{", "otherDenied . add ( new   DeniedMethodKey ( setEntityContext ,    timerServiceMethod )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.AllowedMethodsInformation"}, {"methodBody": ["METHOD_START", "{", "otherDenied . add ( new   AllowedMethodsInformation . DeniedSyncMethodKey ( callbackType ,    timerServiceMethod )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.AllowedMethodsInformation"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   context    =    CurrentInvocationContext . get (  )  ;", "if    ( context    =  =    null )     {", "return ;", "}", "final   Component   component    =    context . getPrivateData ( Component . class )  ;", "if    (  !  ( component   instanceof   EJBComponent )  )     {", "return ;", "}", "final   InvocationType   invocationType    =    context . getPrivateData ( InvocationType . class )  ;", "(  ( EJBComponent )     ( component )  )  . get (  )  . realCheckPermission ( methodType ,    invocationType )  ;", "}", "METHOD_END"], "methodName": ["checkAllowed"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.AllowedMethodsInformation"}, {"methodBody": ["METHOD_START", "{", "final   CurrentSynchronizationCallback . CallbackType   currentSync    =    CurrentSynchronizationCallback . get (  )  ;", "if    ( currentSync    !  =    null )     {", "if    ( deniedSyncMethods . contains ( new    . DeniedSyncMethodKey ( currentSync ,    methodType )  )  )     {", "throwException ( methodType ,    currentSync )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkTransactionSync"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.AllowedMethodsInformation"}, {"methodBody": ["METHOD_START", "{", "checkTransactionSync ( methodType )  ;", "if    ( invocationType    !  =    null )     {", "if    ( denied . contains ( new   DeniKey ( invocationType ,    methodType )  )  )     {", "throwException ( methodType ,    invocationType )  ;", "}", "}", "if    (  (  ( invocationType    !  =     ( InvocationType . CONCURRENT _ CONTEXT )  )     &  &     (  !  ( beanManagedTransaction )  )  )     &  &     ( methodType    =  =     ( MethodType . GET _ USER _ TRANSACTION )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . unauthorizedAccessToUserTransaction (  )  ;", "}", "}", "METHOD_END"], "methodName": ["realCheckPermission"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.AllowedMethodsInformation"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . cannotCallMethod ( methodType . getLabel (  )  ,    invocationType . getLabel (  )  )  ;", "}", "METHOD_END"], "methodName": ["throwException"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.AllowedMethodsInformation"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . cannotCallMethod ( methodType . getLabel (  )  ,    callback . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["throwException"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.AllowedMethodsInformation"}, {"methodBody": ["METHOD_START", "{", "return   invocationType ;", "}", "METHOD_END"], "methodName": ["getInvocationType"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.DeniedMethodKey"}, {"methodBody": ["METHOD_START", "{", "return   methodType ;", "}", "METHOD_END"], "methodName": ["getMethodType"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.DeniedMethodKey"}, {"methodBody": ["METHOD_START", "{", "return   label ;", "}", "METHOD_END"], "methodName": ["getLabel"], "fileName": "org.jboss.as.ejb3.component.allowedmethods.MethodType"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    context . getPrivateData ( Component . class )  ;", "if    ( component    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . componentNotSetIn ( context )  ;", "}", "return   componentType . cast ( component )  ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.jboss.as.ejb3.component.interceptors.AbstractEJBInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   AdditionalSetupInterceptor   interceptor    =    new   AdditionalSetupInterceptor ( actions )  ;", "return   new   ImmediateInterceptorFactory ( interceptor )  ;", "}", "METHOD_END"], "methodName": ["factory"], "fileName": "org.jboss.as.ejb3.component.interceptors.AdditionalSetupInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < Void >  (  )     {", "@ Override", "public   Void   run (  )     {", "RemotingCoxt . clear (  )  ;", "return   null ;", "}", "}  )  ;", "} else    {", "RemotingCoxt . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["clearConnection"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncFutureInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "AccessController . doPrivileged ( new   PrivilegedAction < Void >  (  )     {", "@ Override", "public   Void   run (  )     {", "SecurityCoxtAssociation . clearSecurityCoxt (  )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["clearSecurityContextOnAssociation"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncFutureInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   oldClassLoader    =    WildFlySecurityManager . setCurrentContextClassLoaderPrivileged (  (  ( ClassLoader )     ( null )  )  )  ;", "try    {", "getAsynchronousExecutor (  )  . execute ( task )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldClassLoader )  ;", "}", "return   task ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncFutureInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   WildFlySecurityManager . doUnchecked (  (  ( PrivilegedAction < RemoteConnection >  )     (  (  )     -  >    RemotingCoxt . getRemoteConnection (  )  )  )  )  ;", "} else    {", "return   RemotingCoxt . getRemoteConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncFutureInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < Void >  (  )     {", "@ Override", "public   Void   run (  )     {", "RemotingCoxt . setConnection ( remoteConnection )  ;", "return   null ;", "}", "}  )  ;", "} else    {", "RemotingCoxt . setConnection ( remoteConnection )  ;", "}", "}", "METHOD_END"], "methodName": ["setConnection"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncFutureInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "AccessController . doPrivileged ( new   PrivilegedAction < Void >  (  )     {", "@ Override", "public   Void   run (  )     {", "SecurityCoxtAssociation . setSecurityCoxt ( sc )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setSecurityContextOnAssociation"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncFutureInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "notifyAll (  )  ;", "}", "METHOD_END"], "methodName": ["done"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncInvocationTask"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  !  ( cancelledFlag . runIfNotCancelled (  )  )  )     {", "status    =     . ST _ CANCELLED ;", "done (  )  ;", "return ;", "}", "}", "Object   result ;", "try    {", "result    =    runInvocation (  )  ;", "}    catch    ( Exception   e )     {", "setFailed ( e )  ;", "return ;", "}", "Future <  ?  >    asyncResult    =     (  ( Future <  ?  >  )     ( result )  )  ;", "try    {", "if    ( asyncResult    !  =    null )     {", "result    =    asyncResult . get (  )  ;", "}", "}    catch    ( InterruptedException   e )     {", "setFailed ( new   IllegalStateException ( e )  )  ;", "return ;", "}    catch    ( ExecutionException   e )     {", "try    {", "throw   e . getCause (  )  ;", "}    catch    ( Exception   ex )     {", "setFailed ( ex )  ;", "return ;", "}    catch    ( Throwable   throwable )     {", "setFailed ( new   UndeclaredThrowableException ( throwable )  )  ;", "return ;", "}", "}", "setResult ( result )  ;", "return ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncInvocationTask"}, {"methodBody": ["METHOD_START", "{", "this . failed    =    e ;", "status    =     . ST _ FAILED ;", "done (  )  ;", "}", "METHOD_END"], "methodName": ["setFailed"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncInvocationTask"}, {"methodBody": ["METHOD_START", "{", "this . result    =    result ;", "status    =     . ST _ DONE ;", "done (  )  ;", "}", "METHOD_END"], "methodName": ["setResult"], "fileName": "org.jboss.as.ejb3.component.interceptors.AsyncInvocationTask"}, {"methodBody": ["METHOD_START", "{", "final   AtomicInteger   stateRef    =    this . stateRef ;", "int   oldVal ;", "int   newVal ;", "do    {", "oldVal    =    stateRef . get (  )  ;", "if    ( oldVal    =  =     (  . ST _ WAITING )  )     {", "newVal    =     . ST _ CANCELLED ;", "} else", "if    ( oldVal    =  =     (  . ST _ CANCELLED )  )     {", "if    (  ! setFlag )     {", "return   true ;", "}", "newVal    =     . ST _ CANCELLED _ FLAG _ SET ;", "} else", "if    ( oldVal    =  =     (  . ST _ CANCELLED _ FLAG _ SET )  )     {", "return   true ;", "} else", "if    ( oldVal    =  =     (  . ST _ STARTED )  )     {", "if    (  ! setFlag )     {", "return   false ;", "}", "newVal    =     . ST _ STARTED _ FLAG _ SET ;", "} else    {", "assert   oldVal    =  =     (  . ST _ STARTED _ FLAG _ SET )  ;", "return   false ;", "}", "}    while    (  !  ( stateRef . compareAndSet ( oldVal ,    newVal )  )     )  ;", "return    ( newVal    =  =     (  . ST _ CANCELLED )  )     |  |     ( newVal    =  =     (  . ST _ CANCELLED _ FLAG _ SET )  )  ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.jboss.as.ejb3.component.interceptors.CancellationFlag"}, {"methodBody": ["METHOD_START", "{", "final   int   state    =    stateRef . get (  )  ;", "return    ( state    =  =     (  . ST _ STARTED _ FLAG _ SET )  )     |  |     ( state    =  =     (  . ST _ CANCELLED _ FLAG _ SET )  )  ;", "}", "METHOD_END"], "methodName": ["isCancelFlagSet"], "fileName": "org.jboss.as.ejb3.component.interceptors.CancellationFlag"}, {"methodBody": ["METHOD_START", "{", "final   int   state    =    stateRef . get (  )  ;", "return    ( state    =  =     (  . ST _ CANCELLED )  )     |  |     ( state    =  =     (  . ST _ CANCELLED _ FLAG _ SET )  )  ;", "}", "METHOD_END"], "methodName": ["isCancelled"], "fileName": "org.jboss.as.ejb3.component.interceptors.CancellationFlag"}, {"methodBody": ["METHOD_START", "{", "final   AtomicInteger   stateRef    =    this . stateRef ;", "int   oldVal ;", "do    {", "oldVal    =    stateRef . get (  )  ;", "if    (  ( oldVal    =  =     (  . ST _ CANCELLED )  )     |  |     ( oldVal    =  =     (  . ST _ CANCELLED _ FLAG _ SET )  )  )     {", "return   false ;", "} else", "if    ( oldVal    !  =     (  . ST _ WAITING )  )     {", "throw   unreachableCode (  )  ;", "}", "}    while    (  !  ( stateRef . compareAndSet ( oldVal ,     . ST _ STARTED )  )     )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["runIfNotCancelled"], "fileName": "org.jboss.as.ejb3.component.interceptors.CancellationFlag"}, {"methodBody": ["METHOD_START", "{", "Throwable   cause    =    originalThrowable . getCause (  )  ;", "if    ( cause    !  =    null )", "try    {", "newThrowable . initCause ( cause )  ;", "}    catch    ( IllegalState   ignored )     {", "}", "return   newThrowable ;", "}", "METHOD_END"], "methodName": ["copyCause"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbExceptionTransformingInterceptorFactories"}, {"methodBody": ["METHOD_START", "{", "newThrowable . setStackTrace ( originalThrowable . getStackTrace (  )  )  ;", "return   newThrowable ;", "}", "METHOD_END"], "methodName": ["copyStackTrace"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbExceptionTransformingInterceptorFactories"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . CREATE _ EXCEPTION . get (  )  ;", "}    finally    {", ". CREATE _ EXCEPTION . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["popCreateException"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbExceptionTransformingInterceptorFactories"}, {"methodBody": ["METHOD_START", "{", "EjbExceptionTransformingInterceptorFactories . CREATE _ EXCEPTION . set ( exception )  ;", "}", "METHOD_END"], "methodName": ["setCreateException"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbExceptionTransformingInterceptorFactories"}, {"methodBody": ["METHOD_START", "{", "return   new   EntityEJBMetaData ( remoteClass ,    EJBClient . getLocatorFor ( home )  .  < H > narrowAsHome ( homeClass )  ,    pkClass )  ;", "}", "METHOD_END"], "methodName": ["createEntityMetaData"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbMetadataInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   StatefulEJBMetaData ( remoteClass ,    EJBClient . getLocatorFor ( home )  .  < H > narrowAsHome ( homeClass )  )  ;", "}", "METHOD_END"], "methodName": ["createStatefulMetaData"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbMetadataInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   StatelessEJBMetaData ( remoteClass ,    EJBClient . getLocatorFor ( home )  .  < H > narrowAsHome ( homeClass )  )  ;", "}", "METHOD_END"], "methodName": ["createStatelessMetaData"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbMetadataInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   homeView ;", "}", "METHOD_END"], "methodName": ["getHomeView"], "fileName": "org.jboss.as.ejb3.component.interceptors.EjbMetadataInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   viewToCreate ;", "}", "METHOD_END"], "methodName": ["getViewToCreate"], "fileName": "org.jboss.as.ejb3.component.interceptors.GetHomeInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "return   LogDiagnosticContextRecoveryInterceptor . FACTORY ;", "}", "METHOD_END"], "methodName": ["getFactory"], "fileName": "org.jboss.as.ejb3.component.interceptors.LogDiagnosticContextRecoveryInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   LogDiagnosticContextRecoveryInterceptor . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.jboss.as.ejb3.component.interceptors.LogDiagnosticContextRecoveryInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    Object >    mdc    =    MDC . getMap (  )  ;", "if    ( mdc    !  =    null )     {", "for    ( String   str    :    mdc . keySet (  )  )     {", "MDC . remove ( str )  ;", "}", "}", "final   Stored   data    =     (  ( Stored )     ( context . getPrivateData ( Stored . KEY )  )  )  ;", "context . putPrivateData ( Stored . KEY ,    null )  ;", "if    (  ( data    !  =    null )     &  &     (  ( data . getMdc (  )  )     !  =    null )  )     {", "for    ( Map . Entry < String ,    Object >    entry    :    data . getMdc (  )  . entrySet (  )  )     {", "MDC . put ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "final   int   depth    =    NDC . getDepth (  )  ;", "NDC . push ( data . getNdc (  )  )  ;", "try    {", "return   context . proceed (  )  ;", "}    finally    {", "NDC . setMaxDepth ( depth )  ;", "for    ( String   str    :    MDC . getMap (  )  . keySet (  )  )     {", "MDC . remove ( str )  ;", "}", "}", "}", "return   context . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.component.interceptors.LogDiagnosticContextRecoveryInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   LogDiagnosticContextStorageInterceptor . FACTORY ;", "}", "METHOD_END"], "methodName": ["getFactory"], "fileName": "org.jboss.as.ejb3.component.interceptors.LogDiagnosticContextStorageInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   LogDiagnosticContextStorageInterceptor . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.jboss.as.ejb3.component.interceptors.LogDiagnosticContextStorageInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    Object >    mdc    =    MDC . getMap (  )  ;", "if    ( mdc    !  =    null )     {", "context . putPrivateData ( Stored . KEY ,    new   Stored ( mdc ,    NDC . get (  )  )  )  ;", "try    {", "return   context . proceed (  )  ;", "}    finally    {", "context . putPrivateData ( Stored . KEY ,    null )  ;", "}", "} else    {", "return   context . proceed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.component.interceptors.LogDiagnosticContextStorageInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   viewToCreate ;", "}", "METHOD_END"], "methodName": ["getViewToCreate"], "fileName": "org.jboss.as.ejb3.component.interceptors.SessionBeanHomeInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "int   value ;", "int   oldValue ;", "do    {", "oldValue    =    invocationCount ;", "value    =     (  . SHUTDOWN _ FLAG )     |    oldValue ;", "if    ( oldValue    =  =    value )     {", "return ;", "}", "}    while    (  !  (  . updater . compareAndSet ( this ,    oldValue ,    value )  )     )  ;", "synchronized ( lock )     {", "value    =    invocationCount ;", "while    ( value    !  =     (  . SHUTDOWN _ FLAG )  )     {", "try    {", "lock . wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "value    =    invocationCount ;", "if    (  ( value    &     (  . SHUTDOWN _ FLAG )  )     =  =     0  )     {", "return ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "int   value ;", "int   oldValue ;", "do    {", "oldValue    =    invocationCount ;", "value    =     (  . INVERSE _ SHUTDOWN _ FLAG )     &    oldValue ;", "if    ( oldValue    =  =    value )     {", "return ;", "}", "}    while    (  !  (  . updater . compareAndSet ( this ,    oldValue ,    value )  )     )  ;", "synchronized ( lock )     {", "lock . notifyAll (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.component.interceptors.ShutDownInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "return   mdc ;", "}", "METHOD_END"], "methodName": ["getMdc"], "fileName": "org.jboss.as.ejb3.component.interceptors.StoredLogDiagnosticContext"}, {"methodBody": ["METHOD_START", "{", "return   ndc ;", "}", "METHOD_END"], "methodName": ["getNdc"], "fileName": "org.jboss.as.ejb3.component.interceptors.StoredLogDiagnosticContext"}, {"methodBody": ["METHOD_START", "{", "concurrent . decrementAndGet (  )  ;", "for    (  ;     ;  )     {", "final    . Values   oldv    =    values . get (  )  ;", "final    . Values   newv    =    new    . Values (  (  ( oldv . invocations )     +     1  )  ,     (  ( oldv . waitTime )     +    invocationWaitTime )  ,     (  ( oldv . executionTime )     +    invocationExecutionTime )  )  ;", "if    ( values . compareAndSet ( oldv ,    newv )  )", "break ;", "}", "final   AtomicReference <  . Values >    methodValues    =     . ref ( methods ,    method . getName (  )  )  ;", "for    (  ;     ;  )     {", "final    . Values   oldv    =    methodValues . get (  )  ;", "final    . Values   newv    =    new    . Values (  (  ( oldv . invocations )     +     1  )  ,     (  ( oldv . waitTime )     +    invocationWaitTime )  ,     (  ( oldv . executionTime )     +    invocationExecutionTime )  )  ;", "if    ( methodValues . compareAndSet ( oldv ,    newv )  )", "break ;", "}", "}", "METHOD_END"], "methodName": ["finishInvocation"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "return   concurrent . get (  )  ;", "}", "METHOD_END"], "methodName": ["getConcurrent"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "return   values . get (  )  . executionTime ;", "}", "METHOD_END"], "methodName": ["getExecutionTime"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "return   values . get (  )  . invocations ;", "}", "METHOD_END"], "methodName": ["getInvocations"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractMap < String ,    InvocationMetrics . Values >  (  )     {", "@ Override", "public   Set < Map . Entry < String ,    InvocationMetrics . Values >  >    entrySet (  )     {", "return   new   AbstractSet < Map . Entry < String ,    InvocationMetrics . Values >  >  (  )     {", "@ Override", "public   Iterator < Map . Entry < String ,    InvocationMetrics . Values >  >    iterator (  )     {", "final   Iterator < Map . Entry < String ,    AtomicReference < InvocationMetrics . Values >  >  >    delegate    =    methods . entrySet (  )  . iterator (  )  ;", "return   new   Iterator < Map . Entry < String ,    InvocationMetrics . Values >  >  (  )     {", "@ Override", "public   boolean   hasNext (  )     {", "return   delegate . hasNext (  )  ;", "}", "@ Override", "public   Map . Entry < String ,    InvocationMetrics . Values >    next (  )     {", "final   Map . Entry < String ,    AtomicReference < InvocationMetrics . Values >  >    next    =    delegate . next (  )  ;", "return   new   Map . Entry < String ,    InvocationMetrics . Values >  (  )     {", "@ Override", "public   String   getKey (  )     {", "return   next . getKey (  )  ;", "}", "@ Override", "public   InvocationMetrics . Values   getValue (  )     {", "return   next . getValue (  )  . get (  )  ;", "}", "@ Override", "public   InvocationMetrics . Values   setValue ( final   InvocationMetrics . Values   value )     {", "throw   new   UnsupportedOperationException (  \" NYI \"  )  ;", "}", "}  ;", "}", "@ Override", "public   void   remove (  )     {", "throw   new   UnsupportedOperationException (  \" NYI \"  )  ;", "}", "}  ;", "}", "@ Override", "public   int   size (  )     {", "return   methods . size (  )  ;", "}", "}  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "return   peakConcurrent . get (  )  ;", "}", "METHOD_END"], "methodName": ["getPeakConcurrent"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "return   values . get (  )  . waitTime ;", "}", "METHOD_END"], "methodName": ["getWaitTime"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "AtomicReference < InvocationMetrics . Values >    ref    =    map . get ( key )  ;", "if    ( ref    =  =    null )     {", "ref    =    new   AtomicReference < InvocationMetrics . Values >  ( new   InvocationMetrics . Values (  0  ,     0  ,     0  )  )  ;", "final   AtomicReference < InvocationMetrics . Values >    prevRef    =    map . putIfAbsent ( key ,    ref )  ;", "if    ( prevRef    !  =    null )", "ref    =    prevRef ;", "}", "return   ref ;", "}", "METHOD_END"], "methodName": ["ref"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "final   long   v    =    concurrent . incrementAndGet (  )  ;", "if    (  ( peakConcurrent . get (  )  )     <    v )", "peakConcurrent . incrementAndGet (  )  ;", "}", "METHOD_END"], "methodName": ["startInvocation"], "fileName": "org.jboss.as.ejb3.component.invocationmetrics.InvocationMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultResourceAdapterName ;", "}", "METHOD_END"], "methodName": ["getDefaultResourceAdapterName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.DefaultResourceAdapterService"}, {"methodBody": ["METHOD_START", "{", "this . defaultResourceAdapterName    =    resourceAdapterName ;", "}", "METHOD_END"], "methodName": ["setResourceAdapterName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.DefaultResourceAdapterService"}, {"methodBody": ["METHOD_START", "{", "return   mdbComponent ;", "}", "METHOD_END"], "methodName": ["getMdbComponent"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MdbDeliveryControllerService"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MdbDeliveryControllerService"}, {"methodBody": ["METHOD_START", "{", "mdbComponent . getValue (  )  . startDelivery (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MdbDeliveryControllerService"}, {"methodBody": ["METHOD_START", "{", "mdbComponent . getValue (  )  . stopDelivery (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MdbDeliveryControllerService"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   oldTccl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( classLoader )  ;", "this . endpoint . activate ( endpointFactory ,    activationSpec )  ;", "}    catch    ( Exception   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToActivateMdb ( getName (  )  ,    e )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "}", "}", "METHOD_END"], "methodName": ["activate"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   oldTccl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( classLoader )  ;", "endpoint . deactivate ( endpointFactory ,    activationSpec )  ;", "}    catch    ( ResourceException   re )     {", "throw   EjbLogger . ROOT _ LOGGER . failureDuringEndpointDeactivation ( this . getName (  )  ,    re )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "}", "}", "METHOD_END"], "methodName": ["deactivate"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "return   deliveryControllerName ;", "}", "METHOD_END"], "methodName": ["getDeliveryControllerName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "return   deliveryActive ;", "}", "METHOD_END"], "methodName": ["isDeliveryActive"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "return    ( deliveryControllerName )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isDeliveryControlled"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "this . endpoint    =    endpoint ;", "}", "METHOD_END"], "methodName": ["setEndpoint"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  !  ( this . deliveryActive )  )     {", "this . deliveryActive    =    true ;", "if    ( this . started )     {", "this . activate (  )  ;", "EjbLogger . ROOT _ LOGGER . mdbDeliveryStarted ( getApplicationName (  )  ,    getName (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["startDelivery"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    ( this . deliveryActive )     {", "if    ( this . started )     {", "this . deactivate (  )  ;", "EjbLogger . ROOT _ LOGGER . mdbDeliveryStopped ( getApplicationName (  )  ,    getName (  )  )  ;", "}", "this . deliveryActive    =    false ;", "}", "}", "}", "METHOD_END"], "methodName": ["stopDelivery"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponent"}, {"methodBody": ["METHOD_START", "{", "return   getComponentClass (  )  . getClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getDeploymentClassLoader"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . ejbUtilitiesInjectedValue ;", "}", "METHOD_END"], "methodName": ["getEJBUtilitiesInjector"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   getEJBUtilities (  )  ;", "}", "METHOD_END"], "methodName": ["getEndpointDeployer"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   moduleClassLoader ;", "}", "METHOD_END"], "methodName": ["getModuleClassLoader"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . poolConfig . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getPoolConfig"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . poolConfig ;", "}", "METHOD_END"], "methodName": ["getPoolConfigInjector"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceAdapterInjectedValue ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterInjector"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   suspendControllerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getSuspendControllerInjectedValue"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "String   result    =    configuredResourceAdapterName ;", "if    (  ( Connectors . getRegisteredResourceAdapterIdentifier ( configuredResourceAdapterName )  )     =  =    null )     {", "String   amended    =    stripDotRarSuffix ( configuredResourceAdapterName )  ;", "if    ( configuredResourceAdapterName . equals ( amended )  )     {", "amended    =    configuredResourceAdapterName    +     \"  . rar \"  ;", "}", "if    (  ( Connectors . getRegisteredResourceAdapterIdentifier ( amended )  )     !  =    null )     {", "result    =    amended ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["searchActiveResourceAdapterName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "if    ( raName    =  =    null )     {", "return   null ;", "}", "if    ( raName . endsWith (  \"  . rar \"  )  )     {", "return   raName . substring (  0  ,    raName . indexOf (  \"  . rar \"  )  )  ;", "}", "return   raName ;", "}", "METHOD_END"], "methodName": ["stripDotRarSuffix"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "this . getConfigurators (  )  . add ( new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,       description ,    ComponentConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "if    ( MessageDrivenBean . class . isAssignableFrom ( configuration . getComponentClass (  )  )  )     {", "configuration . addPostConstructInterceptor ( new   ImmediateInterceptorFactory ( MessageDrivenBeanSetMessageDrivenContextInterceptor . INSTANCE )  ,    EJB _ SET _ CONTEXT _ METHOD _ INVOCATION _ INTERCEPTOR )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addSetMessageDrivenContextMethodInvocationInterceptor"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   activationProps ;", "}", "METHOD_END"], "methodName": ["getActivationProps"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   getServiceName (  )  . append (  \" DELIVERY \"  )  ;", "}", "METHOD_END"], "methodName": ["getDeliveryControllerName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   deliveryGroup ;", "}", "METHOD_END"], "methodName": ["getDeliveryGroup"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   messageListenerInterfaceName ;", "}", "METHOD_END"], "methodName": ["getMessageListenerInterfaceName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . mdbPoolConfigName ;", "}", "METHOD_END"], "methodName": ["getPoolConfigName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdapterName ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   clusteredSingleton ;", "}", "METHOD_END"], "methodName": ["isClusteredSingleton"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   deliveryActive ;", "}", "METHOD_END"], "methodName": ["isDeliveryActive"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    (  ( deliveryGroup )     !  =    null )     |  |     ( clusteredSingleton )  ;", "}", "METHOD_END"], "methodName": ["isDeliveryControlled"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . clusteredSingleton    =    clusteredSingleton ;", "}", "METHOD_END"], "methodName": ["setClusteredSingleton"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . deliveryActive    =    deliveryActive ;", "}", "METHOD_END"], "methodName": ["setDeliveryActive"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . deliveryGroup    =    groupName ;", "}", "METHOD_END"], "methodName": ["setDeliveryGroup"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . mdbPoolConfigName    =    mdbPoolConfigName ;", "}", "METHOD_END"], "methodName": ["setPoolConfigName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resourceAdapterName    =  =    null )     |  |     ( resourceAdapterName . trim (  )  . isEmpty (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . stringParamCannotBeNullOrEmpty (  \" Resource   adapter   name \"  )  ;", "}", "this . resourceAdapterName    =    resourceAdapterName ;", "}", "METHOD_END"], "methodName": ["setResourceAdapterName"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   MessageDrivenComponentInstanceAssociatingFactory . INSTANCE ;", "}", "METHOD_END"], "methodName": ["instance"], "fileName": "org.jboss.as.ejb3.component.messagedriven.MessageDrivenComponentInstanceAssociatingFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . poolName ;", "}", "METHOD_END"], "methodName": ["getPoolName"], "fileName": "org.jboss.as.ejb3.component.pool.PoolConfig"}, {"methodBody": ["METHOD_START", "{", "return   maxPoolSize ;", "}", "METHOD_END"], "methodName": ["getMaxPoolSize"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfig"}, {"methodBody": ["METHOD_START", "{", "return   timeout ;", "}", "METHOD_END"], "methodName": ["getTimeout"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfig"}, {"methodBody": ["METHOD_START", "{", "return   timeoutUnit ;", "}", "METHOD_END"], "methodName": ["getTimeoutUnit"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfig"}, {"methodBody": ["METHOD_START", "{", "this . maxPoolSize    =    maxPoolSize ;", "}", "METHOD_END"], "methodName": ["setMaxPoolSize"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfig"}, {"methodBody": ["METHOD_START", "{", "this . timeout    =    timeout ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfig"}, {"methodBody": ["METHOD_START", "{", "this . timeoutUnit    =    timeoutUnit ;", "}", "METHOD_END"], "methodName": ["setTimeoutUnit"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfig"}, {"methodBody": ["METHOD_START", "{", "return    ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     4  ;", "}", "METHOD_END"], "methodName": ["calcMaxFromCPUCount"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "Integer   max    =    maxThreadsInjector . getOptionalValue (  )  ;", "return    ( max    !  =    null )     &  &     ( max    >     0  )     ?    max    :    calcFromCPUCount (  )  ;", "}", "METHOD_END"], "methodName": ["calcMaxFromWorkPools"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "return   poolConfig . getMaxPoolSize (  )  ;", "}", "METHOD_END"], "methodName": ["getDerivedSize"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "return   maxThreadsInjector ;", "}", "METHOD_END"], "methodName": ["getMaxThreadsInjector"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "this . derive    =    derive ;", "int   max    =    this . declaredMaxSize ;", "switch    ( derive )     {", "case   FROM _ WORKER _ POOLS    :", "{", "max    =    calcMaxFromWorkPools (  )  ;", "EjbLogger . ROOT _ LOGGER . strictPoolDerivedFromWorkers ( p . getPoolName (  )  ,    max )  ;", "break ;", "}", "case   FROM _ CPU _ COUNT    :", "{", "max    =    calcMaxFromCPUCount (  )  ;", "EjbLogger . ROOT _ LOGGER . strictPoolDerivedFromCPUs ( p . getPoolName (  )  ,    max )  ;", "break ;", "}", "}", "p . setMaxPoolSize ( max )  ;", "}", "METHOD_END"], "methodName": ["setDerive"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "this . declaredMaxSize    =    newMax ;", "if    (  ( derive )     =  =     (  . Derive . NONE )  )     {", "poolConfig . setMaxPoolSize ( newMax )  ;", "}", "}", "METHOD_END"], "methodName": ["setMaxPoolSize"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "poolConfig . setTimeout ( timeout )  ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "poolConfig . setTimeoutUnit ( timeUnit )  ;", "}", "METHOD_END"], "methodName": ["setTimeoutUnit"], "fileName": "org.jboss.as.ejb3.component.pool.StrictMaxPoolConfigService"}, {"methodBody": ["METHOD_START", "{", "return   asyncExecutor ;", "}", "METHOD_END"], "methodName": ["getAsynchronousExecutor"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( businessInterface    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . businessInterfaceIsNull (  )  ;", "}", "return   createViewInstanceProxy ( businessInterface ,    Collections . emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBusinessObject"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getEjbLocalObjectViewServiceName (  )  )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . bMissingEjbObject ( getComponentName (  )  ,     \" EJBLocalObject \"  )  ;", "}", "return   createViewInstanceProxy ( EJBLocalObject . class ,    Collections .  < Object ,    Object > emptyMap (  )  ,    getEjbLocalObjectViewServiceName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getEJBLocalObject"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getEjbObjectViewServiceName (  )  )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . bMissingEjbObject ( getComponentName (  )  ,     \" EJBObject \"  )  ;", "}", "return   createViewInstanceProxy ( EJBObject . class ,    Collections .  < Object ,    Object > emptyMap (  )  ,    getEjbObjectViewServiceName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getEJBObject"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponent"}, {"methodBody": ["METHOD_START", "{", "return   asyncExecutorService ;", "}", "METHOD_END"], "methodName": ["getAsyncExecutorService"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . beanLevelAccessTimeout ;", "}", "METHOD_END"], "methodName": ["getBeanAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . beanLevelLockType ;", "}", "METHOD_END"], "methodName": ["getBeanLockType"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   classLoader    =    this . getComponentClass (  )  . getClassLoader (  )  ;", "final   String   methodName    =    method . getName (  )  ;", "final   String [  ]    types    =    method . getParameterTypes (  )  ;", "if    (  ( types    =  =    null )     |  |     (  ( types . length )     =  =     0  )  )     {", "return   new   EJBBusinessMethod ( methodName )  ;", "}", "Class <  ?  >  [  ]    paramTypes    =    new   Class <  ?  >  [ types . length ]  ;", "int   i    =     0  ;", "for    ( String   type    :    types )     {", "try    {", "paramTypes [  ( i +  +  )  ]     =    PrimitiveClassLoaderUtil . loadClass ( type ,    classLoader )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "return   new   EJBBusinessMethod ( methodName ,    paramTypes )  ;", "}", "METHOD_END"], "methodName": ["getEJBBusinessMethod"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . methodApplicableAccessTimeouts ;", "}", "METHOD_END"], "methodName": ["getMethodApplicableAccessTimeouts"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . methodApplicableLockTypes ;", "}", "METHOD_END"], "methodName": ["getMethodApplicableLockTypes"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "asynchronousClasses . add ( viewName )  ;", "}", "METHOD_END"], "methodName": ["addAsynchronousClass"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "asynchronousMethods . add ( methodIdentifier )  ;", "}", "METHOD_END"], "methodName": ["addAsynchronousMethod"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "addLocalBusinessInterfaceViews ( Arrays . asList ( classNames )  )  ;", "}", "METHOD_END"], "methodName": ["addLocalBusinessInterfaceViews"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "for    ( final   String   viewClassName    :    classNames )     {", "assertNoRemoteView ( viewClassName )  ;", "registerView ( viewClassName ,    MethodIntf . LOCAL )  ;", "}", "}", "METHOD_END"], "methodName": ["addLocalBusinessInterfaceViews"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "noInterfaceViewPresent    =    true ;", "final   View   view    =    registerView ( getEJBClassName (  )  ,    MethodIntf . LOCAL )  ;", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   View   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "DeploymentReflectionIndex   index    =    context . getDeploymentUnit (  )  . getAttachment ( REFLECTION _ INDEX )  ;", "for    ( final   Method   method    :    configuration . getProxyFactory (  )  . getCachedMethods (  )  )     {", "if    (  (  !  ( Modifier . isPublic ( method . getModifiers (  )  )  )  )     &  &     ( isNotOverriden ( method ,    componentConfiguration . getComponentClass (  )  ,    index )  )  )     {", "configuration . addClientInterceptor ( method ,    new   ImmediateInterceptorFactory ( new   NotBusinessMethodInterceptor ( method )  )  ,    NOT _ BUSINESS _ METHOD _ EXCEPTION )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addNoInterfaceView"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "for    ( final   String   viewClassName    :    classNames )     {", "assertNoLocalView ( viewClassName )  ;", "registerView ( viewClassName ,    MethodIntf . REMOTE )  ;", "}", "}", "METHOD_END"], "methodName": ["addRemoteBusinessInterfaceViews"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentConfiguration   componentConfiguration ,    ViewDescription   description ,    ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "EJB   ejb    =     (  ( EJB )     ( componentConfiguration . get (  )  )  )  ;", "if    ( CONTAINER . equals ( ejb . getTransactionManagementType (  )  )  )     {", "configuration . addViewInterceptor ( CMTTxInterceptor . FACTORY ,    CMT _ TRANSACTION _ INTERCEPTOR )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addTxManagementInterceptorForView"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   registerView ( getEJBClassName (  )  ,    MethodIntf . SERVICE _ ENDPOINT )  ;", "}", "METHOD_END"], "methodName": ["addWebserviceEndpointView"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "EJBViewDescription   ejbView    =    null ;", "for    ( final   ViewDescription   view    :    getViews (  )  )     {", "ejbView    =     (  ( EJBViewDescription )     ( view )  )  ;", "if    (  ( viewClassName . equals ( ejbView . getViewClassName (  )  )  )     &  &     (  ( ejbView . getMethodIntf (  )  )     =  =     ( MethodIntf . LOCAL )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToAddClassToLocalView ( viewClassName ,    getEJBName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertNoLocalView"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "EJBViewDescription   ejbView    =    null ;", "for    ( final   ViewDescription   view    :    getViews (  )  )     {", "ejbView    =     (  ( EJBViewDescription )     ( view )  )  ;", "if    (  ( viewClassName . equals ( ejbView . getViewClassName (  )  )  )     &  &     (  ( ejbView . getMethodIntf (  )  )     =  =     ( MethodIntf . REMOTE )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToAddClassToLocalView ( viewClassName ,    getEJBName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertNoRemoteView"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   asynchronousClasses ;", "}", "METHOD_END"], "methodName": ["getAsynchronousClasses"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   asynchronousMethods ;", "}", "METHOD_END"], "methodName": ["getAsynchronousMethods"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . beanLevelAccessTimeout ;", "}", "METHOD_END"], "methodName": ["getBeanLevelAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . beanLevelLockType ;", "}", "METHOD_END"], "methodName": ["getBeanLevelLockType"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrencyManagementType ;", "}", "METHOD_END"], "methodName": ["getConcurrencyManagementType"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . mappedName ;", "}", "METHOD_END"], "methodName": ["getMappedName"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . methodAccessTimeouts ;", "}", "METHOD_END"], "methodName": ["getMethodApplicableAccessTimeouts"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . methodLockTypes ;", "}", "METHOD_END"], "methodName": ["getMethodApplicableLockTypes"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . noInterfaceViewPresent ;", "}", "METHOD_END"], "methodName": ["hasNoInterfaceView"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    ( Modifier . isPrivate ( method . getModifiers (  )  )  )     |  |     (  ( ClassReflectionIndexUtil . findRequiredMethod ( deploymentReflectionIndex ,    actualClass ,    method )  . getDeclaringClass (  )  )     =  =     ( method . getDeclaringClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isNotOverriden"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . methodAccessTimeouts . put ( method ,    accessTimeout )  ;", "}", "METHOD_END"], "methodName": ["setAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . beanLevelAccessTimeout . put ( className ,    accessTimeout )  ;", "}", "METHOD_END"], "methodName": ["setBeanLevelAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . beanLevelLockType . put ( className ,    locktype )  ;", "}", "METHOD_END"], "methodName": ["setBeanLevelLockType"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . concurrencyManagementType    =    concurrencyManagementType ;", "}", "METHOD_END"], "methodName": ["setConcurrencyManagementType"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . methodLockTypes . put ( method ,    lockType )  ;", "}", "METHOD_END"], "methodName": ["setLockType"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . mappedName    =    mappedName ;", "}", "METHOD_END"], "methodName": ["setMappedName"], "fileName": "org.jboss.as.ejb3.component.session.SessionBeanComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ejb3.component.session.StatelessSerializedProxy"}, {"methodBody": ["METHOD_START", "{", "ServiceController < ComponentView >    view    =     (  ( ServiceController < ComponentView >  )     ( StatelessSerializedProxy . currentServiceContainer (  )  . getRequiredService ( ServiceName . parse ( viewName )  )  )  )  ;", "try    {", "return   view . getValue (  )  . createInstance (  )  . getInstance (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.jboss.as.ejb3.component.session.StatelessSerializedProxy"}, {"methodBody": ["METHOD_START", "{", "return   new   ImmediateInterceptorFactory ( new   StatelessWriteReplaceInterceptor ( serviceName )  )  ;", "}", "METHOD_END"], "methodName": ["factory"], "fileName": "org.jboss.as.ejb3.component.session.StatelessWriteReplaceInterceptor"}, {"methodBody": ["METHOD_START", "{", "LockType   lockType    =    lockableComponent . getLockType ( method )  ;", "switch    ( lockType )     {", "case   READ    :", "return   lockableComponent . getLock (  )  . readLock (  )  ;", "case   WRITE    :", "return   lockableComponent . getLock (  )  . writeLock (  )  ;", "}", "throw   EjbLogger . ROOT _ LOGGER . failToObtainLockIllegalType ( lockType ,    method ,    lockableComponent )  ;", "}", "METHOD_END"], "methodName": ["getLock"], "fileName": "org.jboss.as.ejb3.component.singleton.ContainerManagedConcurrencyInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . lockableComponent ;", "}", "METHOD_END"], "methodName": ["getLockableComponent"], "fileName": "org.jboss.as.ejb3.component.singleton.ContainerManagedConcurrencyInterceptor"}, {"methodBody": ["METHOD_START", "{", "Integer   current    =    readLockCount . get (  )  ;", "if    ( current    !  =    null )     {", "assert    ( current . intValue (  )  )     >     0     :     \" readLockCount   is   set ,    but   to    0  \"  ;", "throw   EjbLogger . ROOT _ LOGGER . failToUpgradeTo (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkLoopback"], "fileName": "org.jboss.as.ejb3.component.singleton.EJBReadWriteLock"}, {"methodBody": ["METHOD_START", "{", "Integer   current    =    readLockCount . get (  )  ;", "int   next ;", "assert   current    !  =    null    :     \" can ' t   decrease ,    readLockCount   is   not   set \"  ;", "next    =     ( current . intValue (  )  )     -     1  ;", "if    ( next    =  =     0  )", "readLockCount . remove (  )  ;", "else", "readLockCount . set ( new   Integer ( next )  )  ;", "}", "METHOD_END"], "methodName": ["decReadLockCount"], "fileName": "org.jboss.as.ejb3.component.singleton.EJBReadWriteLock"}, {"methodBody": ["METHOD_START", "{", "Integer   current    =    readLockCount . get (  )  ;", "int   next ;", "if    ( current    =  =    null )", "next    =     1  ;", "else", "next    =     ( current . intValue (  )  )     +     1  ;", "readLockCount . set ( new   Integer ( next )  )  ;", "}", "METHOD_END"], "methodName": ["incReadLockCount"], "fileName": "org.jboss.as.ejb3.component.singleton.EJBReadWriteLock"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponent"}, {"methodBody": ["METHOD_START", "{", "synchronized ( creationLock )     {", "if    (  ( this . sInstance )     !  =    null )     {", "sInstance . destroy (  )  ;", "this . sInstance    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["destroySingletonInstance"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponent"}, {"methodBody": ["METHOD_START", "{", "final   EJBBusinessMethod   ejbMethod    =    new   EJBBusinessMethod ( method )  ;", "final   AccessTimeoutDetails   accessTimeout    =    this . methodAccessTimeouts . get ( ejbMethod )  ;", "if    ( accessTimeout    !  =    null )     {", "return   accessTimeout ;", "}", "final   AccessTimeoutDetails   beanTimeout    =    this . beanLevelAccessTimeout . get ( method . getDeclaringClass (  )  . getName (  )  )  ;", "if    ( beanTimeout    !  =    null )     {", "return   beanTimeout ;", "}", "return   getDefaultAccessTimeout (  )  ;", "}", "METHOD_END"], "methodName": ["getAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . singletonComponentInstance )     =  =    null )     {", "if    ( Thread . holdsLock ( creationLock )  )", "throw   logging . EjbLogger . ROOT _ LOGGER . reentrantSingletonCreation ( getComponentName (  )  ,    getComponentClass (  )  . getName (  )  )  ;", "synchronized ( creationLock )     {", "if    (  ( this . singletonComponentInstance )     =  =    null )     {", "this . singletonComponentInstance    =     (  ( SingletonComponentInstance )     ( this . createInstance (  )  )  )  ;", "}", "}", "}", "return   this . singletonComponentInstance ;", "}", "METHOD_END"], "methodName": ["getComponentInstance"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponent"}, {"methodBody": ["METHOD_START", "{", "return   defaultAccessTimeoutProvider . getDefaultAccessTimeout (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponent"}, {"methodBody": ["METHOD_START", "{", "return   readWriteLock ;", "}", "METHOD_END"], "methodName": ["getLock"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponent"}, {"methodBody": ["METHOD_START", "{", "final   EJBBusinessMethod   ejbMethod    =    new   EJBBusinessMethod ( method )  ;", "final   LockType   lockType    =    this . methodLockTypes . get ( ejbMethod )  ;", "if    ( lockType    !  =    null )     {", "return   lockType ;", "}", "final   LockType   type    =    this . beanLevelLockType . get ( method . getDeclaringClass (  )  . getName (  )  )  ;", "if    ( type    !  =    null )     {", "return   type ;", "}", "return   LockType . WRITE ;", "}", "METHOD_END"], "methodName": ["getLockType"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultAccessTimeoutService ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessTimeoutInjector"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   defaultAccessTimeoutService . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessTimeoutService"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . initOnStartup ;", "}", "METHOD_END"], "methodName": ["isInitOnStartup"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentConfiguration   componentConfiguration ,    ViewDescription   description ,    ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final      singletonComponentDescription    =     (  (  )     ( componentConfiguration . getComponentDescription (  )  )  )  ;", "if    (  ( singletonComponentDescription . getConcurrencyManagementType (  )  )     =  =     ( ConcurrencyManagementType . BEAN )  )     {", "return ;", "}", "configuration . addViewInterceptor ( new   ContainerManagedConcurrencyInterceptorFactory ( configuration . getViewToComponentMethodMap (  )  )  ,    SINGLETON _ CONTAINER _ MANAGED _ CONCURRENCY _ INTERCEPTOR )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addConcurrencyManagementInterceptor"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . setSerializable ( true )  ;", "view . setUseWriteReplace ( true )  ;", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   View   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final   DeploymentReflectionIndex   index    =    context . getDeploymentUnit (  )  . getAttachment ( REFLECTION _ INDEX )  ;", "ClassReflectionIndex   classIndex    =    index . getClassIndex ( WriteReplaceInterface . class )  ;", "for    ( Method   method    :    classIndex . getMethods (  )  )     {", "configuration . addClientInterceptor ( method ,    StatelessWriteReplaceInterceptor . factory ( configuration . getViewServiceName (  )  . getCanonicalName (  )  )  ,    WRITE _ REPLACE )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addViewSerializationInterceptor"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   dependsOn ;", "}", "METHOD_END"], "methodName": ["getDependsOn"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . initOnStartup    =    true ;", "}", "METHOD_END"], "methodName": ["initOnStartup"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . initOnStartup ;", "}", "METHOD_END"], "methodName": ["isInitOnStartup"], "fileName": "org.jboss.as.ejb3.component.singleton.SingletonComponentDescription"}, {"methodBody": ["METHOD_START", "{", "CurrentSynchronizationCallback . type . set ( null )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jboss.as.ejb3.component.stateful.CurrentSynchronizationCallback"}, {"methodBody": ["METHOD_START", "{", "return   CurrentSynchronizationCallback . type . get (  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.ejb3.component.stateful.CurrentSynchronizationCallback"}, {"methodBody": ["METHOD_START", "{", "CurrentSynchronizationCallback . type . set ( callback )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jboss.as.ejb3.component.stateful.CurrentSynchronizationCallback"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnitServiceName . append (  \" marshalling \"  )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ejb3.component.stateful.MarshallingConfigurationRepositoryValue"}, {"methodBody": ["METHOD_START", "{", "return   EJBClient . createProxy ( this . ejbLocator )  ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.jboss.as.ejb3.component.stateful.SerializableEJBProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ejb3.component.stateful.SerializedStatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "ServiceName   name    =    ServiceName . parse ( serviceName )  ;", "ServiceController <  ?  >    service    =     . currentServiceContainer (  )  . getRequiredService ( name )  ;", "StatefulSessionComponent   component    =     (  ( StatefulSessionComponent )     ( service . getValue (  )  )  )  ;", "final   Map < Object ,    Object >    context    =    new   HashMap < Object ,    Object >  (  )  ;", "for    ( final   Map . Entry < Object ,    Object >    entry    :    serializableInterceptors . entrySet (  )  )     {", "context . put ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "context . put ( SessionID . class ,    sessionID )  ;", "context . put ( INSTANCE _ KEY ,    instance )  ;", "return   component . constructComponentInstance ( instance ,    false ,    context )  ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.jboss.as.ejb3.component.stateful.SerializedStatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "initMethods . put ( method ,    createMethod )  ;", "}", "METHOD_END"], "methodName": ["addInitMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "getConfigurators (  )  . addFirst ( new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,       description ,    ComponentConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "configuration . addPostConstructInterceptor ( StatefulInitMethodInterceptor . INSTANCE ,    SFSB _ INIT _ METHOD )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addInitMethodInvokingInterceptor"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( removeMethod    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . removeMethodIsNull (  )  ;", "}", "this . removeMethods . put ( removeMethod ,    new    . StatefulRemoveMethod ( removeMethod ,    retainIfException )  )  ;", "}", "METHOD_END"], "methodName": ["addRemoveMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentConfiguration   componentConfiguration ,    ViewDescription   description ,    ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final      statefulComponentDescription    =     (  (  )     ( componentConfiguration . getComponentDescription (  )  )  )  ;", "final   Collection <  . StatefulRemoveMethod >    removeMethods    =    statefulComponentDescription . getRemoveMethods (  )  ;", "if    ( removeMethods . isEmpty (  )  )     {", "return ;", "}", "for    ( final   Method   viewMethod    :    configuration . getProxyFactory (  )  . getCachedMethods (  )  )     {", "final   MethodIdentifier   viewMethodIdentifier    =    MethodIdentifier . getIdentifierForMethod ( viewMethod )  ;", "for    ( final    . StatefulRemoveMethod   removeMethod    :    removeMethods )     {", "if    ( removeMethod . methodIdentifier . equals ( viewMethodIdentifier )  )     {", "final   boolean   object    =     ( EJBObject . class . isAssignableFrom ( configuration . getViewClass (  )  )  )     |  |     ( EJBLocalObject . class . isAssignableFrom ( configuration . getViewClass (  )  )  )  ;", "if    (  (  (  ! object )     |  |     (  !  ( viewMethodIdentifier . getName (  )  . equals (  \" remove \"  )  )  )  )     |  |     (  ( viewMethodIdentifier . getParameterTypes (  )  . length )     !  =     0  )  )     {", "configuration . addViewInterceptor ( viewMethod ,    new   ImmediateInterceptorFactory ( new   StatefulRemoveInterceptor ( removeMethod . retainIfException )  )  ,    SESSION _ REMOVE _ INTERCEPTOR )  ;", "}", "break ;", "}", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addRemoveMethodInterceptor"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    ViewDescription   description ,    ViewConfiguration   viewConfiguration )    throws   DeploymentUnitProcessingException    {", "EJBViewDescription   ejbViewDescription    =     (  ( EJBViewDescription )     ( view )  )  ;", "if    (  (  ( ejbViewDescription . getMethodIntf (  )  )     =  =     ( MethodIntf . HOME )  )     |  |     (  ( ejbViewDescription . getMethodIntf (  )  )     =  =     ( MethodIntf . LOCAL _ HOME )  )  )     {", "for    ( Method   method    :    viewConfiguration . getProxyFactory (  )  . getCachedMethods (  )  )     {", "if    (  (  ( method . getName (  )  . equals (  \" hashCode \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )  )     |  |     (  (  ( method . getName (  )  . equals (  \" equals \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     1  )  )     &  &     (  ( method . getParameterTypes (  )  [  0  ]  )     =  =     ( Object . class )  )  )  )     {", "viewConfiguration . addClientInterceptor ( method ,    ComponentTypeIdentityInterceptorFactory . INSTANCE ,    EJB _ EQUALS _ HASHCODE )  ;", "}", "}", "} else    {", "final   InterceptorFactory   sessionIdGeneratingInterceptorFactory    =    SessionIdGeneratingInterceptor . FACTORY ;", "viewConfiguration . addClientPostConstructInterceptor ( sessionIdGeneratingInterceptorFactory ,    INSTANCE _ CREATE )  ;", "for    ( Method   method    :    viewConfiguration . getProxyFactory (  )  . getCachedMethods (  )  )     {", "if    (  (  ( method . getName (  )  . equals (  \" hashCode \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )  )     |  |     (  (  ( method . getName (  )  . equals (  \" equals \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     1  )  )     &  &     (  ( method . getParameterTypes (  )  [  0  ]  )     =  =     ( Object . class )  )  )  )     {", "viewConfiguration . addClientInterceptor ( method ,    StatefulIdentityInterceptor . FACTORY ,    EJB _ EQUALS _ HASHCODE )  ;", "}", "}", "}", "}", "}  )  ;", "if    (  (  ( view . getMethodIntf (  )  )     !  =     ( MethodIntf . LOCAL _ HOME )  )     &  &     (  ( view . getMethodIntf (  )  )     !  =     ( MethodIntf . HOME )  )  )     {", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentConfiguration   componentConfiguration ,    ViewDescription   description ,    ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "configuration . addViewInterceptor ( InstanceInterceptor . FACTORY ,    ASSOCIATING _ INTERCEPTOR )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["addStatefulInstanceAssociatingInterceptor"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "getConfigurators (  )  . addFirst ( new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,       description ,    ComponentConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final   InterceptorFactory   interceptorFactory    =    StatefulSessionSynchronizationInterceptor . factory ( getTransactionManagementType (  )  )  ;", "configuration . addComponentInterceptor ( interceptorFactory ,    SYNCHRONIZATION _ INTERCEPTOR ,    false )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addStatefulSessionSynchronizationInterceptor"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "view . setSerializable ( true )  ;", "view . setUseWriteReplace ( true )  ;", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   View   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final   DeploymentReflectionIndex   index    =    context . getDeploymentUnit (  )  . getAttachment ( REFLECTION _ INDEX )  ;", "ClassReflectionIndex   classIndex    =    index . getClassIndex ( WriteReplaceInterface . class )  ;", "for    ( Method   method    :     (  ( Collection < Method >  )     ( classIndex . getMethods (  )  )  )  )     {", "configuration . addClientInterceptor ( method ,    new   StatefulWriteReplaceInterceptor . Factory ( configuration . getViewServiceName (  )  . getCanonicalName (  )  )  ,    WRITE _ REPLACE )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addViewSerializationInterceptor"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   afterBegin ;", "}", "METHOD_END"], "methodName": ["getAfterBegin"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   afterCompletion ;", "}", "METHOD_END"], "methodName": ["getAfterCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   beforeCompletion ;", "}", "METHOD_END"], "methodName": ["getBeforeCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . deploymentUnitServiceName ;", "}", "METHOD_END"], "methodName": ["getDeploymentUnitServiceName"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( initMethods )  ;", "}", "METHOD_END"], "methodName": ["getInitMethods"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . removeMethods . values (  )  ;", "}", "METHOD_END"], "methodName": ["getRemoveMethods"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   statefulTimeout ;", "}", "METHOD_END"], "methodName": ["getStatefulTimeout"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . afterBegin    =    afterBegin ;", "}", "METHOD_END"], "methodName": ["setAfterBegin"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . afterCompletion    =    afterCompletion ;", "}", "METHOD_END"], "methodName": ["setAfterCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . beforeCompletion    =    afterCompletion ;", "}", "METHOD_END"], "methodName": ["setBeforeCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . cache    =    cache ;", "}", "METHOD_END"], "methodName": ["setCache"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . passivationApplicable    =    passivationApplicable ;", "}", "METHOD_END"], "methodName": ["setPassivationApplicable"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . statefulTimeout    =    statefulTimeout ;", "}", "METHOD_END"], "methodName": ["setStatefulTimeout"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    (  ( StatefulSessionComponentInstance )     ( context . getPrivateData ( ComponentInstance . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentInstance"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulComponentInstanceInterceptor"}, {"methodBody": ["METHOD_START", "{", "return    ( ejbComponent . getApplicationException ( exceptionClass ,    invokedMethod )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isApplicationException"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulRemoveInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSerializedProxy"}, {"methodBody": ["METHOD_START", "{", "ServiceController < ComponentView >    view    =     (  ( ServiceController < ComponentView >  )     ( StatefulSerializedProxy . currentServiceContainer (  )  . getRequiredService ( ServiceName . parse ( viewName )  )  )  )  ;", "try    {", "return   view . getValue (  )  . createInstance ( Collections .  < Object ,    Object > singletonMap ( SessionID . class ,    sessionID )  )  . getInstance (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSerializedProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . cache . create (  )  . getId (  )  ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "ControlPoint   controlPoint    =    getControlPoint (  )  ;", "if    ( controlPoint    =  =    null )     {", "return   createSession (  )  ;", "} else    {", "try    {", "RunResult   result    =    controlPoint . beginRequest (  )  ;", "if    ( result    =  =     ( RunResult . REJECTED )  )     {", "throw   EjbLogger . ROOT _ LOGGER . containerSuspended (  )  ;", "}", "try    {", "return   createSession (  )  ;", "}    finally    {", "controlPoint . requestComplete (  )  ;", "}", "}    catch    ( EJBUnavailableException    |    IsStoppedException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   EJBException ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createSessionRemote"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "final   EJBBusinessMethod   ejbMethod    =    new   EJBBusinessMethod ( method )  ;", "final   AccessTimeoutDetails   accessTimeout    =    this . methodAccessTimeouts . get ( ejbMethod )  ;", "if    ( accessTimeout    !  =    null )     {", "return   accessTimeout ;", "}", "final   AccessTimeoutDetails   timeout    =    this . beanLevelAccessTimeout . get ( method . getDeclaringClass (  )  . getName (  )  )  ;", "if    ( timeout    !  =    null )     {", "return   timeout ;", "}", "return   defaultAccessTimeoutProvider . getDefaultAccessTimeout (  )  ;", "}", "METHOD_END"], "methodName": ["getAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   afterBeginInterceptor ;", "}", "METHOD_END"], "methodName": ["getAfterBegin"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   afterBeginMethod ;", "}", "METHOD_END"], "methodName": ["getAfterBeginMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   afterCompletionInterceptor ;", "}", "METHOD_END"], "methodName": ["getAfterCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   afterCompletionMethod ;", "}", "METHOD_END"], "methodName": ["getAfterCompletionMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   beforeCompletionInterceptor ;", "}", "METHOD_END"], "methodName": ["getBeforeCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   beforeCompletionMethod ;", "}", "METHOD_END"], "methodName": ["getBeforeCompletionMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . ejb 2 XRemoveMethodInterceptor ;", "}", "METHOD_END"], "methodName": ["getEjb2XRemoveMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . postActivateInterceptor ;", "}", "METHOD_END"], "methodName": ["getPostActivate"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   this . prePassivateInterceptor ;", "}", "METHOD_END"], "methodName": ["getPrePassivate"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   serialiableInterceptorContextKeys ;", "}", "METHOD_END"], "methodName": ["getSerialiableInterceptorContextKeys"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "final   StatefulSessionComponentInstance   instance    =     (  ( StatefulSessionComponentInstance )     ( ctx . getPrivateData ( ComponentInstance . class )  )  )  ;", "return   instance . getId (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionIdOf"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   cache . isRemotable ( throwable )  ;", "}", "METHOD_END"], "methodName": ["isRemotable"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "this . cache . remove ( sessionId )  ;", "}", "METHOD_END"], "methodName": ["removeSession"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getApplicationException ( ex . getClass (  )  ,    method )  )     !  =    null )     {", "return   false ;", "}", "if    (  ( ex   instanceof   ConcurrentAccessTimeoutException )     |  |     ( ex   instanceof   ConcurrentAccessException )  )     {", "return   false ;", "}", "if    (  !  ( ex   instanceof   RemoveException )  )     {", "if    (  ( ex   instanceof   RuntimeException )     |  |     ( ex   instanceof   RemoteException )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldDiscard"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponent"}, {"methodBody": ["METHOD_START", "{", "return   afterBegin ;", "}", "METHOD_END"], "methodName": ["getAfterBegin"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   afterBeginMethod ;", "}", "METHOD_END"], "methodName": ["getAfterBeginMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   afterCompletion ;", "}", "METHOD_END"], "methodName": ["getAfterCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   afterCompletionMethod ;", "}", "METHOD_END"], "methodName": ["getAfterCompletionMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   beforeCompletion ;", "}", "METHOD_END"], "methodName": ["getBeforeCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   beforeCompletionMethod ;", "}", "METHOD_END"], "methodName": ["getBeforeCompletionMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheFactory ;", "}", "METHOD_END"], "methodName": ["getCacheFactory"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheFactoryBuilder ;", "}", "METHOD_END"], "methodName": ["getCacheFactoryBuilderInjector"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultAccessTimeoutService ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessTimeoutInjector"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   defaultAccessTimeoutService . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultAccessTimeoutService"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   ejb 2 XRemoveMethod ;", "}", "METHOD_END"], "methodName": ["getEjb2XRemoveMethod"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . postActivate ;", "}", "METHOD_END"], "methodName": ["getPostActivate"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . prePassivate ;", "}", "METHOD_END"], "methodName": ["getPrePassivate"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   serializableInterceptorContextKeys ;", "}", "METHOD_END"], "methodName": ["getSerializableInterceptorContextKeys"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "method . setAccessible ( true )  ;", "return   InvokeMethodOnTargetInterceptor . factory ( method )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodOnTarget"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . passivationCapable ;", "}", "METHOD_END"], "methodName": ["isPassivationCapable"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "CurrentSynchronizationCallback . set ( CurrentSynchronizationCallback . CallbackType . AFTER _ BEGIN )  ;", "try    {", "execute ( afterBegin ,    get (  )  . getAfterBeginMethod (  )  )  ;", "}    finally    {", "CurrentSynchronizationCallback . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["afterBegin"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "CurrentSynchronizationCallback . set ( CurrentSynchronizationCallback . CallbackType . AFTER _ COMPLETION )  ;", "try    {", "execute ( afterCompletion ,    get (  )  . getAfterCompletionMethod (  )  ,    committed )  ;", "}    finally    {", "CurrentSynchronizationCallback . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["afterCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "CurrentSynchronizationCallback . set ( CurrentSynchronizationCallback . CallbackType . BEFORE _ COMPLETION )  ;", "try    {", "execute ( beforeCompletion ,    get (  )  . getBeforeCompletionMethod (  )  )  ;", "}    finally    {", "CurrentSynchronizationCallback . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["beforeCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "if    ( interceptor    =  =    null )", "return   null ;", "final   InterceptorContext   interceptorContext    =    new   InterceptorContext (  )  ;", "interceptorContext . setMethod ( method )  ;", "interceptorContext . putPrivateData ( Component . class ,    getComponent (  )  )  ;", "interceptorContext . putPrivateData (  . class ,    this )  ;", "interceptorContext . putPrivateData ( InvokeMethodOnTargetInterceptor . PARAMETERS _ KEY ,    parameters )  ;", "interceptorContext . setContextData ( new   HashMap < String ,    Object >  (  )  )  ;", "interceptorContext . setTarget ( getInstance (  )  )  ;", "final   AbstractTransaction   transaction    =    ContextTransactionManager . getInstance (  )  . getTransaction (  )  ;", "interceptorContext . setTransactionSupplier (  (  )     -  >    transaction )  ;", "try    {", "return   interceptor . processInvocation ( interceptorContext )  ;", "}    catch    ( Error   e )     {", "throw   e ;", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   EJBException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   ejb 2 XRemoveInterceptor ;", "}", "METHOD_END"], "methodName": ["getEjb2XRemoveInterceptor"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   invocationSynchState ;", "}", "METHOD_END"], "methodName": ["getInvocationSynchState"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   lock ;", "}", "METHOD_END"], "methodName": ["getLock"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   threadLock ;", "}", "METHOD_END"], "methodName": ["getThreadLock"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   transaction ;", "}", "METHOD_END"], "methodName": ["getTransaction"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   removed ;", "}", "METHOD_END"], "methodName": ["isRemoved"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   synchronizationRegistered ;", "}", "METHOD_END"], "methodName": ["isSynchronizationRegistered"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "this . execute ( postActivate ,    null )  ;", "}", "METHOD_END"], "methodName": ["postActivate"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "this . execute ( prePassivate ,    null )  ;", "}", "METHOD_END"], "methodName": ["prePassivate"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "this . removed    =    removed ;", "}", "METHOD_END"], "methodName": ["setRemoved"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "this . synchronizationRegistered    =    synchronizationRegistered ;", "}", "METHOD_END"], "methodName": ["setSynchronizationRegistered"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "this . transaction    =    transaction ;", "}", "METHOD_END"], "methodName": ["setTransaction"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "Set < Object >    keys    =    getComponent (  )  . getSerialiableInterceptorContextKeys (  )  ;", "final   Map < Object ,    Object >    serializableInterceptors    =    new   HashMap < Object ,    Object >  (  )  ;", "for    ( Object   key    :    keys )     {", "serializableInterceptors . put ( key ,    getInstanceData ( key )  )  ;", "}", "return   new   Serialized (  (  ( ManagedReference )     ( getInstanceData ( INSTANCE _ KEY )  )  )  ,    id ,    getComponent (  )  . getCreateServiceName (  )  . getCanonicalName (  )  ,    serializableInterceptors )  ;", "}", "METHOD_END"], "methodName": ["writeReplace"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   type    =  =     ( TransactionManagementType . CONTAINER )     ?    StatefulSessionSynchronizationInterceptor . CONTAINER _ MANAGED    :    StatefulSessionSynchronizationInterceptor . BEAN _ MANAGED ;", "}", "METHOD_END"], "methodName": ["factory"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "Object   owner    =    ContextTransactionSynchronizationRegistry . getInstance (  )  . getTransactionKey (  )  ;", "return   owner    !  =    null    ?    owner    :    Thread . currentThread (  )  ;", "}", "METHOD_END"], "methodName": ["getLockOwner"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "EjbLogger . ROOT _ LOGGER . tracef (  \" After   completion   callback   invoked   on   Transaction   synchronization :     % s \"  ,    statefulSessionComponentInstance )  ;", "if    (  (  !  ( statefulSessionComponentInstance . isDiscarded (  )  )  )     &  &     (  ! toDiscard )  )     {", "statefulSessionComponentInstance . afterCompletion ( committed )  ;", "}", "}    catch    ( Throwable   t )     {", ". handleThrowable ( t ,    statefulSessionComponentInstance )  ;", "}", "if    (  (  ( statefulSessionComponentInstance . isRemoved (  )  )     &  &     (  !  ( statefulSessionComponentInstance . isDiscarded (  )  )  )  )     &  &     (  ! toDiscard )  )     {", "try    {", "statefulSessionComponentInstance . destroy (  )  ;", "}    catch    ( Throwable   t )     {", ". handleThrowable ( t ,    statefulSessionComponentInstance )  ;", "}", "}", ". releaseInstance ( statefulSessionComponentInstance )  ;", "}", "METHOD_END"], "methodName": ["handleAfterCompletion"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "EjbLogger . ROOT _ LOGGER . discardingStatefulComponent ( statefulSessionComponentInstance ,    t )  ;", "try    {", "statefulSessionComponentInstance . discard (  )  ;", "}    finally    {", ". releaseLock ( statefulSessionComponentInstance )  ;", "}", "if    ( t   instanceof   RuntimeException )", "throw    (  ( RuntimeException )     ( t )  )  ;", "if    ( t   instanceof   Error )", "throw    (  ( Error )     ( t )  )  ;", "throw    (  ( EJBException )     ( new   EJBException (  )  . initCause ( t )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleThrowable"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  !  ( instance . isDiscarded (  )  )  )     {", "instance . getComponent (  )  . getCache (  )  . release ( instance )  ;", "}", "}    finally    {", "instance . setSynchronizationRegistered ( false )  ;", ". releaseLock ( instance )  ;", "}", "}", "METHOD_END"], "methodName": ["releaseInstance"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "instance . getLock (  )  . unlock ( StatefulSessionSynchronizationInterceptor . getLockOwner (  )  )  ;", "EjbLogger . ROOT _ LOGGER . tracef (  \" Released   lock :     % s \"  ,    instance . getLock (  )  )  ;", "}", "METHOD_END"], "methodName": ["releaseLock"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   AccessTimeoutDetails (  5  ,    TimeUnit . MINUTES )  ;", "}", "METHOD_END"], "methodName": ["defaultAccessTimeout"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptorTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   Interceptor (  )     {", "@ Override", "public   Object   processInvocation ( InterceptorContext   context )    throws   Exception    {", "return   null ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["noop"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptorTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Interceptor   interceptor    =    new   StatefulSessionSynchronizationInterceptor ( true )  ;", "final   InterceptorContext   context    =    new   InterceptorContext (  )  ;", "context . setInterceptors ( Arrays . asList (  . noop (  )  )  )  ;", "final   StatefulSessionComponent   component    =    mock ( StatefulSessionComponent . class )  ;", "context . putPrivateData ( Component . class ,    component )  ;", "when ( component . getAccessTimeout ( null )  )  . thenReturn (  . defaultAccessTimeout (  )  )  ;", "Cache < SessionID ,    StatefulSessionComponentInstance >    cache    =    mock ( Cache . class )  ;", "when ( component . getCache (  )  )  . thenReturn ( cache )  ;", "final   TransactionSynchronizationRegistry   transactionSynchronizationRegistry    =    mock ( TransactionSynchronizationRegistry . class )  ;", "when ( component . getTransactionSynchronizationRegistry (  )  )  . thenReturn ( transactionSynchronizationRegistry )  ;", "when ( transactionSynchronizationRegistry . getTransactionKey (  )  )  . thenReturn (  \" TX 1  \"  )  ;", "final   List < Synchronization >    synchronizations    =    new   LinkedList < Synchronization >  (  )  ;", "doAnswer ( new   Answer < Void >  (  )     {", "@ Override", "public   Void   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "Synchronization   synchronization    =     (  ( Synchronization )     ( invocation . getArguments (  )  [  0  ]  )  )  ;", "synchronizations . add ( synchronization )  ;", "return   null ;", "}", "}  )  . when ( transactionSynchronizationRegistry )  . registerInterposedSynchronization (  (  ( Synchronization )     ( any (  )  )  )  )  ;", "final   StatefulSessionComponentInstance   instance    =    new   StatefulSessionComponentInstance ( component ,    getTerminalInterceptor (  )  ,    Collections . EMPTY _ MAP ,    Collections . emptyMap (  )  )  ;", "context . putPrivateData ( ComponentInstance . class ,    instance )  ;", "interceptor . processInvocation ( context )  ;", "for    ( Synchronization   synchronization    :    synchronizations )     {", "synchronization . beforeCompletion (  )  ;", "}", "for    ( Synchronization   synchronization    :    synchronizations )     {", "synchronization . afterCompletion ( STATUS _ COMMITTED )  ;", "}", "synchronizations . clear (  )  ;", "when ( transactionSynchronizationRegistry . getTransactionKey (  )  )  . thenReturn (  \" TX 2  \"  )  ;", "interceptor . processInvocation ( context )  ;", "}", "METHOD_END"], "methodName": ["testDifferentTx"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulSessionSynchronizationInterceptorTestCase"}, {"methodBody": ["METHOD_START", "{", "return   timeUnit ;", "}", "METHOD_END"], "methodName": ["getTimeUnit"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulTimeoutInfo"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulTimeoutInfo"}, {"methodBody": ["METHOD_START", "{", "return   firstInvocation ;", "}", "METHOD_END"], "methodName": ["isFirstInvocation"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulTransactionMarker"}, {"methodBody": ["METHOD_START", "{", "return   firstInvocation    ?    StatefulTransactionMarker . FIRST    :    StatefulTransactionMarker . SECOND ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.jboss.as.ejb3.component.stateful.StatefulTransactionMarker"}, {"methodBody": ["METHOD_START", "{", "view . setSerializable ( true )  ;", "view . setUseWriteReplace ( true )  ;", "view . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   View   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final   DeploymentReflectionIndex   index    =    context . getDeploymentUnit (  )  . getAttachment ( REFLECTION _ INDEX )  ;", "ClassReflectionIndex   classIndex    =    index . getClassIndex ( WriteReplaceInterface . class )  ;", "for    ( Method   method    :     (  ( Collection < Method >  )     ( classIndex . getMethods (  )  )  )  )     {", "configuration . addClientInterceptor ( method ,    StatelessWriteReplaceInterceptor . factory ( configuration . getViewServiceName (  )  . getCanonicalName (  )  )  ,    WRITE _ REPLACE )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addViewSerializationInterceptor"], "fileName": "org.jboss.as.ejb3.component.stateless.StatelessComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . poolConfigName ;", "}", "METHOD_END"], "methodName": ["getPoolConfigName"], "fileName": "org.jboss.as.ejb3.component.stateless.StatelessComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . poolConfigName    =    poolConfigName ;", "}", "METHOD_END"], "methodName": ["setPoolConfigName"], "fileName": "org.jboss.as.ejb3.component.stateless.StatelessComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   StatelessComponentInstanceAssociatingFactory . INSTANCE ;", "}", "METHOD_END"], "methodName": ["instance"], "fileName": "org.jboss.as.ejb3.component.stateless.StatelessComponentInstanceAssociatingFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . poolConfig . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getPoolConfig"], "fileName": "org.jboss.as.ejb3.component.stateless.StatelessSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . poolConfig ;", "}", "METHOD_END"], "methodName": ["getPoolConfigInjector"], "fileName": "org.jboss.as.ejb3.component.stateless.StatelessSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   Affinity . NONE ;", "}", "METHOD_END"], "methodName": ["getWeakAffinity"], "fileName": "org.jboss.as.ejb3.component.stateless.StatelessSessionComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   timeUnit ;", "}", "METHOD_END"], "methodName": ["getTimeUnit"], "fileName": "org.jboss.as.ejb3.concurrency.AccessTimeoutDetails"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ejb3.concurrency.AccessTimeoutDetails"}, {"methodBody": ["METHOD_START", "{", "this . ejbReadWriteLock    =    null ;", "}", "METHOD_END"], "methodName": ["afterTest"], "fileName": "org.jboss.as.ejb3.concurrency.EJBReadWriteLockTest"}, {"methodBody": ["METHOD_START", "{", "this . ejbReadWriteLock    =    new   EJBReadWriteLock (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTest"], "fileName": "org.jboss.as.ejb3.concurrency.EJBReadWriteLockTest"}, {"methodBody": ["METHOD_START", "{", "Lock   readLock    =    this . ejbReadWriteLock . readLock (  )  ;", "readLock . lock (  )  ;", "Lock   writeLock    =    this . ejbReadWriteLock . writeLock (  )  ;", "try    {", "writeLock . lock (  )  ;", "writeLock . unlock (  )  ;", "Assert . fail (  \" Unexpected   acquired   write   lock \"  )  ;", "}    catch    ( IllegalLoopbackException   ilbe )     {", "}    finally    {", "readLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIllegalLoopBack"], "fileName": "org.jboss.as.ejb3.concurrency.EJBReadWriteLockTest"}, {"methodBody": ["METHOD_START", "{", "Lock   writeLock    =    this . ejbReadWriteLock . writeLock (  )  ;", "writeLock . lock (  )  ;", "Lock   readLock    =    this . ejbReadWriteLock . readLock (  )  ;", "try    {", "boolean   readLockAcquired    =    readLock . tryLock (  2  ,    TimeUnit . SECONDS )  ;", "if    ( readLockAcquired )     {", "readLock . unlock (  )  ;", "}", "Assert . assertTrue (  \" Could   not   obtain   read   lock   when   write   lock   was   held   by   the   same   thread !  \"  ,    readLockAcquired )  ;", "}    finally    {", "writeLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSameThreadCanGetWriteThenReadLock"], "fileName": "org.jboss.as.ejb3.concurrency.EJBReadWriteLockTest"}, {"methodBody": ["METHOD_START", "{", "CountDownLatch   latch    =    new   CountDownLatch (  2  )  ;", "Lock   writeLock    =    this . ejbReadWriteLock . writeLock (  )  ;", "Thread   threadHoldingWriteLock    =    new   Thread ( new    . ThreadHoldingWriteLock ( latch ,    writeLock ,     5  0  0  0  )  )  ;", "Lock   readLock    =    this . ejbReadWriteLock . readLock (  )  ;", "threadHoldingWriteLock . start (  )  ;", "Thread . sleep (  5  0  0  )  ;", "try    {", "boolean   readLockAcquired    =    readLock . tryLock (  2  ,    TimeUnit . SECONDS )  ;", "Assert . assertFalse (  \" Unexpected   obtained   a   read   lock \"  ,    readLockAcquired )  ;", "}    catch    ( ConcurrentAccessTimeoutException   cate )     {", "}    finally    {", "latch . countDown (  )  ;", "latch . await (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTimeout"], "fileName": "org.jboss.as.ejb3.concurrency.EJBReadWriteLockTest"}, {"methodBody": ["METHOD_START", "{", "InterceptorContext   current    =    CurrentInvocationContext . stack . peek (  )  ;", "return   current ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.ejb3.context.CurrentInvocationContext"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   context    =    CurrentInvocationContext . get (  )  ;", "if    ( context    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . noEjbContextAvailable (  )  ;", "}", "final   ComponentInstance   component    =    context . getPrivateData ( ComponentInstance . class )  ;", "if    (  !  ( component   instanceof   EjbComponentInstance )  )     {", "throw   EjbLogger . ROOT _ LOGGER . currentComponentNotAEjb ( component )  ;", "}", "return    (  ( EjbComponentInstance )     ( component )  )  . getEjbContext (  )  ;", "}", "METHOD_END"], "methodName": ["getEjbContext"], "fileName": "org.jboss.as.ejb3.context.CurrentInvocationContext"}, {"methodBody": ["METHOD_START", "{", "return   CurrentInvocationContext . stack . pop (  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jboss.as.ejb3.context.CurrentInvocationContext"}, {"methodBody": ["METHOD_START", "{", "assert   invocation    !  =    null    :     \" invocation   is   null \"  ;", ". stack . push ( invocation )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.ejb3.context.CurrentInvocationContext"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . isDeprecated (  \" getCallerIdentity \"  )  ;", "}", "METHOD_END"], "methodName": ["getCallerIdentity"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . GET _ CALLER _ PRINCIPLE )  ;", "return   instance . getComponent (  )  . getCallerPrincipal (  )  ;", "}", "METHOD_END"], "methodName": ["getCallerPrincipal"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "return   instance . getComponent (  )  ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   invocation    =    CurrentInvocationContext . get (  )  ;", "return   invocation . getContextData (  )  ;", "}", "METHOD_END"], "methodName": ["getContextData"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "return   getComponent (  )  . getEJBHome (  )  ;", "}", "METHOD_END"], "methodName": ["getEJBHome"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "return   instance . getComponent (  )  . getEJBLocalHome (  )  ;", "}", "METHOD_END"], "methodName": ["getEJBLocalHome"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . isDeprecated (  \" getCallerIdentity \"  )  ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext    =    CurrentInvocationContext . get (  )  ;", "if    (  ( getMethod (  )  )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . lifecycleMethodNotAllowed (  \" getRollbackOnly \"  )  ;", "}", "return   instance . getComponent (  )  . getRollbackOnly (  )  ;", "}", "METHOD_END"], "methodName": ["getRollbackOnly"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "return   instance . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . GET _ TIMER _ SERVICE )  ;", "return   instance . getComponent (  )  . getTimerService (  )  ;", "}", "METHOD_END"], "methodName": ["getTimerService"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . GET _ USER _ TRANSACTION )  ;", "return   getComponent (  )  . getUserTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["getUserTransaction"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . IS _ CALLER _ IN _ ROLE )  ;", "return   instance . getComponent (  )  . isCallerInRole ( roleName )  ;", "}", "METHOD_END"], "methodName": ["isCallerInRole"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . isDeprecatedIllegalState (  \" isCallerInRole \"  )  ;", "}", "METHOD_END"], "methodName": ["isCallerInRole"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "return   getComponent (  )  . lookup ( name )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext    =    CurrentInvocationContext . get (  )  ;", "if    (  ( getMethod (  )  )     =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . lifecycleMethodNotAllowed (  \" getRollbackOnly \"  )  ;", "}", "instance . getComponent (  )  . setRollbackOnly (  )  ;", "}", "METHOD_END"], "methodName": ["setRollbackOnly"], "fileName": "org.jboss.as.ejb3.context.EJBContextImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   invocation    =    CurrentInvocationContext . get (  )  ;", "return   getComponent (  )  . getBusinessObject ( businessInterface ,    invocation )  ;", "}", "METHOD_END"], "methodName": ["getBusinessObject"], "fileName": "org.jboss.as.ejb3.context.SessionContextImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SessionBeanComponent )     ( super . getComponent (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.jboss.as.ejb3.context.SessionContextImpl"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . GET _ EJB _ LOCAL _ OBJECT )  ;", "final   InterceptorContext   invocation    =    CurrentInvocat . get (  )  ;", "return   getComponent (  )  . getEJBLocalObject ( invocation )  ;", "}", "METHOD_END"], "methodName": ["getEJBLocalObject"], "fileName": "org.jboss.as.ejb3.context.SessionContextImpl"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . GET _ EJB _ OBJECT )  ;", "final   InterceptorContext   invocation    =    CurrentInvocat . get (  )  ;", "return   getComponent (  )  . getEJBObject ( invocation )  ;", "}", "METHOD_END"], "methodName": ["getEJBObject"], "fileName": "org.jboss.as.ejb3.context.SessionContextImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   invocation    =    CurrentInvocationContext . get (  )  ;", "final   ComponentView   view    =    invocation . getPrivateData ( ComponentView . class )  ;", "if    (  ( view . getViewClass (  )  . equals ( getComponent (  )  . getEjbObjectType (  )  )  )     |  |     ( view . getViewClass (  )  . equals ( getComponent (  )  . getEjbLocalObjectType (  )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . cannotCall (  \" getInvokedBusinessInterface \"  ,     \" EjbObject \"  ,     \" EJBLocalObject \"  )  ;", "}", "return   view . getViewClass (  )  ;", "}", "METHOD_END"], "methodName": ["getInvokedBusinessInterface"], "fileName": "org.jboss.as.ejb3.context.SessionContextImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   invocation    =    CurrentInvocationContext . get (  )  ;", "final   MessageContext   context    =    invocation . getPrivateData ( MessageContext . class )  ;", "if    ( context    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . cannotCall (  \" getMessageContext (  )  \"  ,     \" MessageContext \"  )  ;", "}", "return   context ;", "}", "METHOD_END"], "methodName": ["getMessageContext"], "fileName": "org.jboss.as.ejb3.context.SessionContextImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   invocation    =    CurrentInvocationContext . get (  )  ;", "final   CancellationFlag   flag    =    invocation . getPrivateData ( CancellationFlag . class )  ;", "if    ( flag    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . noAsynchronousInvocationInProgress (  )  ;", "}", "return   flag . isCancelFlagSet (  )  ;", "}", "METHOD_END"], "methodName": ["wasCancelCalled"], "fileName": "org.jboss.as.ejb3.context.SessionContextImpl"}, {"methodBody": ["METHOD_START", "{", "return   deliveryGroup ;", "}", "METHOD_END"], "methodName": ["getDeliveryGroup"], "fileName": "org.jboss.as.ejb3.deliveryactive.metadata.EJBBoundMdbDeliveryMetaData"}, {"methodBody": ["METHOD_START", "{", "return   deliveryActive ;", "}", "METHOD_END"], "methodName": ["isDeliveryActive"], "fileName": "org.jboss.as.ejb3.deliveryactive.metadata.EJBBoundMdbDeliveryMetaData"}, {"methodBody": ["METHOD_START", "{", "this . deliveryActive    =    deliveryActive ;", "}", "METHOD_END"], "methodName": ["setDeliveryActive"], "fileName": "org.jboss.as.ejb3.deliveryactive.metadata.EJBBoundMdbDeliveryMetaData"}, {"methodBody": ["METHOD_START", "{", "this . deliveryGroup    =    deliveryGroup ;", "}", "METHOD_END"], "methodName": ["setDeliveryGroup"], "fileName": "org.jboss.as.ejb3.deliveryactive.metadata.EJBBoundMdbDeliveryMetaData"}, {"methodBody": ["METHOD_START", "{", "if    ( map    =  =    null )", "return   null ;", "return   map . get ( key )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "assert   methodIntf    !  =    null    :     \" methodIntf   is   null \"  ;", "Method   classMethod    =    resolveRealMethod ( method )  ;", "String [  ]    methodParams    =    MethodInfoHelper . getCanonicalParameterTypes ( classMethod )  ;", "final   String   methodName    =    classMethod . getName (  )  ;", "final   String   className    =    classMethod . getDeclaringClass (  )  . getName (  )  ;", "final   List < T >    ret    =    new   ArrayList < T >  (  )  ;", ". ArrayKey   methodParamsKey    =    new    . ArrayKey (  (  ( Object [  ]  )     ( methodParams )  )  )  ;", "T   attr    =     . get (  . get (  . get ( perViewStyle 3  ,    methodIntf )  ,    methodName )  ,    methodParamsKey )  ;", "if    ( attr    !  =    null )", "ret . add ( attr )  ;", "attr    =     . get (  . get ( perViewStyle 2  ,    methodIntf )  ,    methodName )  ;", "if    ( attr    !  =    null )", "ret . add ( attr )  ;", "attr    =     . get ( perViewStyle 1  ,    methodIntf )  ;", "if    ( attr    !  =    null )", "ret . add ( attr )  ;", "attr    =     . get (  . get (  . get ( style 3  ,    className )  ,    methodName )  ,    methodParamsKey )  ;", "if    ( attr    !  =    null )", "ret . add ( attr )  ;", "attr    =     . get ( style 2  ,    methodName )  ;", "if    ( attr    !  =    null )", "ret . add ( attr )  ;", "attr    =     . get ( style 1  ,    className )  ;", "if    ( attr    !  =    null )", "ret . add ( attr )  ;", "return   ret ;", "}", "METHOD_END"], "methodName": ["getAllAttributes"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "return   getAttribute ( methodIntf ,    method ,    null )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "assert   methodIntf    !  =    null    :     \" methodIntf   is   null \"  ;", "assert   method    !  =    null    :     \" method   is   null \"  ;", "Method   classMethod    =    resolveRealMethod ( method )  ;", "String [  ]    methodParams    =    MethodInfoHelper . getCanonicalParameterTypes ( classMethod )  ;", "final   String   methodName    =    classMethod . getName (  )  ;", "final   String   className    =    classMethod . getDeclaringClass (  )  . getName (  )  ;", ". ArrayKey   methodParamsKey    =    new    . ArrayKey (  (  ( Object [  ]  )     ( methodParams )  )  )  ;", "T   attr    =     . get (  . get (  . get ( perViewStyle 3  ,    methodIntf )  ,    methodName )  ,    methodParamsKey )  ;", "if    ( attr    !  =    null )", "return   attr ;", "attr    =     . get (  . get ( perViewStyle 2  ,    methodIntf )  ,    methodName )  ;", "if    ( attr    !  =    null )", "return   attr ;", "attr    =     . get ( perViewStyle 1  ,    methodIntf )  ;", "if    ( attr    !  =    null )", "return   attr ;", "attr    =     . get (  . get (  . get ( style 3  ,    className )  ,    methodName )  ,    methodParamsKey )  ;", "if    ( attr    !  =    null )", "return   attr ;", "attr    =     . get ( style 2  ,    methodName )  ;", "if    ( attr    !  =    null )", "return   attr ;", "attr    =     . get ( style 1  ,    className )  ;", "if    ( attr    !  =    null )", "return   attr ;", "if    ( defaultMethodIntf    =  =    null )     {", "return   defaultAttribute ;", "} else    {", "return   getAttribute ( defaultMethodIntf ,    method )  ;", "}", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( methodIntf    !  =    null )     &  &     ( className    !  =    null )  )", "throw   logging . EjbLogger . ROOT _ LOGGER . bothMethodIntAndClassNameSet ( componentName )  ;", "if    ( methodIntf    =  =    null )     {", "return   style 1  . get ( className )  ;", "} else    {", "return   perViewStyle 1  . get ( methodIntf )  ;", "}", "}", "METHOD_END"], "methodName": ["getAttributeStyle1"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "if    ( methodIntf    =  =    null )", "return   style 2  . get ( methodName )  ;", "else", "return   perViewStyle 2  . pick ( methodIntf )  . get ( methodName )  ;", "}", "METHOD_END"], "methodName": ["getAttributeStyle2"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "ApplicableMethodInformation . ArrayKey   methodParamsKey    =    new   ApplicableMethodInformation . ArrayKey (  (  ( Object [  ]  )     ( methodParams )  )  )  ;", "if    ( methodIntf    =  =    null )", "return   style 3  . pick ( className )  . pick ( methodName )  . get ( methodParamsKey )  ;", "else", "return   perViewStyle 3  . pick ( methodIntf )  . pick ( methodName )  . get ( methodParamsKey )  ;", "}", "METHOD_END"], "methodName": ["getAttributeStyle3"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "return   style 1  . get ( className )  ;", "}", "METHOD_END"], "methodName": ["getClassLevelAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "return   defaultAttribute ;", "}", "METHOD_END"], "methodName": ["getDefaultAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "assert   methodIntf    !  =    null    :     \" methodIntf   is   null \"  ;", "Method   classMethod    =    resolveRealMethod ( method )  ;", "String [  ]    methodParams    =    MethodInfoHelper . getCanonicalParameterTypes ( classMethod )  ;", "final   String   methodName    =    classMethod . getName (  )  ;", ". ArrayKey   methodParamsKey    =    new    . ArrayKey (  (  ( Object [  ]  )     ( methodParams )  )  )  ;", "T   attr    =     . get (  . get (  . get ( perViewStyle 3  ,    methodIntf )  ,    methodName )  ,    methodParamsKey )  ;", "if    ( attr    !  =    null )", "return   attr ;", "attr    =     . get (  . get ( perViewStyle 2  ,    methodIntf )  ,    methodName )  ;", "if    ( attr    !  =    null )", "return   attr ;", "attr    =     . get ( perViewStyle 1  ,    methodIntf )  ;", "if    ( attr    !  =    null )", "return   attr ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getViewAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "assert   methodIntf    !  =    null    :     \" methodIntf   is   null \"  ;", "assert   method    !  =    null    :     \" method   is   null \"  ;", "Method   classMethod    =    resolveRealMethod ( method )  ;", "String [  ]    methodParams    =    MethodInfoHelper . getCanonicalParameterTypes ( classMethod )  ;", "final   String   methodName    =    classMethod . getName (  )  ;", "final   String   className    =    classMethod . getDeclaringClass (  )  . getName (  )  ;", ". ArrayKey   methodParamsKey    =    new    . ArrayKey (  (  ( Object [  ]  )     ( methodParams )  )  )  ;", "T   attr    =     . get (  . get (  . get ( perViewStyle 3  ,    methodIntf )  ,    methodName )  ,    methodParamsKey )  ;", "if    ( attr    !  =    null )", "return   true ;", "attr    =     . get (  . get ( perViewStyle 2  ,    methodIntf )  ,    methodName )  ;", "if    ( attr    !  =    null )", "return   true ;", "attr    =     . get ( perViewStyle 1  ,    methodIntf )  ;", "if    ( attr    !  =    null )", "return   false ;", "attr    =     . get (  . get (  . get ( style 3  ,    className )  ,    methodName )  ,    methodParamsKey )  ;", "if    ( attr    !  =    null )", "return   true ;", "attr    =     . get ( style 2  ,    methodName )  ;", "if    ( attr    !  =    null )", "return   true ;", "attr    =     . get ( style 1  ,    className )  ;", "if    ( attr    !  =    null )", "return   false ;", "if    ( defaultMethodIntf    =  =    null )     {", "return   false ;", "} else    {", "return   isMethodLevel ( defaultMethodIntf ,    method ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["isMethodLevel"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( method . isBridge (  )  )     |  |     ( method . isSynthetic (  )  )  )     {", "[  ]    declareds    =    WildFlySecurityManager . doUnchecked ( new   PrivilegedAction <  [  ]  >  (  )     {", "@ Override", "public    [  ]    run (  )     {", "return   method . getDeclaringClass (  )  . getDeclareds (  )  ;", "}", "}  )  ;", "methodLoop    :    for    (    m    :    declareds )     {", "if    (  (  (  ( m . getName (  )  . equals ( method . getName (  )  )  )     &  &     (  ( m . getParameterTypes (  )  . length )     =  =     ( method . getParameterTypes (  )  . length )  )  )     &  &     (  !  ( m . isBridge (  )  )  )  )     &  &     (  !  ( m . isSynthetic (  )  )  )  )     {", "if    (  !  ( method . getReturnType (  )  . isAssignableFrom ( m . getReturnType (  )  )  )  )     {", "continue   methodLoop ;", "}", "for    ( int   i    =     0  ;    i    <     ( method . getParameterTypes (  )  . length )  ;     +  + i )     {", "if    (  !  ( method . getParameterTypes (  )  [ i ]  . isAssignableFrom ( m . getParameterTypes (  )  [ i ]  )  )  )     {", "continue   methodLoop ;", "}", "}", "return   m ;", "}", "}", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["resolveRealMethod"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "if    ( methodIntf    =  =    null )", "style 2  . put ( methodName ,    transactionAttribute )  ;", "else", "perViewStyle 2  . pick ( methodIntf )  . put ( methodName ,    transactionAttribute )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "ApplicableMethodInformation . ArrayKey   methodParamsKey    =    new   ApplicableMethodInformation . ArrayKey (  (  ( Object [  ]  )     ( methodParams )  )  )  ;", "if    ( methodIntf    =  =    null )", "style 3  . pick ( className )  . pick ( methodName )  . put ( methodParamsKey ,    transactionAttribute )  ;", "else", "perViewStyle 3  . pick ( methodIntf )  . pick ( methodName )  . put ( methodParamsKey ,    transactionAttribute )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( methodIntf    !  =    null )     &  &     ( className    !  =    null )  )", "throw   logging . EjbLogger . ROOT _ LOGGER . bothMethodIntAndClassNameSet ( componentName )  ;", "if    ( methodIntf    =  =    null )     {", "style 1  . put ( className ,    attribute )  ;", "} else", "perViewStyle 1  . put ( methodIntf ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "this . defaultAttribute    =    defaultAttribute ;", "}", "METHOD_END"], "methodName": ["setDefaultAttribute"], "fileName": "org.jboss.as.ejb3.deployment.ApplicableMethodInformation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( exceptionClassName    =  =    null )     |  |     ( exceptionClassName . isEmpty (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . stringParamCannotBeNullOrEmpty (  \" Exception   class   name \"  )  ;", "}", "tails   appException    =    new   tails ( exceptionClassName ,    inherited ,    rollback )  ;", "this . applicationExceptions . put ( exceptionClassName ,    appException )  ;", "}", "METHOD_END"], "methodName": ["addApplicationException"], "fileName": "org.jboss.as.ejb3.deployment.ApplicationExceptionDescriptions"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . applicationExceptions )  ;", "}", "METHOD_END"], "methodName": ["getApplicationExceptions"], "fileName": "org.jboss.as.ejb3.deployment.ApplicationExceptionDescriptions"}, {"methodBody": ["METHOD_START", "{", "if    ( exceptionClass    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . paramCannotBeNull (  \" Exception   class \"  )  ;", "}", "if    ( applicationException    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . paramCannotBeNull (  \"  \"  )  ;", "}", "if    (  !  ( Exception . class . isAssignableFrom ( exceptionClass )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . cannotBeBecauseNotAnExceptionType ( exceptionClass )  ;", "}", "if    ( RemoteException . class . isAssignableFrom ( exceptionClass )  )     {", "throw   EjbLogger . ROOT _ LOGGER . rmiRemoteExceptionCannotBe ( exceptionClass )  ;", "}", "this . applicationExceptions . put ( exceptionClass ,    applicationException )  ;", "}", "METHOD_END"], "methodName": ["addApplicationException"], "fileName": "org.jboss.as.ejb3.deployment.ApplicationExceptions"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationExceptions . get ( exceptionClass )  ;", "}", "METHOD_END"], "methodName": ["getApplicationException"], "fileName": "org.jboss.as.ejb3.deployment.ApplicationExceptions"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . applicationExceptions )  ;", "}", "METHOD_END"], "methodName": ["getApplicationExceptions"], "fileName": "org.jboss.as.ejb3.deployment.ApplicationExceptions"}, {"methodBody": ["METHOD_START", "{", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentModuleIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   distinctName ;", "}", "METHOD_END"], "methodName": ["getDistinctName"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentModuleIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentModuleIdentifier"}, {"methodBody": ["METHOD_START", "{", "final   List < DeploymentRepositoryListener >    listeners ;", "final   boolean   suspended ;", "synchronized ( this )     {", "final   Map < DeploymentModuleIdentifier ,    DeploymentRepository . DeploymentHolder >    modules    =    new   HashMap < DeploymentModuleIdentifier ,    DeploymentRepository . DeploymentHolder >  ( this . modules )  ;", "modules . put ( identifier ,    new   DeploymentRepository . DeploymentHolder ( deployment )  )  ;", "this . modules    =    Collections . unmodifiableMap ( modules )  ;", "listeners    =    new   ArrayList < DeploymentRepositoryListener >  ( this . listeners )  ;", "suspended    =    this . suspended ;", "}", "for    ( final   DeploymentRepositoryListener   listener    :    listeners )     {", "try    {", "listener . deploymentAvailable ( identifier ,    deployment )  ;", "if    ( suspended )     {", "listener . deploymentSuspended ( identifier )  ;", "}", "}    catch    ( Throwable   t )     {", "EjbLogger . DEPLOYMENT _ LOGGER . deploymentAddListenerException ( t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "listenerdd ( listener )  ;", "}", "listener . listenerAdded ( this )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "Map < DeploymentModuleIdentifier ,    ModuleDeployment >    modules    =    new   HashMap < DeploymentModuleIdentifier ,    ModuleDeployment >  (  )  ;", "for    ( Map . Entry < DeploymentModuleIdentifier ,     . DeploymentHolder >    entry    :    this . modules . entrySet (  )  )     {", "modules . put ( entry . getKey (  )  ,    entry . getValue (  )  . deployment )  ;", "}", "return   modules ;", "}", "METHOD_END"], "methodName": ["getModules"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "Map < DeploymentModuleIdentifier ,    ModuleDeployment >    modules    =    new   HashMap < DeploymentModuleIdentifier ,    ModuleDeployment >  (  )  ;", "for    ( Map . Entry < DeploymentModuleIdentifier ,     . DeploymentHolder >    entry    :    this . modules . entrySet (  )  )     {", "if    ( entry . getValue (  )  . started )     {", "modules . put ( entry . getKey (  )  ,    entry . getValue (  )  . deployment )  ;", "}", "}", "return   modules ;", "}", "METHOD_END"], "methodName": ["getStartedModules"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "final   List < DeploymentRepositoryListener >    listeners ;", "synchronized ( this )     {", "final   Map < DeploymentModuleIdentifier ,    DeploymentRepository . DeploymentHolder >    modules    =    new   HashMap < DeploymentModuleIdentifier ,    DeploymentRepository . DeploymentHolder >  ( this . modules )  ;", "modules . remove ( identifier )  ;", "this . modules    =    Collections . unmodifiableMap ( modules )  ;", "listeners    =    new   ArrayList < DeploymentRepositoryListener >  ( this . listeners )  ;", "}", "for    ( final   DeploymentRepositoryListener   listener    :    listeners )     {", "try    {", "listener . deploymentRemoved ( identifier )  ;", "}    catch    ( Throwable   t )     {", "EjbLogger . DEPLOYMENT _ LOGGER . deploymentRemoveListenerException ( t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "listeners . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "final   List < DeploymentRepositoryListener >    listeners ;", "final   Set < DeploymentModuleIdentifier >    moduleIdentifiers ;", "synchronized ( this )     {", "moduleIdentifiers    =    new   HashSet <  >  ( this . modules . keySet (  )  )  ;", "listeners    =    new   ArrayList <  >  ( this . listeners )  ;", "suspended    =    false ;", "}", "for    ( final   DeploymentRepositoryListener   listener    :    listeners )     {", "for    ( DeploymentModuleIdentifier   moduleIdentifier    :    moduleIdentifiers )", "try    {", "listener . deploymentResumed ( moduleIdentifier )  ;", "}    catch    ( Throwable   t )     {", "deploymentAddListenerException ( t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "DeploymentRepository . DeploymentHolder   deployment ;", "final   List < DeploymentRepositoryListener >    listeners ;", "synchronized ( this )     {", "deployment    =    modules . get ( identifier )  ;", "if    ( deployment    =  =    null )", "return   false ;", "deployment . started    =    true ;", "listeners    =    new   ArrayList < DeploymentRepositoryListener >  ( this . listeners )  ;", "}", "for    ( final   DeploymentRepositoryListener   listener    :    listeners )     {", "try    {", "listener . deploymentStarted ( identifier ,    deployment . deployment )  ;", "}    catch    ( Throwable   t )     {", "EjbLogger . DEPLOYMENT _ LOGGER . deploymentAddListenerException ( t )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["startDeployment"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "final   List < DeploymentRepositoryListener >    listeners ;", "final   Set < DeploymentModuleIdentifier >    moduleIdentifiers ;", "synchronized ( this )     {", "moduleIdentifiers    =    new   HashSet <  >  ( this . modules . keySet (  )  )  ;", "listeners    =    new   ArrayList <  >  ( this . listeners )  ;", "suspended    =    true ;", "}", "for    ( final   DeploymentRepositoryListener   listener    :    listeners )     {", "for    ( DeploymentModuleIdentifier   moduleIdentifier    :    moduleIdentifiers )", "try    {", "listener . deploymentSuspended ( moduleIdentifier )  ;", "}    catch    ( Throwable   t )     {", "deploymentAddListenerException ( t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["suspend"], "fileName": "org.jboss.as.ejb3.deployment.DeploymentRepository"}, {"methodBody": ["METHOD_START", "{", "return   applicationSecurityDomain . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationSecurityDomain"], "fileName": "org.jboss.as.ejb3.deployment.EJBSecurityDomainService"}, {"methodBody": ["METHOD_START", "{", "return   applicationSecurityDomain ;", "}", "METHOD_END"], "methodName": ["getApplicationSecurityDomainInjector"], "fileName": "org.jboss.as.ejb3.deployment.EJBSecurityDomainService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentClassLoader ;", "}", "METHOD_END"], "methodName": ["getDeploymentClassLoader"], "fileName": "org.jboss.as.ejb3.deployment.EjbDeploymentInformation"}, {"methodBody": ["METHOD_START", "{", "return   ejbComponent . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getEjbComponent"], "fileName": "org.jboss.as.ejb3.deployment.EjbDeploymentInformation"}, {"methodBody": ["METHOD_START", "{", "return   ejbName ;", "}", "METHOD_END"], "methodName": ["getEjbName"], "fileName": "org.jboss.as.ejb3.deployment.EjbDeploymentInformation"}, {"methodBody": ["METHOD_START", "{", "return   iorFactory . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getIorFactory"], "fileName": "org.jboss.as.ejb3.deployment.EjbDeploymentInformation"}, {"methodBody": ["METHOD_START", "{", "final   InjectedValue < ComponentView >    value    =    componentViews . get ( name )  ;", "if    ( value    =  =    null )     {", "throw   new   IllegalArguException (  (  (  \" View    \"     +    name )     +     \"    was   not   found \"  )  )  ;", "}", "return   value . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getView"], "fileName": "org.jboss.as.ejb3.deployment.EjbDeploymentInformation"}, {"methodBody": ["METHOD_START", "{", "return   componentViews . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["getViewNames"], "fileName": "org.jboss.as.ejb3.deployment.EjbDeploymentInformation"}, {"methodBody": ["METHOD_START", "{", "return   this . remoteViewClassNames . contains ( viewClassName )  ;", "}", "METHOD_END"], "methodName": ["isRemoteView"], "fileName": "org.jboss.as.ejb3.deployment.EjbDeploymentInformation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( role    =  =    null )     |  |     ( role . trim (  )  . isEmpty (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . stringParamCannotBeNullOrEmpty (  \" Security   role \"  )  ;", "}", "this . applicaLevelSecurityRoles . add ( role )  ;", "}", "METHOD_END"], "methodName": ["addSecurityRole"], "fileName": "org.jboss.as.ejb3.deployment.EjbJarDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . eeModuleDescription ;", "}", "METHOD_END"], "methodName": ["getEEModuleDescription"], "fileName": "org.jboss.as.ejb3.deployment.EjbJarDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . applicationLevelSecurityRoles )  ;", "}", "METHOD_END"], "methodName": ["getSecurityRoles"], "fileName": "org.jboss.as.ejb3.deployment.EjbJarDescription"}, {"methodBody": ["METHOD_START", "{", "return   eeModuleDescription . hasComponent ( componentName )  ;", "}", "METHOD_END"], "methodName": ["hasComponent"], "fileName": "org.jboss.as.ejb3.deployment.EjbJarDescription"}, {"methodBody": ["METHOD_START", "{", "return   war ;", "}", "METHOD_END"], "methodName": ["isWar"], "fileName": "org.jboss.as.ejb3.deployment.EjbJarDescription"}, {"methodBody": ["METHOD_START", "{", "return   deploymentRepository ;", "}", "METHOD_END"], "methodName": ["getDeploymentRepository"], "fileName": "org.jboss.as.ejb3.deployment.ModuleDeployment"}, {"methodBody": ["METHOD_START", "{", "return   ejbs ;", "}", "METHOD_END"], "methodName": ["getEjbs"], "fileName": "org.jboss.as.ejb3.deployment.ModuleDeployment"}, {"methodBody": ["METHOD_START", "{", "return   identifier ;", "}", "METHOD_END"], "methodName": ["getIdentifier"], "fileName": "org.jboss.as.ejb3.deployment.ModuleDeployment"}, {"methodBody": ["METHOD_START", "{", "EjbJarDescription   ejbJarDescription    =    deploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ JAR _ DESCRIPTION )  ;", "final   EEApplicationClasses   applicationClassesDescription    =    deploymentUnit . getAttachment ( EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "if    ( ejbJarDescription    =  =    null )     {", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "ejbJarDescription    =    new   EjbJarDescription ( moduleDescription ,    deploymentUnit . getName (  )  . endsWith (  \"  . war \"  )  )  ;", "deploymentUnit . putAttachment ( EjbDeploymentAttachmentKeys . EJB _ JAR _ DESCRIPTION ,    ejbJarDescription )  ;", "}", "return   ejbJarDescription ;", "}", "METHOD_END"], "methodName": ["getEjbJarDescription"], "fileName": "org.jboss.as.ejb3.deployment.processors.AbstractDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   EjbJarMetaData   ejbJarMetaData    =    deploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ JAR _ METADATA )  ;", "if    ( ejbJarMetaData    =  =    null )     {", "return ;", "}", "final    . SimpleSet < String >    annotatedEJBs ;", "if    ( appclient )     {", "final   List < ComponentDescription >    additionalComponents    =    deploymentUnit . getAttachmentList ( ADDITIONAL _ RESOLVABLE _ COMPONENTS )  ;", "annotatedEJBs    =    new    . SimpleSet < String >  (  )     {", "@ Override", "public   boolean   contains ( Object   o )     {", "for    ( final   ComponentDescription   component    :    additionalComponents )     {", "if    ( component . getComponentName (  )  . equals ( o )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "}  ;", "} else    {", "final   EjbJarDescription   ejbJarDescription    =     . getEjbJarDescription ( deploymentUnit )  ;", "annotatedEJBs    =    new    . SimpleSet < String >  (  )     {", "@ Override", "public   boolean   contains ( Object   o )     {", "return   ejbJarDescription . hasComponent (  (  ( String )     ( o )  )  )  ;", "}", "}  ;", "}", "final   EnterpriseBeansMetaData   ejbs    =    ejbJarMetaData . getEnterpriseBeans (  )  ;", "if    (  ( ejbs    !  =    null )     &  &     (  !  ( ejbs . isEmpty (  )  )  )  )     {", "for    ( final   EnterpriseBeanMetaData   ejb    :    ejbs )     {", "final   String   beanName    =    ejb . getName (  )  ;", "if    ( annotatedEJBs . contains ( beanName )  )     {", "continue ;", "}", "processBeanMetaData ( deploymentUnit ,    ejb )  ;", "}", "}", "EjbDeploymentMarker . mark ( deploymentUnit )  ;", "}", "METHOD_END"], "methodName": ["processDeploymentDescriptor"], "fileName": "org.jboss.as.ejb3.deployment.processors.AbstractDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    ( MetadataCompleteMarker . isMetadataComplete ( deploymentUnit )  )     {", "return ;", "}", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "final   List < AnnotationInstance >    aroundInvokes    =    index . getAnnotations (  . AROUND _ TIMEOUT _ ANNOTATION _ NAME )  ;", "for    ( AnnotationInstance   annotation    :    aroundInvokes )     {", "processAroundInvoke ( annotation . target (  )  ,    eeModuleDescription )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ejb3.deployment.processors.AroundTimeoutAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( target   instanceof   MethodInfo )  )     {", "throw   EjbLogger . ROOT _ LOGGER . annotationApplicableOnlyForMethods (  . AROUND _ TIMEOUT _ ANNOTATION _ NAME . toString (  )  )  ;", "}", "final   MethodInfo   methodInfo    =    MethodInfo . class . cast ( target )  ;", "final   ClassInfo   classInfo    =    methodInfo . declaringClass (  )  ;", "final   EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "validateArgumentType ( classInfo ,    methodInfo )  ;", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder ( classDescription . getInterceptorClassDescription (  )  )  ;", "builder . setAroundTimeout ( MethodIdentifier . getIdentifier ( Object . class ,    methodInfo . name (  )  ,    InvocationContext . class )  )  ;", "classDescription . setInterceptorClassDescription ( builder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["processAroundInvoke"], "fileName": "org.jboss.as.ejb3.deployment.processors.AroundTimeoutAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Type [  ]    args    =    methodInfo . args (  )  ;", "switch    ( args . length )     {", "case    0     :", "throw   EjbLogger . ROOT _ LOGGER . aMethodExpectedWithInvocationContextParam ( methodInfo . name (  )  ,    classInfo . toString (  )  )  ;", "case    1     :", "if    (  !  ( InvocationContext . class . getName (  )  . equals ( args [  0  ]  . name (  )  . toString (  )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . aMethodExpectedWithInvocationContextParam ( methodInfo . name (  )  ,    classInfo . toString (  )  )  ;", "}", "break ;", "default    :", "throw   EjbLogger . ROOT _ LOGGER . aMethodExpectedWithInvocationContextParam ( methodInfo . name (  )  ,    classInfo . toString (  )  )  ;", "}", "if    (  !  ( methodInfo . returnType (  )  . name (  )  . toString (  )  . equals ( Object . class . getName (  )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . aMethodMustReturnObjectType ( methodInfo . name (  )  ,    classInfo . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateArgumentType"], "fileName": "org.jboss.as.ejb3.deployment.processors.AroundTimeoutAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Set < Class <  ?  >  >    potentialBusinessInterfaces    =    BusinessViewAnnotationProcessor . getPotentialBusinessInterfaces ( sessionBeanClass )  ;", "final   Set < Class <  ?  >  >    businessInterfaces    =    new   HashSet < Class <  ?  >  >  (  )  ;", "for    ( Class <  ?  >    iface    :    potentialBusinessInterfaces )     {", "if    (  ( iface . getAnnotation ( annotation )  )     !  =    null )     {", "businessInterfaces . add ( iface )  ;", "}", "}", "return   businessInterfaces ;", "}", "METHOD_END"], "methodName": ["getBusinessInterfacesFromInterfaceAnnotations"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   cl . loadClass ( className )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   DUnitProcessingException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getEjbClass"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Local   localViewAnnotation    =    sessionBeanClass . getAnnotation ( Local . class )  ;", "if    ( localViewAnnotation    =  =    null )     {", "Collection < Class <  ?  >  >    interfaces    =     . getBusinessInterfacesFromInterfaceAnnotations ( sessionBeanClass ,    Local . class )  ;", "if    (  !  ( interfaces . isEmpty (  )  )  )     {", "return   interfaces ;", "}", "return   Collections . emptySet (  )  ;", "}", "Class <  ?  >  [  ]    localViews    =    localViewAnnotation . value (  )  ;", "if    (  ( localViews    =  =    null )     |  |     (  ( localViews . length )     =  =     0  )  )     {", "Set < Class <  ?  >  >    interfaces    =     . getPotentialBusinessInterfaces ( sessionBeanClass )  ;", "if    (  (  ( interfaces . size (  )  )     !  =     1  )     &  &     (  !  ( isEjbVersionGreaterThanOrEqualTo 3  2  ( deploymentUnit )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . beanWithLocalAnnotationImplementsMoreThanOneInterface ( sessionBeanClass )  ;", "}", "return   interfaces ;", "}", "return   Arrays . asList ( localViews )  ;", "}", "METHOD_END"], "methodName": ["getLocalBusinessInterfaces"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "return   ViewInterfaces . getPotentialViewInterfaces ( sessionBeanClass )  ;", "}", "METHOD_END"], "methodName": ["getPotentialBusinessInterfaces"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Remote   remoteViewAnnotation    =    sessionBeanClass . getAnnotation ( Remote . class )  ;", "if    ( remoteViewAnnotation    =  =    null )     {", "Collection < Class <  ?  >  >    interfaces    =     . getBusinessInterfacesFromInterfaceAnnotations ( sessionBeanClass ,    Remote . class )  ;", "if    (  !  ( interfaces . isEmpty (  )  )  )     {", "return   interfaces ;", "}", "return   Collections . emptySet (  )  ;", "}", "Class <  ?  >  [  ]    remoteViews    =    remoteViewAnnotation . value (  )  ;", "if    (  ( remoteViews    =  =    null )     |  |     (  ( remoteViews . length )     =  =     0  )  )     {", "Set < Class <  ?  >  >    interfaces    =     . getPotentialBusinessInterfaces ( sessionBeanClass )  ;", "if    (  (  ( interfaces . size (  )  )     !  =     1  )     &  &     (  !  ( isEjbVersionGreaterThanOrEqualTo 3  2  ( deploymentUnit )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . beanWithRemoteAnnotationImplementsMoreThanOneInterface ( sessionBeanClass )  ;", "}", "return   interfaces ;", "}", "return   Arrays . asList ( remoteViews )  ;", "}", "METHOD_END"], "methodName": ["getRemoteBusinessInterfaces"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( sessionBeanClass . getAnnotation ( LocalBean . class )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasNoInterfaceView"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( sessionBeanComponentDescription . getViews (  )  )     =  =    null )     |  |     ( sessionBeanComponentDescription . getViews (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasNoViews"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( deploymentUnit    =  =    null )     {", "return   false ;", "}", "final   EjbJarMetaData   ejbJarMetaData    =    deploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ JAR _ METADATA )  ;", "if    ( ejbJarMetaData    =  =    null )     {", "return   true ;", "}", "return   ejbJarMetaData . isVersionGreaterThanOrEqual ( EJB _  3  _  2  )  ;", "}", "METHOD_END"], "methodName": ["isEjbVersionGreaterThanOrEqualTo32"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Collection < Class <  ?  >  >    remoteBusinessInterfaces    =    this . getRemoteBusinessInterfaces ( deploymentUnit ,    sessionBeanClass )  ;", "if    (  ( remoteBusinessInterfaces    !  =    null )     &  &     (  !  ( remoteBusinessInterfaces . isEmpty (  )  )  )  )     {", "verifyViewMethodsNotDeclaredFinal ( sessionBeanClass ,    remoteBusinessInterfaces )  ;", "sessionBeanComponentDescription . addRemoteBusinessInterfaceViews ( this . toString ( remoteBusinessInterfaces )  )  ;", "}", "Collection < Class <  ?  >  >    localBusinessInterfaces    =    this . getLocalBusinessInterfaces ( deploymentUnit ,    sessionBeanClass )  ;", "if    (  ( localBusinessInterfaces    !  =    null )     &  &     (  !  ( localBusinessInterfaces . isEmpty (  )  )  )  )     {", "verifyViewMethodsNotDeclaredFinal ( sessionBeanClass ,    localBusinessInterfaces )  ;", "sessionBeanComponentDescription . addLocalBusinessInterfaceViews ( this . toString ( localBusinessInterfaces )  )  ;", "}", "if    (  . hasNoInterfaceView ( sessionBeanClass )  )     {", "verifyNoInterfaceViewMethodsNotDeclaredFinal ( sessionBeanClass )  ;", "sessionBeanComponentDescription . addNoInterfaceView (  )  ;", "}", "if    (  . hasNoViews ( sessionBeanComponentDescription )  )     {", "final   Set < Class <  ?  >  >    potentialBusinessInterfaces    =     . getPotentialBusinessInterfaces ( sessionBeanClass )  ;", "if    ( potentialBusinessInterfaces . isEmpty (  )  )     {", "verifyNoInterfaceViewMethodsNotDeclaredFinal ( sessionBeanClass )  ;", "sessionBeanComponentDescription . addNoInterfaceView (  )  ;", "} else", "if    (  ( potentialBusinessInterfaces . size (  )  )     =  =     1  )     {", "sessionBeanComponentDescription . addLocalBusinessInterfaceViews ( potentialBusinessInterfaces . iterator (  )  . next (  )  . getName (  )  )  ;", "} else", "if    ( isEjbVersionGreaterThanOrEqualTo 3  2  ( deploymentUnit )  )     {", "sessionBeanComponentDescription . addLocalBusinessInterfaceViews ( toString ( potentialBusinessInterfaces )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processViewAnnotations"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Collection < String >    classNames    =    new   ArrayList < String >  ( classes . size (  )  )  ;", "for    ( Class <  ?  >    klass    :    classes )     {", "classNames . add ( klass . getName (  )  )  ;", "}", "return   classNames ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   beanMethod    :    sessionBeanClass . getMethods (  )  )     {", "if    (  (  (  !  ( beanMethod . getDeclaringClass (  )  . equals ( Object . class )  )  )     &  &     ( Modifier . isPublic ( beanMethod . getModifiers (  )  )  )  )     &  &     ( Modifier . isFinal ( beanMethod . getModifiers (  )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . bMethodDeclaredFinal ( beanMethod . getName (  )  ,    sessionBeanClass . getName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["verifyNoInterfaceViewMethodsNotDeclaredFinal"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    ifce    :    businessInterfaces )     {", "for    ( Method   ifceMethod    :    ifce . getMethods (  )  )     {", "try    {", "final   Method   beanMethod    =    sessionBeanClass . getMethod ( ifceMethod . getName (  )  ,    ifceMethod . getParameterTypes (  )  )  ;", "if    ( Modifier . isFinal ( beanMethod . getModifiers (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . bMethodDeclaredFinal ( beanMethod . getName (  )  ,    sessionBeanClass . getName (  )  )  ;", "}", "}    catch    ( NoSuchMethodException   e )     {", "Assert . unreachableCode (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["verifyViewMethodsNotDeclaredFinal"], "fileName": "org.jboss.as.ejb3.deployment.processors.BusinessViewAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( description . isPassivationApplicable (  )  )  )", "return   FactoryBuilderService . DEFAULT _ PASSIVATION _ DISABLED _ CACHE _ SERVICE _ NAME ;", "Info   cache    =    description . get (  )  ;", "return   cache    !  =    null    ?    FactoryBuilderService . getServiceName ( cache . getName (  )  )     :    FactoryBuilderService . DEFAULT _ CACHE _ SERVICE _ NAME ;", "}", "METHOD_END"], "methodName": ["getCacheFactoryBuilderServiceName"], "fileName": "org.jboss.as.ejb3.deployment.processors.CacheDependenciesProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "return ;", "}", "final   ServiceName   profileServiceName    =    deploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ REMOTING _ PROFILE _ SERVICE _ NAME )  ;", "final   DiscoveryService   discoveryService    =    new   DiscoveryService (  )  ;", "final   ServiceName   discoveryServiceName    =    DiscoveryService . BASE _ NAME . append ( deploymentUnit . getName (  )  )  ;", "final   ServiceBuilder < Discovery >    builder    =    phaseContext . getServiceTarget (  )  . addService ( discoveryServiceName ,    discoveryService )  ;", "Injector < DiscoveryProvider >    providerInjector    =    discoveryService . getDiscoveryProviderInjector (  )  ;", "new   RemoteEJBDiscoveryConfigurator (  )  . configure ( providerInjector :  : inject ,     (    registryProvider )     -  >     {", "}  )  ;", "if    ( profileServiceName    !  =    null )", "builder . addDependency ( profileServiceName ,    remote . RemotingProfileService . class ,    new   Injector < remote . RemotingProfileService >  (  )     {", "Injector < DiscoveryProvider >    providerInjector    =    discoveryService . getDiscoveryProviderInjector (  )  ;", "public   void   inject ( final   remote . RemotingProfileService   value )    throws   InjectionException    {", "providerInjector . inject ( new   StaticDiscoveryProvider ( value . getServiceUrls (  )  )  )  ;", "}", "public   void   uninject (  )     {", "providerInjector . uninject (  )  ;", "}", "}  )  ;", "final   EJBClientDescriptorMetaData   ejbClientDescriptorMetaData    =    deploymentUnit . getAttachment ( EJB _ CLIENT _ METADATA )  ;", "final   boolean   useLocalReceiver    =     ( ejbClientDescriptorMetaData    =  =    null )     |  |     (  ( ejbClientDescriptorMetaData . isLocalReceiverExcluded (  )  )     !  =     ( Boolean . TRUE )  )  ;", "if    ( useLocalReceiver    &  &     (  !  ( appClient )  )  )     {", "builder . addDependency ( AssociationService . SERVICE _ NAME ,    AssociationService . class ,    new   Injector < AssociationService >  (  )     {", "Injector < DiscoveryProvider >    providerInjector    =    discoveryService . getDiscoveryProviderInjector (  )  ;", "public   void   inject ( final   AssociationService   value )    throws   InjectionException    {", "providerInjector . inject ( value . getLocalDiscoveryProvider (  )  )  ;", "}", "public   void   uninject (  )     {", "providerInjector . uninject (  )  ;", "}", "}  )  ;", "}", "builder . install (  )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ejb3.deployment.processors.DiscoveryRegistrationProcessor"}, {"methodBody": ["METHOD_START", "{", "return   providerInjectors . injector (  )  ;", "}", "METHOD_END"], "methodName": ["getDiscoveryProviderInjector"], "fileName": "org.jboss.as.ejb3.deployment.processors.DiscoveryService"}, {"methodBody": ["METHOD_START", "{", "return   discovery ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ejb3.deployment.processors.DiscoveryService"}, {"methodBody": ["METHOD_START", "{", "discovery    =    Discovery . create ( providerInjectors . getValue (  )  . toArray ( DiscoveryService . NO _ PROVIDERS )  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.deployment.processors.DiscoveryService"}, {"methodBody": ["METHOD_START", "{", "discovery    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ejb3.deployment.processors.DiscoveryService"}, {"methodBody": ["METHOD_START", "{", "final   boolean   profileDefined    =     ( ejbClientDescriptorMetaData . getProfile (  )  )     !  =    null ;", "final   boolean   receiversDefined    =     (  (  !  ( ejbClientDescriptorMetaData . getRemotingReceiverConfigurations (  )  . isEmpty (  )  )  )     |  |     (  ( ejbClientDescriptorMetaData . isLocalReceiverExcluded (  )  )     !  =    null )  )     |  |     (  ( ejbClientDescriptorMetaData . isLocalReceiverPassByValue (  )  )     !  =    null )  ;", "if    ( profileDefined    &  &    receiversDefined )     {", "throw   EjbLogger . ROOT _ LOGGER . profileAndRemotingEjbReceiversUsedTogether (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkDescriptorConfiguration"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBClientDescriptorMetaDataProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( securityRealmName    !  =    null )     &  &     (  !  ( securityRealmName . trim (  )  . isEmpty (  )  )  )  )     {", "final   ServiceName   securityRealmServiceName    =    ServiceUtil . createServiceName ( securityRealmName )  ;", "final   ServiceController < SecurityRealm >    securityRealmController    =     (  ( ServiceController < SecurityRealm >  )     ( serviceRegistry . getService ( securityRealmServiceName )  )  )  ;", "if    ( securityRealmController    !  =    null )     {", "final   SecurityRealm   securityRealm    =    securityRealmController . getValue (  )  ;", "final   CallbackHandlerFacy   cbhFacy ;", "if    (  (  ( securityRealm    !  =    null )     &  &     (  ( cbhFacy    =    securityRealm . getSecretCallbackHandlerFacy (  )  )     !  =    null )  )     &  &     ( userName    !  =    null )  )     {", "return   cbhFacy . getCallbackHandler ( userName )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCallbackHandler"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBClientDescriptorMetaDataProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Enumeration < URL >    resources    =    classLoader . getResources (  \" META - INF / services / ejb . client . EJBClientInterceptor \"  )  ;", "final   ArrayList < EJBClientInterceptor >    interceptors    =    new   ArrayList <  >  (  )  ;", "if    ( resources . hasMoreElements (  )  )     {", "do    {", "final   URL   url    =    resources . nextElement (  )  ;", "try    ( InputStream   st    =    url . openStream (  )  )     {", "try    ( InputStreamReader   isr    =    new   InputStreamReader ( st ,    StandardCharsets . UTF _  8  )  )     {", "try    ( BufferedReader   r    =    new   BufferedReader ( isr )  )     {", "String   line ;", "while    (  ( line    =    r . readLine (  )  )     !  =    null )     {", "line    =    line . trim (  )  ;", "if    (  ( line . isEmpty (  )  )     |  |     (  ( line . charAt (  0  )  )     =  =     '  #  '  )  )     {", "continue ;", "}", "try    {", "final   EJBClientInterceptor   interceptor    =    Class . forName ( line ,    true ,    classLoader )  . asSubclass ( EJBClientInterceptor . class )  . getConstructor (  )  . newInstance (  )  ;", "interceptors . add ( interceptor )  ;", "}    catch    ( Exception   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToCreateEJBClientInterceptor ( e ,    line )  ;", "}", "}", "}", "}", "}", "}    while    ( resources . hasMoreElements (  )     )  ;", "}", "return   interceptors ;", "}    catch    ( IOException   e )     {", "return   Collections . emptyList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getClassPathInterceptors"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBClientDescriptorMetaDataProcessor"}, {"methodBody": ["METHOD_START", "{", "final   OptionMap . Builder   optionMapBuilder    =    OptionMap . builder (  )  ;", "if    ( properties    !  =    null )", "for    ( final   String   propertyName    :    properties . stringPropertyNames (  )  )     {", "try    {", "final   Option <  ?  >    option    =    fromString ( propertyName ,    classLoader )  ;", "optionMapBuilder . parse ( option ,    properties . getProperty ( propertyName )  ,    classLoader )  ;", "}    catch    ( IllegalArgumentException   e )     {", "logging . EjbLogger . DEPLOYMENT _ LOGGER . failedToCreateOptionForProperty ( propertyName ,    e . getMessage (  )  )  ;", "}", "}", "return   optionMapBuilder . getMap (  )  ;", "}", "METHOD_END"], "methodName": ["getOptionMapFromProperties"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBClientDescriptorMetaDataProcessor"}, {"methodBody": ["METHOD_START", "{", "final   EjbJarDescription   ejbJarDescription    =    AbstractDeploymentUnitProcessor . getEjbJarDescription ( deploymentUnit )  ;", "if    ( appclient )     {", "deploymentUnit . addToAttachmentList ( ADDITIONAL _ RESOLVABLE _ COMPONENTS ,    beanDescription )  ;", "} else    {", "ejbJarDescription . getEEModuleDescription (  )  . addComponent ( beanDescription )  ;", "}", "}", "METHOD_END"], "methodName": ["addComponent"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   EnterpriseBeansMetaData   enterpriseBeansMetaData    =    EJBComponentDescriptionFactory . getEnterpriseBeansMetaData ( deploymentUnit )  ;", "if    ( enterpriseBeansMetaData    =  =    null )", "return   null ;", "return   expectedType . cast ( enterpriseBeansMetaData . get ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getEnterpriseBeanMetaData"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   EjbJarMetaData   jarMetaData    =    deploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ JAR _ METADATA )  ;", "if    ( jarMetaData    =  =    null )", "return   null ;", "return   jarMetaData . getEnterpriseBeans (  )  ;", "}", "METHOD_END"], "methodName": ["getEnterpriseBeansMetaData"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "return   override    !  =    null    ?    override    :    original ;", "}", "METHOD_END"], "methodName": ["override"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "this . defaultSecurityDomainName    =    securityDomainName ;", "}", "METHOD_END"], "methodName": ["setDefaultSecurityDomainName"], "fileName": "org.jboss.as.ejb3.deployment.processors.EJBDefaultSecurityDomainProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   DeploymentUnit   parentDeploymentUnit    =    deploymentUnit . getParent (  )  ;", "if    ( parentDeploymentUnit    !  =    null )     {", "return   DiscoveryService . BASE _ NAME . append ( parentDeploymentUnit . getName (  )  )  ;", "} else    {", "return   DiscoveryService . BASE _ NAME . append ( deploymentUnit . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDiscoveryServiceName"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbClientContextSetupProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   DeploymentUnit   parentDeploymentUnit    =    deploymentUnit . getParent (  )  ;", "ServiceName   serviceName ;", "if    ( parentDeploymentUnit    !  =    null )     {", "serviceName    =    parentDeploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ CLIENT _ CONTEXT _ SERVICE _ NAME )  ;", "} else    {", "serviceName    =    deploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ CLIENT _ CONTEXT _ SERVICE _ NAME )  ;", "}", "if    ( serviceName    !  =    null )     {", "return   serviceName ;", "}", "return   EJBrvice . DEFAULT _ SERVICE _ NAME ;", "}", "METHOD_END"], "methodName": ["getEJBClientContextServiceName"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbClientContextSetupProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   DeploymentUnit   parentDeploymentUnit    =    deploymentUnit . getParent (  )  ;", "if    ( parentDeploymentUnit    !  =    null )     {", "return   parentDeploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ REMOTING _ PROFILE _ SERVICE _ NAME )  ;", "} else    {", "return   deploymentUnit . getAttachment ( EjbDeploymentAttachmentKeys . EJB _ REMOTING _ PROFILE _ SERVICE _ NAME )  ;", "}", "}", "METHOD_END"], "methodName": ["getProfileServiceName"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbClientContextSetupProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEResourceReferenceProcessorRegistry   registry    =    deploymentUnit . getAttachment ( RESOURCE _ REFERENCE _ PROCESSOR _ REGISTRY )  ;", "registry . registerResourceReferenceProcessor ( new   EjbContextResourceReferenceProcessor ( EJBContext . class )  )  ;", "registry . registerResourceReferenceProcessor ( new   EjbContextResourceReferenceProcessor ( SessionContext . class )  )  ;", "registry . registerResourceReferenceProcessor ( new   EjbContextResourceReferenceProcessor ( EntityContext . class )  )  ;", "registry . registerResourceReferenceProcessor ( new   EjbContextResourceReferenceProcessor ( MessageDrivenContext . class )  )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "final   Collection < ComponentDescription >    componentConfigurations    =    eeModuleDescription . getComponentDescriptions (  )  ;", "if    (  ( componentConfigurations    =  =    null )     |  |     ( componentConfigurations . isEmpty (  )  )  )     {", "return ;", "}", "for    ( ComponentDescription   componentConfiguration    :    componentConfigurations )     {", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "if    ( index    !  =    null )     {", "processComponentConfig ( componentConfiguration )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbContextJndiBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( componentDescription   instanceof   EJBComponentDescription )  )     {", "return ;", "}", "if    (  ( componentDescription . getNamingMode (  )  )     !  =     ( ComponentNamingMode . CREATE )  )     {", "final   EEModuleDescription   moduleDescription    =    componentDescription . getModuleDescription (  )  ;", "final   BindingConfiguration   ejbContextBinding    =    new   BindingConfiguration (  \" java : module / EJBContext \"  ,     . directEjbContextReferenceSource )  ;", "moduleDescription . getBindingConfigurations (  )  . add ( ejbContextBinding )  ;", "} else    {", "final   BindingConfiguration   ejbContextBinding    =    new   BindingConfiguration (  \" java : comp / EJBContext \"  ,     . directEjbContextReferenceSource )  ;", "componentDescription . getBindingConfigurations (  )  . add ( ejbContextBinding )  ;", "}", "}", "METHOD_END"], "methodName": ["processComponentConfig"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbContextJndiBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "componentDescription . setExposedViaIiop ( true )  ;", "final   EJBViewDescription   remoteView    =    componentDescription . getEjbRemoteView (  )  ;", "final   Class <  ?  >    remoteClass ;", "try    {", "remoteClass    =    ClassLoadingUtils . loadClass ( remoteView . getViewClassName (  )  ,    module )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLoadViewClassForComponent ( e ,    componentDescription . getEJBClassName (  )  )  ;", "}", "final   EJBViewDescription   homeView    =    componentDescription . getEjbHomeView (  )  ;", "final   Class <  ?  >    homeClass ;", "try    {", "homeClass    =    ClassLoadingUtils . loadClass ( homeView . getViewClassName (  )  ,    module )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLoadViewClassForComponent ( e ,    componentDescription . getEJBClassName (  )  )  ;", "}", "componentDescription . getEjbHomeView (  )  . getConfigurators (  )  . add ( new    . IIOPInterceptorViewConfigurator (  )  )  ;", "componentDescription . getEjbRemoteView (  )  . getConfigurators (  )  . add ( new    . IIOPInterceptorViewConfigurator (  )  )  ;", "final   InterfaceAnalysis   remoteInterfaceAnalysis ;", "try    {", "remoteInterfaceAnalysis    =    InterfaceAnalysis . getInterfaceAnalysis ( remoteClass )  ;", "}    catch    ( RMIIIOPViolationException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToAnalyzeRemoteInterface ( e ,    componentDescription . getComponentName (  )  )  ;", "}", "final   Map < String ,    SkeletonStrategy >    beanMethodMap    =    new   HashMap < String ,    SkeletonStrategy >  (  )  ;", "final   AttributeAnalysis [  ]    remoteAttrs    =    remoteInterfaceAnalysis . getAttributes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( remoteAttrs . length )  ;    i +  +  )     {", "final   OperationAnalysis   op    =    remoteAttrs [ i ]  . getAccessorAnalysis (  )  ;", "if    ( op    !  =    null )     {", "EjbLogger . DEPLOYMENT _ LOGGER . debugf (  \"              % s % n                                                 % s \"  ,    op . getJavaName (  )  ,    op . getIDLName (  )  )  ;", "final   Method   method    =    translateMethod ( deploymentReflectionIndex ,    op )  ;", "beanMethodMap . put ( op . getIDLName (  )  ,    new   SkeletonStrategy ( method )  )  ;", "final   OperationAnalysis   setop    =    remoteAttrs [ i ]  . getMutatorAnalysis (  )  ;", "if    ( setop    !  =    null )     {", "EjbLogger . DEPLOYMENT _ LOGGER . debugf (  \"              % s % n                                                 % s \"  ,    setop . getJavaName (  )  ,    setop . getIDLName (  )  )  ;", "final   Method   realSetmethod    =    translateMethod ( deploymentReflectionIndex ,    setop )  ;", "beanMethodMap . put ( setop . getIDLName (  )  ,    new   SkeletonStrategy ( realSetmethod )  )  ;", "}", "}", "}", "final   OperationAnalysis [  ]    ops    =    remoteInterfaceAnalysis . getOperations (  )  ;", "for    ( int   i    =     0  ;    i    <     ( ops . length )  ;    i +  +  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . debugf (  \"              % s % n                                                 % s \"  ,    ops [ i ]  . getJavaName (  )  ,    ops [ i ]  . getIDLName (  )  )  ;", "beanMethodMap . put ( ops [ i ]  . getIDLName (  )  ,    new   SkeletonStrategy ( translateMethod ( deploymentReflectionIndex ,    ops [ i ]  )  )  )  ;", "}", "final   String [  ]    beanRepositoryIds    =    remoteInterfaceAnalysis . getAllTypeIds (  )  ;", "final   InterfaceAnalysis   homeInterfaceAnalysis ;", "try    {", "homeInterfaceAnalysis    =    InterfaceAnalysis . getInterfaceAnalysis ( homeClass )  ;", "}    catch    ( RMIIIOPViolationException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToAnalyzeRemoteInterface ( e ,    componentDescription . getComponentName (  )  )  ;", "}", "final   Map < String ,    SkeletonStrategy >    homeMethodMap    =    new   HashMap < String ,    SkeletonStrategy >  (  )  ;", "final   AttributeAnalysis [  ]    attrs    =    homeInterfaceAnalysis . getAttributes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( attrs . length )  ;    i +  +  )     {", "final   OperationAnalysis   op    =    attrs [ i ]  . getAccessorAnalysis (  )  ;", "if    ( op    !  =    null )     {", "EjbLogger . DEPLOYMENT _ LOGGER . debugf (  \"              % s % n                                                 % s \"  ,    op . getJavaName (  )  ,    op . getIDLName (  )  )  ;", "homeMethodMap . put ( op . getIDLName (  )  ,    new   SkeletonStrategy ( translateMethod ( deploymentReflectionIndex ,    op )  )  )  ;", "final   OperationAnalysis   setop    =    attrs [ i ]  . getMutatorAnalysis (  )  ;", "if    ( setop    !  =    null )     {", "EjbLogger . DEPLOYMENT _ LOGGER . debugf (  \"              % s % n                                                 % s \"  ,    setop . getJavaName (  )  ,    setop . getIDLName (  )  )  ;", "homeMethodMap . put ( setop . getIDLName (  )  ,    new   SkeletonStrategy ( translateMethod ( deploymentReflectionIndex ,    setop )  )  )  ;", "}", "}", "}", "final   OperationAnalysis [  ]    homeops    =    homeInterfaceAnalysis . getOperations (  )  ;", "for    ( int   i    =     0  ;    i    <     ( homeops . length )  ;    i +  +  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . debugf (  \"              % s % n                                                 % s \"  ,    homeops [ i ]  . getJavaName (  )  ,    homeops [ i ]  . getIDLName (  )  )  ;", "homeMethodMap . put ( homeops [ i ]  . getIDLName (  )  ,    new   SkeletonStrategy ( translateMethod ( deploymentReflectionIndex ,    homeops [ i ]  )  )  )  ;", "}", "final   String [  ]    homeRepositoryIds    =    homeInterfaceAnalysis . getAllTypeIds (  )  ;", "final   EjbIIOPService   service    =    new   EjbIIOPService ( beanMethodMap ,    beanRepositoryIds ,    homeMethodMap ,    homeRepositoryIds ,    settingsService . isUseQualifiedName (  )  ,    iiopMetaData ,    module )  ;", "final   ServiceBuilder < EjbIIOPService >    builder    =    serviceTarget . addService ( componentDescription . getServiceName (  )  . append ( EjbIIOPService . SERVICE _ NAME )  ,    service )  ;", "builder . addDependency ( componentDescription . getCreateServiceName (  )  ,    EJBComponent . class ,    service . getEjbComponentInjectedValue (  )  )  ;", "builder . addDependency ( homeView . getServiceName (  )  ,    ComponentView . class ,    service . getHomeView (  )  )  ;", "builder . addDependency ( remoteView . getServiceName (  )  ,    ComponentView . class ,    service . getRemoteView (  )  )  ;", "builder . addDependency ( SERVICE _ NAME ,    ORB . class ,    service . getOrb (  )  )  ;", "builder . addDependency ( POARegistry . SERVICE _ NAME ,    POARegistry . class ,    service . getPoaRegistry (  )  )  ;", "builder . addDependency ( INTERFACE _ REPOSITORY _ SERVICE _ NAME ,    POA . class ,    service . getIrPoa (  )  )  ;", "builder . addDependency ( CorbaNamingService . SERVICE _ NAME ,    NamingContextExt . class ,    service . getCorbaNamingContext (  )  )  ;", "builder . addDependency ( IORSecConfigMetaDataService . SERVICE _ NAME ,    IORSecurityConfigMetaData . class ,    service . getIORSecConfigMetaDataInjectedValue (  )  )  ;", "builder . addDependency ( JBOSS _ SERVICE _ MODULE _ LOADER ,    ServiceModuleLoader . class ,    service . getServiceModuleLoaderInjectedValue (  )  )  ;", "builder . addDependency ( JBOSS _ TXN _ ARJUNA _ TRANSACTION _ MANAGER ,    TransactionManagerService . class ,    service . getTransactionManagerInjectedValue (  )  )  ;", "builder . install (  )  ;", "}", "METHOD_END"], "methodName": ["processEjb"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbIIOPDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Method   nonMethod    =    op . getMethod (  )  ;", "return   ReflectionIndex . getClassIndex ( nonMethod . getDeclaringClass (  )  )  . getMethod ( nonMethod )  ;", "}", "METHOD_END"], "methodName": ["translateMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbIIOPDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( a    =  =    b )     |  |     (  ( a    !  =    null )     &  &     ( a . equals ( b )  )  )  ;", "}", "METHOD_END"], "methodName": ["eq"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )     {", "return   true ;", "}", "if    (  !  ( o   instanceof    )  )     {", "return   false ;", "}", "resolve (  )  ;", "if    (  ( error )     !  =    null )     {", "return   false ;", "}", "final      other    =     (  (  )     ( o )  )  ;", "return    (  . eq ( typeName ,    other . typeName )  )     &  &     (  . eq ( resolvedViewName ,    other . resolvedViewName )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbInjectionSource"}, {"methodBody": ["METHOD_START", "{", "resolve (  )  ;", "if    (  ( error )     !  =    null )     {", "throw   new   DeploymentUnitProcessingException ( error )  ;", "}", "if    (  ( remoteFactory )     !  =    null )     {", "injector . inject ( remoteFactory )  ;", "} else", "if    (  !  ( appclient )  )     {", "serviceBuilder . addDependency ( resolvedViewName ,    e . component . ComponentView . class ,    new   e . component . ViewManagedReferenceFactory . Injector ( injector )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   EEApplicationDescription   applicationDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ DESCRIPTION )  ;", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   Set < ViewDescription >    componentsForViewName ;", "if    (  ( beanName )     !  =    null )     {", "componentsForViewName    =    applicationDescription . getComponents ( beanName ,    typeName ,    deploymentRoot . getRoot (  )  )  ;", "} else    {", "componentsForViewName    =    applicationDescription . getComponentsForViewName ( typeName ,    deploymentRoot . getRoot (  )  )  ;", "}", "return   componentsForViewName ;", "}", "METHOD_END"], "methodName": ["getViews"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   typeName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( resolved )  )     {", "synchronized ( this )     {", "if    (  !  ( resolved )  )     {", "final   Set < ViewDescription >    views    =    getViews (  )  ;", "final   Set < EJBViewDescription >    ejbsForViewName    =    new   HashSet < EJBViewDescription >  (  )  ;", "for    ( final   ViewDescription   view    :    views )     {", "if    ( view   instanceof   EJBViewDescription )     {", "final   MethodIntf   viewType    =     (  ( EJBViewDescription )     ( view )  )  . getMethodIntf (  )  ;", "if    (  ( viewType    =  =     ( MethodIntf . SERVICE _ ENDPOINT )  )     |  |     ( viewType    =  =     ( MethodIntf . MESSAGE _ ENDPOINT )  )  )     {", "continue ;", "}", "ejbsForViewName . add (  (  ( EJBViewDescription )     ( view )  )  )  ;", "}", "}", "if    ( ejbsForViewName . isEmpty (  )  )     {", "if    (  ( beanName )     =  =    null )     {", "error    =    EjbLogger . ROOT _ LOGGER . ejbNotFound ( typeName ,    bindingName )  ;", "} else    {", "error    =    EjbLogger . ROOT _ LOGGER . ejbNotFound ( typeName ,    beanName ,    bindingName )  ;", "}", "} else", "if    (  ( ejbsForViewName . size (  )  )     >     1  )     {", "if    (  ( beanName )     =  =    null )     {", "error    =    EjbLogger . ROOT _ LOGGER . moreThanOneEjbFound ( typeName ,    bindingName ,    ejbsForViewName )  ;", "} else    {", "error    =    EjbLogger . ROOT _ LOGGER . moreThanOneEjbFound ( typeName ,    beanName ,    bindingName ,    ejbsForViewName )  ;", "}", "} else    {", "final   EJBViewDescription   description    =    ejbsForViewName . iterator (  )  . next (  )  ;", "final   EJBViewDescription   ejbViewDescription    =     (  ( EJBViewDescription )     ( description )  )  ;", "if    (  (  ( ejbViewDescription . getMethodIntf (  )  )     =  =     ( MethodIntf . REMOTE )  )     |  |     (  ( ejbViewDescription . getMethodIntf (  )  )     =  =     ( MethodIntf . HOME )  )  )     {", "final   component . EJBComponentDescription   componentDescription    =     (  ( component . EJBComponentDescription )     ( description . getComponentDescription (  )  )  )  ;", "final   EEModuleDescription   moduleDescription    =    componentDescription . getModuleDescription (  )  ;", "final   String   earApplicationName    =    moduleDescription . getEarApplicationName (  )  ;", "final   Value < ClassLoader >    viewClassLoader    =    new   Value < ClassLoader >  (  )     {", "@ Override", "public   ClassLoader   getValue (  )    throws   IllegalArgumentException ,    IllegalStateException    {", "final   Module   module    =    deploymentUnit . getAttachment ( Attachments . MODULE )  ;", "return   module    !  =    null    ?    module . getClassLoader (  )     :    null ;", "}", "}  ;", "remoteFactory    =    new   remote . RemoteViewManagedReferenceFactory ( earApplicationName ,    moduleDescription . getModuleName (  )  ,    moduleDescription . getDistinctName (  )  ,    componentDescription . getComponentName (  )  ,    description . getViewClassName (  )  ,    componentDescription . isStateful (  )  ,    viewClassLoader ,    appclient )  ;", "}", "final   ServiceName   serviceName    =    description . getServiceName (  )  ;", "resolvedViewName    =    serviceName ;", "}", "resolved    =    true ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbInjectionSource"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    AbstractMetaDataParser <  ?  >  >    parsers    =    new   HashMap < String ,    AbstractMetaDataParser <  ?  >  >  (  )  ;", "for    ( ClusteringSchema   schema    :    EnumSet . allOf ( ClusteringSchema . class )  )     {", "parsers . put ( schema . getNamespaceUri (  )  ,    new   EJBBoundClusteringMetaDataParser ( schema )  )  ;", "}", "parsers . put ( EJBBoundSecurityMetaDataParser . LEGACY _ NAMESPACE _ URI ,    EJBBoundSecurityMetaDataParser . INSTANCE )  ;", "parsers . put ( EJBBoundSecurityMetaDataParser . NAMESPACE _ URI _  1  _  0  ,    EJBBoundSecurityMetaDataParser . INSTANCE )  ;", "parsers . put ( EJBBoundSecurityMetaDataParser 1  1  . NAMESPACE _ URI _  1  _  1  ,    EJBBoundSecurityMetaDataParser 1  1  . INSTANCE )  ;", "parsers . put ( SecurityRoleMetaDataParser . LEGACY _ NAMESPACE _ URI ,    SecurityRoleMetaDataParser . INSTANCE )  ;", "parsers . put ( SecurityRoleMetaDataParser . NAMESPACE _ URI ,    SecurityRoleMetaDataParser . INSTANCE )  ;", "parsers . put ( EJBBoundResourceAdapterBindingMetaDataParser . LEGACY _ NAMESPACE _ URI ,    EJBBoundResourceAdapterBindingMetaDataParser . INSTANCE )  ;", "parsers . put ( EJBBoundResourceAdapterBindingMetaDataParser . NAMESPACE _ URI ,    EJBBoundResourceAdapterBindingMetaDataParser . INSTANCE )  ;", "parsers . put ( EJBBoundMdbDeliveryMetaDataParser . NAMESPACE _ URI _  1  _  0  ,    EJBBoundMdbDeliveryMetaDataParser . INSTANCE )  ;", "parsers . put ( EJBBoundMdbDeliveryMetaDataParser 1  1  . NAMESPACE _ URI _  1  _  1  ,    EJBBoundMdbDeliveryMetaDataParser 1  1  . INSTANCE )  ;", "parsers . put (  \" urn : iiop \"  ,    new   IIOPMetaDataParser (  )  )  ;", "parsers . put (  \" urn : iiop :  1  .  0  \"  ,    new   IIOPMetaDataParser (  )  )  ;", "parsers . put (  \" urn : trans - timeout \"  ,    new   TransactionTimeoutMetaDataParser (  )  )  ;", "parsers . put (  \" urn : trans - timeout :  1  .  0  \"  ,    new   TransactionTimeoutMetaDataParser (  )  )  ;", "parsers . put ( EJBBoundPoolParser . NAMESPACE _ URI ,    new   EJBBoundPoolParser (  )  )  ;", "parsers . put ( EJBBoundCacheParser . NAMESPACE _ URI ,    new   EJBBoundCacheParser (  )  )  ;", "parsers . put ( ContainerInterceptorsParser . NAMESPACE _ URI _  1  _  0  ,    ContainerInterceptorsParser . INSTANCE )  ;", "parsers . put ( TimerServiceMetaDataParser . NAMESPACE _ URI ,    TimerServiceMetaDataParser . INSTANCE )  ;", "return   parsers ;", "}", "METHOD_END"], "methodName": ["createJbossEjbJarParsers"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJarParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   descriptor ;", "if    (  . isWar ( deploymentRoot )  )     {", "descriptor    =    deploymentRoot . getChild (  (  (  (  . WEB _ INF )     +     \"  /  \"  )     +    descriptorName )  )  ;", "} else", "if    ( deploymentRoot . getName (  )  . toLowerCase ( ENGLISH )  . endsWith (  . JAR _ FILE _ EXTENSION )  )     {", "descriptor    =    deploymentRoot . getChild (  (  (  (  . META _ INF )     +     \"  /  \"  )     +    descriptorName )  )  ;", "} else    {", "return   null ;", "}", "if    (  ( descriptor    =  =    null )     |  |     (  !  ( descriptor . exists (  )  )  )  )     {", "return   null ;", "}", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJarParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( resolver )  ;", "XMLStreamReader   xmlReader    =    inputFactory . createXMLStreamReader ( stream )  ;", "return   xmlReader ;", "}    catch    ( XMLStreamException   xmlse )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToParse ( xmlse ,     (  \" ejb - jar . xml :     \"     +     ( eXml . getPathName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getXMLStreamReader"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJarParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "return   deploymentRoot . getName (  )  . toLowerCase ( Locale . ENGLISH )  . endsWith ( EjbJarParsingDeploymentUnitProcessor . WAR _ FILE _ EXTENSION )  ;", "}", "METHOD_END"], "methodName": ["isWar"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJarParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   file . openStream (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   ingException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJarParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   VirtualFile   alternateDescriptor    =    deploymentRoot . getAttachment ( ALTERNATE _ EJB _ DEPLOYMENT _ DESCRIPTOR )  ;", "final   VirtualFile   descriptor ;", "if    ( alternateDescriptor    !  =    null )     {", "descriptor    =    alternateDescriptor ;", "} else    {", "descriptor    =     . getDescriptor ( deploymentRoot . getRoot (  )  ,     . EJB _ JAR _ XML )  ;", "}", "if    ( descriptor    =  =    null )     {", "return   null ;", "}", "MetaDataElementParser . DTDInfo   dtdInfo    =    new   MetaDataElementParser . DTDInfo (  )  ;", "InputStream   stream    =     . open ( descriptor )  ;", "try    {", "XMLStreamReader   reader    =     . getXMLStreamReader ( stream ,    descriptor ,    dtdInfo )  ;", "EjbJarMetaData   ejbJarMetaData    =    EjbJarMetaDataParser . parse ( reader ,    dtdInfo ,    SpecDescriptorPropertyReplacement . propertyReplacer ( deploymentUnit )  )  ;", "return   ejbJarMetaData ;", "}    catch    ( XMLStreamException   xmlse )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToParse ( xmlse ,     (  \" ejb - jar . xml :     \"     +     ( descriptor . getPathName (  )  )  )  )  ;", "}    finally    {", "try    {", "stream . close (  )  ;", "}    catch    ( IOException   ioe )     {", "EjbLogger . DEPLOYMENT _ LOGGER . failToCloseFile ( ioe )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseEjbJarXml"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJarParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  . getRoot (  )  ;", "final   VirtualFile   descriptor    =     . getDescriptor ( deploymentRoot ,     . JBOSS _ EJB 3  _ XML )  ;", "if    ( descriptor    =  =    null )     {", "return   deploymentUnit . getAttachment ( EjbJarJBossAllParser . ATTACHMENT _ KEY )  ;", "}", "MetaDataElementParser . DTDInfo   dtdInfo    =    new   MetaDataElementParser . DTDInfo (  )  ;", "InputStream   stream    =     . open ( descriptor )  ;", "try    {", "XMLStreamReader   reader    =     . getXMLStreamReader ( stream ,    descriptor ,    dtdInfo )  ;", "final   JBossEjb 3 MetaDataParser   parser    =    new   JBossEjb 3 MetaDataParser (  . createJbossEjbJarParsers (  )  )  ;", "final   EjbJarMetaData   ejbJarMetaData    =    parser . parse ( reader ,    dtdInfo ,    JBossDescriptorPropertyReplacement . propertyReplacer ( deploymentUnit )  )  ;", "return   ejbJarMetaData ;", "}    catch    ( XMLStreamException   xmlse )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToParse ( xmlse ,     (  (  (  . JBOSS _ EJB 3  _ XML )     +     \"  :     \"  )     +     ( descriptor . getPathName (  )  )  )  )  ;", "}    finally    {", "try    {", "stream . close (  )  ;", "}    catch    ( IOException   ioe )     {", "EjbLogger . DEPLOYMENT _ LOGGER . failToCloseFile ( ioe )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseJBossEjb3Xml"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJarParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "jndiBindingsLogMessage . append (  \"  \\ t \"  )  ;", "jndiBindingsLogMessage . append ( jndiName )  ;", "jndiBindingsLogMessage . append ( System . lineSeparator (  )  )  ;", "}", "METHOD_END"], "methodName": ["logBinding"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJndiBindingsDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( appclient )     {", "registerRemote ( componentDescription ,    viewDescription ,    jndiName )  ;", "} else    {", "viewDescription . getNames (  )  . add ( jndiName )  ;", "}", "}", "METHOD_END"], "methodName": ["registerBinding"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJndiBindingsDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   EEModuleDescription   moduleDescription    =    componentDescription . getModuleDescription (  )  ;", "final   InjectedValue < ClassLoader >    viewClassLoader    =    new   InjectedValue < ClassLoader >  (  )  ;", "final   InjectedValue < ControlPoint >    controlPointInjectedValue    =    new   InjectedValue (  )  ;", "final   RemoteViewInjectionSource   delegate    =    new   RemoteViewInjectionSource ( null ,    moduleDescription . getEarApplicationName (  )  ,    moduleDescription . getModuleName (  )  ,    moduleDescription . getDistinctName (  )  ,    componentDescription . getComponentName (  )  ,    viewDescription . getViewClassName (  )  ,    componentDescription . isStateful (  )  ,    viewClassLoader ,    appclient )  ;", "final   ServiceName   depName    =    ControlPointService . serviceName (  (  ( deploymentUnit . getParent (  )  )     =  =    null    ?    deploymentUnit . getName (  )     :    deploymentUnit . getParent (  )  . getName (  )  )  ,     (  (  (  ( EJBComponentSuspend . ENTRY _ POINT _ NAME )     +     ( deploymentUnit . getName (  )  )  )     +     \"  .  \"  )     +     ( componentDescription . getComponentName (  )  )  )  )  ;", "componentDescription . getConfigurators (  )  . add (  (    context ,    description ,    configuration )     -  >     {", "viewClassLoader . setValue ( Values . immediateValue ( configuration . getModuleClassLoader (  )  )  )  ;", "configuration . getCreateDependencies (  )  . add (  (    serviceBuilder ,    service )     -  >    serviceBuilder . addDependency ( depName ,     . class ,    controlPointInjectedValue )  )  ;", "}  )  ;", "final   InjectionSource   is    =    new   InjectionSource (  )     {", "@ Override", "public   void   getResourceValue ( ResolutionContext   resolutionContext ,    ServiceBuilder <  ?  >    serviceBuilder ,    DeploymentPhaseContext   phaseContext ,    Injector < ManagedReferenceFactory >    injector )    throws   DeploymentUnitProcessingException    {", "final   InjectedValue < ManagedReferenceFactory >    delegateInjection    =    new   InjectedValue (  )  ;", "delegate . getResourceValue ( resolutionContext ,    serviceBuilder ,    phaseContext ,    delegateInjection )  ;", "injector . inject ( new   ManagedReferenceFactory (  )     {", "@ Override", "public   ManagedReference   getReference (  )     {", "ControlPoint   cp    =    controlPointInjectedValue . getValue (  )  ;", "try    {", "RunResult   res    =    cp . beginRequest (  )  ;", "if    ( res    !  =     ( RunResult . RUN )  )     {", "throw   EjbLogger . ROOT _ LOGGER . containerSuspended (  )  ;", "}", "try    {", "return   delegateInjection . getValue (  )  . getReference (  )  ;", "}    finally    {", "cp . requestComplete (  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  )  ;", "}", "}  ;", "moduleDescription . getBindingConfigurations (  )  . add ( new   BindingConfiguration ( jndiName ,    is )  )  ;", "}", "METHOD_END"], "methodName": ["registerControlPointBinding"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJndiBindingsDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   EEModuleDescription   moduleDescription    =    componentDescription . getModuleDescription (  )  ;", "final   InjectedValue < ClassLoader >    viewClassLoader    =    new   InjectedValue < ClassLoader >  (  )  ;", "moduleDescription . getBindingConfigurations (  )  . add ( new   BindingConfiguration ( jndiName ,    new   RemoteViewInjectionSource ( null ,    moduleDescription . getEarApplicationName (  )  ,    moduleDescription . getModuleName (  )  ,    moduleDescription . getDistinctName (  )  ,    componentDescription . getComponentName (  )  ,    viewDescription . getViewClassName (  )  ,    componentDescription . isStateful (  )  ,    viewClassLoader ,    appclient )  )  )  ;", "componentDescription . getConfigurators (  )  . add ( new   ComponentConfigurator (  )     {", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentDescription   description ,    ComponentConfiguration   configuration )    throws   ingException    {", "viewClassLoader . setValue ( Values . immediateValue ( configuration . getModuleClassLoader (  )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerRemoteBinding"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJndiBindingsDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Collection < ViewDescription >    views    =    sessionBean . getViews (  )  ;", "if    (  ( views    =  =    null )     |  |     ( views . isEmpty (  )  )  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . noJNDIBindingsForSessionBean ( sessionBean . getEJBName (  )  )  ;", "return ;", "}", "final   String   applicationName    =    sessionBean . getModuleDescription (  )  . getEarApplicationName (  )  ;", "final   String   distinctName    =    sessionBean . getModuleDescription (  )  . getDistinctName (  )  ;", "final   String   globalJNDIBaseName    =     (  (  (  \" java : global /  \"     +     ( applicationName    !  =    null    ?    applicationName    +     \"  /  \"     :     \"  \"  )  )     +     ( sessionBean . getModuleName (  )  )  )     +     \"  /  \"  )     +     ( sessionBean . getEJBName (  )  )  ;", "final   String   appJNDIBaseName    =     (  (  \" java : app /  \"     +     ( sessionBean . getModuleName (  )  )  )     +     \"  /  \"  )     +     ( sessionBean . getEJBName (  )  )  ;", "final   String   moduleJNDIBaseName    =     \" java : module /  \"     +     ( sessionBean . getEJBName (  )  )  ;", "final   String   remoteExportedJNDIBaseName    =     (  (  (  \" java : jboss / exported /  \"     +     ( applicationName    !  =    null    ?    applicationName    +     \"  /  \"     :     \"  \"  )  )     +     ( sessionBean . getModuleName (  )  )  )     +     \"  /  \"  )     +     ( sessionBean . getEJBName (  )  )  ;", "final   String   ejbNamespaceBindingBaseName    =     (  (  (  (  \" ejb :  \"     +     ( applicationName    !  =    null    ?    applicationName    +     \"  /  \"     :     \"  \"  )  )     +     ( sessionBean . getModuleName (  )  )  )     +     \"  /  \"  )     +     ( distinctName    !  =     \"  \"     ?    distinctName    +     \"  /  \"     :     \"  \"  )  )     +     ( sessionBean . getEJBName (  )  )  ;", "final   StringBuilder   jndiBindingsLogMessage    =    new   StringBuilder (  )  ;", "jndiBindingsLogMessage . append ( System . lineSeparator (  )  )  . append ( System . lineSeparator (  )  )  ;", "EJBViewDescription   ejbViewDescription    =    null ;", "for    ( ViewDescription   viewDescription    :    views )     {", "ejbViewDescription    =     (  ( EJBViewDescription )     ( viewDescription )  )  ;", "if    (  (  ( appclient )     &  &     (  ( ejbViewDescription . getMethodIntf (  )  )     !  =     ( MethodIntf . REMOTE )  )  )     &  &     (  ( ejbViewDescription . getMethodIntf (  )  )     !  =     ( MethodIntf . HOME )  )  )     {", "continue ;", "}", "if    (  !  ( ejbViewDescription . hasJNDIBindings (  )  )  )", "continue ;", "final   String   viewClassName    =    ejbViewDescription . getViewClassName (  )  ;", "final   String   globalJNDIName    =     ( globalJNDIBaseName    +     \"  !  \"  )     +    viewClassName ;", "registerBinding ( sessionBean ,    viewDescription ,    globalJNDIName )  ;", "logBinding ( jndiBindingsLogMessage ,    globalJNDIName )  ;", "final   String   appJNDIName    =     ( appJNDIBaseName    +     \"  !  \"  )     +    viewClassName ;", "registerBinding ( sessionBean ,    viewDescription ,    appJNDIName )  ;", "logBinding ( jndiBindingsLogMessage ,    appJNDIName )  ;", "final   String   moduleJNDIName    =     ( moduleJNDIBaseName    +     \"  !  \"  )     +    viewClassName ;", "registerBinding ( sessionBean ,    viewDescription ,    moduleJNDIName )  ;", "logBinding ( jndiBindingsLogMessage ,    moduleJNDIName )  ;", "if    (  (  ( ejbViewDescription . getMethodIntf (  )  )     =  =     ( MethodIntf . REMOTE )  )     |  |     (  ( ejbViewDescription . getMethodIntf (  )  )     =  =     ( MethodIntf . HOME )  )  )     {", "final   String   remoteJNDIName    =     ( remoteExportedJNDIBaseName    +     \"  !  \"  )     +    viewClassName ;", "if    ( RequestControllerActivationMarker . isRequestControllerEnabled ( d )  )     {", "registerControlPointBinding ( sessionBean ,    viewDescription ,    remoteJNDIName ,    d )  ;", "} else    {", "registerBinding ( sessionBean ,    viewDescription ,    remoteJNDIName )  ;", "}", "logBinding ( jndiBindingsLogMessage ,    remoteJNDIName )  ;", "}", "final   String   ejbNamespaceBindingName    =     ( sessionBean . isStateful (  )  )     ?     (  ( ejbNamespaceBindingBaseName    +     \"  !  \"  )     +    viewClassName )     +     \"  ? stateful \"     :     ( ejbNamespaceBindingBaseName    +     \"  !  \"  )     +    viewClassName ;", "logBinding ( jndiBindingsLogMessage ,    ejbNamespaceBindingName )  ;", "}", "if    (  ( views . size (  )  )     =  =     1  )     {", "final   EJBViewDescription   viewDescription    =     (  ( EJBViewDescription )     ( views . iterator (  )  . next (  )  )  )  ;", "if    ( ejbViewDescription . hasJNDIBindings (  )  )     {", "registerBinding ( sessionBean ,    viewDescription ,    globalJNDIBaseName )  ;", "logBinding ( jndiBindingsLogMessage ,    globalJNDIBaseName )  ;", "registerBinding ( sessionBean ,    viewDescription ,    appJNDIBaseName )  ;", "logBinding ( jndiBindingsLogMessage ,    appJNDIBaseName )  ;", "registerBinding ( sessionBean ,    viewDescription ,    moduleJNDIBaseName )  ;", "logBinding ( jndiBindingsLogMessage ,    moduleJNDIBaseName )  ;", "}", "}", "EjbLogger . DEPLOYMENT _ LOGGER . jndiBindings ( sessionBean . getEJBName (  )  ,    d ,    jndiBindingsLogMessage )  ;", "}", "METHOD_END"], "methodName": ["setupJNDIBindings"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbJndiBindingsDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "List < PathElement >    elements    =    new   ArrayList < PathElement >  (  )  ;", "if    (  ( d . getParent (  )  )     =  =    null )     {", "elements . add ( PathElement . pathElement ( DEPLOYMENT ,    d . getName (  )  )  )  ;", "} else    {", "elements . add ( PathElement . pathElement ( DEPLOYMENT ,    d . getParent (  )  . getName (  )  )  )  ;", "elements . add ( PathElement . pathElement ( SUBDEPLOYMENT ,    d . getName (  )  )  )  ;", "}", "elements . add ( PathElement . pathElement ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  )  ;", "elements . add ( PathElement . pathElement ( type . getResourceType (  )  ,    configuration . getComponentName (  )  )  )  ;", "return   PathAddress . pathAddress ( elements )  ;", "}", "METHOD_END"], "methodName": ["getComponentAddress"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbManagementDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   EJBComponentType   type    =    EJBComponentType . getComponentType ( configuration )  ;", "PathAddress   addr    =     . getComponentAddress ( type ,    configuration ,    deploymentUnit )  ;", "final   AbstractEJBComponentRuntimeHandler <  ?  >    handler    =    type . getRuntimeHandler (  )  ;", "handler . registerComponent ( addr ,    configuration . getComponentDescription (  )  . getStartServiceName (  )  )  ;", "deploymentUnit . addToAttachmentList ( EjbDeploymentAttachmentKeys . MANAGED _ COMPONENTS ,    new   InstalledComponent ( type ,    addr )  )  ;", "final   DeploymentResourceSupport   deploymentResourceSupport    =    deploymentUnit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "deploymentResourceSupport . getDeploymentSubModel ( EJB 3 Extension . SUBSYSTEM _ NAME ,    addr . getLastElement (  )  )  ;", "final   EJBComponentDescription   description    =     (  ( EJBComponentDescription )     ( configuration . getComponentDescription (  )  )  )  ;", "if    ( description . isTimerServiceRequired (  )  )     {", "final   PathAddress   timerServiceAddress    =    PathAddress . pathAddress ( addr . getLastElement (  )  ,    EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH )  ;", "final   TimerServiceResource   timerServiceResource    =     (  ( TimerServiceImpl )     ( description . getTimerService (  )  )  )  . getResource (  )  ;", "deploymentResourceSupport . registerDeploymentSubResource ( EJB 3 Extension . SUBSYSTEM _ NAME ,    timerServiceAddress ,    timerServiceResource )  ;", "}", "}", "METHOD_END"], "methodName": ["installManagementResource"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbManagementDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "component . getType (  )  . getRuntimeHandler (  )  . unregisterComponent ( component . getAddress (  )  )  ;", "Resource   root    =    d . getAttachment ( DeploymentModelUtils . DEPLOYMENT _ RESOURCE )  ;", "Resource   subResource    =    root . getChild ( component . getAddress (  )  . getParent (  )  . getLastElement (  )  )  ;", "if    ( subResource    !  =    null )     {", "Resource   componentResource    =    subResource . getChild ( component . getAddress (  )  . getLastElement (  )  )  ;", "if    ( componentResource    !  =    null )     {", "componentResource . removeChild ( EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["uninstallManagementResource"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbManagementDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( string    =  =    null )     |  |     ( string . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbRefProcessor"}, {"methodBody": ["METHOD_START", "{", "final   RemoteEnvironment   remoteEnvironment    =    environment . getEnvironment (  )  ;", "List < BindingConfiguration >    bindingDescriptions    =    new   ArrayList < BindingConfiguration >  (  )  ;", "EJBReferencesMetaData   ejbRefs    =    remoteEnvironment . getEjbReferences (  )  ;", "if    ( ejbRefs    !  =    null )     {", "for    ( EJBReferenceMetaData   ejbRef    :    ejbRefs )     {", "String   name    =    ejbRef . getEjbRefName (  )  ;", "String   ejbName    =    ejbRef . getLink (  )  ;", "String   lookup    =     (  ( ejbRef . getLookupName (  )  )     !  =    null )     ?    ejbRef . getLookupName (  )     :    ejbRef . getMappedName (  )  ;", "String   remoteInterface    =    ejbRef . getRemote (  )  ;", "String   home    =    ejbRef . getHome (  )  ;", "Class <  ?  >    remoteInterfaceType    =    null ;", "if    (  !  ( isEmpty ( home )  )  )     {", "try    {", "remoteInterfaceType    =    ClassLoadingUtils . loadClass ( home ,    Unit )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLoadViewClass ( e ,    home )  ;", "}", "} else", "if    (  !  ( isEmpty ( remoteInterface )  )  )     {", "try    {", "remoteInterfaceType    =    ClassLoadingUtils . loadClass ( remoteInterface ,    Unit )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLoadViewClass ( e ,    remoteInterface )  ;", "}", "}", "if    (  !  ( name . startsWith (  \" java :  \"  )  )  )     {", "name    =     ( environment . getDefaultContext (  )  )     +    name ;", "}", "LookupInjectionSource   injectionSource    =    new   LookupInjectionSource ( name )  ;", "remoteInterfaceType    =    processInjectionTargets ( resourceInjectionTarget ,    injectionSource ,    classLoader ,    ReflectionIndex ,    ejbRef ,    remoteInterfaceType )  ;", "final   BindingConfiguration   bindingConfiguration ;", "EjbInjectionSource   ejbInjectionSource    =    null ;", "if    (  !  ( isEmpty ( lookup )  )  )     {", "if    (  !  ( lookup . startsWith (  \" java :  \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EjbLookupInjectionSource ( lookup ,    remoteInterfaceType )  )  ;", "} else    {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   LookupInjectionSource ( lookup )  )  ;", "}", "} else    {", "if    ( remoteInterfaceType    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . couldNotDetermineEjbRefForInjectionTarget ( name ,    resourceInjectionTarget )  ;", "}", "if    (  !  ( isEmpty ( ejbName )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,     ( ejbInjectionSource    =    new   EjbInjectionSource ( ejbName ,    remoteInterfaceType . getName (  )  ,    name ,    Unit ,    appclient )  )  )  ;", "} else    {", "bindingConfiguration    =    new   BindingConfiguration ( name ,     ( ejbInjectionSource    =    new   EjbInjectionSource ( remoteInterfaceType . getName (  )  ,    name ,    Unit ,    appclient )  )  )  ;", "}", "}", "if    ( ejbInjectionSource    !  =    null )     {", "Unit . addToAttachmentList ( EjbDeploymentAttachmentKeys . EJB _ INJECTIONS ,    ejbInjectionSource )  ;", "}", "bindingDescriptions . add ( bindingConfiguration )  ;", "}", "}", "if    (  ( remoteEnvironment   instanceof   Environment )     &  &     (  !  ( appclient )  )  )     {", "EJBLocalReferencesMetaData   ejbLocalRefs    =     (  ( Environment )     ( remoteEnvironment )  )  . getEjbLocalReferences (  )  ;", "if    ( ejbLocalRefs    !  =    null )     {", "for    ( EJBLocalReferenceMetaData   ejbRef    :    ejbLocalRefs )     {", "String   name    =    ejbRef . getEjbRefName (  )  ;", "String   ejbName    =    ejbRef . getLink (  )  ;", "String   lookup    =     (  ( ejbRef . getLookupName (  )  )     !  =    null )     ?    ejbRef . getLookupName (  )     :    ejbRef . getMappedName (  )  ;", "String   localInterface    =    ejbRef . getLocal (  )  ;", "String   localHome    =    ejbRef . getLocalHome (  )  ;", "Class <  ?  >    localInterfaceType    =    null ;", "if    (  !  ( isEmpty ( localHome )  )  )     {", "try    {", "localInterfaceType    =    ClassLoadingUtils . loadClass ( localHome ,    Unit )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLoadViewClass ( e ,    localHome )  ;", "}", "} else", "if    (  !  ( isEmpty ( localInterface )  )  )     {", "try    {", "localInterfaceType    =    ClassLoadingUtils . loadClass ( localInterface ,    Unit )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLoadViewClass ( e ,    localInterface )  ;", "}", "}", "if    (  !  ( name . startsWith (  \" java :  \"  )  )  )     {", "name    =     ( environment . getDefaultContext (  )  )     +    name ;", "}", "LookupInjectionSource   injectionSource    =    new   LookupInjectionSource ( name )  ;", "localInterfaceType    =    processInjectionTargets ( resourceInjectionTarget ,    injectionSource ,    classLoader ,    ReflectionIndex ,    ejbRef ,    localInterfaceType )  ;", "if    ( localInterfaceType    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . couldNotDetermineEjbLocalRefForInjectionTarget ( name ,    resourceInjectionTarget )  ;", "}", "final   BindingConfiguration   bindingConfiguration ;", "EjbInjectionSource   ejbInjectionSource    =    null ;", "if    (  !  ( isEmpty ( lookup )  )  )     {", "if    (  !  ( lookup . startsWith (  \" java :  \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EjbLookupInjectionSource ( lookup ,    localInterfaceType )  )  ;", "} else    {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   LookupInjectionSource ( lookup )  )  ;", "}", "} else", "if    (  !  ( isEmpty ( ejbName )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,     ( ejbInjectionSource    =    new   EjbInjectionSource ( ejbName ,    localInterfaceType . getName (  )  ,    name ,    Unit ,    appclient )  )  )  ;", "} else    {", "bindingConfiguration    =    new   BindingConfiguration ( name ,     ( ejbInjectionSource    =    new   EjbInjectionSource ( localInterfaceType . getName (  )  ,    name ,    Unit ,    appclient )  )  )  ;", "}", "if    ( ejbInjectionSource    !  =    null )     {", "Unit . addToAttachmentList ( EjbDeploymentAttachmentKeys . EJB _ INJECTIONS ,    ejbInjectionSource )  ;", "}", "bindingDescriptions . add ( bindingConfiguration )  ;", "}", "}", "}", "return   bindingDescriptions ;", "}", "METHOD_END"], "methodName": ["processDescriptorEntries"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbRefProcessor"}, {"methodBody": ["METHOD_START", "{", "return   new   LookupInjectionSource ( localContextName ,    appclient )  ;", "}", "METHOD_END"], "methodName": ["createLookup"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbResourceInjectionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "final   List < AnnotationInstance >    resourceAnnotations    =    index . getAnnotations (  . EJB _ ANNOTATION _ NAME )  ;", "PropertyReplacer   propertyReplacer    =    EJBAnnotationPropertyReplacement . propertyReplacer ( deploymentUnit )  ;", "for    ( AnnotationInstance   annotation    :    resourceAnnotations )     {", "final   AnnotationTarget   annotationTarget    =    annotation . target (  )  ;", "final    . EJBResourceWrapper   annotationWrapper    =    new    . EJBResourceWrapper ( annotation ,    propertyReplacer )  ;", "if    ( annotationTarget   instanceof   FieldInfo )     {", "processField ( deploymentUnit ,    annotationWrapper ,     (  ( FieldInfo )     ( annotationTarget )  )  ,    moduleDescription )  ;", "} else", "if    ( annotationTarget   instanceof   MethodInfo )     {", "processMethod ( deploymentUnit ,    annotationWrapper ,     (  ( MethodInfo )     ( annotationTarget )  )  ,    moduleDescription )  ;", "} else", "if    ( annotationTarget   instanceof   ClassInfo )     {", "processClass ( deploymentUnit ,    annotationWrapper ,     (  ( ClassInfo )     ( annotationTarget )  )  ,    moduleDescription )  ;", "}", "}", "final   List < AnnotationInstance >    ejbsAnnotations    =    index . getAnnotations (  . EJBS _ ANNOTATION _ NAME )  ;", "for    ( AnnotationInstance   annotation    :    ejbsAnnotations )     {", "final   AnnotationTarget   annotationTarget    =    annotation . target (  )  ;", "if    ( annotationTarget   instanceof   ClassInfo )     {", "final   AnnotationValue   annotationValue    =    annotation . value (  )  ;", "final   AnnotationInstance [  ]    ejbAnnotations    =    annotationValue . asNestedArray (  )  ;", "for    ( AnnotationInstance   ejbAnnotation    :    ejbAnnotations )     {", "final    . EJBResourceWrapper   annotationWrapper    =    new    . EJBResourceWrapper ( ejbAnnotation ,    propertyReplacer )  ;", "processClass ( deploymentUnit ,    annotationWrapper ,     (  ( ClassInfo )     ( annotationTarget )  )  ,    moduleDescription )  ;", "}", "} else    {", "throw   EjbLogger . ROOT _ LOGGER . annotationOnlyAllowedOnClass ( EJBs . class . getName (  )  ,    annotation . target (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbResourceInjectionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( string    =  =    null )     |  |     ( string . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbResourceInjectionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( isEmpty ( lookup )  )  )     &  &     (  !  ( isEmpty ( beanName )  )  )  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . debugf (  \" Both   beanName    =     % s   and   lookup    =     % s   have   been   specified   in    @ EJB   annotation .    Lookup   will   be   given   preference .    Class :     % s \"  ,    beanName ,    lookup ,    classInfo . name (  )  )  ;", "}", "final   EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "final   InjectionSource   valueSource ;", "EjbInjectionSource   ejbInjectionSource    =    null ;", "if    (  !  ( isEmpty ( lookup )  )  )     {", "if    (  !  ( lookup . startsWith (  \" java :  \"  )  )  )     {", "valueSource    =    new   EjbLookupInjectionSource ( lookup ,     ( targetDescription    =  =    null    ?    null    :    targetDescription . getDeclaredValueClassName (  )  )  )  ;", "} else    {", "valueSource    =    createLookup ( lookup ,    appclient )  ;", "}", "} else", "if    (  !  ( isEmpty ( beanName )  )  )     {", "valueSource    =    ejbInjectionSource    =    new   EjbInjectionSource ( beanName ,    beanInterface ,    localContextName ,    deploymentUnit ,    appclient )  ;", "} else    {", "valueSource    =    ejbInjectionSource    =    new   EjbInjectionSource ( beanInterface ,    localContextName ,    deploymentUnit ,    appclient )  ;", "}", "if    ( ejbInjectionSource    !  =    null )     {", "deploymentUnit . addToAttachmentList ( EjbDeploymentAttachmentKeys . EJB _ INJECTIONS ,    ejbInjectionSource )  ;", "}", "final   Configuration   injectionConfiguration    =     ( targetDescription    !  =    null )     ?    new   Configuration ( targetDescription ,    createLookup ( localContextName ,    appclient )  )     :    null ;", "final   BindingConfiguration   bindingConfiguration    =    new   BindingConfiguration ( localContextName ,    valueSource )  ;", "classDescription . getBindingConfigurations (  )  . add ( bindingConfiguration )  ;", "if    ( injectionConfiguration    !  =    null )     {", "classDescription . add ( injectionConfiguration )  ;", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbResourceInjectionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( isEmpty ( annotation . name (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . nameAttributeRequiredForEJBOnClass ( classInfo . toString (  )  )  ;", "}", "if    ( isEmpty ( annotation . beanInterface (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . beanInterfaceAttributeRequiredForEJBOnClass ( classInfo . toString (  )  )  ;", "}", "process ( deploymentUnit ,    annotation . beanInterface (  )  ,    annotation . beanName (  )  ,    annotation . lookup (  )  ,    classInfo ,    null ,    annotation . name (  )  ,    eeModuleDescription )  ;", "}", "METHOD_END"], "methodName": ["processClass"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbResourceInjectionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   fieldName    =    fieldInfo . name (  )  ;", "final   String   fieldType    =    fieldInfo . type (  )  . name (  )  . toString (  )  ;", "final   InjectionTarget   targetDescription    =    new   e . component . FieldInjectionTarget ( fieldInfo . declaringClass (  )  . name (  )  . toString (  )  ,    fieldName ,    fieldType )  ;", "final   String   localContextName    =     ( isEmpty ( annotation . name (  )  )  )     ?     (  ( fieldInfo . declaringClass (  )  . name (  )  . toString (  )  )     +     \"  /  \"  )     +     ( fieldInfo . name (  )  )     :    annotation . name (  )  ;", "final   String   beanInterfaceType    =     (  ( isEmpty ( annotation . beanInterface (  )  )  )     |  |     ( annotation . beanInterface (  )  . equals ( Object . class . getName (  )  )  )  )     ?    fieldType    :    annotation . beanInterface (  )  ;", "process ( deploymentUnit ,    beanInterfaceType ,    annotation . beanName (  )  ,    annotation . lookup (  )  ,    fieldInfo . declaringClass (  )  ,    targetDescription ,    localContextName ,    eeModuleDescription )  ;", "}", "METHOD_END"], "methodName": ["processField"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbResourceInjectionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   methodName    =    methodInfo . name (  )  ;", "if    (  (  !  ( methodName . startsWith (  \" set \"  )  )  )     |  |     (  ( methodInfo . args (  )  . length )     !  =     1  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . onlySetterMethodsAllowedToHaveEJBAnnotation ( methodInfo )  ;", "}", "final   String   methodParamType    =    methodInfo . args (  )  [  0  ]  . name (  )  . toString (  )  ;", "final   InjectionTarget   targetDescription    =    new   e . component . MethodInjectionTarget ( methodInfo . declaringClass (  )  . name (  )  . toString (  )  ,    methodName ,    methodParamType )  ;", "final   String   localContextName    =     ( isEmpty ( annotation . name (  )  )  )     ?     (  (  ( methodInfo . declaringClass (  )  . name (  )  . toString (  )  )     +     \"  /  \"  )     +     ( methodName . substring (  3  ,     4  )  . toLowerCase ( Locale . ENGLISH )  )  )     +     ( methodName . substring (  4  )  )     :    annotation . name (  )  ;", "final   String   beanInterfaceType    =     (  ( isEmpty ( annotation . beanInterface (  )  )  )     |  |     ( annotation . beanInterface (  )  . equals ( Object . class . getName (  )  )  )  )     ?    methodParamType    :    annotation . beanInterface (  )  ;", "process ( deploymentUnit ,    beanInterfaceType ,    annotation . beanName (  )  ,    annotation . lookup (  )  ,    methodInfo . declaringClass (  )  ,    targetDescription ,    localContextName ,    eeModuleDescription )  ;", "}", "METHOD_END"], "methodName": ["processMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.EjbResourceInjectionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   orbServiceName    =    contextServiceName . append (  \" ORB \"  )  ;", "final   BinderService   orbService    =    new   BinderService (  \" ORB \"  )  ;", "serviceTarget . addService ( orbServiceName ,    orbService )  . addDependency ( SERVICE _ NAME ,    ORB . class ,    new   naming . ManagedReferenceInjector < ORB >  ( orbService . getManagedObjectInjector (  )  )  )  . addDependency ( contextServiceName ,    ServiceBasedNamingStore . class ,    orbService . getNamingStoreInjector (  )  )  . install (  )  ;", "final   ServiceName   handleDelegateServiceName    =    contextServiceName . append (  \" HandleDelegate \"  )  ;", "final   BinderService   handleDelegateBindingService    =    new   BinderService (  \" HandleDelegate \"  )  ;", "handleDelegateBindingService . getManagedObjectInjector (  )  . inject ( new   naming . ValueManagedReferenceFactory ( new   ImmediateValue ( new   HandleDelegateImpl ( module . getClassLoader (  )  )  )  )  )  ;", "serviceTarget . addService ( handleDelegateServiceName ,    handleDelegateBindingService )  . addDependency ( contextServiceName ,    ServiceBasedNamingStore . class ,    handleDelegateBindingService . getNamingStoreInjector (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["bindService"], "fileName": "org.jboss.as.ejb3.deployment.processors.IIOPJndiBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    interfaces    =    beanClass . getInterfaces (  )  ;", "if    (  ( interfaces . length )     =  =     0  )     {", "return   true ;", "}", "List < Class <  ?  >  >    implementedInterfaces    =    new   ArrayList < Class <  ?  >  >  ( ArrayList ( interfaces )  )  ;", "List < Class <  ?  >  >    filteredInterfaces    =    this . filterInterfaces ( implementedInterfaces )  ;", "return   filteredInterfaces . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["exposesNoInterfaceView"], "fileName": "org.jboss.as.ejb3.deployment.processors.ImplicitLocalViewProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( interfaces    =  =    null )     {", "return   null ;", "}", "List < Class <  ?  >  >    filteredInterfaces    =    new   ArrayList < Class <  ?  >  >  (  )  ;", "for    ( Class <  ?  >    intf    :    interfaces )     {", "if    (  (  ( intf . equals ( Serializable . class )  )     |  |     ( intf . equals ( Externalizable . class )  )  )     |  |     ( intf . getName (  )  . startsWith (  \" \"  )  )  )     {", "continue ;", "}", "filteredInterfaces . add ( intf )  ;", "}", "return   filteredInterfaces ;", "}", "METHOD_END"], "methodName": ["filterInterfaces"], "fileName": "org.jboss.as.ejb3.deployment.processors.ImplicitLocalViewProcessor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    interfaces    =    beanClass . getInterfaces (  )  ;", "if    (  ( interfaces . length )     =  =     0  )     {", "return   null ;", "}", "List < Class <  ?  >  >    implementedInterfaces    =    new   ArrayList < Class <  ?  >  >  ( ArrayList ( interfaces )  )  ;", "List < Class <  ?  >  >    filteredInterfaces    =    this . filterInterfaces ( implementedInterfaces )  ;", "if    (  ( filteredInterfaces . isEmpty (  )  )     |  |     (  ( filteredInterfaces . size (  )  )     >     1  )  )     {", "return   null ;", "}", "return   filteredInterfaces . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultLocalView"], "fileName": "org.jboss.as.ejb3.deployment.processors.ImplicitLocalViewProcessor"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append (  \" clustered \"  ,     \" singleton \"  ,     \" dependency \"  )  ;", "}", "METHOD_END"], "methodName": ["createClusteredSingletonDemanderServiceName"], "fileName": "org.jboss.as.ejb3.deployment.processors.MdbDeliveryDependenciesProcessor"}, {"methodBody": ["METHOD_START", "{", "final   short   flags    =    mdbClass . flags (  )  ;", "final   String   className    =    mdbClass . name (  )  . toString (  )  ;", "if    ( Modifier . isInterface ( flags )  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . mdbClassCannotBeAnInterface ( className )  ;", "return   false ;", "}", "if    (  (  (  !  ( Modifier . isPublic ( flags )  )  )     |  |     ( Modifier . isAbstract ( flags )  )  )     |  |     ( Modifier . isFinal ( flags )  )  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . mdbClassMustBePublicNonAbstractNonFinal ( className )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["assertMDBClassValidity"], "fileName": "org.jboss.as.ejb3.deployment.processors.MessageDrivenComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   Properties   props    =    new   Properties (  )  ;", "final   AnnotationValue   activationConfig    =    mBeanAnnotation . value (  \" activationConfig \"  )  ;", "if    ( activationConfig    =  =    null )", "return   props ;", "for    ( final   AnnotationInstance   propAnnotation    :    activationConfig . asNestedArray (  )  )     {", "String   propertyName    =    propAnnotation . value (  \" propertyName \"  )  . asString (  )  ;", "String   propertyValue    =    propAnnotation . value (  \" propertyValue \"  )  . asString (  )  ;", "props . put ( propertyReplacer . replaceProperties ( propertyName )  ,    propertyReplacer . replaceProperties ( propertyValue )  )  ;", "}", "return   props ;", "}", "METHOD_END"], "methodName": ["getActivationConfigProperties"], "fileName": "org.jboss.as.ejb3.deployment.processors.MessageDrivenComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   Properties   activationConfigProps    =    new   Properties (  )  ;", "if    (  ( activationConfig    =  =    null )     |  |     (  ( activationConfig . getActivationConfigProperties (  )  )     =  =    null )  )     {", "return   activationConfigProps ;", "}", "final   ActivationConfigPropertiesMetaData   activationConfigPropertiesMetaData    =    activationConfig . getActivationConfigProperties (  )  ;", "for    ( ActivationConfigPropertyMetaData   activationConfigProp    :    activationConfigPropertiesMetaData )     {", "if    ( activationConfigProp    =  =    null )     {", "continue ;", "}", "final   String   propName    =    activationConfigProp . getActivationConfigPropertyName (  )  ;", "final   String   propValue    =    activationConfigProp . getValue (  )  ;", "if    ( propName    !  =    null )     {", "activationConfigProps . put ( propName ,    propValue )  ;", "}", "}", "return   activationConfigProps ;", "}", "METHOD_END"], "methodName": ["getActivationConfigProperties"], "fileName": "org.jboss.as.ejb3.deployment.processors.MessageDrivenComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( appclient )     {", "return    \" n / a \"  ;", "}", "final   ServiceController < DefaultResourceAdapterService >    serviceController    =     (  ( ServiceController < DefaultResourceAdapterService >  )     ( serviceRegistry . getRequiredService ( DefaultResourceAdapterService . DEFAULT _ RA _ NAME _ SERVICE _ NAME )  )  )  ;", "return   serviceController . getValue (  )  . getDefaultResourceAdapterName (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultResourceAdapterName"], "fileName": "org.jboss.as.ejb3.deployment.processors.MessageDrivenComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   AnnotationValue   value    =    messageBeanAnnotation . value (  \" messageListenerInterface \"  )  ;", "if    ( value    !  =    null )", "return   value . asClass (  )  . name (  )  . toString (  )  ;", "final   ClassInfo   beanClass    =     (  ( ClassInfo )     ( messageBeanAnnotation . target (  )  )  )  ;", "final   Set < DotName >    interfaces    =    new   HashSet < DotName >  ( ViewInterfaces . getPotentialViewInterfaces ( beanClass )  )  ;", "DotName   superClassDotName    =    beanClass . superName (  )  ;", "while    (  (  ( interfaces . isEmpty (  )  )     &  &     ( superClassDotName    !  =    null )  )     &  &     (  !  ( superClassDotName . toString (  )  . equals ( Object . class . getName (  )  )  )  )  )     {", "final   ClassInfo   superClass    =    compositeIndex . getClassByName ( superClassDotName )  ;", "if    ( superClass    =  =    null )     {", "break ;", "}", "interfaces . addAll ( ViewInterfaces . getPotentialViewInterfaces ( superClass )  )  ;", "superClassDotName    =    superClass . superName (  )  ;", "}", "if    (  ( interfaces . size (  )  )     !  =     1  )", "throw   logging . EjbLogger . ROOT _ LOGGER . mdbDoesNotImplementNorSpecifyMessageListener ( beanClass )  ;", "return   interfaces . iterator (  )  . next (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMessageListenerInterface"], "fileName": "org.jboss.as.ejb3.deployment.processors.MessageDrivenComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( messageBeanAnnotations . isEmpty (  )  )", "return ;", "final   EjbJarDescription   ejbJarDescription    =    AbstractDeploymentUnitProcessor . getEjbJarDescription ( deploymentUnit )  ;", "final   PropertyReplacer   propertyReplacer    =    EJBAnnotationPropertyReplacement . propertyReplacer ( deploymentUnit )  ;", "final   ServiceName   deploymentUnitServiceName    =    deploymentUnit . getServiceName (  )  ;", "DeploymentDescriptorEnvironment   deploymentDescriptorEnvironment    =    null ;", "for    ( final   AnnotationInstance   messageBeanAnnotation    :    messageBeanAnnotations )     {", "final   AnnotationTarget   target    =    messageBeanAnnotation . target (  )  ;", "final   ClassInfo   beanClassInfo    =     (  ( ClassInfo )     ( target )  )  ;", "if    (  !  ( assertMDBClassValidity ( beanClassInfo )  )  )     {", "continue ;", "}", "final   String   ejbName    =    beanClassInfo . name (  )  . local (  )  ;", "final   AnnotationValue   nameValue    =    messageBeanAnnotation . value (  \" name \"  )  ;", "final   String   beanName    =     (  ( nameValue    =  =    null )     |  |     ( nameValue . asString (  )  . isEmpty (  )  )  )     ?    ejbName    :    propertyReplacer . replaceProperties ( nameValue . asString (  )  )  ;", "final   MessageDrivenBeanMetaData   beanMetaData    =    EJBComponentDescriptionFactory . getEnterpriseBeanMetaData ( deploymentUnit ,    beanName ,    MessageDrivenBeanMetaData . class )  ;", "final   String   beanClassName ;", "final   String   messageListenerInterfaceName ;", "final   Properties   activationConfigProperties    =    getActivationConfigProperties ( messageBeanAnnotation ,    propertyReplacer )  ;", "final   String   messagingType ;", "if    ( beanMetaData    !  =    null )     {", "beanClassName    =    EJBComponentDescriptionFactory . override ( beanClassInfo . name (  )  . toString (  )  ,    beanMetaData . getEjbClass (  )  )  ;", "deploymentDescriptorEnvironment    =    new   DeploymentDescriptorEnvironment (  \" java : comp / env /  \"  ,    beanMetaData )  ;", "if    ( beanMetaData   instanceof   MessageDrivenBeanMetaData )     {", "final   MessageDrivenBeanMetaData   mdb    =     (  ( MessageDrivenBeanMetaData )     ( beanMetaData )  )  ;", "messagingType    =    mdb . getMessagingType (  )  ;", "final   ActivationConfigMetaData   activationConfigMetaData    =    mdb . getActivationConfig (  )  ;", "if    ( activationConfigMetaData    !  =    null )     {", "final   ActivationConfigPropertiesMetaData   propertiesMetaData    =    activationConfigMetaData . getActivationConfigProperties (  )  ;", "if    ( propertiesMetaData    !  =    null )     {", "for    ( final   ActivationConfigPropertyMetaData   propertyMetaData    :    propertiesMetaData )     {", "activationConfigProperties . put ( propertyMetaData . getKey (  )  ,    propertyMetaData . getValue (  )  )  ;", "}", "}", "}", "} else", "if    ( beanMetaData   instanceof   JBossGenericBeanMetaData )     {", "final   JBossGenericBeanMetaData   mdb    =     (  ( JBossGenericBeanMetaData )     ( beanMetaData )  )  ;", "messagingType    =    mdb . getMessagingType (  )  ;", "final   ActivationConfigMetaData   activationConfigMetaData    =    mdb . getActivationConfig (  )  ;", "if    ( activationConfigMetaData    !  =    null )     {", "final   ActivationConfigPropertiesMetaData   propertiesMetaData    =    activationConfigMetaData . getActivationConfigProperties (  )  ;", "if    ( propertiesMetaData    !  =    null )     {", "for    ( final   ActivationConfigPropertyMetaData   propertyMetaData    :    propertiesMetaData )     {", "activationConfigProperties . put ( propertyMetaData . getKey (  )  ,    propertyMetaData . getValue (  )  )  ;", "}", "}", "}", "} else    {", "messagingType    =    null ;", "}", "messageListenerInterfaceName    =     ( messagingType    !  =    null )     ?    messagingType    :    getMessageListenerInterface ( compositeIndex ,    messageBeanAnnotation )  ;", "} else    {", "beanClassName    =    beanClassInfo . name (  )  . toString (  )  ;", "messageListenerInterfaceName    =    getMessageListenerInterface ( compositeIndex ,    messageBeanAnnotation )  ;", "}", "final   String   defaultResourceAdapterName    =    this . getDefaultResourceAdapterName ( deploymentUnit . getServiceRegistry (  )  )  ;", "final      beanDescription    =    new    ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnitServiceName ,    messageListenerInterfaceName ,    activationConfigProperties ,    defaultResourceAdapterName ,    beanMetaData )  ;", "beanDescription . setDeploymentDescriptorEnvironment ( deploymentDescriptorEnvironment )  ;", "addComponent ( deploymentUnit ,    beanDescription )  ;", "}", "EjbDeploymentMarker . mark ( deploymentUnit )  ;", "}", "METHOD_END"], "methodName": ["processMessageBeans"], "fileName": "org.jboss.as.ejb3.deployment.processors.MessageDrivenComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   EjbJarDescription   ejbJarDescription    =    AbstractDeploymentUnitProcessor . getEjbJarDescription ( deploymentUnit )  ;", "final   String   beanName    =    mdb . getName (  )  ;", "final   String   beanClassName    =    mdb . getEjbClass (  )  ;", "String   messageListenerInterface    =    mdb . getMessagingType (  )  ;", "if    (  ( messageListenerInterface    =  =    null )     |  |     ( messageListenerInterface . trim (  )  . isEmpty (  )  )  )     {", "messageListenerInterface    =    MessageListener . class . getName (  )  ;", "}", "final   Properties   activationConfigProps    =    getActivationConfigProperties ( mdb . getActivationConfig (  )  )  ;", "final   String   defaultResourceAdapterName    =    this . getDefaultResourceAdapterName ( deploymentUnit . getServiceRegistry (  )  )  ;", "final      mdbComponentDescription    =    new    ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnit . getServiceName (  )  ,    messageListenerInterface ,    activationConfigProps ,    defaultResourceAdapterName ,    mdb )  ;", "mdbComponentDescription . setDeploymentDescriptorEnvironment ( new   DeploymentDescriptorEnvironment (  \" java : comp / env /  \"  ,    mdb )  )  ;", "addComponent ( deploymentUnit ,    mdbComponentDescription )  ;", "}", "METHOD_END"], "methodName": ["processMessageDrivenBeanMetaData"], "fileName": "org.jboss.as.ejb3.deployment.processors.MessageDrivenComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "for    ( DotName   annotationName    :     . PASSIVATION _ ANNOTATIONS )     {", "final   List < AnnotationInstance >    lifecycles    =    index . getAnnotations ( annotationName )  ;", "for    ( AnnotationInstance   annotation    :    lifecycles )     {", "processPassivation ( eeModuleDescription ,    annotation . target (  )  ,    annotationName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ejb3.deployment.processors.PassivationAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( target   instanceof   MethodInfo )  )     {", "throw   ROOT _ LOGGER . methodOnlyAnnotation ( annotationType )  ;", "}", "final   MethodInfo   methodInfo    =    MethodInfo . class . cast ( target )  ;", "final   ClassInfo   classInfo    =    methodInfo . declaringClass (  )  ;", "final   EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "final   Type [  ]    args    =    methodInfo . args (  )  ;", "if    (  ( args . length )     >     1  )     {", "EeLogger . ROOT _ LOGGER . warn ( ROOT _ LOGGER . invalidNumberOfArguments ( methodInfo . name (  )  ,    annotationType ,    classInfo . name (  )  )  )  ;", "return ;", "} else", "if    (  (  ( args . length )     =  =     1  )     &  &     (  !  ( args [  0  ]  . name (  )  . toString (  )  . equals ( InvocationContext . class . getName (  )  )  )  )  )     {", "EeLogger . ROOT _ LOGGER . warn ( ROOT _ LOGGER . invalidSignature ( methodInfo . name (  )  ,    annotationType ,    classInfo . name (  )  ,     \" void   methodName ( InvocationContext   ctx )  \"  )  )  ;", "return ;", "}", "final   MethodIdentifier   methodIdentifier ;", "if    (  ( args . length )     =  =     0  )     {", "methodIdentifier    =    MethodIdentifier . getIdentifier ( Void . TYPE ,    methodInfo . name (  )  )  ;", "} else    {", "methodIdentifier    =    MethodIdentifier . getIdentifier ( Void . TYPE ,    methodInfo . name (  )  ,    InvocationContext . class )  ;", "}", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder ( classDescription . getInterceptorClassDescription (  )  )  ;", "if    ( annotationType    =  =     (  . POST _ ACTIVATE )  )     {", "builder . setPostActivate ( methodIdentifier )  ;", "} else    {", "builder . setPrePassivate ( methodIdentifier )  ;", "}", "classDescription . setInterceptorClassDescription ( builder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["processPassivation"], "fileName": "org.jboss.as.ejb3.deployment.processors.PassivationAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   short   flags    =    sessionBeanClass . flags (  )  ;", "final   String   className    =    sessionBeanClass . name (  )  . toString (  )  ;", "if    ( Modifier . isInterface ( flags )  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . sessionBeanClassCannotBeAnInterface ( className )  ;", "return   false ;", "}", "if    (  (  (  !  ( Modifier . isPublic ( flags )  )  )     |  |     ( Modifier . isAbstract ( flags )  )  )     |  |     ( Modifier . isFinal ( flags )  )  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . sessionBeanClassMustBePublicNonAbstractNonFinal ( className )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["assertSessionBeanClassValidity"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( sessionType    =  =    null )", "return   null ;", "switch    ( sessionType )     {", "case   Stateless    :", "return    . SessionBeanType . STATELESS ;", "case   Stateful    :", "return    . SessionBeanType . STATEFUL ;", "case   Singleton    :", "return    . SessionBeanType . SINGLETON ;", "default    :", "throw   EjbLogger . ROOT _ LOGGER . unknownSessionBeanType ( sessionType . name (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["descriptionOf"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( ejbClass    =  =    null )     {", "return   null ;", "}", "final   ClassInfo   info    =    compositeIndex . getClassByName ( DotName . createSimple ( ejbClass )  )  ;", "if    ( info    =  =    null )     {", "return   null ;", "}", "if    (  ( info . annotations (  )  . get (  . STATEFUL _ ANNOTATION )  )     !  =    null )     {", "return   SessionType . Stateful ;", "} else", "if    (  ( info . annotations (  )  . get (  . STATELESS _ ANNOTATION )  )     !  =    null )     {", "return   SessionType . Stateless ;", "} else", "if    (  ( info . annotations (  )  . get (  . SINGLETON _ ANNOTATION )  )     !  =    null )     {", "return   SessionType . Singleton ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["determineSessionType"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   EjbJarDescription   ejbJarDescription    =    AbstractDeploymentUnitProcessor . getEjbJarDescription ( deploymentUnit )  ;", "final   CompositeIndex   compositeIndex    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "final   String   beanName    =    sessionBean . getName (  )  ;", "SessionType   sessionType    =    sessionBean . getSessionType (  )  ;", "if    (  ( sessionType    =  =    null )     &  &     ( sessionBean   instanceof   GenericBeanMetaData )  )     {", "final   GenericBeanMetaData   bean    =     (  ( GenericBeanMetaData )     ( sessionBean )  )  ;", "if    (  ( bean . getEjbType (  )  )     =  =     ( EjbType . SESSION )  )     {", "sessionType    =    determineSessionType ( sessionBean . getEjbClass (  )  ,    compositeIndex )  ;", "if    ( sessionType    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . sessionTypeNotSpecified ( beanName )  ;", "}", "} else    {", "return ;", "}", "} else", "if    ( sessionType    =  =    null )     {", "sessionType    =    determineSessionType ( sessionBean . getEjbClass (  )  ,    compositeIndex )  ;", "if    ( sessionType    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . sessionTypeNotSpecified ( beanName )  ;", "}", "}", "final   String   beanClassName    =    sessionBean . getEjbClass (  )  ;", "final      sessionBeanDescription ;", "switch    ( sessionType )     {", "case   Stateless    :", "sessionBeanDescription    =    new   StatelessComponentDescription ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnit . getServiceName (  )  ,    sessionBean )  ;", "break ;", "case   Stateful    :", "sessionBeanDescription    =    new   StatefulComponentDescription ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnit . getServiceName (  )  ,    sessionBean )  ;", "if    (  ( sessionBean   instanceof   SessionBean 3  2 MetaData )     &  &     (  (  (  ( SessionBean 3  2 MetaData )     ( sessionBean )  )  . isPassivationCapable (  )  )     !  =    null )  )     {", "(  ( StatefulComponentDescription )     ( sessionBeanDescription )  )  . setPassivationApplicable (  (  ( SessionBean 3  2 MetaData )     ( sessionBean )  )  . isPassivationCapable (  )  )  ;", "}", "break ;", "case   Singleton    :", "sessionBeanDescription    =    new   SingletonComponentDescription ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnit . getServiceName (  )  ,    sessionBean )  ;", "break ;", "default    :", "throw   EjbLogger . ROOT _ LOGGER . unknownSessionBeanType ( sessionType . name (  )  )  ;", "}", "addComponent ( deploymentUnit ,    sessionBeanDescription )  ;", "}", "METHOD_END"], "methodName": ["processSessionBeanMetaData"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "final   EjbJarDescription   ejbJarDescription    =    AbstractDeploymentUnitProcessor . getEjbJarDescription ( deploymentUnit )  ;", "final   ServiceName   deploymentUnitServiceName    =    deploymentUnit . getServiceName (  )  ;", "PropertyReplacer   propertyReplacer    =    EJBAnnotationPropertyReplacement . propertyReplacer ( deploymentUnit )  ;", "for    ( final   AnnotationInstance   sessionBeanAnnotation    :    sessionBeanAnnotations )     {", "final   AnnotationTarget   target    =    sessionBeanAnnotation . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "EjbLogger . DEPLOYMENT _ LOGGER . warn ( EjbLogger . ROOT _ LOGGER . annotationOnlyAllowedOnClass ( sessionBeanAnnotation . name (  )  . toString (  )  ,    target )  . getMessage (  )  )  ;", "continue ;", "}", "final   ClassInfo   sessionBeanClassInfo    =     (  ( ClassInfo )     ( target )  )  ;", "if    (  !  (  . assertSessionBeanClassValidity ( sessionBeanClassInfo )  )  )     {", "continue ;", "}", "final   String   ejbName    =    sessionBeanClassInfo . name (  )  . local (  )  ;", "final   AnnotationValue   nameValue    =    sessionBeanAnnotation . value (  \" name \"  )  ;", "final   String   beanName    =     (  ( nameValue    =  =    null )     |  |     ( nameValue . asString (  )  . isEmpty (  )  )  )     ?    ejbName    :    propertyReplacer . replaceProperties ( nameValue . asString (  )  )  ;", "final   SessionBeanMetaData   beanMetaData    =    EJBComponentDescriptionFactory . getEnterpriseBeanMetaData ( deploymentUnit ,    beanName ,    SessionBeanMetaData . class )  ;", "final   SessionBeanComponentDescription . SessionBeanType   sessionBeanType ;", "final   String   beanClassName ;", "if    ( beanMetaData    !  =    null )     {", "beanClassName    =    EJBComponentDescriptionFactory . override ( sessionBeanClassInfo . name (  )  . toString (  )  ,    beanMetaData . getEjbClass (  )  )  ;", "sessionBeanType    =    EJBComponentDescriptionFactory . override ( annotatedSessionBeanType ,     . descriptionOf (  (  ( SessionBeanMetaData )     ( beanMetaData )  )  . getSessionType (  )  )  )  ;", "} else    {", "beanClassName    =    sessionBeanClassInfo . name (  )  . toString (  )  ;", "sessionBeanType    =    annotatedSessionBeanType ;", "}", "final   SessionBeanComponentDescription   sessionBeanDescription ;", "switch    ( sessionBeanType )     {", "case   STATELESS    :", "sessionBeanDescription    =    new   StatelessComponentDescription ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnitServiceName ,    beanMetaData )  ;", "break ;", "case   STATEFUL    :", "sessionBeanDescription    =    new   StatefulComponentDescription ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnitServiceName ,    beanMetaData )  ;", "final   boolean   passivationCapableAnnotationValue    =     (  ( sessionBeanAnnotation . value (  \" passivationCapable \"  )  )     =  =    null )     ?    true    :    sessionBeanAnnotation . value (  \" passivationCapable \"  )  . asBoolean (  )  ;", "final   Boolean   passivationCapableDeploymentDescriptorValue ;", "if    ( beanMetaData   instanceof   SessionBean 3  2 MetaData )     {", "passivationCapableDeploymentDescriptorValue    =     (  ( SessionBean 3  2 MetaData )     ( beanMetaData )  )  . isPassivationCapable (  )  ;", "} else    {", "passivationCapableDeploymentDescriptorValue    =    null ;", "}", "final   boolean   passivationApplicable    =    EJBComponentDescriptionFactory . override ( passivationCapableDeploymentDescriptorValue ,    passivationCapableAnnotationValue )  ;", "(  ( StatefulComponentDescription )     ( sessionBeanDescription )  )  . setPassivationApplicable ( passivationApplicable )  ;", "break ;", "case   SINGLETON    :", "sessionBeanDescription    =    new   SingletonComponentDescription ( beanName ,    beanClassName ,    ejbJarDescription ,    deploymentUnitServiceName ,    beanMetaData )  ;", "break ;", "default    :", "throw   EjbLogger . ROOT _ LOGGER . unknownSessionBeanType ( sessionBeanType . name (  )  )  ;", "}", "addComponent ( deploymentUnit ,    sessionBeanDescription )  ;", "}", "EjbDeploymentMarker . mark ( deploymentUnit )  ;", "}", "METHOD_END"], "methodName": ["processSessionBeans"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanComponentDescriptionFactory"}, {"methodBody": ["METHOD_START", "{", "homeView . getConfigurators (  )  . add ( new   ViewConfigurator (  )     {", "@ Override", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   ViewDescription   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "configuration . addClientPostConstructInterceptor ( getTerminalInterceptorFactory (  )  ,    TERMINAL _ INTERCEPTOR )  ;", "configuration . addClientPreDestroyInterceptor ( getTerminalInterceptorFactory (  )  ,    InterceptorOrder . ClientPreDestroy . TERMINAL _ INTERCEPTOR )  ;", "for    ( Method   method    :    configuration . getProxyFactory (  )  . getCachedMethods (  )  )     {", "if    ( method . getName (  )  . startsWith (  \" create \"  )  )     {", "if    ( ejbObjectView    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . invalidEjbLocalInterface ( componentDescription . getComponentName (  )  )  ;", "}", "Method   initMethod    =    resolveInitMethod ( ejbComponentDescription ,    method )  ;", "final   SessionBeanHomeInterceptorFactory   factory    =    new   SessionBeanHomeInterceptorFactory ( initMethod )  ;", "configuration . getDependencies (  )  . add ( new   DependencyConfigurator < ViewService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    final   ViewService   service )    throws   DeploymentUnitProcessingException    {", "serviceBuilder . addDependency ( ejbObjectView . getServiceName (  )  ,    ComponentView . class ,    factory . getViewToCreate (  )  )  ;", "}", "}  )  ;", "configuration . addClientInterceptor ( method ,    CLIENT _ DISPATCHER _ INTERCEPTOR _ FACTORY ,    CLIENT _ DISPATCHER )  ;", "configuration . addViewInterceptor ( method ,    factory ,    HOME _ METHOD _ INTERCEPTOR )  ;", "} else", "if    (  (  ( method . getName (  )  . equals (  \" getEJBMetaData \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )  )     &  &     (  (  (  ( EJBViewDescription )     ( description )  )  . getMethodIntf (  )  )     =  =     ( component . MethodIntf . HOME )  )  )     {", "final   Class <  ?  >    ejbObjectClass ;", "try    {", "ejbObjectClass    =    loadClass ( ejbObjectView . getViewClassName (  )  ,    context . getDeploymentUnit (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLoadViewClassForComponent ( e ,    componentDescription . getComponentName (  )  )  ;", "}", "final   component . interceptors . EjbMetadataInterceptor   factory    =    new   component . interceptors . EjbMetadataInterceptor ( ejbObjectClass ,    configuration . getViewClass (  )  . asSubclass ( class )  ,    null ,    true ,     ( componentDescription   instanceof   component . stateless . StatelessComponentDescription )  )  ;", "componentConfiguration . getStartDependencies (  )  . add ( new   DependencyConfigurator < ComponentStartService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    final   ComponentStartService   service )    throws   DeploymentUnitProcessingException    {", "serviceBuilder . addDependency ( configuration . getViewServiceName (  )  ,    ComponentView . class ,    factory . getHomeView (  )  )  ;", "}", "}  )  ;", "configuration . addClientInterceptor ( method ,    CLIENT _ DISPATCHER _ INTERCEPTOR _ FACTORY ,    CLIENT _ DISPATCHER )  ;", "configuration . addViewInterceptor ( method ,    new   ImmediateInterceptorFactory ( factory )  ,    HOME _ METHOD _ INTERCEPTOR )  ;", "} else", "if    (  (  ( method . getName (  )  . equals (  \" remove \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     1  )  )     &  &     (  ( method . getParameterTypes (  )  [  0  ]  )     =  =     ( Object . class )  )  )     {", "configuration . addClientInterceptor ( method ,    CLIENT _ DISPATCHER _ INTERCEPTOR _ FACTORY ,    CLIENT _ DISPATCHER )  ;", "configuration . addViewInterceptor ( method ,    component . session . InvalidRemoveExceptionMethodInterceptor . FACTORY ,    InterceptorOrder . View . INVALID _ METHOD _ EXCEPTION )  ;", "} else", "if    (  (  ( method . getName (  )  . equals (  \" remove \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     1  )  )     &  &     (  ( method . getParameterTypes (  )  [  0  ]  )     =  =     ( class )  )  )     {", "configuration . addClientInterceptor ( method ,    CLIENT _ DISPATCHER _ INTERCEPTOR _ FACTORY ,    CLIENT _ DISPATCHER )  ;", "configuration . addViewInterceptor ( method ,    component . interceptors . HomeRemoveInterceptor . FACTORY ,    HOME _ METHOD _ INTERCEPTOR )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureHome"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanHomeProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( description   instanceof   StatelessComponentDescription )     {", "return   null ;", "} else", "if    ( description   instanceof   component . stateful . StatefulComponentDescription )     {", "return   resolveStatefulInitMethod (  (  ( component . stateful . StatefulComponentDescription )     ( description )  )  ,    method )  ;", "} else    {", "throw   logging . EjbLogger . ROOT _ LOGGER . localHomeNotAllow ( description )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveInitMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanHomeProcessor"}, {"methodBody": ["METHOD_START", "{", "Method   initMethod    =    null ;", "for    ( Map . Entry < Method ,    String >    entry    :    description . getInitMethods (  )  . entrySet (  )  )     {", "String   name    =    entry . getValue (  )  ;", "Method   init    =    entry . getKey (  )  ;", "if    ( name    !  =    null )     {", "if    ( Arrays . equals ( init . getParameterTypes (  )  ,    method . getParameterTypes (  )  )  )     {", "if    ( init . getName (  )  . equals ( name )  )     {", "initMethod    =    init ;", "}", "}", "}", "}", "if    ( initMethod    =  =    null )     {", "for    ( Map . Entry < Method ,    String >    entry    :    description . getInitMethods (  )  . entrySet (  )  )     {", "Method   init    =    entry . getKey (  )  ;", "if    (  ( entry . getValue (  )  )     =  =    null )     {", "if    ( Arrays . equals ( init . getParameterTypes (  )  ,    method . getParameterTypes (  )  )  )     {", "initMethod    =    init ;", "break ;", "}", "}", "}", "}", "if    ( initMethod    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . failToCallEjbCreateForInterface ( method ,    description . getEJBClassName (  )  )  ;", "}", "return   initMethod ;", "}", "METHOD_END"], "methodName": ["resolveStatefulInitMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.SessionBeanHomeProcessor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    interfaces    =    beanClass . getInterfaces (  )  ;", "if    ( interfaces    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "final   Set < Class <  ?  >  >    potentialBusinessInterfaces    =    new   HashSet < Class <  ?  >  >  (  )  ;", "for    ( Class <  ?  >    klass    :    interfaces )     {", "if    (  (  (  ( klass . equals ( Serializable . class )  )     |  |     ( klass . equals ( Externalizable . class )  )  )     |  |     ( klass . getName (  )  . startsWith (  \" \"  )  )  )     |  |     ( klass . getName (  )  . startsWith (  \" groovy . lang .  \"  )  )  )     {", "continue ;", "}", "potentialBusinessInterfaces . add ( klass )  ;", "}", "return   potentialBusinessInterfaces ;", "}", "METHOD_END"], "methodName": ["getPotentialViewInterfaces"], "fileName": "org.jboss.as.ejb3.deployment.processors.ViewInterfaces"}, {"methodBody": ["METHOD_START", "{", "DotName [  ]    interfaces    =    beanClass . interfaces (  )  ;", "if    ( interfaces    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "final   Set < DotName >    names    =    new   HashSet < DotName >  (  )  ;", "for    ( DotName   dotName    :    interfaces )     {", "String   name    =    dotName . toString (  )  ;", "if    (  (  (  ( name . equals ( Serializable . class . getName (  )  )  )     |  |     ( name . equals ( Externalizable . class . getName (  )  )  )  )     |  |     ( name . startsWith (  \" \"  )  )  )     |  |     ( name . startsWith (  \" groovy . lang .  \"  )  )  )     {", "continue ;", "}", "names . add ( dotName )  ;", "}", "return   names ;", "}", "METHOD_END"], "methodName": ["getPotentialViewInterfaces"], "fileName": "org.jboss.as.ejb3.deployment.processors.ViewInterfaces"}, {"methodBody": ["METHOD_START", "{", "Set   groovyClasses    =    ViewInterfaces . getPotentialViewInterfaces ( ViewInterfacesTestCase . TestGroovyMessageListener . class )  ;", "Assert . assertEquals (  \" One   object   epected   in   Groovy   class \"  ,     1  ,    groovyClasses . size (  )  )  ;", "Assert . assertEquals (  \" Expected   interface   in   Groovy   class \"  ,    MessageListener . class ,    groovyClasses . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGroovyClass"], "fileName": "org.jboss.as.ejb3.deployment.processors.ViewInterfacesTestCase"}, {"methodBody": ["METHOD_START", "{", "Set   javaClasses    =    ViewInterfaces . getPotentialViewInterfaces ( ViewInterfacesTestCase . TestJavaMessageListener . class )  ;", "Assert . assertEquals (  \" One   object   epected   in   Java   class \"  ,     1  ,    size (  )  )  ;", "Assert . assertEquals (  \" Expected   interface   in   Java   class \"  ,    MessageListener . class ,    iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaClass"], "fileName": "org.jboss.as.ejb3.deployment.processors.ViewInterfacesTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( viewType    =  =    null )     {", "return   MethodIf . BEAN ;", "}", "switch    ( viewType )     {", "case   Home    :", "return   MethodIf . HOME ;", "case   LocalHome    :", "return   MethodIf . LOCAL _ HOME ;", "case   ServiceEndpoi    :", "return   MethodIf . SERVICE _ ENDPOINT ;", "case   Local    :", "return   MethodIf . LOCAL ;", "case   Remote    :", "return   MethodIf . REMOTE ;", "}", "return   MethodIf . BEAN ;", "}", "METHOD_END"], "methodName": ["getMethodIntf"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.AbstractEjbXmlDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( methodParametersMetaData    =  =    null )     {", "return   null ;", "}", "return   methodParametersMetaData . toArray ( new   String [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getMethodParams"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.AbstractEjbXmlDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( final   MessageDestinationMetaData   destination    :    destinations )     {", "if    (  ( destination . getJndiName (  )  )     !  =    null )     {", "eeModuleion . addMessageDestination ( destination . getName (  )  ,    destination . getJndiName (  )  )  ;", "} else", "if    (  ( destination . getLookupName (  )  )     !  =    null )     {", "eeModuleion . addMessageDestination ( destination . getName (  )  ,    destination . getLookupName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processMessageDestinations"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.AssemblyDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( securityRoles    =  =    null )     |  |     ( securityRoles . isEmpty (  )  )  )     {", "return ;", "}", "for    ( final   SecurityRoleMetaData   securityRole    :    securityRoles )     {", "final   String   roleName    =    securityRole . getRoleName (  )  ;", "if    (  ( roleName    !  =    null )     &  &     (  !  ( roleName . trim (  )  . isEmpty (  )  )  )  )     {", "ejbJarion . addSecurityRole ( roleName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processSecurityRoles"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.AssemblyDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( component . getDescriptorData (  )  )     =  =    null )     {", "return ;", "}", "final   Class <  ?  >    componentClass    =    ClassLoadingUtils . loadClass ( component . getComponentClassName (  )  ,    module )  ;", "final   EnterpriseBeanMetaData   metaData    =    component . getDescriptorData (  )  ;", "AroundInvokesMetaData   aroundInvokes    =    null ;", "if    ( metaData   instanceof   SessionBeanMetaData )     {", "aroundInvokes    =     (  ( SessionBeanMetaData )     ( metaData )  )  . getAroundInvokes (  )  ;", "} else", "if    ( metaData   instanceof   MessageDrivenBeanMetaData )     {", "aroundInvokes    =     (  ( MessageDrivenBeanMetaData )     ( metaData )  )  . getAroundInvokes (  )  ;", "}", "if    ( aroundInvokes    !  =    null )     {", "for    ( AroundInvokeMetaData   aroundInvoke    :    aroundInvokes )     {", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "String   methodName    =    aroundInvoke . getMethodName (  )  ;", "MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( Object . class ,    methodName ,    InvocationContext . class )  ;", "builder . setAroundInvoke ( methodIdentifier )  ;", "if    (  (  ( aroundInvoke . getClassName (  )  )     =  =    null )     |  |     ( aroundInvoke . getClassName (  )  . isEmpty (  )  )  )     {", "final   String   className    =    ClassReflectionIndexUtil . findRequiredMethod ( reflectionIndex ,    componentClass ,    methodIdentifier )  . getDeclaringClass (  )  . getName (  )  ;", "component . addInterceptorMethodOverride ( className ,    builder . build (  )  )  ;", "} else    {", "component . addInterceptorMethodOverride ( aroundInvoke . getClassName (  )  ,    builder . build (  )  )  ;", "}", "}", "}", "LifecycleCallbacksMetaData   postConstructs    =    metaData . getPostConstructs (  )  ;", "if    ( postConstructs    !  =    null )     {", "for    ( LifecycleCallbackMetaData   postConstruct    :    postConstructs )     {", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "String   methodName    =    postConstruct . getMethodName (  )  ;", "MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName )  ;", "builder . setPostConstruct ( methodIdentifier )  ;", "if    (  (  ( postConstruct . getClassName (  )  )     =  =    null )     |  |     ( postConstruct . getClassName (  )  . isEmpty (  )  )  )     {", "final   String   className    =    ClassReflectionIndexUtil . findRequiredMethod ( reflectionIndex ,    componentClass ,    methodIdentifier )  . getDeclaringClass (  )  . getName (  )  ;", "component . addInterceptorMethodOverride ( className ,    builder . build (  )  )  ;", "} else    {", "component . addInterceptorMethodOverride ( postConstruct . getClassName (  )  ,    builder . build (  )  )  ;", "}", "}", "}", "final   LifecycleCallbacksMetaData   preDestroys    =    metaData . getPreDestroys (  )  ;", "if    ( preDestroys    !  =    null )     {", "for    ( final   LifecycleCallbackMetaData   preDestroy    :    preDestroys )     {", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "final   String   methodName    =    preDestroy . getMethodName (  )  ;", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName )  ;", "builder . setPreDestroy ( methodIdentifier )  ;", "if    (  (  ( preDestroy . getClassName (  )  )     =  =    null )     |  |     ( preDestroy . getClassName (  )  . isEmpty (  )  )  )     {", "final   String   className    =    ClassReflectionIndexUtil . findRequiredMethod ( reflectionIndex ,    componentClass ,    methodIdentifier )  . getDeclaringClass (  )  . getName (  )  ;", "component . addInterceptorMethodOverride ( className ,    builder . build (  )  )  ;", "} else    {", "component . addInterceptorMethodOverride ( preDestroy . getClassName (  )  ,    builder . build (  )  )  ;", "}", "}", "}", "if    ( component . isStateful (  )  )     {", "final   SessionBeanMetaData   sessionBeanMetadata    =     (  ( SessionBeanMetaData )     ( metaData )  )  ;", "final   LifecycleCallbacksMetaData   prePassivates    =    sessionBeanMetadata . getPrePassivates (  )  ;", "if    ( prePassivates    !  =    null )     {", "for    ( final   LifecycleCallbackMetaData   prePassivate    :    prePassivates )     {", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "final   String   methodName    =    prePassivate . getMethodName (  )  ;", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName )  ;", "builder . setPrePassivate ( methodIdentifier )  ;", "if    (  (  ( prePassivate . getClassName (  )  )     =  =    null )     |  |     ( prePassivate . getClassName (  )  . isEmpty (  )  )  )     {", "final   String   className    =    ClassReflectionIndexUtil . findRequiredMethod ( reflectionIndex ,    componentClass ,    methodIdentifier )  . getDeclaringClass (  )  . getName (  )  ;", "component . addInterceptorMethodOverride ( className ,    builder . build (  )  )  ;", "} else    {", "component . addInterceptorMethodOverride ( prePassivate . getClassName (  )  ,    builder . build (  )  )  ;", "}", "}", "}", "final   LifecycleCallbacksMetaData   postActivates    =    sessionBeanMetadata . getPostActivates (  )  ;", "if    ( postActivates    !  =    null )     {", "for    ( final   LifecycleCallbackMetaData   postActivate    :    postActivates )     {", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "final   String   methodName    =    postActivate . getMethodName (  )  ;", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName )  ;", "builder . setPostActivate ( methodIdentifier )  ;", "if    (  (  ( postActivate . getClassName (  )  )     =  =    null )     |  |     ( postActivate . getClassName (  )  . isEmpty (  )  )  )     {", "final   String   className    =    ClassReflectionIndexUtil . findRequiredMethod ( reflectionIndex ,    componentClass ,    methodIdentifier )  . getDeclaringClass (  )  . getName (  )  ;", "component . addInterceptorMethodOverride ( className ,    builder . build (  )  )  ;", "} else    {", "component . addInterceptorMethodOverride ( postActivate . getClassName (  )  ,    builder . build (  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleSessionBean"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.DeploymentDescriptorMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    componentClass    =    ClassLoadingUtils . loadClass ( component . getComponentClassName (  )  ,    module )  ;", "final   MethodIdentifier   ejbCreateId    =    MethodIdentifier . getIdentifier ( void . class ,     \" ejbCreate \"  )  ;", "final   Method   ejbCreate    =    ClassReflectionIndexUtil . findMethod ( reflectionIndex ,    componentClass ,    ejbCreateId )  ;", "if    ( ejbCreate    !  =    null )     {", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "builder . setPostConstruct ( ejbCreateId )  ;", "component . addInterceOverride ( ejbCreate . getDeclaringClass (  )  . getName (  )  ,    builder . build (  )  )  ;", "}", "final   MethodIdentifier   ejbRemoveId    =    MethodIdentifier . getIdentifier ( void . class ,     \" ejbRemove \"  )  ;", "final   Method   ejbRemove    =    ClassReflectionIndexUtil . findMethod ( reflectionIndex ,    componentClass ,    ejbRemoveId )  ;", "if    ( ejbRemove    !  =    null )     {", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "builder . setPreDestroy ( ejbRemoveId )  ;", "component . addInterceOverride ( ejbRemove . getDeclaringClass (  )  . getName (  )  ,    builder . build (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleStatelessSessionBean"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.DeploymentDescriptorMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Collection < Method >    method    =    MethodResolutionUtils . resolveMethods ( methodName ,    parameters ,    componentClass ,    reflectionIndex )  ;", "if    (  ( method . size (  )  )     >     1  )     {", "throw   EjbLogger . ROOT _ LOGGER . moreThanOneMethodWithSameNameOnComponent ( methodName ,    componentClass )  ;", "}", "return   method . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.MethodResolutionUtils"}, {"methodBody": ["METHOD_START", "{", "return   MethodResolutionUtils . resolveMethod ( methodData . getMethodName (  )  ,    methodData . getMethodParams (  )  ,    componentClass ,    reflectionIndex )  ;", "}", "METHOD_END"], "methodName": ["resolveMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.MethodResolutionUtils"}, {"methodBody": ["METHOD_START", "{", "return   MethodResolutionUtils . resolveMethod ( methodData . getMethodName (  )  ,    methodData . getMethodParams (  )  ,    componentClass ,    reflectionIndex )  ;", "}", "METHOD_END"], "methodName": ["resolveMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.MethodResolutionUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    componentClass ;", "while    (  ( clazz    !  =     ( Object . class )  )     &  &     ( clazz    !  =    null )  )     {", "final   ClassReflectionIndex   classIndex    =    reflectionIndex . getClassIndex ( clazz )  ;", "if    ( parameters    =  =    null )     {", "final   Collection <  >    methods    =    classIndex . getAlls ( methodName )  ;", "if    (  !  ( methods . isEmpty (  )  )  )     {", "return   methods ;", "}", "} else    {", "final   Collection <  >    methods    =    classIndex . getAlls ( methodName ,    parameters . size (  )  )  ;", "for    ( final      method    :    methods )     {", "boolean   match    =    true ;", "for    ( int   i    =     0  ;    i    <     ( method . getParameterTypes (  )  . length )  ;     +  + i )     {", "if    (  !  ( method . getParameterTypes (  )  [ i ]  . getName (  )  . equals ( parameters . get ( i )  )  )  )     {", "match    =    false ;", "break ;", "}", "}", "if    ( match )     {", "return   Collections . singleton ( method )  ;", "}", "}", "}", "clazz    =    clazz . getSuperclass (  )  ;", "}", "throw   EjbLogger . ROOT _ LOGGER . failToFindInEjbJarXml ( componentClass . getName (  )  ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["resolveMethods"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.MethodResolutionUtils"}, {"methodBody": ["METHOD_START", "{", "return   MethodResolutionUtils . resolveMethods ( methodData . getMethodName (  )  ,    methodData . getMethodParams (  )  ,    componentClass ,    reflectionIndex )  ;", "}", "METHOD_END"], "methodName": ["resolveMethods"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.MethodResolutionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( sessionBean 3  1 MetaData . isNoInterfaceBean (  )  )     {", "sessionBeanComponentDescription . addNoInterfaceView (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processSessionBean31"], "fileName": "org.jboss.as.ejb3.deployment.processors.dd.SessionBeanXmlDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( viewType    =  =    null )     {", "return   defaulthodIntf ;", "}", "switch    ( viewType )     {", "case   Home    :", "return   MethodIntf . HOME ;", "case   LocalHome    :", "return   MethodIntf . LOCAL _ HOME ;", "case   ServiceEndpoint    :", "return   MethodIntf . SERVICE _ ENDPOINT ;", "case   Local    :", "return   MethodIntf . LOCAL ;", "case   Remote    :", "return   MethodIntf . REMOTE ;", "case   Timer    :", "return   MethodIntf . TIMER ;", "case   MessageEndpoint    :", "return   MethodIntf . MESSAGE _ ENDPOINT ;", "}", "return   defaulthodIntf ;", "}", "METHOD_END"], "methodName": ["getMethodIntf"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.AbstractMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( methodParametersMetaData    =  =    null )     {", "return   null ;", "}", "return   methodParametersMetaData . toArray ( new   Str [ methodParametersMetaData . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getMethodParams"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.AbstractMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    componentClass ;", "try    {", "componentClass    =    module . getClassLoader (  )  . loadClass ( description . getEJBClassName (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failToLoadEjbClass ( description . getEJBClassName (  )  ,    e )  ;", "}", "if    (  !  ( MetadataCompleteMarker . isMetadataComplete ( Unit )  )  )     {", "handleAnnotations ( Unit ,    applicationClasses ,    ReflectionIndex ,    componentClass ,    description )  ;", "}", "handleDeploymentDescriptor ( Unit ,    ReflectionIndex ,    componentClass ,    description )  ;", "}", "METHOD_END"], "methodName": ["processComponentConfig"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.AbstractMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( method . getReturnType (  )  . equals ( void . class )  )     |  |     ( method . getReturnType (  )  . equals ( Future . class )  )  )     {", "configuration . addClientInterceptor ( method ,    LogDiagnosticContextStorageInterceptor . getFactory (  )  ,    LOCAL _ ASYNC _ LOG _ SAVE )  ;", "if    ( isSecurityDomainKnown )     {", "configuration . addClientInterceptor ( method ,    SecurityDomainInterceptorFactory . INSTANCE ,    LOCAL _ ASYNC _ SECURITY _ CONTEXT )  ;", "}", "configuration . addClientInterceptor ( method ,    FutureInterceptorFactory . INSTANCE ,    LOCAL _ ASYNC _ INVOCATION )  ;", "configuration . addClientInterceptor ( method ,    LogDiagnosticContextRecoveryInterceptor . getFactory (  )  ,    LOCAL _ ASYNC _ LOG _ RESTORE )  ;", "} else    {", "throw   EjbLogger . ROOT _ LOGGER . wrongReturnTypeForMethod ( method )  ;", "}", "}", "METHOD_END"], "methodName": ["addAsyncInterceptor"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.AsynchronousMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeAnnotationInformation < LockType >    lockData    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    Lock . class )  ;", "for    ( Map . Entry < String ,    List < LockType >  >    entry    :    lockData . getClassAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "componentConfiguration . setBeanLevelLockType ( entry . getKey (  )  ,    entry . getValue (  )  . get (  0  )  )  ;", "}", "}", "for    ( Map . Entry < Method ,    List < LockType >  >    entry    :    lockData . getMethodAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "componentConfiguration . setLockType ( entry . getValue (  )  . get (  0  )  ,    MethodIdentifier . getIdentifierForMethod ( entry . getKey (  )  )  )  ;", "}", "}", "final   RuntimeAnnotationInformation < AccessTimeoutDetails >    accessTimeout    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    AccessTimeout . class )  ;", "for    ( Map . Entry < String ,    List < AccessTimeoutDetails >  >    entry    :    accessTimeout . getClassAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "componentConfiguration . setBeanLevelAccessTimeout ( entry . getKey (  )  ,    entry . getValue (  )  . get (  0  )  )  ;", "}", "}", "for    ( Map . Entry < Method ,    List < AccessTimeoutDetails >  >    entry    :    accessTimeout . getMethodAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "componentConfiguration . setAccessTimeout ( entry . getValue (  )  . get (  0  )  ,    MethodIdentifier . getIdentifierForMethod ( entry . getKey (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleAnnotations"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.EjbConcurrencyMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( componentConfiguration . getDescriptorData (  )  )     =  =    null )     {", "return ;", "}", "SessionBeanMetaData   sessionBeanMetaData    =    componentConfiguration . getDescriptorData (  )  ;", "if    ( sessionBeanMetaData   instanceof   SessionBean 3  1 MetaData )     {", "SessionBean 3  1 MetaData   descriptor    =     (  ( SessionBean 3  1 MetaData )     ( sessionBeanMetaData )  )  ;", "if    (  ( descriptor . getLockType (  )  )     !  =    null )     {", "componentConfiguration . setBeanLevelLockType ( componentConfiguration . getEJBClassName (  )  ,    descriptor . getLockType (  )  )  ;", "}", "if    (  ( descriptor . getAccessTimeout (  )  )     !  =    null )     {", "componentConfiguration . setBeanLevelAccessTimeout ( componentConfiguration . getEJBClassName (  )  ,    new   AccessTimeoutDetails ( descriptor . getAccessTimeout (  )  . getTimeout (  )  ,    descriptor . getAccessTimeout (  )  . getUnit (  )  )  )  ;", "}", "final   ConcurrentMethodsMetaData   methods    =    descriptor . getConcurrentMethods (  )  ;", "if    ( methods    !  =    null )     {", "for    ( final   ConcurrentMethodMetaData   method    :    methods )     {", "final   Method   realMethod    =    resolveMethod ( ReflectionIndex ,    componentClass ,    componentClass ,    method . getMethod (  )  )  ;", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifierForMethod ( realMethod )  ;", "if    (  ( method . getLockType (  )  )     !  =    null )     {", "componentConfiguration . setLockType ( method . getLockType (  )  ,    methodIdentifier )  ;", "}", "if    (  ( method . getAccessTimeout (  )  )     !  =    null )     {", "componentConfiguration . setAccessTimeout ( new   AccessTimeoutDetails ( method . getAccessTimeout (  )  . getTimeout (  )  ,    method . getAccessTimeout (  )  . getUnit (  )  )  ,    methodIdentifier )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleDeploymentDescriptor"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.EjbConcurrencyMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( currentClass    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . failToFindMethodWithParameterTypes ( componentClass . getName (  )  ,    methodData . getMethodName (  )  ,    methodData . getMethodParams (  )  )  ;", "}", "final   ClassReflectionIndex   classIndex    =    index . getClassIndex ( currentClass )  ;", "if    (  ( methodData . getMethodParams (  )  )     =  =    null )     {", "final   Collection < Method >    methods    =    classIndex . getAllMethods ( methodData . getMethodName (  )  )  ;", "if    ( methods . isEmpty (  )  )     {", "return   resolveMethod ( index ,    currentClass . getSuperclass (  )  ,    componentClass ,    methodData )  ;", "} else", "if    (  ( methods . size (  )  )     >     1  )     {", "throw   EjbLogger . ROOT _ LOGGER . multipleMethodReferencedInEjbJarXml ( methodData . getMethodName (  )  ,    currentClass . getName (  )  )  ;", "}", "return   methods . iterator (  )  . next (  )  ;", "} else    {", "final   Collection < Method >    methods    =    classIndex . getAllMethods ( methodData . getMethodName (  )  ,    methodData . getMethodParams (  )  . size (  )  )  ;", "for    ( final   Method   method    :    methods )     {", "boolean   match    =    true ;", "for    ( int   i    =     0  ;    i    <     ( method . getParameterTypes (  )  . length )  ;     +  + i )     {", "if    (  !  ( method . getParameterTypes (  )  [ i ]  . getName (  )  . equals ( methodData . getMethodParams (  )  . get ( i )  )  )  )     {", "match    =    false ;", "break ;", "}", "}", "if    ( match )     {", "return   method ;", "}", "}", "}", "return   resolveMethod ( index ,    currentClass . getSuperclass (  )  ,    componentClass ,    methodData )  ;", "}", "METHOD_END"], "methodName": ["resolveMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.EjbConcurrencyMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( final   String   annotationValue    :    annotationValues )     {", "final   Set < ComponentDescription >    components    =    applicationDescription . getComponents ( annotationValue ,    Root . getRoot (  )  )  ;", "if    ( components . isEmpty (  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToFindEjbRefByDependsOn ( annotationValue ,    description . getComponentClassName (  )  )  ;", "} else", "if    (  ( components . size (  )  )     !  =     1  )     {", "throw   EjbLogger . ROOT _ LOGGER . failToCallEjbRefByDependsOn ( annotationValue ,    description . getComponentClassName (  )  ,    components )  ;", "}", "final   ComponentDescription   component    =    components . iterator (  )  . next (  )  ;", "description . addDependency ( component . getStartServiceName (  )  ,    REQUIRED )  ;", "if    ( description   instanceof   SingletonComponentDescription )     {", "(  ( SingletonComponentDescription )     ( description )  )  . getDependsOn (  )  . add ( component . getStartServiceName (  )  )  ;", "if    ( EjbLogger . ROOT _ LOGGER . isDebugEnabled (  )  )     {", "EjbLogger . ROOT _ LOGGER . debugf (  (  (  ( description . getEJBName (  )  )     +     \"    bean   is   dependent   on    \"  )     +     ( component . getComponentName (  )  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setupDependencies"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.EjbDependsOnMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    localHomeClass    =    module . getClassLoader (  )  . loadClass ( localHomeClassName )  ;", "final   ClassReflectionIndex   index    =    ReflectionIndex . getClassIndex ( localHomeClass )  ;", "Class <  ?  >    localClass    =    null ;", "for    ( final   Method   method    :     (  ( Iterable < Method >  )     ( index . getMethods (  )  )  )  )     {", "if    ( method . getName (  )  . startsWith (  \" create \"  )  )     {", "if    (  ( localClass    !  =    null )     &  &     ( localClass    !  =     ( method . getReturnType (  )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . multipleCreateMethod ( localHomeClass )  ;", "}", "localClass    =    method . getReturnType (  )  ;", "}", "}", "if    ( localClass    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . couldNotDetermineLocalInterfaceFromLocalHome ( localHomeClassName ,    description . getEJBName (  )  )  ;", "}", "return   localClass . getName (  )  ;", "}", "METHOD_END"], "methodName": ["inferLocalInterfaceFromLocalHome"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.HomeViewMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    homeClass    =    module . getClassLoader (  )  . loadClass ( homeClassName )  ;", "final   ClassReflectionIndex   index    =    ReflectionIndex . getClassIndex ( homeClass )  ;", "Class <  ?  >    remote    =    null ;", "for    ( final   Method   method    :     (  ( Iterable < Method >  )     ( index . getMethods (  )  )  )  )     {", "if    ( method . getName (  )  . startsWith (  \" create \"  )  )     {", "if    (  ( remote    !  =    null )     &  &     ( remote    !  =     ( method . getReturnType (  )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . multipleCreateMethod ( homeClass )  ;", "}", "remote    =    method . getReturnType (  )  ;", "}", "}", "if    ( remote    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . couldNotDetermineRemoteInterfaceFromHome ( homeClassName ,    description . getEJBName (  )  )  ;", "}", "return   remote . getName (  )  ;", "}", "METHOD_END"], "methodName": ["inferRemoteInterfaceFromHome"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.HomeViewMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "String   home    =    null ;", "String   localHome    =    null ;", "if    (  !  ( MetadataCompleteMarker . isMetadataComplete ( Unit )  )  )     {", "final   EEModuleClassDescription   clazz    =    applicationClasses . getClassByName ( description . getComponentClassName (  )  )  ;", "if    ( clazz    !  =    null )     {", "final   ClassAnnotationInformation < LocalHome ,    String >    localAnnotations    =    clazz . getAnnotationInformation ( LocalHome . class )  ;", "if    ( localAnnotations    !  =    null )     {", "if    (  !  ( localAnnotations . getClassLevelAnnotations (  )  . isEmpty (  )  )  )     {", "localHome    =    localAnnotations . getClassLevelAnnotations (  )  . get (  0  )  ;", "if    (  ( description . getEjbLocalView (  )  )     =  =    null )     {", "final   String   localClassName    =    this . inferLocalInterfaceFromLocalHome ( localHome ,    module ,    ReflectionIndex ,    description )  ;", "description . addEjbLocalObjectView ( localClassName )  ;", "}", "}", "}", "final   ClassAnnotationInformation < RemoteHome ,    String >    remoteAnnotations    =    clazz . getAnnotationInformation ( RemoteHome . class )  ;", "if    ( remoteAnnotations    !  =    null )     {", "if    (  !  ( remoteAnnotations . getClassLevelAnnotations (  )  . isEmpty (  )  )  )     {", "home    =    remoteAnnotations . getClassLevelAnnotations (  )  . get (  0  )  ;", "if    (  ( description . getEjbRemoteView (  )  )     =  =    null )     {", "final   String   remoteClassName    =    this . inferRemoteInterfaceFromHome ( home ,    module ,    ReflectionIndex ,    description )  ;", "description . addEjbObjectView ( remoteClassName )  ;", "}", "}", "}", "}", "}", "final   SessionBeanMetaData   descriptorData    =    description . getDescriptorData (  )  ;", "if    ( descriptorData    !  =    null )     {", "if    (  ( descriptorData . getHome (  )  )     !  =    null )     {", "home    =    descriptorData . getHome (  )  ;", "}", "if    (  ( descriptorData . getLocalHome (  )  )     !  =    null )     {", "localHome    =    descriptorData . getLocalHome (  )  ;", "}", "}", "if    ( localHome    !  =    null )     {", "description . addLocalHome ( localHome )  ;", "}", "if    ( home    !  =    null )     {", "description . addRemoteHome ( home )  ;", "}", "if    (  (  ( description . getEjbHomeView (  )  )     !  =    null )     &  &     (  ( description . getEjbRemoteView (  )  )     =  =    null )  )     {", "final   String   remoteClassName    =    this . inferRemoteInterfaceFromHome ( description . getEjbHomeView (  )  . getViewClassName (  )  ,    module ,    ReflectionIndex ,    description )  ;", "description . addEjbObjectView ( remoteClassName )  ;", "}", "if    (  (  ( description . getEjbLocalHomeView (  )  )     !  =    null )     &  &     (  ( description . getEjbLocalView (  )  )     =  =    null )  )     {", "final   String   localClassName    =    this . inferLocalInterfaceFromLocalHome ( description . getEjbLocalHomeView (  )  . getViewClassName (  )  ,    module ,    ReflectionIndex ,    description )  ;", "description . addEjbLocalObjectView ( localClassName )  ;", "}", "}", "METHOD_END"], "methodName": ["processComponentConfig"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.HomeViewMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( final   MethodMetaData   method    :    excludeList . getMethods (  )  )     {", "final   String   methodName    =    method . getMethodName (  )  ;", "final   MethodIntf   defaultMethodIntf    =     ( componentDescription   instanceof   MessageDrivenComponentDescription )     ?    MethodIntf . MESSAGE _ ENDPOINT    :    MethodIntf . BEAN ;", "final   MethodIntf   methodIntf    =    this . getMethodIntf ( method . getMethodIntf (  )  ,    defaultMethodIntf )  ;", "if    ( methodName . equals (  \"  *  \"  )  )     {", "componentDescription . getDescriptor (  )  . setAttribute ( methodIntf ,    null ,    EJBMethodSecurityAttribute . denyAll (  )  )  ;", "} else    {", "final   MethodParametersMetaData   methodParams    =    method . getMethodParams (  )  ;", "if    ( methodParams    =  =    null )     {", "componentDescription . getDescriptor (  )  . setAttribute ( methodIntf ,    EJBMethodSecurityAttribute . denyAll (  )  ,    methodName )  ;", "} else    {", "componentDescription . getDescriptor (  )  . setAttribute ( methodIntf ,    EJBMethodSecurityAttribute . denyAll (  )  ,    null ,    methodName ,    this . getMethodParams ( methodParams )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleExcludeMethods"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.MethodPermissionsMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( final   MethodPermissionMetaData   methodPermissionMetaData    :    methodPermissions )     {", "final   MethodsMetaData   methods    =    methodPermissionMetaData . getMethods (  )  ;", "for    ( final   MethodMetaData   method    :    methods )     {", "EJBMethodSecurityAttribute   ejbMethodSecurityMetaData ;", "if    ( methodPermissionMetaData . isNotChecked (  )  )     {", "ejbMethodSecurityMetaData    =    EJBMethodSecurityAttribute . permitAll (  )  ;", "} else    {", "ejbMethodSecurityMetaData    =    EJBMethodSecurityAttribute . rolesAllowed ( methodPermissionMetaData . getRoles (  )  )  ;", "}", "final   String   methodName    =    method . getMethodName (  )  ;", "final   MethodIntf   defaultMethodIntf    =     ( componentDescription   instanceof   MessageDrivenComponentDescription )     ?    MethodIntf . MESSAGE _ ENDPOINT    :    MethodIntf . BEAN ;", "final   MethodIntf   methodIntf    =    this . getMethodIntf ( method . getMethodIntf (  )  ,    defaultMethodIntf )  ;", "if    ( methodName . equals (  \"  *  \"  )  )     {", "final   EJBMethodSecurityAttribute   existingRoles    =    componentDescription . getDescriptor (  )  . getAttributeStyle 1  ( methodIntf ,    null )  ;", "ejbMethodSecurityMetaData    =    mergeExistingRoles ( ejbMethodSecurityMetaData ,    existingRoles )  ;", "componentDescription . getDescriptor (  )  . setAttribute ( methodIntf ,    null ,    ejbMethodSecurityMetaData )  ;", "} else    {", "final   MethodParametersMetaData   methodParams    =    method . getMethodParams (  )  ;", "if    ( methodParams    =  =    null )     {", "final   EJBMethodSecurityAttribute   existingRoles    =    componentDescription . getDescriptor (  )  . getAttributeStyle 2  ( methodIntf ,    methodName )  ;", "ejbMethodSecurityMetaData    =    mergeExistingRoles ( ejbMethodSecurityMetaData ,    existingRoles )  ;", "componentDescription . getDescriptor (  )  . setAttribute ( methodIntf ,    ejbMethodSecurityMetaData ,    methodName )  ;", "} else    {", "final   EJBMethodSecurityAttribute   existingRoles    =    componentDescription . getDescriptor (  )  . getAttributeStyle 3  ( methodIntf ,    null ,    methodName ,    this . getMethodParams ( methodParams )  )  ;", "ejbMethodSecurityMetaData    =    mergeExistingRoles ( ejbMethodSecurityMetaData ,    existingRoles )  ;", "componentDescription . getDescriptor (  )  . setAttribute ( methodIntf ,    ejbMethodSecurityMetaData ,    null ,    methodName ,    this . getMethodParams ( methodParams )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleMethodPermissions"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.MethodPermissionsMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( existingRoles    !  =    null )     &  &     (  !  ( existingRoles . getRolesAllowed (  )  . isEmpty (  )  )  )  )     {", "final   Set < String >    roles    =    new   HashSet < String >  ( existingRoles . getRolesAllowed (  )  )  ;", "roles . addAll ( ejbSecurityMetaData . getRolesAllowed (  )  )  ;", "ejbSecurityMetaData    =    EJBSecurityAttribute . rolesAllowed ( roles )  ;", "}", "return   ejbSecurityMetaData ;", "}", "METHOD_END"], "methodName": ["mergeExistingRoles"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.MethodPermissionsMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "return   denyAccessByDefault ;", "}", "METHOD_END"], "methodName": ["isDenyAccessByDefault"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.MissingMethodPermissionsDenyAccessMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "this . denyAccessByDefault    =    denyAccessByDefault ;", "}", "METHOD_END"], "methodName": ["setDenyAccessByDefault"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.MissingMethodPermissionsDenyAccessMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeAnnotationInformation < Boolean >    removeMethods    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    Remove . class )  ;", "for    ( Map . Entry < Method ,    List < Boolean >  >    entry    :    removeMethods . getMethodAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "final   Boolean   retainIfException    =    entry . getValue (  )  . get (  0  )  ;", "final   MethodIdentifier   removeMethodIdentifier    =    MethodIdentifier . getIdentifierForMethod ( entry . getKey (  )  )  ;", "componentConfiguration . add ( removeMethodIdentifier ,    retainIfException )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleAnnotations"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.RemoveMethodMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "SessionBeanMetaData   beanMetaData    =    componentConfiguration . getDescriptorData (  )  ;", "if    ( beanMetaData    =  =    null )     {", "return ;", "}", "if    (  (  ( beanMetaData . getRemoveMethods (  )  )     =  =    null )     |  |     ( beanMetaData . getRemoveMethods (  )  . isEmpty (  )  )  )     {", "return ;", "}", "final   DeploymentReflectionIndex   reflectionIndex    =    deploymentUnit . getAttachment ( REFLECTION _ INDEX )  ;", "final   Set < MethodIdentifier >    annotationRemoveMethods    =    new   HashSet < MethodIdentifier >  (  )  ;", "for    ( final   StatefulComponentDescription . StatefulRemoveMethod   method    :    componentConfiguration . getRemoveMethods (  )  )     {", "annotationRemoveMethods . add ( method . getMethodIdentifier (  )  )  ;", "}", "for    ( final   taData   removeMethod    :    beanMetaData . getRemoveMethods (  )  )     {", "if    (  ( removeMethod . getBeanMethod (  )  . getMethodParams (  )  )     =  =    null )     {", "final   NamedMethodMetaData   methodData    =    removeMethod . getBeanMethod (  )  ;", "final   Collection < Method >    methods    =    MethodResolutionUtils . resolveMethods ( methodData ,    componentClass ,    reflectionIndex )  ;", "for    ( final   Method   method    :    methods )     {", "final   Boolean   retainIfException    =    removeMethod . getRetainIfException (  )  ;", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifierForMethod ( method )  ;", "if    ( retainIfException    =  =    null )     {", "if    (  !  ( annotationRemoveMethods . contains ( methodIdentifier )  )  )     {", "componentConfiguration . addRemoveMethod ( methodIdentifier ,    false )  ;", "}", "} else    {", "componentConfiguration . addRemoveMethod ( methodIdentifier ,    retainIfException )  ;", "}", "}", "}", "}", "for    ( final   taData   removeMethod    :    beanMetaData . getRemoveMethods (  )  )     {", "if    (  ( removeMethod . getBeanMethod (  )  . getMethodParams (  )  )     !  =    null )     {", "final   NamedMethodMetaData   methodData    =    removeMethod . getBeanMethod (  )  ;", "final   Collection < Method >    methods    =    MethodResolutionUtils . resolveMethods ( methodData ,    componentClass ,    reflectionIndex )  ;", "for    ( final   Method   method    :    methods )     {", "final   Boolean   retainIfException    =    removeMethod . getRetainIfException (  )  ;", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifierForMethod ( method )  ;", "if    ( retainIfException    =  =    null )     {", "if    (  !  ( annotationRemoveMethods . contains ( methodIdentifier )  )  )     {", "componentConfiguration . addRemoveMethod ( methodIdentifier ,    false )  ;", "}", "} else    {", "componentConfiguration . addRemoveMethod ( methodIdentifier ,    retainIfException )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleDeploymentDescriptor"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.RemoveMethodMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( configuredName . startsWith (  \"  #  \"  )  )  )     {", "return   configuredName ;", "}", "final   DeploymentUnit   parent    =    deploymentUnit . getParent (  )  ;", "if    ( parent    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . relativeerNameInStandaloneModule ( deploymentUnit . getName (  )  ,    componentClass . getName (  )  ,    configuredName )  ;", "}", "return   new   StringBuilder (  )  . append ( parent . getName (  )  )  . append ( configuredName )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["addEarPrefixIfRelativeName"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.ResourceAdaptorMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "String   securityDomain    =    null ;", "DeploymentUnit   parent    =    deploymentUnit . getParent (  )  ;", "if    ( parent    !  =    null )     {", "final   EarMetaData   jbossAppMetaData    =    parent . getAttachment ( EAR _ METADATA )  ;", "if    ( jbossAppMetaData   instanceof   JBossAppMetaData )     {", "securityDomain    =     (  ( JBossAppMetaData )     ( jbossAppMetaData )  )  . get (  )  ;", "}", "}", "return   securityDomain ;", "}", "METHOD_END"], "methodName": ["getJBossAppSecurityDomain"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.SecurityDomainMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( beanMetaData   instanceof   IScheduleTarget )     {", "IScheduleTarget   md    =     (  ( IScheduleTarget )     ( beanMetaData )  )  ;", "if    (  ( md . getTimers (  )  )     !  =    null )     {", "for    ( final   TimerMetaData   timer    :    md . getTimers (  )  )     {", "AutoTimer   autoTimer    =    new   AutoTimer (  )  ;", "autoTimer . getTimerConfig (  )  . setInfo ( timer . getInfo (  )  )  ;", "autoTimer . getTimerConfig (  )  . setPersistent ( timer . isPersistent (  )  )  ;", "final   ScheduleExpression   scheduleExpression    =    autoTimer . getScheduleExpression (  )  ;", "final   ScheduleMetaData   schedule    =    timer . getSchedule (  )  ;", "if    ( schedule    !  =    null )     {", "scheduleExpression . dayOfMonth ( schedule . getDayOfMonth (  )  )  ;", "scheduleExpression . dayOfWeek ( schedule . getDayOfWeek (  )  )  ;", "scheduleExpression . hour ( schedule . getHour (  )  )  ;", "scheduleExpression . minute ( schedule . getMinute (  )  )  ;", "scheduleExpression . month ( schedule . getMonth (  )  )  ;", "scheduleExpression . second ( schedule . getSecond (  )  )  ;", "scheduleExpression . year ( schedule . getYear (  )  )  ;", "}", "if    (  ( timer . getEnd (  )  )     !  =    null )     {", "scheduleExpression . end ( timer . getEnd (  )  . getTime (  )  )  ;", "}", "if    (  ( timer . getStart (  )  )     !  =    null )     {", "scheduleExpression . start ( timer . getStart (  )  . getTime (  )  )  ;", "}", "scheduleExpression . timezone ( timer . getTimezone (  )  )  ;", "sessionBean . addScheduleMethod ( MethodResolutionUtils . resolveMethod ( timer . getTimeoutMethod (  )  ,    componentClass ,    ReflectionIndex )  ,    autoTimer )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseScheduleMethods"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.TimerMethodMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   NamedMethodMetaData   methodData    =    beanMetaData . getTimeoutMethod (  )  ;", "sessionBean . setTimeoutMethod ( MethodResolutionUtils . resolveMethod ( methodData ,    componentClass ,    ReflectionIndex )  )  ;", "}", "METHOD_END"], "methodName": ["parseTimeoutMethod"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.TimerMethodMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeAnnotationInformation < TransactionAttributeType >    data    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    TransactionAttribute . class )  ;", "for    ( Map . Entry < String ,    List < TransactionAttributeType >  >    entry    :    data . getClassAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "final   String   className    =     ( methodIntf    =  =    null )     ?    entry . getKey (  )     :    null ;", "componentConfiguration . getTransactionAttributes (  )  . setAttribute ( methodIntf ,    className ,    entry . getValue (  )  . get (  0  )  )  ;", "}", "}", "for    ( Map . Entry < Method ,    List < TransactionAttributeType >  >    entry    :    data . getMethodAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "String [  ]    parameterTypes    =    MethodInfoHelper . getCanonicalParameterTypes ( entry . getKey (  )  )  ;", "componentConfiguration . getTransactionAttributes (  )  . setAttribute ( methodIntf ,    entry . getValue (  )  . get (  0  )  ,    entry . getKey (  )  . getDeclaringClass (  )  . getName (  )  ,    entry . getKey (  )  . getName (  )  ,    parameterTypes )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processTransactionAttributeAnnotation"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.TransactionAttributeMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeAnnotationInformation < Integer >    data    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    TransactionTimeout . class )  ;", "for    ( Map . Entry < String ,    List < Integer >  >    entry    :    data . getClassAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "final   String   className    =     ( methodIntf    =  =    null )     ?    entry . getKey (  )     :    null ;", "componentConfiguration . getTransactionTimeouts (  )  . setAttribute ( methodIntf ,    className ,    entry . getValue (  )  . get (  0  )  )  ;", "}", "}", "for    ( Map . Entry < Method ,    List < Integer >  >    entry    :    data . getMethodAnnotations (  )  . entrySet (  )  )     {", "if    (  !  ( entry . getValue (  )  . isEmpty (  )  )  )     {", "final   String   className    =    entry . getKey (  )  . getDeclaringClass (  )  . getName (  )  ;", "String [  ]    parameterTypes    =    MethodInfoHelper . getCanonicalParameterTypes ( entry . getKey (  )  )  ;", "componentConfiguration . getTransactionTimeouts (  )  . setAttribute ( methodIntf ,    entry . getValue (  )  . get (  0  )  ,    className ,    entry . getKey (  )  . getName (  )  ,    parameterTypes )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processTransactionTimeoutAnnotation"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.TransactionAttributeMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < TransactionTimeoutMetaData >    transactionTimeouts    =    containerTransaction . getAny ( TransactionTimeoutMetaData . class )  ;", "if    (  ( transactionTimeouts    =  =    null )     |  |     ( transactionTimeouts . isEmpty (  )  )  )", "return   null ;", "final   TransactionTimeoutMetaData   transactionTimeout    =    transactionTimeouts . get (  0  )  ;", "final   TimeUnit   unit    =     (  ( transactionTimeout . getUnit (  )  )     =  =    null )     ?    TimeUnit . SECONDS    :    transactionTimeout . getUnit (  )  ;", "return    (  ( int )     ( unit . toSeconds ( transactionTimeout . getTimeout (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["timeout"], "fileName": "org.jboss.as.ejb3.deployment.processors.merging.TransactionAttributeMergingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   parentDU    =    deploymentUnit . getParent (  )  ;", "ServiceName   jaccServiceName    =    deploymentUnit . getServiceName (  )  . append ( SERVICE _ NAME )  . append (  \" ejb \"  )  ;", "if    ( parentDU    !  =    null )     {", "jaccServiceName    =    jaccServiceName . append ( parentDU . getName (  )  )  ;", "}", "return   jaccServiceName ;", "}", "METHOD_END"], "methodName": ["getJaccServiceName"], "fileName": "org.jboss.as.ejb3.deployment.processors.security.JaccEjbDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "return   repositoryIds . clone (  )  ;", "}", "METHOD_END"], "methodName": ["_all_interfaces"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "if    (  ( interfaceDef )     !  =    null )", "return   interfaceDef ;", "else", "return   super .  _ get _ interface _ def (  )  ;", "}", "METHOD_END"], "methodName": ["_get_interface_def"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "EjbLogger . ROOT _ LOGGER . tracef (  \" EJBObject   invocation :     % s \"  ,    opName )  ;", "SkeletonStrategy   op    =    methodInvokerMap . get ( opName )  ;", "if    ( op    =  =    null )     {", "EjbLogger . ROOT _ LOGGER . debugf (  \" Unable   to   find   opname    '  % s '    valid   operations :  % s \"  ,    opName ,    methodInvokerMap . keySet (  )  )  ;", "throw   new   BAD _ OPERATION ( opName )  ;", "}", "final   NamespaceContextSelector   selector    =    componentView . getComponent (  )  . getNamespaceContextSelector (  )  ;", "final   ClassLoader   oldCl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "NamespaceContextSelector . pushCurrentSelector ( selector )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( classLoader )  ;", "OutputStream   out ;", "try    {", "Object   retVal ;", "if    (  (  !  ( home )  )     &  &     ( opName . equals (  \"  _ get _ handle \"  )  )  )     {", "retVal    =    new   HandleImplIIOP ( orb . object _ to _ string (  _ this _ object (  )  )  )  ;", "} else", "if    (  ( home )     &  &     ( opName . equals (  \"  _ get _ homeHandle \"  )  )  )     {", "retVal    =    homeHandle ;", "} else", "if    (  ( home )     &  &     ( opName . equals (  \"  _ get _ EJBMetaData \"  )  )  )     {", "retVal    =    ejbMetaData ;", "} else    {", "Principal   identityPrincipal    =    null ;", "Principal   principal    =    null ;", "Object   credential    =    null ;", "if    (  ( this . sasCurrent )     !  =    null )     {", "final   byte [  ]    incomingIdentity    =    this . sasCurrent . get _ incoming _ principal _ name (  )  ;", "if    (  ( incomingIdentity    !  =    null )     &  &     (  ( incomingIdentity . length )     >     0  )  )     {", "String   name    =    new   String ( incomingIdentity ,    UTF _  8  )  ;", "int   domainIndex    =    name . indexOf (  '  @  '  )  ;", "if    ( domainIndex    >     0  )", "name    =    name . substring (  0  ,    domainIndex )  ;", "identityPrincipal    =    new   NamePrincipal ( name )  ;", "}", "final   byte [  ]    incomingUsername    =    this . sasCurrent . get _ incoming _ username (  )  ;", "if    (  ( incomingUsername    !  =    null )     &  &     (  ( incomingUsername . length )     >     0  )  )     {", "final   byte [  ]    incomingPassword    =    this . sasCurrent . get _ incoming _ password (  )  ;", "String   name    =    new   String ( incomingUsername ,    UTF _  8  )  ;", "int   domainIndex    =    name . indexOf (  '  @  '  )  ;", "if    ( domainIndex    >     0  )     {", "name    =    name . substring (  0  ,    domainIndex )  ;", "}", "principal    =    new   NamePrincipal ( name )  ;", "credential    =    new   String ( incomingPassword ,    UTF _  8  )  . toCharArray (  )  ;", "}", "}", "final   Object [  ]    params    =    op . readParams (  (  ( InputStream )     ( in )  )  )  ;", "if    (  (  (  !  ( this . home )  )     &  &     ( opName . equals (  \" isIdentical \"  )  )  )     &  &     (  ( params . length )     =  =     1  )  )     {", "Object   val    =    params [  0  ]  ;", "retVal    =     ( val   instanceof   Object )     &  &     ( handleIsIdentical (  (  ( Object )     ( val )  )  )  )  ;", "} else    {", "if    (  ( this . securityDomain )     !  =    null )     {", "SecurityIdentity   identity    =    this . securityDomain . getAnonymousSecurityIdentity (  )  ;", "AuthenticationConfiguration   authenticationConfiguration    =    EMPTY ;", "if    ( identityPrincipal    !  =    null )     {", "if    ( principal    !  =    null )     {", "char [  ]    password    =     (  ( char [  ]  )     ( credential )  )  ;", "authenticationConfiguration    =    authenticationConfiguration . useName ( principal . getName (  )  )  . usePassword ( password )  ;", "SecurityIdentity   authenticatedIdentity    =    this . authenticate ( principal ,    password )  ;", "identity    =    authenticatedIdentity . createRunAsIdentity ( identityPrincipal . getName (  )  ,    true )  ;", "} else    {", "identity    =    this . securityDomain . getAnonymousSecurityIdentity (  )  . createRunAsIdentity ( identityPrincipal . getName (  )  ,    true )  ;", "}", "} else", "if    ( principal    !  =    null )     {", "char [  ]    password    =     (  ( char [  ]  )     ( credential )  )  ;", "authenticationConfiguration    =    authenticationConfiguration . useName ( principal . getName (  )  )  . usePassword ( password )  ;", "identity    =    this . authenticate ( principal ,    password )  ;", "}", "final   InterceptorContext   interceptorContext    =    new   InterceptorContext (  )  ;", "this . prepareInterceptorContext ( op ,    params ,    interceptorContext )  ;", "try    {", "final   AuthenticationContext   context    =    captureCurrent (  )  . with ( MatchRule . ALL . matchProtocol (  \" iiop \"  )  ,    authenticationConfiguration )  ;", "retVal    =    identity . runAs (  (  ( PrivilegedExceptionAction < Object >  )     (  (  )     -  >    context . run (  (  ( PrivilegedExceptionAction < Object >  )     (  (  )     -  >    this . componentView . invoke ( interceptorContext )  )  )  )  )  )  )  ;", "}    catch    ( PrivilegedActionException   e )     {", "throw   e . getCause (  )  ;", "}", "} else    {", "SecurityContext   legacyContext    =    null ;", "if    (  (  ( this . legacySecurityDomain )     !  =    null )     &  &     (  ( identityPrincipal    !  =    null )     |  |     ( principal    !  =    null )  )  )     {", "final   Object   finalCredential    =     ( identityPrincipal    !  =    null )     ?    this . sasCurrent    :    credential ;", "final   Principal   finalPrincipal    =     ( identityPrincipal    !  =    null )     ?    identityPrincipal    :    principal ;", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "legacyContext    =    doPrivileged (  (  ( PrivilegedExceptionAction < SecurityContext >  )     (  (  )     -  >     {", "SecurityContext   sc    =    createSecurityContext ( this . legacySecurityDomain )  ;", "sc . getUtil (  )  . createSubjectInfo ( finalPrincipal ,    finalCredential ,    null )  ;", "return   sc ;", "}  )  )  )  ;", "} else    {", "legacyContext    =    createSecurityContext ( this . legacySecurityDomain )  ;", "legacyContext . getUtil (  )  . createSubjectInfo ( finalPrincipal ,    finalCredential ,    null )  ;", "}", "}", "if    ( legacyContext    !  =    null )     {", ". setSecurityContextOnAssociation ( legacyContext )  ;", "}", "try    {", "final   InterceptorContext   interceptorContext    =    new   InterceptorContext (  )  ;", "if    ( legacyContext    !  =    null )     {", "interceptorContext . putPrivateData ( class ,    legacyContext )  ;", "}", "prepareInterceptorContext ( op ,    params ,    interceptorContext )  ;", "retVal    =    this . componentView . invoke ( interceptorContext )  ;", "}    finally    {", "if    ( legacyContext    !  =    null )     {", ". clearSecurityContextOnAssociation (  )  ;", "}", "}", "}", "}", "}", "out    =     (  ( OutputStream )     ( handler . createReply (  )  )  )  ;", "if    ( op . isNonVoid (  )  )     {", "op . writeRetval ( out ,    retVal )  ;", "}", "}    catch    ( Throwable   e )     {", "EjbLogger . ROOT _ LOGGER . trace (  \" Exception   in   EJBObject   invocation \"  ,    e )  ;", "if    ( e   instanceof   MBeanException )     {", "e    =     (  ( MBeanException )     ( e )  )  . getTargetException (  )  ;", "}", "RmiIdlUtil . rethrowIfCorbaSystemException ( e )  ;", "out    =     (  ( OutputStream )     ( handler . createExceptionReply (  )  )  )  ;", "op . writeException ( out ,    e )  ;", "}", "return   out ;", "}    finally    {", "NamespaceContextSelector . popCurrentSelector (  )  ;", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldCl )  ;", "}", "}", "METHOD_END"], "methodName": ["_invoke"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "final   ServerAuthenticationContext   context    =    this . securityDomain . createNewAuthenticationContext (  )  ;", "final   PasswordGuessEvidence   evidence    =    new   PasswordGuessEvidence (  ( credential    !  =    null    ?    credential    :    null )  )  ;", "try    {", "context . setAuthenticationPrincipal ( principal )  ;", "if    ( context . verifyEvidence ( evidence )  )     {", "if    ( context . authorize (  )  )     {", "context . succeed (  )  ;", "return   context . getAuthorizedIdentity (  )  ;", "} else    {", "context . fail (  )  ;", "throw   new   SecurityException (  \" Authorization   failed \"  )  ;", "}", "} else    {", "context . fail (  )  ;", "throw   new   SecurityException (  \" Authentication   failed \"  )  ;", "}", "}    catch    ( IllegalArgumentException    |    IllegalStateException    |    RealmUnavailableException   e )     {", "context . fail (  )  ;", "throw   e ;", "}    finally    {", "evidence . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["authenticate"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", "SecurityContextAssociation . clearSecurityContext (  )  ;", "return   null ;", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["clearSecurityContextOnAssociation"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "return   orb . object _ to _ string (  _ this _ object (  )  )  . equals ( orb . object _ to _ string ( val )  )  ;", "}", "METHOD_END"], "methodName": ["handleIsIdentical"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "EjbLogger . ROOT _ LOGGER . tracef (  \" EJBObject   local   invocation :     % s \"  ,    opName )  ;", "SkeletonStrategy   op    =    methodInvokerMap . get ( opName )  ;", "if    ( op    =  =    null )     {", "throw   new   BAD _ OPERATION ( opName )  ;", "}", "if    ( tx    !  =    null )     {", "transactionManager . resume ( tx )  ;", "}", "try    {", "final   InterceptorContext   interceptorContext    =    new   InterceptorContext (  )  ;", "prepareInterceptorContext ( op ,    arguments ,    interceptorContext )  ;", "return   componentView . invoke ( interceptorContext )  ;", "}    finally    {", "if    ( tx    !  =    null )     {", "if    (  ( transactionManager . getStatus (  )  )     !  =     ( Status . STATUS _ NO _ TRANSACTION )  )     {", "transactionManager . suspend (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( home )  )     {", "if    (  ( componentView . getComponent (  )  )    instanceof   StatefulSessionComponent )     {", "final   SessionID   sessionID    =     (  ( SessionID )     ( unmarshalIdentifier (  )  )  )  ;", "interceptorContext . putPrivateData ( SessionID . class ,    sessionID )  ;", "}", "}", "interceptorContext . setContextData ( new   HashMap (  )  )  ;", "interceptorContext . setParameters ( params )  ;", "interceptorContext . setMethod ( getMethod (  )  )  ;", "interceptorContext . putPrivateData ( ComponentView . class ,    componentView )  ;", "interceptorContext . putPrivateData ( Component . class ,    componentView . getComponent (  )  )  ;", "interceptorContext . putPrivateData ( InvocationType . class ,    REMOTE )  ;", "interceptorContext . setTransaction (  (  ( inboundTxCurrent )     =  =    null    ?    null    :    inboundTxCurrent . getCurrentTransaction (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["prepareInterceptorContext"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "this . ejbMetaData    =    ejbMetaData ;", "}", "METHOD_END"], "methodName": ["setEjbMetaData"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "this . homeHandle    =    homeHandle ;", "}", "METHOD_END"], "methodName": ["setHomeHandle"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", "SecurityContextAssociation . setSecurityContext ( sc )  ;", "return   null ;", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setSecurityContextOnAssociation"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "final   Object   id ;", "try    {", "final   byte [  ]    idData    =    poaCurre . get _ object _ id (  )  ;", "final   Unmarshaller   unmarshaller    =    factory . createUnmarshaller ( configuration )  ;", "unmarshaller . start ( new   InputStreamByteInput ( new   ByteArrayInputStream ( idData )  )  )  ;", "id    =    unmarshaller . readObject (  )  ;", "unmarshaller . finish (  )  ;", "}    catch    ( NoCoext   noCoext )     {", "throw   new   RuimeException ( noCoext )  ;", "}", "return   id ;", "}", "METHOD_END"], "methodName": ["unmarshalIdentifier"], "fileName": "org.jboss.as.ejb3.iiop.EjbCorbaServant"}, {"methodBody": ["METHOD_START", "{", "return   jndiName    +     \"  / remote \"  ;", "}", "METHOD_END"], "methodName": ["beanServantName"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   corbaNamingContext ;", "}", "METHOD_END"], "methodName": ["getCorbaNamingContext"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   ejbComponentInjectedValue ;", "}", "METHOD_END"], "methodName": ["getEjbComponentInjectedValue"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   homeView ;", "}", "METHOD_END"], "methodName": ["getHomeView"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   iorSecConfigMetaData ;", "}", "METHOD_END"], "methodName": ["getIORSecConfigMetaDataInjectedValue"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   irPoa ;", "}", "METHOD_END"], "methodName": ["getIrPoa"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   orb ;", "}", "METHOD_END"], "methodName": ["getOrb"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   poaRegistry ;", "}", "METHOD_END"], "methodName": ["getPoaRegistry"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   remoteView ;", "}", "METHOD_END"], "methodName": ["getRemoteView"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   serviceModuleLoaderInjectedValue ;", "}", "METHOD_END"], "methodName": ["getServiceModuleLoaderInjectedValue"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   transactionManagerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getTransactionManagerInjectedValue"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "final   Object   reference    =    referenceForLocator ( locator )  ;", "if    ( locator   instanceof   EJBHomeLocator )     {", "return   new   ejb . iiop . HomeHandleImplIIOP ( orb . getValue (  )  . object _ to _ string ( reference )  )  ;", "}", "return   new   ejb . iiop . HandleImplIIOP ( orb . getValue (  )  . object _ to _ string ( reference )  )  ;", "}", "METHOD_END"], "methodName": ["handleForLocator"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "return   jndiName    +     \"  / home \"  ;", "}", "METHOD_END"], "methodName": ["homeServantName"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "final   NameComponent [  ]    name    =    ctx . to _ name ( strName )  ;", "NamingContext   intmediateCtx    =    ctx ;", "for    ( int   i    =     0  ;    i    <     (  ( name . length )     -     1  )  ;    i +  +  )     {", "final   NameComponent [  ]    relativeName    =    new   NameComponent [  ]  {    name [ i ]     }  ;", "try    {", "intmediateCtx    =    NamingContextHelp . narrow ( intmediateCtx . resolve ( relativeName )  )  ;", "}    catch    ( NotFound   e )     {", "intmediateCtx    =    intmediateCtx . bind _ new _ context ( relativeName )  ;", "}", "}", "intmediateCtx . rebind ( new   NameComponent [  ]  {    name [  (  ( name . length )     -     1  )  ]     }  ,    obj )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "final   EJBComponent   ejbComponent    =    ejbComponentInjectedValue . getValue (  )  ;", "try    {", "final   String   earApplicationName    =     (  ( ejbComponent . getEarApplicationName (  )  )     =  =    null )     ?     \"  \"     :    ejbComponent . getEarApplicationName (  )  ;", "if    (  (  (  ( locator . getBeanName (  )  . equals ( ejbComponent . getComponentName (  )  )  )     &  &     ( locator . getAppName (  )  . equals ( earApplicationName )  )  )     &  &     ( locator . getModuleName (  )  . equals ( ejbComponent . getModuleName (  )  )  )  )     &  &     ( locator . getDistinctName (  )  . equals ( ejbComponent . getDistinctName (  )  )  )  )     {", "if    ( locator   instanceof   EJBHomeLocator )     {", "return    (  ( Object )     ( ejbHome )  )  ;", "} else", "if    ( locator   instanceof   ejb . client . StatelessEJBLocator )     {", "return   beanReferenceFactory . createReference ( beanRepositoryIds [  0  ]  )  ;", "} else", "if    ( locator   instanceof   ejb . client . StatefulEJBLocator )     {", "final   marshalling . Marshaller   marshaller    =    factory . createMarshaller ( configuration )  ;", "final   ByteArrayOutputStream   stream    =    new   ByteArrayOutputStream (  )  ;", "marshaller . start ( new   marshalling . OutputStreamByteOutput ( stream )  )  ;", "marshaller . writeObject (  (  ( ejb . client . StatefulEJBLocator <  ?  >  )     ( locator )  )  . getSessionId (  )  )  ;", "marshaller . finish (  )  ;", "return   beanReferenceFactory . createReferenceWithId ( stream . toByteArray (  )  ,    beanRepositoryIds [  0  ]  )  ;", "} else", "if    ( locator   instanceof   ejb . client . EntityEJBLocator )     {", "final   marshalling . Marshaller   marshaller    =    factory . createMarshaller ( configuration )  ;", "final   ByteArrayOutputStream   stream    =    new   ByteArrayOutputStream (  )  ;", "marshaller . start ( new   marshalling . OutputStreamByteOutput ( stream )  )  ;", "marshaller . writeObject (  (  ( ejb . client . EntityEJBLocator <  ?  >  )     ( locator )  )  . getPrimaryKey (  )  )  ;", "marshaller . finish (  )  ;", "return   beanReferenceFactory . createReferenceWithId ( stream . toByteArray (  )  ,    beanRepositoryIds [  0  ]  )  ;", "}", "throw   EjbLogger . ROOT _ LOGGER . unknownEJBLocatorType ( locator )  ;", "} else    {", "throw   EjbLogger . ROOT _ LOGGER . incorrectEJBLocatorForBean ( locator ,    ejbComponent . getComponentName (  )  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   EjbLogger . ROOT _ LOGGER . couldNotCreateCorbaObject ( e ,    locator )  ;", "}", "}", "METHOD_END"], "methodName": ["referenceForLocator"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   RiverMarshallerFactory   factory    =    new   RiverMarshallerFactory (  )  ;", "final   MarshallingConfiguration   configuration    =    new   MarshallingConfiguration (  )  ;", "configuration . setClassResolver ( ModularClassResolver . getInstance ( serviceModuleLoaderInjectedValue . getValue (  )  )  )  ;", "this . configuration    =    configuration ;", "this . factory    =    factory ;", "final   TransactionManager   jtsTransactionManager    =    transactionManagerInjectedValue . getValue (  )  . getTransactionManager (  )  ;", "assert    !  ( jtsTransactionManager   instanceof   ContextTransactionManager )  ;", "final   boolean   interfaceRepositorySupported    =    false ;", "final   EJBComponent   component    =    ejbComponentInjectedValue . getValue (  )  ;", "final   String   earApplicationName    =    component . getEarApplicationName (  )  ;", "if    (  (  ( iiopMetaData )     !  =    null )     &  &     (  ( iiopMetaData . getBindingName (  )  )     !  =    null )  )     {", "name    =    iiopMetaData . getBindingName (  )  ;", "} else", "if    ( useQualifiedName )     {", "if    (  (  ( component . getDistinctName (  )  )     =  =    null )     |  |     ( component . getDistinctName (  )  . isEmpty (  )  )  )     {", "name    =     (  ( earApplicationName    =  =    null )     |  |     ( earApplicationName . isEmpty (  )  )  )     ?     \"  \"     :    earApplicationName    +     \"  /  \"  ;", "name    =     (  (  ( name )     +     ( component . getModuleName (  )  )  )     +     \"  /  \"  )     +     ( component . getComponentName (  )  )  ;", "} else    {", "name    =     (  ( earApplicationName    =  =    null )     |  |     ( earApplicationName . isEmpty (  )  )  )     ?     \"  \"     :    earApplicationName    +     \"  /  \"  ;", "name    =     (  (  (  (  ( name )     +     ( component . getModuleName (  )  )  )     +     \"  /  \"  )     +     ( component . getDistinctName (  )  )  )     +     \"  /  \"  )     +     ( component . getComponentName (  )  )  ;", "}", "} else    {", "name    =    component . getComponentName (  )  ;", "}", "name    =    name . replace (  \"  .  \"  ,     \"  _  \"  )  ;", "final   ORB   orb    =    this . orb . getValue (  )  ;", "if    ( interfaceRepositorySupported )     {", "iri    =    new   InterfaceRepository ( orb ,    irPoa . getValue (  )  ,    name )  ;", "iri . mapClass ( remoteView . getValue (  )  . getViewClass (  )  )  ;", "iri . mapClass ( homeView . getValue (  )  . getViewClass (  )  )  ;", "iri . finishBuild (  )  ;", "EjbLogger . ROOT _ LOGGER . cobraInterfaceRepository ( name ,    orb . object _ to _ string ( iri . getReference (  )  )  )  ;", "}", "IORSecurityConfigMetaData   iorSecurityConfigMetaData    =    this . iorSecConfigMetaData . getOptionalValue (  )  ;", "if    (  (  ( this . iiopMetaData )     !  =    null )     &  &     (  ( this . iiopMetaData . getIorSecurityConfigMetaData (  )  )     !  =    null )  )", "iorSecurityConfigMetaData    =    this . iiopMetaData . getIorSecurityConfigMetaData (  )  ;", "List < Policy >    policyList    =    new   ArrayList < Policy >  (  )  ;", "if    ( iorSecurityConfigMetaData    !  =    null )     {", "final   Any   secPolicy    =    orb . create _ any (  )  ;", "secPolicy . insert _ Value ( iorSecurityConfigMetaData )  ;", "Policy   csiv 2 Policy    =    orb . create _ policy ( TYPE ,    secPolicy )  ;", "policyList . add ( csiv 2 Policy )  ;", "boolean   sslRequired    =    false ;", "if    (  ( iorSecurityConfigMetaData    !  =    null )     &  &     (  ( iorSecurityConfigMetaData . getTransportConfig (  )  )     !  =    null )  )     {", "IORTransportConfigMetaData   tc    =    iorSecurityConfigMetaData . getTransportConfig (  )  ;", "sslRequired    =     (  ( INTEGRITY _ REQUIRED . equals ( tc . getIntegrity (  )  )  )     |  |     ( CONFIDENTIALITY _ REQUIRED . equals ( tc . getConfidentiality (  )  )  )  )     |  |     ( ESTABLISH _ TRUST _ IN _ CLIENT _ REQUIRED . equals ( tc . getEstablishTrustInClient (  )  )  )  ;", "}", "if    ( sslRequired )     {", "policyList . add ( ZeroPortPolicy . getPolicy (  )  )  ;", "}", "}", "String   securityDomain    =     \" CORBA _ REMOTE \"  ;", "if    (  ( component . getSecurityMetaData (  )  )     !  =    null )     {", "securityDomain    =    component . getSecurityMetaData (  )  . getSecurityDomain (  )  ;", "}", "Policy [  ]    policies    =    policyList . toArray ( new   Policy [ policyList . size (  )  ]  )  ;", "InterfaceDef   homeInterfaceDef    =    null ;", "if    (  ( iri )     !  =    null )     {", "Repository   ir    =    iri . getReference (  )  ;", "homeInterfaceDef    =    InterfaceDefHelper . narrow ( ir . lookup _ id ( homeRepositoryIds [  0  ]  )  )  ;", "}", "Current   poaCurrent    =    CurrentHelper . narrow ( orb . resolve _ initial _ references (  \" POACurrent \"  )  )  ;", "final   EjbCorbaServant   homeServant    =    new   EjbCorbaServant ( poaCurrent ,    homeMethodMap ,    homeRepositoryIds ,    homeInterfaceDef ,    orb ,    homeView . getValue (  )  ,    factory ,    configuration ,    jtsTransactionManager ,    module . getClassLoader (  )  ,    true ,    securityDomain ,    component . getSecurityDomain (  )  )  ;", "homeServantRegistry    =    poaRegistry . getValue (  )  . getRegistryWithPersistentPOAPerServant (  )  ;", "ReferenceFactory   homeReferenceFactory    =    homeServantRegistry . bind (  . homeServantName ( name )  ,    homeServant ,    policies )  ;", "final   Object   corbaRef    =    homeReferenceFactory . createReference ( homeRepositoryIds [  0  ]  )  ;", "ejbHome    =     (  ( EJBHome )     ( PortableRemoteObject . narrow ( corbaRef ,    EJBHome . class )  )  )  ;", "final   HomeHandleImplIIOP   homeHandle    =    new   HomeHandleImplIIOP ( orb . object _ to _ string ( corbaRef )  )  ;", "homeServant . setHomeHandle ( homeHandle )  ;", "beanServantRegistry    =    poaRegistry . getValue (  )  . getRegistryWithTransientPOAPerServant (  )  ;", "if    ( component   instanceof   StatelessSessionComponent )     {", "ejbMetaData    =    new   EJBMetaDataImplIIOP ( remoteView . getValue (  )  . getViewClass (  )  ,    homeView . getValue (  )  . getViewClass (  )  ,    null ,    true ,    true ,    homeHandle )  ;", "} else    {", "ejbMetaData    =    new   EJBMetaDataImplIIOP ( remoteView . getValue (  )  . getViewClass (  )  ,    homeView . getValue (  )  . getViewClass (  )  ,    null ,    true ,    false ,    homeHandle )  ;", "}", "homeServant . setEjbMetaData ( ejbMetaData )  ;", "InterfaceDef   beanInterfaceDef    =    null ;", "if    (  ( iri )     !  =    null )     {", "final   Repository   ir    =    iri . getReference (  )  ;", "beanInterfaceDef    =    InterfaceDefHelper . narrow ( ir . lookup _ id ( beanRepositoryIds [  0  ]  )  )  ;", "}", "final   EjbCorbaServant   beanServant    =    new   EjbCorbaServant ( poaCurrent ,    beanMethodMap ,    beanRepositoryIds ,    beanInterfaceDef ,    orb ,    remoteView . getValue (  )  ,    factory ,    configuration ,    jtsTransactionManager ,    module . getClassLoader (  )  ,    false ,    securityDomain ,    component . getSecurityDomain (  )  )  ;", "beanReferenceFactory    =    beanServantRegistry . bind (  . beanServantName ( name )  ,    beanServant ,    policies )  ;", ". rebind ( corbaNamingContext . getValue (  )  ,    name ,    corbaRef )  ;", "EjbLogger . ROOT _ LOGGER . debugf (  \" Home   IOR   for    % s   bound   to    % s   in   CORBA   naming   service \"  ,    component . getComponentName (  )  ,    this . name )  ;", "final   ClassLoader   cl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( module . getClassLoader (  )  )  ;", "try    {", "DynamicStubFactoryFactory . makeStubClass ( homeView . getValue (  )  . getViewClass (  )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . ROOT _ LOGGER . dynamicStubCreationFailed ( homeView . getValue (  )  . getViewClass (  )  . getName (  )  ,    e )  ;", "}", "try    {", "DynamicStubFactoryFactory . makeStubClass ( remoteView . getValue (  )  . getViewClass (  )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . ROOT _ LOGGER . dynamicStubCreationFailed ( remoteView . getValue (  )  . getViewClass (  )  . getName (  )  ,    e )  ;", "}", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( cl )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   StartException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.iiop.EjbIIOPService"}, {"methodBody": ["METHOD_START", "{", "Policy [  ]    policies    =    new   Policy [  ( policies 1  . length )     +     ( policies 2  . length )  ]  ;", "int   j    =     0  ;", "f    ( int   i    =     0  ;    i    <     ( policies 1  . length )  ;    i +  +     ,    j +  +  )     {", "policies [ j ]     =    policies 1  [ i ]  ;", "}", "f    ( int   i    =     0  ;    i    <     ( policies 2  . length )  ;    i +  +     ,    j +  +  )     {", "policies [ j ]     =    policies 2  [ i ]  ;", "}", "return   policies ;", "}", "METHOD_END"], "methodName": ["concatPolicies"], "fileName": "org.jboss.as.ejb3.iiop.POARegistry"}, {"methodBody": ["METHOD_START", "{", "return   registryWithPersistentPOAPerServant ;", "}", "METHOD_END"], "methodName": ["getRegistryWithPersistentPOAPerServant"], "fileName": "org.jboss.as.ejb3.iiop.POARegistry"}, {"methodBody": ["METHOD_START", "{", "return   registryWithTransientPOAPerServant ;", "}", "METHOD_END"], "methodName": ["getRegistryWithTransientPOAPerServant"], "fileName": "org.jboss.as.ejb3.iiop.POARegistry"}, {"methodBody": ["METHOD_START", "{", "return   rootPOA ;", "}", "METHOD_END"], "methodName": ["getRootPOA"], "fileName": "org.jboss.as.ejb3.iiop.POARegistry"}, {"methodBody": ["METHOD_START", "{", "transientPoaMap    =    Collections . synchronizedMap ( new   HashMap < String ,    POA >  (  )  )  ;", "persistentPoaMap    =    Collections . synchronizedMap ( new   HashMap < String ,    POA >  (  )  )  ;", "final   POA   rootPOA    =    this . rootPOA . getValue (  )  ;", "transientPoaPolicies    =    new   Policy [  ]  {    rootPOA . create _ lifespan _ policy ( LifespanPolicyValue . TRANSIENT )  ,    rootPOA . create _ id _ assignment _ policy ( IdAssignmentPolicyValue . SYSTEM _ ID )  ,    rootPOA . create _ servant _ retention _ policy ( ServantRetentionPolicyValue . NON _ RETAIN )  ,    rootPOA . create _ request _ processing _ policy ( RequestProcessingPolicyValue . USE _ DEFAULT _ SERVANT )  ,    rootPOA . create _ id _ uniqueness _ policy ( IdUniquenessPolicyValue . MULTIPLE _ ID )     }  ;", "persistentPoaPolicies    =    new   Policy [  ]  {    rootPOA . create _ lifespan _ policy ( LifespanPolicyValue . PERSISTENT )  ,    rootPOA . create _ id _ assignment _ policy ( IdAssignmentPolicyValue . USER _ ID )  ,    rootPOA . create _ servant _ retention _ policy ( ServantRetentionPolicyValue . NON _ RETAIN )  ,    rootPOA . create _ request _ processing _ policy ( RequestProcessingPolicyValue . USE _ DEFAULT _ SERVANT )  ,    rootPOA . create _ id _ uniqueness _ policy ( IdUniquenessPolicyValue . MULTIPLE _ ID )     }  ;", "registryWithTransientPOAPerServant    =    new    . ServantRegistryWithTransientPOAPerServant (  )  ;", "registryWithPersistentPOAPerServant    =    new    . ServantRegistryWithPersistentPOAPerServant (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.iiop.POARegistry"}, {"methodBody": ["METHOD_START", "{", "transientPoaMap    =    null ;", "persentPoaMap    =    null ;", "transientPoaPolicies    =    null ;", "persentPoaPolicies    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ejb3.iiop.POARegistry"}, {"methodBody": ["METHOD_START", "{", "EJBLocator <  ?    extends   Object >    locator ;", "try    {", "locator    =    EJBClient . getLocatorFor ( object )  ;", "}    catch    ( Exception   e )     {", "locator    =    null ;", "}", "if    ( locator    !  =    null )     {", "final   EjbIIOP   factory    =    serviceForLocator ( locator ,    deploymentRepository )  ;", "if    ( factory    !  =    null )     {", "return   factory . referenceForLocator ( locator )  ;", "}", "}", "return   object ;", "}", "METHOD_END"], "methodName": ["createIIOPReferenceForBean"], "fileName": "org.jboss.as.ejb3.iiop.RemoteObjectSubstitutionService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentRepositoryInjectedValue ;", "}", "METHOD_END"], "methodName": ["getDeploymentRepositoryInjectedValue"], "fileName": "org.jboss.as.ejb3.iiop.RemoteObjectSubstitutionService"}, {"methodBody": ["METHOD_START", "{", "final   ModuleDeployment   module    =    deploymentRepository . getModules (  )  . get ( new   DeploymentModuleIdentifier ( locator . getAppName (  )  ,    locator . getModuleName (  )  ,    locator . getDistinctName (  )  )  )  ;", "if    ( module    =  =    null )     {", "EjbLogger . ROOT _ LOGGER . couldNotFindEjbForLocatorIIOP ( locator )  ;", "return   null ;", "}", "final   EjbDeploymentInformation   ejb    =    module . getEjbs (  )  . get ( locator . getBeanName (  )  )  ;", "if    ( ejb    =  =    null )     {", "EjbLogger . ROOT _ LOGGER . couldNotFindEjbForLocatorIIOP ( locator )  ;", "return   null ;", "}", "final   EjbIIOP   factory    =    ejb . getIorFactory (  )  ;", "if    ( factory    =  =    null )     {", "EjbLogger . ROOT _ LOGGER . ejbNotExposedOverIIOP ( locator )  ;", "return   null ;", "}", "return   factory ;", "}", "METHOD_END"], "methodName": ["serviceForLocator"], "fileName": "org.jboss.as.ejb3.iiop.RemoteObjectSubstitutionService"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   InitialContext   ctx    =    new   InitialContext (  )  ;", "return    (  (  )     ( ctx . lookup (  \" java : comp /  \"  )  )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.jboss.as.ejb3.iiop.handle.HandleDelegateImpl"}, {"methodBody": ["METHOD_START", "{", "final   Object   ejbHome    =    proxy . read ( oistream )  ;", "reconnect ( ejbHome )  ;", "return    (  ( EJBHome )     ( PortableRemoteObject . narrow ( ejbHome ,    EJBHome . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["readEJBHome"], "fileName": "org.jboss.as.ejb3.iiop.handle.HandleDelegateImpl"}, {"methodBody": ["METHOD_START", "{", "final   Object   ejbObject    =    proxy . read ( oistream )  ;", "reconnect ( ejbObject )  ;", "return    (  ( EJBObject )     ( PortableRemoteObject . narrow ( ejbObject ,    EJBObject . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["readEJBObject"], "fileName": "org.jboss.as.ejb3.iiop.handle.HandleDelegateImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( object   instanceof   ObjectImpl )     {", "try    {", "ObjectImpl   objectImpl    =     (  ( ObjectImpl )     ( object )  )  ;", "objectImpl .  _ get _ d (  )  ;", "}    catch    ( BAD _ OPERATION   e )     {", "try    {", "final   Stub   stub    =     (  ( Stub )     ( object )  )  ;", "final   ORB   orb    =     (  ( ORB )     ( new   InitialContext (  )  . lookup (  \" java : comp / ORB \"  )  )  )  ;", "stub . connect ( orb )  ;", "}    catch    ( NamingException   ne )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToLookupORB (  )  ;", "}", "}", "} else    {", "throw   EjbLogger . ROOT _ LOGGER . notAnObjectImpl ( object . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["reconnect"], "fileName": "org.jboss.as.ejb3.iiop.handle.HandleDelegateImpl"}, {"methodBody": ["METHOD_START", "{", "oostream . writeObject ( ejbHome )  ;", "}", "METHOD_END"], "methodName": ["writeEJBHome"], "fileName": "org.jboss.as.ejb3.iiop.handle.HandleDelegateImpl"}, {"methodBody": ["METHOD_START", "{", "oostream . writeObject ( ejbObject )  ;", "}", "METHOD_END"], "methodName": ["writeEJBObject"], "fileName": "org.jboss.as.ejb3.iiop.handle.HandleDelegateImpl"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz ;", "try    {", "clazz    =    loader . loadClass (  . NAME )  ;", "}    catch    ( ClassNotFoundException   e )     {", "try    {", "final   ClassFile   file    =    new   ClassFile (  . NAME ,     . class . getName (  )  )  ;", "final   ClassMethod   method    =    file . addMethod ( Modifier . PUBLIC ,     \" read \"  ,     \" Ljava / lang / Object ;  \"  ,     \" Ljava / io / ObjectInputStream ;  \"  )  ;", "final   CodeAttribute   codeAttribute    =    method . getCodeAttribute (  )  ;", "codeAttribute . aload (  1  )  ;", "codeAttribute . invokevirtual (  \" java / io / ObjectInputStream \"  ,     \" readObject \"  ,     \"  (  ) Ljava / lang / Object ;  \"  )  ;", "codeAttribute . returnInstruction (  )  ;", "ClassMethod   ctor    =    file . addMethod ( Modifier . PUBLIC ,     \"  < init >  \"  ,     \" V \"  )  ;", "ctor . getCodeAttribute (  )  . aload (  0  )  ;", "ctor . getCodeAttribute (  )  . invokespecial (  . class . getName (  )  ,     \"  < init >  \"  ,     \"  (  ) V \"  )  ;", "ctor . getCodeAttribute (  )  . returnInstruction (  )  ;", "clazz    =    file . define ( loader )  ;", "}    catch    ( RuntimeException   ex )     {", "try    {", "clazz    =    loader . loadClass (  . NAME )  ;", "}    catch    ( ClassNotFoundException   e 1  )     {", "throw   ex ;", "}", "}", "}", "try    {", "return    (  (  )     ( clazz . newInstance (  )  )  )  ;", "}    catch    ( InstantiationException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["proxy"], "fileName": "org.jboss.as.ejb3.iiop.handle.SerializationHackProxy"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.jboss.as.ejb3.iiop.handle.SerializationHackProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( operationName . equals (  \"  _ get _ handle \"  )  )     &  &     (  ( this )    instanceof   EJBObject )  )     {", "if    (  ( handle )     =  =    null )     {", "handle    =    new   HandleImplIIOP ( this )  ;", "}", "return   handle ;", "} else", "if    (  ( operationName . equals (  \"  _ get _ homeHandle \"  )  )     &  &     (  ( this )    instanceof   EJBHome )  )     {", "if    (  ( handle )     =  =    null )     {", "handle    =    new   HomeHandleImplIIOP ( this )  ;", "}", "return   handle ;", "} else    {", "InputStream   in    =    null ;", "try    {", "try    {", "OutputStream   out    =     (  ( OutputStream )     (  _ request ( operationName ,    true )  )  )  ;", "stubStrategy . writeParams ( out ,    params )  ;", "DynamicIIOPStub . tracef (  \" sent   request :     % s \"  ,    operationName )  ;", "in    =     (  ( InputStream )     (  _ invoke ( out )  )  )  ;", "if    ( stubStrategy . isNonVoid (  )  )     {", "DynamicIIOPStub . trace (  \" received   reply \"  )  ;", "final   InputStream   finalIn    =    in ;", "return   doPrivileged ( new   PrivilegedAction < Object >  (  )     {", "public   Object   run (  )     {", "return   stubStrategy . readRetval ( finalIn )  ;", "}", "}  )  ;", "} else    {", "return   null ;", "}", "}    catch    ( final   ApplicationException   ex )     {", "DynamicIIOPStub . trace (  \" got   application   exception \"  )  ;", "in    =     (  ( InputStream )     ( ex . getInputStream (  )  )  )  ;", "final   InputStream   finalIn 1     =    in ;", "throw   doPrivileged ( new   PrivilegedAction < Exception >  (  )     {", "public   Exception   run (  )     {", "return   stubStrategy . readException ( ex . getId (  )  ,    finalIn 1  )  ;", "}", "}  )  ;", "}    catch    ( RemarshalException   ex )     {", "DynamicIIOPStub . trace (  \" got   remarshal   exception \"  )  ;", "return   invoke ( operationName ,    stubStrategy ,    params )  ;", "}", "}    catch    ( SystemException   ex )     {", "if    ( logging . EjbLogger . EJB 3  _ INVOCATION _ LOGGER . isTraceEnabled (  )  )     {", "logging . EjbLogger . EJB 3  _ INVOCATION _ LOGGER . trace (  \" CORBA   system   exception   in   IIOP   stub \"  ,    ex )  ;", "}", "throw   mapSystemException ( ex )  ;", "}    finally    {", "_ releaseReply ( in )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Boolean )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . booleanValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeBoolean"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Number )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . byteValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeByte"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Character )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . charValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeChar"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Number )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . doubleValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeDouble"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Number )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . floatValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeFloat"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Number )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeInt"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Number )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . longValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeLong"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Number )     ( invoke ( operationName ,    stubStrategy ,    params )  )  )  . shortValue (  )  ;", "}", "METHOD_END"], "methodName": ["invokeShort"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "if    ( EjbLogger . EJB 3  _ INVOCATION _ LOGGER . isTraceEnabled (  )  )", "EjbLogger . EJB 3  _ INVOCATION _ LOGGER . trace ( msg )  ;", "}", "METHOD_END"], "methodName": ["trace"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "if    ( EjbLogger . EJB 3  _ INVOCATION _ LOGGER . isTraceEnabled (  )  )", "EjbLogger . EJB 3  _ INVOCATION _ LOGGER . tracef ( format ,    params )  ;", "}", "METHOD_END"], "methodName": ["tracef"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicIIOPStub"}, {"methodBody": ["METHOD_START", "{", "final   String   stubClassName    =    myClass    +     \"  _ Stub \"  ;", "ClassLoader   cl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "if    ( cl    =  =    null )     {", "cl    =    myClass . getClassLoader (  )  ;", "}", "if    ( cl    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . couldNotFindClassLoaderForStub ( stubClassName )  ;", "}", "Class <  ?  >    theClass ;", "try    {", "theClass    =    cl . loadClass ( stubClassName )  ;", "}    catch    ( ClassNotFoundException   e )     {", "try    {", "final   ClassFile   clazz    =    IIOPStubCompiler . compile ( myClass ,    stubClassName )  ;", "theClass    =    clazz . define ( cl ,    myClass . getProtectionDomain (  )  )  ;", "}    catch    ( Throwable   ex )     {", "try    {", "theClass    =    cl . loadClass ( stubClassName )  ;", "}    catch    ( ClassNotFoundException   e 1  )     {", "EjbLogger . ROOT _ LOGGER . dCreationFailed ( stubClassName ,    ex )  ;", "throw   ex ;", "}", "}", "}", "return   theClass ;", "}", "METHOD_END"], "methodName": ["makeStubClass"], "fileName": "org.jboss.as.ejb3.iiop.stub.DynamicStubFactoryFactory"}, {"methodBody": ["METHOD_START", "{", "InterfaceAnalysis   interfaceAnalysis    =    null ;", "try    {", "interfaceAnalysis    =    InterfaceAnalysis . getInterfaceAnalysis ( intf )  ;", "}    catch    ( RMIIIOPViolationException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . rmiIiopVoliation ( e . getLocalizedMessage (  )  )  ;", "}", "return    . makeCode ( interfaceAnalysis ,    DynamicIIOPStub . class ,    stubClassName )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.jboss.as.ejb3.iiop.stub.IIOPStubCompiler"}, {"methodBody": ["METHOD_START", "{", "return   IIOPStubCompiler . compile ( intf ,    stubClassName )  . define ( intf . getClassLoader (  )  ,    intf . getProtectionDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["compileToClass"], "fileName": "org.jboss.as.ejb3.iiop.stub.IIOPStubCompiler"}, {"methodBody": ["METHOD_START", "{", "final   ClassFile   asm    =    new   ClassFile ( stubClassName ,    superclass . getName (  )  ,    interfaceAnalysis . getCls (  )  . getName (  )  )  ;", "int   methodIndex    =     0  ;", "AttributeAnalysis [  ]    attrs    =    interfaceAnalysis . getAttributes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( attrs . length )  ;    i +  +  )     {", "OperationAnalysis   op    =    attrs [ i ]  . getAccessorAnalysis (  )  ;", ". generateMethodCode ( asm ,    superclass ,    op . getMethod (  )  ,    op . getIDLName (  )  ,     . strategy ( methodIndex )  ,     . init ( methodIndex )  )  ;", "methodIndex +  +  ;", "op    =    attrs [ i ]  . getMutatorAnalysis (  )  ;", "if    ( op    !  =    null )     {", ". generateMethodCode ( asm ,    superclass ,    op . getMethod (  )  ,    op . getIDLName (  )  ,     . strategy ( methodIndex )  ,     . init ( methodIndex )  )  ;", "methodIndex +  +  ;", "}", "}", "final   OperationAnalysis [  ]    ops    =    interfaceAnalysis . getOperations (  )  ;", "for    ( int   i    =     0  ;    i    <     ( ops . length )  ;    i +  +  )     {", ". generateMethodCode ( asm ,    superclass ,    ops [ i ]  . getMethod (  )  ,    ops [ i ]  . getIDLName (  )  ,     . strategy ( methodIndex )  ,     . init ( methodIndex )  )  ;", "methodIndex +  +  ;", "}", "final   ClassMethod   ctor    =    asm . addMethod ( Modifier . PUBLIC ,     \"  < init >  \"  ,     \" V \"  )  ;", "ctor . getCodeAttribute (  )  . aload (  0  )  ;", "ctor . getCodeAttribute (  )  . invokespecial ( superclass . getName (  )  ,     \"  < init >  \"  ,     \"  (  ) V \"  )  ;", "ctor . getCodeAttribute (  )  . returnInstruction (  )  ;", "final   String [  ]    ids    =    interfaceAnalysis . getAllTypeIds (  )  ;", "asm . addField (  (  ( Modifier . PRIVATE )     +     ( Modifier . STATIC )  )  ,     . ID _ FIELD _ NAME ,    String [  ]  . class )  ;", "final   CodeAttribute   idMethod    =    asm . addMethod (  (  ( Modifier . PUBLIC )     +     ( Modifier . FINAL )  )  ,     \"  _ ids \"  ,     \"  [ Ljava / lang / String ;  \"  )  . getCodeAttribute (  )  ;", "idMethod . getstatic ( stubClassName ,     . ID _ FIELD _ NAME ,     \"  [ Ljava / lang / String ;  \"  )  ;", "idMethod . returnInstruction (  )  ;", "final   CodeAttribute   clinit    =    asm . addMethod ( Modifier . STATIC ,     \"  < clinit >  \"  ,     \" V \"  )  . getCodeAttribute (  )  ;", "clinit . iconst ( ids . length )  ;", "clinit . anewarray ( String . class . getName (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( ids . length )  ;    i +  +  )     {", "clinit . dup (  )  ;", "clinit . iconst ( i )  ;", "clinit . ldc ( ids [ i ]  )  ;", "clinit . aastore (  )  ;", "}", "clinit . putstatic ( stubClassName ,     . ID _ FIELD _ NAME ,     \"  [ Ljava / lang / String ;  \"  )  ;", "int   n    =    methodIndex ;", "for    ( methodIndex    =     0  ;    methodIndex    <    n ;    methodIndex +  +  )     {", "clinit . invokestatic ( stubClassName ,     . init ( methodIndex )  ,     \"  (  ) V \"  )  ;", "}", "clinit . returnInstruction (  )  ;", "return   asm ;", "}", "METHOD_END"], "methodName": ["generateCode"], "fileName": "org.jboss.as.ejb3.iiop.stub.IIOPStubCompiler"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    returnType    =    m . getReturnType (  )  ;", "Class <  ?  >  [  ]    paramTypes    =    m . getParameterTypes (  )  ;", "Class <  ?  >  [  ]    exceptions    =    m . getExceptionTypes (  )  ;", "asm . addField (  (  ( Modifier . PRIVATE )     +     ( Modifier . STATIC )  )  ,    strategyField ,    StubStrategy . class )  ;", "final   CodeAttribute   ca    =    asm . addMethod ( m )  . getCodeAttribute (  )  ;", "ca . aload (  0  )  ;", "ca . ldc ( idlName )  ;", "ca . getstatic ( asm . getName (  )  ,    strategyField ,    StubStrategy . class )  ;", "if    (  ( paramTypes . length )     =  =     0  )     {", "ca . iconst (  0  )  ;", "ca . anewarray ( Object . class . getName (  )  )  ;", "} else    {", "ca . iconst ( paramTypes . length )  ;", "ca . anewarray ( Object . class . getName (  )  )  ;", "int   index    =     1  ;", "for    ( int   j    =     0  ;    j    <     ( paramTypes . length )  ;    j +  +  )     {", "Class <  ?  >    type    =    paramTypes [ j ]  ;", "ca . dup (  )  ;", "ca . iconst ( j )  ;", "if    (  !  ( type . isPrimitive (  )  )  )     {", "ca . aload ( index )  ;", "} else", "if    ( type . equals ( double . class )  )     {", "ca . dload ( index )  ;", "classfilewriter . util . Boxing . boxDouble ( ca )  ;", "index +  +  ;", "} else", "if    ( type . equals ( long . class )  )     {", "ca . lload ( index )  ;", "classfilewriter . util . Boxing . boxLong ( ca )  ;", "index +  +  ;", "} else", "if    ( type . equals ( float . class )  )     {", "ca . fload ( index )  ;", "classfilewriter . util . Boxing . boxFloat ( ca )  ;", "} else    {", "ca . iload ( index )  ;", "classfilewriter . util . Boxing . boxIfNessesary ( ca ,    DescriptorUtils . makeDescriptor ( type )  )  ;", "}", "index +  +  ;", "ca . aastore (  )  ;", "}", "}", "String   invoke    =     \" invoke \"  ;", "String   ret    =     \" Ljava / lang / Object ;  \"  ;", "if    (  ( returnType . isPrimitive (  )  )     &  &     ( returnType    !  =     ( Void . TYPE )  )  )     {", "String   typeName    =    returnType . getName (  )  ;", "invoke    +  =     ( Character . toUpperCase ( typeName . charAt (  0  )  )  )     +     ( typeName . substring (  1  )  )  ;", "ret    =    DescriptorUtils . makeDescriptor ( returnType )  ;", "}", "ca . invokevirtual ( superclass . getName (  )  ,    invoke ,     (  \"  ( Ljava / lang / String ; Lorg / wildfly / iiop / openjdk / rmi / marshal / strategy / StubStrategy ;  [ Ljava / lang / Object ;  )  \"     +    ret )  )  ;", "if    (  (  !  ( returnType . isPrimitive (  )  )  )     &  &     ( returnType    !  =     ( Object . class )  )  )     {", "ca . checkcast ( returnType )  ;", "}", "ca . returnInstruction (  )  ;", "final   CodeAttribute   init    =    asm . addMethod (  (  ( Modifier . PRIVATE )     +     ( Modifier . STATIC )  )  ,    initMethod ,     \" V \"  )  . getCodeAttribute (  )  ;", "int   i ;", "int   len ;", "len    =    paramTypes . length ;", "init . iconst ( len )  ;", "init . anewarray ( String . class . getName (  )  )  ;", "for    ( i    =     0  ;    i    <    len ;    i +  +  )     {", "init . dup (  )  ;", "init . iconst ( i )  ;", "init . ldc ( CDRStream . abbrevFor ( paramTypes [ i ]  )  )  ;", "init . aastore (  )  ;", "}", "len    =    exceptions . length ;", "int   n    =     0  ;", "for    ( i    =     0  ;    i    <    len ;    i +  +  )     {", "if    (  !  ( RemoteException . class . isAssignableFrom ( exceptions [ i ]  )  )  )     {", "n +  +  ;", "}", "}", "init . iconst ( n )  ;", "init . anewarray ( String . class . getName (  )  )  ;", "try    {", "int   j    =     0  ;", "for    ( i    =     0  ;    i    <    len ;    i +  +  )     {", "if    (  !  ( RemoteException . class . isAssignableFrom ( exceptions [ i ]  )  )  )     {", "init . dup (  )  ;", "init . iconst ( j )  ;", "init . ldc ( ExceptionAnalysis . getExceptionAnalysis ( exceptions [ i ]  )  . getExceptionRepositoryId (  )  )  ;", "init . aastore (  )  ;", "j +  +  ;", "}", "}", "}    catch    ( RMIIIOPViolationException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . exceptionRepositoryNotFound ( exceptions [ i ]  . getName (  )  ,    e . getLocalizedMessage (  )  )  ;", "}", "init . iconst ( n )  ;", "init . anewarray ( String . class . getName (  )  )  ;", "int   j    =     0  ;", "for    ( i    =     0  ;    i    <    len ;    i +  +  )     {", "if    (  !  ( RemoteException . class . isAssignableFrom ( exceptions [ i ]  )  )  )     {", "init . dup (  )  ;", "init . iconst ( j )  ;", "init . ldc ( exceptions [ i ]  . getName (  )  )  ;", "init . aastore (  )  ;", "j +  +  ;", "}", "}", "init . ldc ( CDRStream . abbrevFor ( returnType )  )  ;", "init . aconstNull (  )  ;", "init . invokestatic ( StubStrategy . class . getName (  )  ,     \" forMethod \"  ,     \"  (  [ Ljava / lang / String ;  [ Ljava / lang / String ;  [ Ljava / lang / String ; Ljava / lang / String ; Ljava / lang / ClassLoader ;  ) Lorg / wildfly / iiop / openjdk / rmi / marshal / strategy / StubStrategy ;  \"  )  ;", "init . putstatic ( asm . getName (  )  ,    strategyField ,    StubStrategy . class )  ;", "init . returnInstruction (  )  ;", "}", "METHOD_END"], "methodName": ["generateMethodCode"], "fileName": "org.jboss.as.ejb3.iiop.stub.IIOPStubCompiler"}, {"methodBody": ["METHOD_START", "{", "return    \"  $ i \"     +    methodIndex ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jboss.as.ejb3.iiop.stub.IIOPStubCompiler"}, {"methodBody": ["METHOD_START", "{", "ClassFile   code    =    IIOPStubCompiler . generateCode ( interfaceAnalysis ,    superclass ,    stubClassName )  ;", "return   code ;", "}", "METHOD_END"], "methodName": ["makeCode"], "fileName": "org.jboss.as.ejb3.iiop.stub.IIOPStubCompiler"}, {"methodBody": ["METHOD_START", "{", "return    \"  $ s \"     +    methodIndex ;", "}", "METHOD_END"], "methodName": ["strategy"], "fileName": "org.jboss.as.ejb3.iiop.stub.IIOPStubCompiler"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   method . invoke ( this ,    args )  ;", "}    catch    ( TargetException   e )     {", "throw   e . getCause (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.jboss.as.ejb3.inflow.AbstractInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  (  )     ( factory . newInstance ( handler )  )  )  ;", "}    catch    ( InstantiationException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createEndpoint"], "fileName": "org.jboss.as.ejb3.inflow.JBossMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . service . getClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationClassLoader"], "fileName": "org.jboss.as.ejb3.inflow.MessageEndpointInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   service . getTransactionManager (  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.jboss.as.ejb3.inflow.MessageEndpointInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "this . interceptorBindings . add ( interceptorBinding )  ;", "}", "METHOD_END"], "methodName": ["addInterceptorBinding"], "fileName": "org.jboss.as.ejb3.interceptor.ContainerInterceptorsMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . interceptorBindings ;", "}", "METHOD_END"], "methodName": ["getInterceptorBindings"], "fileName": "org.jboss.as.ejb3.interceptor.ContainerInterceptorsMetaData"}, {"methodBody": ["METHOD_START", "{", "return   INSTANCE . parse ( reader ,    propertyReplacer )  ;", "}", "METHOD_END"], "methodName": ["readInterceptorBinding"], "fileName": "org.jboss.as.ejb3.interceptor.ContainerInterceptorsParser"}, {"methodBody": ["METHOD_START", "{", "T   bean    =    factory . create (  )  ;", "createCount . incrementAndGet (  )  ;", "return   bean ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.ejb3.pool.AbstractPool"}, {"methodBody": ["METHOD_START", "{", "doRemove ( bean )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.jboss.as.ejb3.pool.AbstractPool"}, {"methodBody": ["METHOD_START", "{", "try    {", "fory . destroy ( bean )  ;", "}    finally    {", "removeCount . incrementAndGet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doRemove"], "fileName": "org.jboss.as.ejb3.pool.AbstractPool"}, {"methodBody": ["METHOD_START", "{", "return   createCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getCreateCount"], "fileName": "org.jboss.as.ejb3.pool.AbstractPool"}, {"methodBody": ["METHOD_START", "{", "return   removeCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getRemoveCount"], "fileName": "org.jboss.as.ejb3.pool.AbstractPool"}, {"methodBody": ["METHOD_START", "{", "this . doRemove ( bean )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.ejb3.pool.AbstractPool"}, {"methodBody": ["METHOD_START", "{", "return   poolName ;", "}", "METHOD_END"], "methodName": ["getPoolName"], "fileName": "org.jboss.as.ejb3.pool.EJBBoundPoolMetaData"}, {"methodBody": ["METHOD_START", "{", "this . poolName    =    poolName ;", "}", "METHOD_END"], "methodName": ["setPoolName"], "fileName": "org.jboss.as.ejb3.pool.EJBBoundPoolMetaData"}, {"methodBody": ["METHOD_START", "{", "return   MockBean . finalized . get (  )  ;", "}", "METHOD_END"], "methodName": ["getFinalized"], "fileName": "org.jboss.as.ejb3.pool.common.MockBean"}, {"methodBody": ["METHOD_START", "{", "return   MockBean . postConstructs . get (  )  ;", "}", "METHOD_END"], "methodName": ["getPostConstructs"], "fileName": "org.jboss.as.ejb3.pool.common.MockBean"}, {"methodBody": ["METHOD_START", "{", "return   MockBean . preDestroys . get (  )  ;", "}", "METHOD_END"], "methodName": ["getPreDestroys"], "fileName": "org.jboss.as.ejb3.pool.common.MockBean"}, {"methodBody": ["METHOD_START", "{", "MockBean . log . info (  \" postConstruct \"  )  ;", "MockBean . postConstructs . incrementAndGet (  )  ;", "}", "METHOD_END"], "methodName": ["postConstruct"], "fileName": "org.jboss.as.ejb3.pool.common.MockBean"}, {"methodBody": ["METHOD_START", "{", "MockBean . log . info (  \" preDestroy \"  )  ;", "MockBean . preDestroys . incrementAndGet (  )  ;", "}", "METHOD_END"], "methodName": ["preDestroy"], "fileName": "org.jboss.as.ejb3.pool.common.MockBean"}, {"methodBody": ["METHOD_START", "{", "MockBean . finalized . set (  0  )  ;", "MockBean . preDestroys . set (  0  )  ;", "MockBean . postConstructs . set (  0  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.jboss.as.ejb3.pool.common.MockBean"}, {"methodBody": ["METHOD_START", "{", "MockBean   bean    =    new   MockBean (  )  ;", "bean . postConstruct (  )  ;", "return   bean ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.ejb3.pool.common.MockFactory"}, {"methodBody": ["METHOD_START", "{", "obj . preDestroy (  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.jboss.as.ejb3.pool.common.MockFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( EjbLogger . ROOT _ LOGGER . isTraceEnabled (  )  )     {", "EjbLogger . ROOT _ LOGGER . tracef (  \" Discard   instance    % s #  % s \"  ,    this ,    ctx )  ;", "}", "semaphore . release (  )  ;", "super . doRemove ( ctx )  ;", "}", "METHOD_END"], "methodName": ["discard"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "try    {", "boolean   acquired    =    semaphore . tryAcquire ( timeout ,    timeUnit )  ;", "if    (  ! acquired )", "throw   EjbLogger . ROOT _ LOGGER . failedToAcquirePermit ( timeout ,    timeUnit )  ;", "}    catch    ( InterruptedException   e )     {", "throw   EjbLogger . ROOT _ LOGGER . acquireSemaphoreInterrupted (  )  ;", "}", "T   bean    =    poll (  )  ;", "if    ( bean    !  =    null )     {", "return   bean ;", "}", "try    {", "bean    =    create (  )  ;", "}    finally    {", "if    ( bean    =  =    null )     {", "semaphore . release (  )  ;", "}", "}", "return   bean ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "return   semaphore . availablePermits (  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableCount"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "return    ( getCreateCount (  )  )     -     ( getRemoveCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentSize"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "return   maxSize ;", "}", "METHOD_END"], "methodName": ["getMaxSize"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "if    ( EjbLogger . ROOT _ LOGGER . isTraceEnabled (  )  )     {", "EjbLogger . ROOT _ LOGGER . tracef (  \"  % s /  % s   Free   instance :     % s \"  ,    ize (  )  ,    maxSize ,    this )  ;", "}", "pool . add ( obj )  ;", "semaphore . release (  )  ;", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . methodNotImplemented (  )  ;", "}", "METHOD_END"], "methodName": ["setMaxSize"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "for    ( T   obj    =    pool . poll (  )  ;    obj    !  =    null ;    obj    =    pool . poll (  )  )     {", "destroy ( obj )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxPool"}, {"methodBody": ["METHOD_START", "{", "MockBean . reset (  )  ;", "used    =    new   AtomicInteger (  0  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "MockBean . reset (  )  ;", "StatelessObjectFactory < MockBean >    factory    =    new   MockFactory (  )  ;", "Pool < MockBean >    pool    =    new   Pool < MockBean >  ( factory ,     1  0  ,     1  ,    TimeUnit . SECONDS )  ;", "pool . start (  )  ;", "MockBean [  ]    beans    =    new   MockBean [  1  0  ]  ;", "for    ( int   i    =     0  ;    i    <     ( beans . length )  ;    i +  +  )     {", "beans [ i ]     =    pool . get (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( beans . length )  ;    i +  +  )     {", "pool . release ( beans [ i ]  )  ;", "beans [ i ]     =    null ;", "}", "pool . stop (  )  ;", "assertEquals (  1  0  ,    MockBean . getPostConstructs (  )  )  ;", "assertEquals (  1  0  ,    MockBean . getPreDestroys (  )  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "MockBean . reset (  )  ;", "StatelessObjectFactory < MockBean >    factory    =    new   MockFactory (  )  ;", "final   Pool < MockBean >    pool    =    new   Pool < MockBean >  ( factory ,     1  0  ,     6  0  ,    TimeUnit . SECONDS )  ;", "pool . start (  )  ;", "final   CountDownLatch   in    =    new   CountDownLatch (  1  )  ;", "final   CountDownLatch   ready    =    new   CountDownLatch (  1  0  )  ;", "Callable < Void >    task    =    new   Callable < Void >  (  )     {", "public   Void   call (  )    throws   Exception    {", "MockBean   bean    =    pool . get (  )  ;", "ready . countDown (  )  ;", "in . await (  )  ;", "pool . release ( bean )  ;", "bean    =    null ;", "used . incrementAndGet (  )  ;", "return   null ;", "}", "}  ;", "ExecutorService   service    =    Executors . newFixedThreadPool (  2  0  )  ;", "Future <  ?  >  [  ]    results    =    new   Future <  ?  >  [  2  0  ]  ;", "for    ( int   i    =     0  ;    i    <     ( results . length )  ;    i +  +  )     {", "results [ i ]     =    service . submit ( task )  ;", "}", "ready . await (  1  2  0  ,    TimeUnit . SECONDS )  ;", "in . countDown (  )  ;", "for    ( Future <  ?  >    result    :    results )     {", "result . get (  5  ,    TimeUnit . SECONDS )  ;", "}", "service . shutdown (  )  ;", "pool . stop (  )  ;", "assertEquals (  2  0  ,    used . intValue (  )  )  ;", "assertEquals (  1  0  ,    MockBean . getPostConstructs (  )  )  ;", "assertEquals (  1  0  ,    MockBean . getPreDestroys (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiThread"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "MockBean . reset (  )  ;", "StatelessObjectFactory < MockBean >    factory    =    new   MockFactory (  )  ;", "Pool < MockBean >    pool    =    new   Pool < MockBean >  ( factory ,     1  0  ,     1  ,    TimeUnit . SECONDS )  ;", "pool . start (  )  ;", "MockBean [  ]    beans    =    new   MockBean [  1  0  ]  ;", "for    ( int   i    =     0  ;    i    <     ( beans . length )  ;    i +  +  )     {", "beans [ i ]     =    pool . get (  )  ;", "}", "try    {", "pool . get (  )  ;", "fail (  \" should   have   thrown   an   exception \"  )  ;", "}    catch    ( Exception   e )     {", "assertEquals ( EjbLogger . ROOT _ LOGGER . failedToAcquirePermit (  1  ,    TimeUnit . SECONDS )  . getMessage (  )  ,    e . getMessage (  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( beans . length )  ;    i +  +  )     {", "pool . release ( beans [ i ]  )  ;", "beans [ i ]     =    null ;", "}", "pool . stop (  )  ;", "assertEquals (  1  0  ,    MockBean . getPostConstructs (  )  )  ;", "assertEquals (  1  0  ,    MockBean . getPreDestroys (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTooMany"], "fileName": "org.jboss.as.ejb3.pool.strictmax.StrictMaxUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getProtocol (  )  . equals (  \" local \"  )  )     &  &     (  ! isAsync )  )     {", "task . run (  )  ;", "} else    {", "if    (  ( executor )     !  =    null )     {", "executor . execute ( task )  ;", "} else    {", "request . getRequestExecutor (  )  . execute ( task )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentModuleIdentifier   ejbModule    =    new   DeploymentModuleIdentifier ( appName ,    moduleName ,    distinctName )  ;", "final   Map < DeploymentModuleIdentifier ,    ModuleDeployment >    modules    =    this . deploymentRepository . getStartedModules (  )  ;", "if    (  ( modules    =  =    null )     |  |     ( modules . isEmpty (  )  )  )     {", "return   null ;", "}", "final   ModuleDeployment   moduleDeployment    =    modules . get ( ejbModule )  ;", "if    ( moduleDeployment    =  =    null )     {", "return   null ;", "}", "return   moduleDeployment . getEjbs (  )  . get ( beanName )  ;", "}", "METHOD_END"], "methodName": ["findEJB"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "final   Set < Method >    viewMethods    =    componentView . getViewMethods (  )  ;", "for    ( final   Method   method    :    viewMethods )     {", "if    ( method . getName (  )  . equals ( MethodLocator . getMethodName (  )  )  )     {", "final   Class <  ?  >  [  ]    methodParamTypes    =    method . getParameterTypes (  )  ;", "if    (  ( methodParamTypes . length )     !  =     ( MethodLocator . getParameterCount (  )  )  )     {", "continue ;", "}", "boolean   found    =    true ;", "for    ( int   i    =     0  ;    i    <     ( methodParamTypes . length )  ;    i +  +  )     {", "if    (  !  ( methodParamTypes [ i ]  . getName (  )  . equals ( MethodLocator . getParameterTypeName ( i )  )  )  )     {", "found    =    false ;", "break ;", "}", "}", "if    ( found )     {", "return   method ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "Registry < String ,    List < ClientMapping >  >    registry    =    this . clientMappingRegistry ;", "Group   group    =     ( registry    !  =    null )     ?    registry . getGroup (  )     :    null ;", "return    ( group    !  =    null )     &  &     (  !  ( group . isSingleton (  )  )  )     ?    new   ejb . client . ClusterAffinity ( group . getName (  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getClusterAffinity"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "return   executor ;", "}", "METHOD_END"], "methodName": ["getExecutor"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "return   statefulSessionComponent . getCache (  )  . getWeakAffinity ( sessionID )  ;", "}", "METHOD_END"], "methodName": ["getWeakAffinity"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "final   SessionID   sessionID    =    statefulEJBLocator . getSessionId (  )  ;", "return    . getWeakAffinity ( statefulSessionComponent ,    sessionID )  ;", "}", "METHOD_END"], "methodName": ["getWeakAffinity"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   interceptorContext    =    new   InterceptorContext (  )  ;", "interceptorContext . setParameters ( content . getParameters (  )  )  ;", "interceptorContext . setMethod ( method )  ;", "interceptorContext . putPrivateData ( Component . class ,    componentView . getComponent (  )  )  ;", "interceptorContext . putPrivateData ( ComponentView . class ,    componentView )  ;", "interceptorContext . putPrivateData ( InvocationType . class ,    REMOTE )  ;", "interceptorContext . setBlockingCaller ( false )  ;", "final   Map < String ,    Object >    invocationContextData    =    new   HashMap < String ,    Object >  (  )  ;", "interceptorContext . setContextData ( invocationContextData )  ;", "if    (  ( content . getAttachments (  )  )     !  =    null )     {", "for    ( final   Map . Entry < String ,    Object >    attachment    :    content . getAttachments (  )  . entrySet (  )  )     {", "if    ( attachment    =  =    null )     {", "continue ;", "}", "final   String   key    =    attachment . getKey (  )  ;", "final   Object   value    =    attachment . getValue (  )  ;", "if    ( PRIVATE _ ATTACHMENTS _ KEY . equals ( key )  )     {", "final   Map <  ?  ,     ?  >    privateAttachments    =     (  ( Map <  ?  ,     ?  >  )     ( value )  )  ;", "for    ( final   Map . Entry <  ?  ,     ?  >    privateAttachment    :    privateAttachments . entrySet (  )  )     {", "interceptorContext . putPrivateData ( privateAttachment . getKey (  )  ,    privateAttachment . getValue (  )  )  ;", "}", "} else    {", "invocationContextData . put ( key ,    value )  ;", "}", "}", "}", "final   EJBLocator <  ?  >    ejbLocator    =    content . getEJBLocator (  )  ;", "if    ( ejbLocator . isStateful (  )  )     {", "interceptorContext . putPrivateData ( SessionID . class ,    ejbLocator . asStateful (  )  . getSessionId (  )  )  ;", "}", "if    ( content . hasTransaction (  )  )     {", "interceptorContext . setTransactionSupplier ( content :  : getTransaction )  ;", "}", "final   SecurityIdentity   securityIdentity    =    incomingInvocation . getSecurityIdentity (  )  ;", "final   boolean   isAsync    =    componentView . isAsynchronous ( method )  ;", "final   boolean   oneWay    =    isAsync    &  &     (  ( method . getReturnType (  )  )     =  =     ( void . class )  )  ;", "final   boolean   isSessionBean    =     ( componentView . getComponent (  )  )    instanceof   SessionBeanComponent ;", "contextDataHolder . putAll ( interceptorContext . getContextData (  )  )  ;", "if    ( isAsync    &  &    isSessionBean )     {", "if    (  ! oneWay )     {", "interceptorContext . putPrivateData ( CancellationFlag . class ,    cancellationFlag )  ;", "}", "final   Object   result    =     . invokeWithIdentity ( componentView ,    interceptorContext ,    securityIdentity )  ;", "return   result    =  =    null    ?    null    :     (  ( Future <  ?  >  )     ( result )  )  . get (  )  ;", "} else    {", "return    . invokeWithIdentity ( componentView ,    interceptorContext ,    securityIdentity )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "return   securityIdentity    =  =    null    ?    componentView . invoke ( interceptorContext )     :    securityIdentity . runAsFunctionEx ( ComponentView :  : invoke ,    componentView ,    interceptorContext )  ;", "}", "METHOD_END"], "methodName": ["invokeWithIdentity"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "this . executor    =    executor ;", "}", "METHOD_END"], "methodName": ["setExecutor"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   EJBModuleIdentifier ( identifier . getApplicationName (  )  ,    identifier . getModuleName (  )  ,    identifier . getDistinctName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toModuleIdentifier"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "Affinity   legacyAffinity    =    null ;", "Affinity   weakAffinity    =    null ;", "Affinity   clusterAffinity    =    getClusterAffinity (  )  ;", "if    (  ( ejbLocator . isStateful (  )  )     &  &     (  ( componentView . getComponent (  )  )    instanceof   StatefulSessionComponent )  )     {", "final   StatefulSessionComponent   statefulSessionComponent    =     (  ( StatefulSessionComponent )     ( componentView . getComponent (  )  )  )  ;", "weakAffinity    =    legacyAffinity    =    AssociationImpl . getWeakAffinity ( statefulSessionComponent ,    ejbLocator . asStateful (  )  )  ;", "} else", "if    (  ( componentView . getComponent (  )  )    instanceof   component . stateless . StatelessSessionComponent )     {", "legacyAffinity    =    clusterAffinity ;", "}", "if    ( clusterAffinity    !  =    null )     {", "invocationRequest . updateStrongAffinity ( clusterAffinity )  ;", "}", "if    (  ( weakAffinity    !  =    null )     &  &     (  !  ( weakAffinity . equals ( NONE )  )  )  )     {", "invocationRequest . updateWeakAffinity ( weakAffinity )  ;", "}", "if    (  ( legacyAffinity    !  =    null )     &  &     (  !  ( legacyAffinity . equals ( NONE )  )  )  )     {", "attachments . put ( WEAK _ AFFINITY _ CONTEXT _ KEY ,    legacyAffinity )  ;", "}", "}", "METHOD_END"], "methodName": ["updateAffinities"], "fileName": "org.jboss.as.ejb3.remote.AssociationImpl"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getAssociation"], "fileName": "org.jboss.as.ejb3.remote.AssociationService"}, {"methodBody": ["METHOD_START", "{", "return   clientMappingsRegistryInjector ;", "}", "METHOD_END"], "methodName": ["getClientMappingsRegistryInjector"], "fileName": "org.jboss.as.ejb3.remote.AssociationService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentRepositoryInjector ;", "}", "METHOD_END"], "methodName": ["getDeploymentRepositoryInjector"], "fileName": "org.jboss.as.ejb3.remote.AssociationService"}, {"methodBody": ["METHOD_START", "{", "return   mutableDiscoveryProvider ;", "}", "METHOD_END"], "methodName": ["getLocalDiscoveryProvider"], "fileName": "org.jboss.as.ejb3.remote.AssociationService"}, {"methodBody": ["METHOD_START", "{", "return   serverEnvironmentServiceInjector ;", "}", "METHOD_END"], "methodName": ["getServerEnvironmentServiceInjector"], "fileName": "org.jboss.as.ejb3.remote.AssociationService"}, {"methodBody": ["METHOD_START", "{", "return   suspendControllerInjector ;", "}", "METHOD_END"], "methodName": ["getSuspendControllerInjector"], "fileName": "org.jboss.as.ejb3.remote.AssociationService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( valu    !  =    null )     {", "valusExutor ( utor )  ;", "}", "}", "METHOD_END"], "methodName": ["setExecutor"], "fileName": "org.jboss.as.ejb3.remote.AssociationService"}, {"methodBody": ["METHOD_START", "{", "return   appClientEjbProperties ;", "}", "METHOD_END"], "methodName": ["getAppClientEjbProperties"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   appClientUri ;", "}", "METHOD_END"], "methodName": ["getAppClientUri"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   clientContext ;", "}", "METHOD_END"], "methodName": ["getClientContext"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   clustersAuthenticationContext ;", "}", "METHOD_END"], "methodName": ["getClustersAuthenticationContext"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   configuratorServiceInjector ;", "}", "METHOD_END"], "methodName": ["getConfiguratorServiceInjector"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   localProviderInjector ;", "}", "METHOD_END"], "methodName": ["getLocalProviderInjector"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   profileServiceInjector ;", "}", "METHOD_END"], "methodName": ["getProfileServiceInjector"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "this . clientClusters    =    clientClusters ;", "}", "METHOD_END"], "methodName": ["setClientClusters"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "this . clientInterceptors    =    clientInterceptors ;", "}", "METHOD_END"], "methodName": ["setClientInterceptors"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "this . clustersAuthenticationContext    =    clustersAuthenticationContext ;", "}", "METHOD_END"], "methodName": ["setClustersAuthenticationContext"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "this . deploymentNodeSelector    =    deploymentNodeSelector ;", "}", "METHOD_END"], "methodName": ["setDeploymentNodeSelector"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "this . invocationTimeout    =    invocationTimeout ;", "}", "METHOD_END"], "methodName": ["setInvocationTimeout"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   File   file    =    new   File ( connectionPropertiesUrl )  ;", "final   URL   url ;", "if    ( file . exists (  )  )     {", "url    =    file . toURI (  )  . toURL (  )  ;", "} else    {", "url    =    new   URL ( connectionPropertiesUrl )  ;", "}", "Properties   properties    =    new   Properties (  )  ;", "InputStream   stream    =    null ;", "try    {", "stream    =    url . openStream (  )  ;", "properties . load ( stream )  ;", "}    finally    {", "if    ( stream    !  =    null )     {", "try    {", "stream . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "}", "JBossEJBProperties   ejbProps    =    JBossEJBProperties . fromProperties ( connectionPropertiesUrl ,    properties )  ;", "JBossEJBProperties . geManager (  )  . setGlobalDefault ( ejbProps )  ;", "}    catch    ( Exception   e )     {", "throw   new   StartException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["setupEjbClientProps"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "final   EJBClientContext . Builder   builder    =    new   EJBClientContext . Builder (  )  ;", "configuratorServiceInjector . getValue (  )  . accept ( builder )  ;", "builder . setInvocationTimeout ( invocationTimeout )  ;", "final   EJBTransportProvider   localTransport    =    localProviderInjector . getOptionalValue (  )  ;", "if    ( localTransport    !  =    null )     {", "builder . addTransportProvider ( localTransport )  ;", "}", "final   RemotingProfileService   profileService    =    profileServiceInjector . getOptionalValue (  )  ;", "if    ( profileService    !  =    null )", "for    ( RemotingProfileService . ConnectionSpec   spec    :    profileService . getConnectionSpecs (  )  )     {", "final   EJBClientConnection . Builder   connBuilder    =    new   EJBClientConnection . Builder (  )  ;", "connBuilder . setDestination ( spec . getInjector (  )  . getValue (  )  . getDestinationUri (  )  )  ;", "builder . addClientConnection ( connBuilder . build (  )  )  ;", "}", "if    (  ( appClientUri . getOptionalValue (  )  )     !  =    null )     {", "final   EJBClientConnection . Builder   connBuilder    =    new   EJBClientConnection . Builder (  )  ;", "connBuilder . setDestination ( appClientUri . getOptionalValue (  )  )  ;", "builder . addClientConnection ( connBuilder . build (  )  )  ;", "}", "if    (  ( clientClusters )     !  =    null )     {", "boolean   firstSelector    =    true ;", "for    ( EJBClientCluster   clientCluster    :    clientClusters )     {", "builder . addClientCluster ( clientCluster )  ;", "ClusterNodeSelector   selector    =    clientCluster . getClusterNodeSelector (  )  ;", "if    ( firstSelector    &  &     ( selector    !  =    null )  )     {", "builder . setClusterNodeSelector ( selector )  ;", "firstSelector    =    false ;", "}", "}", "}", "if    (  ( deploymentNodeSelector )     !  =    null )     {", "builder . setDeploymentNodeSelector ( deploymentNodeSelector )  ;", "}", "if    (  ( appClientEjbProperties . getOptionalValue (  )  )     !  =    null )     {", "setupEjbClientProps ( appClientEjbProperties . getOptionalValue (  )  )  ;", "LegacyPropertiesConfiguration . configure ( builder )  ;", "}", "if    (  ( clientInterceptors )     !  =    null )     {", "for    ( EJBClientInterceptor   clientInterceptor    :    clientInterceptors )     {", "builder . addInterceptor ( clientInterceptor )  ;", "}", "}", "clientContext    =    builder . build (  )  ;", "if    ( makeGlobal )     {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", "EJBClientContext . getContextManager (  )  . setGlobalDefault ( clientContext )  ;", "return   null ;", "}  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "clientContext    =    null ;", "if    ( makeGlobal )     {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", ". getContextManager (  )  . setGlobalDefault ( null )  ;", "return   null ;", "}  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ejb3.remote.EJBClientContextService"}, {"methodBody": ["METHOD_START", "{", "return   associationServiceInjectedValue ;", "}", "METHOD_END"], "methodName": ["getAssociationServiceInjector"], "fileName": "org.jboss.as.ejb3.remote.EJBRemoteConnectorService"}, {"methodBody": ["METHOD_START", "{", "return   endpointValue ;", "}", "METHOD_END"], "methodName": ["getEndpointInjector"], "fileName": "org.jboss.as.ejb3.remote.EJBRemoteConnectorService"}, {"methodBody": ["METHOD_START", "{", "return   executorService ;", "}", "METHOD_END"], "methodName": ["getExecutorService"], "fileName": "org.jboss.as.ejb3.remote.EJBRemoteConnectorService"}, {"methodBody": ["METHOD_START", "{", "return   remotingConnectorInfoInjectedValue ;", "}", "METHOD_END"], "methodName": ["getRemotingConnectorInfoInjectedValue"], "fileName": "org.jboss.as.ejb3.remote.EJBRemoteConnectorService"}, {"methodBody": ["METHOD_START", "{", "return   remotingTransactionServiceInjectedValue ;", "}", "METHOD_END"], "methodName": ["getRemotingTransactionServiceInjector"], "fileName": "org.jboss.as.ejb3.remote.EJBRemoteConnectorService"}, {"methodBody": ["METHOD_START", "{", "final   List < ClientMapping >    ret    =    new   ArrayList <  >  (  )  ;", "BindingInfoService . Info   info    =    this . remotingConnectorInfo . getValue (  )  ;", "if    (  (  ( info . getSocketBinding (  )  . getClientMappings (  )  )     !  =    null )     &  &     (  !  ( info . getSocketBinding (  )  . getClientMappings (  )  . isEmpty (  )  )  )  )     {", "ret . addAll ( info . getSocketBinding (  )  . getClientMappings (  )  )  ;", "} else    {", "final   String   destinationAddress    =    info . getSocketBinding (  )  . getAddress (  )  . getHostAddress (  )  ;", "final   InetAddress   clientNetworkAddress ;", "try    {", "clientNetworkAddress    =    InetAddress . getByName (  \"  :  :  \"  )  ;", "}    catch    ( UnknownHostException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "final   ClientMapping   defaultClientMapping    =    new   ClientMapping ( clientNetworkAddress ,     0  ,    destinationAddress ,    info . getSocketBinding (  )  . getAbsolutePort (  )  )  ;", "ret . add ( defaultClientMapping )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["getClientMappings"], "fileName": "org.jboss.as.ejb3.remote.EJBRemotingConnectorClientMappingsEntryProviderService"}, {"methodBody": ["METHOD_START", "{", "CancellationFlag   flag    =    receiverContext . getClientInvocationContext (  )  . getAttachment ( LocalEjbReceiver . CANCELLATION _ FLAG _ ATTACHMENT _ KEY )  ;", "return    ( flag    !  =    null )     &  &     ( flag . cancel ( cancelIfRunning )  )  ;", "}", "METHOD_END"], "methodName": ["cancelInvocation"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", "SecurityContextAssociation . clearSecurityContext (  )  ;", "return   null ;", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["clearSecurityContextOnAssociation"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )     {", "return   null ;", "}", "if    ( target . isPrimitive (  )  )     {", "return   object ;", "}", "if    ( allowPassByReference    &  &     ( target . isAssignableFrom ( object . getClass (  )  )  )  )     {", "return   object ;", "}", "return    . clone ( cloner ,    object )  ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )     {", "return   null ;", "}", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >     {", "try    {", "return   cloner . clone ( object )  ;", "}    catch    ( Exception   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToMarshParameters ( e )  ;", "}", "}  )  )  )  ;", "} else    {", "try    {", "return   cloner . clone ( object )  ;", "}    catch    ( Exception   e )     {", "throw   EjbLogger . ROOT _ LOGGER . failedToMarshParameters ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "ObjectCloner   parameterCloner ;", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "parameterCloner    =    WildFlySecurityManager . doUnchecked (  (  ( PrivilegedAction < ObjectCloner >  )     (  (  )     -  >    ObjectCloners . getSerializingObjectClonerFactory (  )  . createCloner ( paramConfig )  )  )  )  ;", "} else    {", "parameterCloner    =    ObjectCloners . getSerializingObjectClonerFactory (  )  . createCloner ( paramConfig )  ;", "}", "return   parameterCloner ;", "}", "METHOD_END"], "methodName": ["createCloner"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "final   StatelessEJBLocator <  ?  >    statelessLocator    =    receiverContext . getClientInvocationContext (  )  . getLocator (  )  . asStateless (  )  ;", "final   EjbDeploymentInformation   ejbInfo    =    findBean ( statelessLocator )  ;", "final   EJBComponent   component    =    ejbInfo . getEjbComponent (  )  ;", "if    (  !  ( component   instanceof   StatefulSessionComponent )  )     {", "throw   EjbLogger . ROOT _ LOGGER . notStatefulSessionBean ( statelessLocator . getAppName (  )  ,    statelessLocator . getModuleName (  )  ,    statelessLocator . getDistinctName (  )  ,    statelessLocator . getBeanName (  )  )  ;", "}", "component . waitForComponentStart (  )  ;", "return    (  ( StatefulSessionComponent )     ( component )  )  . createSession (  )  ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "final   String   appName    =    locator . getAppName (  )  ;", "final   String   moduleName    =    locator . getModuleName (  )  ;", "final   String   distinctName    =    locator . getDistinctName (  )  ;", "final   String   beanName    =    locator . getBeanName (  )  ;", "final   DeploymentModuleIdentifier   moduleIdentifier    =    new   DeploymentModuleIdentifier ( appName ,    moduleName ,    distinctName )  ;", "final   ModuleDeployment   module    =    deploymentRepository . getValue (  )  . getModules (  )  . get ( moduleIdentifier )  ;", "if    ( module    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGER . unknownDeployment ( locator )  ;", "}", "final   EjbDeploymentInformationInfo    =    module . getEjbs (  )  . get ( beanName )  ;", "if   Info    =  =    null )     {", "throw   EjbLogger . ROOT _ LOGGERNotFoundInDeployment ( locator )  ;", "}", "returnInfo ;", "}", "METHOD_END"], "methodName": ["findBean"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", "SecurityContextAssociation . setSecurityContext ( sc )  ;", "return   null ;", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setSecurityContextOnAssociation"], "fileName": "org.jboss.as.ejb3.remote.LocalEjbReceiver"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    original . getName (  )  ;", "if    ( name . startsWith (  \" \"  )  )     {", "return   original ;", "} else", "if    (  ( original . getLoader (  )  )     =  =     ( destLoader )  )     {", "return   original ;", "} else    {", "try    {", "return    . forName ( name ,    true ,    destLoader )  ;", "}    catch    ( NotFoundException   e )     {", "Loader   current    =    Thread . currentThread (  )  . getContextLoader (  )  ;", "if    ( current    !  =     ( destLoader )  )     {", "try    {", "return    . forName ( name ,    true ,    current )  ;", "}    catch    ( NotFoundException   ignored )     {", "}", "}", "return   original ;", "}", "}", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jboss.as.ejb3.remote.LocalInvocationClassCloner"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >  [  ]    origInterfaces    =    proxyClass . getInterfaces (  )  ;", "final   Class <  ?  >  [  ]    interfaces    =    new   Class [ origInterfaces . length ]  ;", "for    ( int   i    =     0  ,    origInterfacesLength    =    origInterfaces . length ;    i    <    origInterfacesLength ;    i +  +  )     {", "interfaces [ i ]     =    clone ( origInterfaces [ i ]  )  ;", "}", "return   Proxy . getProxyClass ( destClassLoader ,    interfaces )  ;", "}", "METHOD_END"], "methodName": ["cloneProxy"], "fileName": "org.jboss.as.ejb3.remote.LocalInvocationClassCloner"}, {"methodBody": ["METHOD_START", "{", "return   deploymentRepository ;", "}", "METHOD_END"], "methodName": ["getDeploymentRepository"], "fileName": "org.jboss.as.ejb3.remote.LocalTransportProvider"}, {"methodBody": ["METHOD_START", "{", "switch    ( uriScheme )     {", "case    \" l \"     :", "{", "break ;", "}", "default    :", "{", "throw   new   IllegalArgumentException (  (  \" Unsupported   EJB   receiver   protocol    \"     +    uriScheme )  )  ;", "}", "}", "return   receiver ;", "}", "METHOD_END"], "methodName": ["getReceiver"], "fileName": "org.jboss.as.ejb3.remote.LocalTransportProvider"}, {"methodBody": ["METHOD_START", "{", "switch    ( uriScheme )     {", "case    \" l \"     :", "{", "return   true ;", "}", "default    :", "{", "return   false ;", "}", "}", "}", "METHOD_END"], "methodName": ["supportsProtocol"], "fileName": "org.jboss.as.ejb3.remote.LocalTransportProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( serviceName )     !  =    null )     {", "serviceBuilder . addDependency ( serviceName )  ;", "}", "final   ManagedReferenceFactory   factory    =    new   ManagedReferenceFactory ( appName ,    moduleName ,    distinctName ,    beanName ,    viewClass ,    stateful ,    viewClassLoader ,    appclient )  ;", "injector . inject ( factory )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ejb3.remote.RemoteViewInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   connectionSpecMap . values (  )  ;", "}", "METHOD_END"], "methodName": ["getConnectionSpecs"], "fileName": "org.jboss.as.ejb3.remote.RemotingProfileService"}, {"methodBody": ["METHOD_START", "{", "return   localTransportProviderInjector ;", "}", "METHOD_END"], "methodName": ["getLocalTransportProviderInjector"], "fileName": "org.jboss.as.ejb3.remote.RemotingProfileService"}, {"methodBody": ["METHOD_START", "{", "return   serviceUrls ;", "}", "METHOD_END"], "methodName": ["getServiceUrls"], "fileName": "org.jboss.as.ejb3.remote.RemotingProfileService"}, {"methodBody": ["METHOD_START", "{", "return    !  ( WildFlySecurityManager . isChecking (  )  )     ?    SecurityActions . RemoteContextAssociationActions . NON _ PRIVILEGED    :    SecurityActions . RemoteContextAssociationActions . PRIVILEGED ;", "}", "METHOD_END"], "methodName": ["remoteContextAssociationActions"], "fileName": "org.jboss.as.ejb3.remote.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return    !  ( WildFlySecurityManager . isChecking (  )  )     ?    SecurityActions . RemotingContextAssociationActions . NON _ PRIVILEGED    :    SecurityActions . RemotingContextAssociationActions . PRIVILEGED ;", "}", "METHOD_END"], "methodName": ["remotingContextAssociationActions"], "fileName": "org.jboss.as.ejb3.remote.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "SecurityActions . remotingContextAssociationActions (  )  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["remotingContextClear"], "fileName": "org.jboss.as.ejb3.remote.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "SecurityActions . remoteContextAssociationActions (  )  . setConnection ( connection )  ;", "}", "METHOD_END"], "methodName": ["remotingContextSetConnection"], "fileName": "org.jboss.as.ejb3.remote.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "SecurityActions . remotingContextAssociationActions (  )  . setConnection ( connection )  ;", "}", "METHOD_END"], "methodName": ["remotingContextSetConnection"], "fileName": "org.jboss.as.ejb3.remote.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   associationServiceInjectedValue ;", "}", "METHOD_END"], "methodName": ["getAssociationServiceInjectedValue"], "fileName": "org.jboss.as.ejb3.remote.http.EJB3RemoteHTTPService"}, {"methodBody": ["METHOD_START", "{", "return   localTransactionContextInjectedValue ;", "}", "METHOD_END"], "methodName": ["getLocalTransactionContextInjectedValue"], "fileName": "org.jboss.as.ejb3.remote.http.EJB3RemoteHTTPService"}, {"methodBody": ["METHOD_START", "{", "return   pathHandlerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getPathHandlerInjectedValue"], "fileName": "org.jboss.as.ejb3.remote.http.EJB3RemoteHTTPService"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdapterName ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterName"], "fileName": "org.jboss.as.ejb3.resourceadapterbinding.metadata.EJBBoundResourceAdapterBindingMetaData"}, {"methodBody": ["METHOD_START", "{", "this . resourceAdapterName    =    resourceAdapterName ;", "}", "METHOD_END"], "methodName": ["setResourceAdapterName"], "fileName": "org.jboss.as.ejb3.resourceadapterbinding.metadata.EJBBoundResourceAdapterBindingMetaData"}, {"methodBody": ["METHOD_START", "{", "return   enableJacc ;", "}", "METHOD_END"], "methodName": ["isEnableJacc"], "fileName": "org.jboss.as.ejb3.security.ApplicationSecurityDomainConfig"}, {"methodBody": ["METHOD_START", "{", "return   name . equals ( other )  ;", "}", "METHOD_END"], "methodName": ["isSameDomain"], "fileName": "org.jboss.as.ejb3.security.ApplicationSecurityDomainConfig"}, {"methodBody": ["METHOD_START", "{", "switch    ( viewType )     {", "case   HOME    :", "return   MethodfaceType . Home ;", "case   LOCAL _ HOME    :", "return   MethodfaceType . LocalHome ;", "case   SERVICE _ ENDPOINT    :", "return   MethodfaceType . ServiceEndpoint ;", "case   LOCAL    :", "return   MethodfaceType . Local ;", "case   REMOTE    :", "return   MethodfaceType . Remote ;", "case   TIMER    :", "return   MethodfaceType . Timer ;", "case   MESSAGE _ ENDPOINT    :", "return   MethodfaceType . MessageEndpoint ;", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getMethodInterfaceType"], "fileName": "org.jboss.as.ejb3.security.AuthorizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "Set < Principal >    methodRoles    =    new   HashSet < Principal >  (  )  ;", "if    ( this . ejbMethodSecurityMetaData . isDenyAll (  )  )", "methodRoles . add ( NobodyPrincipal . NOBODY _ PRINCIPAL )  ;", "else", "if    ( this . ejbMethodSecurityMetaData . isPermitAll (  )  )", "methodRoles . add ( AnybodyPrincipal . ANYBODY _ PRINCIPAL )  ;", "else    {", "for    ( String   role    :    this . ejbMethodSecurityMetaData . getRolesAllowed (  )  )", "methodRoles . add ( new   security . SimplePrincipal ( role )  )  ;", "}", "return   methodRoles ;", "}", "METHOD_END"], "methodName": ["getMethodRolesAsPrincipals"], "fileName": "org.jboss.as.ejb3.security.AuthorizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "final   String   previousID    =    PolicyContext . getContextID (  )  ;", "PolicyContext . setContextID ( contextID )  ;", "return   previousID ;", "} else    {", "final   PrivilegedAction < String >    action    =    new    . SetContextIDAction ( contextID )  ;", "return   AccessController . doPrivileged ( action )  ;", "}", "}", "METHOD_END"], "methodName": ["setContextID"], "fileName": "org.jboss.as.ejb3.security.AuthorizationInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   EJBMethodSecurityAttribute . DENY _ ALL ;", "}", "METHOD_END"], "methodName": ["denyAll"], "fileName": "org.jboss.as.ejb3.security.EJBMethodSecurityAttribute"}, {"methodBody": ["METHOD_START", "{", "return   rolesAllowed ;", "}", "METHOD_END"], "methodName": ["getRolesAllowed"], "fileName": "org.jboss.as.ejb3.security.EJBMethodSecurityAttribute"}, {"methodBody": ["METHOD_START", "{", "return   denyAll ;", "}", "METHOD_END"], "methodName": ["isDenyAll"], "fileName": "org.jboss.as.ejb3.security.EJBMethodSecurityAttribute"}, {"methodBody": ["METHOD_START", "{", "return   permitAll ;", "}", "METHOD_END"], "methodName": ["isPermitAll"], "fileName": "org.jboss.as.ejb3.security.EJBMethodSecurityAttribute"}, {"methodBody": ["METHOD_START", "{", "return   EJBMethodSecurityAttribute . NONE ;", "}", "METHOD_END"], "methodName": ["none"], "fileName": "org.jboss.as.ejb3.security.EJBMethodSecurityAttribute"}, {"methodBody": ["METHOD_START", "{", "return   EJBMethodSecurityAttribute . PERMIT _ ALL ;", "}", "METHOD_END"], "methodName": ["permitAll"], "fileName": "org.jboss.as.ejb3.security.EJBMethodSecurityAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   EJBMethodSecurityAttribute ( false ,    false ,    roles )  ;", "}", "METHOD_END"], "methodName": ["rolesAllowed"], "fileName": "org.jboss.as.ejb3.security.EJBMethodSecurityAttribute"}, {"methodBody": ["METHOD_START", "{", "return   declaredRoles ;", "}", "METHOD_END"], "methodName": ["getDeclaredRoles"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . runAsRole ;", "}", "METHOD_END"], "methodName": ["getRunAs"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   runAsPrincipal ;", "}", "METHOD_END"], "methodName": ["getRunAsPrincipal"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . securityDomain ;", "}", "METHOD_END"], "methodName": ["getSecurityDomain"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . securityRoleLinks ;", "}", "METHOD_END"], "methodName": ["getSecurityRoleLinks"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   securityRoles ;", "}", "METHOD_END"], "methodName": ["getSecurityRoles"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "EJBMethodSecurityAttribute   ejbMethodSecurityMetaData    =    permissions . getViewAttribute ( ejbViewDescription . getMethodIntf (  )  ,    viewMethod )  ;", "final   List < EJBMethodSecurityAttribute >    allAttributes    =    new   ArrayList < EJBMethodSecurityAttribute >  (  )  ;", "allAttributes . addAll ( permissions . getAllAttributes ( ejbViewDescription . getMethodIntf (  )  ,    viewMethod )  )  ;", "if    ( ejbMethodSecurityMetaData    =  =    null )     {", "ejbMethodSecurityMetaData    =    permissions . getViewAttribute ( MethodIntf . BEAN ,    viewMethod )  ;", "}", "allAttributes . addAll ( permissions . getAllAttributes ( MethodIntf . BEAN ,    viewMethod )  )  ;", "final   Method   classMethod    =    ClassReflectionIndexUtil . findMethod ( deploymentReflectionIndex ,    componentConfiguration . getComponentClass (  )  ,    viewMethod )  ;", "if    ( ejbMethodSecurityMetaData    =  =    null )     {", "if    ( classMethod    !  =    null )     {", "ejbMethodSecurityMetaData    =    permissions . getAttribute ( ejbViewDescription . getMethodIntf (  )  ,    classMethod )  ;", "if    ( ejbMethodSecurityMetaData    =  =    null )     {", "ejbMethodSecurityMetaData    =    permissions . getAttribute ( MethodIntf . BEAN ,    classMethod )  ;", "}", "}", "}", "if    ( classMethod    !  =    null )     {", "allAttributes . addAll ( permissions . getAllAttributes ( ejbViewDescription . getMethodIntf (  )  ,    classMethod )  )  ;", "allAttributes . addAll ( permissions . getAllAttributes ( MethodIntf . BEAN ,    classMethod )  )  ;", "}", "if    ( ejbMethodSecurityMetaData    !  =    null )     {", "if    (  (  (  ! annotations )     &  &     (  !  ( ejbMethodSecurityMetaData . isDenyAll (  )  )  )  )     &  &     (  !  ( ejbMethodSecurityMetaData . isPermitAll (  )  )  )  )     {", "final   Set < String >    rolesAllowed    =    new   HashSet < String >  (  )  ;", "for    ( EJBMethodSecurityAttribute   attr    :    allAttributes )     {", "rolesAllowed . addAll ( attr . getRolesAllowed (  )  )  ;", "}", "ejbMethodSecurityMetaData    =    EJBMethodSecurityAttribute . rolesAllowed ( rolesAllowed )  ;", "}", "if    ( viewMethodSecurityAttributesServiceBuilder    !  =    null )     {", "viewMethodSecurityAttributesServiceBuilder . addMethodSecurityMetadata ( viewMethod ,    ejbMethodSecurityMetaData )  ;", "}", "if    ( ejbMethodSecurityMetaData . isPermitAll (  )  )     {", "return   true ;", "}", "final   Interceptor   authorizationInterceptor ;", "if    ( componentDescription . isSecurityDomainKnown (  )  )     {", "if    ( ejbMethodSecurityMetaData . isDenyAll (  )  )     {", "authorizationInterceptor    =    RolesAllowedInterceptor . DENY _ ALL ;", "} else    {", "if    ( componentDescription . isEnableJacc (  )  )     {", "authorizationInterceptor    =    new   JaccInterceptor ( viewClassName ,    viewMethod )  ;", "} else    {", "authorizationInterceptor    =    new   RolesAllowedInterceptor ( ejbMethodSecurityMetaData . getRolesAllowed (  )  )  ;", "}", "}", "} else    {", "authorizationInterceptor    =    new   AuthorizationInterceptor ( ejbMethodSecurityMetaData ,    viewClassName ,    viewMethod ,    contextID )  ;", "}", "vion . addViewInterceptor ( viewMethod ,    new   ImmediateInterceptorFactory ( authorizationInterceptor )  ,    EJB _ SECURITY _ AUTHORIZATION _ INTERCEPTOR )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["handlePermissions"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityViewConfigurator"}, {"methodBody": ["METHOD_START", "{", "if    ( viewMethodSecurityAttributesServiceBuilder    !  =    null )     {", "final   EJBViewMethodSecurityAttributesService   viewMethodSecurityAttributesService    =    viewMethodSecurityAttributesServiceBuilder . build (  )  ;", "context . getServiceTarget (  )  . addService ( viewMethodSecurityAttributesServiceName ,    viewMethodSecurityAttributesService )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["installAttributeServiceIfRequired"], "fileName": "org.jboss.as.ejb3.security.EJBSecurityViewConfigurator"}, {"methodBody": ["METHOD_START", "{", "deny . add ( permission )  ;", "}", "METHOD_END"], "methodName": ["addDeny"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfig"}, {"methodBody": ["METHOD_START", "{", "permit . add ( permission )  ;", "}", "METHOD_END"], "methodName": ["addPermit"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfig"}, {"methodBody": ["METHOD_START", "{", "roles . add ( new   EjbJaccConfig . Entry <  >  ( role ,    permission )  )  ;", "}", "METHOD_END"], "methodName": ["addRole"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfig"}, {"methodBody": ["METHOD_START", "{", "return   deny ;", "}", "METHOD_END"], "methodName": ["getDeny"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfig"}, {"methodBody": ["METHOD_START", "{", "return   permit ;", "}", "METHOD_END"], "methodName": ["getPermit"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfig"}, {"methodBody": ["METHOD_START", "{", "return   roles ;", "}", "METHOD_END"], "methodName": ["getRoles"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfig"}, {"methodBody": ["METHOD_START", "{", "MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifierForMethod ( viewMethod )  ;", "EJBMethodSecurityAttribute   ejbMethodSecurityMetaData    =    permissions . getViewAttribute ( ejbViewConfiguration . getMethodIntf (  )  ,    viewMethod )  ;", "if    ( ejbMethodSecurityMetaData    =  =    null )     {", "ejbMethodSecurityMetaData    =    permissions . getViewAttribute ( MethodIntf . BEAN ,    viewMethod )  ;", "}", "final   Method   classMethod    =    ClassReflectionIndexUtil . findMethod ( index ,    ejbViewConfiguration . getComponentConfiguration (  )  . getComponentClass (  )  ,    viewMethod )  ;", "if    ( ejbMethodSecurityMetaData    =  =    null )     {", "if    ( classMethod    !  =    null )     {", "methodIdentifier    =    MethodIdentifier . getIdentifierForMethod ( classMethod )  ;", "ejbMethodSecurityMetaData    =    permissions . getAttribute ( ejbViewConfiguration . getMethodIntf (  )  ,    classMethod )  ;", "if    ( ejbMethodSecurityMetaData    =  =    null )     {", "ejbMethodSecurityMetaData    =    permissions . getAttribute ( MethodIntf . BEAN ,    classMethod )  ;", "}", "}", "}", "if    ( ejbMethodSecurityMetaData    !  =    null )     {", "final   MethodInterfaceType   interfaceType    =    this . getMethodInterfaceType ( ejbViewConfiguration . getMethodIntf (  )  )  ;", "final   EJBMethodPermission   permission    =    new   EJBMethodPermission ( description . getEJBName (  )  ,    methodIdentifier . getName (  )  ,    interfaceType . name (  )  ,    methodIdentifier . getParameterTypes (  )  )  ;", "if    ( ejbMethodSecurityMetaData . isPermitAll (  )  )     {", "e . addPermit ( permission )  ;", "}", "if    ( ejbMethodSecurityMetaData . isDenyAll (  )  )     {", "e . addDeny ( permission )  ;", "}", "for    ( String   role    :    ejbMethodSecurityMetaData . getRolesAllowed (  )  )     {", "e . addRole ( role ,    permission )  ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["createPermissions"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfigurator"}, {"methodBody": ["METHOD_START", "{", "switch    ( viewType )     {", "case   HOME    :", "return   MethodInterfaceType . Home ;", "case   LOCAL _ HOME    :", "return   MethodInterfaceType . LocalHome ;", "case   SERVICE _ ENDPOINT    :", "return   MethodInterfaceType . ServiceEndpoint ;", "case   LOCAL    :", "return   MethodInterfaceType . Local ;", "case   REMOTE    :", "return   MethodInterfaceType . Remote ;", "case   TIMER    :", "return   MethodInterfaceType . Timer ;", "case   MESSAGE _ ENDPOINT    :", "return   MethodInterfaceType . MessageEndpoint ;", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getMethodInterfaceType"], "fileName": "org.jboss.as.ejb3.security.EjbJaccConfigurator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( identityOutflowFunction )     !  =    null )     {", "final   SecurityDomain   securityDomain    =    context . getPrivateData ( SecurityDomain . class )  ;", "final   SecurityIdentity   currentIdentity    =    securityDomain . getCurrentSecurityIdentity (  )  ;", "Set < SecurityIdentity >    outflowedIdentities    =    identityOutflowFunction . apply ( currentIdentity )  ;", "SecurityIdentity [  ]    newIdentities ;", "if    (  (  ( category )     !  =    null )     &  &     (  ( roleMapper )     !  =    null )  )     {", "newIdentities    =    outflowedIdentities . stream (  )  . map (  (    outflowedIdentity )     -  >     {", "final   RoleMapper   mergeMapper    =    roleMapper . or (  (    roles )     -  >    outflowedIdentity . getRoles ( category )  )  ;", "return   outflowedIdentity . withRoleMapper ( category ,    mergeMapper )  ;", "}  )  . toArray ( SecurityIdentity [  ]  :  : new )  ;", "} else    {", "newIdentities    =    outflowedIdentities . toArray ( new   SecurityIdentity [ outflowedIdentities . size (  )  ]  )  ;", "}", "return   SecurityIdentity . runAsAll ( context ,    newIdentities )  ;", "} else    {", "return   context . proceed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.security.IdentityOutflowInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   EJBMethodPermission ( ejbComponent . getComponentName (  )  ,    methodIntfType . name (  )  ,    invokedMethod )  ;", "}", "METHOD_END"], "methodName": ["createEjbMethodPermission"], "fileName": "org.jboss.as.ejb3.security.JaccInterceptor"}, {"methodBody": ["METHOD_START", "{", "Set < String >    roles    =    new   HashSet <  >  (  )  ;", "for    ( String   s    :    securityIdentity . getRoles (  \" ejb \"  )  )     {", "roles . add ( s )  ;", "}", "List < Principal >    list    =    new   ArrayList <  >  (  )  ;", "Function < String ,    Principal >    mapper    =     (    roleName )     -  >     (  ( Principal )     (  (  )     -  >    roleName )  )  ;", "for    ( String   role    :    roles )     {", "Principal   principal    =    mapper . apply ( role )  ;", "list . add ( principal )  ;", "}", "return   list . toArray (  . NO _ PRINCIPALS )  ;", "}", "METHOD_END"], "methodName": ["getGrantedRoles"], "fileName": "org.jboss.as.ejb3.security.JaccInterceptor"}, {"methodBody": ["METHOD_START", "{", "switch    ( viewType )     {", "case   HOME    :", "return   MethodfaceType . Home ;", "case   LOCAL _ HOME    :", "return   MethodfaceType . LocalHome ;", "case   SERVICE _ ENDPOINT    :", "return   MethodfaceType . ServiceEndpoint ;", "case   LOCAL    :", "return   MethodfaceType . Local ;", "case   REMOTE    :", "return   MethodfaceType . Remote ;", "case   TIMER    :", "return   MethodfaceType . Timer ;", "case   MESSAGE _ ENDPOINT    :", "return   MethodfaceType . MessageEndpoint ;", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getMethodInterfaceType"], "fileName": "org.jboss.as.ejb3.security.JaccInterceptor"}, {"methodBody": ["METHOD_START", "{", "MethodInterfaceType   methodIntfType    =    getMethodInterfaceType ( componentView . getPrivateData ( MethodIntf . class )  )  ;", "EJBMethodPermission   permission    =    createEjbMethodPermission ( method ,    ejbComponent ,    methodIntfType )  ;", "ProtectionDomain   domain    =    new   ProtectionDomain ( componentView . getProxyClass (  )  . getProtectionDomain (  )  . getCodeSource (  )  ,    null ,    null ,     . getGrantedRoles ( securityIdentity )  )  ;", "Policy   policy    =     ( WildFlySecurityManager . isChecking (  )  )     ?    AccessController . doPrivileged (  (  ( PrivilegedAction < Policy >  )     ( Policy :  : getPolicy )  )  )     :    Policy . getPolicy (  )  ;", "if    (  !  ( policy . implies ( domain ,    permission )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . invocationOfMethodNotAllowed ( method ,    ejbComponent . getComponentName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["hasPermission"], "fileName": "org.jboss.as.ejb3.security.JaccInterceptor"}, {"methodBody": ["METHOD_START", "{", "PolicyContext . setContextID ( policyContextID )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["doSetContextID"], "fileName": "org.jboss.as.ejb3.security.PolicyContextIdInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   String   oldId    =    PolicyContext . getContextID (  )  ;", ". setContextID ( policyContextID )  ;", "try    {", "return   context . proceed (  )  ;", "}    finally    {", ". setContextID ( oldId )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.security.PolicyContextIdInterceptor"}, {"methodBody": ["METHOD_START", "{", "WildFlySecurityManager . doPrivilegedWithParameter ( contextID ,     (  ( ParametricPrivilegedAction < Void ,    String >  )     ( PolicyContextIdInterceptor :  : doSetContextID )  )  )  ;", "}", "METHOD_END"], "methodName": ["setContextID"], "fileName": "org.jboss.as.ejb3.security.PolicyContextIdInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   SecurityDomain   securityDomain    =    context . getPrivateData ( SecurityDomain . class )  ;", "Assert . checkNotNullParam (  \" securityDomain \"  ,    securityDomain )  ;", "final   SecurityIdentity   currentIdentity    =    securityDomain . getCurrentSecurityIdentity (  )  ;", "final   RoleMapper   mergeMapper    =    roleMapper . or (  (    roles )     -  >    currentIdentity . getRoles ( category )  )  ;", "final   SecurityIdentity   newIdentity    =    currentIdentity . withRoleMapper ( category ,    mergeMapper )  ;", "try    {", "return   newIdentity . runAs ( context )  ;", "}    catch    ( PrivilegedActionException   e )     {", "Throwable   cause    =    e . getCause (  )  ;", "if    ( cause    !  =    null )     {", "if    ( cause   instanceof   Exception )     {", "throw    (  ( Exception )     ( cause )  )  ;", "} else    {", "throw   new   RuntimeException ( e )  ;", "}", "} else    {", "throw   e ;", "}", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.security.RoleAddingInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   Component   component    =    context . getPrivateData ( Component . class )  ;", "if    (  !  ( component   instanceof   EJBComponent )  )     {", "throw   EjbLogger . ROOT _ LOGGER . unexpectedComponent ( component ,    EJBComponent . class )  ;", "}", "final   Iterator < String >    iterator    =    r . iterator (  )  ;", "if    ( iterator . hasNext (  )  )     {", "final   SecurityDomain   securityDomain    =    context . getPrivateData ( SecurityDomain . class )  ;", "final   SecurityIdentity   identity    =    securityDomain . getCurrentSecurityIdentity (  )  ;", "final   Roles   ejbRoles    =    identity . getRoles (  \" ejb \"  ,    true )  ;", "do    {", "final   String   role    =    iterator . next (  )  ;", "if    (  ( ejbRoles . contains ( role )  )     |  |     (  ( role . equals (  \"  *  *  \"  )  )     &  &     (  !  ( identity . isAnonymous (  )  )  )  )  )     {", "return   context . proceed (  )  ;", "}", "}    while    ( iterator . hasNext (  )     )  ;", "}", "throw   EjbLogger . ROOT _ LOGGER . invocationOfMethodNotAllowed ( context . getMethod (  )  ,     (  ( EJBComponent )     ( component )  )  . getComponentName (  )  )  ;", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.security.RolesAllowedInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   Component   component    =    context . getPrivateData ( Component . class )  ;", "if    (  ( component   instanceof   EJBComponent )     =  =    false )     {", "throw   EjbLogger . ROOT _ LOGGER . unexpectedComponent ( component ,    EJBComponent . class )  ;", "}", "final   EJBComponent   ejbComponent    =     (  ( EJBComponent )     ( component )  )  ;", "final   SecurityDomain   securityDomain    =    context . getPrivateData ( SecurityDomain . class )  ;", "Assert . checkNotNullParam (  \" securityDomain \"  ,    securityDomain )  ;", "final   SecurityIdentity   currentIdentity    =    securityDomain . getCurrentSecurityIdentity (  )  ;", "final   SecurityIdentity   oldIncomingRunAsIdentity    =    ejbComponent . getIncomingRunAsIdentity (  )  ;", "SecurityIdentity   newIdentity ;", "try    {", "if    ( runAsPrincipal . equals (  . ANONYMOUS _ PRINCIPAL )  )     {", "try    {", "newIdentity    =    currentIdentity . createRunAsAnonymous (  )  ;", "}    catch    ( AuthorizationFailureException   ex )     {", "newIdentity    =    currentIdentity . createRunAsAnonymous ( false )  ;", "}", "} else    {", "if    (  !  ( runAsPrincipalExists ( securityDomain ,    runAsPrincipal )  )  )     {", "newIdentity    =    securityDomain . createAdHocIdentity ( runAsPrincipal )  ;", "} else    {", "try    {", "newIdentity    =    currentIdentity . createRunAsIdentity ( runAsPrincipal )  ;", "}    catch    ( AuthorizationFailureException   ex )     {", "newIdentity    =    currentIdentity . createRunAsIdentity ( runAsPrincipal ,    false )  ;", "}", "}", "}", "ejbComponent . setIncomingRunAsIdentity ( currentIdentity )  ;", "return   newIdentity . runAs ( context )  ;", "}    catch    ( PrivilegedActionException   e )     {", "Throwable   cause    =    e . getCause (  )  ;", "if    ( cause    !  =    null )     {", "if    ( cause   instanceof   Exception )     {", "throw    (  ( Exception )     ( cause )  )  ;", "} else    {", "throw   new   RuntimeException ( e )  ;", "}", "} else    {", "throw   e ;", "}", "}    finally    {", "ejbComponent . setIncomingRunAsIdentity ( oldIncomingRunAsIdentity )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.security.RunAsPrincipalInterceptor"}, {"methodBody": ["METHOD_START", "{", "RealmIdentity   realmIdentity    =    null ;", "try    {", "realmIdentity    =    securityDomain . getIdentity ( r )  ;", "return   realmIdentity . exists (  )  ;", "}    finally    {", "if    ( realmIdentity    !  =    null )     {", "realmIdentity . dispose (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["runAsPrincipalExists"], "fileName": "org.jboss.as.ejb3.security.RunAsPrincipalInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "final   String   previousID    =    PolicyContext . getContextID (  )  ;", "PolicyContext . setContextID ( contextID )  ;", "return   previousID ;", "} else    {", "final   PrivilegedAction < String >    action    =    new    . SetContextIDAction ( contextID )  ;", "return   AccessController . doPrivileged ( action )  ;", "}", "}", "METHOD_END"], "methodName": ["setContextID"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . extraRoles    =    er ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExtraRoles"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "this . policyContextID    =    policyContextID ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPolicyContextID"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "this . principalVsRolesMap    =    pr ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPrincipalVsRolesMap"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "this . runAs    =    ras ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRunAs"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "this . runAsPrincipal    =    ras ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRunAsPrincipal"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "this . securityDomain    =    sd ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSecurityDomain"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "this . securityManager    =    ssm ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSecurityManager"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "this . skipAuthentication    =    skipAuthentication ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSkipAuthentication"], "fileName": "org.jboss.as.ejb3.security.SecurityContextInterceptorHolder"}, {"methodBody": ["METHOD_START", "{", "final   SecurityDomain   oldDomain    =    context . putPrivateData ( SecurityDomain . class ,    securityDomain )  ;", "try    {", "return   context . proceed (  )  ;", "}    finally    {", "context . putPrivateData ( SecurityDomain . class ,    oldDomain )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.security.SecurityDomainInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   SecurityDomain   securityDomain    =    context . getPrivateData ( SecurityDomain . class )  ;", "Assert . checkNotNullParam (  \" securityDomain \"  ,    securityDomain )  ;", "final   SecurityIdentity   currentIdentity    =    securityDomain . getCurrentSecurityIdentity (  )  ;", "final   Set < String >    s    =    principalVsRolesMap . get ( currentIdentity . getPrincipal (  )  . getName (  )  )  ;", "if    (  ( s    !  =    null )     &  &     (  !  ( s . isEmpty (  )  )  )  )     {", "final   RoleMapper   roleMapper    =    RoleMapper . constant ( Roles . fromSet ( s )  )  ;", "final   RoleMapper   mergeMapper    =    roleMapper . or (  (    roles )     -  >    currentIdentity . getRoles ( category )  )  ;", "final   SecurityIdentity   newIdentity ;", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "newIdentity    =    AccessController . doPrivileged (  (  ( PrivilegedAction < SecurityIdentity >  )     (  (  )     -  >    currentIdentity . withRoleMapper ( category ,    mergeMapper )  )  )  )  ;", "} else    {", "newIdentity    =    currentIdentity . withRoleMapper ( category ,    mergeMapper )  ;", "}", "try    {", "return   newIdentity . runAs ( context )  ;", "}    catch    ( PrivilegedActionException   e )     {", "Throwable   cause    =    e . getCause (  )  ;", "if    ( cause    !  =    null )     {", "if    ( cause   instanceof   Exception )     {", "throw    (  ( Exception )     ( cause )  )  ;", "} else    {", "throw   new   RuntimeException ( e )  ;", "}", "} else    {", "throw   e ;", "}", "}", "} else    {", "return   context . proceed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.security.SecurityRolesAddingInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . missingMethodPermissionsDenyAccess ;", "}", "METHOD_END"], "methodName": ["getMissingMethodPermissionsDenyAccess"], "fileName": "org.jboss.as.ejb3.security.metadata.EJBBoundSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   runAsPrincipal ;", "}", "METHOD_END"], "methodName": ["getRunAsPrincipal"], "fileName": "org.jboss.as.ejb3.security.metadata.EJBBoundSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   securityDomain ;", "}", "METHOD_END"], "methodName": ["getSecurityDomain"], "fileName": "org.jboss.as.ejb3.security.metadata.EJBBoundSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "this . missingMethodPermissionsDenyAccess    =    missingMethodPermissionsDenyAccess ;", "}", "METHOD_END"], "methodName": ["setMissingMethodPermissionsDenyAccess"], "fileName": "org.jboss.as.ejb3.security.metadata.EJBBoundSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "this . runAsPrincipal    =    runAsPrincipal ;", "}", "METHOD_END"], "methodName": ["setRunAsPrincipal"], "fileName": "org.jboss.as.ejb3.security.metadata.EJBBoundSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "this . securityDomain    =    securityDomain ;", "}", "METHOD_END"], "methodName": ["setSecurityDomain"], "fileName": "org.jboss.as.ejb3.security.metadata.EJBBoundSecurityMetaData"}, {"methodBody": ["METHOD_START", "{", "return   methodSecurityAttributes . get ( viewMethod )  ;", "}", "METHOD_END"], "methodName": ["getSecurityAttributes"], "fileName": "org.jboss.as.ejb3.security.service.EJBViewMethodSecurityAttributesService"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName ;", "if    ( appName    !  =    null )     {", "serviceName    =     . BASE _ SERVICE _ NAME . append ( appName )  ;", "} else    {", "serviceName    =     . BASE _ SERVICE _ NAME ;", "}", "return   serviceName . append ( moduleName )  . append ( beanName )  . append ( viewClassName )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ejb3.security.service.EJBViewMethodSecurityAttributesService"}, {"methodBody": ["METHOD_START", "{", "return    (    name )     -  >     {", "for    ( ApplicationSecurityDomainConfig   applicationSecurityDomainConfig    :     . knownApplicationSecurityDomains )     {", "if    ( applicationSecurityDomainConfig . isSameDomain ( name )  )     {", "return   applicationSecurityDomainConfig ;", "}", "}", "return   null ;", "}  ;", "}", "METHOD_END"], "methodName": ["getKnownSecurityDomainFunction"], "fileName": "org.jboss.as.ejb3.subsystem.ApplicationSecurityDomainDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( registrations )     {", "Set < String >    deploymentNames    =    new   HashSet <  >  (  )  ;", "for    (  . RegistrationImpl   r    :    registrations )     {", "String   deploymentName    =    r . deploymentName ;", "deploymentNames . add ( deploymentName )  ;", "}", "return   deploymentNames . toArray ( new   String [ deploymentNames . size (  )  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeployments"], "fileName": "org.jboss.as.ejb3.subsystem.ApplicationSecurityDomainService"}, {"methodBody": ["METHOD_START", "{", "return   securityDomainInjector ;", "}", "METHOD_END"], "methodName": ["getSecurityDomainInjector"], "fileName": "org.jboss.as.ejb3.subsystem.ApplicationSecurityDomainService"}, {"methodBody": ["METHOD_START", "{", "if    ( passivationStore    =  =    null )     {", "return   new   SimpleCacheFactoryBuilderService <  >  ( name )  . build ( target )  ;", "}", "return   new   cache . DelegateCacheFactoryBuilderService ( name ,    DistributableCacheFactoryBuilderService . getServiceName ( passivationStore )  )  . build ( target )  ;", "}", "METHOD_END"], "methodName": ["buildCacheFactoryBuilder"], "fileName": "org.jboss.as.ejb3.subsystem.CacheFactoryAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attr    :    DatabaseDataStoreResourceDefinition . ATTRIBUTES . values (  )  )     {", "attr . validateAndSet ( operation ,    timerServiceModel )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.ejb3.subsystem.DatabaseDataStoreAdd"}, {"methodBody": ["METHOD_START", "{", "return   defaultDistinctName ;", "}", "METHOD_END"], "methodName": ["getDefaultDistinctName"], "fileName": "org.jboss.as.ejb3.subsystem.DefaultDistinctNameService"}, {"methodBody": ["METHOD_START", "{", "this . defaultDistinctName    =    defaultDistinctName ;", "}", "METHOD_END"], "methodName": ["setDefaultDistinctName"], "fileName": "org.jboss.as.ejb3.subsystem.DefaultDistinctNameService"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   adapterNameNode    =    EJB 3 SubsystemRootResourceDefinition . DEFAULT _ RESOURCE _ ADAPTER _ NAME . resolveModelAttribute ( context ,    model )  ;", "final   String   adapterName    =     ( adapterNameNode . isDefined (  )  )     ?    adapterNameNode . asString (  )     :    null ;", "final   ServiceRegistry   serviceRegistry    =    context . getServiceRegistry ( true )  ;", "ServiceController < Service >    existingDefaultRANameService    =     (  ( ServiceController < Service >  )     ( serviceRegistry . getService ( Service . DEFAULT _ RA _ NAME _ SERVICE _ NAME )  )  )  ;", "if    ( existingDefaultRANameService    !  =    null )     {", "existingDefaultRANameService . getValue (  )  . setResourceAdapterName ( adapterName )  ;", "} else", "if    ( adapterName    !  =    null )     {", "final   Service   defaultResourceAdapterService    =    new   Service ( adapterName )  ;", "ServiceController <  ?  >    newController    =    context . getServiceTarget (  )  . addService ( Service . DEFAULT _ RA _ NAME _ SERVICE _ NAME ,    defaultResourceAdapterService )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateDefaultAdapterService"], "fileName": "org.jboss.as.ejb3.subsystem.DefaultResourceAdapterWriteHandler"}, {"methodBody": ["METHOD_START", "{", "long   timeout    =    attribute . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   ServiceRegistry   serviceRegistry    =    context . getServiceRegistry ( true )  ;", "ServiceController < DefaultService >    controller    =     (  ( ServiceController < DefaultService >  )     ( serviceRegistry . getService ( serviceName )  )  )  ;", "if    ( controller    !  =    null )     {", "DefaultService   service    =    controller . getValue (  )  ;", "if    ( service    !  =    null )     {", "service . setDefault ( timeout )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyModelToRuntime"], "fileName": "org.jboss.as.ejb3.subsystem.DefaultSessionBeanAccessTimeoutWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   long   defaultAccessTimeout    =    EJB 3 SubsystemRootResourceDefinition . DEFAULT _ SINGLETON _ BEAN _ ACCESS _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   ServiceName   serviceName    =    DefaultAccessTimeoutService . SINGLETON _ SERVICE _ NAME ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceController <  ?  >    sc    =    registry . getService ( serviceName )  ;", "if    ( sc    !  =    null )     {", "final   DefaultAccessTimeoutService   defaultAccessTimeoutService    =    DefaultAccessTimeoutService . class . cast ( sc . getValue (  )  )  ;", "defaultAccessTimeoutService . setDefaultAccessTimeout ( defaultAccessTimeout )  ;", "} else    {", "final   DefaultAccessTimeoutService   defaultAccessTimeoutService    =    new   DefaultAccessTimeoutService ( defaultAccessTimeout )  ;", "final   ServiceController <  ?  >    newService    =    context . getServiceTarget (  )  . addService ( serviceName ,    defaultAccessTimeoutService )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateOrCreateDefaultSingletonBeanAccessTimeoutService"], "fileName": "org.jboss.as.ejb3.subsystem.DefaultSingletonBeanAccessTimeoutWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   long   defaultAccessTimeout    =    EJB 3 SubsystemRootResourceDefinition . DEFAULT _ STATEFUL _ BEAN _ ACCESS _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   ServiceName   serviceName    =    DefaultAccessTimeoutService . STATEFUL _ SERVICE _ NAME ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceController <  ?  >    sc    =    registry . getService ( serviceName )  ;", "if    ( sc    !  =    null )     {", "final   DefaultAccessTimeoutService   defaultAccessTimeoutService    =    DefaultAccessTimeoutService . class . cast ( sc . getValue (  )  )  ;", "defaultAccessTimeoutService . setDefaultAccessTimeout ( defaultAccessTimeout )  ;", "} else    {", "final   DefaultAccessTimeoutService   defaultAccessTimeoutService    =    new   DefaultAccessTimeoutService ( defaultAccessTimeout )  ;", "final   ServiceController <  ?  >    newService    =    context . getServiceTarget (  )  . addService ( serviceName ,    defaultAccessTimeoutService )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateOrCreateDefaultStatefulBeanAccessTimeoutService"], "fileName": "org.jboss.as.ejb3.subsystem.DefaultStatefulBeanAccessTimeoutWriteHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardResourceDescriptionResolver ( keyPrefix ,    EJB 3 Extension . RESOURCE _ NAME ,    EJB 3 Extension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Extension"}, {"methodBody": ["METHOD_START", "{", "return   this . version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Model"}, {"methodBody": ["METHOD_START", "{", "return   this . version . equals ( version )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Model"}, {"methodBody": ["METHOD_START", "{", "return    ( ModelVersion . compare ( this . version ,    version )  )     <     0  ;", "}", "METHOD_END"], "methodName": ["requiresTransformation"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Model"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   fullModel    =    Tools . readModel ( context . readResource ( EMPTY _ ADDRESS )  )  ;", "final   ModelNode   channelCreationOptions    =    fullModel . get ( EJB 3 SModel . CHANNEL _ CREATION _ OPTIONS )  ;", "if    (  ( channelCreationOptions . isDefined (  )  )     &  &     (  ( channelCreationOptions . asInt (  )  )     >     0  )  )     {", "final   ClassLoader   loader    =    this . getClass (  )  . getClassLoader (  )  ;", "final   OptionMap . Builder   builder    =    OptionMap . builder (  )  ;", "for    ( final   Property   optionProperty    :    channelCreationOptions . asPropertyList (  )  )     {", "final   String   name    =    optionProperty . getName (  )  ;", "final   ModelNode   propValueModel    =    optionProperty . getValue (  )  ;", "final   String   type    =    RemoteConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ TYPE . resolveModelAttribute ( context ,    propValueModel )  . asString (  )  ;", "final   String   optionClassName    =    this . getClassNameForChannelOptionType ( type )  ;", "final   String   fullyQualifiedOptionName    =     ( optionClassName    +     \"  .  \"  )     +    name ;", "final   Option   option    =    Option . fromString ( fullyQualifiedOptionName ,    loader )  ;", "final   String   value    =    RemoteConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ VALUE . resolveModelAttribute ( context ,    propValueModel )  . asString (  )  ;", "builder . set ( option ,    option . parseValue ( value ,    loader )  )  ;", "}", "return   builder . getMap (  )  ;", "}", "return   OptionMap . EMPTY ;", "}", "METHOD_END"], "methodName": ["getChannelCreationOptions"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3RemoteServiceAdd"}, {"methodBody": ["METHOD_START", "{", "if    (  \" remoting \"  . equals ( optionType )  )     {", "return   ingOptions . class . getName (  )  ;", "}", "if    (  \" xnio \"  . equals ( optionType )  )     {", "return   Options . class . getName (  )  ;", "}", "throw   EjbLogger . ROOT _ LOGGER . unknownChannelCreationOptionType ( optionType )  ;", "}", "METHOD_END"], "methodName": ["getClassNameForChannelOptionType"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3RemoteServiceAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   clientMappingsClusterName    =    EJB 3 RemoteResourceDefinition . CLIENT _ MAPPINGS _ CLUSTER _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   connectorName    =    EJB 3 RemoteResourceDefinition . CONNECTOR _ REF . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ServiceName   remotingServerInfoServiceName    =    RemotingConnectorBindingInfoService . serviceName ( connectorName )  ;", "final   String   threadPoolName    =    EJB 3 RemoteResourceDefinition . THREAD _ POOL _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   boolean   executeInWorker    =    EJB 3 RemoteResourceDefinition . EXECUTE _ IN _ WORKER . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   ServiceTarget   target    =    context . getServiceTarget (  )  ;", "new   EJBRemotingConnectorClientMappingsEntryProviderService ( clientMappingsClusterName ,    remotingServerInfoServiceName )  . configure ( context )  . build ( target )  . setInitialMode ( ON _ DEMAND )  . install (  )  ;", "new   ClientMappingsRegistryBuilder ( clientMappingsClusterName )  . configure ( context )  . build ( target )  . setInitialMode ( ON _ DEMAND )  . install (  )  ;", "PathElement   infinispanPath    =    PathElement . pathElement ( SUBSYSTEM ,     \" infinispan \"  )  ;", "Resource   infinispanResource    =     . safeGetResource ( context ,    infinispanPath )  ;", "if    (  ( infinispanResource    =  =    null )     |  |     (  !  ( infinispanResource . hasChild ( PathElement . pathElement (  \" cache - container \"  ,    clientMappingsClusterName )  )  )  )  )     {", "CapabilityServiceSupport   support    =    context . getCapabilityServiceSupport (  )  ;", "for    ( GroupBuilderProvider   provider    :    ServiceLoader . load ( LocalGroupBuilderProvider . class ,    LocalGroupBuilderProvider . class . getClassLoader (  )  )  )     {", "for    ( CapabilityServiceBuilder <  ?  >    builder    :    provider . getBuilders (  (    requirement )     -  >    requirement . getServiceName ( support ,    clientMappingsClusterName )  ,    clientMappingsClusterName )  )     {", "builder . configure ( support )  . build ( target )  . install (  )  ;", "}", "}", "for    ( CacheBuilderProvider   provider    :    ServiceLoader . load ( LocalCacheBuilderProvider . class ,    LocalCacheBuilderProvider . class . getClassLoader (  )  )  )     {", "for    ( CapabilityServiceBuilder <  ?  >    builder    :    provider . getBuilders (  (    requirement )     -  >    requirement . getServiceName ( support ,    clientMappingsClusterName ,    null )  ,    clientMappingsClusterName ,    null )  )     {", "builder . configure ( support )  . build ( target )  . install (  )  ;", "}", "}", "}", "final   OptionMap   channelCreationOptions    =    this . getChannelCreationOptions ( context )  ;", "final   EJBRemoteConnectorService   ejbRemoteConnectorService    =    new   EJBRemoteConnectorService ( channelCreationOptions )  ;", "ServiceBuilder <  ?  >    builder    =    context . getCapabilityServiceTarget (  )  . addCapability ( EJB 3 RemoteResourceDefinition . EJB _ REMOTE _ CAPABILITY ,    ejbRemoteConnectorService )  . addAliases ( EJBRemoteConnectorService . SERVICE _ NAME )  . addDependency ( SUBSYSTEM _ ENDPOINT ,    Endpoint . class ,    ejbRemoteConnectorService . getEndpointInjector (  )  )  . addDependency ( remotingServerInfoServiceName ,    RemotingConnectorInfo . class ,    ejbRemoteConnectorService . getRemotingConnectorInfoInjectedValue (  )  )  . addDependency ( AssociationService . SERVICE _ NAME ,    AssociationService . class ,    ejbRemoteConnectorService . getAssociationServiceInjector (  )  )  . addDependency ( JBOSS _ TXN _ REMOTE _ TRANSACTION _ SERVICE ,    RemotingTransactionService . class ,    ejbRemoteConnectorService . getRemotingTransactionServiceInjector (  )  )  . setInitialMode ( LAZY )  ;", "if    (  ! executeInWorker )     {", "builder . addDependency ( EJB 3 SubsystemModel . BASE _ THREAD _ POOL _ SERVICE _ NAME . append ( threadPoolName )  ,    ExecutorService . class ,    ejbRemoteConnectorService . getExecutorService (  )  )  ;", "}", "builder . install (  )  ;", "}", "METHOD_END"], "methodName": ["installRuntimeServices"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3RemoteServiceAdd"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   context . readResourceFromRoot ( PathAddrepathAddrepath )  ,    false )  ;", "}    catch    ( RuntimeException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["safeGetResource"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3RemoteServiceAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   addStrictMaxPoolOperation    =    new   ModelNode (  )  ;", "addStrictMaxPoolOperation . get ( OP )  . set ( ADD )  ;", "final   PathAddress   address    =    this . getAddress (  )  . append ( PathElement . pathElement ( Model . STRICT _ MAX _ BEAN _ INSTANCE _ POOL ,    name )  )  ;", "addStrictMaxPoolOperation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "if    ( maxPoolSize    !  =    null )     {", "addStrictMaxPoolOperation . get ( Model . MAX _ POOL _ SIZE )  . set ( maxPoolSize )  ;", "}", "if    ( timeout    !  =    null )     {", "addStrictMaxPoolOperation . get ( Model . INSTANCE _ ACQUISITION _ TIMEOUT )  . set ( timeout )  ;", "}", "if    ( timeoutUnit    !  =    null )     {", "addStrictMaxPoolOperation . get ( Model . INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT )  . set ( timeoutUnit )  ;", "}", "return   addStrictMaxPoolOperation ;", "}", "METHOD_END"], "methodName": ["createAddStrictMaxBeanInstancePoolOperation"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "return   EJB 3 Subsystem 1  2 Parser . SUBSYSTEM _ PATH ;", "}", "METHOD_END"], "methodName": ["getEJB3SubsystemAddress"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   STRICT _ MAX _ POOL    :", "{", "this . parseStrictMaxPool ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBeanInstancePools"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   mdbModelNode    =    new   ModelNode (  )  ;", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   BEAN _ INSTANCE _ POOL _ REF    :", "{", "final   String   poolName    =    readStringAttributeElement ( reader ,    XMLAttribute . POOL _ NAME . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ MDB _ INSTANCE _ POOL . parseAndSetParameter ( poolName ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "case   RESOURCE _ ADAPTER _ REF    :", "{", "final   String   resourceAdapterName    =    readStringAttributeElement ( reader ,    XMLAttribute . RESOURCE _ ADAPTER _ NAME . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ RESOURCE _ ADAPTER _ NAME . parseAndSetParameter ( resourceAdapterName ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "if    (  !  ( ejb 3 SubsystemAddOperation . hasDefined ( Model . DEFAULT _ RESOURCE _ ADAPTER _ NAME )  )  )     {", "final   ModelNode   defaultRAName    =    RootResourceDefinition . DEFAULT _ RESOURCE _ ADAPTER _ NAME . getDefaultValue (  )  ;", "if    ( defaultRAName    !  =    null )     {", "ejb 3 SubsystemAddOperation . get ( Model . DEFAULT _ RESOURCE _ ADAPTER _ NAME )  . set ( defaultRAName )  ;", "}", "}", "return   mdbModelNode ;", "}", "METHOD_END"], "methodName": ["parseMDB"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   BEAN _ INSTANCE _ POOLS    :", "{", "this . parseBeanInstancePools ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parsePools"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   STATELESS    :", "{", "this . parseStatelessBean ( reader ,    operations ,    ejb 3 SubsystemAddOperation )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseSessionBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   BEAN _ INSTANCE _ POOL _ REF    :", "{", "final   String   poolName    =    readStringAttributeElement ( reader ,    XMLAttribute . POOL _ NAME . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ SLSB _ INSTANCE _ POOL . parseAndSetParameter ( poolName ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseStatelessBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   poolName    =    null ;", "Integer   maxPoolSize    =    null ;", "Long   timeout    =    null ;", "String   unit    =    null ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "poolName    =    value ;", "break ;", "case   MAX _ POOL _ SIZE    :", "maxPoolSize    =    StrictMaxPoolResourceDefinition . MAX _ POOL _ SIZE . parse ( value ,    reader )  . asInt (  )  ;", "break ;", "case   INSTANCE _ ACQUISITION _ TIMEOUT    :", "timeout    =    StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT . parse ( value ,    reader )  . asLong (  )  ;", "break ;", "case   INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT    :", "unit    =    StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    ( poolName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "operations . add ( this . createAddStrictMaxBeanInstancePoolOperation ( poolName ,    maxPoolSize ,    timeout ,    unit )  )  ;", "}", "METHOD_END"], "methodName": ["parseStrictMaxPool"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "final   ModelNode   timerServiceAdd    =    new   ModelNode (  )  ;", "timerServiceAdd . get ( OP )  . set ( ADD )  ;", "timerServiceAdd . get ( OP _ ADDR )  . set ( address )  ;", "String   dataStorePath    =    null ;", "String   dataStorePathRelativeTo    =    null ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   THREAD _ POOL    :", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   CORE _ THREADS    :", "break ;", "case   MAX _ THREADS    :", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "break ;", "}", "case   DATA _ STORE    :", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PATH    :", "if    ( dataStorePath    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePath    =    FileDataStoreResourceDefinition . PATH . parse ( value ,    reader )  . asString (  )  ;", "break ;", "case   RELATIVE _ TO    :", "if    ( dataStorePathRelativeTo    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePathRelativeTo    =    FileDataStoreResourceDefinition . RELATIVE _ TO . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( dataStorePath    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . PATH )  )  ;", "}", "timerServiceAdd . get ( Model . DEFAULT _ DATA _ STORE )  . set (  \" default - file - store \"  )  ;", "final   ModelNode   fileDataStoreAdd    =    new   ModelNode (  )  ;", "final   ModelNode   fileDataAddress    =    address . clone (  )  ;", "fileDataAddress . add ( Model . FILE _ DATA _ STORE ,     \" default - file - store \"  )  ;", "fileDataStoreAdd . get ( OP )  . set ( ADD )  ;", "fileDataStoreAdd . get ( OP _ ADDR )  . set ( fileDataAddress )  ;", "fileDataStoreAdd . get ( Model . PATH )  . set ( dataStorePath )  ;", "if    ( dataStorePathRelativeTo    !  =    null )     {", "fileDataStoreAdd . get ( Model . RELATIVE _ TO )  . set ( dataStorePathRelativeTo )  ;", "}", "requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "operations . add ( timerServiceAdd )  ;", "}", "METHOD_END"], "methodName": ["parseTimerService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem11Parser"}, {"methodBody": ["METHOD_START", "{", "return   EJB 3 Subsystem 1  2 Parser . SUBSYSTEM _ PATH ;", "}", "METHOD_END"], "methodName": ["getEJB3SubsystemAddress"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "return   EJB 3 SubsystemNamespace . EJB 3  _  1  _  2  ;", "}", "METHOD_END"], "methodName": ["getExpectedNamespace"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "ModelNode   operation    =    Util . createAddOperation (  . SUBSYSTEM _ PATH . append ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . ASYNC )  )  ;", "final   EnumSet < EJB 3 SubsystemXMLAttribute >    required    =    EnumSet . of ( EJB 3 SubsystemXMLAttribute . THREAD _ POOL _ NAME )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   EJB 3 SubsystemXMLAttribute   attribute    =    EJB 3 SubsystemXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   THREAD _ POOL _ NAME    :", "EJB 3 AsyncResourceDefinition . THREAD _ POOL _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseAsync"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   STRICT _ MAX _ POOL    :", "{", "this . parseStrictMaxPool ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseBeanInstancePools"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  )     {", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "case   PASSIVATION _ STORE _ REF    :", "{", "CacheFactoryResourceDefinition . PASSIVATION _ STORE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   ALIASES    :", "{", "for    ( String   alias    :    reader . getListAttributeValue ( i )  )     {", "CacheFactoryResourceDefinition . ALIASES . parseAndAddParameterElement ( alias ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "{", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "requireNoContent ( reader )  ;", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "final   PathAddress   address    =    this . getAddress (  )  . append ( PathElement . pathElement ( Model . CACHE ,    name )  )  ;", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseCache"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . CACHE    :", "{", "this . parseCache ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseCaches"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( EJB 3 SubsystemXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  )     {", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "case   MAX _ SIZE    :", "{", "ClusterPassivationStoreResourceDefinition . MAX _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   IDLE _ TIMEOUT    :", "{", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   IDLE _ TIMEOUT _ UNIT    :", "{", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT _ UNIT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   CACHE _ CONTAINER    :", "{", "ClusterPassivationStoreResourceDefinition . CACHE _ CONTAINER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   BEAN _ CACHE    :", "{", "ClusterPassivationStoreResourceDefinition . BEAN _ CACHE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   CLIENT _ MAPPINGS _ CACHE    :", "{", "ClusterPassivationStoreResourceDefinition . CLIENT _ MAPPINGS _ CACHE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   PASSIVATE _ EVENTS _ ON _ REPLICATE    :", "{", "ClusterPassivationStoreResourceDefinition . PASSIVATE _ EVENTS _ ON _ REPLICATE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "requireNoContent ( reader )  ;", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( EJB 3 SubsystemXMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "operation . get ( OP _ ADDR )  . set (  . SUBSYSTEM _ PATH . append ( EJB 3 SubsystemModel . CLUSTER _ PASSIVATION _ STORE ,    name )  . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseClusterPassivationStore"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   BEAN _ INSTANCE _ POOL _ REF    :", "{", "final   String   poolName    =    readStringAttributeElement ( reader ,    XMLAttribute . POOL _ NAME . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ ENTITY _ BEAN _ INSTANCE _ POOL . parseAndSetParameter ( poolName ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "case   OPTIMISTIC _ LOCKING    :", "{", "final   String   enabled    =    readStringAttributeElement ( reader ,    XMLAttribute . ENABLED . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ ENTITY _ BEAN _ OPTIMISTIC _ LOCKING . parseAndSetParameter ( enabled ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseEntityBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( EJB 3 SubsystemXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  )     {", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "case   MAX _ SIZE    :", "{", "FilePassivationStoreResourceDefinition . MAX _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   IDLE _ TIMEOUT    :", "{", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   IDLE _ TIMEOUT _ UNIT    :", "{", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT _ UNIT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   EJB 3 SubsystemModel . RELATIVE _ TO    :", "{", "FilePassivationStoreResourceDefinition . RELATIVE _ TO . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   GROUPS _ PATH    :", "{", "FilePassivationStoreResourceDefinition . GROUPS _ PATH . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SESSIONS _ PATH    :", "{", "FilePassivationStoreResourceDefinition . SESSIONS _ PATH . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SUBDIRECTORY _ COUNT    :", "{", "FilePassivationStoreResourceDefinition . SUBDIRECTORY _ COUNT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "requireNoContent ( reader )  ;", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( EJB 3 SubsystemXMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "operation . get ( OP _ ADDR )  . set (  . SUBSYSTEM _ PATH . append ( EJB 3 SubsystemModel . FILE _ PASSIVATION _ STORE ,    name )  . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseFilePassivationStore"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    Util . createAddOperation ( EJB 3 Subsystem 1  2 Parser . SUBSYSTEM _ PATH . append ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . IIOP )  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < EJB 3 SubsystemXMLAttribute >    required    =    EnumSet . of ( EJB 3 SubsystemXMLAttribute . ENABLE _ BY _ DEFAULT ,    EJB 3 SubsystemXMLAttribute . USE _ QUALIFIED _ NAME )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   EJB 3 SubsystemXMLAttribute   attribute    =    EJB 3 SubsystemXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   ENABLE _ BY _ DEFAULT    :", "EJB 3 IIOPResourceDefinition . ENABLE _ BY _ DEFAULT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   USE _ QUALIFIED _ NAME    :", "EJB 3 IIOPResourceDefinition . USE _ QUALIFIED _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseIIOP"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . PASS _ BY _ VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PASS _ BY _ VALUE    :", "RootResourceDefinition . PASS _ BY _ VALUE . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . PASS _ BY _ VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseInVMRemoteInterfaceInvocation"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   BEAN _ INSTANCE _ POOL _ REF    :", "{", "final   String   poolName    =    readStringAttributeElement ( reader ,    XMLAttribute . POOL _ NAME . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ MDB _ INSTANCE _ POOL . parseAndSetParameter ( poolName ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "case   RESOURCE _ ADAPTER _ REF    :", "{", "final   String   resourceAdapterName    =    readStringAttributeElement ( reader ,    XMLAttribute . RESOURCE _ ADAPTER _ NAME . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ RESOURCE _ ADAPTER _ NAME . parseAndSetParameter ( resourceAdapterName ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseMDB"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . FILE _ PASSIVATION _ STORE    :", "{", "this . parseFilePassivationStore ( reader ,    operations )  ;", "break ;", "}", "case   Model . CLUSTER _ PASSIVATION _ STORE    :", "{", "this . parseClusterPassivationStore ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parsePassivationStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   BEAN _ INSTANCE _ POOLS    :", "{", "this . parseBeanInstancePools ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parsePools"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "ModelNode   operation    =    Util . createAddOperation (  . SUBSYSTEM _ PATH . append ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . REMOTE )  )  ;", "final   EnumSet < EJB 3 SubsystemXMLAttribute >    required    =    EnumSet . of ( EJB 3 SubsystemXMLAttribute . CONNECTOR _ REF ,    EJB 3 SubsystemXMLAttribute . THREAD _ POOL _ NAME )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   EJB 3 SubsystemXMLAttribute   attribute    =    EJB 3 SubsystemXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   CONNECTOR _ REF    :", "EJB 3 RemoteResourceDefinition . CONNECTOR _ REF . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   THREAD _ POOL _ NAME    :", "EJB 3 RemoteResourceDefinition . THREAD _ POOL _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "operation . get ( EJB 3 SubsystemModel . EXECUTE _ IN _ WORKER )  . set ( new   ModelNode ( false )  )  ;", "requireNoContent ( reader )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseRemote"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   STATELESS    :", "{", "this . parseStatelessBean ( reader ,    operations ,    ejb 3 SubsystemAddOperation )  ;", "break ;", "}", "case   STATEFUL    :", "{", "this . parseStatefulBean ( reader ,    operations ,    ejb 3 SubsystemAddOperation )  ;", "break ;", "}", "case   SINGLETON    :", "{", "this . parseSingletonBean ( reader ,    operations ,    ejb 3 SubsystemAddOperation )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseSessionBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . DEFAULT _ ACCESS _ TIMEOUT )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   DEFAULT _ ACCESS _ TIMEOUT    :", "RootResourceDefinition . DEFAULT _ SINGLETON _ BEAN _ ACCESS _ TIMEOUT . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . DEFAULT _ ACCESS _ TIMEOUT )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseSingletonBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . DEFAULT _ ACCESS _ TIMEOUT ,    XMLAttribute . CACHE _ REF )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   DEFAULT _ ACCESS _ TIMEOUT    :", "{", "RootResourceDefinition . DEFAULT _ STATEFUL _ BEAN _ ACCESS _ TIMEOUT . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "case   CACHE _ REF    :", "{", "RootResourceDefinition . DEFAULT _ SFSB _ CACHE . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "case   CLUSTERED _ CACHE _ REF    :", "{", "RootResourceDefinition . DEFAULT _ CLUSTERED _ SFSB _ CACHE . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "missingRequiredAttributes . remove ( attribute )  ;", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseStatefulBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   BEAN _ INSTANCE _ POOL _ REF    :", "{", "final   String   poolName    =    readStringAttributeElement ( reader ,    XMLAttribute . POOL _ NAME . getLocalName (  )  )  ;", "RootResourceDefinition . DEFAULT _ SLSB _ INSTANCE _ POOL . parseAndSetParameter ( poolName ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseStatelessBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   poolName    =    null ;", "final   ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "poolName    =    value ;", "break ;", "case   MAX _ POOL _ SIZE    :", "StrictMaxPoolResourceDefinition . MAX _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   INSTANCE _ ACQUISITION _ TIMEOUT    :", "StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT    :", "StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    ( poolName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "final   PathAddress   address    =    this . getAddress (  )  . append ( Model . STRICT _ MAX _ BEAN _ INSTANCE _ POOL ,    poolName )  ;", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseStrictMaxPool"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "final   ModelNode   parentAddress    =     . SUBSYSTEM _ PATH . toModelNode (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "EJB 3 SubsystemNamespace   readerNS    =    EJB 3 SubsystemNamespace . forUri ( reader . getNamespaceURI (  )  )  ;", "switch    ( EJB 3 SubsystemXMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   EJB 3 SubsystemModel . THREAD _ POOL    :", "{", "ThreadsParser . getInstance (  )  . parseUnboundedQueueThreadPool ( reader ,    readerNS . getUriString (  )  ,    THREADS _  1  _  1  ,    parentAddress ,    operations ,    EJB 3 SubsystemModel . THREAD _ POOL ,    null )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseThreadPools"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   fileDataStoreAdd    =    null ;", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "final   ModelNode   timerServiceAdd    =    new   ModelNode (  )  ;", "timerServiceAdd . get ( OP )  . set ( ADD )  ;", "timerServiceAdd . get ( OP _ ADDR )  . set ( address )  ;", "ModelNode   dataStorePath    =    null ;", "ModelNode   dataStorePathRelativeTo    =    null ;", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . THREAD _ POOL _ NAME )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   THREAD _ POOL _ NAME    :", "TimerServiceResourceDefinition . THREAD _ POOL _ NAME . parseAndSetParameter ( value ,    timerServiceAdd ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   DATA _ STORE    :", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PATH    :", "if    ( dataStorePath    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePath    =    FileDataStoreResourceDefinition . PATH . parse ( value ,    reader )  ;", "break ;", "case   RELATIVE _ TO    :", "if    ( dataStorePathRelativeTo    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePathRelativeTo    =    FileDataStoreResourceDefinition . RELATIVE _ TO . parse ( value ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( dataStorePath    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . PATH )  )  ;", "}", "timerServiceAdd . get ( Model . DEFAULT _ DATA _ STORE )  . set (  \" default - file - store \"  )  ;", "fileDataStoreAdd    =    new   ModelNode (  )  ;", "final   ModelNode   fileDataAddress    =    address . clone (  )  ;", "fileDataAddress . add ( Model . FILE _ DATA _ STORE ,     \" default - file - store \"  )  ;", "fileDataStoreAdd . get ( OP )  . set ( ADD )  ;", "fileDataStoreAdd . get ( OP _ ADDR )  . set ( fileDataAddress )  ;", "fileDataStoreAdd . get ( Model . PATH )  . set ( dataStorePath )  ;", "if    ( dataStorePathRelativeTo    !  =    null )     {", "fileDataStoreAdd . get ( Model . RELATIVE _ TO )  . set ( dataStorePathRelativeTo )  ;", "}", "requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "operations . add ( timerServiceAdd )  ;", "if    ( fileDataStoreAdd    !  =    null )     {", "operations . add ( fileDataStoreAdd )  ;", "}", "}", "METHOD_END"], "methodName": ["parseTimerService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "Utils . requireNoNamespaceAttribute ( reader ,    i )  ;", "throw   Utils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "METHOD_END"], "methodName": ["readAttributes"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "switch    ( element )     {", "case   CACHES    :", "{", "this . parseCaches ( reader ,    operations )  ;", "break ;", "}", "case   PASSIVATION _ STORES    :", "{", "this . parsePassivationStores ( reader ,    operations )  ;", "break ;", "}", "case   MDB    :", "{", "this . parseMDB ( reader ,    operations ,    ejbAddOperation )  ;", "break ;", "}", "case   ENTITY _ BEAN    :", "{", "this . parseEntityBean ( reader ,    operations ,    ejbAddOperation )  ;", "break ;", "}", "case   POOLS    :", "{", "this . parsePools ( reader ,    operations )  ;", "break ;", "}", "case   REMOTE    :", "{", "parseRemote ( reader ,    operations )  ;", "break ;", "}", "case   ASYNC    :", "{", "parseAsync ( reader ,    operations )  ;", "break ;", "}", "case   SESSION _ BEAN    :", "{", "this . parseSessionBean ( reader ,    operations ,    ejbAddOperation )  ;", "break ;", "}", "case   TIMER _ SERVICE    :", "{", "parseTimerService ( reader ,    operations )  ;", "break ;", "}", "case   THREAD _ POOLS    :", "{", "parseThreadPools ( reader ,    operations )  ;", "break ;", "}", "case   IIOP    :", "{", "parseIIOP ( reader ,    operations )  ;", "break ;", "}", "case   IN _ VM _ REMOTE _ INTERFACE _ INVOCATION    :", "parseInVMRemoteInterfaceInvocation ( reader ,    ejbAddOperation )  ;", "break ;", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem12Parser"}, {"methodBody": ["METHOD_START", "{", "final   EnumSet < EJB 3 SubsystemXMLAttribute >    required    =    EnumSet . of ( EJB 3 SubsystemXMLAttribute . NAME ,    EJB 3 SubsystemXMLAttribute . TYPE )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   optionName    =    null ;", "ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   attributeValue    =    reader . getAttributeValue ( i )  ;", "final   EJB 3 SubsystemXMLAttribute   attribute    =    EJB 3 SubsystemXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "optionName    =    attributeValue ;", "break ;", "case   TYPE    :", "RemoteConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ TYPE . parseAndSetParameter ( attributeValue ,    operation ,    reader )  ;", "break ;", "case   VALUE    :", "RemoteConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ VALUE . parseAndSetParameter ( attributeValue ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "operation . get ( ADDRESS )  . set ( address . append ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS ,    optionName )  . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseChannelCreationOption"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   OPTION    :", "{", "this . parseChannelCreationOption ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseChannelCreationOptions"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   VALUE    :", "RootResourceDefinition . DEFAULT _ DISTINCT _ NAME . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDefaultDistinctName"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . ENABLED )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   ENABLED    :", "RootResourceDefinition . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . ENABLED )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseStatistics"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem13Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   VALUE    :", "RootResourceDefinition . DEFAULT _ MISSING _ METHOD _ PERMISSIONS _ DENY _ ACCESS . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDefaultMissingMethodPermissionsDenyAccess"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   VALUE    :", "RootResourceDefinition . DEFAULT _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDefaultSecurityDomain"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem14Parser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . FILE _ DATA _ STORE    :", "{", "parseFileDataStore ( reader ,    operations )  ;", "break ;", "}", "case   Model . DATABASE _ DATA _ STORE    :", "{", "parseDatabaseDataStore ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseDataStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem15Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "final   ModelNode   databaseDataStore    =    new   ModelNode (  )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . DATASOURCE _ JNDI _ NAME )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "if    ( name    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "name    =    reader . getAttributeValue ( i )  ;", "break ;", "case   DATASOURCE _ JNDI _ NAME    :", "DatabaseDataStoreResourceDefinition . DATASOURCE _ JNDI _ NAME . parseAndSetParameter ( value ,    databaseDataStore ,    reader )  ;", "break ;", "case   DATABASE    :", "DatabaseDataStoreResourceDefinition . DATABASE . parseAndSetParameter ( value ,    databaseDataStore ,    reader )  ;", "break ;", "case   PARTITION    :", "DatabaseDataStoreResourceDefinition . PARTITION . parseAndSetParameter ( value ,    databaseDataStore ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "address . add ( Model . DATABASE _ DATA _ STORE ,    name )  ;", "databaseDataStore . get ( OP )  . set ( ADD )  ;", "databaseDataStore . get ( ADDRESS )  . set ( address )  ;", "operations . add ( databaseDataStore )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseDatabaseDataStore"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem15Parser"}, {"methodBody": ["METHOD_START", "{", "String   dataStorePath    =    null ;", "String   dataStorePathRelativeTo    =    null ;", "String   name    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . PATH )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "if    ( name    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "name    =    reader . getAttributeValue ( i )  ;", "break ;", "case   PATH    :", "if    ( dataStorePath    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePath    =    FileDataStoreResourceDefinition . PATH . parse ( value ,    reader )  . asString (  )  ;", "break ;", "case   RELATIVE _ TO    :", "if    ( dataStorePathRelativeTo    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePathRelativeTo    =    FileDataStoreResourceDefinition . RELATIVE _ TO . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "address . add ( Model . FILE _ DATA _ STORE ,    name )  ;", "final   ModelNode   fileDataStoreAdd    =    new   ModelNode (  )  ;", "fileDataStoreAdd . get ( OP )  . set ( ADD )  ;", "fileDataStoreAdd . get ( ADDRESS )  . set ( address )  ;", "fileDataStoreAdd . get ( Model . PATH )  . set ( dataStorePath )  ;", "if    ( dataStorePathRelativeTo    !  =    null )     {", "fileDataStoreAdd . get ( Model . RELATIVE _ TO )  . set ( dataStorePathRelativeTo )  ;", "}", "operations . add ( fileDataStoreAdd )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseFileDataStore"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem15Parser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "final   ModelNode   timerServiceAdd    =    new   ModelNode (  )  ;", "timerServiceAdd . get ( OP )  . set ( ADD )  ;", "timerServiceAdd . get ( OP _ ADDR )  . set ( address )  ;", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . THREAD _ POOL _ NAME ,    XMLAttribute . DEFAULT _ DATA _ STORE )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   THREAD _ POOL _ NAME    :", "{", "TimerServiceResourceDefinition . THREAD _ POOL _ NAME . parseAndSetParameter ( value ,    timerServiceAdd ,    reader )  ;", "break ;", "}", "case   DEFAULT _ DATA _ STORE    :", "{", "TimerServiceResourceDefinition . DEFAULT _ DATA _ STORE . parseAndSetParameter ( value ,    timerServiceAdd ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "operations . add ( timerServiceAdd )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   DATA _ STORES    :", "{", "parseDataStores ( reader ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTimerService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem15Parser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . FILE _ DATA _ STORE    :", "{", "parseFileDataStore ( reader ,    operations )  ;", "break ;", "}", "case   Model . DATABASE _ DATA _ STORE    :", "{", "parseDatabaseDataStore ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseDataStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem20Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "final   ModelNode   databaseDataStore    =    new   ModelNode (  )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . DATASOURCE _ JNDI _ NAME )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "if    ( name    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "name    =    reader . getAttributeValue ( i )  ;", "break ;", "case   DATASOURCE _ JNDI _ NAME    :", "DatabaseDataStoreResourceDefinition . DATASOURCE _ JNDI _ NAME . parseAndSetParameter ( value ,    databaseDataStore ,    reader )  ;", "break ;", "case   DATABASE    :", "DatabaseDataStoreResourceDefinition . DATABASE . parseAndSetParameter ( value ,    databaseDataStore ,    reader )  ;", "break ;", "case   PARTITION    :", "DatabaseDataStoreResourceDefinition . PARTITION . parseAndSetParameter ( value ,    databaseDataStore ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "address . add ( Model . DATABASE _ DATA _ STORE ,    name )  ;", "databaseDataStore . get ( OP )  . set ( ADD )  ;", "databaseDataStore . get ( ADDRESS )  . set ( address )  ;", "operations . add ( databaseDataStore )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseDatabaseDataStore"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem20Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   VALUE    :", "RootResourceDefinition . DISABLE _ DEFAULT _ EJB _ PERMISSIONS . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDisableDefaultEjbPermissions"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem20Parser"}, {"methodBody": ["METHOD_START", "{", "String   dataStorePath    =    null ;", "String   dataStorePathRelativeTo    =    null ;", "String   name    =    null ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . NAME ,    XMLAttribute . PATH )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "if    ( name    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "name    =    reader . getAttributeValue ( i )  ;", "break ;", "case   PATH    :", "if    ( dataStorePath    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePath    =    FileDataStoreResourceDefinition . PATH . parse ( value ,    reader )  . asString (  )  ;", "break ;", "case   RELATIVE _ TO    :", "if    ( dataStorePathRelativeTo    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "dataStorePathRelativeTo    =    FileDataStoreResourceDefinition . RELATIVE _ TO . parse ( value ,    reader )  . asString (  )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "address . add ( Model . FILE _ DATA _ STORE ,    name )  ;", "final   ModelNode   fileDataStoreAdd    =    new   ModelNode (  )  ;", "fileDataStoreAdd . get ( OP )  . set ( ADD )  ;", "fileDataStoreAdd . get ( ADDRESS )  . set ( address )  ;", "fileDataStoreAdd . get ( Model . PATH )  . set ( dataStorePath )  ;", "if    ( dataStorePathRelativeTo    !  =    null )     {", "fileDataStoreAdd . get ( Model . RELATIVE _ TO )  . set ( dataStorePathRelativeTo )  ;", "}", "operations . add ( fileDataStoreAdd )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseFileDataStore"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem20Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  )     {", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "case   Model . MAX _ SIZE    :", "{", "PassivationStoreResourceDefinition . MAX _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Model . CACHE _ CONTAINER    :", "{", "PassivationStoreResourceDefinition . CACHE _ CONTAINER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Model . BEAN _ CACHE    :", "{", "PassivationStoreResourceDefinition . BEAN _ CACHE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "requireNoContent ( reader )  ;", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "operation . get ( OP _ ADDR )  . set (  1  2 Parser . SUBSYSTEM _ PATH . append ( Model . PASSIVATION _ STORE ,    name )  . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parsePassivationStore"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem20Parser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "address . add ( Model . SERVICE ,    Model . TIMER _ SERVICE )  ;", "final   ModelNode   timerServiceAdd    =    new   ModelNode (  )  ;", "timerServiceAdd . get ( OP )  . set ( ADD )  ;", "timerServiceAdd . get ( OP _ ADDR )  . set ( address )  ;", "final   int   attCount    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . THREAD _ POOL _ NAME ,    XMLAttribute . DEFAULT _ DATA _ STORE )  ;", "for    ( int   i    =     0  ;    i    <    attCount ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   THREAD _ POOL _ NAME    :", "{", "TimerServiceResourceDefinition . THREAD _ POOL _ NAME . parseAndSetParameter ( value ,    timerServiceAdd ,    reader )  ;", "break ;", "}", "case   DEFAULT _ DATA _ STORE    :", "{", "TimerServiceResourceDefinition . DEFAULT _ DATA _ STORE . parseAndSetParameter ( value ,    timerServiceAdd ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "operations . add ( timerServiceAdd )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   DATA _ STORES    :", "{", "parseDataStores ( reader ,    operations )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTimerService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem20Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   VALUE    :", "RootResourceDefinition . LOG _ EJB _ EXCEPTIONS . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseLogEjbExceptions"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem30Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   profileName    =    null ;", "final   ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "profileName    =    value ;", "break ;", "case   EXCLUDE _ LOCAL _ RECEIVER    :", "RemotingProfileResourceDefinition . EXCLUDE _ LOCAL _ RECEIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   LOCAL _ RECEIVER _ PASS _ BY _ VALUE    :", "RemotingProfileResourceDefinition . LOCAL _ RECEIVER _ PASS _ BY _ VALUE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "final   PathAddress   address    =     1  2 Parser . SUBSYSTEM _ PATH . append ( Model . REMOTING _ PROFILE ,    profileName )  ;", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   REMOTING _ EJB _ RECEIVER    :", "{", "parseRemotingReceiver ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( profileName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseProfile"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem30Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   PROFILE    :", "{", "this . parseProfile ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseProfiles"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem30Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   PathAddress   ejb 3 RemoteServiceAddress    =     1  2 Parser . SUBSYSTEM _ PATH . append ( Model . SERVICE ,    Model . REMOTE )  ;", "ModelNode   operation    =    Util . createAddOperation ( ejb 3 RemoteServiceAddress )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . CONNECTOR _ REF ,    XMLAttribute . THREAD _ POOL _ NAME )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   CONNECTOR _ REF    :", "EJB 3 RemoteResourceDefinition . CONNECTOR _ REF . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   THREAD _ POOL _ NAME    :", "EJB 3 RemoteResourceDefinition . THREAD _ POOL _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "operation . get ( Model . EXECUTE _ IN _ WORKER )  . set ( new   ModelNode ( false )  )  ;", "operations . add ( operation )  ;", "final   Set < XMLElement >    parsedElements    =    new   HashSet < XMLElement >  (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CHANNEL _ CREATION _ OPTIONS    :", "{", "if    ( parsedElements . contains ( XMLElement . CHANNEL _ CREATION _ OPTIONS )  )     {", "throw   unexpectedElement ( reader )  ;", "}", "parsedElements . add ( XMLElement . CHANNEL _ CREATION _ OPTIONS )  ;", "this . parseChannelCreationOptions ( reader ,    ejb 3 RemoteServiceAddress ,    operations )  ;", "break ;", "}", "case   PROFILES    :", "{", "parseProfiles ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseRemote"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem30Parser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   operation    =    Util . createAddOperation (  )  ;", "String   name    =    null ;", "final   Set < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . OUTBOUND _ CONNECTION _ REF )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value ;", "break ;", "case   OUTBOUND _ CONNECTION _ REF    :", "RemotingEjbReceiverDefinition . OUTBOUND _ CONNECTION _ REF . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   CONNECT _ TIMEOUT    :", "RemotingEjbReceiverDefinition . CONNECT _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "final   PathAddress   receiverAddress    =    profileAddress . append ( Model . REMOTING _ EJB _ RECEIVER ,    name )  ;", "operation . get ( OP _ ADDR )  . set ( receiverAddress . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   CHANNEL _ CREATION _ OPTIONS    :", "parseChannelCreationOptions ( reader ,    receiverAddress ,    operations )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseRemotingReceiver"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem30Parser"}, {"methodBody": ["METHOD_START", "{", "return   EjbLogger . ROOT _ LOGGER . mutuallyExclusiveAttributes ( reader . getLocation (  )  ,    EJB 3 SubsystemModel . MAX _ POOL _ SIZE ,    EJB 3 SubsystemModel . DERIVE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["mutuallyExclusiveAttributes"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem40Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   DELIVERY _ GROUP    :", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   groupName    =    null ;", "final   ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "groupName    =    value ;", "break ;", "case   ACTIVE    :", "MdbDeliveryGroupResourceDefinition . ACTIVE . parseAndSetParameter ( reader . getAttributeValue ( i )  ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    ( groupName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "final   PathAddress   address    =     1  2 Parser . SUBSYSTEM _ PATH . append ( Model . MDB _ DELIVERY _ GROUP ,    groupName )  ;", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseDeliveryGroups"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem40Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   PathAddress   ejb 3 RemoteServiceAddress    =     1  2 Parser . SUBSYSTEM _ PATH . append ( Model . SERVICE ,    Model . REMOTE )  ;", "ModelNode   operation    =    Util . createAddOperation ( ejb 3 RemoteServiceAddress )  ;", "final   EnumSet < XMLAttribute >    required    =    EnumSet . of ( XMLAttribute . CONNECTOR _ REF ,    XMLAttribute . THREAD _ POOL _ NAME )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   CLIENT _ MAPPINGS _ CLUSTER _ NAME    :", "EJB 3 RemoteResourceDefinition . CLIENT _ MAPPINGS _ CLUSTER _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   CONNECTOR _ REF    :", "EJB 3 RemoteResourceDefinition . CONNECTOR _ REF . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   THREAD _ POOL _ NAME    :", "EJB 3 RemoteResourceDefinition . THREAD _ POOL _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   EXECUTE _ IN _ WORKER    :", "EJB 3 RemoteResourceDefinition . EXECUTE _ IN _ WORKER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "operations . add ( operation )  ;", "final   Set < XMLElement >    parsedElements    =    new   HashSet < XMLElement >  (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "XMLElement   element    =    XMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CHANNEL _ CREATION _ OPTIONS    :", "{", "if    ( parsedElements . contains ( XMLElement . CHANNEL _ CREATION _ OPTIONS )  )     {", "throw   unexpectedElement ( reader )  ;", "}", "parsedElements . add ( XMLElement . CHANNEL _ CREATION _ OPTIONS )  ;", "this . parseChannelCreationOptions ( reader ,    ejb 3 RemoteServiceAddress ,    operations )  ;", "break ;", "}", "case   PROFILES    :", "{", "parseProfiles ( reader ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseRemote"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem40Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   poolName    =    null ;", "final   ModelNode   operation    =    Util . createAddOperation (  )  ;", "boolean   sizeAttribute    =    false ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "poolName    =    value ;", "break ;", "case   MAX _ POOL _ SIZE    :", "if    ( sizeAttribute )     {", "throw   mutuallyExclusiveAttributes ( reader )  ;", "}", "sizeAttribute    =    true ;", "StrictMaxPoolResourceDefinition . MAX _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   DERIVE _ SIZE    :", "if    ( sizeAttribute )     {", "throw   mutuallyExclusiveAttributes ( reader )  ;", "}", "sizeAttribute    =    true ;", "StrictMaxPoolResourceDefinition . DERIVE _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   INSTANCE _ ACQUISITION _ TIMEOUT    :", "StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT    :", "StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    ( poolName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "final   PathAddress   address    =    this . getAddress (  )  . append ( Model . STRICT _ MAX _ BEAN _ INSTANCE _ POOL ,    poolName )  ;", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseStrictMaxPool"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem40Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   VALUE    :", "RootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAllowEjbNameRegex"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem50Parser"}, {"methodBody": ["METHOD_START", "{", "String   applicationSecurityDomain    =    null ;", "ModelNode   operation    =    Util . createAddOperation (  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   attributeValue    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "applicationSecurityDomain    =    attributeValue ;", "break ;", "case   SECURITY _ DOMAIN    :", "ApplicationSecurityDomainDefinition . SECURITY _ DOMAIN . parseAndSetParameter ( attributeValue ,    operation ,    reader )  ;", "break ;", "case   ENABLE _ JACC    :", "ApplicationSecurityDomainDefinition . ENABLE _ JACC . parseAndSetParameter ( attributeValue ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( applicationSecurityDomain    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "requireNoContent ( reader )  ;", "final   PathAddress   address    =    this . getAddress (  )  . append ( PathElement . pathElement ( Model . APPLICATION _ SECURITY _ DOMAIN ,    applicationSecurityDomain )  )  ;", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseApplicationSecurityDomain"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem50Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "boolean   applicationSecurityDomainFound    =    false ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   Model . APPLICATION _ SECURITY _ DOMAIN    :", "{", "parseApplicationSecurityDomain ( reader ,    operations )  ;", "applicationSecurityDomainFound    =    true ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "if    (  ! applicationSecurityDomainFound )     {", "throw   missingRequiredElement ( reader ,    Collections . singleton ( XMLElement . APPLICATION _ SECURITY _ DOMAIN . getLocalName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseApplicationSecurityDomains"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem50Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "final   EnumSet < XMLAttribute >    missingRequiredAttributes    =    EnumSet . of ( XMLAttribute . VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   VALUE    :", "RootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN . parseAndSetParameter ( value ,    ejb 3 SubsystemAddOperation ,    reader )  ;", "missingRequiredAttributes . remove ( XMLAttribute . VALUE )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "if    (  !  ( missingRequiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    missingRequiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEnableGracefulTxnShutdown"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem50Parser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    this . getEJB 3 SubsystemAddress (  )  . append ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . IDENTITY )  ;", "ModelNode   addIdentity    =    Util . createAddOperation ( address )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   EJB 3 SubsystemXMLAttribute   attribute    =    EJB 3 SubsystemXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   OUTFLOW _ SECURITY _ DOMAINS    :", "{", "for    ( String   outflowDomain    :    reader . getListAttributeValue ( i )  )     {", "IdentityResourceDefinition . OUTFLOW _ SECURITY _ DOMAINS . parseAndAddParameterElement ( outflowDomain ,    addIdentity ,    reader )  ;", "}", "break ;", "}", "default    :", "{", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "requireNoContent ( reader )  ;", "operations . add ( addIdentity )  ;", "}", "METHOD_END"], "methodName": ["parseIdentity"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem50Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   profileName    =    null ;", "final   EJBClientContext . Builder   builder    =    new   EJBClientContext . Builder (  )  ;", "final   ModelNode   operation    =    Util . createAddOperation (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "profileName    =    value ;", "break ;", "case   EXCLUDE _ LOCAL _ RECEIVER    :", "RemotingProfileResourceDefinition . EXCLUDE _ LOCAL _ RECEIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   LOCAL _ RECEIVER _ PASS _ BY _ VALUE    :", "RemotingProfileResourceDefinition . LOCAL _ RECEIVER _ PASS _ BY _ VALUE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( profileName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . NAME . getLocalName (  )  )  )  ;", "}", "final   PathAddress   address    =     1  2 Parser . SUBSYSTEM _ PATH . append ( Model . REMOTING _ PROFILE ,    profileName )  ;", "operation . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "operations . add ( operation )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   STATIC _ EJB _ DISCOVERY    :", "final   ModelNode   staticEjb    =    parseStaticEjbDiscoveryType ( reader )  ;", "operation . get ( StaticEJBDiscoveryDefinition . STATIC _ EJB _ DISCOVERY )  . set ( staticEjb )  ;", "break ;", "case   REMOTING _ EJB _ RECEIVER    :", "{", "parseRemotingReceiver ( reader ,    address ,    operations )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseProfile"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem50Parser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   staticDiscovery    =    new   ModelNode (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( XMLElement . forName ( reader . getLocalName (  )  )  )     {", "case   MODULE    :", "{", "final   ModelNode   ejb    =    new   ModelNode (  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   uri    =    null ;", "String   module    =    null ;", "String   app    =    null ;", "String   distinct    =    null ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   XMLAttribute   attribute    =    XMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   URI    :", "if    ( uri    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "uri    =    value ;", "StaticEJBDiscoveryDefinition . URI _ AD . parseAndSetParameter ( uri ,    ejb ,    reader )  ;", "break ;", "case   MODULE _ NAME    :", "if    ( module    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "module    =    value ;", "StaticEJBDiscoveryDefinition . MODULE _ AD . parseAndSetParameter ( module ,    ejb ,    reader )  ;", "break ;", "case   APP _ NAME    :", "if    ( app    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "app    =    value ;", "StaticEJBDiscoveryDefinition . APP _ AD . parseAndSetParameter ( app ,    ejb ,    reader )  ;", "break ;", "case   DISTINCT _ NAME    :", "if    ( distinct    !  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "distinct    =    value ;", "StaticEJBDiscoveryDefinition . DISTINCT _ AD . parseAndSetParameter ( distinct ,    ejb ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( module    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( XMLAttribute . MODULE _ NAME . getLocalName (  )  )  )  ;", "}", "if    ( uri    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( URI )  )  ;", "}", "staticDiscovery . add ( ejb )  ;", "requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "return   staticDiscovery ;", "}", "METHOD_END"], "methodName": ["parseStaticEjbDiscoveryType"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3Subsystem50Parser"}, {"methodBody": ["METHOD_START", "{", "ServiceTarget   target    =    context . getServiceTarget (  )  ;", "if    ( appclient )     {", "return ;", "}", "if    ( context . hasOptionalCapability ( SINGLETON _ POLICY . getName (  )  ,    RootResourceDefinition . CLUSTERED _ SINGLETON _ CAPABILITY . getName (  )  ,    null )  )     {", "final   ClusteredSingletonServiceCreator   singletonBarrierCreator    =    new   ClusteredSingletonServiceCreator (  )  ;", "target . addService ( RootResourceDefinition . CLUSTERED _ SINGLETON _ CAPABILITY . getCapabilityServiceName (  )  . append (  \" creator \"  )  ,    singletonBarrierCreator )  . addDependency ( context . getCapabilityServiceName ( SINGLETON _ POLICY . getName (  )  ,    SINGLETON _ POLICY . getType (  )  )  ,    SingletonPolicy . class ,    singletonBarrierCreator . getSingletonPolicy (  )  )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addClusteringServices"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   EJBClientConfiguratorService   clientConfiguratorService    =    new   EJBClientConfiguratorService (  )  ;", "final   ServiceBuilder < EJBClientConfiguratorService >    configuratorBuilder    =    serviceTarget . addService ( EJBClientConfiguratorService . SERVICE _ NAME ,    clientConfiguratorService )  ;", "if    ( context . hasOptionalCapability (  . REMOTING _ ENDPOINT _ CAPABILITY ,    EJB 3 SubsystemRootResourceDefinition . EJB _ CLIENT _ CONFIGURATOR . getName (  )  ,    null )  )     {", "ServiceName   serviceName    =    context . getCapabilityServiceName (  . REMOTING _ ENDPOINT _ CAPABILITY ,    Endpoint . class )  ;", "configuratorBuilder . addDependency ( serviceName ,    Endpoint . class ,    clientConfiguratorService . getEndpointInjector (  )  )  ;", "}", "configuratorBuilder . setInitialMode ( ACTIVE )  . install (  )  ;", "final   EJBClientContextService   clientContextService    =    new   EJBClientContextService ( true )  ;", "final   ServiceBuilder < EJBClientContextService >    clientContextServiceBuilder    =    context . getServiceTarget (  )  . addService ( EJBClientContextService . DEFAULT _ SERVICE _ NAME ,    clientContextService )  ;", "clientContextServiceBuilder . addDependency ( EJBClientConfiguratorService . SERVICE _ NAME ,    EJBClientConfiguratorService . class ,    clientContextService . getConfiguratorServiceInjector (  )  )  ;", "if    ( appclient )     {", "clientContextServiceBuilder . addDependency ( EJBClientContextService . APP _ CLIENT _ URI _ SERVICE _ NAME ,    URI . class ,    clientContextService . getAppClientUri (  )  )  ;", "clientContextServiceBuilder . addDependency ( EJBClientContextService . APP _ CLIENT _ EJB _ PROPERTIES _ SERVICE _ NAME ,    String . class ,    clientContextService . getAppClientEjbProperties (  )  )  ;", "}", "if    (  ! appclient )     {", "final   LocalTransportProvider   byValueLocalEjbReceiver    =    new   LocalTransportProvider ( false )  ;", "ServiceBuilder < LocalTransportProvider >    byValueServiceBuilder    =    serviceTarget . addService ( LocalTransportProvider . BY _ VALUE _ SERVICE _ NAME ,    byValueLocalEjbReceiver )  . addDependency ( DeploymentRepository . SERVICE _ NAME ,    DeploymentRepository . class ,    byValueLocalEjbReceiver . getDeploymentRepository (  )  )  . setInitialMode ( ON _ DEMAND )  ;", "byValueServiceBuilder . install (  )  ;", "final   LocalTransportProvider   byReferenceLocalEjbReceiver    =    new   LocalTransportProvider ( true )  ;", "ServiceBuilder < LocalTransportProvider >    byReferenceServiceBuilder    =    serviceTarget . addService ( LocalTransportProvider . BY _ REFERENCE _ SERVICE _ NAME ,    byReferenceLocalEjbReceiver )  . addDependency ( DeploymentRepository . SERVICE _ NAME ,    DeploymentRepository . class ,    byReferenceLocalEjbReceiver . getDeploymentRepository (  )  )  . setInitialMode ( ON _ DEMAND )  ;", "byReferenceServiceBuilder . install (  )  ;", "EJBRemoteInvocationPassByValueWriteHandler . INSTANCE . updateDefaultLocalEJBReceiverService ( context ,    ejbSubsystemModel )  ;", "clientContextServiceBuilder . addDependency ( LocalTransportProvider . DEFAULT _ LOCAL _ TRANSPORT _ PROVIDER _ SERVICE _ NAME ,    EJBTransportProvider . class ,    clientContextService . getLocalProviderInjector (  )  )  ;", "}", "clientContextServiceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["addRemoteInvocationServices"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "final   InjectedValue < T >    value    =    new   InjectedValue (  )  ;", "return   context . getServiceTarget (  )  . addService ( serviceName ,    new   msc . service . ValueService ( value )  )  . addDependency ( dependencyServiceName ,    targetClass ,    value )  . setInitialMode ( ON _ DEMAND )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installValueService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemDefaultCacheWriteHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   cacheName    =    this . attribute . resolveModelAttribute ( context ,    model )  ;", "ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "if    (  ( registry . getService ( this . serviceName )  )     !  =    null )     {", "context . removeService ( this . serviceName )  ;", "}", "if    ( cacheName . isDefined (  )  )     {", "this . installValueService ( context ,    this . serviceName ,    FactoryBuilder . class ,    FactoryBuilderService . getServiceName ( cacheName . asString (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateCacheService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemDefaultCacheWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   enabled    =    EJB 3 SubsystemRootResourceDefinition . DEFAULT _ ENTITY _ BEAN _ OPTIMISTIC _ LOCKING . resolveModelAttribute ( context ,    model )  ;", "final   ServiceRegistry   serviceRegistry    =    context . getServiceRegistry ( true )  ;", "ServiceController <  ?  >    existingService    =    serviceRegistry . getService (  . SERVICE _ NAME )  ;", "if    ( existingService    !  =    null )     {", "context . removeService ( existingService )  ;", "}", "if    ( enabled . isDefined (  )  )     {", "final   Service < Boolean >    newDefaultPoolConfigService    =    new   ValueService < Boolean >  ( new   ImmediateValue < Boolean >  ( enabled . asBoolean (  )  )  )  ;", "ServiceController <  ?  >    newController    =    context . getServiceTarget (  )  . addService (  . SERVICE _ NAME ,    newDefaultPoolConfigService )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateOptimisticLocking"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemDefaultEntityBeanOptimisticLockingWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   poolName    =    poolAttribute . resolveModelAttribute ( context ,    model )  ;", "final   ServiceRegistry   serviceRegistry    =    context . getServiceRegistry ( true )  ;", "ServiceController <  ?  >    existingConfigService    =    serviceRegistry . getService ( poolConfigServiceName )  ;", "if    ( existingConfigService    !  =    null )     {", "context . removeService ( existingConfigService )  ;", "}", "if    ( poolName . isDefined (  )  )     {", "final   ValueInjectionService < PoolConfig >    newConfigService    =    new   ValueInjectionService < PoolConfig >  (  )  ;", "ServiceController <  ?  >    newController    =    context . getServiceTarget (  )  . addService ( poolConfigServiceName ,    newConfigService )  . addDependency ( StrictMaxPoolConfigService . EJB _ POOL _ CONFIG _ BASE _ SERVICE _ NAME . append ( poolName . asString (  )  )  ,    PoolConfig . class ,    newConfigService . getInjector (  )  )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updatePoolService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemDefaultPoolWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   EJB 3 SubsystemNamespace   element    =    EJB 3 SubsystemNamespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    EJB 3 SubsystemNamespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemNamespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemNamespace"}, {"methodBody": ["METHOD_START", "{", "final   EJB 3 SubsystemXMLAttribute   element    =    EJB 3 SubsystemXMLAttribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    EJB 3 SubsystemXMLAttribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLAttribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLAttribute"}, {"methodBody": ["METHOD_START", "{", "final   EJB 3 SubsystemXMLElement   element    =    EJB 3 SubsystemXMLElement . MAP . get ( localName )  ;", "return   element    =  =    null    ?    EJB 3 SubsystemXMLElement . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLElement"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLElement"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( EJB 3 SubsystemModel . APPLICATION _ SECURITY _ DOMAIN )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "ApplicationSecurityDomainDefinition . SECURITY _ DOMAIN . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", "ApplicationSecurityDomainDefinition . ENABLE _ JACC . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeApplicationSecurityDomain"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "List < Property >    applicationSecurityDomains    =    model . get ( EJB 3 SubsystemModel . APPLICATION _ SECURITY _ DOMAIN )  . asPropertyList (  )  ;", "for    ( Property   property    :    applicationSecurityDomains )     {", "writeApplicationSecurityDomain ( writer ,    property )  ;", "}", "}", "METHOD_END"], "methodName": ["writeApplicationSecurityDomains"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeAttribute ( EJB 3 SubsystemXMLAttribute . THREAD _ POOL _ NAME . getLocalName (  )  ,    model . require ( EJB 3 SubsystemModel . THREAD _ POOL _ NAME )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeAsync"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "attribute . getAttributeMarshaller (  )  . marshallAsAttribute ( attribute ,    model ,    true ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeAttribute"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( beanInstancePoolModelNode . hasDefined ( EJB 3 SubsystemModel . STRICT _ MAX _ BEAN _ INSTANCE _ POOL )  )     {", "final   List < Property >    strictMaxPools    =    beanInstancePoolModelNode . get ( EJB 3 SubsystemModel . STRICT _ MAX _ BEAN _ INSTANCE _ POOL )  . asPropertyList (  )  ;", "for    ( Property   property    :    strictMaxPools )     {", "writer . writeStartElement ( Element . STRICT _ MAX _ POOL . getLocalName (  )  )  ;", "this . writeStrictMaxPoolConfig ( writer ,    property )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeBeanInstancePools"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "List < Property >    caches    =    model . get ( EJB 3 SubsystemModel . CACHE )  . asPropertyList (  )  ;", "for    ( Property   property    :    caches )     {", "writer . writeStartElement ( EJB 3 SubsystemXMLElement . CACHE . getLocalName (  )  )  ;", "ModelNode   cache    =    property . getValue (  )  ;", "writer . writeAttribute ( EJB 3 SubsystemXMLAttribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "CacheFactoryResourceDefinition . PASSIVATION _ STORE . marshallAsAttribute ( cache ,    writer )  ;", ". writeAttribute ( writer ,    cache ,    CacheFactoryResourceDefinition . ALIASES )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeCaches"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( EJB 3 SubsystemXMLElement . CHANNEL _ CREATION _ OPTIONS . getLocalName (  )  )  ;", "for    ( final   Property   optionPropertyModelNode    :    node . asPropertyList (  )  )     {", "writer . writeStartElement ( EJB 3 SubsystemXMLElement . OPTION . getLocalName (  )  )  ;", "writer . writeAttribute ( NAME . getLocalName (  )  ,    optionPropertyModelNode . getName (  )  )  ;", "final   ModelNode   propertyValueModelNode    =    optionPropertyModelNode . getValue (  )  ;", "RemoteConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ VALUE . marshallAsAttribute ( propertyValueModelNode ,    writer )  ;", "RemoteConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ TYPE . marshallAsAttribute ( propertyValueModelNode ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeChannelCreationOptions"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( EJB 3 SubsystemModel . CLUSTER _ PASSIVATION _ STORE )  )     {", "List < Property >    caches    =    model . get ( EJB 3 SubsystemModel . CLUSTER _ PASSIVATION _ STORE )  . asPropertyList (  )  ;", "for    ( Property   property    :    caches )     {", "writer . writeStartElement ( Element . CLUSTER _ PASSIVATION _ STORE . getLocalName (  )  )  ;", "ModelNode   store    =    property . getValue (  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT . marshallAsAttribute ( store ,    writer )  ;", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT _ UNIT . marshallAsAttribute ( store ,    writer )  ;", "ClusterPassivationStoreResourceDefinition . MAX _ SIZE . marshallAsAttribute ( store ,    writer )  ;", "ClusterPassivationStoreResourceDefinition . CACHE _ CONTAINER . marshallAsAttribute ( store ,    writer )  ;", "ClusterPassivationStoreResourceDefinition . BEAN _ CACHE . marshallAsAttribute ( store ,    writer )  ;", "ClusterPassivationStoreResourceDefinition . CLIENT _ MAPPINGS _ CACHE . marshallAsAttribute ( store ,    writer )  ;", "ClusterPassivationStoreResourceDefinition . PASSIVATE _ EVENTS _ ON _ REPLICATE . marshallAsAttribute ( store ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeClusterPassivationStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( timerServiceModel . hasDefined ( EJB 3 SubsystemModel . DATABASE _ DATA _ STORE )  )     {", "List < Property >    stores    =    timerServiceModel . get ( EJB 3 SubsystemModel . DATABASE _ DATA _ STORE )  . asPropertyList (  )  ;", "for    ( Property   property    :    stores )     {", "writer . writeStartElement ( Element . DATABASE _ DATA _ STORE . getLocalName (  )  )  ;", "ModelNode   store    =    property . getValue (  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "DatabaseDataStoreResourceDefinition . DATASOURCE _ JNDI _ NAME . marshallAsAttribute ( store ,    writer )  ;", "DatabaseDataStoreResourceDefinition . DATABASE . marshallAsAttribute ( store ,    writer )  ;", "DatabaseDataStoreResourceDefinition . PARTITION . marshallAsAttribute ( store ,    writer )  ;", "DatabaseDataStoreResourceDefinition . REFRESH _ INTERVAL . marshallAsAttribute ( store ,    writer )  ;", "DatabaseDataStoreResourceDefinition . ALLOW _ EXECUTION . marshallAsAttribute ( store ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeDatabaseDataStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SLSB _ INSTANCE _ POOL )  )     {", "writer . writeStartElement ( Element . BEAN _ INSTANCE _ POOL _ REF . getLocalName (  )  )  ;", "final   String   poolRefName    =    model . get ( EJB 3 SubsystemModel . DEFAULT _ SLSB _ INSTANCE _ POOL )  . asString (  )  ;", "writer . writeAttribute ( Attribute . POOL _ NAME . getLocalName (  )  ,    poolRefName )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDefaultSLSBPool"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    context . getModelNode (  )  ;", "if    (  (  ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SLSB _ INSTANCE _ POOL )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ STATEFUL _ BEAN _ ACCESS _ TIMEOUT )  )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SINGLETON _ BEAN _ ACCESS _ TIMEOUT )  )  )     {", "writer . writeStartElement ( Element . SESSION _ BEAN . getLocalName (  )  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SLSB _ INSTANCE _ POOL )  )     {", "writer . writeStartElement ( Element . STATELESS . getLocalName (  )  )  ;", "this . writeDefaultSLSBPool ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  (  ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ STATEFUL _ BEAN _ ACCESS _ TIMEOUT )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SFSB _ CACHE )  )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SFSB _ PASSIVATION _ DISABLED _ CACHE )  )  )     {", "writer . writeStartElement ( Element . STATEFUL . getLocalName (  )  )  ;", "this . writeStatefulBean ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SINGLETON _ BEAN _ ACCESS _ TIMEOUT )  )     {", "writer . writeStartElement ( Element . SINGLETON . getLocalName (  )  )  ;", "this . writeSingletonBean ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  (  ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SLSB _ INSTANCE _ POOL )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ STATEFUL _ BEAN _ ACCESS _ TIMEOUT )  )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SINGLETON _ BEAN _ ACCESS _ TIMEOUT )  )  )     {", "writer . writeEndElement (  )  ;", "}", "if    (  (  ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ MDB _ INSTANCE _ POOL )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ RESOURCE _ ADAPTER _ NAME )  )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . MDB _ DELIVERY _ GROUP )  )  )     {", "writer . writeStartElement ( Element . MDB . getLocalName (  )  )  ;", "this . writeMDB ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ ENTITY _ BEAN _ INSTANCE _ POOL )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ ENTITY _ BEAN _ OPTIMISTIC _ LOCKING )  )  )     {", "writer . writeStartElement ( Element . ENTITY _ BEAN . getLocalName (  )  )  ;", "this . writeEntityBean ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . STRICT _ MAX _ BEAN _ INSTANCE _ POOL )  )     {", "writer . writeStartElement ( Element . POOLS . getLocalName (  )  )  ;", "writer . writeStartElement ( Element . BEAN _ INSTANCE _ POOLS . getLocalName (  )  )  ;", "this . writeBeanInstancePools ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . CACHE )  )     {", "writer . writeStartElement ( Element . CACHES . getLocalName (  )  )  ;", "this . writeCaches ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  (  ( model . hasDefined ( EJB 3 SubsystemModel . PASSIVATION _ STORE )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . CLUSTER _ PASSIVATION _ STORE )  )  )     |  |     ( model . hasDefined ( EJB 3 SubsystemModel . FILE _ PASSIVATION _ STORE )  )  )     {", "writer . writeStartElement ( Element . PASSIVATION _ STORES . getLocalName (  )  )  ;", "this . writePassivationStores ( writer ,    model )  ;", "this . writeFilePassivationStores ( writer ,    model )  ;", "this . writeClusterPassivationStores ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  ( model . hasDefined ( EJB 3 SubsystemModel . SERVICE )  )     &  &     ( model . get ( EJB 3 SubsystemModel . SERVICE )  . hasDefined ( EJB 3 SubsystemModel . ASYNC )  )  )     {", "writer . writeStartElement ( Element . ASYNC . getLocalName (  )  )  ;", "writeAsync ( writer ,    model . get ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . ASYNC )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  ( model . hasDefined ( EJB 3 SubsystemModel . SERVICE )  )     &  &     ( model . get ( EJB 3 SubsystemModel . SERVICE )  . hasDefined ( EJB 3 SubsystemModel . TIMER _ SERVICE )  )  )     {", "writer . writeStartElement ( Element . TIMER _ SERVICE . getLocalName (  )  )  ;", "final   ModelNode   timerServiceModel    =    model . get ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . TIMER _ SERVICE )  ;", "this . writeTimerService ( writer ,    timerServiceModel )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  ( model . hasDefined ( EJB 3 SubsystemModel . SERVICE )  )     &  &     ( model . get ( EJB 3 SubsystemModel . SERVICE )  . hasDefined ( EJB 3 SubsystemModel . REMOTE )  )  )     {", "writer . writeStartElement ( Element . REMOTE . getLocalName (  )  )  ;", "writeRemote ( writer ,    model . get ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . REMOTE )  )  ;", "if    ( model . hasDefined ( EJB 3 SubsystemModel . REMOTING _ PROFILE )  )     {", "writer . writeStartElement ( Element . PROFILES . getLocalName (  )  )  ;", "writeProfiles ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . THREAD _ POOL )  )     {", "writer . writeStartElement ( Element . THREAD _ POOLS . getLocalName (  )  )  ;", "final   ModelNode   threadsModel    =    model . get ( EJB 3 SubsystemModel . THREAD _ POOL )  ;", "this . writeThreadPools ( writer ,    threadsModel )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  ( model . hasDefined ( EJB 3 SubsystemModel . SERVICE )  )     &  &     ( model . get ( EJB 3 SubsystemModel . SERVICE )  . hasDefined ( EJB 3 SubsystemModel . IIOP )  )  )     {", "writer . writeStartElement ( Element . IIOP . getLocalName (  )  )  ;", "writeIIOP ( writer ,    model . get ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . IIOP )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . IN _ VM _ REMOTE _ INTERFACE _ INVOCATION _ PASS _ BY _ VALUE )  )     {", "writer . writeStartElement ( Element . IN _ VM _ REMOTE _ INTERFACE _ INVOCATION . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . PASS _ BY _ VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . IN _ VM _ REMOTE _ INTERFACE _ INVOCATION _ PASS _ BY _ VALUE )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ DISTINCT _ NAME )  )     {", "writer . writeStartElement ( Element . DEFAULT _ DISTINCT _ NAME . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . DEFAULT _ DISTINCT _ NAME )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SECURITY _ DOMAIN )  )     {", "writer . writeStartElement ( Element . DEFAULT _ SECURITY _ DOMAIN . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . DEFAULT _ SECURITY _ DOMAIN )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . APPLICATION _ SECURITY _ DOMAIN )  )     {", "writer . writeStartElement ( Element . APPLICATION _ SECURITY _ DOMAINS . getLocalName (  )  )  ;", "writeApplicationSecurityDomains ( writer ,    model )  ;", "writer . writeEndElement (  )  ;", "}", "if    (  (  ( model . hasDefined ( EJB 3 SubsystemModel . SERVICE )  )     &  &     ( model . get ( EJB 3 SubsystemModel . SERVICE )  . hasDefined ( EJB 3 SubsystemModel . IDENTITY )  )  )     &  &     ( model . get ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . IDENTITY )  . hasDefined ( IdentityResourceDefinition . OUTFLOW _ SECURITY _ DOMAINS . getName (  )  )  )  )     {", "writer . writeStartElement ( Element . IDENTITY . getLocalName (  )  )  ;", "IdentityResourceDefinition . OUTFLOW _ SECURITY _ DOMAINS . getAttributeMarshaller (  )  . marshallAsAttribute ( IdentityResourceDefinition . OUTFLOW _ SECURITY _ DOMAINS ,    model . get ( EJB 3 SubsystemModel . SERVICE ,    EJB 3 SubsystemModel . IDENTITY )  ,    false ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ MISSING _ METHOD _ PERMISSIONS _ DENY _ ACCESS )  )     {", "writer . writeStartElement ( Element . DEFAULT _ MISSING _ METHOD _ PERMISSIONS _ DENY _ ACCESS . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . DEFAULT _ MISSING _ METHOD _ PERMISSIONS _ DENY _ ACCESS )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  )     {", "writer . writeStartElement ( Element . DISABLE _ DEFAULT _ EJB _ PERMISSIONS . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  )     {", "writer . writeStartElement ( Element . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . STATISTICS _ ENABLED )  )     {", "writer . writeStartElement ( Element . STATISTICS . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . ENABLED . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . STATISTICS _ ENABLED )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . LOG _ SYSTEM _ EXCEPTIONS )  )     {", "writer . writeStartElement ( Element . LOG _ SYSTEM _ EXCEPTIONS . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . LOG _ SYSTEM _ EXCEPTIONS )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( model . hasDefined ( EJB 3 SubsystemModel . ALLOW _ EJB _ NAME _ REGEX )  )     {", "writer . writeStartElement ( Element . ALLOW _ EJB _ NAME _ REGEX . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    model . get ( EJB 3 SubsystemModel . ALLOW _ EJB _ NAME _ REGEX )  . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeElements"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( entityModelNode . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ ENTITY _ BEAN _ INSTANCE _ POOL )  )     {", "writer . writeStartElement ( Element . BEAN _ INSTANCE _ POOL _ REF . getLocalName (  )  )  ;", "final   String   poolRefName    =    entityModelNode . get ( EJB 3 SubsystemModel . DEFAULT _ ENTITY _ BEAN _ INSTANCE _ POOL )  . asString (  )  ;", "writer . writeAttribute ( Attribute . POOL _ NAME . getLocalName (  )  ,    poolRefName )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( entityModelNode . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ ENTITY _ BEAN _ OPTIMISTIC _ LOCKING )  )     {", "writer . writeStartElement ( Element . OPTIMISTIC _ LOCKING . getLocalName (  )  )  ;", "final   Boolean   locking    =    entityModelNode . get ( EJB 3 SubsystemModel . DEFAULT _ ENTITY _ BEAN _ OPTIMISTIC _ LOCKING )  . asBoolean (  )  ;", "writer . writeAttribute ( Attribute . ENABLED . getLocalName (  )  ,    locking . toString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeEntityBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( timerServiceModel . hasDefined ( EJB 3 SubsystemModel . FILE _ DATA _ STORE )  )     {", "List < Property >    stores    =    timerServiceModel . get ( EJB 3 SubsystemModel . FILE _ DATA _ STORE )  . asPropertyList (  )  ;", "for    ( Property   property    :    stores )     {", "writer . writeStartElement ( Element . FILE _ DATA _ STORE . getLocalName (  )  )  ;", "ModelNode   store    =    property . getValue (  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "FileDataStoreResourceDefinition . PATH . marshallAsAttribute ( store ,    writer )  ;", "FileDataStoreResourceDefinition . RELATIVE _ TO . marshallAsAttribute ( store ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeFileDataStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( EJB 3 SubsystemModel . FILE _ PASSIVATION _ STORE )  )     {", "List < Property >    caches    =    model . get ( EJB 3 SubsystemModel . FILE _ PASSIVATION _ STORE )  . asPropertyList (  )  ;", "for    ( Property   property    :    caches )     {", "writer . writeStartElement ( Element . FILE _ PASSIVATION _ STORE . getLocalName (  )  )  ;", "ModelNode   store    =    property . getValue (  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT . marshallAsAttribute ( store ,    writer )  ;", "LegacyPassivationStoreResourceDefinition . IDLE _ TIMEOUT _ UNIT . marshallAsAttribute ( store ,    writer )  ;", "FilePassivationStoreResourceDefinition . MAX _ SIZE . marshallAsAttribute ( store ,    writer )  ;", "FilePassivationStoreResourceDefinition . RELATIVE _ TO . marshallAsAttribute ( store ,    writer )  ;", "FilePassivationStoreResourceDefinition . GROUPS _ PATH . marshallAsAttribute ( store ,    writer )  ;", "FilePassivationStoreResourceDefinition . SESSIONS _ PATH . marshallAsAttribute ( store ,    writer )  ;", "FilePassivationStoreResourceDefinition . SUBDIRECTORY _ COUNT . marshallAsAttribute ( store ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeFilePassivationStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "EJB 3 IIOPResourceDefinition . ENABLE _ BY _ DEFAULT . marshallAsAttribute ( model ,    writer )  ;", "EJB 3 IIOPResourceDefinition . USE _ QUALIFIED _ NAME . marshallAsAttribute ( model ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeIIOP"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( mdbModelNode . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ RESOURCE _ ADAPTER _ NAME )  )     {", "writer . writeStartElement ( Element . RESOURCE _ ADAPTER _ REF . getLocalName (  )  )  ;", "final   String   resourceAdapterName    =    mdbModelNode . get ( EJB 3 SubsystemModel . DEFAULT _ RESOURCE _ ADAPTER _ NAME )  . asString (  )  ;", "writer . writeAttribute ( Attribute . RESOURCE _ ADAPTER _ NAME . getLocalName (  )  ,    resourceAdapterName )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( mdbModelNode . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ MDB _ INSTANCE _ POOL )  )     {", "writer . writeStartElement ( Element . BEAN _ INSTANCE _ POOL _ REF . getLocalName (  )  )  ;", "final   String   poolRefName    =    mdbModelNode . get ( EJB 3 SubsystemModel . DEFAULT _ MDB _ INSTANCE _ POOL )  . asString (  )  ;", "writer . writeAttribute ( Attribute . POOL _ NAME . getLocalName (  )  ,    poolRefName )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( mdbModelNode . hasDefined ( EJB 3 SubsystemModel . MDB _ DELIVERY _ GROUP )  )     {", "writer . writeStartElement ( Element . DELIVERY _ GROUPS . getLocalName (  )  )  ;", "for    ( Property   property    :    mdbModelNode . get ( EJB 3 SubsystemModel . MDB _ DELIVERY _ GROUP )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . DELIVERY _ GROUP . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "MdbDeliveryGroupResourceDefinition . ACTIVE . marshallAsAttribute ( mdbModelNode . get ( EJB 3 SubsystemModel . MDB _ DELIVERY _ GROUP ,    property . getName (  )  )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeMDB"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( EJB 3 SubsystemModel . PASSIVATION _ STORE )  )     {", "List < Property >    caches    =    model . get ( EJB 3 SubsystemModel . PASSIVATION _ STORE )  . asPropertyList (  )  ;", "for    ( Property   property    :    caches )     {", "writer . writeStartElement ( Element . PASSIVATION _ STORE . getLocalName (  )  )  ;", "ModelNode   store    =    property . getValue (  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "PassivationStoreResourceDefinition . CACHE _ CONTAINER . marshallAsAttribute ( store ,    writer )  ;", "PassivationStoreResourceDefinition . BEAN _ CACHE . marshallAsAttribute ( store ,    writer )  ;", "PassivationStoreResourceDefinition . MAX _ SIZE . marshallAsAttribute ( store ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writePassivationStores"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "final   List < Property >    profiles    =    model . get ( EJB 3 SubsystemModel . REMOTING _ PROFILE )  . asPropertyList (  )  ;", "for    ( final   Property   property    :    profiles )     {", "writer . writeStartElement ( EJB 3 SubsystemModel . PROFILE )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "final   ModelNode   profileNode    =    property . getValue (  )  ;", "RemotingProfileResourceDefinition . EXCLUDE _ LOCAL _ RECEIVER . marshallAsAttribute ( profileNode ,    writer )  ;", "RemotingProfileResourceDefinition . LOCAL _ RECEIVER _ PASS _ BY _ VALUE . marshallAsAttribute ( profileNode ,    writer )  ;", "if    ( profileNode . hasDefined ( EJB 3 SubsystemModel . REMOTING _ EJB _ RECEIVER )  )     {", "writeRemotingEjbReceivers ( writer ,    profileNode )  ;", "}", "StaticEJBDiscoveryDefinition . INSTANCE . marshallAsElement ( profileNode ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeProfiles"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( EJB 3 SubsystemModel . CLIENT _ MAPPINGS _ CLUSTER _ NAME )  )     {", "writer . writeAttribute ( Attribute . CLIENT _ MAPPINGS _ CLUSTER _ NAME . getLocalName (  )  ,    model . require ( EJB 3 SubsystemModel . CLIENT _ MAPPINGS _ CLUSTER _ NAME )  . asString (  )  )  ;", "}", "writer . writeAttribute ( Attribute . CONNECTOR _ REF . getLocalName (  )  ,    model . require ( EJB 3 SubsystemModel . CONNECTOR _ REF )  . asString (  )  )  ;", "writer . writeAttribute ( Attribute . THREAD _ POOL _ NAME . getLocalName (  )  ,    model . require ( EJB 3 SubsystemModel . THREAD _ POOL _ NAME )  . asString (  )  )  ;", "EJB 3 RemoteResourceDefinition . EXECUTE _ IN _ WORKER . marshallAsAttribute ( model ,    writer )  ;", "if    ( model . hasDefined ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS )  )     {", "writeChannelCreationOptions ( writer ,    model . get ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeRemote"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "final   List < Property >    receivers    =    profileNode . get ( EJB 3 SubsystemModel . REMOTING _ EJB _ RECEIVER )  . asPropertyList (  )  ;", "for    ( final   Property   property    :    receivers )     {", "writer . writeStartElement ( EJB 3 SubsystemModel . REMOTING _ EJB _ RECEIVER )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "final   ModelNode   receiverNode    =    property . getValue (  )  ;", "RemotingEjbReceiverDefinition . OUTBOUND _ CONNECTION _ REF . marshallAsAttribute ( receiverNode ,    writer )  ;", "RemotingEjbReceiverDefinition . CONNECT _ TIMEOUT . marshallAsAttribute ( receiverNode ,    writer )  ;", "if    ( receiverNode . hasDefined ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS )  )     {", "writeChannelCreationOptions ( writer ,    receiverNode . get ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS )  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeRemotingEjbReceivers"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "final   String   defaultAccessTimeout    =    singletonBeanModel . get ( EJB 3 SubsystemModel . DEFAULT _ SINGLETON _ BEAN _ ACCESS _ TIMEOUT )  . asString (  )  ;", "writer . writeAttribute ( Attribute . DEFAULT _ ACCESS _ TIMEOUT . getLocalName (  )  ,    defaultAccessTimeout )  ;", "}", "METHOD_END"], "methodName": ["writeSingletonBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( statefulBeanModel . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ STATEFUL _ BEAN _ ACCESS _ TIMEOUT )  )     {", "String   defaultAccessTimeout    =    statefulBeanModel . get ( EJB 3 SubsystemModel . DEFAULT _ STATEFUL _ BEAN _ ACCESS _ TIMEOUT )  . asString (  )  ;", "writer . writeAttribute ( Attribute . DEFAULT _ ACCESS _ TIMEOUT . getLocalName (  )  ,    defaultAccessTimeout )  ;", "}", "if    ( statefulBeanModel . hasDefined ( EJB 3 SubsystemModel . DEFAULT _ SFSB _ CACHE )  )     {", "String   cache    =    statefulBeanModel . get ( EJB 3 SubsystemModel . DEFAULT _ SFSB _ CACHE )  . asString (  )  ;", "writer . writeAttribute ( Attribute . CACHE _ REF . getLocalName (  )  ,    cache )  ;", "}", "EJB 3 SubsystemRootResourceDefinition . DEFAULT _ SFSB _ PASSIVATION _ DISABLED _ CACHE . marshallAsAttribute ( statefulBeanModel ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeStatefulBean"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   strictMaxPoolModelNode    =    strictMaxPoolModel . getValue (  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    strictMaxPoolModel . getName (  )  )  ;", "StrictMaxPoolResourceDefinition . MAX _ POOL _ SIZE . marshallAsAttribute ( strictMaxPoolModelNode ,    writer )  ;", "StrictMaxPoolResourceDefinition . DERIVE _ SIZE . marshallAsAttribute ( strictMaxPoolModelNode ,    writer )  ;", "StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT . marshallAsAttribute ( strictMaxPoolModelNode ,    writer )  ;", "StrictMaxPoolResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT . marshallAsAttribute ( strictMaxPoolModelNode ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeStrictMaxPoolConfig"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "for    ( Property   threadPool    :    threadPoolsModel . asPropertyList (  )  )     {", "ThreadsParser . getInstance (  )  . writeUnboundedQueueThreadPool ( writer ,    threadPool ,    Element . THREAD _ POOL . getLocalName (  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["writeThreadPools"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "TimerServiceResourceDefinition . THREAD _ POOL _ NAME . marshallAsAttribute ( timerServiceModel ,    writer )  ;", "TimerServiceResourceDefinition . DEFAULT _ DATA _ STORE . marshallAsAttribute ( timerServiceModel ,    writer )  ;", "writer . writeStartElement ( Element . DATA _ STORES . getLocalName (  )  )  ;", "writeFileDataStores ( writer ,    timerServiceModel )  ;", "writeDatabaseDataStores ( writer ,    timerServiceModel )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeTimerService"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3SubsystemXMLPersister"}, {"methodBody": ["METHOD_START", "{", "return   this . accessControlService ;", "}", "METHOD_END"], "methodName": ["getUserTransactionAccessControlServiceInjector"], "fileName": "org.jboss.as.ejb3.subsystem.EJB3UserTransactionAccessControlService"}, {"methodBody": ["METHOD_START", "{", "final   EJBTransportProvider   remoteTransportProvider    =    this . remoteTransportProvider ;", "if    ( remoteTransportProvider    !  =    null )     {", "builder . addTransportProvider ( remoteTransportProvider )  ;", "builder . addTransportProvider ( remoteHttpTransportProvider )  ;", "}", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.jboss.as.ejb3.subsystem.EJBClientConfiguratorService"}, {"methodBody": ["METHOD_START", "{", "return   endpointInjector ;", "}", "METHOD_END"], "methodName": ["getEndpointInjector"], "fileName": "org.jboss.as.ejb3.subsystem.EJBClientConfiguratorService"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ejb3.subsystem.EJBClientConfiguratorService"}, {"methodBody": ["METHOD_START", "{", "remoteTransportProvider    =    new   RemoteTransportProvider (  )  ;", "remoteHttpTransportProvider    =    new   HttpProvider (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.subsystem.EJBClientConfiguratorService"}, {"methodBody": ["METHOD_START", "{", "remoteTransportProvider    =    null ;", "remoteHttpTransportProvider    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ejb3.subsystem.EJBClientConfiguratorService"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   defaultDistinctName    =    this . attributeDefinition . resolveModelAttribute ( context ,    model )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceController <  ?  >    existingDefaultLocalEJBReceiverServiceController    =    registry . getService ( Service . SERVICE _ NAME )  ;", "Service   service    =     (  ( Service )     ( existingDefaultLocalEJBReceiverServiceController . getValue (  )  )  )  ;", "if    (  !  ( defaultDistinctName . isDefined (  )  )  )     {", "service . set ( null )  ;", "} else    {", "service . set ( defaultDistinctName . asString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateDefaultDistinctName"], "fileName": "org.jboss.as.ejb3.subsystem.EJBDefaultDistinctNameWriteHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . missingMethodPermissionsDenyAccessMergingProcessor )     =  =    null )     {", "return ;", "}", "final   ModelNode   modelNode    =    this . attributeDefinition . resolveModelAttribute ( context ,    model )  ;", "final   boolean   value    =    modelNode . asBoolean (  )  ;", "this . missingMethodPermissionsDenyAccessMergingProcessor . setDenyAccessByDefault ( value )  ;", "}", "METHOD_END"], "methodName": ["updateDefaultMethodPermissionsDenyAccess"], "fileName": "org.jboss.as.ejb3.subsystem.EJBDefaultMissingMethodPermissionsWriteHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . ejbDefaultSecurityDomainProcessor )     =  =    null )     {", "return ;", "}", "final   ModelNode   defaultSecurityDomainModelNode    =    this . attributeDefinition . resolveModelAttribute ( context ,    model )  ;", "final   String   defaultSecurityDomainName    =     ( defaultSecurityDomainModelNode . isDefined (  )  )     ?    defaultSecurityDomainModelNode . asString (  )     :    null ;", "this . ejbDefaultSecurityDomainProcessor . setDefaultSecurityDomainName ( defaultSecurityDomainName )  ;", "}", "METHOD_END"], "methodName": ["updateDefaultSecurityDomainDeploymentProcessor"], "fileName": "org.jboss.as.ejb3.subsystem.EJBDefaultSecurityDomainWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   allowRegex    =    this . attributeDefinition . resolveModelAttribute ( context ,    model )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceController <  ?  >    ejbNameServiceController    =    registry . getService ( EjbService . SERVICE _ NAME )  ;", "EjbService   service    =     (  ( EjbService )     ( ejbNameServiceController . getValue (  )  )  )  ;", "if    (  !  ( allowRegex . isDefined (  )  )  )     {", "service . setEjbAllowed ( false )  ;", "} else    {", "service . setEjbAllowed ( allowRegex . asBoolean (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateRegexAllowed"], "fileName": "org.jboss.as.ejb3.subsystem.EJBNameRegexWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   passByValueModel    =    this . attributeDefinition . resolveModelAttribute ( context ,    model )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceName   localTransportProviderServiceName ;", "if    ( passByValueModel . isDefined (  )  )     {", "final   boolean   passByValue    =    passByValueModel . asBoolean ( true )  ;", "if    ( passByValue )     {", "localTransportProviderServiceName    =    LocalTransportProvider . BY _ VALUE _ SERVICE _ NAME ;", "} else    {", "localTransportProviderServiceName    =    LocalTransportProvider . BY _ REFERENCE _ SERVICE _ NAME ;", "}", "} else    {", "localTransportProviderServiceName    =    LocalTransportProvider . BY _ VALUE _ SERVICE _ NAME ;", "}", "final   ServiceController <  ?  >    existingDefaultLocalEJBReceiverServiceController    =    registry . getService ( LocalTransportProvider . DEFAULT _ LOCAL _ TRANSPORT _ PROVIDER _ SERVICE _ NAME )  ;", "if    ( existingDefaultLocalEJBReceiverServiceController    !  =    null )     {", "context . removeService ( existingDefaultLocalEJBReceiverServiceController )  ;", "}", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   ValueInjectionService < LocalTransportProvider >    newDefaultLocalTransportProviderService    =    new   ValueInjectionService < LocalTransportProvider >  (  )  ;", "final   ServiceBuilder < LocalTransportProvider >    defaultLocalEJBReceiverServiceBuilder    =    serviceTarget . addService ( LocalTransportProvider . DEFAULT _ LOCAL _ TRANSPORT _ PROVIDER _ SERVICE _ NAME ,    newDefaultLocalTransportProviderService )  ;", "defaultLocalEJBReceiverServiceBuilder . addDependency ( localTransportProviderServiceName ,    LocalTransportProvider . class ,    newDefaultLocalTransportProviderService . getInjector (  )  )  ;", "defaultLocalEJBReceiverServiceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["updateDefaultLocalEJBReceiverService"], "fileName": "org.jboss.as.ejb3.subsystem.EJBRemoteInvocationPassByValueWriteHandler"}, {"methodBody": ["METHOD_START", "{", "parent . rejectChildResource ( PathElement . pathElement ( EJB 3 SubsystemModel . APPLICATION _ SECURITY _ DOMAIN )  )  ;", "}", "METHOD_END"], "methodName": ["registerApplicationSecurityDomainDTransformers"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "EJBTransformers . DataStoreTransformer   dataStoreTransformer    =    new   EJBTransformers . DataStoreTransformer (  )  ;", "timerService . getAttributeBuilder (  )  . setDiscard ( ALWAYS ,    EJB 3 SubsystemModel . DEFAULT _ DATA _ STORE )  . end (  )  ;", "timerService . discardOperations ( ADD )  ;", "timerService . setCustomResourceTransformer ( dataStoreTransformer )  ;", "timerService . rejectChildResource ( EJB 3 SubsystemModel . DATABASE _ DATA _ STORE _ PATH )  ;", "ResourceTransformationDescriptionBuilder   fileDataStore    =    timerService . addChildRedirection ( EJB 3 SubsystemModel . FILE _ DATA _ STORE _ PATH ,     (    current ,    builder )     -  >    builder . getCurrent (  )  )  ;", "fileDataStore . addOperationTransformationOverride ( ADD )  . inheritResourceAttributeDefinitions (  )  . setCustomOperationTransformer ( dataStoreTransformer )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["registerDataStoreTransformers"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "parent . rejectChildResource ( EJB 3 SubsystemModel . IDENTITY _ PATH )  ;", "}", "METHOD_END"], "methodName": ["registerIdentityTransformers"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "parent . rejectChildResource ( PathElement . pathElement ( EJB 3 SubsystemModel . MDB _ DELIVERY _ GROUP )  )  ;", "}", "METHOD_END"], "methodName": ["registerMdbDeliveryGroupTransformers"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   child    =    parent . addChildRedirection ( PassivationStoreResourceDefinition . INSTANCE . getPathElement (  )  ,    PathElement . pathElement ( EJB 3 SubsystemModel . CLUSTER _ PASSIVATION _ STORE )  )  ;", "child . getAttributeBuilder (  )  . setValueConverter ( Factory . createHardCoded ( new   ModelNode ( true )  ,    true )  ,    EJB 3 SubsystemModel . PASSIVATE _ EVENTS _ ON _ REPLICATE )  . setValueConverter ( Factory . createHardCoded ( new   ModelNode (  \" default \"  )  ,    true )  ,    EJB 3 SubsystemModel . CLIENT _ MAPPINGS _ CACHE )  . setValueConverter ( Factory . createHardCoded ( new   ModelNode (  )  . set ( Long . valueOf ( Integer . MAX _ VALUE )  )  ,    true )  ,    EJB 3 SubsystemModel . IDLE _ TIMEOUT )  . setValueConverter ( Factory . createHardCoded ( new   ModelNode (  )  . set ( TimeUnit . SECONDS . name (  )  )  ,    true )  ,    EJB 3 SubsystemModel . IDLE _ TIMEOUT _ UNIT )  ;", "}", "METHOD_END"], "methodName": ["registerPassivationStoreTransformers_1_2_1_and_1_3_0"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   remoteService    =    parent . addChildResource ( EJB 3 SubsystemModel . REMOTE _ SERVICE _ PATH )  ;", "remoteService . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeChecker . DiscardAttributeValueChecker ( new   dmr . ModelNode ( BeanManagerFactoryBuilderConfiguration . DEFAULT _ CONTAINER _ NAME )  )  ,    EJB 3 SubsystemModel . CLIENT _ MAPPINGS _ CLUSTER _ NAME )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemModel . CLIENT _ MAPPINGS _ CLUSTER _ NAME )  . setDiscard ( ALWAYS ,    EJB 3 SubsystemModel . EXECUTE _ IN _ WORKER )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["registerRemoteTransformers"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "parent . addChildResource ( PathElement . pathElement ( EJB 3 SubsystemModel . STRICT _ MAX _ BEAN _ INSTANCE _ POOL )  )  . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( StrictMaxPoolResourceDefinition . DeriveSize . NONE . toString (  )  )  )  ,    StrictMaxPoolResourceDefinition . DERIVE _ SIZE )  . addRejectCheck ( DEFINED ,    StrictMaxPoolResourceDefinition . DERIVE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["registerStrictMaxPoolTransformers"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   timerService    =    parent . addChildResource ( EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH )  ;", ". registerDataStoreTransformers ( timerService )  ;", "}", "METHOD_END"], "methodName": ["registerTimerTransformers_1_2_0"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "EJBTransformers . registerTransformers _  1  _  2  _  1  _ and _  1  _  3  _  0  ( subsystemRegistration ,    EJBTransformers . VERSION _  1  _  3  _  0  )  ;", "}", "METHOD_END"], "methodName": ["registerTimerTransformers_1_3_0"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   timerService    =    parent . addChildResource ( EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH )  ;", "ResourceTransformationDescriptionBuilder   db    =    timerService . addChildResource ( EJB 3 SubsystemModel . DATABASE _ DATA _ STORE _ PATH )  ;", "db . getAttributeBuilder (  )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( new   ModelNode (  (  -  1  )  )  )  ,    EJB 3 SubsystemModel . REFRESH _ INTERVAL )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( new   ModelNode ( true )  )  ,    EJB 3 SubsystemModel . ALLOW _ EXECUTION )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemModel . REFRESH _ INTERVAL ,    EJB 3 SubsystemModel . ALLOW _ EXECUTION )  ;", "}", "METHOD_END"], "methodName": ["registerTimerTransformers_1_3_0"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "EJBTransformers . registerTransformers _  1  _  2  _  1  _ and _  1  _  3  _  0  ( subsystemRegistration ,    EJBTransformers . VERSION _  1  _  2  _  1  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_1_2_1"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", ". StatefulCacheRefTransformer   statefulCacheRefTransformer    =    new    . StatefulCacheRefTransformer (  )  ;", "builder . setCustomResourceTransformer ( statefulCacheRefTransformer )  ;", "for    ( String   name    :    Arrays . asList ( WRITE _ ATTRIBUTE _ OPERATION ,    UNDEFINE _ ATTRIBUTE _ OPERATION ,    READ _ ATTRIBUTE _ OPERATION )  )     {", "builder . addOperationTransformationOverride ( name )  . inheritResourceAttributeDefinitions (  )  . setCustomOperationTransformer ( statefulCacheRefTransformer )  . end (  )  ;", "}", "builder . addOperationTransformationOverride ( ADD )  . inheritResourceAttributeDefinitions (  )  . setCustomOperationTransformer ( new    . AddStatefulCacheRefTransformer (  )  )  . end (  )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( true )  )  ,    EJB 3 SubsystemRootResourceDefinition . LOG _ EJB _ EXCEPTIONS )  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . LOG _ EJB _ EXCEPTIONS )  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    EJB 3 SubsystemRootResourceDefinition . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX )  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  ;", ". registerPassivationStoreTransformers _  1  _  2  _  1  _ and _  1  _  3  _  0  ( builder )  ;", ". registerRemoteTransformers ( builder )  ;", ". registerMdbDeliveryGroupTransformers ( builder )  ;", ". registerStrictMaxPoolTransformers ( builder )  ;", ". registerApplicationSecurityDomainDTransformers ( builder )  ;", ". registerIdentityTransformers ( builder )  ;", "builder . rejectChildResource ( PathElement . pathElement ( EJB 3 SubsystemModel . REMOTING _ PROFILE )  )  ;", "if    ( version . equals (  . VERSION _  1  _  2  _  1  )  )     {", ". registerTimerTransformers _  1  _  2  _  0  ( builder )  ;", "} else", "if    ( version . equals (  . VERSION _  1  _  3  _  0  )  )     {", ". registerTimerTransformers _  1  _  3  _  0  ( builder )  ;", "}", "builder . getAttributeBuilder (  )  . addRename ( EJB 3 SubsystemModel . STATISTICS _ ENABLED ,    EJB 3 SubsystemModel . ENABLE _ STATISTICS )  ;", "Tools . register ( builder . build (  )  ,    subsystemRegistration ,    version )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_1_2_1_and_1_3_0"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", "builder . getAttributeBuilder (  )  . setValueConverter ( AttributeConverter . Factory . createHardCoded ( new   ModelNode (  \" hornetq - ra \"  )  ,    true )  ,    EJB 3 SubsystemRootResourceDefinition . DEFAULT _ RESOURCE _ ADAPTER _ NAME )  . end (  )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX )  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  ;", ". registerMdbDeliveryGroupTransformers ( builder )  ;", ". registerRemoteTransformers ( builder )  ;", ". registerStrictMaxPoolTransformers ( builder )  ;", ". registerApplicationSecurityDomainDTransformers ( builder )  ;", ". registerIdentityTransformers ( builder )  ;", "builder . getAttributeBuilder (  )  . addRename ( EJB 3 SubsystemModel . STATISTICS _ ENABLED ,    EJB 3 SubsystemModel . ENABLE _ STATISTICS )  ;", "Tools . register ( builder . build (  )  ,    subsystemRegistration ,     . VERSION _  3  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_3_0_0"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", ". registerApplicationSecurityDomainDTransformers ( builder )  ;", ". registerIdentityTransformers ( builder )  ;", "builder . addChildResource ( RemotingProfileResourceDefinition . INSTANCE )  . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    StaticEJBDiscoveryDefinition . INSTANCE )  . end (  )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX )  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  ;", "builder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  ;", "builder . getAttributeBuilder (  )  . addRename ( EJB 3 SubsystemModel . STATISTICS _ ENABLED ,    EJB 3 SubsystemModel . ENABLE _ STATISTICS )  ;", "Tools . register ( builder . build (  )  ,    subsystemRegistration ,     . VERSION _  4  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_4_0_0"], "fileName": "org.jboss.as.ejb3.subsystem.EJBTransformers"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem 1  5  . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["test15"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3SubsystemUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "final   String   subsystemXml    =    getSubsystemXml (  )  ;", "final   KernelServices   ks    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "Assert . assertTrue (  \" Subsystem   boot   failed !  \"  ,    ks . isSuccessfulBoot (  )  )  ;", "PathAddress   pa    =    PathAddress . pathAddress (  \" subsystem \"  ,     \" ejb 3  \"  )  . append (  \" strict - max - bean - instance - pool \"  ,     \" slsb - strict - max - pool \"  )  ;", "ModelNode   composite    =    Util . createEmptyOperation (  \" composite \"  ,    EMPTY _ ADDRESS )  ;", "ModelNode   steps    =    composite . get (  \" steps \"  )  ;", "ModelNode   writeMax    =    Util . getWriteAttributeOperation ( pa ,     \" max - pool - size \"  ,     5  )  ;", "ModelNode   writeDerive    =    Util . getWriteAttributeOperation ( pa ,     \" derive - size \"  ,     \" none \"  )  ;", "steps . add ( writeMax )  ;", "steps . add ( writeDerive )  ;", "ModelNode   response    =    ks . executeOperation ( composite )  ;", "Assert . assertEquals ( response . toString (  )  ,     \" success \"  ,    response . get (  \" outcome \"  )  . asString (  )  )  ;", "validatePoolConfig ( ks ,    pa )  ;", "steps . setEmptyList (  )  ;", "writeMax . get (  \" value \"  )  . set (  1  0  )  ;", "writeDerive . get (  \" value \"  )  . set (  \" from - cpu - count \"  )  ;", "steps . add ( writeMax )  ;", "steps . add ( writeDerive )  ;", "ks . executeForFailure ( composite )  ;", "validatePoolConfig ( ks ,    pa )  ;", "}", "METHOD_END"], "methodName": ["testPoolSizeAlternatives"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3SubsystemUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   ra    =    Util . createEmptyOperation (  \" read - attribute \"  ,    pa )  ;", "ra . get (  \" name \"  )  . set (  \" max - pool - size \"  )  ;", "ModelNode   response    =    kxecuteOperation ( ra )  ;", "Art . artEquals ( response . toString (  )  ,     5  ,    response . get (  \" result \"  )  . asInt (  )  )  ;", "ra . get (  \" name \"  )  . set (  \" derive - size \"  )  ;", "response    =    kxecuteOperation ( ra )  ;", "Art . artFalse ( response . toString (  )  ,    response . hafined (  \" result \"  )  )  ;", "}", "METHOD_END"], "methodName": ["validatePoolConfig"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3SubsystemUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( EJB 3 Extension . SUBSYSTEM _ PATH )  ;", "if    ( EJB 3 Model . VERSION _  1  _  2  _  1  . matches ( version )  )     {", "FailedOperationTransformationConfig . ChainedConfig   chainedSubsystemConfig    =    ChainedConfig . createBuilder ( EJB 3 SubsystemRootResourceDefinition . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  . addConfig ( new   FailedOperationTransformationConfig . NewAttributesConfig ( EJB 3 SubsystemRootResourceDefinition . LOG _ EJB _ EXCEPTIONS ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  )  . addConfig ( new    . CorrectFalseToTrue ( EJB 3 SubsystemRootResourceDefinition . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  )  . build (  )  ;", "config . addFailedAttribute ( subsystemAddress ,    chainedSubsystemConfig )  ;", "final   PathAddress   timerServiceAddr    =    subsystemAddress . append ( EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH )  ;", "final   PathAddress   badFileStoreAddr    =    timerServiceAddr . append ( PathElement . pathElement ( EJB 3 SubsystemModel . FILE _ DATA _ STORE ,     \" file - data - store - rename - to - default \"  )  )  ;", "final   PathAddress   newFileStoreAddr    =    timerServiceAddr . append ( PathElement . pathElement ( EJB 3 SubsystemModel . FILE _ DATA _ STORE ,     \" file - data - store \"  )  )  ;", "config . addFailedAttribute ( badFileStoreAddr ,    new    . ChangeAddressConfig ( services ,    badFileStoreAddr ,    newFileStoreAddr )  )  ;", ". RemoveExtraFileStoreConfig   removeExtraFileStoreConfig    =    new    . RemoveExtraFileStoreConfig ( services ,    timerServiceAddr )  ;", "config . addFailedAttribute ( newFileStoreAddr ,    removeExtraFileStoreConfig )  ;", "config . addFailedAttribute ( subsystemAddress . append ( EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH ,    PathElement . pathElement ( EJB 3 SubsystemModel . FILE _ DATA _ STORE ,     \" file - data - store - rejected \"  )  )  ,    REJECTED _ RESOURCE )  ;", "PathAddress   databaseDataStore    =    subsystemAddress . append ( EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH ,    EJB 3 SubsystemModel . DATABASE _ DATA _ STORE _ PATH )  ;", "config . addFailedAttribute ( databaseDataStore ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . MDB _ DELIVERY _ GROUP ,     \" delivery - group - name \"  )  )  ,    REJECTED _ RESOURCE )  ;", "PathAddress   remotingProfileAddress    =    subsystemAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . REMOTING _ PROFILE ,     \" profile \"  )  )  ;", "PathAddress   ejbReceiverAddress    =    remotingProfileAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . REMOTING _ EJB _ RECEIVER ,     \" receiver \"  )  )  ;", "PathAddress   channelCreationOptionsAddress    =    ejbReceiverAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS )  )  ;", "config . addFailedAttribute ( remotingProfileAddress ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( ejbReceiverAddress ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( channelCreationOptionsAddress ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( subsystemAddress . append ( EJB 3 SubsystemModel . REMOTE _ SERVICE _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( EJB 3 RemoteResourceDefinition . CLIENT _ MAPPINGS _ CLUSTER _ NAME )  )  ;", "config . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . APPLICATION _ SECURITY _ DOMAIN ,     \" domain \"  )  )  ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( subsystemAddress . append ( EJB 3 SubsystemModel . IDENTITY _ PATH )  ,    REJECTED _ RESOURCE )  ;", "config . setDontTransformComposite (  )  ;", "config . setCallback (  (  )     -  >    removeExtraFileStoreConfig . removeExtraFileDataStore (  )  )  ;", "}", "if    ( EJB 3 Model . VERSION _  1  _  3  _  0  . matches ( version )  )     {", "FailedOperationTransformationConfig . ChainedConfig   chainedConfig    =    ChainedConfig . createBuilder ( EJB 3 SubsystemRootResourceDefinition . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  . addConfig ( new   FailedOperationTransformationConfig . NewAttributesConfig ( EJB 3 SubsystemRootResourceDefinition . LOG _ EJB _ EXCEPTIONS ,    EJB 3 SubsystemRootResourceDefinition . ALLOW _ EJB _ NAME _ REGEX ,    EJB 3 SubsystemRootResourceDefinition . ENABLE _ GRACEFUL _ TXN _ SHUTDOWN )  )  . addConfig ( new    . CorrectFalseToTrue ( EJB 3 SubsystemRootResourceDefinition . DISABLE _ DEFAULT _ EJB _ PERMISSIONS )  )  . build (  )  ;", "config . addFailedAttribute ( subsystemAddress ,    chainedConfig )  ;", "PathAddress   databaseDataStore    =    subsystemAddress . append ( EJB 3 SubsystemModel . TIMER _ SERVICE _ PATH ,    EJB 3 SubsystemModel . DATABASE _ DATA _ STORE _ PATH )  ;", "config . addFailedAttribute ( databaseDataStore ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . MDB _ DELIVERY _ GROUP ,     \" delivery - group - name \"  )  )  ,    REJECTED _ RESOURCE )  ;", "PathAddress   remotingProfileAddress    =    subsystemAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . REMOTING _ PROFILE ,     \" profile \"  )  )  ;", "PathAddress   ejbReceiverAddress    =    remotingProfileAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . REMOTING _ EJB _ RECEIVER ,     \" receiver \"  )  )  ;", "PathAddress   channelCreationOptionsAddress    =    ejbReceiverAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS )  )  ;", "config . addFailedAttribute ( remotingProfileAddress ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( ejbReceiverAddress ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( channelCreationOptionsAddress ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( subsystemAddress . append ( EJB 3 SubsystemModel . REMOTE _ SERVICE _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( EJB 3 RemoteResourceDefinition . CLIENT _ MAPPINGS _ CLUSTER _ NAME )  )  ;", "config . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( EJB 3 SubsystemModel . APPLICATION _ SECURITY _ DOMAIN ,     \" domain \"  )  )  ,    REJECTED _ RESOURCE )  ;", "config . addFailedAttribute ( subsystemAddress . append ( EJB 3 SubsystemModel . IDENTITY _ PATH )  ,    REJECTED _ RESOURCE )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["createFailedOperationTransformationConfig"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   String . format ( pattern ,    version . getMavenGavVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["formatArtifact"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   Ejb 3 TransformersTestCase . formatArtifact (  \" as : jboss - as - ejb 3  :  % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["formatLegacySubsystemArtifact"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   Ejb 3 TransformersTestCase . formatArtifact (  \" wildfly : wildfly - ejb 3  :  % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["formatSubsystemArtifact"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "OperationTransformer . TransformedOperation   op    =    mainServices . executeInMainAndGetTheTransformedOperation ( operation ,    modelVersion )  ;", "if    (  ( op . getTransformedOperation (  )  )     !  =    null )     {", "ModelTestUtils . checkOutcome ( mainServices . getLegacyServices ( modelVersion )  . executeOperation ( op . getTransformedOperation (  )  )  )  ;", "}", "ModelNode   mainModel    =    mainServices . readWholeModel (  )  ;", "ModelNode   legacyModel    =    legacyServices . readWholeModel (  )  ;", "ModelNode   mainEjbSubsystem    =    mainModel . get ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "ModelNode   legacyEjbSubsystem    =    legacyModel . get ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "Assert . assertEquals ( mainEjbSubsystem . get ( attributeName )  ,    legacyEjbSubsystem . get ( legacyAttributeName )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeRenameTransform"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( this . createAdditionalInitialization (  )  . withCapabilities ( buildDynamicCapabilityName (  \" security - domain \"  ,     \" ApplicationDomain \"  )  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controller ,    model )  . addMavenResourceURL ( mavenResourceURLs )  . dontPersistXml (  )  ;", "KernelServices   services    =    builder . build (  )  ;", "Assert . assertTrue ( services . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    services . getLegacyServices ( model )  ;", "Assert . assertNotNull ( legacyServices )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    operations    =    builder . parseXmlResource (  \" subsystem - ejb 3  - transform - reject . xml \"  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( services ,    model ,    operations ,     . createFailedOperationTransformationConfig ( services ,    model )  )  ;", "}", "METHOD_END"], "methodName": ["testRejections"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   controller    =    ModelTestControllerVersion . EAP _  6  _  2  _  0  ;", "this . testRejections ( ModelVersion . create (  1  ,     2  ,     1  )  ,    controller ,     . formatLegacySubsystemArtifact ( controller )  ,     . formatArtifact (  \" as : jboss - as - threads :  % s \"  ,    controller )  ,     . LEGACY _ EJB _ CLIENT _ ARTIFACT )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP620"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   controller    =    ModelTestControllerVersion . EAP _  6  _  3  _  0  ;", "this . testRejections ( ModelVersion . create (  1  ,     2  ,     1  )  ,    controller ,     . formatLegacySubsystemArtifact ( controller )  ,     . formatArtifact (  \" as : jboss - as - threads :  % s \"  ,    controller )  ,     . LEGACY _ EJB _ CLIENT _ ARTIFACT )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP630"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   controller    =    ModelTestControllerVersion . EAP _  6  _  4  _  0  ;", "this . testRejections ( ModelVersion . create (  1  ,     3  ,     0  )  ,    controller ,     . formatLegacySubsystemArtifact ( controller )  ,     . formatArtifact (  \" as : jboss - as - threads :  % s \"  ,    controller )  ,     . LEGACY _ EJB _ CLIENT _ ARTIFACT )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP640"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXmlResource (  \" subsystem - ejb 3  - transform . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controller ,    model )  . addMavenResourceURL ( mavenResourceURLs )  . skipReverseControllerCheck (  )  ;", "KernelServices   services    =    builder . build (  )  ;", "KernelServices   legacyServices    =    services . getLegacyServices ( model )  ;", "Assert . assertTrue ( services . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( services ,    model ,    null )  ;", "PathAddress   ejb 3 PathAddress    =    PathAddress . pathAddress ( SUBSYSTEM ,    EJB 3 Extension . SUBSYSTEM _ NAME )  ;", "Map < String ,    String >    attributeRenames    =    new   HashMap <  >  (  )  ;", "attributeRenames . put ( EJB 3 SubsystemRootResourceDefinition . DEFAULT _ SFSB _ CACHE . getName (  )  ,    EJB 3 SubsystemRootResourceDefinition . DEFAULT _ CLUSTERED _ SFSB _ CACHE . getName (  )  )  ;", "attributeRenames . put ( EJB 3 SubsystemRootResourceDefinition . DEFAULT _ SFSB _ PASSIVATION _ DISABLED _ CACHE . getName (  )  ,    EJB 3 SubsystemRootResourceDefinition . DEFAULT _ SFSB _ CACHE . getName (  )  )  ;", "for    ( Map . Entry < String ,    String >    renames    :    attributeRenames . entrySet (  )  )     {", "ModelNode   operation    =    Util . getWriteAttributeOperation ( ejb 3 PathAddress ,    renames . getKey (  )  ,     \" test \"  )  ;", "testAttributeRenameTransform ( model ,    services ,    legacyServices ,    operation ,    renames . getKey (  )  ,    renames . getValue (  )  )  ;", "operation    =    Util . getReadAttributeOperation ( ejb 3 PathAddress ,    renames . getKey (  )  )  ;", "testAttributeRenameTransform ( model ,    services ,    legacyServices ,    operation ,    renames . getKey (  )  ,    renames . getValue (  )  )  ;", "operation    =    Util . getUndefineAttributeOperation ( ejb 3 PathAddress ,    renames . getKey (  )  )  ;", "testAttributeRenameTransform ( model ,    services ,    legacyServices ,    operation ,    renames . getKey (  )  ,    renames . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTransformation"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   controller    =    ModelTestControllerVersion . EAP _  6  _  2  _  0  ;", "testTransformation ( ModelVersion . create (  1  ,     2  ,     1  )  ,    controller ,     . formatLegacySubsystemArtifact ( controller )  ,     . formatArtifact (  \" as : jboss - as - threads :  % s \"  ,    controller )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP620"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   controller    =    ModelTestControllerVersion . EAP _  6  _  3  _  0  ;", "testTransformation ( ModelVersion . create (  1  ,     2  ,     1  )  ,    controller ,     . formatLegacySubsystemArtifact ( controller )  ,     . formatArtifact (  \" as : jboss - as - threads :  % s \"  ,    controller )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP630"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   controller    =    ModelTestControllerVersion . EAP _  6  _  4  _  0  ;", "testTransformation ( ModelVersion . create (  1  ,     3  ,     0  )  ,    controller ,     . formatLegacySubsystemArtifact ( controller )  ,     . formatArtifact (  \" as : jboss - as - threads :  % s \"  ,    controller )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP640"], "fileName": "org.jboss.as.ejb3.subsystem.Ejb3TransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   ejbNameRegexAllowed ;", "}", "METHOD_END"], "methodName": ["isEjbNameRegexAllowed"], "fileName": "org.jboss.as.ejb3.subsystem.EjbNameRegexService"}, {"methodBody": ["METHOD_START", "{", "this . ejbNameRegexAllowed    =    ejbNameRegexAllowed ;", "}", "METHOD_END"], "methodName": ["setEjbNameRegexAllowed"], "fileName": "org.jboss.as.ejb3.subsystem.EjbNameRegexService"}, {"methodBody": ["METHOD_START", "{", "String   name    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  . getLastElement (  )  . getValue (  )  ;", "ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "EJBSuspendHandlerService   service    =     (  ( EJBSuspendHandlerService )     ( registry . getRequiredService ( EJBSuspendHandlerService . SERVICE _ NAME )  . getValue (  )  )  )  ;", "if    (  ( service    !  =    null )     &  &     ( this . gracefulTxnShutdownAttribute . getName (  )  . equals ( attributeName )  )  )     {", "boolean   e    =    this . gracefulTxnShutdownAttribute . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "service . e ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["applyModelToRuntime"], "fileName": "org.jboss.as.ejb3.subsystem.EnableGracefulTxnShutdownWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   boolean   enabled    =    EJB 3 SubsystemRootResourceDefinition . LOG _ EJB _ EXCEPTIONS . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   ServiceName   serviceName    =    LoggingInterceptor . LOGGING _ ENABLED _ SERVICE _ NAME ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceController   sc    =    registry . getService ( serviceName )  ;", "if    ( sc    !  =    null )     {", "final   AtomicBoolean   value    =     (  ( AtomicBoolean )     ( sc . getValue (  )  )  )  ;", "value . set ( enabled )  ;", "} else    {", "final   ValueService < AtomicBoolean >    service    =    new   ValueService ( new   msc . value . ImmediateValue ( new   AtomicBoolean ( enabled )  )  )  ;", "context . getServiceTarget (  )  . addService ( serviceName ,    service )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateOrCreateDefaultExceptionLoggingEnabledService"], "fileName": "org.jboss.as.ejb3.subsystem.ExceptionLoggingWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   pathNode    =    FileDataStoreResourceDefinition . PATH . resolveModelAttribute ( context ,    model )  ;", "final   String   path    =     ( pathNode . isDefined (  )  )     ?    pathNode . asString (  )     :    null ;", "final   ModelNode   relativeToNode    =    FileDataStoreResourceDefinition . RELATIVE _ TO . resolveModelAttribute ( context ,    model )  ;", "final   String   relativeTo    =     ( relativeToNode . isDefined (  )  )     ?    relativeToNode . asString (  )     :    null ;", "final   FileTimerPersistence   fileTimerPersistence    =    new   FileTimerPersistence ( true ,    path ,    relativeTo )  ;", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  ;", "final   ServiceName   serviceName    =    TimerPersistence . SERVICE _ NAME . append ( address . getLastElement (  )  . getValue (  )  )  ;", "context . getServiceTarget (  )  . addService ( serviceName ,    fileTimerPersistence )  . addDependency ( JBOSS _ SERVICE _ MODULE _ LOADER ,    ModuleLoader . class ,    fileTimerPersistence . getModuleLoader (  )  )  . addDependency ( SERVICE _ NAME ,    PathManager . class ,    fileTimerPersistence . getPathManager (  )  )  . addDependency ( TransactionManagerService . SERVICE _ NAME ,    TransactionManager . class ,    fileTimerPersistence . getTransactionManager (  )  )  . addDependency ( TransactionSynchronizationRegistryService . SERVICE _ NAME ,    TransactionSynchronizationRegistry . class ,    fileTimerPersistence . getTransactionSynchronizationRegistry (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.jboss.as.ejb3.subsystem.FileDataStoreAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attr    :    FileDataStoreResourceDefinition . ATTRIBUTES . values (  )  )     {", "attr . validateAndSet ( operation ,    timerServiceModel )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.ejb3.subsystem.FileDataStoreAdd"}, {"methodBody": ["METHOD_START", "{", "return   enabledByDefault ;", "}", "METHOD_END"], "methodName": ["isEnabledByDefault"], "fileName": "org.jboss.as.ejb3.subsystem.IIOPSettingsService"}, {"methodBody": ["METHOD_START", "{", "return   useQualifiedName ;", "}", "METHOD_END"], "methodName": ["isUseQualifiedName"], "fileName": "org.jboss.as.ejb3.subsystem.IIOPSettingsService"}, {"methodBody": ["METHOD_START", "{", "this . enabledByDefault    =    enabledByDefault ;", "}", "METHOD_END"], "methodName": ["setEnabledByDefault"], "fileName": "org.jboss.as.ejb3.subsystem.IIOPSettingsService"}, {"methodBody": ["METHOD_START", "{", "this . useQualifiedName    =    useQualifiedName ;", "}", "METHOD_END"], "methodName": ["setUseQualifiedName"], "fileName": "org.jboss.as.ejb3.subsystem.IIOPSettingsService"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >     !  ( IdentityResourceDefinition . outflowSecurityDomains . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["getOutflowSecurityDomainsConfiguredSupplier"], "fileName": "org.jboss.as.ejb3.subsystem.IdentityResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   String   groupName    =    PathAddress . pathAddress ( operation . get ( ADDRESS )  )  . getLastElement (  )  . getValue (  )  ;", "final   boolean   active    =    ResourceDefinition . ACTIVE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "context . getServiceTarget (  )  . addService ( ResourceDefinition . getDeliveryGroupServiceName ( groupName )  ,    NULL )  . setInitialMode (  ( active    ?    Mode . ACTIVE    :    Mode . NEVER )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installServices"], "fileName": "org.jboss.as.ejb3.subsystem.MdbDeliveryGroupAdd"}, {"methodBody": ["METHOD_START", "{", "return   MdbDeliveryGroupResourceDefinition . DELIVERY _ GROUP _ SERVICE _ NAME . append ( deliveryGroupName )  ;", "}", "METHOD_END"], "methodName": ["getDeliveryGroupServiceName"], "fileName": "org.jboss.as.ejb3.subsystem.MdbDeliveryGroupResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    PathAddress . pathAddress ( operation . get ( ADDRESS )  )  . getLastElement (  )  . getValue (  )  ;", "BeanManagerFactoryBuilderConfiguration   config    =    new   BeanManagerFactoryBuilderConfiguration (  )     {", "private   volatile   int   maxSize    =    initialMaxSize ;", "@ Override", "public   String   getContainerName (  )     {", "return   containerName ;", "}", "@ Override", "public   String   getCacheName (  )     {", "return   cacheName ;", "}", "@ Override", "public   int   getMaxSize (  )     {", "return   this . maxSize ;", "}", "@ Override", "public   void   setMaxSize ( int   size )     {", "this . maxSize    =    size ;", "}", "}  ;", "new   cache . distributable . DistributableCacheFactoryBuilderService ( context . getCapabilityServiceSupport (  )  ,    name ,    config )  . build ( context . getServiceTarget (  )  )  . setInitialMode ( ON _ DEMAND )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["install"], "fileName": "org.jboss.as.ejb3.subsystem.PassivationStoreAdd"}, {"methodBody": ["METHOD_START", "{", "String   name    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  . getLastElement (  )  . getValue (  )  ;", "ServiceName   serviceName    =    DistributableCacheFactoryBuilderService . getServiceName ( name )  ;", "ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "ServiceController <  ?  >    service    =    registry . getService ( serviceName )  ;", "if    ( service    !  =    null )     {", "DistributableCacheFactoryBuilder <  ?  ,     ?  >    builder    =     (  ( DistributableCacheFactoryBuilder <  ?  ,     ?  >  )     ( service . getValue (  )  )  )  ;", "if    ( builder    !  =    null )     {", "if    ( this . maxSizeAttribute . getName (  )  . equals ( attributeName )  )     {", "int   maxSize    =    this . maxSizeAttribute . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "builder . getConfiguration (  )  . setMaxSize ( maxSize )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["applyModelToRuntime"], "fileName": "org.jboss.as.ejb3.subsystem.PassivationStoreWriteHandler"}, {"methodBody": ["METHOD_START", "{", "EJB 3 RemoteServiceAdd . INSTANCE . installRuntimeServices ( context ,    ejb 3 RemoteServiceModelNode )  ;", "}", "METHOD_END"], "methodName": ["recreateParentService"], "fileName": "org.jboss.as.ejb3.subsystem.RemoteConnectorChannelCreationOptionResource"}, {"methodBody": ["METHOD_START", "{", "final   OptionMap   optionMap ;", "if    ( channelCreationOptionsNode . isDefined (  )  )     {", "final   OptionMap . Builder   optionMapBuilder    =    OptionMap . builder (  )  ;", "final   ClassLoader   loader    =    this . getClass (  )  . getClassLoader (  )  ;", "for    ( final   Property   optionProperty    :    channelCreationOptionsNode . asPropertyList (  )  )     {", "final   String   name    =    optionProperty . getName (  )  ;", "final   ModelNode   propValueModel    =    optionProperty . getValue (  )  ;", "final   String   type    =    eConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ TYPE . resolveModelAttribute ( context ,    propValueModel )  . asString (  )  ;", "final   String   optionClassName    =    this . getClassNameForChannelOptionType ( type )  ;", "final   String   fullyQualifiedOptionName    =     ( optionClassName    +     \"  .  \"  )     +    name ;", "final   Option   option    =    Option . fromString ( fullyQualifiedOptionName ,    loader )  ;", "final   String   value    =    eConnectorChannelCreationOptionResource . CHANNEL _ CREATION _ OPTION _ VALUE . resolveModelAttribute ( context ,    propValueModel )  . asString (  )  ;", "optionMapBuilder . set ( option ,    option . parseValue ( value ,    loader )  )  ;", "}", "optionMap    =    optionMapBuilder . getMap (  )  ;", "} else    {", "optionMap    =    OptionMap . EMPTY ;", "}", "return   optionMap ;", "}", "METHOD_END"], "methodName": ["createChannelOptionMap"], "fileName": "org.jboss.as.ejb3.subsystem.RemotingProfileAdd"}, {"methodBody": ["METHOD_START", "{", "if    (  \" remoting \"  . equals ( optionType )  )     {", "return   Options . class . getName (  )  ;", "}", "if    (  \" xnio \"  . equals ( optionType )  )     {", "return   Options . class . getName (  )  ;", "}", "throw   EjbLogger . ROOT _ LOGGER . unknownChannelCreationOptionType ( optionType )  ;", "}", "METHOD_END"], "methodName": ["getClassNameForChannelOptionType"], "fileName": "org.jboss.as.ejb3.subsystem.RemotingProfileAdd"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   String   profileName    =    address . getLastElement (  )  . getValue (  )  ;", "final   ServiceName   profileServiceName    =    Service . BASE _ SERVICE _ NAME . append ( profileName )  ;", "final   ModelNode   staticEjbDiscoery    =    StaticEJBDiscoveryDefinition . INSTANCE . resolveModelAttribute ( context ,    profileNode )  ;", "List < StaticEJBDiscoveryDefinition . StaticEjbDiscovery >    discoveryList    =    StaticEJBDiscoveryDefinition . createStaticEjbList ( context ,    staticEjbDiscoery )  ;", "final   List < ServiceURL >    urls    =    new   ArrayList <  >  (  )  ;", "for    ( StaticEJBDiscoveryDefinition . StaticEjbDiscovery   resource    :    discoveryList )     {", "ServiceURL . Builder   builder    =    new   ServiceURL . Builder (  )  ;", "builder . setAbstractType (  \" ejb \"  )  . setAbstractTypeAuthority (  \" jboss \"  )  . setUri ( new   URI ( resource . getUrl (  )  )  )  ;", "String   distinctName    =     (  ( resource . getDistinct (  )  )     =  =    null )     ?     \"  \"     :    resource . getDistinct (  )  ;", "String   appName    =     (  ( resource . getApp (  )  )     =  =    null )     ?     \"  \"     :    resource . getApp (  )  ;", "String   moduleName    =    resource . getModule (  )  ;", "if    ( distinctName . isEmpty (  )  )     {", "if    ( appName . isEmpty (  )  )     {", "builder . addAttribute ( FILTER _ ATTR _ EJB _ MODULE ,    AttributeValue . fromString ( moduleName )  )  ;", "} else    {", "builder . addAttribute ( FILTER _ ATTR _ EJB _ MODULE ,    AttributeValue . fromString (  (  ( appName    +     \"  /  \"  )     +    moduleName )  )  )  ;", "}", "} else    {", "if    ( appName . isEmpty (  )  )     {", "builder . addAttribute ( FILTER _ ATTR _ EJB _ MODULE _ DISTINCT ,    AttributeValue . fromString (  (  ( moduleName    +     \"  /  \"  )     +    distinctName )  )  )  ;", "} else    {", "builder . addAttribute ( FILTER _ ATTR _ EJB _ MODULE _ DISTINCT ,    AttributeValue . fromString (  (  (  (  ( appName    +     \"  /  \"  )     +    moduleName )     +     \"  /  \"  )     +    distinctName )  )  )  ;", "}", "}", "urls . add ( builder . create (  )  )  ;", "}", "final   Map < String ,    Service . ConnectionSpec >    map    =    new   HashMap <  >  (  )  ;", "final   Service   profileService    =    new   Service ( urls ,    map )  ;", "final   ServiceBuilder < Service >    builder    =    context . getServiceTarget (  )  . addService ( profileServiceName ,    profileService )  ;", "if    ( profileNode . hasDefined ( EJB 3 SubsystemModel . REMOTING _ EJB _ RECEIVER )  )     {", "for    ( final   Property   receiverProperty    :    profileNode . get ( EJB 3 SubsystemModel . REMOTING _ EJB _ RECEIVER )  . asPropertyList (  )  )     {", "final   ModelNode   receiverNode    =    receiverProperty . getValue (  )  ;", "final   String   connectionRef    =    RemotingEjbReceiverDefinition . OUTBOUND _ CONNECTION _ REF . resolveModelAttribute ( context ,    receiverNode )  . asString (  )  ;", "final   long   timeout    =    RemotingEjbReceiverDefinition . CONNECT _ TIMEOUT . resolveModelAttribute ( context ,    receiverNode )  . asLong (  )  ;", "final   ServiceName   connectionDependencyService    =    OUTBOUND _ CONNECTION _ BASE _ SERVICE _ NAME . append ( connectionRef )  ;", "final   InjectedValue < AbstractOutboundConnectionService >    connectionInjector    =    new   InjectedValue < AbstractOutboundConnectionService >  (  )  ;", "builder . addDependency ( connectionDependencyService ,    AbstractOutboundConnectionService . class ,    connectionInjector )  ;", "final   ModelNode   channelCreationOptionsNode    =    receiverNode . get ( EJB 3 SubsystemModel . CHANNEL _ CREATION _ OPTIONS )  ;", "OptionMap   channelCreationOptions    =    createChannelOptionMap ( context ,    channelCreationOptionsNode )  ;", "map . put ( connectionRef ,    new   Service . ConnectionSpec ( connectionRef ,    connectionInjector ,    channelCreationOptions ,    timeout )  )  ;", "}", "}", "final   boolean   isLocalReceiverExcluded    =    ResourceDefinition . EXCLUDE _ LOCAL _ RECEIVER . resolveModelAttribute ( context ,    profileNode )  . asBoolean (  )  ;", "if    (  ! isLocalReceiverExcluded )     {", "final   ModelNode   passByValueNode    =    ResourceDefinition . LOCAL _ RECEIVER _ PASS _ BY _ VALUE . resolveModelAttribute ( context ,    profileNode )  ;", "if    ( passByValueNode . isDefined (  )  )     {", "final   ServiceName   localTransportProviderServiceName    =     (  ( passByValueNode . asBoolean (  )  )     =  =    true )     ?    LocalTransportProvider . BY _ VALUE _ SERVICE _ NAME    :    LocalTransportProvider . BY _ REFERENCE _ SERVICE _ NAME ;", "builder . addDependency ( localTransportProviderServiceName ,    EJBTransportProvider . class ,    profileService . getLocalTransportProviderInjector (  )  )  ;", "} else    {", "builder . addDependency ( LocalTransportProvider . DEFAULT _ LOCAL _ TRANSPORT _ PROVIDER _ SERVICE _ NAME ,    EJBTransportProvider . class ,    profileService . getLocalTransportProviderInjector (  )  )  ;", "}", "}", "builder . setInitialMode ( ACTIVE )  . install (  )  ;", "}    catch    ( IllegalArgumentException    |    URISyntaxException   e )     {", "throw   new   OperationFailedException ( e . getLocalizedMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["installServices"], "fileName": "org.jboss.as.ejb3.subsystem.RemotingProfileAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( final   AttributeDefinition   attr    :    this . attributes )     {", "attr . validateAndSet ( operation ,    model )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.ejb3.subsystem.RemotingProfileChildResourceAddHandler"}, {"methodBody": ["METHOD_START", "{", "context . readResource ( EMPTY _ ADDRESS ,    false )  ;", "context . removeResource ( EMPTY _ ADDRESS )  ;", "}", "METHOD_END"], "methodName": ["updateModel"], "fileName": "org.jboss.as.ejb3.subsystem.RemotingProfileChildResourceRemoveHandler"}, {"methodBody": ["METHOD_START", "{", "final   List < StaticEJBDiscoveryDefinition . StaticEjbDiscovery >    ret    =    new   ArrayList <  >  (  )  ;", "if    ( ejbList . isDefined (  )  )     {", "for    ( final   ModelNode   disc    :    ejbList . asList (  )  )     {", "ModelNode   app    =    StaticEJBDiscoveryDefinition . APP _ AD . resolveModelAttribute ( context ,    disc )  ;", "String   module    =    StaticEJBDiscoveryDefinition . MODULE _ AD . resolveModelAttribute ( context ,    disc )  . asString (  )  ;", "ModelNode   distinct    =    StaticEJBDiscoveryDefinition . DISTINCT _ AD . resolveModelAttribute ( context ,    disc )  ;", "String   url    =    StaticEJBDiscoveryDefinition . URI _ AD . resolveModelAttribute ( context ,    disc )  . asString (  )  ;", "ret . add ( new   StaticEJBDiscoveryDefinition . StaticEjbDiscovery (  ( app . isDefined (  )     ?    app . asString (  )     :    null )  ,    module ,     ( distinct . isDefined (  )     ?    distinct . asString (  )     :    null )  ,    url )  )  ;", "}", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["createStaticEjbList"], "fileName": "org.jboss.as.ejb3.subsystem.StaticEJBDiscoveryDefinition"}, {"methodBody": ["METHOD_START", "{", "final   boolean   statisticsEnabled    =    EJB 3 SubsystemRootResourceDefinition . STATISTICS _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", ". utilities ( context )  . setStatisticsEnabled ( statisticsEnabled )  ;", "}", "METHOD_END"], "methodName": ["updateToRuntime"], "fileName": "org.jboss.as.ejb3.subsystem.StatisticsEnabledWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceRegistry   serviceRegistry    =    context . getServiceRegistry ( true )  ;", "return    (  ( EJBUtilities )     ( serviceRegistry . getRequiredService ( EJBUtilities . SERVICE _ NAME )  . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["utilities"], "fileName": "org.jboss.as.ejb3.subsystem.StatisticsEnabledWriteHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   dsNode    =    StrictMaxPoolResourceDefinition . DERIVE _ SIZE . resolveModelAttribute ( context ,    strictMaxPoolModel )  ;", "if    ( dsNode . isDefined (  )  )     {", "StrictMaxPoolResourceDefinition . DeriveSize   deriveSize    =    StrictMaxPoolResourceDefinition . DeriveSize . fromValue ( dsNode . asString (  )  )  ;", "switch    ( deriveSize )     {", "case   FROM _ WORKER _ POOLS    :", "return   StrictMaxPoolConfigService . Derive . FROM _ WORKER _ POOLS ;", "case   FROM _ CPU _ COUNT    :", "return   StrictMaxPoolConfigService . Derive . FROM _ CPU _ COUNT ;", "}", "}", "return   StrictMaxPoolConfigService . Derive . NONE ;", "}", "METHOD_END"], "methodName": ["parseDeriveSize"], "fileName": "org.jboss.as.ejb3.subsystem.StrictMaxPoolResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   String   poolName    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  . getLastElement (  )  . getValue (  )  ;", "final   ServiceName   serviceName    =    ConfigService . EJB _ POOL _ CONFIG _ BASE _ SERVICE _ NAME . append ( poolName )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "ServiceController <  ?  >    sc    =    registry . getService ( serviceName )  ;", "if    ( sc    !  =    null )     {", "ConfigService   smpc    =     (  ( ConfigService )     ( sc . getService (  )  )  )  ;", "if    ( smpc    !  =    null )     {", "if    ( ResourceDefinition . MAX _ POOL _ SIZE . getName (  )  . equals ( attributeName )  )     {", "int   maxPoolSize    =    ResourceDefinition . MAX _ POOL _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  (  -  1  )  )  ;", "smpc . setMaxPoolSize ( maxPoolSize )  ;", "} else", "if    ( ResourceDefinition . DERIVE _ SIZE . getName (  )  . equals ( attributeName )  )     {", "ConfigService . Derive   derive    =    ResourceDefinition . parseDeriveSize ( context ,    model )  ;", "smpc . setDerive ( derive )  ;", "} else", "if    ( ResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT . getName (  )  . equals ( attributeName )  )     {", "long   timeout    =    ResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "smpc . setTimeout ( timeout )  ;", "} else", "if    ( ResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT . getName (  )  . equals ( attributeName )  )     {", "String   timeoutUnit    =    ResourceDefinition . INSTANCE _ ACQUISITION _ TIMEOUT _ UNIT . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "smpc . setTimeoutUnit ( valueOf ( timeoutUnit )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["applyModelToRuntime"], "fileName": "org.jboss.as.ejb3.subsystem.StrictMaxPoolWriteHandler"}, {"methodBody": ["METHOD_START", "{", "final   String   defaultDataStore    =    TimerServiceResourceDefinition . DEFAULT _ DATA _ STORE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   threadPoolName    =    TimerServiceResourceDefinition . THREAD _ POOL _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ServiceName   threadPoolServiceName    =    EJB 3 SubsystemModel . BASE _ THREAD _ POOL _ SERVICE _ NAME . append ( threadPoolName )  ;", "context . addStep ( new   AbstractDeploymentChainStep (  )     {", "protected   void   execute ( DeploymentProcessorTarget   processorTarget )     {", "EjbLogger . ROOT _ LOGGER . debug (  \" Configuring   timers \"  )  ;", "processorTarget . addDeploymentProcessor ( EJB 3 Extension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ TIMEOUT _ ANNOTATION ,    new   TimerServiceAnnotationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EJB 3 Extension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ AROUNDTIMEOUT _ ANNOTATION ,    new   AroundTimeoutAnnotationParsingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EJB 3 Extension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ EJB _ TIMER _ METADATA _ MERGE ,    new   TimerMethodMergingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EJB 3 Extension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ EJB _ TIMER _ SERVICE ,    new   TimerServiceDeploymentProcessor ( threadPoolServiceName ,    defaultDataStore )  )  ;", "}", "}  ,    RUNTIME )  ;", "context . getServiceTarget (  )  . addService ( TimerServiceDeploymentProcessor . TIMER _ SERVICE _ NAME ,    new    . TimerValueService (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["performBoottime"], "fileName": "org.jboss.as.ejb3.subsystem.TimerServiceAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attr    :    TimerServiceResourceDefinition . ATTRIBUTES . values (  )  )     {", "attr . validateAndSet ( operation ,    timerServiceModel )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.ejb3.subsystem.TimerServiceAdd"}, {"methodBody": ["METHOD_START", "{", "throw   AbstractEJBComponentRuntimeHandler . unknownOperation ( opName )  ;", "}", "METHOD_END"], "methodName": ["executeAgainstComponent"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "final   boolean   hasPool    =    componentType . hasPool (  )  ;", "if    ( esourceDefinition . COMPONENT _ CLASS _ NAME . getName (  )  . equals ( attributeName )  )     {", "context . getResult (  )  . set ( component . getComponentName (  )  )  ;", "} else", "if    ( esourceDefinition . SECURITY _ DOMAIN . getName (  )  . equals ( attributeName )  )     {", "final   ModelNode   result    =    context . getResult (  )  ;", "EJBSecurityMetaData   md    =    component . getSecurityMetaData (  )  ;", "if    (  ( md    !  =    null )     &  &     (  ( md . getSecurityDomain (  )  )     !  =    null )  )     {", "result . set ( md . getSecurityDomain (  )  )  ;", "}", "} else", "if    ( esourceDefinition . RUN _ AS _ ROLE . getName (  )  . equals ( attributeName )  )     {", "final   ModelNode   result    =    context . getResult (  )  ;", "EJBSecurityMetaData   md    =    component . getSecurityMetaData (  )  ;", "if    (  ( md    !  =    null )     &  &     (  ( md . getRunAs (  )  )     !  =    null )  )     {", "result . set ( md . getRunAs (  )  )  ;", "}", "} else", "if    ( esourceDefinition . DECLARED _ ROLES . getName (  )  . equals ( attributeName )  )     {", "final   ModelNode   result    =    context . getResult (  )  ;", "EJBSecurityMetaData   md    =    component . getSecurityMetaData (  )  ;", "if    ( md    !  =    null )     {", "result . setEmptyList (  )  ;", "Set < String >    roles    =    md . getDeclaredRoles (  )  ;", "if    ( roles    !  =    null )     {", "for    ( String   role    :    roles )     {", "result . add ( role )  ;", "}", "}", "}", "} else", "if    (  ( componentType . hasTimer (  )  )     &  &     ( TimerAttributeDefinition . INSTANCE . getName (  )  . equals ( attributeName )  )  )     {", "TimerAttributeDefinition . addTimers ( component ,    context . getResult (  )  )  ;", "} else", "if    ( hasPool    &  &     ( esourceDefinition . POOL _ AVAILABLE _ COUNT . getName (  )  . equals ( attributeName )  )  )     {", "final   Pool <  ?  >    pool    =    componentType . getPool ( component )  ;", "final   ModelNode   result    =    context . getResult (  )  ;", "if    ( pool    !  =    null )     {", "result . set ( pool . getAvailableCount (  )  )  ;", "}", "} else", "if    ( hasPool    &  &     ( esourceDefinition . POOL _ CREATE _ COUNT . getName (  )  . equals ( attributeName )  )  )     {", "final   Pool <  ?  >    pool    =    componentType . getPool ( component )  ;", "final   ModelNode   result    =    context . getResult (  )  ;", "if    ( pool    !  =    null )     {", "result . set ( pool . getCreateCount (  )  )  ;", "}", "} else", "if    ( hasPool    &  &     ( esourceDefinition . POOL _ NAME . getName (  )  . equals ( attributeName )  )  )     {", "final   String   poolName    =    componentType . pooledComponent ( component )  . getPoolName (  )  ;", "final   ModelNode   result    =    context . getResult (  )  ;", "if    ( poolName    !  =    null )     {", "result . set ( poolName )  ;", "}", "} else", "if    ( hasPool    &  &     ( esourceDefinition . POOL _ REMOVE _ COUNT . getName (  )  . equals ( attributeName )  )  )     {", "final   Pool <  ?  >    pool    =    componentType . getPool ( component )  ;", "final   ModelNode   result    =    context . getResult (  )  ;", "if    ( pool    !  =    null )     {", "result . set ( pool . getRemoveCount (  )  )  ;", "}", "} else", "if    ( hasPool    &  &     ( esourceDefinition . POOL _ CURRENT _ SIZE . getName (  )  . equals ( attributeName )  )  )     {", "final   Pool <  ?  >    pool    =    componentType . getPool ( component )  ;", "final   ModelNode   result    =    context . getResult (  )  ;", "if    ( pool    !  =    null )     {", "result . set ( pool . getCurrentSize (  )  )  ;", "}", "} else", "if    ( hasPool    &  &     ( esourceDefinition . POOL _ MAX _ SIZE . getName (  )  . equals ( attributeName )  )  )     {", "final   Pool <  ?  >    pool    =    componentType . getPool ( component )  ;", "final   ModelNode   result    =    context . getResult (  )  ;", "if    ( pool    !  =    null )     {", "result . set ( pool . getMaxSize (  )  )  ;", "}", "} else    {", "throw   unknownAttribute ( attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["executeReadAttribute"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( componentType . hasPool (  )  )     &  &     ( AbstractEJBComponentResourceDefinition . POOL _ MAX _ SIZE . getName (  )  . equals ( attributeName )  )  )     {", "int   newSize    =    AbstractEJBComponentResourceDefinition . POOL _ MAX _ SIZE . resolveValue ( context ,    operation . get ( VALUE )  )  . asInt (  )  ;", "final   Pool <  ?  >    pool    =    componentType . getPool ( component )  ;", "final   int   oldSize    =    pool . getMaxSize (  )  ;", "componentType . getPool ( component )  . setMaxSize ( newSize )  ;", "context . completeStep ( new   OperationContext . RollbackHandler (  )     {", "@ Override", "public   void   handleRollback ( OperationContext   context ,    ModelNode   operation )     {", "pool . setMaxSize ( oldSize )  ;", "}", "}  )  ;", "} else    {", "throw   EjbLogger . ROOT _ LOGGER . unknownAttribute ( attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["executeWriteAttribute"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  ;", "final   ServiceName   serviceName    =    getConfiguration ( context ,    address )  ;", "T   component    =    get ( serviceName ,    address ,    context ,    false )  ;", "return   component ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   registry    =    context . getServiceRegistry ( forWrite )  ;", "ServiceController <  ?  >    controller    =    registry . getService ( serviceName )  ;", "if    ( controller    =  =    null )     {", "String   exceptionMessage    =    EjbLogger . ROOT _ LOGGER . noAvailableForAddress ( operationAddress )  ;", "throw   new   OperationFailedException ( exceptionMessage )  ;", "}", "ServiceController . State   controllerState    =    controller . getState (  )  ;", "if    ( controllerState    !  =     ( State . UP )  )     {", "String   exceptionMessage    =    EjbLogger . ROOT _ LOGGER . invalidState ( operationAddress ,    controllerState ,    UP )  ;", "throw   new   OperationFailedException ( exceptionMessage )  ;", "}", "return   componentClass . cast ( controller . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "final   List < PathElement >    relativeAddress    =    new   ArrayList < PathElement >  (  )  ;", "final   String   typeKey    =    this . componentType . getResourceType (  )  ;", "boolean   skip    =    true ;", "for    ( int   i    =     ( operationAddress . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "PathElement   pe    =    operationAddress . getElement ( i )  ;", "if    ( skip    &  &     (  !  ( pe . getKey (  )  . equals ( typeKey )  )  )  )     {", "continue ;", "} else    {", "skip    =    false ;", "}", "if    ( DEPLOYMENT . equals ( pe . getKey (  )  )  )     {", "final   String   runtimName    =    resolveRuntimeName ( context ,    pe )  ;", "PathElement   realPe    =    PathElement . pathElement ( pe . getKey (  )  ,    runtimName )  ;", "relativeAddress . add (  0  ,    realPe )  ;", "break ;", "} else    {", "relativeAddress . add (  0  ,    pe )  ;", "}", "}", "final   PathAddress   pa    =    PathAddress . pathAddress ( relativeAddress )  ;", "final   ServiceName   config    =    componentConfigs . get ( pa )  ;", "if    ( config    =  =    null )     {", "String   exceptionMessage    =    EjbLogger . ROOT _ LOGGER . noegisteredForAddress ( operationAddress )  ;", "throw   new   OperationFailedException ( exceptionMessage )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["getComponentConfiguration"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( WRITE _ ATTRIBUTE _ OPERATION . equals ( opName )  )     {", "return   true ;", "} else", "if    ( ModelDescriptionConstants . READ _ ATTRIBUTE _ OPERATION . equals ( opName )  )     {", "return   false ;", "} else    {", "return    !  ( isOperationReadOnly ( opName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isForWrite"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "throw   AbstractEJBComponentRuntimeHandler . unknownOperation ( opName )  ;", "}", "METHOD_END"], "methodName": ["isOperationReadOnly"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "componentConfigs . put ( address ,    serviceName )  ;", "}", "METHOD_END"], "methodName": ["registerComponent"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   runtimeName    =    context . readResourceFromRoot ( PathAddress . pathAddress ( address )  ,    false )  . getModel (  )  . get ( RUNTIME _ NAME )  ;", "return   runtimeName . asString (  )  ;", "}", "METHOD_END"], "methodName": ["resolveRuntimeName"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . unknownOperations ( opName )  ;", "}", "METHOD_END"], "methodName": ["unknownOperation"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "componentConfigs . remove ( address )  ;", "}", "METHOD_END"], "methodName": ["unregisterComponent"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractEJBComponentRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  ;", "final   String   parent ;", "final   String   module ;", "int   i    =     2  ;", "if    ( address . getElement (  1  )  . getKey (  )  . equals ( SUBDEPLOYMENT )  )     {", "parent    =     . resolveRuntimeName ( context ,    address . getElement (  0  )  )  ;", "module    =    address . getElement (  1  )  . getValue (  )  ;", "i +  +  ;", "} else    {", "parent    =    null ;", "module    =     . resolveRuntimeName ( context ,    address . getElement (  0  )  )  ;", "}", "final   String   component    =    address . getElement ( i )  . getValue (  )  ;", "final   ServiceName   deploymentUnitServiceName ;", "if    ( parent    =  =    null )     {", "deploymentUnitServiceName    =    Services . deploymentUnitName ( module )  ;", "} else    {", "deploymentUnitServiceName    =    Services . deploymentUnitName ( parent ,    module )  ;", "}", "return   BasicComponent . serviceNameOf ( deploymentUnitServiceName ,    component )  . append (  \" START \"  )  ;", "}", "METHOD_END"], "methodName": ["componentServiceName"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractRuntimeMetricsHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   runtimeName    =    context . readResourceFromRoot ( PathAddress . pathAddress ( address )  ,    false )  . getModel (  )  . get ( RUNTIME _ NAME )  ;", "return   runtimeName . asString (  )  ;", "}", "METHOD_END"], "methodName": ["resolveRuntimeName"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.AbstractRuntimeMetricsHandler"}, {"methodBody": ["METHOD_START", "{", "return   componentClass ;", "}", "METHOD_END"], "methodName": ["getComponentClass"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "return   componentDescriptionClass ;", "}", "METHOD_END"], "methodName": ["getComponentDescriptionClass"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "final   ComponentDescription   description    =    componentConfiguration . getComponentDescription (  )  ;", "type    =     . typeByDescriptionClass . get ( description . getClass (  )  )  ;", "if    ( type    !  =    null )     {", "return   type ;", "}", "for    ( Map . Entry < Class <  ?  >  ,     >    entry    :     . typeByDescriptionClass . entrySet (  )  )     {", "if    ( entry . getKey (  )  . isAssignableFrom ( description . getClass (  )  )  )     {", "return   entry . getValue (  )  ;", "}", "}", "throw   EjbLogger . ROOT _ LOGGER . unknownComponentDescriptionType ( description . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "return   pooledComponent ( component )  . getPool (  )  ;", "}", "METHOD_END"], "methodName": ["getPool"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "return   resourceType ;", "}", "METHOD_END"], "methodName": ["getResourceType"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "case   MESSAGE _ DRIVEN    :", "return   MessageDrivenBeanRuntimeHandler . INSTANCE ;", "case   SINGLETON    :", "return   SingletonBeanRuntimeHandler . INSTANCE ;", "case   STATELESS    :", "return   StatelessSessionBeanRuntimeHandler . INSTANCE ;", "case   STATEFUL    :", "return   StatefulSessionBeanRuntimeHandler . INSTANCE ;", "default    :", "throw   EjbLogger . ROOT _ LOGGER . unknown ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["getRuntimeHandler"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "ce   STATEFUL    :", "ce   SINGLETON    :", "return   false ;", "default    :", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["hasPool"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "ce   STATELESS    :", "ce   SINGLETON    :", "ce   MESSAGE _ DRIVEN    :", "return   true ;", "default    :", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["hasTimer"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "case   MESSAGE _ DRIVEN    :", "return   MessageDrivenComponent . class . cast ( component )  ;", "case   STATELESS    :", "return   StatelessSessionComponent . class . cast ( component )  ;", "case   SINGLETON    :", "case   STATEFUL    :", "throw   EjbLogger . ROOT _ LOGGER . invalid ( this . getComponentClass (  )  . getSimpleName (  )  )  ;", "default    :", "throw   EjbLogger . ROOT _ LOGGER . unknown ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["pooledComponent"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.EJBComponentType"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.InstalledComponent"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.InstalledComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( MessageDrivenBeanResourceDefinition . START _ DELIVERY . equals ( opName )  )     |  |     ( MessageDrivenBeanResourceDefinition . STOP _ DELIVERY . equals ( opName )  )  )     {", "return   false ;", "}", "return   super . isOperationReadOnly ( opName )  ;", "}", "METHOD_END"], "methodName": ["isOperationReadOnly"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.MessageDrivenBeanRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   valNode    =    node . get ( suffixes [  (  ( suffixes . length )     -     1  )  ]  )  ;", "valNode . get ( DESCRIPTION )  . set ( resolver . getResourceValueTypeDescription ( getName (  )  ,    locale ,    bundle ,    suffixes )  )  ;", "valNode . get ( TYPE )  . set ( type )  ;", "valNode . get ( NILLABLE )  . set ( nillable )  ;", "if    ( measurementUnit    !  =    null )     {", "valNode . get ( UNIT )  . set ( measurementUnit . getName (  )  )  ;", "}", "return   valNode ;", "}", "METHOD_END"], "methodName": ["addAttributeDescription"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ModelNode   detailNode    =    timerNode . get (  . CALENDAR _ TIMER )  ;", "boolean   b    =    timer . isCalendarTimer (  )  ;", "detailNode . set ( b )  ;", "}    catch    ( IllegalStateException   e )     {", "}    catch    ( NoSuchObjectLocalException   e )     {", "}    catch    ( EJBException   e )     {", ". logTimerFailure ( componentName ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["addCalendarTimer"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ModelNode   detailNode    =    timerNode . get (  . NEXT _ TIMEOUT )  ;", "Date   d    =    timer . getNextTimeout (  )  ;", "if    ( d    !  =    null )     {", "detailNode . set ( d . getTime (  )  )  ;", "}", "}    catch    ( IllegalStateException   e )     {", "}    catch    ( NoSuchObjectLocalException   e )     {", "}    catch    ( EJBException   e )     {", ". logTimerFailure ( componentName ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["addNextTimeout"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ModelNode   detailNode    =    timerNode . get (  . PERSISTENT )  ;", "boolean   b    =    timer . isPersistent (  )  ;", "detailNode . set ( b )  ;", "}    catch    ( IllegalStateException   e )     {", "}    catch    ( NoSuchObjectLocalException   e )     {", "}    catch    ( EJBException   e )     {", ". logTimerFailure ( componentName ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["addPersistent"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ModelNode   schedNode    =    timerNode . get (  . SCHEDULE )  ;", "ScheduleExpression   sched    =    timer . getSchedule (  )  ;", ". addScheduleDetailString ( schedNode ,    sched . getYear (  )  ,     . YEAR )  ;", ". addScheduleDetailString ( schedNode ,    sched . getMonth (  )  ,     . MONTH )  ;", ". addScheduleDetailString ( schedNode ,    sched . getDayOfMonth (  )  ,     . DAY _ OF _ MONTH )  ;", ". addScheduleDetailString ( schedNode ,    sched . getDayOfWeek (  )  ,     . DAY _ OF _ WEEK )  ;", ". addScheduleDetailString ( schedNode ,    sched . getHour (  )  ,     . HOUR )  ;", ". addScheduleDetailString ( schedNode ,    sched . getMinute (  )  ,     . MINUTE )  ;", ". addScheduleDetailString ( schedNode ,    sched . getSecond (  )  ,     . SECOND )  ;", ". addScheduleDetailString ( schedNode ,    sched . getTimezone (  )  ,     . TIMEZONE )  ;", ". addScheduleDetailDate ( schedNode ,    sched . getStart (  )  ,     . START )  ;", ". addScheduleDetailDate ( schedNode ,    sched . getEnd (  )  ,     . END )  ;", "}    catch    ( IllegalStateException   e )     {", "}    catch    ( NoSuchObjectLocalException   e )     {", "}    catch    ( EJBException   e )     {", ". logTimerFailure ( componentName ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["addSchedule"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   node    =    schedNode . get ( detailName )  ;", "if    ( value    !  =    null )     {", "node . set ( value . get (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addScheduleDetailDate"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   node    =    schedNode . get ( detailName )  ;", "if    ( value    !  =    null )     {", "node . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["addScheduleDetailString"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ModelNode   detailNode    =    timerNode . get (  . TIME _ REMAINING )  ;", "long   time    =    timer . getTimeRemaining (  )  ;", "detailNode . set ( time )  ;", "}    catch    ( IllegalStateException   e )     {", "}    catch    ( NoSuchObjectLocalException   e )     {", "}    catch    ( EJBException   e )     {", ". logTimerFailure ( componentName ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["addTimeRemaining"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "response . setEmptyList (  )  ;", "final   String   name    =    ejb . getComponentName (  )  ;", "TimerService   ts    =    ejb . getTimerService (  )  ;", "if    ( ts    !  =    null )     {", "for    ( Timer   timer    :    ts . getTimers (  )  )     {", "ModelNode   timerNode    =    response . add (  )  ;", ". addTimeRemaining ( timer ,    timerNode ,    name )  ;", ". addNextTimeout ( timer ,    timerNode ,    name )  ;", ". addCalendarTimer ( timer ,    timerNode ,    name )  ;", ". addPersistent ( timer ,    timerNode ,    name )  ;", ". addSchedule ( timer ,    timerNode ,    name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addTimers"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   valueTypeNode    =    node . get ( VALUE _ TYPE )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    valueTypeNode ,    LONG ,    true ,    MILLISECONDS ,     . TIME _ REMAINING )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    valueTypeNode ,    LONG ,    true ,    EPOCH _ MILLISECONDS ,     . NEXT _ TIMEOUT )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    valueTypeNode ,    BOOLEAN ,    true ,    null ,     . CALENDAR _ TIMER )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    valueTypeNode ,    BOOLEAN ,    true ,    null ,     . PERSISTENT )  ;", "final   ModelNode   sched    =    addAttributeDescription ( resolver ,    locale ,    bundle ,    valueTypeNode ,    OBJECT ,    true ,    null ,     . SCHEDULE )  ;", "final   ModelNode   schedValType    =    sched . get ( VALUE _ TYPE )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . YEAR )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . MONTH )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . DAY _ OF _ MONTH )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . DAY _ OF _ WEEK )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . HOUR )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . MINUTE )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . SECOND )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    STRING ,    true ,    null ,     . SCHEDULE ,     . TIMEZONE )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    LONG ,    true ,    EPOCH _ MILLISECONDS ,     . SCHEDULE ,     . START )  ;", "addAttributeDescription ( resolver ,    locale ,    bundle ,    schedValType ,    LONG ,    true ,    EPOCH _ MILLISECONDS ,     . SCHEDULE ,     . END )  ;", "}", "METHOD_END"], "methodName": ["addValueTypeDescription"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "EjbLogger . ROOT _ LOGGER . failToReadTimerInformation ( componentName )  ;", "}", "METHOD_END"], "methodName": ["logTimerFailure"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerAttributeDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getChild ( element )  ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getChildTypes (  )  ;", "}", "METHOD_END"], "methodName": ["getChildTypes"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getChildren ( childType )  ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getChildrenNames ( childType )  ;", "}", "METHOD_END"], "methodName": ["getChildrenNames"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getModel (  )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . hasChild ( element )  ;", "}", "METHOD_END"], "methodName": ["hasChild"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . hasChildren ( childType )  ;", "}", "METHOD_END"], "methodName": ["hasChildren"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . isModelDefined (  )  ;", "}", "METHOD_END"], "methodName": ["isModelDefined"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . isProxy (  )  ;", "}", "METHOD_END"], "methodName": ["isProxy"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . isRuntime (  )  ;", "}", "METHOD_END"], "methodName": ["isRuntime"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . navigate ( address )  ;", "}", "METHOD_END"], "methodName": ["navigate"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "delegate . registerChild ( address ,    resource )  ;", "}", "METHOD_END"], "methodName": ["registerChild"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . removeChild ( address )  ;", "}", "METHOD_END"], "methodName": ["removeChild"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "return   delegate . requireChild ( element )  ;", "}", "METHOD_END"], "methodName": ["requireChild"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "PathElement   address    =    PathElement . pathElement ( EJB 3 SubsystemModel . TIMER ,    id )  ;", "this . delegate . registerChild ( address ,    Factory . create (  )  )  ;", "}", "METHOD_END"], "methodName": ["timerCreated"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "PathElement   address    =    PathElement . pathElement ( EJB 3 SubsystemModel . TIMER ,    id )  ;", "this . delegate . removeChild ( address )  ;", "}", "METHOD_END"], "methodName": ["timerRemoved"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "delegate . writeModel ( newModel )  ;", "}", "METHOD_END"], "methodName": ["writeModel"], "fileName": "org.jboss.as.ejb3.subsystem.deployment.TimerServiceResource"}, {"methodBody": ["METHOD_START", "{", "if    ( suspended )     {", "if    (  !  ( gracefulTxnShutdown )  )", "return   false ;", "if    (  (  (  . listenerUpdater . get ( this )  )     =  =    null )     |  |     (  (  . activeTransactionCountUpdater . get ( this )  )     =  =     0  )  )", "return   false ;", "if    (  !  ( context . hasTransaction (  )  )  )     {", "return   false ;", "}", "}", ". activeInvocationCountUpdater . incrementAndGet ( this )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["acceptInvocation"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "int   activeTransactionCount    =    EJBSuspendHandlerService . activeTransactionCountUpdater . decrementAndGet ( this )  ;", "if    (  (  ( suspended )     &  &     ( activeTransactionCount    =  =     0  )  )     &  &     (  ( EJBSuspendHandlerService . activeInvocationCountUpdater . get ( this )  )     =  =     0  )  )     {", "doneSuspended (  )  ;", "}", "}", "METHOD_END"], "methodName": ["decrementTransactionCount"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "final   ServerActivityCallback   oldListener    =    listener ;", "if    (  ( oldListener    !  =    null )     &  &     (  . listenerUpdater . compareAndSet ( this ,    oldListener ,    null )  )  )     {", "deploymentRepositoryInjectedValue . getValue (  )  . suspend (  )  ;", "oldListener . done (  )  ;", "EjbLogger . ROOT _ LOGGER . suspensionComplete (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doneSuspended"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "this . gracefulTxnShutdown    =    gracefulTxnShutdown ;", "}", "METHOD_END"], "methodName": ["enableGracefulTxnShutdown"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentRepositoryInjectedValue ;", "}", "METHOD_END"], "methodName": ["getDeploymentRepositoryInjectedValue"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "return   localTransactionContextInjectedValue ;", "}", "METHOD_END"], "methodName": ["getLocalTransactionContextInjectedValue"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "return   suspendControllerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getSuspendControllerInjectedValue"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "int   activeInvocations    =    EJBSuspendHandlerService . activeInvocationCountUpdater . decrementAndGet ( this )  ;", "if    (  (  ( suspended )     &  &     ( activeInvocations    =  =     0  )  )     &  &     (  (  !  ( gracefulTxnShutdown )  )     |  |     (  ( EJBSuspendHandlerService . activeTransactionCountUpdater . get ( this )  )     =  =     0  )  )  )     {", "doneSuspended (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invocationComplete"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "return   suspended ;", "}", "METHOD_END"], "methodName": ["isSuspended"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "final   SuspendController   suspendController    =    suspendControllerInjectedValue . getValue (  )  ;", "suspendController . registerActivity ( this )  ;", "final   LocalTransactionContext   localTransactionContext    =    localTransactionContextInjectedValue . getValue (  )  ;", "localTransactionContext . registerCreationListener ( this )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "final   SuspendController   suspendController    =    suspendControllerInjectedValue . getValue (  )  ;", "suspendController . unRegisterActivity ( this )  ;", "final   LocalTransactionContext   localTransactionContext    =    localTransactionContextInjectedValue . getValue (  )  ;", "localTransactionContext . removeCreationListener ( this )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ejb3.suspend.EJBSuspendHandlerService"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   scheduleExpression    =    new   ScheduleExpression (  )  . timezone ( this . timezone . getID (  )  )  ;", "GregorianCalendar   start    =    new   GregorianCalendar ( this . timezone )  ;", "start . clear (  )  ;", "start . set (  2  0  1  4  ,     0  ,     1  ,     1  ,     0  ,     0  )  ;", "return   scheduleExpression . start ( start . getTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTimezoneSpecificScheduleExpression"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "String [  ]    candidates    =    TimeZone . getAvailableIDs (  )  ;", "List < TimeZone >    timeZones    =    new   ArrayList < TimeZone >  ( candidates . length )  ;", "for    ( String   timezoneID    :    candidates )     {", "TimeZone   timeZone    =    TimeZone . getTimeZone ( timezoneID )  ;", "boolean   different    =    true ;", "for    ( int   i    =     ( timeZones . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "TimeZone   testee    =    timeZones . get ( i )  ;", "if    ( testee . hasSameRules ( timeZone )  )     {", "different    =    false ;", "break ;", "}", "}", "if    ( different )     {", "timeZones . add ( timeZone )  ;", "}", "}", "return   timeZones ;", "}", "METHOD_END"], "methodName": ["getTimezones"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "int   year    =    cal . get ( Calendar . YEAR )  ;", "return    ( year    %     4  )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isLeapYear"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "int   dayOfWeek    =    cal . get ( Calendar . DAY _ OF _ WEEK )  ;", "switch    ( dayOfWeek )     {", "case   Calendar . SATURDAY    :", "case   Calendar . SUNDAY    :", "return   false ;", "default    :", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["isWeekDay"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( TimeZone   tz    :    CalendarBasedTimeoutTestCase . getTimezones (  )  )     {", "this . timezone    =    tz ;", "this . timeZoneDisplayName    =    this . timezone . getDisplayName (  )  ;", "testEverySecondTimeout (  )  ;", "testEveryMinuteEveryHourEveryDay (  )  ;", "testEveryMorningFiveFifteen (  )  ;", "testEveryWeekdayEightFifteen (  )  ;", "testEveryMonWedFriTwelveThirtyNoon (  )  ;", "testEvery 3  1 stOfTheMonth (  )  ;", "testRun 2  9 thOfFeb (  )  ;", "testSomeSpecificTime (  )  ;", "testEvery 1  0 Seconds (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCalendarBasedTimeout"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "Calendar   start    =    new   GregorianCalendar ( TimeZone . getTimeZone (  \" Europe / Berlin \"  )  )  ;", "start . clear (  )  ;", "start . set (  2  0  1  7  ,    Calendar . OCTOBER ,     2  9  ,     1  ,     3  0  ,     0  )  ;", "ScheduleExpression   schedule    =    new   ScheduleExpression (  )  ;", "schedule . hour (  \"  *  \"  )  . minute (  \"  5  /  1  5  \"  )  . second (  \"  0  \"  )  . timezone (  \" Europe / Berlin \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( schedule )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "if    (  (  (  (  (  (  (  ( firstTimeout . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( firstTimeout . get ( Calendar . MONTH )  )     !  =     ( Calendar . OCTOBER )  )  )     |  |     (  ( firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     2  9  )  )     |  |     (  ( firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     1  )  )     |  |     (  ( firstTimeout . get ( Calendar . MINUTE )  )     !  =     3  5  )  )     |  |     (  ( firstTimeout . get ( Calendar . SECOND )  )     !  =     0  )  )     |  |     (  ( firstTimeout . get ( Calendar . DST _ OFFSET )  )     !  =     3  6  0  0  0  0  0  )  )     {", "Assert . fail (  (  \" Start   time   unexpected    :     \"     +     ( firstTimeout . toString (  )  )  )  )  ;", "}", "Calendar   current    =    firstTimeout ;", "for    ( int   i    =     0  ;    i    <     7  ;    i +  +  )     {", "Calendar   next    =    calendarTimeout . getNextTimeout ( current )  ;", "if    (  ( current . getTimeInMillis (  )  )     !  =     (  ( next . getTimeInMillis (  )  )     -     9  0  0  0  0  0  )  )     {", "Assert . fail (  (  (  (  \" Schedule   is   more   than    1  5    minutes   from    \"     +     ( current . getTime (  )  )  )     +     \"    to    \"  )     +     ( next . getTime (  )  )  )  )  ;", "}", "current    =    next ;", "}", "if    (  (  (  (  (  (  ( current . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( current . get ( Calendar . MONTH )  )     !  =     ( Calendar . OCTOBER )  )  )     |  |     (  ( current . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     2  9  )  )     |  |     (  ( current . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     2  )  )     |  |     (  ( current . get ( Calendar . MINUTE )  )     !  =     2  0  )  )     |  |     (  ( current . get ( Calendar . DST _ OFFSET )  )     !  =     0  )  )     {", "Assert . fail (  (  \" End   time   unexpected    :     \"     +     ( current . toString (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testChangeCEST2CET"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "Calendar   start    =    new   GregorianCalendar ( TimeZone . getTimeZone (  \" Europe / Berlin \"  )  )  ;", "start . clear (  )  ;", "start . set (  2  0  1  7  ,    Calendar . MARCH ,     2  6  ,     1  ,     3  0  ,     0  )  ;", "ScheduleExpression   schedule    =    new   ScheduleExpression (  )  ;", "schedule . hour (  \"  *  \"  )  . minute (  \"  0  /  1  5  \"  )  . second (  \"  0  \"  )  . timezone (  \" Europe / Berlin \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( schedule )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "if    (  (  (  (  (  (  (  ( firstTimeout . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( firstTimeout . get ( Calendar . MONTH )  )     !  =     ( Calendar . MARCH )  )  )     |  |     (  ( firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     2  6  )  )     |  |     (  ( firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     1  )  )     |  |     (  ( firstTimeout . get ( Calendar . MINUTE )  )     !  =     3  0  )  )     |  |     (  ( firstTimeout . get ( Calendar . SECOND )  )     !  =     0  )  )     |  |     (  ( firstTimeout . get ( Calendar . DST _ OFFSET )  )     !  =     0  )  )     {", "Assert . fail (  (  \" Start   time   unexpected    :     \"     +     ( firstTimeout . toString (  )  )  )  )  ;", "}", "Calendar   current    =    firstTimeout ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "Calendar   next    =    calendarTimeout . getNextTimeout ( current )  ;", "if    (  ( current . getTimeInMillis (  )  )     !  =     (  ( next . getTimeInMillis (  )  )     -     9  0  0  0  0  0  )  )     {", "Assert . fail (  (  (  (  \" Schedule   is   more   than    1  5    minutes   from    \"     +     ( current . getTime (  )  )  )     +     \"    to    \"  )     +     ( next . getTime (  )  )  )  )  ;", "}", "current    =    next ;", "}", "if    (  (  (  (  (  (  ( current . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( current . get ( Calendar . MONTH )  )     !  =     ( Calendar . MARCH )  )  )     |  |     (  ( current . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     2  6  )  )     |  |     (  ( current . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     3  )  )     |  |     (  ( current . get ( Calendar . MINUTE )  )     !  =     1  5  )  )     |  |     (  ( current . get ( Calendar . DST _ OFFSET )  )     !  =     3  6  0  0  0  0  0  )  )     {", "Assert . fail (  (  \" End   time   unexpected    :     \"     +     ( current . toString (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testChangeCET2CEST"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "Calendar   start    =    new   GregorianCalendar ( TimeZone . getTimeZone (  \" America / Los _ Angeles \"  )  )  ;", "start . clear (  )  ;", "start . set (  2  0  1  7  ,    Calendar . MARCH ,     1  2  ,     1  ,     3  0  ,     0  )  ;", "ScheduleExpression   schedule    =    new   ScheduleExpression (  )  ;", "schedule . hour (  \"  *  \"  )  . minute (  \"  0  /  1  5  \"  )  . second (  \"  0  \"  )  . timezone (  \" America / Los _ Angeles \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( schedule )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "if    (  (  (  (  (  (  (  ( firstTimeout . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( firstTimeout . get ( Calendar . MONTH )  )     !  =     ( Calendar . MARCH )  )  )     |  |     (  ( firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     1  2  )  )     |  |     (  ( firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     1  )  )     |  |     (  ( firstTimeout . get ( Calendar . MINUTE )  )     !  =     3  0  )  )     |  |     (  ( firstTimeout . get ( Calendar . SECOND )  )     !  =     0  )  )     |  |     (  ( firstTimeout . get ( Calendar . DST _ OFFSET )  )     !  =     0  )  )     {", "Assert . fail (  (  \" Start   time   unexpected    :     \"     +     ( firstTimeout . toString (  )  )  )  )  ;", "}", "Calendar   current    =    firstTimeout ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "Calendar   next    =    calendarTimeout . getNextTimeout ( current )  ;", "if    (  ( current . getTimeInMillis (  )  )     !  =     (  ( next . getTimeInMillis (  )  )     -     9  0  0  0  0  0  )  )     {", "Assert . fail (  (  (  (  \" Schedule   is   more   than    1  5    minutes   from    \"     +     ( current . getTime (  )  )  )     +     \"    to    \"  )     +     ( next . getTime (  )  )  )  )  ;", "}", "current    =    next ;", "}", "if    (  (  (  (  (  (  ( current . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( current . get ( Calendar . MONTH )  )     !  =     ( Calendar . MARCH )  )  )     |  |     (  ( current . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     1  2  )  )     |  |     (  ( current . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     3  )  )     |  |     (  ( current . get ( Calendar . MINUTE )  )     !  =     1  5  )  )     |  |     (  ( current . get ( Calendar . DST _ OFFSET )  )     !  =     3  6  0  0  0  0  0  )  )     {", "Assert . fail (  (  \" End   time   unexpected    :     \"     +     ( current . toString (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testChangeUS2Summer"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "Calendar   start    =    new   GregorianCalendar ( TimeZone . getTimeZone (  \" America / Los _ Angeles \"  )  )  ;", "start . clear (  )  ;", "start . set (  2  0  1  7  ,    Calendar . NOVEMBER ,     5  ,     0  ,     3  0  ,     0  )  ;", "ScheduleExpression   schedule    =    new   ScheduleExpression (  )  ;", "schedule . hour (  \"  *  \"  )  . minute (  \"  0  /  1  5  \"  )  . second (  \"  0  \"  )  . timezone (  \" America / Los _ Angeles \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( schedule )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "if    (  (  (  (  (  (  (  ( firstTimeout . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( firstTimeout . get ( Calendar . MONTH )  )     !  =     ( Calendar . NOVEMBER )  )  )     |  |     (  ( firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     5  )  )     |  |     (  ( firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     0  )  )     |  |     (  ( firstTimeout . get ( Calendar . MINUTE )  )     !  =     3  0  )  )     |  |     (  ( firstTimeout . get ( Calendar . SECOND )  )     !  =     0  )  )     |  |     (  ( firstTimeout . get ( Calendar . DST _ OFFSET )  )     !  =     3  6  0  0  0  0  0  )  )     {", "Assert . fail (  (  \" Start   time   unexpected    :     \"     +     ( firstTimeout . toString (  )  )  )  )  ;", "}", "Calendar   current    =    firstTimeout ;", "for    ( int   i    =     0  ;    i    <     7  ;    i +  +  )     {", "Calendar   next    =    calendarTimeout . getNextTimeout ( current )  ;", "if    (  ( current . getTimeInMillis (  )  )     !  =     (  ( next . getTimeInMillis (  )  )     -     9  0  0  0  0  0  )  )     {", "Assert . fail (  (  (  (  \" Schedule   is   more   than    1  5    minutes   from    \"     +     ( current . getTime (  )  )  )     +     \"    to    \"  )     +     ( next . getTime (  )  )  )  )  ;", "}", "current    =    next ;", "}", "if    (  (  (  (  (  (  ( current . get ( Calendar . YEAR )  )     !  =     2  0  1  7  )     |  |     (  ( current . get ( Calendar . MONTH )  )     !  =     ( Calendar . NOVEMBER )  )  )     |  |     (  ( current . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     5  )  )     |  |     (  ( current . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     1  )  )     |  |     (  ( current . get ( Calendar . MINUTE )  )     !  =     1  5  )  )     |  |     (  ( current . get ( Calendar . DST _ OFFSET )  )     !  =     0  )  )     {", "Assert . fail (  (  \" End   time   unexpected    :     \"     +     ( current . toString (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testChangeUS2Winter"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "int   year    =     2  0  1  6  ;", "int   month    =    Calendar . JANUARY ;", "int   dayOfMonth    =     1  4  ;", "int   hourOfDay    =     9  ;", "int   minute    =     5  6  ;", "int   second    =     0  ;", "Calendar   start    =    new   GregorianCalendar (  )  ;", "start . clear (  )  ;", "start . set ( year ,    month ,    dayOfMonth ,    hourOfDay ,    minute ,    second )  ;", "ScheduleExpression   expression    =    new   ScheduleExpression (  )  . dayOfMonth (  \"  2  -  1  3  \"  )  . hour (  \"  3  -  9  \"  )  . minute (  \"  0  /  5  \"  )  . second (  \"  0  \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( expression )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "Assert . assertEquals ( year ,    firstTimeout . get ( Calendar . YEAR )  )  ;", "Assert . assertEquals (  1  ,    firstTimeout . get ( Calendar . MONTH )  )  ;", "Assert . assertEquals (  2  ,    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "Assert . assertEquals (  3  ,    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )  ;", "Assert . assertEquals (  0  ,    firstTimeout . get ( Calendar . MINUTE )  )  ;", "Assert . assertEquals (  0  ,    firstTimeout . get ( Calendar . SECOND )  )  ;", "}", "METHOD_END"], "methodName": ["testDayOverflow"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   every 1  0 Secs    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "every 1  0 Secs . second (  \"  *  /  1  0  \"  )  ;", "every 1  0 Secs . minute (  \"  *  \"  )  ;", "every 1  0 Secs . hour (  \"  *  \"  )  ;", "calendarTimeout    =    new    ( every 1  0 Secs )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "int   firstTimeoutSecond    =    firstTimeout . get ( Calendar . SECOND )  ;", "Assert . assertTrue ( timeZoneDisplayName ,     (  ( firstTimeoutSecond    %     1  0  )     =  =     0  )  )  ;", "Calendar   previousTimeout    =    firstTimeout ;", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )     {", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( previousTimeout )  ;", "int   nextTimeoutSecond    =    nextTimeout . get ( Calendar . SECOND )  ;", "Assert . assertTrue ( timeZoneDisplayName ,     (  ( nextTimeoutSecond    %     1  0  )     =  =     0  )  )  ;", "previousTimeout    =    nextTimeout ;", "}", "}", "METHOD_END"], "methodName": ["testEvery10Seconds"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   every 3  1 st 9  _  3  0  _  1  5  _ AM    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "every 3  1 st 9  _  3  0  _  1  5  _ AM . dayOfMonth (  3  1  )  ;", "every 3  1 st 9  _  3  0  _  1  5  _ AM . hour (  9  )  ;", "every 3  1 st 9  _  3  0  _  1  5  _ AM . minute (  \"  3  0  \"  )  ;", "every 3  1 st 9  _  3  0  _  1  5  _ AM . second (  1  5  )  ;", "calendarTimeout    =    new    ( every 3  1 st 9  _  3  0  _  1  5  _ AM )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    firstTimeout )  ;", "int   minute    =    firstTimeout . get ( Calendar . MINUTE )  ;", "int   second    =    firstTimeout . get ( Calendar . SECOND )  ;", "int   hour    =    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   amOrPm    =    firstTimeout . get ( Calendar . AM _ PM )  ;", "int   dayOfMonth    =    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  5  ,    second )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  0  ,    minute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     9  ,    hour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    amOrPm )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  1  ,    dayOfMonth )  ;", "Calendar   previousTimeout    =    firstTimeout ;", "for    ( int   i    =     1  ;    i    <  =     1  8  ;    i +  +  )     {", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( previousTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout . after ( previousTimeout )  )  ;", "int   nextMinute    =    nextTimeout . get ( Calendar . MINUTE )  ;", "int   nextSecond    =    nextTimeout . get ( Calendar . SECOND )  ;", "int   nextHour    =    nextTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   nextAmOrPm    =    nextTimeout . get ( Calendar . AM _ PM )  ;", "int   nextDayOfMonth    =    nextTimeout . get ( Calendar . DAY _ OF _ MONTH )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  5  ,    nextSecond )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  0  ,    nextMinute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     9  ,    nextHour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    nextAmOrPm )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  1  ,    nextDayOfMonth )  ;", "previousTimeout    =    nextTimeout ;", "}", "}", "METHOD_END"], "methodName": ["testEvery31stOfTheMonth"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   everyMinEveryHourEveryDay    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "everyMinEveryHourEveryDay . minute (  \"  *  \"  )  ;", "everyMinEveryHourEveryDay . hour (  \"  *  \"  )  ;", "calendarTimeout    =    new    ( everyMinEveryHourEveryDay )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Calendar   previousTimeout    =    firstTimeout ;", "for    ( int   i    =     1  ;    i    <  =     6  5  ;    i +  +  )     {", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( previousTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout . after ( previousTimeout )  )  ;", "long   diff    =     ( nextTimeout . getTimeInMillis (  )  )     -     ( previousTimeout . getTimeInMillis (  )  )  ;", "long   diffWithFirstTimeout    =     ( nextTimeout . getTimeInMillis (  )  )     -     ( firstTimeout . getTimeInMillis (  )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     (  6  0     *     1  0  0  0  )  ,    diff )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     (  (  6  0     *     1  0  0  0  )     *    i )  ,    diffWithFirstTimeout )  ;", "previousTimeout    =    nextTimeout ;", "}", "}", "METHOD_END"], "methodName": ["testEveryMinuteEveryHourEveryDay"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   everyMonWedFriTwelveThirtyNoon    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "everyMonWedFriTwelveThirtyNoon . hour (  1  2  )  ;", "everyMonWedFriTwelveThirtyNoon . second (  \"  3  0  \"  )  ;", "everyMonWedFriTwelveThirtyNoon . dayOfWeek (  \" Mon , Wed , Fri \"  )  ;", "calendarTimeout    =    new    ( everyMonWedFriTwelveThirtyNoon )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    firstTimeout )  ;", "int   minute    =    firstTimeout . get ( Calendar . MINUTE )  ;", "int   second    =    firstTimeout . get ( Calendar . SECOND )  ;", "int   hour    =    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   amOrPm    =    firstTimeout . get ( Calendar . AM _ PM )  ;", "int   dayOfWeek    =    firstTimeout . get ( Calendar . DAY _ OF _ WEEK )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  0  ,    second )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    minute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  2  ,    hour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . PM ,    amOrPm )  ;", "List < Integer >    validDays    =    new   ArrayList < Integer >  (  )  ;", "validDays . add ( Calendar . MONDAY )  ;", "validDays . add ( Calendar . WEDNESDAY )  ;", "validDays . add ( Calendar . FRIDAY )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    validDays . contains ( dayOfWeek )  )  ;", "Calendar   previousTimeout    =    firstTimeout ;", "for    ( int   i    =     1  ;    i    <  =     1  8  0  ;    i +  +  )     {", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( previousTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout . after ( previousTimeout )  )  ;", "int   nextMinute    =    nextTimeout . get ( Calendar . MINUTE )  ;", "int   nextSecond    =    nextTimeout . get ( Calendar . SECOND )  ;", "int   nextHour    =    nextTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   nextAmOrPm    =    nextTimeout . get ( Calendar . AM _ PM )  ;", "int   nextDayOfWeek    =    nextTimeout . get ( Calendar . DAY _ OF _ WEEK )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  0  ,    nextSecond )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    nextMinute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  2  ,    nextHour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . PM ,    nextAmOrPm )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    validDays . contains ( nextDayOfWeek )  )  ;", "previousTimeout    =    nextTimeout ;", "}", "}", "METHOD_END"], "methodName": ["testEveryMonWedFriTwelveThirtyNoon"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   everyMorningFiveFifteen    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "everyMorningFiveFifteen . minute (  1  5  )  ;", "everyMorningFiveFifteen . hour (  5  )  ;", "calendarTimeout    =    new    ( everyMorningFiveFifteen )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    firstTimeout )  ;", "int   minute    =    firstTimeout . get ( Calendar . MINUTE )  ;", "int   second    =    firstTimeout . get ( Calendar . SECOND )  ;", "int   hour    =    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   amOrPm    =    firstTimeout . get ( Calendar . AM _ PM )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    second )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  5  ,    minute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     5  ,    hour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    amOrPm )  ;", "Calendar   previousTimeout    =    firstTimeout ;", "for    ( int   i    =     1  ;    i    <  =     3  7  0  ;    i +  +  )     {", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( previousTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout . after ( previousTimeout )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    nextTimeout . get ( Calendar . SECOND )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  5  ,    nextTimeout . get ( Calendar . MINUTE )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     5  ,    nextTimeout . get ( Calendar . HOUR _ OF _ DAY )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    nextTimeout . get ( Calendar . AM _ PM )  )  ;", "previousTimeout    =    nextTimeout ;", "}", "}", "METHOD_END"], "methodName": ["testEveryMorningFiveFifteen"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   everySecondExpression    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "everySecondExpression . second (  \"  *  \"  )  ;", "everySecondExpression . minute (  \"  *  \"  )  ;", "everySecondExpression . hour (  \"  *  \"  )  ;", "calendarTimeout    =    new    ( everySecondExpression )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( firstTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout . after ( firstTimeout )  )  ;", "long   diff    =     ( nextTimeout . getTimeInMillis (  )  )     -     ( firstTimeout . getTimeInMillis (  )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  0  0  0  ,    diff )  ;", "}", "METHOD_END"], "methodName": ["testEverySecondTimeout"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   everyWeekDayThreeFifteen    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "everyWeekDayThreeFifteen . minute (  1  5  )  ;", "everyWeekDayThreeFifteen . hour (  8  )  ;", "everyWeekDayThreeFifteen . dayOfWeek (  \" Mon - Fri \"  )  ;", "calendarTimeout    =    new    ( everyWeekDayThreeFifteen )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    firstTimeout )  ;", "int   minute    =    firstTimeout . get ( Calendar . MINUTE )  ;", "int   second    =    firstTimeout . get ( Calendar . SECOND )  ;", "int   hour    =    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   amOrPm    =    firstTimeout . get ( Calendar . AM _ PM )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    second )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  5  ,    minute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     8  ,    hour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    amOrPm )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    this . isWeekDay ( firstTimeout )  )  ;", "Calendar   previousTimeout    =    firstTimeout ;", "for    ( int   i    =     1  ;    i    <  =     1  8  0  ;    i +  +  )     {", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( previousTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout . after ( previousTimeout )  )  ;", "int   nextMinute    =    nextTimeout . get ( Calendar . MINUTE )  ;", "int   nextSecond    =    nextTimeout . get ( Calendar . SECOND )  ;", "int   nextHour    =    nextTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   nextAmOrPm    =    nextTimeout . get ( Calendar . AM _ PM )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    nextSecond )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     1  5  ,    nextMinute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     8  ,    nextHour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    nextAmOrPm )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    this . isWeekDay ( nextTimeout )  )  ;", "previousTimeout    =    nextTimeout ;", "}", "}", "METHOD_END"], "methodName": ["testEveryWeekdayEightFifteen"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "testNextDayOfWeek ( new   GregorianCalendar (  2  0  1  4  ,     2  ,     2  2  ,     4  ,     0  ,     0  )  . getTime (  )  )  ;", "testNextDayOfWeek ( new   GregorianCalendar (  2  0  1  4  ,     2  ,     2  5  ,     2  ,     0  ,     0  )  . getTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNextDayOfWeek"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   expression    =    new   ScheduleExpression (  )  ;", "expression . dayOfWeek (  \"  6  \"  )  ;", "expression . hour (  \"  3  \"  )  ;", "expression . minute (  \"  2  1  \"  )  ;", "expression . second (  \"  5  0  \"  )  ;", "expression . start ( start )  ;", "calendarTimeout    =    new    ( expression )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "Assert . assertEquals (  5  0  ,    firstTimeout . get ( Calendar . SECOND )  )  ;", "Assert . assertEquals (  2  1  ,    firstTimeout . get ( Calendar . MINUTE )  )  ;", "Assert . assertEquals (  3  ,    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )  ;", "Assert . assertEquals (  7  ,    firstTimeout . get ( Calendar . DAY _ OF _ WEEK )  )  ;", "Assert . assertEquals (  2  9  ,    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "}", "METHOD_END"], "methodName": ["testNextDayOfWeek"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   everyLeapYearOn 2  9 thFeb    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "everyLeapYearOn 2  9 thFeb . dayOfMonth (  2  9  )  ;", "everyLeapYearOn 2  9 thFeb . month (  \" fEb \"  )  ;", "calendarTimeout    =    new    ( everyLeapYearOn 2  9 thFeb )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    firstTimeout )  ;", "int   minute    =    firstTimeout . get ( Calendar . MINUTE )  ;", "int   second    =    firstTimeout . get ( Calendar . SECOND )  ;", "int   hour    =    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   amOrPm    =    firstTimeout . get ( Calendar . AM _ PM )  ;", "int   dayOfMonth    =    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  ;", "int   month    =    firstTimeout . get ( Calendar . MONTH )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    second )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    minute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    hour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    amOrPm )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     2  9  ,    dayOfMonth )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . FEBRUARY ,    month )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    this . isLeapYear ( firstTimeout )  )  ;", "Calendar   previousTimeout    =    firstTimeout ;", "for    ( int   i    =     1  ;    i    <  =     2  ;    i +  +  )     {", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( previousTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    nextTimeout . after ( previousTimeout )  )  ;", "int   nextMinute    =    nextTimeout . get ( Calendar . MINUTE )  ;", "int   nextSecond    =    nextTimeout . get ( Calendar . SECOND )  ;", "int   nextHour    =    nextTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   nextAmOrPm    =    nextTimeout . get ( Calendar . AM _ PM )  ;", "int   nextDayOfMonth    =    nextTimeout . get ( Calendar . DAY _ OF _ MONTH )  ;", "int   nextMonth    =    nextTimeout . get ( Calendar . MONTH )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    nextSecond )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    nextMinute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    nextHour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . AM ,    nextAmOrPm )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     2  9  ,    nextDayOfMonth )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . FEBRUARY ,    nextMonth )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    this . isLeapYear ( nextTimeout )  )  ;", "previousTimeout    =    nextTimeout ;", "}", "}", "METHOD_END"], "methodName": ["testRun29thOfFeb"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   every 0  _  1  5  _  3  0  _ Sec _ At _  9  _  3  0  _ PM    =    this . getTimezoneSpecificScheduleExpression (  )  ;", "every 0  _  1  5  _  3  0  _ Sec _ At _  9  _  3  0  _ PM . dayOfMonth (  3  1  )  ;", "every 0  _  1  5  _  3  0  _ Sec _ At _  9  _  3  0  _ PM . month (  \" Nov - Feb \"  )  ;", "every 0  _  1  5  _  3  0  _ Sec _ At _  9  _  3  0  _ PM . second (  \"  0  ,  1  5  ,  3  0  \"  )  ;", "every 0  _  1  5  _  3  0  _ Sec _ At _  9  _  3  0  _ PM . minute (  3  0  )  ;", "every 0  _  1  5  _  3  0  _ Sec _ At _  9  _  3  0  _ PM . hour (  \"  2  1  \"  )  ;", "calendarTimeout    =    new    ( every 0  _  1  5  _  3  0  _ Sec _ At _  9  _  3  0  _ PM )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( timeZoneDisplayName ,    firstTimeout )  ;", "int   minute    =    firstTimeout . get ( Calendar . MINUTE )  ;", "int   second    =    firstTimeout . get ( Calendar . SECOND )  ;", "int   hour    =    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   amOrPm    =    firstTimeout . get ( Calendar . AM _ PM )  ;", "int   dayOfMonth    =    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  ;", "int   month    =    firstTimeout . get ( Calendar . MONTH )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     0  ,    second )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  0  ,    minute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     2  1  ,    hour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . PM ,    amOrPm )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  1  ,    dayOfMonth )  ;", "List < Integer >    validMonths    =    new   ArrayList < Integer >  (  )  ;", "validMonths . add ( Calendar . NOVEMBER )  ;", "validMonths . add ( Calendar . DECEMBER )  ;", "validMonths . add ( Calendar . JANUARY )  ;", "validMonths . add ( Calendar . FEBRUARY )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    validMonths . contains ( month )  )  ;", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( firstTimeout )  ;", "long   diff    =     ( nextTimeout . getTimeInMillis (  )  )     -     ( firstTimeout . getTimeInMillis (  )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     (  1  5     *     1  0  0  0  )  ,    diff )  ;", "Calendar   date    =    new   GregorianCalendar (  2  0  1  4  ,     3  ,     1  8  )  ;", "Calendar   nextTimeoutFromNow    =    calendarTimeout . getNextTimeout ( date )  ;", "int   nextMinute    =    nextTimeoutFromNow . get ( Calendar . MINUTE )  ;", "int   nextSecond    =    nextTimeoutFromNow . get ( Calendar . SECOND )  ;", "int   nextHour    =    nextTimeoutFromNow . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   nextAmOrPM    =    nextTimeoutFromNow . get ( Calendar . AM _ PM )  ;", "int   nextDayOfMonth    =    nextTimeoutFromNow . get ( Calendar . DAY _ OF _ MONTH )  ;", "int   nextMonth    =    nextTimeoutFromNow . get ( Calendar . MONTH )  ;", "List < Integer >    validSeconds    =    new   ArrayList < Integer >  (  )  ;", "validSeconds . add (  0  )  ;", "validSeconds . add (  1  5  )  ;", "validSeconds . add (  3  0  )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    validSeconds . contains ( nextSecond )  )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  0  ,    nextMinute )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     2  1  ,    nextHour )  ;", "Assert . assertEquals ( timeZoneDisplayName ,    Calendar . PM ,    nextAmOrPM )  ;", "Assert . assertEquals ( timeZoneDisplayName ,     3  1  ,    nextDayOfMonth )  ;", "Assert . assertTrue ( timeZoneDisplayName ,    validMonths . contains ( nextMonth )  )  ;", "}", "METHOD_END"], "methodName": ["testSomeSpecificTime"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   schedule    =    new   ScheduleExpression (  )  ;", "int   year    =     2  0  1  3  ;", "int   month    =    Calendar . JUNE ;", "int   dayOfMonth    =     3  ;", "int   hourOfDay    =     2  ;", "int   minutes    =     0  ;", "Calendar   start    =    new   GregorianCalendar ( year ,    month ,    dayOfMonth ,    hourOfDay ,    minutes )  ;", "schedule . hour (  \"  0  -  1  2  \"  )  . month (  \"  *  \"  )  . dayOfMonth (  \"  3  \"  )  . minute (  \"  0  /  5  \"  )  . second (  \"  0  \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( schedule )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "if    (  (  (  (  ( firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )     !  =     3  )     |  |     (  ( firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )     !  =     2  )  )     |  |     (  ( firstTimeout . get ( Calendar . MINUTE )  )     !  =     0  )  )     |  |     (  ( firstTimeout . get ( Calendar . SECOND )  )     !  =     0  )  )     {", "Assert . fail ( firstTimeout . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWFLY1468"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "TimeZone   timeZone    =    TimeZone . getTimeZone (  \" Europe / Lisbon \"  )  ;", "int   year    =     2  0  1  3  ;", "int   month    =    Calendar . MARCH ;", "int   dayOfMonth    =     3  1  ;", "int   hourOfDay    =     3  ;", "int   minute    =     3  0  ;", "int   second    =     0  ;", "Calendar   start    =    new   GregorianCalendar ( timeZone )  ;", "start . clear (  )  ;", "start . set ( year ,    month ,    dayOfMonth ,    hourOfDay ,    minute ,    second )  ;", "ScheduleExpression   expression    =    new   ScheduleExpression (  )  . timezone ( timeZone . getID (  )  )  . dayOfMonth (  \"  *  \"  )  . hour (  \"  1  \"  )  . minute (  \"  3  0  \"  )  . second (  \"  0  \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( expression )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "Assert . assertEquals ( year ,    firstTimeout . get ( Calendar . YEAR )  )  ;", "Assert . assertEquals ( Calendar . APRIL ,    firstTimeout . get ( Calendar . MONTH )  )  ;", "Assert . assertEquals (  1  ,    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "Assert . assertEquals (  1  ,    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )  ;", "Assert . assertEquals (  3  0  ,    firstTimeout . get ( Calendar . MINUTE )  )  ;", "Assert . assertEquals ( second ,    firstTimeout . get ( Calendar . SECOND )  )  ;", "}", "METHOD_END"], "methodName": ["testWFLY3947_1"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "TimeZone   timeZone    =    TimeZone . getTimeZone (  \" Australia / Lord _ Howe \"  )  ;", "int   year    =     2  0  1  3  ;", "int   month    =    Calendar . OCTOBER ;", "int   dayOfMonth    =     6  ;", "int   hourOfDay    =     2  ;", "int   minute    =     4  1  ;", "int   second    =     0  ;", "Calendar   start    =    new   GregorianCalendar ( timeZone )  ;", "start . clear (  )  ;", "start . set ( year ,    month ,    dayOfMonth ,    hourOfDay ,    minute ,    second )  ;", "ScheduleExpression   expression    =    new   ScheduleExpression (  )  . timezone ( timeZone . getID (  )  )  . dayOfMonth (  \"  *  \"  )  . hour (  \"  2  ,     3  \"  )  . minute (  \"  2  0  ,     4  0  \"  )  . second (  \"  0  \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( expression )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "Assert . assertEquals ( year ,    firstTimeout . get ( Calendar . YEAR )  )  ;", "Assert . assertEquals ( month ,    firstTimeout . get ( Calendar . MONTH )  )  ;", "Assert . assertEquals ( dayOfMonth ,    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "Assert . assertEquals (  3  ,    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )  ;", "Assert . assertEquals (  2  0  ,    firstTimeout . get ( Calendar . MINUTE )  )  ;", "Assert . assertEquals ( second ,    firstTimeout . get ( Calendar . SECOND )  )  ;", "}", "METHOD_END"], "methodName": ["testWFLY3947_2"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "int   year    =     2  0  1  6  ;", "int   month    =    Calendar . JANUARY ;", "int   dayOfMonth    =     1  4  ;", "int   hourOfDay    =     9  ;", "int   minute    =     4  5  ;", "int   second    =     3  5  ;", "Calendar   start    =    new   GregorianCalendar (  )  ;", "start . clear (  )  ;", "start . set ( year ,    month ,    dayOfMonth ,    hourOfDay ,    minute ,    second )  ;", "ScheduleExpression   expression    =    new   ScheduleExpression (  )  . dayOfMonth (  \"  *  \"  )  . hour (  \"  2  0  -  2  2  \"  )  . minute (  \"  0  /  5  \"  )  . second (  \"  2  0  ,  4  0  \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( expression )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "Assert . assertEquals ( year ,    firstTimeout . get ( Calendar . YEAR )  )  ;", "Assert . assertEquals ( month ,    firstTimeout . get ( Calendar . MONTH )  )  ;", "Assert . assertEquals ( dayOfMonth ,    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "Assert . assertEquals (  2  0  ,    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )  ;", "Assert . assertEquals (  0  ,    firstTimeout . get ( Calendar . MINUTE )  )  ;", "Assert . assertEquals (  2  0  ,    firstTimeout . get ( Calendar . SECOND )  )  ;", "}", "METHOD_END"], "methodName": ["testWFLY5995_HourOverflow"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "int   year    =     2  0  1  6  ;", "int   month    =    Calendar . JANUARY ;", "int   dayOfMonth    =     1  4  ;", "int   hourOfDay    =     9  ;", "int   minute    =     4  6  ;", "int   second    =     4  2  ;", "Calendar   start    =    new   GregorianCalendar (  )  ;", "start . clear (  )  ;", "start . set ( year ,    month ,    dayOfMonth ,    hourOfDay ,    minute ,    second )  ;", "ScheduleExpression   expression    =    new   ScheduleExpression (  )  . dayOfMonth (  \"  *  \"  )  . hour (  \"  *  \"  )  . minute (  \"  0  -  4  5  \"  )  . second (  \"  0  /  1  0  \"  )  . start ( start . getTime (  )  )  ;", "calendarTimeout    =    new    ( expression )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull ( firstTimeout )  ;", "Assert . assertEquals ( year ,    firstTimeout . get ( Calendar . YEAR )  )  ;", "Assert . assertEquals ( month ,    firstTimeout . get ( Calendar . MONTH )  )  ;", "Assert . assertEquals ( dayOfMonth ,    firstTimeout . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "Assert . assertEquals (  1  0  ,    firstTimeout . get ( Calendar . HOUR _ OF _ DAY )  )  ;", "Assert . assertEquals (  0  ,    firstTimeout . get ( Calendar . MINUTE )  )  ;", "Assert . assertEquals (  0  ,    firstTimeout . get ( Calendar . SECOND )  )  ;", "}", "METHOD_END"], "methodName": ["testWFLY5995_MinuteOverflow"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutTestCase"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   sch    =    new   ScheduleExpression (  )  ;", "sch . timezone (  \" America / New _ York \"  )  ;", "sch . dayOfMonth (  \"  *  \"  )  ;", "sch . dayOfWeek (  \"  *  \"  )  ;", "sch . month (  \"  *  \"  )  ;", "sch . hour (  \"  2  \"  )  ;", "sch . minute (  \"  *  \"  )  ;", "sch . second (  \"  0  \"  )  ;", "sch . year (  \"  *  \"  )  ;", "CalendarBasedTimeout   calendarTimeout    =    new   CalendarBasedTimeout ( sch )  ;", "Calendar   firstTimeout    =    calendarTimeout . getFirstTimeout (  )  ;", "Assert . assertNotNull (  \" first   timeout   is   null \"  ,    firstTimeout )  ;", ". logger . info (  (  \" First   timeout   is    \"     +     ( firstTimeout . getTime (  )  )  )  )  ;", "TimeZone   currentTimezone    =    TimeZone . getTimeZone (  \" America / Chicago \"  )  ;", "Calendar   currentCal    =    new   GregorianCalendar ( currentTimezone )  ;", "currentCal . set ( Calendar . YEAR ,     2  0  1  4  )  ;", "currentCal . set ( Calendar . MONTH ,     1  )  ;", "currentCal . set ( Calendar . DATE ,     8  )  ;", "currentCal . set ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "currentCal . set ( Calendar . MINUTE ,     1  )  ;", "currentCal . set ( Calendar . SECOND ,     1  )  ;", "currentCal . set ( Calendar . MILLISECOND ,     0  )  ;", "Calendar   nextTimeout    =    calendarTimeout . getNextTimeout ( currentCal )  ;", ". logger . info (  (  \" Next   timeout   is    \"     +     ( nextTimeout . getTime (  )  )  )  )  ;", "Calendar   expectedCal    =    new   GregorianCalendar ( currentTimezone )  ;", "expectedCal . set ( Calendar . YEAR ,     2  0  1  4  )  ;", "expectedCal . set ( Calendar . MONTH ,     1  )  ;", "expectedCal . set ( Calendar . DATE ,     8  )  ;", "expectedCal . set ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "expectedCal . set ( Calendar . MINUTE ,     2  )  ;", "expectedCal . set ( Calendar . SECOND ,     0  )  ;", "expectedCal . set ( Calendar . MILLISECOND ,     0  )  ;", "Assert . assertEquals (  (  \"  [ WFLY -  2  8  4  0  ]    Next   timeout   should   be :     \"     +     ( expectedCal . getTime (  )  )  )  ,    expectedCal . getTime (  )  ,    nextTimeout . getTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScheduledTimezoneDifferentThanCurrentSystem"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarBasedTimeoutWithDifferentTimeZoneTestCase"}, {"methodBody": ["METHOD_START", "{", "int   expectedDateOfFirstSunOfJuly 2  0  1  0     =     4  ;", "Calendar   july 2  0  1  0     =    new   GregorianCalendar (  )  ;", "july 2  0  1  0  . set ( Calendar . MONTH ,    Calendar . JULY )  ;", "july 2  0  1  0  . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "int   dateOfFirstSunOfJuly 2  0  1  0     =     . getNthDayOfMonth ( july 2  0  1  0  ,     1  ,    Calendar . SUNDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   sunday   of   July    2  0  1  0  \"  ,    expectedDateOfFirstSunOfJuly 2  0  1  0  ,    dateOfFirstSunOfJuly 2  0  1  0  )  ;", "}", "METHOD_END"], "methodName": ["test1stSunday"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarUtilTestCase"}, {"methodBody": ["METHOD_START", "{", "final   int   FIRST _ WEEK    =     1  ;", "int   expectedDateOfFirstSunOfJuly 2  0  1  0     =     4  ;", "Calendar   july 2  0  1  0     =    new   GregorianCalendar (  )  ;", "july 2  0  1  0  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "july 2  0  1  0  . set ( Calendar . MONTH ,    Calendar . JULY )  ;", "july 2  0  1  0  . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "int   dateOfFirstSunOfJuly 2  0  1  0     =     . getNthDayOfMonth ( july 2  0  1  0  ,    FIRST _ WEEK ,    Calendar . SUNDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   sunday   of   July    2  0  1  0  \"  ,    expectedDateOfFirstSunOfJuly 2  0  1  0  ,    dateOfFirstSunOfJuly 2  0  1  0  )  ;", "int   expectedDateOfFirstMonOfJune 2  0  0  9     =     1  ;", "Calendar   june 2  0  0  9     =    new   GregorianCalendar (  )  ;", "june 2  0  0  9  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "june 2  0  0  9  . set ( Calendar . MONTH ,    Calendar . JUNE )  ;", "june 2  0  0  9  . set ( Calendar . YEAR ,     2  0  0  9  )  ;", "int   dateOfFirstMonJune 2  0  0  9     =     . getNthDayOfMonth ( june 2  0  0  9  ,    FIRST _ WEEK ,    Calendar . MONDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   monday   of   June    2  0  0  9  \"  ,    expectedDateOfFirstMonOfJune 2  0  0  9  ,    dateOfFirstMonJune 2  0  0  9  )  ;", "int   expectedDateOfFirstTueOfFeb 2  0  1  2     =     7  ;", "Calendar   feb 2  0  1  2     =    new   GregorianCalendar (  )  ;", "feb 2  0  1  2  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "feb 2  0  1  2  . set ( Calendar . MONTH ,    Calendar . FEBRUARY )  ;", "feb 2  0  1  2  . set ( Calendar . YEAR ,     2  0  1  2  )  ;", "int   dateOfFirstTueFeb 2  0  1  2     =     . getNthDayOfMonth ( feb 2  0  1  2  ,    FIRST _ WEEK ,    Calendar . TUESDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   tuesday   of   Feb    2  0  1  2  \"  ,    expectedDateOfFirstTueOfFeb 2  0  1  2  ,    dateOfFirstTueFeb 2  0  1  2  )  ;", "int   expectedDateOfFirstMonOfJan 2  0  0  6     =     4  ;", "Calendar   jan 2  0  0  6     =    new   GregorianCalendar (  )  ;", "jan 2  0  0  6  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "jan 2  0  0  6  . set ( Calendar . MONTH ,    Calendar . JANUARY )  ;", "jan 2  0  0  6  . set ( Calendar . YEAR ,     2  0  0  6  )  ;", "int   dateOfFirstWedJan 2  0  0  6     =     . getNthDayOfMonth ( jan 2  0  0  6  ,    FIRST _ WEEK ,    Calendar . WEDNESDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   wednesday   of   Jan    2  0  0  6  \"  ,    expectedDateOfFirstMonOfJan 2  0  0  6  ,    dateOfFirstWedJan 2  0  0  6  )  ;", "int   expectedDateOfFirstThuOfSep 1  9  9  9     =     2  ;", "Calendar   sep 1  9  9  9     =    new   GregorianCalendar (  )  ;", "sep 1  9  9  9  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "sep 1  9  9  9  . set ( Calendar . MONTH ,    Calendar . SEPTEMBER )  ;", "sep 1  9  9  9  . set ( Calendar . YEAR ,     1  9  9  9  )  ;", "int   dateOfFirstThuSep 1  9  9  9     =     . getNthDayOfMonth ( sep 1  9  9  9  ,    FIRST _ WEEK ,    Calendar . THURSDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   thursday   of   September    1  9  9  9  \"  ,    expectedDateOfFirstThuOfSep 1  9  9  9  ,    dateOfFirstThuSep 1  9  9  9  )  ;", "int   expectedDateOfFirstFriOfDec 2  0  5  8     =     6  ;", "Calendar   dec 2  0  5  8     =    new   GregorianCalendar (  )  ;", "dec 2  0  5  8  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "dec 2  0  5  8  . set ( Calendar . MONTH ,    Calendar . DECEMBER )  ;", "dec 2  0  5  8  . set ( Calendar . YEAR ,     2  0  5  8  )  ;", "int   dateOfFirstFriDec 2  0  5  8     =     . getNthDayOfMonth ( dec 2  0  5  8  ,    FIRST _ WEEK ,    Calendar . FRIDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   friday   of   December    2  0  5  8  \"  ,    expectedDateOfFirstFriOfDec 2  0  5  8  ,    dateOfFirstFriDec 2  0  5  8  )  ;", "int   expectedDateOfFirstSatOfAug 2  0  0  0     =     5  ;", "Calendar   aug 2  0  0  0     =    new   GregorianCalendar (  )  ;", "aug 2  0  0  0  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "aug 2  0  0  0  . set ( Calendar . MONTH ,    Calendar . AUGUST )  ;", "aug 2  0  0  0  . set ( Calendar . YEAR ,     2  0  0  0  )  ;", "int   dateOfFirstSatAug 2  0  0  0     =     . getNthDayOfMonth ( aug 2  0  0  0  ,    FIRST _ WEEK ,    Calendar . SATURDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   saturday   of   August    2  0  0  0  \"  ,    expectedDateOfFirstSatOfAug 2  0  0  0  ,    dateOfFirstSatAug 2  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["test1stXXXDay"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarUtilTestCase"}, {"methodBody": ["METHOD_START", "{", "final   int   SECOND _ WEEK    =     2  ;", "int   expectedDateOfSecondSunOfMay 2  0  1  0     =     9  ;", "Calendar   may 2  0  1  0     =    new   GregorianCalendar (  )  ;", "may 2  0  1  0  . set ( Calendar . MONTH ,    Calendar . MAY )  ;", "may 2  0  1  0  . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "int   dateOfSecondSunOfMay 2  0  1  0     =     . getNthDayOfMonth ( may 2  0  1  0  ,    SECOND _ WEEK ,    Calendar . SUNDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    2 nd   sunday   of   May    2  0  1  0  \"  ,    expectedDateOfSecondSunOfMay 2  0  1  0  ,    dateOfSecondSunOfMay 2  0  1  0  )  ;", "int   expectedDateOfSecondMonOfFeb 2  1  1  1     =     9  ;", "Calendar   feb 2  1  1  1     =    new   GregorianCalendar (  )  ;", "feb 2  1  1  1  . set ( Calendar . MONTH ,    Calendar . FEBRUARY )  ;", "feb 2  1  1  1  . set ( Calendar . YEAR ,     2  1  1  1  )  ;", "int   dateOfSecondMonFeb 2  1  1  1     =     . getNthDayOfMonth ( feb 2  1  1  1  ,    SECOND _ WEEK ,    Calendar . MONDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    2 nd   monday   of   Feb    2  1  1  1  \"  ,    expectedDateOfSecondMonOfFeb 2  1  1  1  ,    dateOfSecondMonFeb 2  1  1  1  )  ;", "int   expectedDateOfSecondTueOct 2  0  1  6     =     1  1  ;", "Calendar   oct 2  0  1  6     =    new   GregorianCalendar (  )  ;", "oct 2  0  1  6  . set ( Calendar . MONTH ,    Calendar . OCTOBER )  ;", "oct 2  0  1  6  . set ( Calendar . YEAR ,     2  0  1  6  )  ;", "int   dateOfSecondTueOct 2  0  1  6     =     . getNthDayOfMonth ( oct 2  0  1  6  ,    SECOND _ WEEK ,    Calendar . TUESDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    2 nd   tuesday   of   Oct    2  0  1  6  \"  ,    expectedDateOfSecondTueOct 2  0  1  6  ,    dateOfSecondTueOct 2  0  1  6  )  ;", "int   expectedDateOfSecWedApr 2  0  1  0     =     1  4  ;", "Calendar   apr 2  0  1  0     =    new   GregorianCalendar (  )  ;", "apr 2  0  1  0  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "apr 2  0  1  0  . set ( Calendar . MONTH ,    Calendar . APRIL )  ;", "apr 2  0  1  0  . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "int   dateOfSecondWedApril 2  0  1  0     =     . getNthDayOfMonth ( apr 2  0  1  0  ,    SECOND _ WEEK ,    Calendar . WEDNESDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    2 nd   wednesday   of   April    2  0  1  0  \"  ,    expectedDateOfSecWedApr 2  0  1  0  ,    dateOfSecondWedApril 2  0  1  0  )  ;", "int   expectedDateOfSecondThuMar 2  0  6  7     =     1  0  ;", "Calendar   march 2  0  6  7     =    new   GregorianCalendar (  )  ;", "march 2  0  6  7  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "march 2  0  6  7  . set ( Calendar . MONTH ,    Calendar . MARCH )  ;", "march 2  0  6  7  . set ( Calendar . YEAR ,     2  0  6  7  )  ;", "int   dateOfSecThuMarch 2  0  6  7     =     . getNthDayOfMonth ( march 2  0  6  7  ,    SECOND _ WEEK ,    Calendar . THURSDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    2 nd   thursday   of   March    2  0  6  7  \"  ,    expectedDateOfSecondThuMar 2  0  6  7  ,    dateOfSecThuMarch 2  0  6  7  )  ;", "int   expectedDateOfSecFriNov 2  0  2  0     =     1  3  ;", "Calendar   nov 2  0  2  0     =    new   GregorianCalendar (  )  ;", "nov 2  0  2  0  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "nov 2  0  2  0  . set ( Calendar . MONTH ,    Calendar . NOVEMBER )  ;", "nov 2  0  2  0  . set ( Calendar . YEAR ,     2  0  2  0  )  ;", "int   dateOfFirstFriDec 2  0  5  8     =     . getNthDayOfMonth ( nov 2  0  2  0  ,    SECOND _ WEEK ,    Calendar . FRIDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    2 nd   friday   of   November    2  0  2  0  \"  ,    expectedDateOfSecFriNov 2  0  2  0  ,    dateOfFirstFriDec 2  0  5  8  )  ;", "int   expectedDateOfSecSatOfSep 2  0  1  3     =     1  4  ;", "Calendar   aug 2  0  0  0     =    new   GregorianCalendar (  )  ;", "aug 2  0  0  0  . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "aug 2  0  0  0  . set ( Calendar . MONTH ,    Calendar . SEPTEMBER )  ;", "aug 2  0  0  0  . set ( Calendar . YEAR ,     2  0  1  3  )  ;", "int   dateOfSecSatSep 2  0  1  3     =     . getNthDayOfMonth ( aug 2  0  0  0  ,    SECOND _ WEEK ,    Calendar . SATURDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    2 nd   saturday   of   September    2  0  1  3  \"  ,    expectedDateOfSecSatOfSep 2  0  1  3  ,    dateOfSecSatSep 2  0  1  3  )  ;", "}", "METHOD_END"], "methodName": ["test2ndXXXDay"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarUtilTestCase"}, {"methodBody": ["METHOD_START", "{", "int   expectedDateOfFirstSunOfJuly 2  0  1  0     =     4  ;", "Calendar   july 2  0  1  0     =    new   GregorianCalendar (  )  ;", "july 2  0  1  0  . set ( Calendar . MONTH ,    Calendar . JULY )  ;", "july 2  0  1  0  . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "int   dateOfFirstSunOfJuly 2  0  1  0     =     . getNthDayOfMonth ( july 2  0  1  0  ,     1  ,    Calendar . SUNDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   sunday   of   July    2  0  1  0  \"  ,    expectedDateOfFirstSunOfJuly 2  0  1  0  ,    dateOfFirstSunOfJuly 2  0  1  0  )  ;", "}", "METHOD_END"], "methodName": ["test3rdXXXDay"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarUtilTestCase"}, {"methodBody": ["METHOD_START", "{", "int   expectedDateOfFirstSunOfJuly 2  0  1  0     =     4  ;", "Calendar   july 2  0  1  0     =    new   GregorianCalendar (  )  ;", "july 2  0  1  0  . set ( Calendar . MONTH ,    Calendar . JULY )  ;", "july 2  0  1  0  . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "int   dateOfFirstSunOfJuly 2  0  1  0     =     . getNthDayOfMonth ( july 2  0  1  0  ,     1  ,    Calendar . SUNDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   sunday   of   July    2  0  1  0  \"  ,    expectedDateOfFirstSunOfJuly 2  0  1  0  ,    dateOfFirstSunOfJuly 2  0  1  0  )  ;", "}", "METHOD_END"], "methodName": ["test4thXXXDay"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarUtilTestCase"}, {"methodBody": ["METHOD_START", "{", "int   expectedDateOfFirstSunOfJuly 2  0  1  0     =     4  ;", "Calendar   july 2  0  1  0     =    new   GregorianCalendar (  )  ;", "july 2  0  1  0  . set ( Calendar . MONTH ,    Calendar . JULY )  ;", "july 2  0  1  0  . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "int   dateOfFirstSunOfJuly 2  0  1  0     =     . getNthDayOfMonth ( july 2  0  1  0  ,     1  ,    Calendar . SUNDAY )  ;", "Assert . assertEquals (  \" Unexpected   date   for    1 st   sunday   of   July    2  0  1  0  \"  ,    expectedDateOfFirstSunOfJuly 2  0  1  0  ,    dateOfFirstSunOfJuly 2  0  1  0  )  ;", "}", "METHOD_END"], "methodName": ["test5thXXXDay"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarUtilTestCase"}, {"methodBody": ["METHOD_START", "{", "Calendar   march    =    new   GregorianCalendar (  )  ;", "march . set ( Calendar . MONTH ,    Calendar . MARCH )  ;", "march . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "int   lastDateOfMarch    =     . getLastDateOfMonth ( march )  ;", "Assert . assertEquals (  \" Unexpected   last   date   for   march \"  ,     3  1  ,    lastDateOfMarch )  ;", "Calendar   april    =    new   GregorianCalendar (  )  ;", "april . set ( Calendar . MONTH ,    Calendar . APRIL )  ;", "april . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "int   lastDateOfApril    =     . getLastDateOfMonth ( april )  ;", "Assert . assertEquals (  \" Unexpected   last   date   for   april \"  ,     3  0  ,    lastDateOfApril )  ;", "Calendar   nonLeapFebruary    =    new   GregorianCalendar (  )  ;", "nonLeapFebruary . set ( Calendar . MONTH ,    Calendar . FEBRUARY )  ;", "nonLeapFebruary . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "nonLeapFebruary . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "int   lastDateOfNonLeapFebruary    =     . getLastDateOfMonth ( nonLeapFebruary )  ;", "Assert . assertEquals (  \" Unexpected   last   date   for   non - leap   february \"  ,     2  8  ,    lastDateOfNonLeapFebruary )  ;", "Calendar   leapFebruary    =    new   GregorianCalendar (  )  ;", "leapFebruary . set ( Calendar . MONTH ,    Calendar . FEBRUARY )  ;", "leapFebruary . set ( Calendar . YEAR ,     2  0  1  2  )  ;", "leapFebruary . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "int   lastDateOfLeapFebruary    =     . getLastDateOfMonth ( leapFebruary )  ;", "Assert . assertEquals (  \" Unexpected   last   date   for   leap   february \"  ,     2  9  ,    lastDateOfLeapFebruary )  ;", "}", "METHOD_END"], "methodName": ["testLastDateOfMonth"], "fileName": "org.jboss.as.ejb3.timer.schedule.CalendarUtilTestCase"}, {"methodBody": ["METHOD_START", "{", "String [  ]    invalidRangeValues    =    new   String [  ]  {    null ,     \"  \"  ,     \"     \"  ,     \"  0  .  1  \"  ,     \"  1 d \"  ,     \"  1  .  0  \"  ,     \"  ?  \"  ,     \"  %  \"  ,     \"  $  \"  ,     \"  !  \"  ,     \"  &  \"  ,     \"  -  \"  ,     \"  /  \"  ,     \"  ,  \"  ,     \"  .  \"  ,     \"  1  -  \"  ,     \"  1  -  2  -  3  \"  ,     \"  1  +  2  \"  ,     \"  *  *  \"  ,     \"  *  -  \"  ,     \"  *  ,  1  \"  ,     \"  1  ,  *  \"  ,     \"  5  /  *  \"  ,     \"  1  ,     2  /  2  \"  ,     \"  -  -  -  \"  ,     \"  -  \"  ,     \"  -  -  \"  ,     \"     -  2     -  3     -  4  \"  ,     \"  -  0  \"  ,     \"  1  -  -  \"     }  ;", "for    ( String   invalidRange    :    invalidRangeValues )     {", "boolean   accepts    =    RangeValue . accepts ( invalidRange )  ;", "Assert . assertFalse (  (  \" Range   value   accepted   an   invalid   value :     \"     +    invalidRange )  ,    accepts )  ;", "try    {", "RangeValue   invalidRangeValue    =    new   RangeValue ( invalidRange )  ;", "Assert . fail (  (  \" Range   value   did    * not *    throw   IllegalArgumentException   for   an   invalid   range :     \"     +    invalidRange )  )  ;", "}    catch    ( IllegalArgumentException   iae )     {", "}", "}", "}", "METHOD_END"], "methodName": ["testInvalidRange"], "fileName": "org.jboss.as.ejb3.timer.schedule.RangeValueTestCase"}, {"methodBody": ["METHOD_START", "{", "String [  ]    validRanges    =    new   String [  ]  {     \"  1  -  8  \"  ,     \"  -  7  -  -  1  \"  ,     \"  7  -  -  1  \"  ,     \"  1 st   Fri -  1 st   Mon \"     }  ;", "for    ( String   validRange    :    validRanges )     {", "boolean   accepts    =     . accepts ( validRange )  ;", "Assert . assertTrue (  (  \" Valid   range   value   wasn ' t   accepted :     \"     +    validRange )  ,    accepts )  ;", "valid    =    new    ( validRange )  ;", "}", "}", "METHOD_END"], "methodName": ["testValidRange"], "fileName": "org.jboss.as.ejb3.timer.schedule.RangeValueTestCase"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExpression ;", "}", "METHOD_END"], "methodName": ["getScheduleExpression"], "fileName": "org.jboss.as.ejb3.timerservice.AutoTimer"}, {"methodBody": ["METHOD_START", "{", "return   timerConfig ;", "}", "METHOD_END"], "methodName": ["getTimerConfig"], "fileName": "org.jboss.as.ejb3.timerservice.AutoTimer"}, {"methodBody": ["METHOD_START", "{", "return   new   CalendarTimer . Builder (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.jboss.as.ejb3.timerservice.CalendarTimer"}, {"methodBody": ["METHOD_START", "{", "return   this . calendarTimeout ;", "}", "METHOD_END"], "methodName": ["getCalendarTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.CalendarTimer"}, {"methodBody": ["METHOD_START", "{", "return   this . calendarTimeout . getScheduleExpression (  )  ;", "}", "METHOD_END"], "methodName": ["getScheduleExpression"], "fileName": "org.jboss.as.ejb3.timerservice.CalendarTimer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . autoTimer )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failToInvokegetTimeoutMethod (  )  ;", "}", "return   this . timeoutMethod ;", "}", "METHOD_END"], "methodName": ["getTimeoutMethod"], "fileName": "org.jboss.as.ejb3.timerservice.CalendarTimer"}, {"methodBody": ["METHOD_START", "{", "if    ( timeoutMethodInfo    =  =    null )     {", "return   null ;", "}", "String   declaringClass    =    timeoutMethodInfo . getDeclaringClass (  )  ;", "Class <  ?  >    timeoutMethodDeclaringClass    =    null ;", "try    {", "timeoutMethodDeclaringClass    =    Class . forName ( declaringClass ,    false ,    classLoader )  ;", "}    catch    ( ClassNotFoundException   cnfe )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failToLoadDeclaringClassOfTimeOut ( declaringClass )  ;", "}", "String   timeoutMethodName    =    timeoutMethodInfo . getMethodName (  )  ;", "String [  ]    timeoutMethodParams    =    timeoutMethodInfo . getMethodParams (  )  ;", "Class <  ?  >  [  ]    timeoutMethodParamTypes    =    new   Class <  ?  >  [  ]  {        }  ;", "if    ( timeoutMethodParams    !  =    null )     {", "timeoutMethodParamTypes    =    new   Class <  ?  >  [ timeoutMethodParams . length ]  ;", "int   i    =     0  ;", "for    ( String   paramClassName    :    timeoutMethodParams )     {", "Class <  ?  >    methodParamClass    =    null ;", "try    {", "methodParamClass    =    Class . forName ( paramClassName ,    false ,    classLoader )  ;", "}    catch    ( ClassNotFoundException   cnfe )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failedToLoadTimeoutMethodParamClass ( cnfe ,    paramClassName )  ;", "}", "timeoutMethodParamTypes [  ( i +  +  )  ]     =    methodParamClass ;", "}", "}", "Class <  ?  >    klass    =    timeoutMethodDeclaringClass ;", "while    ( klass    !  =    null )     {", "Method [  ]    methods    =    klass . getDeclaredMethods (  )  ;", "for    ( Method   method    :    methods )     {", "if    ( method . getName (  )  . equals ( timeoutMethodName )  )     {", "Class <  ?  >  [  ]    methodParamTypes    =    method . getParameterTypes (  )  ;", "if    (  ( timeoutMethodParamTypes . length )     !  =     ( methodParamTypes . length )  )     {", "continue ;", "}", "boolean   match    =    true ;", "for    ( int   i    =     0  ;    i    <     ( methodParamTypes . length )  ;    i +  +  )     {", "if    (  !  ( timeoutMethodParamTypes [ i ]  . equals ( methodParamTypes [ i ]  )  )  )     {", "match    =    false ;", "break ;", "}", "}", "if    ( match )     {", "return   method ;", "}", "}", "}", "klass    =    klass . getSuperclass (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getTimeoutMethod"], "fileName": "org.jboss.as.ejb3.timerservice.CalendarTimer"}, {"methodBody": ["METHOD_START", "{", "CalendarTimer   calendarTimer    =     (  ( CalendarTimer )     ( timer )  )  ;", "if    ( calendarTimer . isAutoTimer (  )  )     {", "TimedObjectInvoker   invoker    =    this . timerService . getInvoker (  )  ;", "invoker . callTimeout ( calendarTimer ,    calendarTimer . getTimeoutMethod (  )  )  ;", "} else    {", "this . timerService . getInvoker (  )  . callTimeout ( calendarTimer )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeBeanMethod"], "fileName": "org.jboss.as.ejb3.timerservice.CalendarTimerTask"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . TIMER _ SERVICE _ METHOD )  ;", "final   InterceptorContext   currentInvocationContext    =    CurrentInvocationContext . get (  )  ;", "if    ( currentInvocationContext    =  =    null )     {", "return ;", "}", "Method   invokedMethod    =    currentInvocationContext . getMethod (  )  ;", "if    ( invokedMethod    =  =    null )     {", "Component   component    =    currentInvocationContext . getPrivateData ( Component . class )  ;", "if    (  !  ( component   instanceof   SingletonComponent )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failToInvokeDoLifecycle (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertInvocationAllowed"], "fileName": "org.jboss.as.ejb3.timerservice.NonFunctionalTimerService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ejbComponentDescription    =  =    null )     |  |     (  ( ejbComponentDescription . getServiceName (  )  )     =  =    null )  )     {", "return   null ;", "}", "return   ejbComponentDescription . getServiceName (  )  . append (  \" ejb \"  ,     \" non - functional -  \"  )  ;", "}", "METHOD_END"], "methodName": ["serviceNameFor"], "fileName": "org.jboss.as.ejb3.timerservice.NonFunctionalTimerService"}, {"methodBody": ["METHOD_START", "{", "return   ejbComponent ;", "}", "METHOD_END"], "methodName": ["getEjbComponent"], "fileName": "org.jboss.as.ejb3.timerservice.TimedObjectInvokerImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrentSContainer . getSContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerHandleImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.jboss.as.ejb3.timerservice.TimerHandleImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . timedObjectId ;", "}", "METHOD_END"], "methodName": ["getTimedObjectId"], "fileName": "org.jboss.as.ejb3.timerservice.TimerHandleImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( service )     =  =    null )     {", "service    =     (  ( TimerServiceImpl )     (  . currentServiceContainer (  )  . getRequiredService ( ServiceName . parse ( serviceName )  )  . getValue (  )  )  )  ;", "if    (  ( service )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . timerServiceWithIdNotRegistered ( timedObjectId )  ;", "}", "}", "final   TimerImpl   timer    =    this . service . getTimer ( this )  ;", "if    (  ( timer    =  =    null )     |  |     (  !  ( timer . isActive (  )  )  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . timerHandleIsNotActive ( this )  ;", "}", "return   timer ;", "}", "METHOD_END"], "methodName": ["getTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerHandleImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( timerState )     =  =     ( TimerState . EXPIRED )  )", "throw   logging . EjbLogger . EJB 3  _ TIMER _ LOGGER . timerHasExpired (  )  ;", "if    (  ( timerState )     =  =     ( TimerState . CANCELED )  )", "throw   logging . EjbLogger . EJB 3  _ TIMER _ LOGGER . timerWasCanceled (  )  ;", "AllowedMethodsInformation . checkAllowed ( MethodType . TIMER _ SERVICE _ METHOD )  ;", "}", "METHOD_END"], "methodName": ["assertTimerState"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   TimerImpl . Builder (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "this . timerService . cancelTimeout ( this )  ;", "}", "METHOD_END"], "methodName": ["cancelTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . initialExpiration ;", "}", "METHOD_END"], "methodName": ["getInitialExpiration"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . intervalDuration ;", "}", "METHOD_END"], "methodName": ["getInterval"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . nextExpiration ;", "}", "METHOD_END"], "methodName": ["getNextExpiration"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . previousRun ;", "}", "METHOD_END"], "methodName": ["getPreviousRun"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   primaryKey ;", "}", "METHOD_END"], "methodName": ["getPrimaryKey"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . timerState ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   timedObjectId ;", "}", "METHOD_END"], "methodName": ["getTimedObjectId"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . handle ;", "}", "METHOD_END"], "methodName": ["getTimerHandle"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . info ;", "}", "METHOD_END"], "methodName": ["getTimerInfo"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . timerService ;", "}", "METHOD_END"], "methodName": ["getTimerService"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   TimerTask < TimerImpl >  ( this )  ;", "}", "METHOD_END"], "methodName": ["getTimerTask"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "this . getTimerTask (  )  . invokeBeanMethod ( this )  ;", "}", "METHOD_END"], "methodName": ["invokeOneOff"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( timerService . isStarted (  )  )     &  &     (  !  ( isCanceled (  )  )  )  )     &  &     (  !  ( isExpired (  )  )  )  )     &  &     (  ( timerService . isScheduled ( getId (  )  )  )     |  |     (  ( timerState )     =  =     ( TimerState . CREATED )  )  )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isAutoTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( timerState )     =  =     ( TimerState . CANCELED )  ;", "}", "METHOD_END"], "methodName": ["isCanceled"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( timerState )     =  =     ( TimerState . EXPIRED )  ;", "}", "METHOD_END"], "methodName": ["isExpired"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( timerState )     =  =     ( TimerState . RETRY _ TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["isInRetry"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . persistent ;", "}", "METHOD_END"], "methodName": ["isTimerPersistent"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "inUseLock . lock (  )  ;", "}", "METHOD_END"], "methodName": ["lock"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "this . timerService . scheduleTimeout ( this ,    newTimer )  ;", "}", "METHOD_END"], "methodName": ["scheduleTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( next    =  =    null )     {", "setState ( State . EXPIRED )  ;", "}", "this . nextExpiration    =    next ;", "}", "METHOD_END"], "methodName": ["setNextTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "this . previousRun    =    previousRun ;", "}", "METHOD_END"], "methodName": ["setPreviousRun"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "this . timerState    =    state ;", "}", "METHOD_END"], "methodName": ["setTimerState"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "this . cancelTimeout (  )  ;", "}", "METHOD_END"], "methodName": ["suspend"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "inUseLock . unlock (  )  ;", "}", "METHOD_END"], "methodName": ["unlock"], "fileName": "org.jboss.as.ejb3.timerservice.TimerImpl"}, {"methodBody": ["METHOD_START", "{", "return   o   instanceof   TimerServiceBindingSource ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceBindingSource"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceBindingSource"}, {"methodBody": ["METHOD_START", "{", "final   List < ScheduleTimer >    timers    =    new   ArrayList < ScheduleTimer >  (  )  ;", "for    ( Map . Entry < Method ,    List < AutoTimer >  >    entry    :    autoTimers . entrySet (  )  )     {", "for    ( AutoTimer   timer    :    entry . getValue (  )  )     {", "timers . add ( new   ScheduleTimer ( entry . getKey (  )  ,    timer . getScheduleExpression (  )  ,    timer . getTimerConfig (  )  )  )  ;", "}", "}", "restoreTimers ( timers )  ;", "}", "METHOD_END"], "methodName": ["activate"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TimerImpl >    timers    =     (  ( Map < String ,    TimerImpl >  )     ( ContextTransactionSynchronizationRegistry . getInstance (  )  . getResource ( waitingOnTxCompletionKey )  )  )  ;", "if    ( timers    =  =    null )     {", "ContextTransactionSynchronizationRegistry . getInstance (  )  . putResource ( waitingOnTxCompletionKey ,     ( timers    =    new   HashMap < String ,    TimerImpl >  (  )  )  )  ;", "}", "timers . put ( timer . getId (  )  ,    timer )  ;", "}", "METHOD_END"], "methodName": ["addWaitingOnTxCompletionTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "AllowedMethodsInformation . checkAllowed ( MethodType . TIMER _ SERVICE _ METHOD )  ;", "if    (  ( isLifecycleCallbackInvocation (  )  )     &  &     (  !  ( this . isSingletonBeanInvocation (  )  )  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failToInvokeDoLifecycle (  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertTimerServiceState"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . scheduledTimerFutures )     {", "TimerTask   timerTask    =    this . scheduledTimerFutures . remove ( timer . getId (  )  )  ;", "if    ( timerTask    !  =    null )     {", "timerTask . cancel (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["cancelTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "timer . lock (  )  ;", "boolean   release    =    true ;", "try    {", "timer . assertTimerState (  )  ;", "boolean   startedInTx    =    getWaitingOnTxCompletionTimers (  )  . containsKey ( timer . getId (  )  )  ;", "if    (  ( timer . getState (  )  )     !  =     ( TimerState . EXPIRED )  )     {", "timer . setTimerState ( TimerState . CANCELED )  ;", "}", "if    (  ( transactionActive (  )  )     &  &     (  ! startedInTx )  )     {", "registerSynchronization ( new    . TimerRemoveSynchronization ( timer )  )  ;", "release    =    false ;", "} else    {", "this . cancelTimeout ( timer )  ;", "this . unregisterTimerResource ( timer . getId (  )  )  ;", "this . timers . remove ( timer . getId (  )  )  ;", "}", "persistTimer ( timer ,    false )  ;", "}    finally    {", "if    ( release )     {", "timer . unlock (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["cancelTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . isLifecycleCallbackInvocation (  )  )     &  &     (  !  ( this . isSingletonBeanInvocation (  )  )  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failToCreateTimerDoLifecycle (  )  ;", "}", "if    ( schedule    =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . scheduleIsNull (  )  ;", "}", "UUID   uuid    =    UUID . randomUUID (  )  ;", "TimerImpl   timer    =    CalendarTimer . builder (  )  . setAutoTimer (  ( timeoutMethod    !  =    null )  )  . setScheduleExprSecond ( schedule . getSecond (  )  )  . setScheduleExprMinute ( schedule . getMinute (  )  )  . setScheduleExprHour ( schedule . getHour (  )  )  . setScheduleExprDayOfWeek ( schedule . getDayOfWeek (  )  )  . setScheduleExprDayOfMonth ( schedule . getDayOfMonth (  )  )  . setScheduleExprMonth ( schedule . getMonth (  )  )  . setScheduleExprYear ( schedule . getYear (  )  )  . setScheduleExprStartDate ( schedule . getStart (  )  )  . setScheduleExprEndDate ( schedule . getEnd (  )  )  . setScheduleExprTimezone ( schedule . getTimezone (  )  )  . setTimeoutMethod ( timeoutMethod )  . settate ( tate . CREATED )  . setId ( uuid . toString (  )  )  . setPersistent ( persistent )  . setPrimaryKey ( currentPrimaryKey (  )  )  . setTimedObjectId ( getInvoker (  )  . getTimedObjectId (  )  )  . setInfo ( info )  . setNewTimer ( true )  . build ( this )  ;", "this . persistTimer ( timer ,    true )  ;", "this . startTimer ( timer )  ;", "return   timer ;", "}", "METHOD_END"], "methodName": ["createCalendarTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . isLifecycleCallbackInvocation (  )  )     &  &     (  !  ( this . isSingletonBeanInvocation (  )  )  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failToCreateTimerDoLifecycle (  )  ;", "}", "if    ( initialExpiration    =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . initialExpirationIsNull (  )  ;", "}", "if    ( intervalDuration    <     0  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidIntervalDuration (  )  ;", "}", "UUID   uuid    =    UUID . randomUUID (  )  ;", "TimerImpl   timer    =    TimerImpl . builder (  )  . setNewTimer ( true )  . setId ( uuid . toString (  )  )  . setInitialDate ( initialExpiration )  . setRepeatInterval ( intervalDuration )  . setInfo ( info )  . setPersistent ( persistent )  . setPrimaryKey ( currentPrimaryKey (  )  )  . settate ( tate . CREATED )  . setTimedObjectId ( getInvoker (  )  . getTimedObjectId (  )  )  . build ( this )  ;", "this . persistTimer ( timer ,    true )  ;", "this . startTimer ( timer )  ;", "return   timer ;", "}", "METHOD_END"], "methodName": ["createTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["currentPrimaryKey"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "suspendTimers (  )  ;", "}", "METHOD_END"], "methodName": ["deactivate"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( same ( expression 1  . getDayOfMonth (  )  ,    expression 2  . getDayOfMonth (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getDayOfWeek (  )  ,    expression 2  . getDayOfWeek (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getEnd (  )  ,    expression 2  . getEnd (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getHour (  )  ,    expression 2  . getHour (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getMinute (  )  ,    expression 2  . getMinute (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getMonth (  )  ,    expression 2  . getMonth (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getSecond (  )  ,    expression 2  . getSecond (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getStart (  )  ,    expression 2  . getStart (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getzone (  )  ,    expression 2  . getzone (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( same ( expression 1  . getYear (  )  ,    expression 2  . getYear (  )  )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["doesScheduleMatch"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( timeoutMethod . getName (  )  . equals ( timeoutMethodName )  )     =  =    false )     {", "return   false ;", "}", "final   Class <  ?  >  [  ]    timeoutMethodParams    =    timeoutMethod . getParameterTypes (  )  ;", "return   this . methodParamsMatch ( timeoutMethodParams ,    methodParams )  ;", "}", "METHOD_END"], "methodName": ["doesTimeoutMethodMatch"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "this . cancelTimeout ( timer )  ;", "timer . setTimerState ( TimerState . EXPIRED )  ;", "this . unregisterTimerResource ( timer . getId (  )  )  ;", "this . remove ( timer . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["expireTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   timedObjectId    =    this . getInvoker (  )  . getTimedObjectId (  )  ;", "if    (  ( timerPersistence . getOptionalValue (  )  )     =  =    null )     {", "return   Collections . emptyList (  )  ;", "}", "final   List < TimerImpl >    persistedTimers    =    timerPersistence . getValue (  )  . loadActiveTimers ( timedObjectId ,    this )  ;", "final   List < TimerImpl >    activeTimers    =    new   ArrayList < TimerImpl >  (  )  ;", "for    ( final   TimerImpl   persistedTimer    :    persistedTimers )     {", "if    (  . ineligibleTimerStates . contains ( persistedTimer . getState (  )  )  )     {", "continue ;", "}", "activeTimers . add ( persistedTimer )  ;", "}", "return   activeTimers ;", "}", "METHOD_END"], "methodName": ["getActivePersistentTimers"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   ejbComponentInjectedValue ;", "}", "METHOD_END"], "methodName": ["getEjbComponentInjectedValue"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   executorServiceInjectedValue ;", "}", "METHOD_END"], "methodName": ["getExecutorServiceInjectedValue"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   timedObjectInvoker . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getInvoker"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   timedObjectInvoker ;", "}", "METHOD_END"], "methodName": ["getTimedObjectInvoker"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   timers . get ( timerId )  ;", "}", "METHOD_END"], "methodName": ["getTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "TimerHandleImpl   timerHandle    =     (  ( TimerHandleImpl )     ( handle )  )  ;", "TimerImpl   timer    =     . get ( timerHandle . getId (  )  )  ;", "if    ( timer    !  =    null )     {", "return   timer ;", "}", "return   getWaitingOnTxCompletionTimers (  )  . get ( timerHandle . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   timerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getTimerInjectedValue"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   timerPersistence ;", "}", "METHOD_END"], "methodName": ["getTimerPersistence"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   ContextTransactionManager . getInstance (  )  . getTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["getTransaction"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TimerImpl >    timers    =    null ;", "if    (  ( getTransaction (  )  )     !  =    null )     {", "timers    =     (  ( Map < String ,    TimerImpl >  )     ( ContextTransactionSynchronizationRegistry . getInstance (  )  . getResource ( waitingOnTxCompletionKey )  )  )  ;", "}", "return   timers    =  =    null    ?    Collections .  < String ,    TimerImpl > emptyMap (  )     :    timers ;", "}", "METHOD_END"], "methodName": ["getWaitingOnTxCompletionTimers"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   CurrentSynchronizationCallback . CallbackType   type    =    CurrentSynchronizationCallback . get (  )  ;", "if    ( type    !  =    null )     {", "return   type    =  =     ( CurrentSynchronizationCallback . CallbackType . BEFORE _ COMPLETION )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isBeforeCompletion"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   currentInvocationContext    =    CurrentInvocationContext . get (  )  ;", "if    ( currentInvocationContext    =  =    null )     {", "return   false ;", "}", "Method   invokedMethod    =    currentInvocationContext . getMethod (  )  ;", "if    ( invokedMethod    =  =    null )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isLifecycleCallbackInvocation"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . scheduledTimerFutures )     {", "return   this . scheduledTimerFutures . containsKey ( tid )  ;", "}", "}", "METHOD_END"], "methodName": ["isScheduled"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( ejbComponentInjectedValue . getValue (  )  )    instanceof   SingletonComponent ;", "}", "METHOD_END"], "methodName": ["isSingletonBeanInvocation"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   started ;", "}", "METHOD_END"], "methodName": ["isStarted"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . createCalendarTimer ( schedule ,    timerConfig . getInfo (  )  ,    timerConfig . isPersistent (  )  ,    timeoutMethod )  ;", "}", "METHOD_END"], "methodName": ["loadAutoTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( otherMethodParams    =  =    null )     {", "otherMethodParams    =    new   String [  0  ]  ;", "}", "if    (  ( methodParams . length )     !  =     ( otherMethodParams . length )  )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <     ( methodParams . length )  ;    i +  +  )     {", "if    (  !  ( methodParams [ i ]  . getName (  )  . equals ( otherMethodParams [ i ]  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["methodParamsMatch"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if       =  =    null )     {", "return ;", "}", "if    . isTimerPersistent (  )  )     {", "try    {", "if    ( Persistence . getOptionalValue (  )  )     =  =    null )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGERPersistenceNotEnable (  )  ;", "return ;", "}", "if    ( newTimer )     {", "Persistence . getValue (  )  . addTimer )  ;", "} else    {", "Persistence . getValue (  )  . persistTimer )  ;", "}", "}    catch    ( Throwable   t )     {", "this . setRollbackOnly (  )  ;", "throw   new   RuntimeException ( t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["persistTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Transaction   tx    =    this . getTransaction (  )  ;", "tx . registerSynchronization ( synchronization )  ;", "}    catch    ( RollbackException   e )     {", "throw   new   EJBException ( e )  ;", "}    catch    ( SystemException   e )     {", "throw   new   EJBException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["registerSynchronization"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "this . resource . timerCreated ( timerId )  ;", "}", "METHOD_END"], "methodName": ["registerTimerResource"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "List < TimerImpl >    restorableTimers    =    this . getActivePersistentTimers (  )  ;", "final   List < ScheduleTimer >    newAutoTimers    =    new   LinkedList < ScheduleTimer >  ( autoTimers )  ;", "if    ( EjbLogger . EJB 3  _ TIMER _ LOGGER . isDebugEnabled (  )  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debug (  (  (  (  \" Found    \"     +     ( restorableTimers . size (  )  )  )     +     \"    active   persistentTimers   for   timedObjectId :     \"  )     +     ( getInvoker (  )  . getTimedObjectId (  )  )  )  )  ;", "}", "for    ( final   TimerImpl   activeTimer    :    restorableTimers )     {", "if    ( activeTimer . isAutoTimer (  )  )     {", "CalendarTimer   calendarTimer    =     (  ( CalendarTimer )     ( activeTimer )  )  ;", "boolean   found    =    false ;", "ListIterator < ScheduleTimer >    it    =    newAutoTimers . listIterator (  )  ;", "while    ( it . hasNext (  )  )     {", "ScheduleTimer   timer    =    it . next (  )  ;", "final   String   methodName    =    timer . getMethod (  )  . getName (  )  ;", "final   String [  ]    params    =    new   String [ timer . getMethod (  )  . getParameterTypes (  )  . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( timer . getMethod (  )  . getParameterTypes (  )  . length )  ;     +  + i )     {", "params [ i ]     =    timer . getMethod (  )  . getParameterTypes (  )  [ i ]  . getName (  )  ;", "}", "if    ( doesTimeoutMethodMatch ( calendarTimer . getTimeoutMethod (  )  ,    methodName ,    params )  )     {", "if    (  ( this . doesScheduleMatch ( calendarTimer . getScheduleExpression (  )  ,    timer . getScheduleExpression (  )  )  )     &  &     ( timer . getTimerConfig (  )  . isPersistent (  )  )  )     {", "it . remove (  )  ;", "found    =    true ;", "break ;", "}", "}", "}", "if    (  ! found )     {", "activeTimer . setTimerState ( TimerState . CANCELED )  ;", "} else    {", "activeTimer . setTimerState ( TimerState . ACTIVE )  ;", "}", "try    {", "this . persistTimer ( activeTimer ,    false )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failedToPersistTimerOnStartup ( activeTimer ,    e )  ;", "}", "if    ( found )     {", "startTimer ( activeTimer )  ;", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debugv (  \" Started   timer :     {  0  }  \"  ,    activeTimer )  ;", "}", "} else", "if    (  !  (  . ineligibleTimerStates . contains ( activeTimer . getState (  )  )  )  )     {", "startTimer ( activeTimer )  ;", "}", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debugv (  \" Started   timer :     {  0  }  \"  ,    activeTimer )  ;", "}", "for    ( ScheduleTimer   timer    :    newAutoTimers )     {", "this . loadAutoTimer ( timer . getScheduleExpression (  )  ,    timer . getTimerConfig (  )  ,    timer . getMethod (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["restoreTimers"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( i 1     =  =    null )     &  &     ( i 2     !  =    null )  )     {", "return   fal ;", "}", "if    (  ( i 2     =  =    null )     &  &     ( i 1     !  =    null )  )     {", "return   fal ;", "}", "if    (  ( i 1     =  =    null )     &  &     ( i 2     =  =    null )  )     {", "return   true ;", "}", "return   i 1  . equals ( i 2  )  ;", "}", "METHOD_END"], "methodName": ["same"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( scheduledTimerFutures )     {", "if    (  (  ! newTimer )     &  &     (  !  ( scheduledTimerFutures . containsKey ( timer . getId (  )  )  )  )  )     {", "return ;", "}", "Date   nextExpiration    =    timer . getNextExpiration (  )  ;", "if    ( nextExpiration    =  =    null )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . nextExpirationIsNull ( timer )  ;", "return ;", "}", "final   TimerTask <  ?  >    timerTask    =    timer . getTimerTask (  )  ;", "long   delay    =     ( nextExpiration . getTime (  )  )     -     ( System . currentTimeMillis (  )  )  ;", "if    ( delay    <     0  )     {", "delay    =     0  ;", "}", "long   intervalDuration    =    timer . getInterval (  )  ;", "final    . Task   task    =    new    . Task ( timerTask ,    ejbComponentInjectedValue . getValue (  )  . getControlPoint (  )  )  ;", "if    ( intervalDuration    >     0  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debugv (  \" Scheduling   timer    {  0  }    at   fixed   rate ,    starting   at    {  1  }    milliseconds   from   now   with   repeated   interval =  {  2  }  \"  ,    timer ,    delay ,    intervalDuration )  ;", "this . timerInjectedValue . getValue (  )  . scheduleAtFixedRate ( task ,    delay ,    intervalDuration )  ;", "this . scheduledTimerFutures . put ( timer . getId (  )  ,    task )  ;", "} else    {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debugv (  \" Scheduling   a   single   action   timer    {  0  }    starting   at    {  1  }    milliseconds   from   now \"  ,    timer ,    delay )  ;", "this . timerInjectedValue . getValue (  )  . schedule ( task ,    delay )  ;", "this . scheduledTimerFutures . put ( timer . getId (  )  ,    task )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["scheduleTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "Transacon   tx    =    ContextTransaconManager . getInstance (  )  . getTransacon (  )  ;", "if    ( tx    !  =    null )     {", "tx . setRollbackOnly (  )  ;", "}", "}    catch    ( IllegalStateExcepon   ise )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . ignoringExcepon ( ise )  ;", "}    catch    ( SystemExcepon   se )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . ignoringExcepon ( se )  ;", "}", "}", "METHOD_END"], "methodName": ["setRollbackOnly"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( timer . isTimerPersistent (  )  )  )     |  |     ( timerPersistence . getValue (  )  . shouldRun ( timer ,    ContextTransactionManager . getInstance (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldRun"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( transactionActive (  )  )  )     {", "this . timers . put ( timer . getId (  )  ,    timer )  ;", "timer . setTimerState ( TimerState . ACTIVE )  ;", "this . registerTimerResource ( timer . getId (  )  )  ;", "timer . scheduleTimeout ( true )  ;", "} else    {", "addWaitingOnTxCompletionTimer ( timer )  ;", "registerSynchronization ( new    . TimerCreationTransactionSynchronization ( timer )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startTimer"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "Collection < Timer >    timers    =    this . getTimers (  )  ;", "for    ( Timer   timer    :    timers )     {", "if    (  !  ( timer   instanceof   TimerImpl )  )     {", "continue ;", "}", "(  ( TimerImpl )     ( timer )  )  . suspend (  )  ;", "}", "}", "METHOD_END"], "methodName": ["suspendTimers"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "final   Transaction   currentTx    =    getTransaction (  )  ;", "if    ( currentTx    !  =    null )     {", "try    {", "int   status    =    currentTx . getStatus (  )  ;", "if    (  (  (  (  (  (  ( status    =  =     ( Status . STATUS _ MARKED _ ROLLBACK )  )     |  |     ( status    =  =     ( Status . STATUS _ ROLLEDBACK )  )  )     |  |     ( status    =  =     ( Status . STATUS _ ROLLING _ BACK )  )  )     |  |     ( status    =  =     ( Status . STATUS _ NO _ TRANSACTION )  )  )     |  |     ( status    =  =     ( Status . STATUS _ UNKNOWN )  )  )     |  |     ( status    =  =     ( Status . STATUS _ COMMITTED )  )  )     |  |     ( isBeforeCompletion (  )  )  )     {", "return   false ;", "} else    {", "return   true ;", "}", "}    catch    ( SystemException   e )     {", "throw   new   RunException ( e )  ;", "}", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["transactionActive"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "this . resource . timerRemoved ( timerId )  ;", "}", "METHOD_END"], "methodName": ["unregisterTimerResource"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   dataStoreName ;", "}", "METHOD_END"], "methodName": ["getDataStoreName"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceMetaData"}, {"methodBody": ["METHOD_START", "{", "this . dataStoreName    =    dataStoreName ;", "}", "METHOD_END"], "methodName": ["setDataStoreName"], "fileName": "org.jboss.as.ejb3.timerservice.TimerServiceMetaData"}, {"methodBody": ["METHOD_START", "{", "long   intervalDuration    =    timer . getInterval (  )  ;", "if    ( intervalDuration    >     0  )     {", "long   now    =    new   Date (  )  . getTime (  )  ;", "long   nextExpiration    =    timer . getNextExpiration (  )  . getTime (  )  ;", "int   periods    =     (  ( int )     (  ( now    -    nextExpiration )     /    intervalDuration )  )  ;", "return   new   Date (  (  ( nextExpiration    +     ( periods    *    intervalDuration )  )     +    intervalDuration )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["calculateNextTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerTask"}, {"methodBody": ["METHOD_START", "{", "invokeBeanMethod ( timer )  ;", "}", "METHOD_END"], "methodName": ["callTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerTask"}, {"methodBody": ["METHOD_START", "{", "cancelled    =    true ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.jboss.as.ejb3.timerservice.TimerTask"}, {"methodBody": ["METHOD_START", "{", "timerService . getInvoker (  )  . callTimeout ( timer )  ;", "}", "METHOD_END"], "methodName": ["invokeBeanMethod"], "fileName": "org.jboss.as.ejb3.timerservice.TimerTask"}, {"methodBody": ["METHOD_START", "{", "timer . lock (  )  ;", "try    {", "TimerState   timerState    =    timer . getState (  )  ;", "if    (  ( timerState    !  =     ( TimerState . CANCELED )  )     &  &     ( timerState    !  =     ( TimerState . EXPIRED )  )  )     {", "if    (  ( timer . getInterval (  )  )     =  =     0  )     {", "timerSexpireTimer ( timer )  ;", "} else    {", "timer . setTimerState ( TimerState . ACTIVE )  ;", "}", "timerSpersistTimer ( timer ,    false )  ;", "}", "}    finally    {", "timer . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["postTimeoutProcessing"], "fileName": "org.jboss.as.ejb3.timerservice.TimerTask"}, {"methodBody": ["METHOD_START", "{", "boolean   callTimeout    =    false ;", "timer . lock (  )  ;", "try    {", "if    ( timer . isActive (  )  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . retryingTimeout ( timer )  ;", "timer . setTimerState ( TimerState . RETRY _ TIMEOUT )  ;", "timerSpersistTimer ( timer ,    false )  ;", "callTimeout    =    true ;", "} else    {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . timerNotActive ( timer )  ;", "}", "}    finally    {", "timer . unlock (  )  ;", "}", "if    ( callTimeout )     {", "this . callTimeout ( timer )  ;", "}", "}", "METHOD_END"], "methodName": ["retryTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.TimerTask"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . calendarTimeout )     =  =    null )     {", "this . calendarTimeout    =    new   CalendarBasedTimeout ( this . getScheduleExpression (  )  )  ;", "}", "return   this . calendarTimeout ;", "}", "METHOD_END"], "methodName": ["getCalendarTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprDayOfMonth ;", "}", "METHOD_END"], "methodName": ["getDayOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprDayOfWeek ;", "}", "METHOD_END"], "methodName": ["getDayOfWeek"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprEndDate ;", "}", "METHOD_END"], "methodName": ["getEndDate"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprHour ;", "}", "METHOD_END"], "methodName": ["getHour"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprMinute ;", "}", "METHOD_END"], "methodName": ["getMinute"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprMonth ;", "}", "METHOD_END"], "methodName": ["getMonth"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpression )     =  =    null )     {", "this . scheduleExpression    =    new   ScheduleExpression (  )  ;", "this . scheduleExpression . second ( this . scheduleExprSecond )  . minute ( this . scheduleExprMinute )  . hour ( this . scheduleExprHour )  . dayOfWeek ( this . scheduleExprDayOfWeek )  . dayOfMonth ( this . scheduleExprDayOfMonth )  . month ( this . scheduleExprMonth )  . year ( this . scheduleExprYear ) zone ( this . scheduleExprTimezone )  . start ( this . scheduleExprStartDate )  . end ( this . scheduleExprEndDate )  ;", "}", "return   scheduleExpression ;", "}", "METHOD_END"], "methodName": ["getScheduleExpression"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprSecond ;", "}", "METHOD_END"], "methodName": ["getSecond"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprStartDate ;", "}", "METHOD_END"], "methodName": ["getStartDate"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   timeoutMethod ;", "}", "METHOD_END"], "methodName": ["getTimeoutMethod"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprTimezone ;", "}", "METHOD_END"], "methodName": ["getTimezone"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExprYear ;", "}", "METHOD_END"], "methodName": ["getYear"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   autoTimer ;", "}", "METHOD_END"], "methodName": ["isAutoTimer"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.CalendarTimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   declaringClass ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimeoutMethod"}, {"methodBody": ["METHOD_START", "{", "return   methodName ;", "}", "METHOD_END"], "methodName": ["getMethodName"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimeoutMethod"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . methodParams )     =  =    null )     {", "return   null ;", "}", "return   methodParams . toArray ( new   String [  ]  {        }  )  ;", "}", "METHOD_END"], "methodName": ["getMethodParams"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimeoutMethod"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . info ;", "}", "METHOD_END"], "methodName": ["getInfo"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   initialDate ;", "}", "METHOD_END"], "methodName": ["getInitialDate"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   repeatInterval ;", "}", "METHOD_END"], "methodName": ["getInterval"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   nextDate ;", "}", "METHOD_END"], "methodName": ["getNextDate"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   previousRun ;", "}", "METHOD_END"], "methodName": ["getPreviousRun"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   primaryKey ;", "}", "METHOD_END"], "methodName": ["getPrimaryKey"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   timedObjectId ;", "}", "METHOD_END"], "methodName": ["getTimedObjectId"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   timerState ;", "}", "METHOD_END"], "methodName": ["getTimerState"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCalendarTimer"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.TimerEntity"}, {"methodBody": ["METHOD_START", "{", "String   loadTimer    =    sql ( DatabaseTimerPersistence . LOAD _ TIMER )  ;", "Connection   connection    =    null ;", "Statement   statement    =    null ;", "PreparedStatement   preparedStatement    =    null ;", "ResultSet   resultSet    =    null ;", "try    {", "connection    =    dataSource . getConnection (  )  ;", "if    (  ( connection . getTransactionIsolation (  )  )     <     ( Connection . TRANSACTION _ READ _ COMMITTED )  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . wrongTransactionIsolationConfiguredForTimer (  )  ;", "}", "preparedStatement    =    connection . prepareStatement ( loadTimer )  ;", "preparedStatement . setString (  1  ,     \" NON - EXISTENT \"  )  ;", "preparedStatement . setString (  2  ,     \" NON - EXISTENT \"  )  ;", "preparedStatement . setString (  3  ,     \" NON - EXISTENT \"  )  ;", "resultSet    =    preparedStatement . executeQuery (  )  ;", "}    catch    ( SQLException   e )     {", "if    ( connection    !  =    null )     {", "try    {", "String   createTable    =    sql ( DatabaseTimerPersistence . CREATE _ TABLE )  ;", "String [  ]    statements    =    createTable . split (  \"  ;  \"  )  ;", "for    ( final   String   sql    :    statements )     {", "try    {", "statement    =    connection . createStatement (  )  ;", "statement . executeUpdate ( sql )  ;", "}    finally    {", "DatabaseTimerPersistence . safeClose ( statement )  ;", "}", "}", "}    catch    ( SQLException   e 1  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . couldNotCreateTable ( e 1  )  ;", "}", "} else    {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . couldNotCreateTable ( e )  ;", "}", "}    finally    {", "DatabaseTimerPersistence . safeClose ( resultSet )  ;", "DatabaseTimerPersistence . safeClose ( preparedStatement )  ;", "DatabaseTimerPersistence . safeClose ( statement )  ;", "DatabaseTimerPersistence . safeClose ( connection )  ;", "}", "}", "METHOD_END"], "methodName": ["checkDatabase"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    ( data    =  =    null )     {", "return   null ;", "}", "InputStream   in    =    new   ByteArrayInputStream ( Base 6  4  . getDecoder (  )  . decode ( data )  )  ;", "try    {", "final   Unmarshaller   unmarshaller    =    factory . createUnmarshaller ( configuration )  ;", "unmarshaller . start ( new   InputStreamByteInput ( in )  )  ;", "Object   ret    =    unmarshaller . readObject (  )  ;", "unmarshaller . finish (  )  ;", "return   ret ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    finally    {", ". safeClose ( in )  ;", "}", "}", "METHOD_END"], "methodName": ["deSerialize"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   prop    :    sql . keySet (  )  )     {", "int   dot    =     (  ( String )     ( prop )  )  . indexOf (  '  .  '  )  ;", "if    ( dot    >     0  )     {", "Dialects . add (  (  ( String )     ( prop )  )  . substring (  ( dot    +     1  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["extractDialects"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   dataSourceInjectedValue ;", "}", "METHOD_END"], "methodName": ["getDataSourceInjectedValue"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   moduleLoader ;", "}", "METHOD_END"], "methodName": ["getModuleLoader"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   timerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getTimerInjectedValue"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "String   unified    =    null ;", "if    ( name    !  =    null )     {", "if    ( name . toLowerCase (  )  . contains (  \" postgres \"  )  )     {", "unified    =     \" postgresql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" mysql \"  )  )     {", "unified    =     \" mysql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" db 2  \"  )  )     {", "unified    =     \" db 2  \"  ;", "} else", "if    (  ( name . toLowerCase (  )  . contains (  \" hsql \"  )  )     |  |     ( name . toLowerCase (  )  . contains (  \" hyonic \"  )  )  )     {", "unified    =     \" hsql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" h 2  \"  )  )     {", "unified    =     \" h 2  \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" oracle \"  )  )     {", "unified    =     \" oracle \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" microsoft \"  )  )     {", "unified    =     \" mssql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" jconnect \"  )  )     {", "unified    =     \" sybase \"  ;", "}", "}", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debugf (  \" Check   dialect   for    '  % s '  ,    result   is    '  % s '  \"  ,    name ,    unified )  ;", "return   unified ;", "}", "METHOD_END"], "methodName": ["identifyDialect"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "Connection   connection    =    null ;", "if    (  ( database )     =  =    null )     {", "try    {", "connection    =    dataSource . getConnection (  )  ;", "DatabaseMetaData   metaData    =    connection . getMetaData (  )  ;", "String   dbProduct    =    metaData . getDatabaseProductName (  )  ;", "database    =    identifyDialect ( dbProduct )  ;", "if    (  ( database )     =  =    null )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debug (  \" Attempting   to   guess   on   driver   name .  \"  )  ;", "database    =    identifyDialect ( metaData . getDriverName (  )  )  ;", "}", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debug (  \" Unable   to   read   JDBC   metadata .  \"  ,    e )  ;", "}    finally    {", ". safeClose ( connection )  ;", "}", "if    (  ( database )     =  =    null )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . jdbcDatabaseDialectDetectionFailed ( databaseDialects . toString (  )  )  ;", "} else    {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debugf (  \" Detect   database   dialect   as    '  % s '  .       If   this   is   incorrect ,    please   specify   the   correct   dialect   using   the    ' database '    attribute   in   your   configuration .       Supported   database   dialect   strings   are    % s \"  ,    database ,    databaseDialects )  ;", "}", "} else    {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . debugf (  \" Database   dialect    '  % s '    read   from   configuration \"  ,    database )  ;", "}", "}", "METHOD_END"], "methodName": ["investigateDialect"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( resour !  =    null )     {", "resourclose (  )  ;", "}", "}    catch    ( Throwable   t )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . tra ( t ,     \" Closing   resourfailed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( resour !  =    null )     {", "resourclose (  )  ;", "}", "}    catch    ( Throwable   t )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . tra ( t ,     \" Closing   resourfailed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( resour !  =    null )     {", "resourclose (  )  ;", "}", "}    catch    ( Throwable   t )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . tra ( t ,     \" Closing   resourfailed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( resour !  =    null )     {", "resourclose (  )  ;", "}", "}    catch    ( Throwable   t )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . tra ( t ,     \" Closing   resourfailed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    ( date    =  =    null )     {", "return   null ;", "}", "return   new   SimpleDateFormat (  . SCHEDULER _ DATE _ FORMAT )  . format ( date )  ;", "}", "METHOD_END"], "methodName": ["schedulerDateAsString"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    ( serializable    =  =    null )     {", "return   null ;", "}", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "try    {", "final   Marshaller   marshaller    =    factory . createMarshaller ( configuration )  ;", "marshaller . start ( new   OutputStreamByteOutput ( out )  )  ;", "marshaller . writeObject ( serializable )  ;", "marshaller . finish (  )  ;", "out . flush (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   RunException ( e )  ;", "}", "return   Base 6  4  . getEncoder (  )  . encodeToString ( out . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    (  ( timerState    =  =     ( TimerState . IN _ TIMEOUT )  )     |  |     ( timerState    =  =     ( TimerState . RETRY _ TIMEOUT )  )  )     {", "statement . setString ( paramIndex ,    nodeName )  ;", "} else    {", "statement . setNull ( paramIndex ,    Types . VARCHAR )  ;", "}", "}", "METHOD_END"], "methodName": ["setNodeName"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    (  ( database )     !  =    null )     {", "String   result    =    sql . getProperty (  (  ( key    +     \"  .  \"  )     +     ( database )  )  )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "return   sql . getProperty ( key )  ;", "}", "METHOD_END"], "methodName": ["sql"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "statement . setString (  1  ,    timerEntity . getId (  )  )  ;", "statement . setString (  2  ,    timerEntity . getTimedObjectId (  )  )  ;", "statement . setTimestamp (  3  ,    timestamp ( timerEntity . getInitialExpiration (  )  )  )  ;", "statement . setLong (  4  ,    timerEntity . getInterval (  )  )  ;", "statement . setTimestamp (  5  ,    timestamp ( timerEntity . getNextExpiration (  )  )  )  ;", "statement . setTimestamp (  6  ,    timestamp ( timerEntity . getPreviousRun (  )  )  )  ;", "statement . setString (  7  ,    serialize (  (  ( Serializable )     ( timerEntity . getPrimaryKey (  )  )  )  )  )  ;", "statement . setString (  8  ,    serialize ( timerEntity . getTimerInfo (  )  )  )  ;", "statement . setString (  9  ,    timerEntity . getState (  )  . name (  )  )  ;", "if    ( timerEntity   instanceof   CalendarTimer )     {", "final   CalendarTimer   c    =     (  ( CalendarTimer )     ( timerEntity )  )  ;", "statement . setString (  1  0  ,    c . getScheduleExpression (  )  . getSecond (  )  )  ;", "statement . setString (  1  1  ,    c . getScheduleExpression (  )  . getMinute (  )  )  ;", "statement . setString (  1  2  ,    c . getScheduleExpression (  )  . getHour (  )  )  ;", "statement . setString (  1  3  ,    c . getScheduleExpression (  )  . getDayOfWeek (  )  )  ;", "statement . setString (  1  4  ,    c . getScheduleExpression (  )  . getDayOfMonth (  )  )  ;", "statement . setString (  1  5  ,    c . getScheduleExpression (  )  . getMonth (  )  )  ;", "statement . setString (  1  6  ,    c . getScheduleExpression (  )  . getYear (  )  )  ;", "statement . setString (  1  7  ,    schedulerDateAsString ( c . getScheduleExpression (  )  . getStart (  )  )  )  ;", "statement . setString (  1  8  ,    schedulerDateAsString ( c . getScheduleExpression (  )  . getEnd (  )  )  )  ;", "statement . setString (  1  9  ,    c . getScheduleExpression (  )  . getTimezone (  )  )  ;", "statement . setBoolean (  2  0  ,    c . isAutoTimer (  )  )  ;", "if    ( c . isAutoTimer (  )  )     {", "statement . setString (  2  1  ,    c . getTimeoutMethod (  )  . getDeclaringClass (  )  . getName (  )  )  ;", "statement . setString (  2  2  ,    c . getTimeoutMethod (  )  . getName (  )  )  ;", "StringBuilder   params    =    new   StringBuilder (  )  ;", "final   Class <  ?  >  [  ]    parameterTypes    =    c . getTimeoutMethod (  )  . getParameterTypes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( parameterTypes . length )  ;     +  + i )     {", "params . append ( parameterTypes [ i ]  . getName (  )  )  ;", "if    ( i    !  =     (  ( parameterTypes . length )     -     1  )  )     {", "params . append (  \"  ;  \"  )  ;", "}", "}", "statement . setString (  2  3  ,    params . toString (  )  )  ;", "} else    {", "statement . setString (  2  1  ,    null )  ;", "statement . setString (  2  2  ,    null )  ;", "statement . setString (  2  3  ,    null )  ;", "}", "statement . setBoolean (  2  4  ,    true )  ;", "} else    {", "statement . setString (  1  0  ,    null )  ;", "statement . setString (  1  1  ,    null )  ;", "statement . setString (  1  2  ,    null )  ;", "statement . setString (  1  3  ,    null )  ;", "statement . setString (  1  4  ,    null )  ;", "statement . setString (  1  5  ,    null )  ;", "statement . setString (  1  6  ,    null )  ;", "statement . setTimestamp (  1  7  ,    null )  ;", "statement . setTimestamp (  1  8  ,    null )  ;", "statement . setString (  1  9  ,    null )  ;", "statement . setBoolean (  2  0  ,    false )  ;", "statement . setString (  2  1  ,    null )  ;", "statement . setString (  2  2  ,    null )  ;", "statement . setString (  2  3  ,    null )  ;", "statement . setBoolean (  2  4  ,    false )  ;", "}", "statement . setString (  2  5  ,    partition )  ;", "setNodeName ( timerEntity . getState (  )  ,    statement ,     2  6  )  ;", "}", "METHOD_END"], "methodName": ["statementParameters"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    ( date    =  =    null )     {", "return   null ;", "}", "try    {", "return   new   SimpleDateFormat (  . SCHEDULER _ DATE _ FORMAT )  . parse ( date )  ;", "}    catch    ( ParseException   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . scheduleExpressionDateFromTimerPersistenceInvalid ( timerId ,    e . getMessage (  )  )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["stringAsSchedulerDate"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "boolean   calendarTimer    =    resultSet . getBoolean (  2  4  )  ;", "final   String   nodeName    =    resultSet . getString (  2  5  )  ;", "boolean   requiresReset    =    false ;", "TimerImpl . Builder   builder    =    null ;", "final   String   timerId    =    resultSet . getString (  1  )  ;", "if    ( calendarTimer )     {", "CalendarTimer . Builder   cb    =    CalendarTimer . builder (  )  ;", "builder    =    cb ;", "cb . setScheduleExprSecond ( resultSet . getString (  1  0  )  )  ;", "cb . setScheduleExprMinute ( resultSet . getString (  1  1  )  )  ;", "cb . setScheduleExprHour ( resultSet . getString (  1  2  )  )  ;", "cb . setScheduleExprDayOfWeek ( resultSet . getString (  1  3  )  )  ;", "cb . setScheduleExprDayOfMonth ( resultSet . getString (  1  4  )  )  ;", "cb . setScheduleExprMonth ( resultSet . getString (  1  5  )  )  ;", "cb . setScheduleExprYear ( resultSet . getString (  1  6  )  )  ;", "cb . setScheduleExprStartDate ( stringAsSchedulerDate ( resultSet . getString (  1  7  )  ,    timerId )  )  ;", "cb . setScheduleExprEndDate ( stringAsSchedulerDate ( resultSet . getString (  1  8  )  ,    timerId )  )  ;", "cb . setScheduleExprTimezone ( resultSet . getString (  1  9  )  )  ;", "cb . setAutoTimer ( resultSet . getBoolean (  2  0  )  )  ;", "final   String   clazz    =    resultSet . getString (  2  1  )  ;", "final   String   methodName    =    resultSet . getString (  2  2  )  ;", "if    ( methodName    !  =    null )     {", "final   String   paramString    =    resultSet . getString (  2  3  )  ;", "final   String [  ]    params    =     (  ( paramString    =  =    null )     |  |     ( paramString . isEmpty (  )  )  )     ?    new   String [  0  ]     :    paramString . split (  \"  ;  \"  )  ;", "final   Method   timeoutMethod    =    CalendarTimer . getTimeoutMethod ( new   TimeoutMethod ( clazz ,    methodName ,    params )  ,    timerService . getTimedObjectInvoker (  )  . getValue (  )  . getClassLoader (  )  )  ;", "if    ( timeoutMethod    =  =    null )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . timerReinstatementFailed ( resultSet . getString (  2  )  ,    resultSet . getString (  1  )  ,    new   NoSuchMethodException (  )  )  ;", "return   null ;", "}", "cb . setTimeoutMethod ( timeoutMethod )  ;", "}", "} else    {", "builder    =    TimerImpl . builder (  )  ;", "}", "builder . setId ( timerId )  ;", "builder . setTimedObjectId ( resultSet . getString (  2  )  )  ;", "builder . setInitialDate ( resultSet . getTimestamp (  3  )  )  ;", "builder . setRepeatInterval ( resultSet . getLong (  4  )  )  ;", "builder . setNextDate ( resultSet . getTimestamp (  5  )  )  ;", "builder . setPreviousRun ( resultSet . getTimestamp (  6  )  )  ;", "builder . setPrimaryKey ( deSerialize ( resultSet . getString (  7  )  )  )  ;", "builder . setInfo (  (  ( Serializable )     ( deSerialize ( resultSet . getString (  8  )  )  )  )  )  ;", "builder . setTimerState ( TimerState . valueOf ( resultSet . getString (  9  )  )  )  ;", "builder . setPersistent ( true )  ;", "TimerImpl   ret    =    builder . build ( timerService )  ;", "if    (  ( nodeName    !  =    null )     &  &     ( nodeName . equals ( this . nodeName )  )  )     {", "if    (  (  ( ret . getState (  )  )     =  =     ( TimerState . IN _ TIMEOUT )  )     |  |     (  ( ret . getState (  )  )     =  =     ( TimerState . RETRY _ TIMEOUT )  )  )     {", "requiresReset    =    true ;", "}", "}", "return   new    . Holder ( ret ,    requiresReset )  ;", "}", "METHOD_END"], "methodName": ["timerFromResult"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    ( date    =  =    null )     {", "return   null ;", "}", "long   time    =    date . getTime (  )  ;", "if    (  (  (     !  =    null )     &  &     ( equals (  \" mysql \"  )  )  )     {", "time    -  =    time    %     1  0  0  0  ;", "}", "return   new   Timestamp ( time )  ;", "}", "METHOD_END"], "methodName": ["timestamp"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.database.DatabaseTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    data    =    Base 6  4  . getDecoder (  )  . decode ( info . trim (  )  )  ;", "Unmarshaller   unmarshaller    =    facy . createUnmarshaller ( configuration )  ;", "unmarshaller . start ( new   ByteBufferInput ( ByteBuffer . wrap ( data )  )  )  ;", "try    {", "return   unmarshaller . readObject (  )  ;", "}    finally    {", "unmarshaller . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["deserialize"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlParser_1_0"}, {"methodBody": ["METHOD_START", "{", "boolean   handled    =    true ;", "String   attr    =    reader . getAttributeValue ( i )  ;", "switch    ( reader . getAttributeLocalName ( i )  )     {", "case   ersister . TIMED _ OBJECT _ ID    :", "builder . setTimedObjectId ( attr )  ;", "break ;", "case   ersister . TIMER _ ID    :", "builder . setId ( attr )  ;", "break ;", "case   ersister . INITIAL _ DATE    :", "builder . setInitialDate ( new   Date ( Long . parseLong ( attr )  )  )  ;", "break ;", "case   ersister . NEXT _ DATE    :", "builder . setNextDate ( new   Date ( Long . parseLong ( attr )  )  )  ;", "break ;", "case   ersister . TIMER _ STATE    :", "builder . setTimerState ( TimerState . valueOf ( attr )  )  ;", "break ;", "case   ersister . PREVIOUS _ RUN    :", "builder . setPreviousRun ( new   Date ( Long . parseLong ( attr )  )  )  ;", "break ;", "default    :", "handled    =    false ;", "}", "return   handled ;", "}", "METHOD_END"], "methodName": ["handleCommonAttributes"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlParser_1_0"}, {"methodBody": ["METHOD_START", "{", "boolean   handled    =    false ;", "switch    ( reader . getName (  )  . getLocalPart (  )  )     {", "case   ersister . INFO    :", "{", "builder . info    =    reader . getElementText (  )  ;", "handled    =    true ;", "break ;", "}", "case   ersister . PRIMARY _ KEY    :", "{", "builder . primaryKey    =    reader . getElementText (  )  ;", "handled    =    true ;", "break ;", "}", "}", "return   handled ;", "}", "METHOD_END"], "methodName": ["handleCommonElements"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlParser_1_0"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    required    =    new   HashSet <  >  ( Arrays . asList ( new   String [  ]  {    EjbTimerXmlPersister . TYPE    }  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;     +  + i )     {", "String   attr    =    reader . getAttributeValue ( i )  ;", "String   attrName    =    reader . getAttributeLocalName ( i )  ;", "required . remove ( attrName )  ;", "switch    ( attrName )     {", "case   EjbTimerXmlPersister . TYPE    :", "loadableElements . params . add ( attr )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    required )  ;", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleParam"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlParser_1_0"}, {"methodBody": ["METHOD_START", "{", "EjbTimerXmlParser _  1  _  0  . LoadableElements   loadableElements    =    new   EjbTimerXmlParser _  1  _  0  . LoadableElements (  )  ;", "CalendarTimer . Builder   builder    =    CalendarTimer . builder (  )  ;", "builder . setAutoTimer ( false )  . setPersistent ( true )  ;", "final   Set < String >    required    =    new   HashSet <  >  ( Arrays . asList ( new   String [  ]  {    EjbTimerXmlPersister . TIMED _ OBJECT _ ID ,    EjbTimerXmlPersister . TIMER _ ID ,    EjbTimerXmlPersister . TIMER _ STATE ,    EjbTimerXmlPersister . SCHEDULE _ EXPR _ SECOND ,    EjbTimerXmlPersister . SCHEDULE _ EXPR _ MINUTE ,    EjbTimerXmlPersister . SCHEDULE _ EXPR _ HOUR ,    EjbTimerXmlPersister . SCHEDULE _ EXPR _ DAY _ OF _ WEEK ,    EjbTimerXmlPersister . SCHEDULE _ EXPR _ DAY _ OF _ MONTH ,    EjbTimerXmlPersister . SCHEDULE _ EXPR _ MONTH ,    EjbTimerXmlPersister . SCHEDULE _ EXPR _ YEAR    }  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;     +  + i )     {", "String   attr    =    reader . getAttributeValue ( i )  ;", "String   attrName    =    reader . getAttributeLocalName ( i )  ;", "required . remove ( attrName )  ;", "boolean   handled    =    handleCommonAttributes ( builder ,    reader ,    i )  ;", "if    (  ! handled )     {", "switch    ( attrName )     {", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ SECOND    :", "builder . setScheduleExprSecond ( attr )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ MINUTE    :", "builder . setScheduleExprMinute ( attr )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ HOUR    :", "builder . setScheduleExprHour ( attr )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ DAY _ OF _ WEEK    :", "builder . setScheduleExprDayOfWeek ( attr )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ DAY _ OF _ MONTH    :", "builder . setScheduleExprDayOfMonth ( attr )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ MONTH    :", "builder . setScheduleExprMonth ( attr )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ YEAR    :", "builder . setScheduleExprYear ( attr )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ START _ DATE    :", "builder . setScheduleExprStartDate ( new   Date ( Long . parseLong ( attr )  )  )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ END _ DATE    :", "builder . setScheduleExprEndDate ( new   Date ( Long . parseLong ( attr )  )  )  ;", "break ;", "case   EjbTimerXmlPersister . SCHEDULE _ EXPR _ TIMEZONE    :", "builder . setScheduleExprTimezone ( attr )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    required )  ;", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "try    {", "if    (  ( loadableElements . info )     !  =    null )     {", "builder . setInfo (  (  ( Serializable )     ( deserialize ( loadableElements . info )  )  )  )  ;", "}", "if    (  ( loadableElements . primaryKey )     !  =    null )     {", "builder . setPrimaryKey ( deserialize ( loadableElements . primaryKey )  )  ;", "}", "if    (  ( loadableElements . methodName )     !  =    null )     {", "Method   timeoutMethod    =    CalendarTimer . getTimeoutMethod ( new   TimeoutMethod ( loadableElements . className ,    loadableElements . methodName ,    loadableElements . params . toArray ( new   String [ loadableElements . params . size (  )  ]  )  )  ,    classLoader )  ;", "if    ( timeoutMethod    !  =    null )     {", "builder . setTimeoutMethod ( timeoutMethod )  ;", "timers . add ( builder . build ( timerService )  )  ;", "} else    {", "builder . setId (  \" deleted - timer \"  )  ;", "timers . add ( builder . build ( timerService )  )  ;", "EjbLogger . EJB 3  _ TIMER _ LOGGER . timerReinstatementFailed ( builder . getTimedObjectId (  )  ,    builder . getId (  )  ,    null )  ;", "}", "} else    {", "timers . add ( builder . build ( timerService )  )  ;", "}", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . timerReinstatementFailed ( builder . getTimedObjectId (  )  ,    builder . getId (  )  ,    e )  ;", "}", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "boolean   handled    =    handleCommonElements ( reader ,    loadableElements )  ;", "if    (  ! handled )     {", "switch    ( reader . getName (  )  . getLocalPart (  )  )     {", "case   EjbTimerXmlPersister . TIMEOUT _ METHOD    :", "{", "builder . setAutoTimer ( true )  ;", "parseTimeoutMethod ( reader ,    loadableElements )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseCalendarTimer"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlParser_1_0"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    required    =    new   HashSet <  >  ( Arrays . asList ( new   String [  ]  {    EjbTimerXmlPersister . DECLARING _ CLASS ,    EjbTimerXmlPersister . NAME    }  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;     +  + i )     {", "String   attr    =    reader . getAttributeValue ( i )  ;", "String   attrName    =    reader . getAttributeLocalName ( i )  ;", "required . remove ( attrName )  ;", "switch    ( attrName )     {", "case   EjbTimerXmlPersister . DECLARING _ CLASS    :", "loadableElements . className    =    attr ;", "break ;", "case   EjbTimerXmlPersister . NAME    :", "loadableElements . methodName    =    attr ;", "break ;", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    required )  ;", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( reader . getName (  )  . getLocalPart (  )  )     {", "case   EjbTimerXmlPersister . PARAMETER    :", "{", "handleParam ( reader ,    loadableElements )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTimeoutMethod"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlParser_1_0"}, {"methodBody": ["METHOD_START", "{", "EjbTimerXmlParser _  1  _  0  . LoadableElements   loadableElements    =    new   EjbTimerXmlParser _  1  _  0  . LoadableElements (  )  ;", "TimerImpl . Builder   builder    =    TimerImpl . builder (  )  ;", "builder . setPersistent ( true )  ;", "final   Set < String >    required    =    new   HashSet <  >  ( Arrays . asList ( new   String [  ]  {    EjbTimerXmlPersister . TIMED _ OBJECT _ ID ,    EjbTimerXmlPersister . TIMER _ ID ,    EjbTimerXmlPersister . INITIAL _ DATE ,    EjbTimerXmlPersister . REPEAT _ INTERVAL ,    EjbTimerXmlPersister . TIMER _ STATE    }  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;     +  + i )     {", "String   attr    =    reader . getAttributeValue ( i )  ;", "String   attrName    =    reader . getAttributeLocalName ( i )  ;", "required . remove ( attrName )  ;", "boolean   handled    =    handleCommonAttributes ( builder ,    reader ,    i )  ;", "if    (  ! handled )     {", "switch    ( attrName )     {", "case   EjbTimerXmlPersister . REPEAT _ INTERVAL    :", "builder . setRepeatInterval ( Long . parseLong ( attr )  )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    required )  ;", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "try    {", "if    (  ( loadableElements . info )     !  =    null )     {", "builder . setInfo (  (  ( Serializable )     ( deserialize ( loadableElements . info )  )  )  )  ;", "}", "if    (  ( loadableElements . primaryKey )     !  =    null )     {", "builder . setPrimaryKey ( deserialize ( loadableElements . primaryKey )  )  ;", "}", "timers . add ( builder . build ( timerService )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . timerReinstatementFailed ( builder . getTimedObjectId (  )  ,    builder . getId (  )  ,    e )  ;", "}", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "boolean   handled    =    handleCommonElements ( reader ,    loadableElements )  ;", "if    (  ! handled )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTimer"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlParser_1_0"}, {"methodBody": ["METHOD_START", "{", "String   info    =    null ;", "String   primaryKey    =    null ;", "if    (  ( timer . getInfo (  )  )     !  =    null )     {", "try    {", "Marshaller   marshaller    =    factory . createMarshaller ( configuration )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "marshaller . start ( new   OutputStreamByteOutput ( out )  )  ;", "marshaller . writeObject ( timer . getInfo (  )  )  ;", "marshaller . finish (  )  ;", "marshaller . flush (  )  ;", "info    =    Base 6  4  . getEncoder (  )  . encodeToString ( out . toByteArray (  )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failedToPersistTimer ( timer ,    e )  ;", "return ;", "}", "}", "if    (  ( timer . getPrimaryKey (  )  )     !  =    null )     {", "try    {", "Marshaller   marshaller    =    factory . createMarshaller ( configuration )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "marshaller . start ( new   OutputStreamByteOutput ( out )  )  ;", "marshaller . writeObject ( timer . getPrimaryKey (  )  )  ;", "marshaller . finish (  )  ;", "marshaller . flush (  )  ;", "primaryKey    =    Base 6  4  . getEncoder (  )  . encodeToString ( out . toByteArray (  )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failedToPersistTimer ( timer ,    e )  ;", "return ;", "}", "}", "writer . writeStartElement (  . CALENDAR _ TIMER )  ;", "writer . writeAttribute (  . TIMED _ OBJECT _ ID ,    timer . getTimedObjectId (  )  )  ;", "writer . writeAttribute (  . TIMER _ ID ,    timer . getId (  )  )  ;", "if    (  ( timer . getInitialExpiration (  )  )     !  =    null )     {", "writer . writeAttribute (  . INITIAL _ DATE ,    Long . toString ( timer . getInitialExpiration (  )  . getTime (  )  )  )  ;", "}", "if    (  ( timer . getNextExpiration (  )  )     !  =    null )     {", "writer . writeAttribute (  . NEXT _ DATE ,    Long . toString ( timer . getNextExpiration (  )  . getTime (  )  )  )  ;", "}", "writer . writeAttribute (  . TIMER _ STATE ,    timer . getState (  )  . name (  )  )  ;", "writer . writeAttribute (  . SCHEDULE _ EXPR _ SECOND ,    timer . getScheduleExpression (  )  . getSecond (  )  )  ;", "writer . writeAttribute (  . SCHEDULE _ EXPR _ MINUTE ,    timer . getScheduleExpression (  )  . getMinute (  )  )  ;", "writer . writeAttribute (  . SCHEDULE _ EXPR _ HOUR ,    timer . getScheduleExpression (  )  . getHour (  )  )  ;", "writer . writeAttribute (  . SCHEDULE _ EXPR _ DAY _ OF _ WEEK ,    timer . getScheduleExpression (  )  . getDayOfWeek (  )  )  ;", "writer . writeAttribute (  . SCHEDULE _ EXPR _ DAY _ OF _ MONTH ,    timer . getScheduleExpression (  )  . getDayOfMonth (  )  )  ;", "writer . writeAttribute (  . SCHEDULE _ EXPR _ MONTH ,    timer . getScheduleExpression (  )  . getMonth (  )  )  ;", "writer . writeAttribute (  . SCHEDULE _ EXPR _ YEAR ,    timer . getScheduleExpression (  )  . getYear (  )  )  ;", "if    (  ( timer . getScheduleExpression (  )  . getStart (  )  )     !  =    null )     {", "writer . writeAttribute (  . SCHEDULE _ EXPR _ START _ DATE ,    Long . toString ( timer . getScheduleExpression (  )  . getStart (  )  . getTime (  )  )  )  ;", "}", "if    (  ( timer . getScheduleExpression (  )  . getEnd (  )  )     !  =    null )     {", "writer . writeAttribute (  . SCHEDULE _ EXPR _ END _ DATE ,    Long . toString ( timer . getScheduleExpression (  )  . getEnd (  )  . getTime (  )  )  )  ;", "}", "if    (  ( timer . getScheduleExpression (  )  . getTimezone (  )  )     !  =    null )     {", "writer . writeAttribute (  . SCHEDULE _ EXPR _ TIMEZONE ,    timer . getScheduleExpression (  )  . getTimezone (  )  )  ;", "}", "if    ( info    !  =    null )     {", "writer . writeStartElement (  . INFO )  ;", "writer . writeCharacters ( info )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( primaryKey    !  =    null )     {", "writer . writeStartElement (  . PRIMARY _ KEY )  ;", "writer . writeCharacters ( primaryKey )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( timer . isAutoTimer (  )  )     {", "writer . writeStartElement (  . TIMEOUT _ METHOD )  ;", "writer . writeAttribute (  . DECLARING _ CLASS ,    timer . getTimeoutMethod (  )  . getDeclaringClass (  )  . getName (  )  )  ;", "writer . writeAttribute (  . NAME ,    timer . getTimeoutMethod (  )  . getName (  )  )  ;", "for    ( Class <  ?  >    param    :    timer . getTimeoutMethod (  )  . getParameterTypes (  )  )     {", "writer . writeStartElement (  . PARAMETER )  ;", "writer . writeAttribute (  . TYPE ,    param . getName (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeCalendarTimer"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlPersister"}, {"methodBody": ["METHOD_START", "{", "String   info    =    null ;", "String   primaryKey    =    null ;", "if    (  ( timer . getInfo (  )  )     !  =    null )     {", "try    {", "Marshaller   marshaller    =    factory . createMarshaller ( configuration )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "marshaller . start ( new   OutputStreamByteOutput ( out )  )  ;", "marshaller . writeObject ( timer . getInfo (  )  )  ;", "marshaller . finish (  )  ;", "marshaller . flush (  )  ;", "info    =    Base 6  4  . getEncoder (  )  . encodeToString ( out . toByteArray (  )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failedToPersistTimer ( timer ,    e )  ;", "return ;", "}", "}", "if    (  ( timer . getPrimaryKey (  )  )     !  =    null )     {", "try    {", "Marshaller   marshaller    =    factory . createMarshaller ( configuration )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "marshaller . start ( new   OutputStreamByteOutput ( out )  )  ;", "marshaller . writeObject ( timer . getPrimaryKey (  )  )  ;", "marshaller . finish (  )  ;", "marshaller . flush (  )  ;", "primaryKey    =    Base 6  4  . getEncoder (  )  . encodeToString ( out . toByteArray (  )  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failedToPersistTimer ( timer ,    e )  ;", "return ;", "}", "}", "writer . writeStartElement (  . TIMER )  ;", "writer . writeAttribute (  . TIMED _ OBJECT _ ID ,    timer . getTimedObjectId (  )  )  ;", "writer . writeAttribute (  . TIMER _ ID ,    timer . getId (  )  )  ;", "writer . writeAttribute (  . INITIAL _ DATE ,    Long . toString ( timer . getInitialExpiration (  )  . getTime (  )  )  )  ;", "writer . writeAttribute (  . REPEAT _ INTERVAL ,    Long . toString ( timer . getInterval (  )  )  )  ;", "if    (  ( timer . getNextExpiration (  )  )     !  =    null )     {", "writer . writeAttribute (  . NEXT _ DATE ,    Long . toString ( timer . getNextExpiration (  )  . getTime (  )  )  )  ;", "}", "writer . writeAttribute (  . TIMER _ STATE ,    timer . getState (  )  . name (  )  )  ;", "if    ( info    !  =    null )     {", "writer . writeStartElement (  . INFO )  ;", "writer . writeCharacters ( info )  ;", "writer . writeEndElement (  )  ;", "}", "if    ( primaryKey    !  =    null )     {", "writer . writeStartElement (  . PRIMARY _ KEY )  ;", "writer . writeCharacters ( primaryKey )  ;", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeTimer"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.EjbTimerXmlPersister"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    Class . forName (  \" FormattingXMLStreamWriter \"  )  ;", "Constructor <  ?  >    ctr    =    clazz . getConstructor ( XMLStreamWriter . class )  ;", "ctr . setAccessible ( true )  ;", "return    (  ( XMLExtendedStreamWriter )     ( ctr . newInstance ( new   Object [  ]  {    writer    }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "final   XMLMapper   mapper    =    Factory . create (  )  ;", "mapper . registerRootElement ( new   QName ( EjbTimerXmlParser _  1  _  0  . NAMESPACE ,    EjbTimerXmlr . TIMERS )  ,    new   EjbTimerXmlParser _  1  _  0  ( timerService ,    factory ,    configuration ,    timerService . getTimedObjectInvoker (  )  . getValue (  )  . getClassLoader (  )  )  )  ;", "return   mapper ;", "}", "METHOD_END"], "methodName": ["createMapper"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "final   RiverMarshallerFactory   factory    =    new   RiverMarshallerFactory (  )  ;", "final   MarshallingConfiguration   configuration    =    new   MarshallingConfiguration (  )  ;", "configuration . setClassResolver ( ModularClassResolver . getInstance ( moduleLoader . getValue (  )  )  )  ;", "configuration . setVersion (  3  )  ;", "this . configuration    =    configuration ;", "this . factory    =    factory ;", "if    (  ( pathRelativeTo )     !  =    null )     {", "callbackHandle    =    pathManager . getValue (  )  . registerCallback ( pathRelativeTo ,    ReloadServerCallback . create (  )  ,    UPDATED ,    REMOVED )  ;", "}", "baseDir    =    new   File ( pathManager . getValue (  )  . resolveRelativePathEntry ( path ,    pathRelativeTo )  )  ;", "if    (  !  ( baseDir . exists (  )  )  )     {", "if    ( createIfNotExists )     {", "if    (  !  ( baseDir . mkdirs (  )  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . failToCreatFileStoreDir ( baseDir )  ;", "}", "} else    {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . timerFileStoreDirNotExist ( baseDir )  ;", "}", "}", "if    (  !  ( baseDir . isDirectory (  )  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidTimerFileStoreDir ( baseDir )  ;", "}", "}", "METHOD_END"], "methodName": ["doStart"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   new   File (  (  (  (  ( getDirectory ( timedObjectId )  )     +     ( File . separator )  )     +     ( timerId . replace ( File . separator ,     \"  -  \"  )  )  )     +     \"  . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["fileName"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "String   dirName    =    directories . get ( timedObjectId )  ;", "if    ( dirName    =  =    null )     {", "dirName    =     (  ( baseDir . getAbsolutePath (  )  )     +     ( File . separator )  )     +     ( timedObjectId . replace ( File . separator ,     \"  -  \"  )  )  ;", "File   file    =    new   File ( dirName )  ;", "if    (  !  ( file . exists (  )  )  )     {", "if    (  !  ( file . mkdirs (  )  )  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToCreateDirectoryFoTimers ( file )  ;", "}", "}", "directories . put ( timedObjectId ,    dirName )  ;", "}", "return   dirName ;", "}", "METHOD_END"], "methodName": ["getDirectory"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "Lock   lock    =    locks . get ( timedObjectId )  ;", "if    ( lock    =  =    null )     {", "final   Lock   addedLock    =    new   ReentrantLock (  )  ;", "lock    =    locks . putIfAbsent ( timedObjectId ,    addedLock )  ;", "if    ( lock    =  =    null )     {", "lock    =    addedLock ;", "}", "}", "return   lock ;", "}", "METHOD_END"], "methodName": ["getLock"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   moduleLoader ;", "}", "METHOD_END"], "methodName": ["getModuleLoader"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   pathManager ;", "}", "METHOD_END"], "methodName": ["getPathManager"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   loadTimersFromFile ( timedObjectId ,    timerService )  ;", "}", "METHOD_END"], "methodName": ["getTimers"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return   transactionSynchronizationRegistry ;", "}", "METHOD_END"], "methodName": ["getTransactionSynchronizationRegistry"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "final   CurrentSynchronizationCallback . CallbackType   type    =    CurrentSynchronizationCallback . get (  )  ;", "if    ( type    !  =    null )     {", "return   type    =  =     ( CurrentSynchronizationCallback . CallbackType . BEFORE _ COMPLETION )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isBeforeCompletion"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TimerImpl >    timers    =    new   HashMap <  >  (  )  ;", "String   directory    =    getDirectory ( timedObjectId )  ;", "timers . putAll ( LegacyFileStore . loadTimersFromFile ( timedObjectId ,    timerService ,    directory ,    factory ,    configuration )  )  ;", "for    ( Map . Entry < String ,    TimerImpl >    entry    :    timers . entrySet (  )  )     {", "writeFile ( entry . getValue (  )  )  ;", "}", "final   File   file    =    new   File ( directory )  ;", "if    (  !  ( file . exists (  )  )  )     {", "return   timers ;", "} else", "if    (  !  ( file . isDirectory (  )  )  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToRestoreTimers ( file )  ;", "return   timers ;", "}", "final   XMLMapper   mapper    =    createMapper ( timerService )  ;", "for    ( File   timerFile    :    file . listFiles (  )  )     {", "if    (  !  ( timerFile . getName (  )  . endsWith (  \"  . xml \"  )  )  )     {", "continue ;", "}", "FileInputStream   in    =    null ;", "try    {", "in    =    new   FileInputStream ( timerFile )  ;", "final   XMLInputFactory   inputFactory    =     . INPUT _ FACTORY ;", "setIfSupported ( inputFactory ,    XMLInputFactory . IS _ VALIDATING ,    Boolean . FALSE )  ;", "setIfSupported ( inputFactory ,    XMLInputFactory . SUPPORT _ DTD ,    Boolean . FALSE )  ;", "final   XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( in )  ;", "try    {", "List < TimerImpl >    timerList    =    new   ArrayList <  >  (  )  ;", "mapper . parseDocument ( timerList ,    streamReader )  ;", "for    ( TimerImpl   timer    :    timerList )     {", "if    ( timer . getId (  )  . equals (  \" deleted - timer \"  )  )     {", "timerFile . delete (  )  ;", "break ;", "}", "timers . put ( timer . getId (  )  ,    timer )  ;", "}", "}    finally    {", ". safeClose ( in )  ;", "}", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToRestoreTimersFromFile ( timerFile ,    e )  ;", "}    finally    {", "if    ( in    !  =    null )     {", "try    {", "in . close (  )  ;", "}    catch    ( IOException   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToCloseFile ( e )  ;", "}", "}", "}", "}", "return   timers ;", "}", "METHOD_END"], "methodName": ["loadTimersFromFile"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   int   status    =    transactionManager . getValue (  )  . getStatus (  )  ;", "if    (  ( status    =  =     ( Status . STATUS _ UNKNOWN )  )     |  |     ( status    =  =     ( Status . STATUS _ NO _ TRANSACTION )  )  )     {", "return   Impl ;", "}", "final   String   key    =    TransactionKey ( Impl )  ;", "TimerImpl   existing    =     (  ( TimerImpl )     ( transactionSynchronizationRegistry . getValue (  )  . getResource ( key )  )  )  ;", "return   existing    !  =    null    ?    existing    :    Impl ;", "}    catch    ( SystemException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["mostRecentEntityVersion"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "final   Lock   lock    =    getLock ( timer . getTimedObjectId (  )  )  ;", "try    {", "final   int   status    =    transactionManager . getValue (  )  . getStatus (  )  ;", "if    (  (  ( status    =  =     ( Status . STATUS _ MARKED _ ROLLBACK )  )     |  |     ( status    =  =     ( Status . STATUS _ ROLLEDBACK )  )  )     |  |     ( status    =  =     ( Status . STATUS _ ROLLING _ BACK )  )  )     {", "return ;", "}", "lock . lock (  )  ;", "if    (  (  (  ( status    =  =     ( Status . STATUS _ NO _ TRANSACTION )  )     |  |     ( status    =  =     ( Status . STATUS _ UNKNOWN )  )  )     |  |     ( isBeforeCompletion (  )  )  )     |  |     ( status    =  =     ( Status . STATUS _ COMMITTED )  )  )     {", "Map < String ,    TimerImpl >    map    =    getTimers ( timer . getTimedObjectId (  )  ,    timer . getTimerService (  )  )  ;", "if    (  (  ( timer . getState (  )  )     =  =     ( TimerState . CANCELED )  )     |  |     (  ( timer . getState (  )  )     =  =     ( TimerState . EXPIRED )  )  )     {", "map . remove ( timer . getId (  )  )  ;", "writeFile ( timer )  ;", "} else", "if    ( newTimer    |  |     ( map . containsKey ( timer . getId (  )  )  )  )     {", "map . put ( timer . getId (  )  ,    timer )  ;", "writeFile ( timer )  ;", "}", "} else    {", "final   String   key    =    timerTransactionKey ( timer )  ;", "Object   existing    =    transactionSynchronizationRegistry . getValue (  )  . getResource ( key )  ;", "if    ( existing    =  =    null )     {", "transactionSynchronizationRegistry . getValue (  )  . registerInterposedSynchronization ( new    . PersistTransactionSynchronization ( lock ,    key ,    newTimer )  )  ;", "}", "transactionSynchronizationRegistry . getValue (  )  . putResource ( key ,    timer )  ;", "}", "}    catch    ( SystemException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["persistTimer"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    ( closeable    !  =    null )     {", "try    {", "closeable . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "if    ( inputFactory . isPropertySupported ( property )  )     {", "inputFactory . setProperty ( property ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setIfSupported"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "return    \" \"     +     ( TimerImpl . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["timerTransactionKey"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "final   File   file    =    fileName ( timer . getTimedObjectId (  )  ,    timer . getId (  )  )  ;", "if    (  (  ( timer . getState (  )  )     =  =     ( TimerState . CANCELED )  )     |  |     (  ( timer . getState (  )  )     =  =     ( TimerState . EXPIRED )  )  )     {", "if    ( file . exists (  )  )     {", "file . delete (  )  ;", "}", "return ;", "}", "try    {", "FileOutputStream   out    =    new   FileOutputStream ( file )  ;", "try    {", "XMLStreamWriter   writer    =    XMLOutputFactory . newInstance (  )  . createXMLStreamWriter ( out )  ;", "XMLMapper   mapper    =    createMapper ( timer . getTimerService (  )  )  ;", "mapper . deparseDocument ( new   EjbTimerXmlPersister ( factory ,    configuration )  ,    Collections . singletonList ( timer )  ,    writer )  ;", "writer . flush (  )  ;", "writer . close (  )  ;", "}    finally    {", ". safeClose ( out )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFile"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.FileTimerPersistence"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    TimerImpl >    timers    =    new   HashMap < String ,    TimerImpl >  (  )  ;", "try    {", "final   File   file    =    new   File ( directory )  ;", "if    (  !  ( file . exists (  )  )  )     {", "return   timers ;", "} else", "if    (  !  ( file . isDirectory (  )  )  )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToRestoreTimers ( file )  ;", "return   timers ;", "}", "File   marker    =    new   File ( file ,     . MIGRATION _ MARKER )  ;", "if    ( marker . exists (  )  )     {", "return   timers ;", "}", "Unmarshaller   unmarshaller    =    factory . createUnmarshaller ( configuration )  ;", "for    ( File   timerFile    :    file . listFiles (  )  )     {", "if    ( timerFile . getName (  )  . endsWith (  \"  . xml \"  )  )     {", "continue ;", "}", "FileInputStream   in    =    null ;", "try    {", "in    =    new   FileInputStream ( timerFile )  ;", "unmarshaller . start ( new   InputStreamByteInput ( in )  )  ;", "final   TimerEntity   entity    =    unmarshaller . readObject ( TimerEntity . class )  ;", "TimerImpl . Builder   builder ;", "if    ( entity   instanceof   CalendarTimerEntity )     {", "CalendarTimerEntity   c    =     (  ( CalendarTimerEntity )     ( entity )  )  ;", "builder    =    CalendarTimer . builder (  )  . setScheduleExprSecond ( c . getSecond (  )  )  . setScheduleExprMinute ( c . getMinute (  )  )  . setScheduleExprHour ( c . getHour (  )  )  . setScheduleExprDayOfWeek ( c . getDayOfWeek (  )  )  . setScheduleExprDayOfMonth ( c . getDayOfMonth (  )  )  . setScheduleExprMonth ( c . getMonth (  )  )  . setScheduleExprYear ( c . getYear (  )  )  . setScheduleExprStartDate ( c . getStartDate (  )  )  . setScheduleExprEndDate ( c . getEndDate (  )  )  . setScheduleExprTimezone ( c . getTimezone (  )  )  . setAutoTimer ( c . isAutoTimer (  )  )  . setTimeoutMethod ( CalendarTimer . getTimeoutMethod ( c . getTimeoutMethod (  )  ,    timerService . getTimedObjectInvoker (  )  . getValue (  )  . getClassLoader (  )  )  )  ;", "} else    {", "builder    =    TimerImpl . builder (  )  ;", "}", "builder . setId ( entity . getId (  )  )  . setTimedObjectId ( entity . getTimedObjectId (  )  )  . setInitialDate ( entity . getInitialDate (  )  )  . setRepeatInterval ( entity . getInterval (  )  )  . setNextDate ( entity . getNextDate (  )  )  . setPreviousRun ( entity . getPreviousRun (  )  )  . setInfo ( entity . getInfo (  )  )  . setPrimaryKey ( entity . getPrimaryKey (  )  )  . setTimerState ( entity . getTimerState (  )  )  . setPersistent ( true )  ;", "timers . put ( entity . getId (  )  ,    builder . build ( timerService )  )  ;", "unmarshaller . finish (  )  ;", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToRestoreTimersFromFile ( timerFile ,    e )  ;", "}    finally    {", "if    ( in    !  =    null )     {", "try    {", "in . close (  )  ;", "}    catch    ( IOException   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToCloseFile ( e )  ;", "}", "}", "}", "}", "if    (  !  ( timers . isEmpty (  )  )  )     {", "FileOutputStream   out    =    new   FileOutputStream ( marker )  ;", "try    {", "out . write ( new   Date (  )  . toString (  )  . getBytes (  )  )  ;", "}    finally    {", "out . close (  )  ;", "}", "}", "}    catch    ( Exception   e )     {", "EjbLogger . EJB 3  _ TIMER _ LOGGER . failToRestoreTimersForObjectId ( timedObjectId ,    e )  ;", "}", "return   timers ;", "}", "METHOD_END"], "methodName": ["loadTimersFromFile"], "fileName": "org.jboss.as.ejb3.timerservice.persistence.filestore.LegacyFileStore"}, {"methodBody": ["METHOD_START", "{", "resetTimeToFirstValues ( cal )  ;", "while    (  ( monthHasDate ( cal ,    date )  )     =  =    false )     {", "if    (  ( cal . get (  . YEAR )  )     >     ( Year . MAX _ YEAR )  )     {", "return   null ;", "}", "cal . add (  . MONTH ,     1  )  ;", "cal    =    this . computeNextMonth ( cal )  ;", "if    ( cal    =  =    null )     {", "return   null ;", "}", "date    =    this . dayOfMonth . getFirstMatch ( cal )  ;", "if    ( date    =  =    null )     {", "return   null ;", "}", "}", "cal . set (  . DAY _ OF _ MONTH ,    date )  ;", "return   cal ;", "}", "METHOD_END"], "methodName": ["advanceTillMonthHasDate"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpression   clonedSchedule    =    new   ScheduleExpression (  )  ;", "clonedSchedule . second ( getSecond (  )  )  ;", "clonedSchedule . minute ( getMinute (  )  )  ;", "clonedSchedule . hour ( getHour (  )  )  ;", "clonedSchedule . dayOfWeek ( getDayOfWeek (  )  )  ;", "clonedSchedule . dayOfMonth ( getDayOfMonth (  )  )  ;", "clonedSchedule . month ( getMonth (  )  )  ;", "clonedSchedule . year ( getYear (  )  )  ;", "clonedSchedule . timezone ( getTimezone (  )  )  ;", "clonedSchedule . start ( getStart (  )  )  ;", "clonedSchedule . end ( getEnd (  )  )  ;", "return   clonedSchedule ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "if    ( this . isDayOfMonthWildcard (  )  )     {", "return   this . computeNextDayOfWeek ( nextCal )  ;", "}", "if    ( this . isDayOfWeekWildcard (  )  )     {", "return   this . computeNextDayOfMonth ( nextCal )  ;", "}", "nextDayOfMonthCal    =    this . computeNextDayOfMonth (  (  (  )     ( nextCal . clone (  )  )  )  )  ;", "nextDayOfWeekCal    =    this . computeNextDayOfWeek (  (  (  )     ( nextCal . clone (  )  )  )  )  ;", "if    ( nextDayOfMonthCal    =  =    null )     {", "return   nextDayOfWeekCal ;", "}", "if    ( nextDayOfWeekCal    =  =    null )     {", "return   nextDayOfMonthCal ;", "}", "return   nextDayOfWeekCal . getTime (  )  . before ( nextDayOfMonthCal . getTime (  )  )     ?    nextDayOfWeekCal    :    nextDayOfMonthCal ;", "}", "METHOD_END"], "methodName": ["computeNextDate"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "Integer   nextDayOfMonth    =    this . dayOfMonth . getNextMatch ( nextCal )  ;", "if    ( nextDayOfMonth    =  =    null )     {", "return   null ;", "}", "int   currentDayOfMonth    =    nextCal . get (  . DAY _ OF _ MONTH )  ;", "if    ( currentDayOfMonth    =  =    nextDayOfMonth )     {", "return   nextCal ;", "}", "if    ( nextDayOfMonth    >    currentDayOfMonth )     {", "if    ( this . monthHasDate ( nextCal ,    nextDayOfMonth )  )     {", "nextCal . set (  . DAY _ OF _ MONTH ,    nextDayOfMonth )  ;", "resetTimeToFirstValues ( nextCal )  ;", "} else    {", "nextCal    =    this . advanceTillMonthHasDate ( nextCal ,    nextDayOfMonth )  ;", "}", "} else    {", "nextCal . add (  . MONTH ,     1  )  ;", "resetTimeToFirstValues ( nextCal )  ;", "nextCal    =    this . computeNextMonth ( nextCal )  ;", "if    ( nextCal    =  =    null )     {", "return   null ;", "}", "nextDayOfMonth    =    this . dayOfMonth . getFirstMatch ( nextCal )  ;", "if    ( nextDayOfMonth    =  =    null )     {", "return   null ;", "}", "nextCal    =    this . advanceTillMonthHasDate ( nextCal ,    nextDayOfMonth )  ;", "}", "return   nextCal ;", "}", "METHOD_END"], "methodName": ["computeNextDayOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "Integer   nextDayOfWeek    =    this . dayOfWeek . getNextMatch ( nextCal )  ;", "if    ( nextDayOfWeek    =  =    null )     {", "return   null ;", "}", "int   currentDayOfWeek    =    nextCal . get (  . DAY _ OF _ WEEK )  ;", "if    ( currentDayOfWeek    =  =    nextDayOfWeek )     {", "return   nextCal ;", "}", "int   currentMonth    =    nextCal . get (  . MONTH )  ;", "if    ( nextDayOfWeek    <    currentDayOfWeek )     {", "nextCal . add (  . WEEK _ OF _ MONTH ,     1  )  ;", "}", "nextCal . set (  . DAY _ OF _ WEEK ,    nextDayOfWeek )  ;", "resetTimeToFirstValues ( nextCal )  ;", "if    (  ( nextCal . get (  . MONTH )  )     !  =    currentMonth )     {", "nextCal    =    computeNextMonth ( nextCal )  ;", "}", "return   nextCal ;", "}", "METHOD_END"], "methodName": ["computeNextDayOfWeek"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "Integer   nextMonth    =    this . month . getNextMatch ( nextCal )  ;", "if    ( nextMonth    =  =    null )     {", "return   null ;", "}", "int   currentMonth    =    nextCal . get (  . MONTH )  ;", "if    ( currentMonth    =  =    nextMonth )     {", "return   nextCal ;", "}", "if    ( nextMonth    <    currentMonth )     {", "nextCal . add (  . YEAR ,     1  )  ;", "}", "nextCal . set (  . MONTH ,    nextMonth )  ;", "nextCal . set (  . DAY _ OF _ WEEK ,    this . dayOfWeek . getFirst (  )  )  ;", "nextCal . set (  . DAY _ OF _ MONTH ,     1  )  ;", "resetTimeToFirstValues ( nextCal )  ;", "return   nextCal ;", "}", "METHOD_END"], "methodName": ["computeNextMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "int   currentSecond    =    nextCal . get ( Calendar . SECOND )  ;", "int   currentMinute    =    nextCal . get ( Calendar . MINUTE )  ;", "int   currentHour    =    nextCal . get ( Calendar . HOUR _ OF _ DAY )  ;", "final   int   currentTimeInSeconds    =     (  ( currentHour    *     3  6  0  0  )     +     ( currentMinute    *     6  0  )  )     +    currentSecond ;", "Integer   nextSecond    =    this . second . getNextMatch ( currentSecond )  ;", "if    ( nextSecond    =  =    null )     {", "return   null ;", "}", "if    ( nextSecond    <    currentSecond )     {", "currentMinute +  +  ;", "}", "Integer   nextMinute    =    this . minute . getNextMatch (  ( currentMinute    <     6  0     ?    currentMinute    :     0  )  )  ;", "if    ( nextMinute    =  =    null )     {", "return   null ;", "}", "if    ( nextMinute    !  =    currentMinute )     {", "nextSecond    =    this . second . getNextMatch (  0  )  ;", "}", "if    ( nextMinute    <    currentMinute )     {", "currentHour +  +  ;", "}", "Integer   nextHour    =    this . hour . getNextMatch (  ( currentHour    <     2  4     ?    currentHour    :     0  )  )  ;", "if    ( nextHour    =  =    null )     {", "return   null ;", "}", "if    ( nextHour    !  =    currentHour )     {", "nextSecond    =    this . second . getNextMatch (  0  )  ;", "nextMinute    =    this . minute . getNextMatch (  0  )  ;", "}", "final   int   nextTimeInSeconds    =     (  ( nextHour    *     3  6  0  0  )     +     ( nextMinute    *     6  0  )  )     +    nextSecond ;", "if    ( nextTimeInSeconds    =  =    currentTimeInSeconds )     {", "return   nextCal ;", "}", "if    ( nextTimeInSeconds    <    currentTimeInSeconds )     {", "nextCal . add ( Calendar . DATE ,     1  )  ;", "}", "setTime ( nextCal ,    nextHour ,    nextMinute ,    nextSecond )  ;", "return   nextCal ;", "}", "METHOD_END"], "methodName": ["computeNextTime"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "Integer   nextYear    =    this . year . getNextMatch ( nextCal )  ;", "if    (  ( nextYear    =  =    null )     |  |     ( nextYear    >     ( Year . MAX _ YEAR )  )  )     {", "return   null ;", "}", "int   currentYear    =    nextCal . get (  . YEAR )  ;", "if    ( currentYear    =  =    nextYear )     {", "return   nextCal ;", "}", "if    ( nextYear    <    currentYear )     {", "return   null ;", "}", "nextCal . set (  . YEAR ,    nextYear )  ;", "nextCal . set (  . MONTH ,    this . month . getFirstMatch (  )  )  ;", "nextCal . set (  . DAY _ OF _ MONTH ,     1  )  ;", "resetTimeToFirstValues ( nextCal )  ;", "nextCal    =    this . computeNextDate ( nextCal )  ;", "return   nextCal ;", "}", "METHOD_END"], "methodName": ["computeNextYear"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "return   this . firstTimeout ;", "}", "METHOD_END"], "methodName": ["getFirstTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "return   getNextTimeout ( new   GregorianCalendar ( this . timezone )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["getNextTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "return   getNextTimeout ( currentCal ,    true )  ;", "}", "METHOD_END"], "methodName": ["getNextTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "if    ( this . noMoreTimeouts ( currentCal )  )     {", "return   null ;", "}", "Calendar   nextCal    =     (  ( Calendar )     ( currentCal . clone (  )  )  )  ;", "nextCal . setTimeZone ( this . timezone )  ;", "Date   start    =    thisExpression . getStart (  )  ;", "if    (  ( start    !  =    null )     &  &     ( currentCal . getTime (  )  . before ( start )  )  )     {", "nextCal . setTime ( start )  ;", "} else    {", "if    ( increment )     {", "nextCal . add ( Calendar . SECOND ,     1  )  ;", "}", "nextCal . add ( Calendar . MILLISECOND ,     (  -  ( nextCal . get ( Calendar . MILLISECOND )  )  )  )  ;", "}", "nextCal . setFirstDayOfWeek ( Calendar . SUNDAY )  ;", "nextCal    =    this . computeNextTime ( nextCal )  ;", "if    ( nextCal    =  =    null )     {", "return   null ;", "}", "nextCal    =    this . computeNextMonth ( nextCal )  ;", "if    ( nextCal    =  =    null )     {", "return   null ;", "}", "nextCal    =    this . computeNextDate ( nextCal )  ;", "if    ( nextCal    =  =    null )     {", "return   null ;", "}", "nextCal    =    this . computeNextYear ( nextCal )  ;", "if    ( nextCal    =  =    null )     {", "return   null ;", "}", "if    ( this . noMoreTimeouts ( nextCal )  )     {", "return   null ;", "}", "return   nextCal ;", "}", "METHOD_END"], "methodName": ["getNextTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "return   this . scheduleExpression ;", "}", "METHOD_END"], "methodName": ["getScheduleExpression"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "Date   end    =    this . scheduleExpression . getEnd (  )  ;", "if    ( end    =  =    null )     {", "return   false ;", "}", "return   cal . getTime (  )  . after ( end )  ;", "}", "METHOD_END"], "methodName": ["isAfterEnd"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "return   this . scheduleExpression . getDayOfMonth (  )  . equals (  \"  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["isDayOfMonthWildcard"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "return   this . scheduleExpression . getDayOfWeek (  )  . equals (  \"  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["isDayOfWeekWildcard"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "return   date    <  =     ( cal . getActualMaximum ( Calendar . DAY _ OF _ MONTH )  )  ;", "}", "METHOD_END"], "methodName": ["monthHasDate"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( cal . get ( Calendar . YEAR )  )     >     ( Year . MAX _ YEAR )  )     |  |     ( isAfterEnd ( cal )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["noMoreTimeouts"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "if    (  ( schedule . getSecond (  )  )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidScheduleExpressionSecond ( schedule )  ;", "}", "if    (  ( schedule . getMinute (  )  )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidScheduleExpressionMinute ( schedule )  ;", "}", "if    (  ( schedule . getHour (  )  )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidScheduleExpressionHour ( schedule )  ;", "}", "if    (  ( schedule . getDayOfMonth (  )  )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidScheduleExpressionDayOfMonth ( schedule )  ;", "}", "if    (  ( schedule . getDayOfWeek (  )  )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidScheduleExpressionDayOfWeek ( schedule )  ;", "}", "if    (  ( schedule . getMonth (  )  )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidScheduleExpressionMonth ( schedule )  ;", "}", "if    (  ( schedule . getYear (  )  )     =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidScheduleExpressionYear ( schedule )  ;", "}", "}", "METHOD_END"], "methodName": ["nullCheckScheduleAttributes"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "final   int   currentHour    =    calendar . get ( Calendar . HOUR _ OF _ DAY )  ;", "final   int   currentMinute    =    calendar . get ( Calendar . MINUTE )  ;", "final   int   currentSecond    =    calendar . get ( Calendar . SECOND )  ;", "final   int   firstHour    =    this . hour . getFirst (  )  ;", "final   int   firstMinute    =    this . minute . getFirst (  )  ;", "final   int   firstSecond    =    this . second . getFirst (  )  ;", "if    (  (  ( currentHour    !  =    firstHour )     |  |     ( currentMinute    !  =    firstMinute )  )     |  |     ( currentSecond    !  =    firstSecond )  )     {", "setTime ( calendar ,    firstHour ,    firstMinute ,    firstSecond )  ;", "}", "}", "METHOD_END"], "methodName": ["resetTimeToFirstValues"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "Calendar   currentCal    =    new   GregorianCalendar ( this . timezone )  ;", "Date   start    =    thisExpression . getStart (  )  ;", "if    ( start    !  =    null )     {", "currentCal . setTime ( start )  ;", "} else    {", "resetTimeToFirstValues ( currentCal )  ;", "}", "this . firstTimeout    =    getNextTimeout ( currentCal ,    false )  ;", "}", "METHOD_END"], "methodName": ["setFirstTimeout"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "int   dst    =    calendar . get ( Calendar . DST _ OFFSET )  ;", "calendar . clear ( Calendar . HOUR _ OF _ DAY )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,    hour )  ;", "calendar . clear ( Calendar . MINUTE )  ;", "calendar . set ( Calendar . MINUTE ,    minute )  ;", "calendar . clear ( Calendar . SECOND )  ;", "calendar . set ( Calendar . SECOND ,    second )  ;", "calendar . set ( Calendar . DST _ OFFSET ,    dst )  ;", "}", "METHOD_END"], "methodName": ["setTime"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.CalendarBasedTimeout"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . valueIsNull (  )  ;", "}", "if    ( value . trim (  )  . equals (  \"  *  \"  )  )     {", "return    . WILDCARD ;", "}", "if    ( value . contains (  \"  ,  \"  )  )     {", "return    . LIST ;", "}", "if    (  ( value . contains (  \"  -  \"  )  )     &  &     ( RangeValue . accepts ( value )  )  )     {", "return    . RANGE ;", "}", "if    ( value . contains (  \"  /  \"  )  )     {", "return    . INCREMENT ;", "}", "return    . SINGLE _ VALUE ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.ScheduleExpressionTypeUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( relativeDayOfMonth    =  =    null )     |  |     ( relativeDayOfMonth . trim (  )  . isEmpty (  )  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . relativeDayOfMonthIsNull (  )  ;", "}", "String   trimmedRelativeDayOfMonth    =    relativeDayOfMonth . trim (  )  ;", "if    ( trimmedRelativeDayOfMonth . equalsIgnoreCase (  \" last \"  )  )     {", "int   lastDayOfCurrentMonth    =    CalendarUtil . getLastDateOfMonth ( cal )  ;", "return   lastDayOfCurrentMonth ;", "}", "if    ( this . isValidNegativeDayOfMonth ( trimmedRelativeDayOfMonth )  )     {", "Integer   negativeRelativeDayOfMonth    =    Integer . parseInt ( trimmedRelativeDayOfMonth )  ;", "int   lastDayOfCurrentMonth    =    CalendarUtil . getLastDateOfMonth ( cal )  ;", "return   lastDayOfCurrentMonth    +    negativeRelativeDayOfMonth ;", "}", "if    ( this . isDayOfWeekBased ( trimmedRelativeDayOfMonth )  )     {", "String [  ]    parts    =    trimmedRelativeDayOfMonth . split (  \"  \\  \\ s +  \"  )  ;", "String   ordinal    =    parts [  0  ]  ;", "String   day    =    parts [  1  ]  ;", "int   dayOfWeek    =    DayOfMonth . DAY _ OF _ MONTH _ ALIAS . get ( day . toLowerCase ( Locale . ENGLISH )  )  ;", "Integer   date    =    null ;", "if    ( ordinal . equalsIgnoreCase (  \" last \"  )  )     {", "date    =    CalendarUtil . getDateOfLastDayOfWeekInMonth ( cal ,    dayOfWeek )  ;", "} else    {", "int   weekNumber    =    DayOfMonth . ORDINAL _ TO _ WEEK _ NUMBER _ MAPPING . get ( ordinal . toLowerCase ( Locale . ENGLISH )  )  ;", "date    =    CalendarUtil . getNthDayOfMonth ( cal ,    weekNumber ,    dayOfWeek )  ;", "}", "if    ( date    =  =    null )     {", "date    =    CalendarUtil . getLastDateOfMonth ( cal )  ;", "}", "return   date ;", "}", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidRelativeValue ( relativeDayOfMonth )  ;", "}", "METHOD_END"], "methodName": ["getAbsoluteDayOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfMonth"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . hasRelativeDayOfMonth (  )  )     =  =    false )     {", "return   this . absoluteValues ;", "}", "SortedSet < Integer >    eligibleDaysOfMonth    =    new   TreeSet < Integer >  ( this . absoluteValues )  ;", "for    ( ScheduleValue   relativeValue    :    this . relativeValues )     {", "if    ( relativeValue   instanceof   SingleValue )     {", "SingleValue   singleValue    =     (  ( SingleValue )     ( relativeValue )  )  ;", "String   value    =    singleValue . getValue (  )  ;", "Integer   absoluteDayOfMonth    =    this . getAbsoluteDayOfMonth ( cal ,    value )  ;", "eligibleDaysOfMonth . add ( absoluteDayOfMonth )  ;", "} else", "if    ( relativeValue   instanceof   value . RangeValue )     {", "value . RangeValue   range    =     (  ( value . RangeValue )     ( relativeValue )  )  ;", "String   start    =    range . getStart (  )  ;", "String   end    =    range . getEnd (  )  ;", "Integer   dayOfMonthStart    =    null ;", "if    ( this . isRelativeValue ( start )  )     {", "dayOfMonthStart    =    this . getAbsoluteDayOfMonth ( cal ,    start )  ;", "} else    {", "dayOfMonthStart    =    this . parseInt ( start )  ;", "}", "Integer   dayOfMonthEnd    =    null ;", "if    ( this . isRelativeValue ( end )  )     {", "dayOfMonthEnd    =    this . getAbsoluteDayOfMonth ( cal ,    end )  ;", "} else    {", "dayOfMonthEnd    =    this . parseInt ( end )  ;", "}", "this . assertValid ( dayOfMonthStart )  ;", "this . assertValid ( dayOfMonthEnd )  ;", "if    ( dayOfMonthStart . equals ( dayOfMonthEnd )  )     {", "eligibleDaysOfMonth . add ( dayOfMonthEnd )  ;", "continue ;", "}", "if    ( dayOfMonthStart    >    dayOfMonthEnd )     {", "for    ( int   i    =    dayOfMonthStart ;    i    <  =     ( this . getMaxValue (  )  )  ;    i +  +  )     {", "eligibleDaysOfMonth . add ( i )  ;", "}", "for    ( int   i    =    this . getMinValue (  )  ;    i    <  =    dayOfMonthEnd ;    i +  +  )     {", "eligibleDaysOfMonth . add ( i )  ;", "}", "} else    {", "for    ( int   i    =    dayOfMonthStart ;    i    <  =    dayOfMonthEnd ;    i +  +  )     {", "eligibleDaysOfMonth . add ( i )  ;", "}", "}", "}", "}", "return   eligibleDaysOfMonth ;", "}", "METHOD_END"], "methodName": ["getEligibleDaysOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfMonth"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   Calendar . SUNDAY ;", "}", "SortedSet < Integer >    eligibleDaysOfMonth    =    this . getEligibleDaysOfMonth ( cal )  ;", "if    ( eligibleDaysOfMonth . isEmpty (  )  )     {", "return   null ;", "}", "return   eligibleDaysOfMonth . first (  )  ;", "}", "METHOD_END"], "methodName": ["getFirstMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfMonth"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   currentCal . get ( Calendar . DAY _ OF _ MONTH )  ;", "}", "int   current    =    currentCal . get ( Calendar . DAY _ OF _ MONTH )  ;", "SortedSet < Integer >    eligibleDaysOfMonth    =    this . getEligibleDaysOfMonth ( currentCal )  ;", "if    ( eligibleDaysOfMonth . isEmpty (  )  )     {", "return   null ;", "}", "for    ( Integer   hour    :    eligibleDaysOfMonth )     {", "if    ( current    =  =    hour )     {", "return   current ;", "}", "if    ( hour    >    current )     {", "return   hour ;", "}", "}", "return   eligibleDaysOfMonth . first (  )  ;", "}", "METHOD_END"], "methodName": ["getNextMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfMonth"}, {"methodBody": ["METHOD_START", "{", "if    ( this . relativeValues . isEmpty (  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasRelativeDayOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfMonth"}, {"methodBody": ["METHOD_START", "{", "String   trimmedVal    =    relativeVal . trim (  )  ;", "Pattern   p    =    Pattern . compile (  \"  \\  \\ s +  \"  )  ;", "String [  ]    relativeParts    =    p . split ( trimmedVal )  ;", "if    ( relativeParts    =  =    null )     {", "return   false ;", "}", "if    (  ( relativeParts . length )     !  =     2  )     {", "return   false ;", "}", "String   ordinal    =    relativeParts [  0  ]  ;", "String   dayOfWeek    =    relativeParts [  1  ]  ;", "if    (  ( ordinal    =  =    null )     |  |     ( dayOfWeek    =  =    null )  )     {", "return   false ;", "}", "String   lowerCaseOrdinal    =    ordinal . toLowerCase ( Locale . ENGLISH )  ;", "if    (  (  . ORDINALS . contains ( lowerCaseOrdinal )  )     =  =    false )     {", "return   false ;", "}", "String   lowerCaseDayOfWeek    =    dayOfWeek . toLowerCase ( Locale . ENGLISH )  ;", "if    (  (  . DAY _ OF _ MONTH _ ALIAS . containsKey ( lowerCaseDayOfWeek )  )     =  =    false )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isDayOfWeekBased"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfMonth"}, {"methodBody": ["METHOD_START", "{", "try    {", "Integer   val    =    Integer . parseInt ( d . trim (  )  )  ;", "if    (  ( val    <  =     (  -  1  )  )     &  &     ( val    >  =     (  -  7  )  )  )     {", "return   true ;", "}", "return   false ;", "}    catch    ( NumberFormatException   nfe )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isValidNegativeDayOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfMonth"}, {"methodBody": ["METHOD_START", "{", "return   DayOfWeek . DAY _ OF _ WEEK _ ALIAS . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["getDaysOfWeek"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfWeek"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   Calendar . SUNDAY ;", "}", "return   this . offsetAdjustedDaysOfWeek . first (  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfWeek"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   currentCal . get ( Calendar . DAY _ OF _ WEEK )  ;", "}", "int   currentDayOfWeek    =    currentCal . get ( Calendar . DAY _ OF _ WEEK )  ;", "for    ( Integer   dayOfWeek    :    this . offsetAdjustedDaysOfWeek )     {", "if    ( currentDayOfWeek    =  =    dayOfWeek )     {", "return   currentDayOfWeek ;", "}", "if    ( dayOfWeek    >    currentDayOfWeek )     {", "return   dayOfWeek ;", "}", "}", "return   this . offsetAdjustedDaysOfWeek . first (  )  ;", "}", "METHOD_END"], "methodName": ["getNextMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.DayOfWeek"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return    0  ;", "}", "return   this . absoluteValues . first (  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Hour"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   currentHour ;", "}", "if    ( this . absoluteValues . isEmpty (  )  )     {", "return   null ;", "}", "for    ( Integer   hour    :    this . absoluteValues )     {", "if    ( currentHour    =  =    hour )     {", "return   currentHour ;", "}", "if    ( hour    >    currentHour )     {", "return   hour ;", "}", "}", "return   this . absoluteValues . first (  )  ;", "}", "METHOD_END"], "methodName": ["getNextMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Hour"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . couldNotParseSchedule ( this . origValue )  ;", "}", "int   max    =    this . getMaxValue (  )  ;", "int   min    =    this . getMinValue (  )  ;", "if    (  ( value    >    max )     |  |     ( value    <    min )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidValuesRange ( value ,    min ,    max )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValid"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.IntegerBasedExpression"}, {"methodBody": ["METHOD_START", "{", "if    ( alias    =  =    null )     {", "return   null ;", "}", "return    . parseInt ( alias . trim (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseInt"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.IntegerBasedExpression"}, {"methodBody": ["METHOD_START", "{", "String   startValue    =    incr . getStart (  )  ;", "start    =     ( startValue . equals (  \"  *  \"  )  )     ?     0     :    this . parseInt ( startValue )  ;", "this . assertValid ( start )  ;", "interval    =    this . parseInt ( incr . getInterval (  )  )  ;", "this . absoluteValues . add ( start )  ;", "int   next    =    start    +    interval ;", "int   maxValue    =    this . getMaxValue (  )  ;", "while    ( next    <  =    maxValue )     {", "this . absoluteValues . add ( next )  ;", "next    =    next    +    interval ;", "}", "}", "METHOD_END"], "methodName": ["processIncrement"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.IntegerBasedExpression"}, {"methodBody": ["METHOD_START", "{", "ScheduleExpressionType   listItemType    =    ScheduleExpressionTypeUtil . getType ( listItem )  ;", "switch    ( listItemType )     {", "case   SINGLE _ VALUE    :", "SingleValue   singleVal    =    new   SingleValue ( listItem )  ;", "this . processSingleValue ( singleVal )  ;", "return ;", "case   RANGE    :", "RangeValue   range    =    new   RangeValue ( listItem )  ;", "this . processRangeValue ( range )  ;", "return ;", "default    :", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidListValue ( listItem )  ;", "}", "}", "METHOD_END"], "methodName": ["processListItem"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.IntegerBasedExpression"}, {"methodBody": ["METHOD_START", "{", "for    ( String   listItem    :    list . getValues (  )  )     {", "this . processListItem ( listItem )  ;", "}", "}", "METHOD_END"], "methodName": ["processListValue"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.IntegerBasedExpression"}, {"methodBody": ["METHOD_START", "{", "String   start    =    range . getStart (  )  ;", "String   end    =    range . getEnd (  )  ;", "if    (  ( this . isRelativeValue ( start )  )     |  |     ( this . isRelativeValue ( end )  )  )     {", "this . relativeValues . add ( range )  ;", "return ;", "}", "rangeStart    =    this . parseInt ( start )  ;", "rangeEnd    =    this . parseInt ( end )  ;", "this . assertValid ( rangeStart )  ;", "this . assertValid ( rangeEnd )  ;", "if    ( rangeStart . equals ( rangeEnd )  )     {", "this . absoluteValues . add ( rangeStart )  ;", "return ;", "}", "if    ( rangeStart    >    rangeEnd )     {", "for    ( int   i    =    rangeStart ;    i    <  =     ( this . getMaxValue (  )  )  ;    i +  +  )     {", "this . absoluteValues . add ( i )  ;", "}", "for    ( int   i    =    this . getMinValue (  )  ;    i    <  =    rangeEnd ;    i +  +  )     {", "this . absoluteValues . add ( i )  ;", "}", "} else    {", "for    ( int   i    =    rangeStart ;    i    <  =    rangeEnd ;    i +  +  )     {", "this . absoluteValues . add ( i )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processRangeValue"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.IntegerBasedExpression"}, {"methodBody": ["METHOD_START", "{", "String   value    =    singleValue . getValue (  )  ;", "if    ( this . isRelativeValue ( value )  )     {", "this . relativeValues . add ( singleValue )  ;", "} else    {", "val    =    this . parseInt ( value )  ;", "this . assertValid ( val )  ;", "this . absoluteValues . add ( val )  ;", "}", "}", "METHOD_END"], "methodName": ["processSingleValue"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.IntegerBasedExpression"}, {"methodBody": ["METHOD_START", "{", "return   this . absoluteValues ;", "}", "METHOD_END"], "methodName": ["getEligibleMinutes"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Minute"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return    0  ;", "}", "SortedSet < Integer >    eligibleMinutes    =    this . getEligibleMinutes (  )  ;", "if    ( eligibleMinutes . isEmpty (  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidExpressionMinutes ( this . origValue )  ;", "}", "return   eligibleMinutes . first (  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Minute"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   currentMinute ;", "}", "if    ( this . absoluteValues . isEmpty (  )  )     {", "return   null ;", "}", "for    ( Integer   minute    :    this . absoluteValues )     {", "if    ( currentMinute    =  =    minute )     {", "return   currentMinute ;", "}", "if    ( minute    >    currentMinute )     {", "return   minute ;", "}", "}", "return   this . absoluteValues . first (  )  ;", "}", "METHOD_END"], "methodName": ["getNextMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Minute"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   Calendar . JANUARY ;", "}", "if    ( this . offsetAdjustedMonths . isEmpty (  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidExpressionSeconds ( this . origValue )  ;", "}", "return   this . offsetAdjustedMonths . first (  )  ;", "}", "METHOD_END"], "methodName": ["getFirstMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Month"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   currentCal . get ( Calendar . MONTH )  ;", "}", "if    ( this . offsetAdjustedMonths . isEmpty (  )  )     {", "return   null ;", "}", "int   currentMonth    =    currentCal . get ( Calendar . MONTH )  ;", "for    ( Integer   month    :    this . offsetAdjustedMonths )     {", "if    ( currentMonth    =  =    month )     {", "return   currentMonth ;", "}", "if    ( month    >    currentMonth )     {", "return   month ;", "}", "}", "return   this . offsetAdjustedMonths . first (  )  ;", "}", "METHOD_END"], "methodName": ["getNextMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Month"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return    0  ;", "}", "if    ( this . absoluteValues . isEmpty (  )  )     {", "throw   EjbLogger . EJB 3  _ TIMER _ LOGGER . invalidExpressionSeconds ( this . origValue )  ;", "}", "return   this . absoluteValues . first (  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Second"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   currentSecond ;", "}", "if    ( this . absoluteValues . isEmpty (  )  )     {", "return   null ;", "}", "for    ( Integer   second    :    this . absoluteValues )     {", "if    ( currentSecond    =  =    second )     {", "return   currentSecond ;", "}", "if    ( second    >    currentSecond )     {", "return   second ;", "}", "}", "return   this . absoluteValues . first (  )  ;", "}", "METHOD_END"], "methodName": ["getNextMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Second"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduleExpressionType )     =  =     ( ScheduleExpressionType . WILDCARD )  )     {", "return   currentCal . get ( Calendar . YEAR )  ;", "}", "if    ( this . absoluteValues . isEmpty (  )  )     {", "return   null ;", "}", "int   currentYear    =    currentCal . get ( Calendar . YEAR )  ;", "for    ( Integer   year    :    this . absoluteValues )     {", "if    ( currentYear    =  =    year )     {", "return   currentYear ;", "}", "if    ( year    >    currentYear )     {", "return   year ;", "}", "}", "return   this . absoluteValues . first (  )  ;", "}", "METHOD_END"], "methodName": ["getNextMatch"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.attribute.Year"}, {"methodBody": ["METHOD_START", "{", "int   lastDateOfMonth    =    CalendarUtil . getLastDateOfMonth ( calendar )  ;", "Calendar   tmpCal    =    new   GregorianCalendar ( calendar . getTimeZone (  )  )  ;", "tmpCal . set ( Calendar . YEAR ,    calendar . get ( Calendar . YEAR )  )  ;", "tmpCal . set ( Calendar . MONTH ,    calendar . get ( Calendar . MONTH )  )  ;", "tmpCal . set ( Calendar . DATE ,    lastDateOfMonth )  ;", "int   day    =    tmpCal . get ( Calendar . DAY _ OF _ WEEK )  ;", "if    ( day    =  =    dayOfWeek )     {", "return   tmpCal . get ( Calendar . DATE )  ;", "}", "while    ( day    !  =    dayOfWeek )     {", "tmpCal . add ( Calendar . DATE ,     (  -  1  )  )  ;", "day    =    tmpCal . get ( Calendar . DAY _ OF _ WEEK )  ;", "}", "return   tmpCal . get ( Calendar . DATE )  ;", "}", "METHOD_END"], "methodName": ["getDateOfLastDayOfWeekInMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.util.CalendarUtil"}, {"methodBody": ["METHOD_START", "{", "Calendar   tmpCal    =    new   GregorianCalendar ( cal . getTimeZone (  )  )  ;", "tmpCal . set ( Calendar . YEAR ,    cal . get ( Calendar . YEAR )  )  ;", "tmpCal . set ( Calendar . MONTH ,    cal . get ( Calendar . MONTH )  )  ;", "tmpCal . set ( Calendar . DATE ,     1  )  ;", "int   day    =    tmpCal . get ( Calendar . DAY _ OF _ WEEK )  ;", "if    ( day    =  =    dayOfWeek )     {", "return   tmpCal . get ( Calendar . DATE )  ;", "}", "while    ( day    !  =    dayOfWeek )     {", "tmpCal . add ( Calendar . DATE ,     1  )  ;", "day    =    tmpCal . get ( Calendar . DAY _ OF _ WEEK )  ;", "}", "return   tmpCal . get ( Calendar . DATE )  ;", "}", "METHOD_END"], "methodName": ["getFirstDateInMonthForDayOfWeek"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.util.CalendarUtil"}, {"methodBody": ["METHOD_START", "{", "Calendar   tmpCal    =    new   GregorianCalendar ( calendar . getTimeZone (  )  )  ;", "tmpCal . set ( Calendar . YEAR ,    calendar . get ( Calendar . YEAR )  )  ;", "tmpCal . set ( Calendar . MONTH ,    calendar . get ( Calendar . MONTH )  )  ;", "tmpCal . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "return   tmpCal . getActualMaximum ( Calendar . DAY _ OF _ MONTH )  ;", "}", "METHOD_END"], "methodName": ["getLastDateOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.util.CalendarUtil"}, {"methodBody": ["METHOD_START", "{", "int   dateOfFirstXXXDay    =    CalendarUtil . getFirstDateInMonthForDayOfWeek ( cal ,    dayOfWeek )  ;", "final   int   FIRST _ WEEK    =     1  ;", "final   int   NUM _ DAYS _ IN _ WEEK    =     7  ;", "int   weekDiff    =    n    -    FIRST _ WEEK ;", "int   dateOfNthXXXDayInMonth    =    dateOfFirstXXXDay    +     ( weekDiff    *    NUM _ DAYS _ IN _ WEEK )  ;", "int   maxDateInCurrentMonth    =    CalendarUtil . getLastDateOfMonth ( cal )  ;", "if    ( dateOfNthXXXDayInMonth    >    maxDateInCurrentMonth )     {", "return   null ;", "}", "return   dateOfNthXXXDayInMonth ;", "}", "METHOD_END"], "methodName": ["getNthDayOfMonth"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.util.CalendarUtil"}, {"methodBody": ["METHOD_START", "{", "return   this . interval ;", "}", "METHOD_END"], "methodName": ["getInterval"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.IncrementValue"}, {"methodBody": ["METHOD_START", "{", "return   this . start ;", "}", "METHOD_END"], "methodName": ["getStart"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.IncrementValue"}, {"methodBody": ["METHOD_START", "{", "return   this . values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.ListValue"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   false ;", "}", "Matcher   matcher    =     . RANGE _ PATTERN . matcher ( value )  ;", "return   matcher . matches (  )  ;", "}", "METHOD_END"], "methodName": ["accepts"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.RangeValue"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . rangeStart )     +     ( RangeValue . RANGE _ SEPARATOR )  )     +     ( this . rangeStart )  ;", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.RangeValue"}, {"methodBody": ["METHOD_START", "{", "return   this . rangeEnd ;", "}", "METHOD_END"], "methodName": ["getEnd"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.RangeValue"}, {"methodBody": ["METHOD_START", "{", "if    ( val    =  =    null )     {", "return   null ;", "}", "Matcher   matcher    =     . RANGE _ PATTERN . matcher ( val )  ;", "if    (  !  ( matcher . matches (  )  )  )     {", "return   null ;", "}", "String [  ]    rangeVals    =    new   String [  2  ]  ;", "rangeVals [  0  ]     =    matcher . group (  1  )  ;", "rangeVals [  1  ]     =    matcher . group (  3  )  ;", "return   rangeVals ;", "}", "METHOD_END"], "methodName": ["getRangeValues"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.RangeValue"}, {"methodBody": ["METHOD_START", "{", "return   this . rangeStart ;", "}", "METHOD_END"], "methodName": ["getStart"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.RangeValue"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ejb3.timerservice.schedule.value.SingleValue"}, {"methodBody": ["METHOD_START", "{", "return   method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.jboss.as.ejb3.timerservice.spi.ScheduleTimer"}, {"methodBody": ["METHOD_START", "{", "return   scheduleExpression ;", "}", "METHOD_END"], "methodName": ["getScheduleExpression"], "fileName": "org.jboss.as.ejb3.timerservice.spi.ScheduleTimer"}, {"methodBody": ["METHOD_START", "{", "return   timerConfig ;", "}", "METHOD_END"], "methodName": ["getTimerConfig"], "fileName": "org.jboss.as.ejb3.timerservice.spi.ScheduleTimer"}, {"methodBody": ["METHOD_START", "{", "return   exceptionClass ;", "}", "METHOD_END"], "methodName": ["getExceptionClass"], "fileName": "org.jboss.as.ejb3.tx.ApplicationExceptionDetails"}, {"methodBody": ["METHOD_START", "{", "return   inherited ;", "}", "METHOD_END"], "methodName": ["isInherited"], "fileName": "org.jboss.as.ejb3.tx.ApplicationExceptionDetails"}, {"methodBody": ["METHOD_START", "{", "return   rollback ;", "}", "METHOD_END"], "methodName": ["isRollback"], "fileName": "org.jboss.as.ejb3.tx.ApplicationExceptionDetails"}, {"methodBody": ["METHOD_START", "{", "return   component ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.jboss.as.ejb3.tx.BMTInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   TransactionManager   tm    =    component . getTransactionManager (  )  ;", "if    ( tm   instanceof   TransactionTimeoutConfiguration )     {", "return    (  ( TransactionTimeoutConfiguration )     ( tm )  )  . getTransactionTimeout (  )  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["getCurrentTransactionTimeout"], "fileName": "org.jboss.as.ejb3.tx.BMTInterceptor"}, {"methodBody": ["METHOD_START", "{", "ApplicationExceptionDetails   ae    =    component . getApplicationException ( ex . getClass (  )  ,    invocation . getMethod (  )  )  ;", "if    ( ae    !  =    null )     {", "throw    (  ( Exception )     ( ex )  )  ;", "}", "if    ( ex   instanceof   EJBException )     {", "throw    (  ( EJBException )     ( ex )  )  ;", "} else", "if    ( ex   instanceof   Exception )     {", "throw   new   EJBException (  (  ( Exception )     ( ex )  )  )  ;", "} else    {", "throw   new   EJBException ( new   RuntimeException ( ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleException"], "fileName": "org.jboss.as.ejb3.tx.BMTInterceptor"}, {"methodBody": ["METHOD_START", "{", "ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "try    {", "if    (  !  ( tx . equals ( tm . getTransaction (  )  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . wrongTxOnThread ( tx ,    tm . getTransaction (  )  )  ;", "}", "final   int   txStatus    =    tx . getStatus (  )  ;", "if    ( txStatus    =  =     ( Status . STATUS _ ACTIVE )  )     {", "tm . commit (  )  ;", "} else", "if    ( txStatus    =  =     ( Status . STATUS _ MARKED _ ROLLBACK )  )     {", "tm . rollback (  )  ;", "} else", "if    (  ( txStatus    =  =     ( Status . STATUS _ ROLLEDBACK )  )     |  |     ( txStatus    =  =     ( Status . STATUS _ ROLLING _ BACK )  )  )     {", "tm . rollback (  )  ;", "throw   EjbLogger . ROOT _ LOGGER . transactionAlreadyRolledBack ( tx )  ;", "} else", "if    ( txStatus    =  =     ( Status . STATUS _ UNKNOWN )  )     {", "tm . rollback (  )  ;", "throw   EjbLogger . ROOT _ LOGGER . transactionInUnexpectedState ( tx ,    util . StatusHelper . statusAsString ( txStatus )  )  ;", "} else    {", "tm . suspend (  )  ;", "throw   EjbLogger . ROOT _ LOGGER . transactionInUnexpectedState ( tx ,    util . StatusHelper . statusAsString ( txStatus )  )  ;", "}", "}    catch    ( RollbackException   e )     {", "throw   new   EJBTransactionRolledbackException ( e . toString (  )  ,    e )  ;", "}    catch    ( HeuristicMixedException    |    SystemException    |    HeuristicRollbackException   e )     {", "throw   new   EJBException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["endTransaction"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "endTransaction ( tx )  ;", "}    catch    ( Throwable   t )     {", "ouEx . addSuppressed ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["endTransaction"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   invocation . proceed (  )  ;", "}    catch    ( Error   e )     {", "final   EJBTransactionRolledbackExion   e 2     =    EjbLogger . ROOT _ LOGGER . unexpectedErrorRolledBack ( e )  ;", "setRollbackOnly ( tx ,    e 2  )  ;", "throw   e 2  ;", "}    catch    ( Exion   e )     {", "ApplicationExionDetails   ae    =    component . getApplicationExion ( e . getClass (  )  ,    invocation . getMethod (  )  )  ;", "if    ( ae    !  =    null )     {", "if    ( ae . isRollback (  )  )", "setRollbackOnly ( tx ,    e )  ;", "throw   e ;", "}", "try    {", "throw   e ;", "}    catch    ( EJBTransactionRolledbackExion    |    NoSuchEJBExion    |    NoSuchEntityExion   e 2  )     {", "setRollbackOnly ( tx ,    e 2  )  ;", "throw   e 2  ;", "}    catch    ( RuntimeExion   e 2  )     {", "final   EJBTransactionRolledbackExion   e 3     =    new   EJBTransactionRolledbackExion ( e 2  . getMessage (  )  ,    e 2  )  ;", "setRollbackOnly ( tx ,    e 3  )  ;", "throw   e 3  ;", "}", "}    catch    ( Throwable   t )     {", "final   EJBExion   e    =    new   EJBExion ( new   UndeclaredThrowableExion ( t )  )  ;", "setRollbackOnly ( tx ,    e )  ;", "throw   e ;", "}", "}", "METHOD_END"], "methodName": ["invokeInCallerTx"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "Transaction   tx ;", "try    {", "tx    =    invocation . getTransaction (  )  ;", "}    catch    ( SystemExion   ex )     {", "if    (  ( component    !  =    null )     &  &     ( component . getEjbSuspendHandlerService (  )  . isSuspended (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . cannotBeginUserTransaction (  )  ;", "} else    {", "throw   new   EJBExion ( ex )  ;", "}", "}", "safeResume ( tx )  ;", "final   Object   result ;", "try    {", "result    =    invokeInCallerTx ( invocation ,    tx ,    component )  ;", "}    catch    ( Throwable   t )     {", "safeSuspend ( t )  ;", "throw   t ;", "}", "safeSuspend (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["invokeInImportedTx"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   invocation . proceed (  )  ;", "}    catch    ( Error   e )     {", "throw   EjbLogger . ROOT _ LOGGER . unexpectedError ( e )  ;", "}    catch    ( EJBExion   e )     {", "throw   e ;", "}    catch    ( RuntimeExion   e )     {", "ApplicationExionDetails   ae    =    component . getApplicationExion ( e . getClass (  )  ,    invocation . getMethod (  )  )  ;", "throw   ae    !  =    null    ?    e    :    new   EJBExion ( e )  ;", "}    catch    ( Exion   e )     {", "throw   e ;", "}    catch    ( Throwable   t )     {", "throw   new   EJBExion ( new   UndeclaredThrowableExion ( t )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeInNoTx"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "tm . begin (  )  ;", "final   AbstractTransaction   tx    =    tm . getTransaction (  )  ;", "final   Object   result ;", "try    {", "result    =    invocation . proceed (  )  ;", "}    catch    ( Throwable   t )     {", "ApplicationExionDetails   ae    =    component . getApplicationExion ( t . getClass (  )  ,    invocation . getMethod (  )  )  ;", "try    {", "try    {", "throw   t ;", "}    catch    ( EJBExion    |    RemoteExion   e )     {", "throw   e ;", "}    catch    ( RuntimeExion   e )     {", "throw   ae    !  =    null    ?    e    :    new   EJBExion ( e )  ;", "}    catch    ( Exion   e )     {", "throw   e ;", "}    catch    ( Error   e )     {", "throw   EjbLogger . ROOT _ LOGGER . unexpectedError ( e )  ;", "}    catch    ( Throwable   e )     {", "throw   new   EJBExion ( new   UndeclaredThrowableExion ( e )  )  ;", "}", "}    catch    ( Throwable   t 2  )     {", "if    (  ( ae    =  =    null )     |  |     ( ae . isRollback (  )  )  )", "setRollbackOnly ( tx ,    t 2  )  ;", "endTransaction ( tx ,    t 2  )  ;", "throw   t 2  ;", "}", "}", "boolean   rolledBack    =     ( safeGetStatus ( tx )  )     =  =     ( Status . STATUS _ MARKED _ ROLLBACK )  ;", "endTransaction ( tx )  ;", "if    ( rolledBack )", "ourTxRolledBack (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["invokeInOurTx"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "Transaction   tx    =    tm . getTransaction (  )  ;", "if    ( tx    =  =    null )     {", "if    ( invocation . hasTransaction (  )  )     {", "return   invokeInImportedTx ( invocation ,    component )  ;", "}", "throw   EjbLogger . ROOT _ LOGGER . txRequiredForInvocation ( invocation )  ;", "}", "return   invokeInCallerTx ( invocation ,    tx ,    component )  ;", "}", "METHOD_END"], "methodName": ["mandatory"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "if    (  (  ( tm . getTransaction (  )  )     !  =    null )     |  |     ( invocation . hasTransaction (  )  )  )     {", "throw   EjbLogger . ROOT _ LOGGER . txPresentForNeverTxAttribute (  )  ;", "}", "return   invokeInNoTx ( invocation ,    component )  ;", "}", "METHOD_END"], "methodName": ["never"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "Transaction   tx    =    tm . getTransaction (  )  ;", "if    ( tx    !  =    null )     {", "safeSuspend (  )  ;", "final   Object   result ;", "try    {", "result    =    invokeInNoTx ( invocation ,    component )  ;", "}    catch    ( Throwable   t )     {", "safeResume ( tx ,    t )  ;", "throw   t ;", "}", "safeResume ( tx )  ;", "return   result ;", "} else    {", "return   invokeInNoTx ( invocation ,    component )  ;", "}", "}", "METHOD_END"], "methodName": ["notSupported"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   EJBComponent   component    =     (  ( EJBComponent )     ( invocation . getPrivateData ( Component . class )  )  )  ;", "final   CoxtTransactionManager   tm    =    CoxtTransactionManager . getInstance (  )  ;", "final   int   oldTimeout    =    tm . getTransactionTimeout (  )  ;", "try    {", "final   MethodIntf   methodIntf    =    MethodIntfHelper . of ( invocation )  ;", "final   TransactionAttributeType   attr    =    component . getTransactionAttributeType ( methodIntf ,    invocation . getMethod (  )  )  ;", "final   int   timeoutInSeconds    =    component . getTransactionTimeout ( methodIntf ,    invocation . getMethod (  )  )  ;", "switch    ( attr )     {", "case   MANDATORY    :", "return   mandatory ( invocation ,    component )  ;", "case   NEVER    :", "return   never ( invocation ,    component )  ;", "case   NOT _ SUPPORTED    :", "return   notSupported ( invocation ,    component )  ;", "case   REQUIRED    :", "return   required ( invocation ,    component ,    timeoutInSeconds )  ;", "case   REQUIRES _ NEW    :", "return   requiresNew ( invocation ,    component ,    timeoutInSeconds )  ;", "case   SUPPORTS    :", "return   supports ( invocation ,    component )  ;", "default    :", "throw   EjbLogger . ROOT _ LOGGER . unknownTxAttributeOnInvocation ( attr ,    invocation )  ;", "}", "}    finally    {", "tm . setTransactionTimeout (  ( oldTimeout    =  =     ( CoxtTransactionManager . getGlobalDefaultTransactionTimeout (  )  )     ?     0     :    oldTimeout )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "if    ( timeout    !  =     (  -  1  )  )     {", "tm . setTransactionTimeout ( timeout )  ;", "}", "final   Transaction   tx    =    tm . getTransaction (  )  ;", "if    ( tx    =  =    null )     {", "if    ( invocation . hasTransaction (  )  )     {", "return   invokeInImportedTx ( invocation ,    component )  ;", "}", "return   invokeInOurTx ( invocation ,    component )  ;", "} else    {", "return   invokeInCallerTx ( invocation ,    tx ,    component )  ;", "}", "}", "METHOD_END"], "methodName": ["required"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "if    ( timeout    !  =     (  -  1  )  )     {", "tm . setTransactionTimeout ( timeout )  ;", "}", "Transaction   tx    =    tm . getTransaction (  )  ;", "if    ( tx    !  =    null )     {", "safeSuspend (  )  ;", "final   Object   result ;", "try    {", "result    =    invokeInOurTx ( invocation ,    component )  ;", "}    catch    ( Throwable   t )     {", "safeResume ( tx ,    t )  ;", "throw   t ;", "}", "safeResume ( tx )  ;", "return   result ;", "} else    {", "return   invokeInOurTx ( invocation ,    component )  ;", "}", "}", "METHOD_END"], "methodName": ["requiresNew"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   tx . getStatus (  )  ;", "}    catch    ( SystemExion   e )     {", "return   Status . STATUS _ UNKNOWN ;", "}", "}", "METHOD_END"], "methodName": ["safeGetStatus"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "ContextTransactionManager . getInstance (  )  . resume ( tx )  ;", "}    catch    ( Exion   e )     {", "throw   new   EJBExion ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["safeResume"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "ContextTransactionManager . getInstance (  )  . resume ( tx )  ;", "}    catch    ( Exion   e )     {", "t . addSuppressed ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["safeResume"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "ContextTransactionManager . getInstance (  )  . suspend (  )  ;", "}    catch    ( SystemExion   e )     {", "throw   new   EJBExion ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["safeSuspend"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "ContextTransactionManager . getInstance (  )  . suspend (  )  ;", "}    catch    ( SystemExion   e )     {", "t . addSuppressed ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["safeSuspend"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "setRollbackOnly (  )  ;", "}    catch    ( Throwable   t 2  )     {", "EjbLogger . ROOT _ LOGGER . failedToSetRollbackOnly ( t 2  )  ;", "if    ( t    !  =    null )     {", "t . addSuppressed ( t 2  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRollbackOnly"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ContextTransactionManager   tm    =    ContextTransactionManager . getInstance (  )  ;", "Transaction   tx    =    tm . getTransaction (  )  ;", "if    ( tx    =  =    null )     {", "if    ( invocation . hasTransaction (  )  )     {", "return   invokeInImportedTx ( invocation ,    component )  ;", "}", "return   invokeInNoTx ( invocation ,    component )  ;", "} else    {", "return   invokeInCallerTx ( invocation ,    tx ,    component )  ;", "}", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.jboss.as.ejb3.tx.CMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "int   status    =    Status . STATUS _ NO _ TRANSACTION ;", "try    {", "status    =    tm . getStatus (  )  ;", "}    catch    ( SystemExion   sex )     {", "EjbLogger . ROOT _ LOGGER . failedToGetStatus ( sex )  ;", "}", "switch    ( status )     {", "case   Status . STATUS _ ACTIVE    :", "case   Status . STATUS _ COMMITTING    :", "case   Status . STATUS _ MARKED _ ROLLBACK    :", "case   Status . STATUS _ PREPARING    :", "case   Status . STATUS _ ROLLING _ BACK    :", "try    {", "tm . rollback (  )  ;", "}    catch    ( Exion   sex )     {", "EjbLogger . ROOT _ LOGGER . failedToRollback ( sex )  ;", "}", "case   Status . STATUS _ PREPARED    :", "final   String   msg    =    EjbLogger . ROOT _ LOGGER . transactionNotComplete ( component . getComponentName (  )  )  ;", "EjbLogger . ROOT _ LOGGER . error ( msg )  ;", "if    ( ex   instanceof   Exion )     {", "throw   new   EJBExion ( msg ,     (  ( Exion )     ( ex )  )  )  ;", "} else    {", "throw   new   EJBExion ( msg ,    new   RuntimeExion ( ex )  )  ;", "}", "}", "if    ( ex    !  =    null )", "throw   this . handleExion ( invocation ,    ex )  ;", "}", "METHOD_END"], "methodName": ["checkStatelessDone"], "fileName": "org.jboss.as.ejb3.tx.EjbBMTInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . checkNotNullParam (  \" owner \"  ,    owner )  ;", "synchronized ( this . l )     {", "if    ( Objects . equals ( owner ,    this . owner )  )     {", "( lCount )  +  +  ;", "} else", "if    (  ( this . owner )     =  =    null )     {", "this . owner    =    owner ;", "( lCount )  +  +  ;", "} else    {", "while    (  ( this . owner )     !  =    null )     {", "try    {", "( waiters )  +  +  ;", "try    {", "l . wait (  )  ;", "}    finally    {", "-  -  ( waiters )  ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "this . owner    =    owner ;", "( lCount )  +  +  ;", "}", "}", "}", "METHOD_END"], "methodName": ["lock"], "fileName": "org.jboss.as.ejb3.tx.OwnableReentrantLock"}, {"methodBody": ["METHOD_START", "{", "return    ( super . toString (  )  )     +     (  ( owner )     =  =    null    ?     \"  [ Unlocked ]  \"     :     (  \"  [ Locked   by    \"     +     ( owner )  )     +     \"  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.ejb3.tx.OwnableReentrantLock"}, {"methodBody": ["METHOD_START", "{", "Assert . checkNotNullParam (  \" owner \"  ,    owner )  ;", "synchronized ( this . l )     {", "if    ( Objects . equals ( owner ,    this . owner )  )     {", "( lCount )  +  +  ;", "return   true ;", "} else", "if    (  ( this . owner )     =  =    null )     {", "this . owner    =    owner ;", "( lCount )  +  +  ;", "return   true ;", "} else    {", "long   endTime    =     ( System . currentTimeMillis (  )  )     +     ( timeUnit . toMillis ( timeValue )  )  ;", "while    (  (  ( this . owner )     !  =    null )     &  &     (  ( System . currentTimeMillis (  )  )     <    endTime )  )     {", "try    {", "( waiters )  +  +  ;", "try    {", "l . wait (  ( endTime    -     ( System . currentTimeMillis (  )  )  )  )  ;", "}    finally    {", "( waiters )  -  -  ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "if    (  ( this . owner )     =  =    null )     {", "this . owner    =    owner ;", "( lCount )  +  +  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["tryLock"], "fileName": "org.jboss.as.ejb3.tx.OwnableReentrantLock"}, {"methodBody": ["METHOD_START", "{", "Assert . checkNotNullParam (  \" owner \"  ,    owner )  ;", "synchronized ( this . l )     {", "if    (  !  ( Objects . equals ( owner ,    this . owner )  )  )     {", "throw   new   IllegalMonitorStateException (  )  ;", "} else    {", "if    (  (  -  -  ( lCount )  )     =  =     0  )     {", "this . owner    =    null ;", "if    (  ( waiters )     >     0  )     {", "l . notifyAll (  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["unlock"], "fileName": "org.jboss.as.ejb3.tx.OwnableReentrantLock"}, {"methodBody": ["METHOD_START", "{", "int   status    =    Status . STATUS _ NO _ TRANSACTION ;", "TransactionManager   tm    =    getComponent (  )  . getTransactionManager (  )  ;", "try    {", "status    =    tm . getStatus (  )  ;", "}    catch    ( SystemException   ex )     {", "EjbLogger . ROOT _ LOGGER . failedToGetStatus ( ex )  ;", "}", "switch    ( status )     {", "case   Status . STATUS _ COMMITTING    :", "case   Status . STATUS _ MARKED _ ROLLBACK    :", "case   Status . STATUS _ PREPARING    :", "case   Status . STATUS _ ROLLING _ BACK    :", "try    {", "tm . rollback (  )  ;", "}    catch    ( Exception   ex )     {", "EjbLogger . ROOT _ LOGGER . failedToRollback ( ex )  ;", "}", "EjbLogger . ROOT _ LOGGER . transactionNotComplete ( getComponent (  )  . getComponentName (  )  ,    StatusHelper . statusAsString ( status )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkBadStateful"], "fileName": "org.jboss.as.ejb3.tx.StatefulBMTInterceptor"}, {"methodBody": ["METHOD_START", "{", "throw   EjbLogger . ROOT _ LOGGER . timerInvocationRolledBack (  )  ;", "}", "METHOD_END"], "methodName": ["ourTxRolledBack"], "fileName": "org.jboss.as.ejb3.tx.TimerCMTTxInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( status    >  =     ( Status . STATUS _ ACTIVE )  )     &  &     ( status    <  =     ( Status . STATUS _ ROLLING _ BACK )  )  )     {", "return    . TxStatusStrings [ status ]  ;", "} else    {", "return    (  \" STATUS _ INVALID (  \"     +    status )     +     \"  )  \"  ;", "}", "}", "METHOD_END"], "methodName": ["statusAsString"], "fileName": "org.jboss.as.ejb3.tx.util.StatusHelper"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    parameterTypes    =    viewMethod . getParameterTypes (  )  ;", "if    ( parameterTypes    =  =    null )     {", "return    . NO _ STRINGS ;", "}", "String [  ]    canonicalNames    =    new   String [ parameterTypes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( parameterTypes . length )  ;    i +  +  )     {", "canonicalNames [ i ]     =    parameterTypes [ i ]  . getCanonicalName (  )  ;", "}", "return   canonicalNames ;", "}", "METHOD_END"], "methodName": ["getCanonicalParameterTypes"], "fileName": "org.jboss.as.ejb3.util.MethodInfoHelper"}, {"methodBody": ["METHOD_START", "{", "return   deque . get (  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.ejb3.util.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "Object   o    =    st . peek (  )  ;", "if    ( o    =  =     (  . NULL _ VALUE )  )     {", "return   null ;", "} else    {", "return    (  ( E )     ( o )  )  ;", "}", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.jboss.as.ejb3.util.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "Object   o    =    st . pop (  )  ;", "if    ( o    =  =     (  . NULL _ VALUE )  )     {", "return   null ;", "} else    {", "return    (  ( E )     ( o )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jboss.as.ejb3.util.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "if    ( item    =  =    null )     {", "st . push (  . NULL _ VALUE )  ;", "} else    {", "st . push ( item )  ;", "}", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.ejb3.util.ThreadLocalStack"}]