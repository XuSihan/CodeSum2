[{"methodBody": ["METHOD_START", "{", "return   factory . createMarshaller ( configuration )  ;", "}", "METHOD_END"], "methodName": ["createMarshaller"], "fileName": "org.wildfly.extension.undertow.AbstractPersistentSessionManager"}, {"methodBody": ["METHOD_START", "{", "return   factory . createUnmarshaller ( configuration )  ;", "}", "METHOD_END"], "methodName": ["createUnmarshaller"], "fileName": "org.wildfly.extension.undertow.AbstractPersistentSessionManager"}, {"methodBody": ["METHOD_START", "{", "return   moduleLoaderInjectedValue ;", "}", "METHOD_END"], "methodName": ["getModuleLoaderInjectedValue"], "fileName": "org.wildfly.extension.undertow.AbstractPersistentSessionManager"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . home . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . home . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . server . server . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.wildfly.extension.undertow.AbstractUndertowSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( mainServices . isSuccessfulBoot (  )  )  )     {", "Throwable   t    =    mainServices . getBootError (  )  ;", "Assert . fail (  (  \" Boot   unsuccessful :     \"     +     ( t    !  =    null    ?    t . toString (  )     :     \" no   boot   error   provided \"  )  )  )  ;", "}", "ServiceController < FilterService >    connectionLimiter    =     (  ( ServiceController < FilterService >  )     ( mainServices . getContainer (  )  . getService ( ervice . FILTER . append (  \" limit - connections \"  )  )  )  )  ;", "connectionLimiter . setMode ( ACTIVE )  ;", "FilterService   connectionLimiterService    =    connectionLimiter . awaitValue (  )  ;", "HttpHandler   result    =    connectionLimiterService . createHttpHandler ( Predicates . truePredicate (  )  ,    new   PathHandler (  )  )  ;", "Assert . assertNotNull (  \" handler   should   have   been   created \"  ,    result )  ;", "ServiceController   headersFilter    =    mainServices . getContainer (  )  . getService ( ervice . FILTER . append (  \" headers \"  )  )  ;", "headersFilter . setMode ( ACTIVE )  ;", "FilterService   headersService    =     (  ( FilterService )     ( headersFilter . awaitValue (  )  )  )  ;", "HttpHandler   headerHandler    =    headersService . createHttpHandler ( Predicates . truePredicate (  )  ,    new   PathHandler (  )  )  ;", "Assert . assertNotNull (  \" handler   should   have   been   created \"  ,    headerHandler )  ;", "if    ( flag    >     0  )     {", "ServiceController   modClusterServiceServiceController    =    mainServices . getContainer (  )  . getService ( ervice . FILTER . append (  \" mod - cluster \"  )  )  ;", "modClusterServiceServiceController . setMode ( ACTIVE )  ;", "ModClusterService   modClusterService    =     (  ( ModClusterService )     ( modClusterServiceServiceController . awaitValue (  )  )  )  ;", "Assert . assertNotNull ( modClusterService )  ;", "Assert . assertNotNull ( modClusterService . getModCluster (  )  )  ;", "HttpHandler   modClusterHandler    =    modClusterService . createHttpHandler ( Predicates . truePredicate (  )  ,    new   PathHandler (  )  )  ;", "Assert . assertNotNull (  \" handler   should   have   been   created \"  ,    modClusterHandler )  ;", "}", "final   ServiceName   hostServiceName    =    HostDefinition . HOST _ CAPABILITY . getCapabilityServiceName ( virtualHostName ,     \" other - host \"  )  ;", "ServiceController   hostSC    =    mainServices . getContainer (  )  . getService ( hostServiceName )  ;", "Assert . assertNotNull ( hostSC )  ;", "hostSC . setMode ( ACTIVE )  ;", "Host   host    =     (  ( Host )     ( hostSC . awaitValue (  )  )  )  ;", "if    ( flag    =  =     1  )     {", "Assert . assertEquals (  3  ,    host . getAllAliases (  )  . size (  )  )  ;", "Assert . assertEquals (  \" default - alias \"  ,    new   ArrayList <  >  ( host . getAllAliases (  )  )  . get (  1  )  )  ;", "}", "final   ServiceName   locationServiceName    =    ervice . locationServiceName ( virtualHostName ,     \" default - virtual - host \"  ,     \"  /  \"  )  ;", "ServiceController   locationSC    =    mainServices . getContainer (  )  . getService ( locationServiceName )  ;", "Assert . assertNotNull ( locationSC )  ;", "locationSC . setMode ( ACTIVE )  ;", "LocationService   locationService    =     (  ( LocationService )     ( locationSC . getValue (  )  )  )  ;", "Assert . assertNotNull ( locationService )  ;", "connectionLimiter . setMode ( REMOVE )  ;", "final   ServiceName   servletContainerServiceName    =    ervice . SERVLET _ CONTAINER . append (  \" myContainer \"  )  ;", "ServiceController   servletContainerService    =    mainServices . getContainer (  )  . getService ( servletContainerServiceName )  ;", "Assert . assertNotNull ( servletContainerService )  ;", "JSPConfig   jspConfig    =     (  ( ServletContainerService )     ( servletContainerService . awaitValue (  )  )  )  . getJspConfig (  )  ;", "Assert . assertNotNull ( jspConfig )  ;", "Assert . assertNotNull ( jspConfig . createJSPServletInfo (  )  )  ;", "final   ServiceName   filterRefName    =    ervice . filterRefName ( virtualHostName ,     \" other - host \"  ,     \"  /  \"  ,     \" static - gzip \"  )  ;", "ServiceController   gzipFilterController    =    mainServices . getContainer (  )  . getService ( filterRefName )  ;", "gzipFilterController . setMode ( ACTIVE )  ;", "FilterRef   gzipFilterRef    =     (  ( FilterRef )     ( gzipFilterController . awaitValue (  )  )  )  ;", "HttpHandler   gzipHandler    =    gzipFilterRef . createHttpHandler ( new   PathHandler (  )  )  ;", "Assert . assertNotNull (  \" handler   should   have   been   created \"  ,    gzipHandler )  ;", "Assert . assertEquals (  1  ,    host . getFilters (  )  . size (  )  )  ;", "ModelNode   op    =    Util . createOperation (  \" write - attribute \"  ,    PathAddress . pathAddress ( UndertowExtension . SUBSYSTEM _ PATH )  . append (  \" servlet - container \"  ,     \" myContainer \"  )  . append (  \" setting \"  ,     \" websockets \"  )  )  ;", "op . get (  \" name \"  )  . set (  \" buffer - pool \"  )  ;", "op . get (  \" value \"  )  . set (  \" default \"  )  ;", "ModelNode   res    =    ModelTestUtils . checkOutcome ( mainServices . executeOperation ( op )  )  ;", "Assert . assertNotNull ( res )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.AbstractUndertowSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   accessLogServiceName    =    UndertowService . accessLogServiceName (  \" some - server \"  ,     \" default - virtual - host \"  )  ;", "ServiceController   accessLogSC    =    mainServices . getContainer (  )  . getService ( accessLogServiceName )  ;", "Assert . assertNotNull ( accessLogSC )  ;", "accessLogSC . setMode ( ACTIVE )  ;", "AccessLogService   accessLogService    =     (  ( AccessLogService )     ( accessLogSC . getValue (  )  )  )  ;", "Assert . assertNotNull ( accessLogService )  ;", "Assert . assertFalse ( accessLogService . isRotate (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRuntimeLast"], "fileName": "org.wildfly.extension.undertow.AbstractUndertowSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ServiceController   defaultHostSC    =    mainServices . getContainer (  )  . getService ( UndertowService . DEFAULT _ HOST )  ;", "defaultHostSC . setMode ( ACTIVE )  ;", "Host   defaultHost    =     (  ( Host )     ( defaultHostSC . getValue (  )  )  )  ;", "Assert . assertNotNull (  \" Default   host   should   exist \"  ,    defaultHost )  ;", "ServiceController   defaultServerSC    =    mainServices . getContainer (  )  . getService ( UndertowService . DEFAULT _ SERVER )  ;", "defaultServerSC . setMode ( ACTIVE )  ;", "Server   defaultServer    =     (  ( Server )     ( defaultServerSC . getValue (  )  )  )  ;", "Assert . assertNotNull (  \" Default   host   should   exist \"  ,    defaultServer )  ;", "}", "METHOD_END"], "methodName": ["testRuntimeOther"], "fileName": "org.wildfly.extension.undertow.AbstractUndertowSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "AccessLogAdd . INSTANCE . performRuntime ( context ,    operation ,    model )  ;", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.wildfly.extension.undertow.AccessLogRemove"}, {"methodBody": ["METHOD_START", "{", "if    (  ( extendedPattern )     !  =    null )     {", "return   new   ioserver . handlers . accesslog . AccessLogHandler ( handler ,    logReceiver ,    pattern ,    extendedPattern ,    predicate )  ;", "} else    {", "return   new   ioserver . handlers . accesslog . AccessLogHandler ( handler ,    logReceiver ,    pattern ,    getClass (  )  . getClassLoader (  )  ,    predicate )  ;", "}", "}", "METHOD_END"], "methodName": ["configureAccessLogHandler"], "fileName": "org.wildfly.extension.undertow.AccessLogService"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.wildfly.extension.undertow.AccessLogService"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.wildfly.extension.undertow.AccessLogService"}, {"methodBody": ["METHOD_START", "{", "return   pathManager ;", "}", "METHOD_END"], "methodName": ["getPathManager"], "fileName": "org.wildfly.extension.undertow.AccessLogService"}, {"methodBody": ["METHOD_START", "{", "return   worker ;", "}", "METHOD_END"], "methodName": ["getWorker"], "fileName": "org.wildfly.extension.undertow.AccessLogService"}, {"methodBody": ["METHOD_START", "{", "return   rotate ;", "}", "METHOD_END"], "methodName": ["isRotate"], "fileName": "org.wildfly.extension.undertow.AccessLogService"}, {"methodBody": ["METHOD_START", "{", "List < AttributeDefinition >    attrs    =    new   ArrayList ( super . getAttributes (  )  )  ;", "attrs . add (  . SCHEME )  ;", "attrs . add ( ListenerResourceDefinition . REDIRECT _ SOCKET )  ;", "attrs . add (  . MAX _ AJP _ PACKET _ SIZE )  ;", "return   attrs ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.wildfly.extension.undertow.AjpListenerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   ApplicationSecurityDomainDefinition . knownApplicationSecurityDomains :  : contains ;", "}", "METHOD_END"], "methodName": ["getKnownSecurityDomainPredicate"], "fileName": "org.wildfly.extension.undertow.ApplicationSecurityDomainDefinition"}, {"methodBody": ["METHOD_START", "{", "List < AuthMethodConfig >    res    =    AuthMethodParser . parse (  \" BASIC \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "Assert . assertEquals (  1  ,    res . size (  )  )  ;", "Assert . assertEquals (  0  ,    res . get (  0  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" BASIC \"  ,    res . get (  0  )  . getName (  )  )  ;", "res    =    AuthMethodParser . parse (  \" BASIC ? silent = true \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "Assert . assertEquals (  1  ,    res . size (  )  )  ;", "Assert . assertEquals (  1  ,    res . get (  0  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" BASIC \"  ,    res . get (  0  )  . getName (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    res . get (  0  )  . getProperties (  )  . get (  \" silent \"  )  )  ;", "res    =    AuthMethodParser . parse (  \" BASIC ? silent = true , FORM \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "Assert . assertEquals (  2  ,    res . size (  )  )  ;", "Assert . assertEquals (  1  ,    res . get (  0  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" BASIC \"  ,    res . get (  0  )  . getName (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    res . get (  0  )  . getProperties (  )  . get (  \" silent \"  )  )  ;", "Assert . assertEquals (  0  ,    res . get (  1  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" FORM \"  ,    res . get (  1  )  . getName (  )  )  ;", "res    =    AuthMethodParser . parse (  \" BASIC ? silent = true , FORM ,  \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "Assert . assertEquals (  2  ,    res . size (  )  )  ;", "Assert . assertEquals (  1  ,    res . get (  0  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" BASIC \"  ,    res . get (  0  )  . getName (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    res . get (  0  )  . getProperties (  )  . get (  \" silent \"  )  )  ;", "Assert . assertEquals (  0  ,    res . get (  1  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" FORM \"  ,    res . get (  1  )  . getName (  )  )  ;", "res    =    AuthMethodParser . parse (  \" BASIC ? silent = true , FORM ?  ,  \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "Assert . assertEquals (  2  ,    res . size (  )  )  ;", "Assert . assertEquals (  1  ,    res . get (  0  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" BASIC \"  ,    res . get (  0  )  . getName (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    res . get (  0  )  . getProperties (  )  . get (  \" silent \"  )  )  ;", "Assert . assertEquals (  0  ,    res . get (  1  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" FORM \"  ,    res . get (  1  )  . getName (  )  )  ;", "res    =    AuthMethodParser . parse (  \" BASIC ? silent = true , FORM ? a = b + c & d = e %  2  0 f ,  \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "Assert . assertEquals (  2  ,    res . size (  )  )  ;", "Assert . assertEquals (  1  ,    res . get (  0  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" BASIC \"  ,    res . get (  0  )  . getName (  )  )  ;", "Assert . assertEquals (  \" true \"  ,    res . get (  0  )  . getProperties (  )  . get (  \" silent \"  )  )  ;", "Assert . assertEquals (  2  ,    res . get (  1  )  . getProperties (  )  . size (  )  )  ;", "Assert . assertEquals (  \" FORM \"  ,    res . get (  1  )  . getName (  )  )  ;", "Assert . assertEquals (  \" b   c \"  ,    res . get (  1  )  . getProperties (  )  . get (  \" a \"  )  )  ;", "Assert . assertEquals (  \" e   f \"  ,    res . get (  1  )  . getProperties (  )  . get (  \" d \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAuthMechanismParsing"], "fileName": "org.wildfly.extension.undertow.AuthMechanismParserUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "return   hostInjector ;", "}", "METHOD_END"], "methodName": ["getHostInjector"], "fileName": "org.wildfly.extension.undertow.ConsoleRedirectService"}, {"methodBody": ["METHOD_START", "{", "return   httpManagementInjector ;", "}", "METHOD_END"], "methodName": ["getHttpManagementInjector"], "fileName": "org.wildfly.extension.undertow.ConsoleRedirectService"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )     {", "return   null ;", "}", "ModelNode   agents    =     . USER _ AGENTS . resolveModelAttribute ( context ,    model )  ;", "ModelNode   timeout    =     . SESSION _ TIMEOUT . resolveModelAttribute ( context ,    model )  ;", "if    (  ( timeout . isDefined (  )  )     &  &     ( agents . isDefined (  )  )  )     {", "return   new   CrawlerSessionManagerConfig ( timeout . asInt (  )  ,    agents . asString (  )  )  ;", "} else", "if    ( timeout . isDefined (  )  )     {", "return   new   CrawlerSessionManagerConfig ( timeout . asInt (  )  )  ;", "} else", "if    ( agents . isDefined (  )  )     {", "return   new   CrawlerSessionManagerConfig ( agents . asString (  )  )  ;", "}", "return   new   CrawlerSessionManagerConfig (  )  ;", "}", "METHOD_END"], "methodName": ["getConfig"], "fileName": "org.wildfly.extension.undertow.CrawlerSessionManagementDefinition"}, {"methodBody": ["METHOD_START", "{", "this . suspended    =    suspended ;", "}", "METHOD_END"], "methodName": ["setSuspended"], "fileName": "org.wildfly.extension.undertow.DefaultResponseCodeHandler"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  ;", "final   Resource   web    =    context . readResourceFromRoot ( address . subAddress (  0  ,    address . size (  )  )  ,    false )  ;", "final   ModelNode   subModel    =    web . getModel (  )  ;", "final   String   host    =     . VIRTUAL _ HOST . resolveModelAttribute ( context ,    subModel )  . asString (  )  ;", "final   String   path    =     . CONTEXT _ ROOT . resolveModelAttribute ( context ,    subModel )  . asString (  )  ;", "final   String   server    =     . SERVER . resolveModelAttribute ( context ,    subModel )  . asString (  )  ;", "final   UndertowDeploymentService   deploymentService ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( false )  . getService ( UndertowService . deploymentServiceName ( server ,    host ,    path )  )  ;", "if    (  ( controller    !  =    null )     &  &     (  ( controller . getState (  )  )     !  =     ( State . UP )  )  )     {", "throw   UndertowLogger . ROOT _ LOGGER . sessionManagerNotAvailable (  )  ;", "} else    {", "deploymentService    =     (  ( UndertowDeploymentService )     ( controller . getService (  )  )  )  ;", "if    (  ( deploymentService    =  =    null )     |  |     (  ( deploymentService . getDeployment (  )  )     =  =    null )  )     {", "throw   UndertowLogger . ROOT _ LOGGER . sessionManagerNotAvailable (  )  ;", "}", "}", "Deployment   deployment    =    deploymentService . getDeployment (  )  ;", "return   deployment . getSessionManager (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionManager"], "fileName": "org.wildfly.extension.undertow.DeploymentDefinition"}, {"methodBody": ["METHOD_START", "{", "return   pathManager ;", "}", "METHOD_END"], "methodName": ["getPathManager"], "fileName": "org.wildfly.extension.undertow.DiskBasedModularPersistentSessionManager"}, {"methodBody": ["METHOD_START", "{", "AccessLogService   logService    =    accessLogService ;", "HttpHandler   rootHandler    =    pathHandler ;", "ArrayList < UFilter >    filters    =    new   ArrayList <  >  ( this . filters )  ;", "rootHandler    =    new   Host . OptionsHandler ( rootHandler )  ;", "rootHandler    =    Handlers . httpContinueRead ( rootHandler )  ;", "rootHandler    =    LocationService . configureHandlerChain ( rootHandler ,    filters )  ;", "if    ( logService    !  =    null )     {", "rootHandler    =    logService . configureAccessLogHandler ( rootHandler )  ;", "}", "GateHandlerWrapper   gateHandlerWrapper    =    this . gateHandlerWrapper ;", "if    ( gateHandlerWrapper    !  =    null )     {", "rootHandler    =    gateHandlerWrapper . wrap ( rootHandler )  ;", "}", "return   rootHandler ;", "}", "METHOD_END"], "methodName": ["configureRootHandler"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashMap ( additionalAuthenticationMechanisms )  ;", "}", "METHOD_END"], "methodName": ["getAdditionalAuthenticationMechanisms"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   allAliases ;", "}", "METHOD_END"], "methodName": ["getAllAliases"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   controlledProcessStateServiceInjectedValue ;", "}", "METHOD_END"], "methodName": ["getControlledProcessStateServiceInjectedValue"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   defaultWebModule ;", "}", "METHOD_END"], "methodName": ["getDefaultWebModule"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return    \"  \"  . equals ( deploymentInfo . getContextPath (  )  )     ?     \"  /  \"     :    deploymentInfo . getContextPath (  )  ;", "}", "METHOD_END"], "methodName": ["getDeployedContextPath"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( deployments )  ;", "}", "METHOD_END"], "methodName": ["getDeployments"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( filters )  ;", "}", "METHOD_END"], "methodName": ["getFilters"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( locations . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLocations"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "HttpHandler   root    =    rootHandler ;", "if    ( root    =  =    null )     {", "synchronized ( this )     {", "root    =    rootHandler ;", "if    ( root    =  =    null )     {", "return   rootHandler    =    configureRootHandler (  )  ;", "}", "}", "}", "return   root ;", "}", "METHOD_END"], "methodName": ["getOrCreateRootHandler"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   hostRootHandler ;", "}", "METHOD_END"], "methodName": ["getRootHandler"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   server . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   server ;", "}", "METHOD_END"], "methodName": ["getServerInjection"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   suspendControllerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getSuspendControllerInjectedValue"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "return   undertowService ;", "}", "METHOD_END"], "methodName": ["getUndertowService"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "additionalAuthenticationMechanisms . put ( name ,    authenticationMechanism )  ;", "}", "METHOD_END"], "methodName": ["registerAdditionalAuthenticationMechanism"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "DeploymentInfo   deploymentInfo    =    deployment . getDeploymentInfo (  )  ;", "String   path    =    getDeployedContextPath ( deploymentInfo )  ;", "registerHandler ( path ,    handler )  ;", "deployments . add ( deployment )  ;", "UndertowLogger . ROOT _ LOGGER . registerWebapp ( path ,    getServer (  )  . getName (  )  )  ;", "Service . getValue (  )  . fireEvent (  (    listener )     -  >    listener . onDeploymentStart ( deployment ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["registerDeployment"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "pathHandler . addPrefixPath ( path ,    handler )  ;", "}", "METHOD_END"], "methodName": ["registerHandler"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "String   realPath    =     ( path . startsWith (  \"  /  \"  )  )     ?    path    :     \"  /  \"     +    path ;", "locations . put ( realPath ,    null )  ;", "Service . getValue (  )  . fireEvent (  (    listener )     -  >    listener . onDeploymentStart ( realPath ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["registerLocation"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "locations . put ( location . getLocationPath (  )  ,    location )  ;", "registerHandler ( location . getLocationPath (  )  ,    location . getLocationHandler (  )  )  ;", "Service . getValue (  )  . fireEvent (  (    listener )     -  >    listener . onDeploymentStart ( location . getLocationPath (  )  ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["registerLocation"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "this . accessLogService    =    service ;", "rootHandler    =    null ;", "}", "METHOD_END"], "methodName": ["setAccessLogService"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . defaultHandler )     !  =    null )     {", "this . registerHandler (  \"  /  \"  ,    this . defaultHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["setupDefaultResponseCodeHandler"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "additionalAuthenticationMechanisms . remove ( name )  ;", "}", "METHOD_END"], "methodName": ["unregisterAdditionalAuthenticationMechanism"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "DeploymentInfo   deploymentInfo    =    deployment . getDeploymentInfo (  )  ;", "String   path    =    getDeployedContextPath ( deploymentInfo )  ;", "Service . getValue (  )  . fireEvent (  (    listener )     -  >    listener . onDeploymentStop ( deployment ,    this )  )  ;", "unregisterHandler ( path )  ;", "deployments . remove ( deployment )  ;", "UndertowLogger . ROOT _ LOGGER . unregisterWebapp ( path ,    getServer (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterDeployment"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "pathHandler . removePrefixPath ( path )  ;", "Locatervice   locat =    locat . get ( path )  ;", "if    ( locat !  =    null )     {", "pathHandler . addPrefixPath ( locatgetLocatath (  )  ,    locatgetLocatandler (  )  )  ;", "} else", "if    ( path . equals (  \"  /  \"  )  )     {", "this . setupDefaultResponseCodeHandler (  )  ;", "}", "}", "METHOD_END"], "methodName": ["unregisterHandler"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "String   realPath    =     ( path . startsWith (  \"  /  \"  )  )     ?    path    :     \"  /  \"     +    path ;", "locations . remove ( realPath )  ;", "Service . getValue (  )  . fireEvent (  (    listener )     -  >    listener . onDeploymentStop ( realPath ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterLocation"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "locations . remove ( location . getLocationPath (  )  )  ;", "unregisterHandler ( location . getLocationPath (  )  )  ;", "Service . getValue (  )  . fireEvent (  (    listener )     -  >    listener . onDeploymentStop ( location . getLocationPath (  )  ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterLocation"], "fileName": "org.wildfly.extension.undertow.Host"}, {"methodBody": ["METHOD_START", "{", "WebHostService   service    =    new   WebHostService (  )  ;", "final   CapabilityServiceBuilder < WebHost >    builder    =    context . getCapabilityServiceTarget (  )  . addCapability ( CAPABILITY ,    service )  . addCapabilityRequirement ( Capabilities . CAPABILITY _ SERVER ,    Server . class ,    service . getServer (  )  ,    serverName )  . addCapabilityRequirement ( CAPABILITY _ NAME ,    CommonWebServer . class )  . addDependency ( virtualHostServiceName ,    Host . class ,    service . getHost (  )  )  ;", "if    ( context . hasOptionalCapability ( Capabilities . REF _ REQUEST _ CONTROLLER ,    null ,    null )  )     {", "builder . addCapabilityRequirement ( Capabilities . REF _ REQUEST _ CONTROLLER ,    RequestController . class ,    service . getRequestControllerInjectedValue (  )  )  ;", "}", "builder . addAliases ( SERVICE _ NAME . append ( context . getCurrentAddressValue (  )  )  )  ;", "if    ( aliases    !  =    null )     {", "for    ( String   alias    :    aliases )     {", "builder . addAliases ( SERVICE _ NAME . append ( alias )  )  ;", "}", "}", "builder . setInitialMode ( PASSIVE )  ;", "return   builder . install (  )  ;", "}", "METHOD_END"], "methodName": ["addCommonHost"], "fileName": "org.wildfly.extension.undertow.HostAdd"}, {"methodBody": ["METHOD_START", "{", "if    ( context . isResourceServiceRestartAllowed (  )  )     {", "Add . INSTANCE . performRuntime ( context ,    operation ,    model )  ;", "} else    {", "context . revertReloadRequired (  )  ;", "}", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.wildfly.extension.undertow.HostRemove"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.wildfly.extension.undertow.HttpInvokerHostService"}, {"methodBody": ["METHOD_START", "{", "return   httpAuthenticationFactoryInjectedValue ;", "}", "METHOD_END"], "methodName": ["getHttpAuthenticationFactoryInjectedValue"], "fileName": "org.wildfly.extension.undertow.HttpInvokerHostService"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.wildfly.extension.undertow.HttpInvokerHostService"}, {"methodBody": ["METHOD_START", "{", "return   realmService ;", "}", "METHOD_END"], "methodName": ["getRealmService"], "fileName": "org.wildfly.extension.undertow.HttpInvokerHostService"}, {"methodBody": ["METHOD_START", "{", "return   remoteHttpInvokerServiceInjectedValue ;", "}", "METHOD_END"], "methodName": ["getRemoteHttpInvokerServiceInjectedValue"], "fileName": "org.wildfly.extension.undertow.HttpInvokerHostService"}, {"methodBody": ["METHOD_START", "{", "domainHandler    =    new   io . undertow . security . handlers . AuthenticationCallHandler ( domainHandler )  ;", "domainHandler    =    new   io . undertow . security . handlers . AuthenticationConstraintHandler ( domainHandler )  ;", "Supplier < List < HttpServerAuthenticationMechanism >  >    mechanismSupplier    =     (  )     -  >    httpAuthenticationFactory . getMechanismNames (  )  . stream (  )  . map (  (    s )     -  >     {", "try    {", "return   httpAuthenticationFactory . createMechanism ( s )  ;", "}    catch    (    e )     {", "return   null ;", "}", "}  )  . collect ( Collectors . toList (  )  )  ;", "domainHandler    =    ElytronContextAssociationHandler . builder (  )  . setNext ( domainHandler )  . setMechanismSupplier ( mechanismSupplier )  . setHttpExchangeSupplier (  (    h )     -  >    new   ElytronHttpExchange ( h )     {", "@ Override", "public   void   authenticationComplete ( SecurityIdentity   securityIdentity ,    String   mechanismName )     {", "super . authenticationComplete ( securityIdentity ,    mechanismName )  ;", "h . putAttachment ( ElytronIdentityHandler . IDENTITY _ KEY ,    securityIdentity )  ;", "}", "}  )  . build (  )  ;", "return   domainHandler ;", "}", "METHOD_END"], "methodName": ["secureAccess"], "fileName": "org.wildfly.extension.undertow.HttpInvokerHostService"}, {"methodBody": ["METHOD_START", "{", "final   SimpleSessionIdentifierCodec   codec    =    new   SimpleSessionIdentifierCodec ( new   SimpleRoutingSupport (  )  ,    this . host . getValue (  )  . getServer (  )  . getRoute (  )  )  ;", "return    (    exchange )     -  >     {", "exchange . addResponseCommitListener (  (    ex )     -  >     {", "Cookie   cookie    =    ex . getResponseCookies (  )  . get (  . JSESSIONID )  ;", "if    ( cookie    !  =    null )     {", "cookie . setValue ( codec . encode ( cookie . getValue (  )  )  )  ;", "}", "}  )  ;", "handler . handleRequest ( exchange )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["setupRoutes"], "fileName": "org.wildfly.extension.undertow.HttpInvokerHostService"}, {"methodBody": ["METHOD_START", "{", "HttpListenerResourceDefinition . HTTP 2  _ ENABLE _ PUSH . resolveOption ( context ,    model ,    listenerBuilder )  ;", "HttpListenerResourceDefinition . HTTP 2  _ HEADER _ TABLE _ SIZE . resolveOption ( context ,    model ,    listenerBuilder )  ;", "HttpListenerResourceDefinition . HTTP 2  _ INITIAL _ WINDOW _ SIZE . resolveOption ( context ,    model ,    listenerBuilder )  ;", "HttpListenerResourceDefinition . HTTP 2  _ MAX _ CONCURRENT _ STREAMS . resolveOption ( context ,    model ,    listenerBuilder )  ;", "HttpListenerResourceDefinition . HTTP 2  _ MAX _ FRAME _ SIZE . resolveOption ( context ,    model ,    listenerBuilder )  ;", "HttpListenerResourceDefinition . HTTP 2  _ MAX _ HEADER _ LIST _ SIZE . resolveOption ( context ,    model ,    listenerBuilder )  ;", "}", "METHOD_END"], "methodName": ["handleHttp2Options"], "fileName": "org.wildfly.extension.undertow.HttpListenerAdd"}, {"methodBody": ["METHOD_START", "{", "List < AttributeDefinition >    attrs    =    new   ArrayList ( super . getAttributes (  )  )  ;", "attrs . add (  . CERTIFICATE _ FORWARDING )  ;", "attrs . add ( ListenerResourceDefinition . REDIRECT _ SOCKET )  ;", "attrs . add (  . PROXY _ ADDRESS _ FORWARDING )  ;", "attrs . add (  . ENABLE _ HTTP 2  )  ;", "attrs . add (  . HTTP 2  _ ENABLE _ PUSH )  ;", "attrs . add (  . HTTP 2  _ HEADER _ TABLE _ SIZE )  ;", "attrs . add (  . HTTP 2  _ INITIAL _ WINDOW _ SIZE )  ;", "attrs . add (  . HTTP 2  _ MAX _ CONCURRENT _ STREAMS )  ;", "attrs . add (  . HTTP 2  _ MAX _ HEADER _ LIST _ SIZE )  ;", "attrs . add (  . HTTP 2  _ MAX _ FRAME _ SIZE )  ;", "attrs . add (  . REQUIRE _ HOST _ HTTP 1  1  )  ;", "attrs . add (  . PROXY _ PROTOCOL )  ;", "return   attrs ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.wildfly.extension.undertow.HttpListenerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   httpListenerRegistry ;", "}", "METHOD_END"], "methodName": ["getHttpListenerRegistry"], "fileName": "org.wildfly.extension.undertow.HttpListenerService"}, {"methodBody": ["METHOD_START", "{", "server    =    worker . createStreamConnectionServer ( socketAddress ,    acceptListener ,    OptionMap . builder (  )  . addAll ( ListenerService . commonOptions )  . addAll ( socketOptions )  . getMap (  )  )  ;", "server . resumeAccepts (  )  ;", "final   InetSocketAddress   boundAddress    =    server . getLocalAddress ( InetSocketAddress . class )  ;", "UndertowLogger . ROOT _ LOGGER . listenerStarted (  \" HTTP \"  ,    getName (  )  ,    NetworkUtils . formatIPAddressForURI ( boundAddress . getAddress (  )  )  ,    boundAddress . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["startListening"], "fileName": "org.wildfly.extension.undertow.HttpListenerService"}, {"methodBody": ["METHOD_START", "{", "httpListenerRegistry . getValue (  )  . removeListener ( getName (  )  )  ;", "super . unregisterBinding (  )  ;", "}", "METHOD_END"], "methodName": ["unregisterBinding"], "fileName": "org.wildfly.extension.undertow.HttpListenerService"}, {"methodBody": ["METHOD_START", "{", "OptionMap   undertowOptions    =    OptionMap . builder (  )  . addAll ( ListenerService . commonOptions )  . addAll ( listenerOptions )  . set ( ENABLE _ CONNECTOR _ STATISTICS ,    getUndertowService (  )  . isStatisticsEnabled (  )  )  . getMap (  )  ;", "Pool < ByteBuffer >    bufferPool    =    getBufferPool (  )  . getValue (  )  ;", "HttpOpenListener   http    =    new   HttpOpenListener ( bufferPool ,    undertowOptions )  ;", "AlpnOpenListener   alpn    =    new   AlpnOpenListener ( bufferPool ,    undertowOptions ,    http )  ;", "if    ( listenerOptions . get ( ENABLE _ HTTP 2  ,    false )  )     {", "Http 2 OpenListener   http 2     =    new   Http 2 OpenListener ( bufferPool ,    undertowOptions ,     \" h 2  \"  )  ;", "alpn . addProtocol ( HTTP 2  ,    http 2  ,     1  0  )  ;", "Http 2 OpenListener   http 2  _  1  4     =    new   Http 2 OpenListener ( bufferPool ,    undertowOptions ,     \" h 2  -  1  4  \"  )  ;", "alpn . addProtocol ( HTTP 2  _  1  4  ,    http 2  _  1  4  ,     9  )  ;", "}", "return   alpn ;", "}", "METHOD_END"], "methodName": ["createAlpnOpenListener"], "fileName": "org.wildfly.extension.undertow.HttpsListenerService"}, {"methodBody": ["METHOD_START", "{", "Builder   builder    =    OptionMap . builder (  )  . addAll ( ListenerService . commonOptions )  ;", "builder . addAll ( socketOptions )  ;", "builder . set ( USE _ DIRECT _ BUFFERS ,    true )  ;", "if    (  ( cipherSuites )     !  =    null )     {", "String [  ]    cipherList    =    CipherSuiteSelector . fromString ( cipherSuites )  . evaluate ( sslContext . getSupportedSSLParameters (  )  . getCipherSuites (  )  )  ;", "builder . setSequence (  (  ( Option < Sequence < String >  >  )     ( HttpsListenerResourceDefinition . ENABLED _ CIPHER _ SUITES . getOption (  )  )  )  ,    cipherList )  ;", "}", "return   builder . getMap (  )  ;", "}", "METHOD_END"], "methodName": ["getSSLOptions"], "fileName": "org.wildfly.extension.undertow.HttpsListenerService"}, {"methodBody": ["METHOD_START", "{", "this . sslContextSupplier    =    sslContextSupplier ;", "}", "METHOD_END"], "methodName": ["setSSLContextSupplier"], "fileName": "org.wildfly.extension.undertow.HttpsListenerService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( servletInfo )     =  =    null )     {", "return   null ;", "}", "return   servletInfo . clone (  )  ;", "}", "METHOD_END"], "methodName": ["createJSPServletInfo"], "fileName": "org.wildfly.extension.undertow.JSPConfig"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )     {", "return   null ;", "}", "boolean   disabled    =     . DISABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   development    =     . DEVELOPMENT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   keepGenerated    =     . KEEP _ GENERATED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   trimSpaces    =     . TRIM _ SPACES . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   tagPooling    =     . TAG _ POOLING . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   mappedFile    =     . MAPPED _ FILE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "int   checkInterval    =     . CHECK _ INTERVAL . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "int   modificationTestInterval    =     . MODIFICATION _ TEST _ INTERVAL . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "boolean   recompileOnFile    =     . RECOMPILE _ ON _ FAIL . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   snap    =     . SMAP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   dumpSnap    =     . DUMP _ SMAP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   generateStringsAsCharArrays    =     . GENERATE _ STRINGS _ AS _ CHAR _ ARRAYS . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   errorOnUseBeanInvalidClassAttribute    =     . ERROR _ ON _ USE _ BEAN _ INVALID _ CLASS _ ATTRIBUTE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   ModelNode   scratchDirValue    =     . SCRATCH _ DIR . resolveModelAttribute ( context ,    model )  ;", "String   scratchDir    =     ( scratchDirValue . isDefined (  )  )     ?    scratchDirValue . asString (  )     :    null ;", "String   sourceVm    =     . SOURCE _ VM . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "String   targetVm    =     . TARGET _ VM . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "String   javaEncoding    =     . JAVA _ ENCODING . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "boolean   xPoweredBy    =     . X _ POWERED _ BY . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   displaySourceFragment    =     . DISPLAY _ SOURCE _ FRAGMENT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "boolean   optimizeScriptlets    =     . OPTIMIZE _ SCRIPTLETS . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "return   new   JSPConfig ( development ,    disabled ,    keepGenerated ,    trimSpaces ,    tagPooling ,    mappedFile ,    checkInterval ,    modificationTestInterval ,    recompileOnFile ,    snap ,    dumpSnap ,    generateStringsAsCharArrays ,    errorOnUseBeanInvalidClassAttribute ,    scratchDir ,    sourceVm ,    targetVm ,    javaEncoding ,    xPoweredBy ,    displaySourceFragment ,    optimizeScriptlets )  ;", "}", "METHOD_END"], "methodName": ["getConfig"], "fileName": "org.wildfly.extension.undertow.JspDefinition"}, {"methodBody": ["METHOD_START", "{", "return   ListenerResourceDefinition . ATTRIBUTES ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.wildfly.extension.undertow.ListenerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    context . getCurrentAddressValue (  )  ;", "ServiceName   serviceName    =     . LISTENER _ CAPABILITY . getCapabilityServiceName ( name )  ;", "ServiceController < ListenerService >    listenerSC    =     (  ( ServiceController < ListenerService >  )     ( context . getServiceRegistry ( false )  . getService ( serviceName )  )  )  ;", "if    (  ( listenerSC    =  =    null )     |  |     (  ( listenerSC . getState (  )  )     !  =     ( State . UP )  )  )     {", "return   null ;", "}", "return   listenerSC . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getListenerService"], "fileName": "org.wildfly.extension.undertow.ListenerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "listenerHandlerWrappers . add ( wrapper )  ;", "}", "METHOD_END"], "methodName": ["addWrapperHandler"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   binding ;", "}", "METHOD_END"], "methodName": ["getBinding"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   bufferPool ;", "}", "METHOD_END"], "methodName": ["getBufferPool"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   openListener ;", "}", "METHOD_END"], "methodName": ["getOpenListener"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   redirectSocket ;", "}", "METHOD_END"], "methodName": ["getRedirectSocket"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   OptionMap . EMPTY ;", "}", "METHOD_END"], "methodName": ["getSSLOptions"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   serverService ;", "}", "METHOD_END"], "methodName": ["getServerService"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getSsl"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   serverService . getValue (  )  . getUndertowService (  )  ;", "}", "METHOD_END"], "methodName": ["getUndertowService"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   worker ;", "}", "METHOD_END"], "methodName": ["getWorker"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "return   enabled ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "binding . getValue (  )  . getSocketBindings (  )  . getNamedRegistry (  )  . registerBinding ( new   ListenerService . ListenerBinding ( binding . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerBinding"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( started )     &  &     ( enabled    !  =     ( this . enabled )  )  )     {", "if    ( enabled )     {", "final   InetSocketAddress   socketAddress    =    binding . getValue (  )  . getSocketAddress (  )  ;", "final   Channel < AcceptingChannel < StreamConnection >  >    accept    =    Channels . openAdapter ( open )  ;", "try    {", "startListening ( worker . getValue (  )  ,    socketAddress ,    accept )  ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "} else    {", "stopListening (  )  ;", "}", "}", "this . enabled    =    enabled ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "final   SocketBinding   binding    =    this . binding . getValue (  )  ;", "binding . getSocketBindings (  )  . getNamedRegistry (  )  . unregrBinding ( binding . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterBinding"], "fileName": "org.wildfly.extension.undertow.ListenerService"}, {"methodBody": ["METHOD_START", "{", "ArrayList < UndertowFilter >    filters    =    new   ArrayList <  >  ( this . filters )  ;", "return    . configureHandlerChain ( getHttpHandler (  )  . getValue (  )  ,    filters )  ;", "}", "METHOD_END"], "methodName": ["configureHandler"], "fileName": "org.wildfly.extension.undertow.LocationService"}, {"methodBody": ["METHOD_START", "{", "filters . sort (  (    o 1  ,    o 2  )     -  >     ( o 1  . getPriority (  )  )     >  =     ( o 2  . getPriority (  )  )     ?     1     :     -  1  )  ;", "Collections . reverse ( filters )  ;", "HttpHandler   handler    =    rootHandler ;", "for    ( UFilter   filter    :    filters )     {", "handler    =    filter . wrap ( handler )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["configureHandlerChain"], "fileName": "org.wildfly.extension.undertow.LocationService"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.wildfly.extension.undertow.LocationService"}, {"methodBody": ["METHOD_START", "{", "return   httpHandler ;", "}", "METHOD_END"], "methodName": ["getHttpHandler"], "fileName": "org.wildfly.extension.undertow.LocationService"}, {"methodBody": ["METHOD_START", "{", "return   locationHandler ;", "}", "METHOD_END"], "methodName": ["getLocationHandler"], "fileName": "org.wildfly.extension.undertow.LocationService"}, {"methodBody": ["METHOD_START", "{", "return   locationPath ;", "}", "METHOD_END"], "methodName": ["getLocationPath"], "fileName": "org.wildfly.extension.undertow.LocationService"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.wildfly.extension.undertow.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.wildfly.extension.undertow.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   model . isDefined (  )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "org.wildfly.extension.undertow.PersistentSessionsDefinition"}, {"methodBody": ["METHOD_START", "{", "ListenerService   service    =    ListenerResourceDefinition . getListenerService ( context )  ;", "if    ( service    !  =    null )     {", "ConnectorStatistics   stats    =    service . getOpenListener (  )  . g (  )  ;", "if    ( stats    !  =    null )     {", "stats . reset (  )  ;", "}", "}", "context . completeStep ( NOOP _ ROLLBACK _ HANDLER )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.wildfly.extension.undertow.ResetConnectorStatisticsHandler"}, {"methodBody": ["METHOD_START", "{", "return   defaultHost ;", "}", "METHOD_END"], "methodName": ["getDefaultHost"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( hosts )  ;", "}", "METHOD_END"], "methodName": ["getHosts"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return    (  ( List )     ( listeners )  )  ;", "}", "METHOD_END"], "methodName": ["getListeners"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "UndertowService   service    =    this . undertowService . getValue (  )  ;", "String   defaultServerRoute    =    service . getInstanceId (  )  ;", "return   this . name . equals ( service . getDefaultServer (  )  )     ?    defaultServerRoute    :    String . join (  \"  -  \"  ,    defaultServerRoute ,    this . name )  ;", "}", "METHOD_END"], "methodName": ["getRoute"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   servletContainer . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getServletContainer"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   servletContainer ;", "}", "METHOD_END"], "methodName": ["getServletContainerInjector"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   undertowService . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getUndertowService"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   undertowService ;", "}", "METHOD_END"], "methodName": ["getUndertowServiceInjector"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "return   securePortMappings . get ( unsecurePort )  ;", "}", "METHOD_END"], "methodName": ["lookupSecurePort"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "hosts . add ( host )  ;", "f    ( String   hostName    :    host . getAllAliases (  )  )     {", "virtualHostHandler . addHost ( hostName ,    host . getRootHandler (  )  )  ;", "}", "if    ( host . getName (  )  . equals ( getDefaultHost (  )  )  )     {", "virtualHostHandler . setDefaultHandler ( host . getRootHandler (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerHost"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "listeners . add ( listener )  ;", "if    (  !  ( listener . isSecure (  )  )  )     {", "SocketBinding   binding    =    listener . getBinding (  )  . getValue (  )  ;", "SocketBinding   redirectBinding    =    listener . getRedirectSocket (  )  . getOptionalValue (  )  ;", "if    ( redirectBinding    !  =    null )     {", "securePortMappings . put ( binding . getAbsolutePort (  )  ,    redirectBinding . getAbsolutePort (  )  )  ;", "} else    {", "securePortMappings . put ( binding . getAbsolutePort (  )  ,     (  -  1  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerListener"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "for    ( String   hostName    :    host . getAllAliases (  )  )     {", "virtualHostHandler . removeHost ( hostName )  ;", "hosts . remove ( host )  ;", "}", "if    ( host . getName (  )  . equals ( getDefaultHost (  )  )  )     {", "virtualHostHandler . setDefaultHandler ( HANDLE _  4  0  4  )  ;", "}", "}", "METHOD_END"], "methodName": ["unregisterHost"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "listeners . remove ( listener )  ;", "if    (  !  ( listener . isSecure (  )  )  )     {", "SocketBinding   binding    =    listener . getBinding (  )  . getValue (  )  ;", "securePortMappings . remove ( binding . getAbsolutePort (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unregisterListener"], "fileName": "org.wildfly.extension.undertow.Server"}, {"methodBody": ["METHOD_START", "{", "ModelNode   listeners    =    Tools . readModel ( context . readResource ( PathAddress . pathAddress ( listenerPath )  )  ,     1  )  ;", "if    ( listeners . isDefined (  )  )     {", "for    ( Property   p    :    listeners . asPropertyList (  )  )     {", "for    ( Property   listener    :    p . getValue (  )  . asPropertyList (  )  )     {", "builder . addDependency ( ListenerResourceDefinitLISTENER _ CAPABILITY . getCapabilityServiceName ( listener . getName (  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addCommonHostListenerDeps"], "fileName": "org.wildfly.extension.undertow.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   fullModel    =    Tools . readModel ( context . readResource ( EMPTY _ ADDRESS )  ,     2  )  ;", "final   SessionCookieConfig   config    =    SessionCookieDefinition . INSTANCE . getConfig ( context ,    fullModel . get ( SessionCookieDefinition . INSTANCE . getPathElement (  )  . getKeyValuePair (  )  )  )  ;", "final   CrawlerSessionManagerConfig   crawlerSessionManagerConfig    =    CrawlerSessionManagementDefinition . INSTANCE . getConfig ( context ,    fullModel . get ( CrawlerSessionManagementDefinition . INSTANCE . getPathElement (  )  . getKeyValuePair (  )  )  )  ;", "final   boolean   persistentSessions    =    PersistentSessionsDefinition . isEnabled ( context ,    fullModel . get ( PersistentSessionsDefinition . INSTANCE . getPathElement (  )  . getKeyValuePair (  )  )  )  ;", "final   boolean   allowNonStandardWrappers    =    Definition . ALLOW _ NON _ STANDARD _ WRAPPERS . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   proactiveAuth    =    Definition . PROACTIVE _ AUTHENTICATION . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   String   bufferCache    =    Definition . DEFAULT _ BUFFER _ CACHE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   boolean   disableFileWatchService    =    Definition . DISABLE _ FILE _ WATCH _ SERVICE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   disableSessionIdReususe    =    Definition . DISABLE _ SESSION _ ID _ REUSE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "JSPConfig   jspConfig    =    JspDefinition . INSTANCE . getConfig ( context ,    fullModel . get ( JspDefinition . INSTANCE . getPathElement (  )  . getKeyValuePair (  )  )  )  ;", "final   String   stackTracesString    =    Definition . STACK _ TRACE _ ON _ ERROR . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ModelNode   defaultEncodingValue    =    Definition . DEFAULT _ ENCODING . resolveModelAttribute ( context ,    model )  ;", "final   String   defaultEncoding    =     ( defaultEncodingValue . isDefined (  )  )     ?    defaultEncodingValue . asString (  )     :    null ;", "final   boolean   useListenerEncoding    =    Definition . USE _ LISTENER _ ENCODING . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   ignoreFlush    =    Definition . IGNORE _ FLUSH . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   eagerFilterInit    =    Definition . EAGER _ FILTER _ INIT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   disableCachingForSecuredPages    =    Definition . DISABLE _ CACHING _ FOR _ SECURED _ PAGES . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   int   sessionIdLength    =    Definition . SESSION _ ID _ LENGTH . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   fileCacheMetadataSize    =    Definition . FILE _ CACHE _ METADATA _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   fileCacheMaxFileSize    =    Definition . FILE _ CACHE _ MAX _ FILE _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   ModelNode   fileCacheTtlNode    =    Definition . FILE _ CACHE _ TIME _ TO _ LIVE . resolveModelAttribute ( context ,    model )  ;", "final   Integer   fileCacheTimeToLive    =     ( fileCacheTtlNode . isDefined (  )  )     ?    fileCacheTtlNode . asInt (  )     :    null ;", "final   int   defaultCookieVersion    =    Definition . DEFAULT _ COOKIE _ VERSION . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "Boolean   directoryListingEnabled    =    null ;", "if    ( model . hasDefined ( Constants . DIRECTORY _ LISTING )  )     {", "directoryListingEnabled    =    Definition . DIRECTORY _ LISTING . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "}", "Integer   maxSessions    =    null ;", "if    ( model . hasDefined ( Constants . MAX _ SESSIONS )  )     {", "maxSessions    =    Definition . MAX _ SESSIONS . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "}", "final   int   sessionTimeout    =    Definition . DEFAULT _ SESSION _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "WebsocketsDefinition . WebSocketInfo   webSocketInfo    =    WebsocketsDefinition . INSTANCE . getConfig ( context ,    fullModel . get ( WebsocketsDefinition . INSTANCE . getPathElement (  )  . getKeyValuePair (  )  )  )  ;", "final   Map < String ,    String >    mimeMappings    =    new   HashMap <  >  (  )  ;", "if    ( fullModel . hasDefined ( Constants . MIME _ MAPPING )  )     {", "for    ( final   Property   mapping    :    fullModel . get ( Constants . MIME _ MAPPING )  . asPropertyList (  )  )     {", "mimeMappings . put ( mapping . getName (  )  ,    MimeMappingDefinition . VALUE . resolveModelAttribute ( context ,    mapping . getValue (  )  )  . asString (  )  )  ;", "}", "}", "List < String >    welcomeFiles    =    new   ArrayList <  >  (  )  ;", "if    ( fullModel . hasDefined ( Constants . WELCOME _ FILE )  )     {", "for    ( final   Property   welcome    :    fullModel . get ( Constants . WELCOME _ FILE )  . asPropertyList (  )  )     {", "welcomeFiles . add ( welcome . getName (  )  )  ;", "}", "}", "Map < String ,    AuthenticationMechanismFactory >    authenticationMechanisms    =    new   HashMap <  >  (  )  ;", "authenticationMechanisms . put (  \" SPNEGO \"  ,    new   NegotiationMechanismFactory (  )  )  ;", "authenticationMechanisms . put ( DIGEST _ AUTH ,    DigestAuthenticationMechanismFactory . FACTORY )  ;", "final   Service   container    =    new   Service ( allowNonStandardWrappers ,    ServletStackTraces . valueOf ( stackTracesString . toUpperCase (  )  . replace (  '  -  '  ,     '  _  '  )  )  ,    config ,    jspConfig ,    defaultEncoding ,    useListenerEncoding ,    ignoreFlush ,    eagerFilterInit ,    sessionTimeout ,    disableCachingForSecuredPages ,     ( webSocketInfo    !  =    null )  ,     (  ( webSocketInfo    !  =    null )     &  &     ( webSocketInfo . isDispatchToWorker (  )  )  )  ,     (  ( webSocketInfo    !  =    null )     &  &     ( webSocketInfo . isPerMessageDeflate (  )  )  )  ,     ( webSocketInfo    =  =    null    ?     -  1     :    webSocketInfo . getDeflaterLevel (  )  )  ,    mimeMappings ,    welcomeFiles ,    directoryListingEnabled ,    proactiveAuth ,    sessionIdLength ,    authenticationMechanisms ,    maxSessions ,    crawlerSessionManagerConfig ,    disableFileWatchService ,    disableSessionIdReususe ,    fileCacheMetadataSize ,    fileCacheMaxFileSize ,    fileCacheTimeToLive ,    defaultCookieVersion )  ;", "final   CapabilityServiceBuilder < Service >    builder    =    context . getCapabilityServiceTarget (  )  . addCapability ( Definition . SERVLET _ CONTAINER _ CAPABILITY ,    container )  ;", "if    ( bufferCache    !  =    null )     {", "builder . addDependency ( BufferCacheService . SERVICE _ NAME . append ( bufferCache )  ,    DirectBufferCache . class ,    container . getBufferCacheInjectedValue (  )  )  ;", "}", "if    ( persistentSessions )     {", "builder . addDependency ( AbstractPersistentSessionManager . SERVICE _ NAME ,    SessionPersistenceManager . class ,    container . getSessionPersistenceManagerInjectedValue (  )  )  ;", "}", "if    ( webSocketInfo    !  =    null )     {", "builder . addCapabilityRequirement ( Capabilities . REF _ IO _ WORKER ,    XnioWorker . class ,    container . getWebsocketsWorker (  )  ,    webSocketInfo . getWorker (  )  )  ;", "builder . addCapabilityRequirement ( Capabilities . REF _ BUFFER _ POOL ,    Pool . class ,     (  ( InjectedValue )     ( container . getWebsocketsBufferPool (  )  )  )  ,    webSocketInfo . getBufferPool (  )  )  ;", "}", "builder . setInitialMode ( ON _ DEMAND )  . addAliases ( UndertowService . SERVLET _ CONTAINER . append ( name )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installRuntimeServices"], "fileName": "org.wildfly.extension.undertow.ServletContainerAdd"}, {"methodBody": ["METHOD_START", "{", "return   authenticationMechanisms ;", "}", "METHOD_END"], "methodName": ["getAuthenticationMechanisms"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   bufferCacheInjectedValue . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getBufferCache"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   bufferCacheInjectedValue ;", "}", "METHOD_END"], "methodName": ["getBufferCacheInjectedValue"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   crawlerSessionManagerConfig ;", "}", "METHOD_END"], "methodName": ["getCrawlerSessionManagerConfig"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   defaultCookieVersion ;", "}", "METHOD_END"], "methodName": ["getDefaultCookieVersion"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   defaultEncoding ;", "}", "METHOD_END"], "methodName": ["getDefaultEncoding"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   defaultSessionTimeout ;", "}", "METHOD_END"], "methodName": ["getDefaultSessionTimeout"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   deflaterLevel ;", "}", "METHOD_END"], "methodName": ["getDeflaterLevel"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   directoryListingEnabled ;", "}", "METHOD_END"], "methodName": ["getDirectoryListingEnabled"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   fileCacheMaxFileSize ;", "}", "METHOD_END"], "methodName": ["getFileCacheMaxFileSize"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   fileCacheMetadataSize ;", "}", "METHOD_END"], "methodName": ["getFileCacheMetadataSize"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   fileCacheTimeToLive ;", "}", "METHOD_END"], "methodName": ["getFileCacheTimeToLive"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   jspConfig ;", "}", "METHOD_END"], "methodName": ["getJspConfig"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   maxSessions ;", "}", "METHOD_END"], "methodName": ["getMaxSessions"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( mimeMappings )  ;", "}", "METHOD_END"], "methodName": ["getMimeMappings"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   servletContainer ;", "}", "METHOD_END"], "methodName": ["getServletContainer"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   sessionCookieConfig ;", "}", "METHOD_END"], "methodName": ["getSessionCookieConfig"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   sessionIdLength ;", "}", "METHOD_END"], "methodName": ["getSessionIdLength"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   sessionPersistenceManagerInjectedValue . getOptionalValue (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionPersistenceManager"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   sessionPersistenceManagerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getSessionPersistenceManagerInjectedValue"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   stackTraces ;", "}", "METHOD_END"], "methodName": ["getStackTraces"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   websocketsBufferPool ;", "}", "METHOD_END"], "methodName": ["getWebsocketsBufferPool"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   websocketsWorker ;", "}", "METHOD_END"], "methodName": ["getWebsocketsWorker"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   welcomeFiles ;", "}", "METHOD_END"], "methodName": ["getWelcomeFiles"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   allowNonStandardWrappers ;", "}", "METHOD_END"], "methodName": ["isAllowNonStandardWrappers"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   disableCachingForSecuredPages ;", "}", "METHOD_END"], "methodName": ["isDisableCachingForSecuredPages"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   disableFileWatchService ;", "}", "METHOD_END"], "methodName": ["isDisableFileWatchService"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   disableSessionIdReuse ;", "}", "METHOD_END"], "methodName": ["isDisableSessionIdReuse"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   dispatchWebsocketInvocationToWorker ;", "}", "METHOD_END"], "methodName": ["isDispatchWebsocketInvocationToWorker"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   eagerFilterInit ;", "}", "METHOD_END"], "methodName": ["isEagerFilterInit"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   ignoreFlush ;", "}", "METHOD_END"], "methodName": ["isIgnoreFlush"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   perMessageDeflate ;", "}", "METHOD_END"], "methodName": ["isPerMessageDeflate"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   proactiveAuth ;", "}", "METHOD_END"], "methodName": ["isProactiveAuth"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   useListenerEncoding ;", "}", "METHOD_END"], "methodName": ["isUseListenerEncoding"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   websocketsEnabled ;", "}", "METHOD_END"], "methodName": ["isWebsocketsEnabled"], "fileName": "org.wildfly.extension.undertow.ServletContainerService"}, {"methodBody": ["METHOD_START", "{", "return   comment ;", "}", "METHOD_END"], "methodName": ["getComment"], "fileName": "org.wildfly.extension.undertow.SessionCookieConfig"}, {"methodBody": ["METHOD_START", "{", "return   domain ;", "}", "METHOD_END"], "methodName": ["getDomain"], "fileName": "org.wildfly.extension.undertow.SessionCookieConfig"}, {"methodBody": ["METHOD_START", "{", "return   httpOnly ;", "}", "METHOD_END"], "methodName": ["getHttpOnly"], "fileName": "org.wildfly.extension.undertow.SessionCookieConfig"}, {"methodBody": ["METHOD_START", "{", "return   maxAge ;", "}", "METHOD_END"], "methodName": ["getMaxAge"], "fileName": "org.wildfly.extension.undertow.SessionCookieConfig"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.undertow.SessionCookieConfig"}, {"methodBody": ["METHOD_START", "{", "return   secure ;", "}", "METHOD_END"], "methodName": ["getSecure"], "fileName": "org.wildfly.extension.undertow.SessionCookieConfig"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )     {", "return   null ;", "}", "ModelNode   nameValue    =     . NAME . resolveModelAttribute ( context ,    model )  ;", "ModelNode   domainValue    =     . DOMAIN . resolveModelAttribute ( context ,    model )  ;", "ModelNode   commentValue    =     . COMMENT . resolveModelAttribute ( context ,    model )  ;", "ModelNode   secureValue    =     . SECURE . resolveModelAttribute ( context ,    model )  ;", "ModelNode   httpOnlyValue    =     . HTTP _ ONLY . resolveModelAttribute ( context ,    model )  ;", "ModelNode   maxAgeValue    =     . MAX _ AGE . resolveModelAttribute ( context ,    model )  ;", "final   String   name    =     ( nameValue . isDefined (  )  )     ?    nameValue . asString (  )     :    null ;", "final   String   domain    =     ( domainValue . isDefined (  )  )     ?    domainValue . asString (  )     :    null ;", "final   String   comment    =     ( commentValue . isDefined (  )  )     ?    commentValue . asString (  )     :    null ;", "final   Boolean   secure    =     ( secureValue . isDefined (  )  )     ?    secureValue . asBoolean (  )     :    null ;", "final   Boolean   httpOnly    =     ( httpOnlyValue . isDefined (  )  )     ?    httpOnlyValue . asBoolean (  )     :    null ;", "final   Integer   maxAge    =     ( maxAgeValue . isDefined (  )  )     ?    maxAgeValue . asInt (  )     :    null ;", "return   new   SessionCookieConfig ( name ,    domain ,    comment ,    httpOnly ,    secure ,    maxAge )  ;", "}", "METHOD_END"], "methodName": ["getConfig"], "fileName": "org.wildfly.extension.undertow.SessionCookieDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.wildfly.extension.undertow.SingleSignOnService"}, {"methodBody": ["METHOD_START", "{", "return   this . manager ;", "}", "METHOD_END"], "methodName": ["getSingleSignOnSessionManager"], "fileName": "org.wildfly.extension.undertow.SingleSignOnService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowDependencies . UNDERTOW _ DEPENDENCIES . get ( controllerVersion )  ;", "}", "METHOD_END"], "methodName": ["getUndertowDependencies"], "fileName": "org.wildfly.extension.undertow.UndertowDependencies"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder ( UndertowExtension . SUBSYSTEM _ NAME )  ;", "for    ( String   kp    :    keyPrefix )     {", "prefix . append (  '  .  '  )  . append ( kp )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,    UndertowExtension . RESOURCE _ NAME ,    UndertowExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResolver"], "fileName": "org.wildfly.extension.undertow.UndertowExtension"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . virtualHostName ( server ,    virtualHost )  . append ( Constants . ACCESS _ LOG )  ;", "}", "METHOD_END"], "methodName": ["accessLogServiceName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . virtualHostName ( server ,    virtualHost )  . append (  \" console \"  ,     \" redirect \"  )  ;", "}", "METHOD_END"], "methodName": ["consoleRedirectServiceName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . WEB _ DEPLOYMENT _ BASE . append ( serverName )  . append ( virtualHost )  . append (  (  \"  \"  . equals ( contextPath )     ?     \"  /  \"     :    contextPath )  )  ;", "}", "METHOD_END"], "methodName": ["deploymentServiceName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . SERVER . append ( server )  . append ( virtualHost )  . append (  \" filter - ref \"  )  . append ( filterName )  ;", "}", "METHOD_END"], "methodName": ["filterRefName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . virtualHostName ( server ,    virtualHost )  . append ( Constants . LOCATION ,    locationName )  . append (  \" filter - ref \"  )  . append ( filterName )  ;", "}", "METHOD_END"], "methodName": ["filterRefName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( listeners )     {", "for    ( EventListener   listener    :    listeners )     {", "invoker . invoke ( listener )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["fireEvent"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   defaultContainer ;", "}", "METHOD_END"], "methodName": ["getDefaultContainer"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   defaultServer ;", "}", "METHOD_END"], "methodName": ["getDefaultServer"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   defaultVirtualHost ;", "}", "METHOD_END"], "methodName": ["getDefaultVirtualHost"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   oneUp    =    address . subAddress (  0  ,     (  ( address . size (  )  )     -     1  )  )  ;", "final   PathAddress   twoUp    =    oneUp . subAddress (  0  ,     (  ( oneUp . size (  )  )     -     1  )  )  ;", "final   PathAddress   threeUp    =    twoUp . subAddress (  0  ,     (  ( twoUp . size (  )  )     -     1  )  )  ;", "ServiceName   serviceName ;", "if    ( address . getLastElement (  )  . getKey (  )  . equals ( Constants . FILTER _ REF )  )     {", "if    ( oneUp . getLastElement (  )  . getKey (  )  . equals ( Constants . HOST )  )     {", "String   host    =    oneUp . getLastElement (  )  . getValue (  )  ;", "String   server    =    twoUp . getLastElement (  )  . getValue (  )  ;", "serviceName    =     . filterRefName ( server ,    host ,    name )  ;", "} else    {", "String   location    =    oneUp . getLastElement (  )  . getValue (  )  ;", "String   host    =    twoUp . getLastElement (  )  . getValue (  )  ;", "String   server    =    threeUp . getLastElement (  )  . getValue (  )  ;", "serviceName    =     . filterRefName ( server ,    host ,    location ,    name )  ;", "}", "} else", "if    ( address . getLastElement (  )  . getKey (  )  . equals ( Constants . HOST )  )     {", "String   host    =    address . getLastElement (  )  . getValue (  )  ;", "String   server    =    oneUp . getLastElement (  )  . getValue (  )  ;", "serviceName    =     . filterRefName ( server ,    host ,    name )  ;", "} else    {", "String   location    =    address . getLastElement (  )  . getValue (  )  ;", "String   host    =    oneUp . getLastElement (  )  . getValue (  )  ;", "String   server    =    twoUp . getLastElement (  )  . getValue (  )  ;", "serviceName    =     . filterRefName ( server ,    host ,    location ,    name )  ;", "}", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getFilterRefServiceName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   instanceId ;", "}", "METHOD_END"], "methodName": ["getInstanceId"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( registeredServers )  ;", "}", "METHOD_END"], "methodName": ["getServers"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   statisticsEnabled ;", "}", "METHOD_END"], "methodName": ["isStatisticsEnabled"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . UNDERTOW . append ( Constants . LISTENER )  . append ( listenerName )  ;", "}", "METHOD_END"], "methodName": ["listenerName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . virtualHostName ( server ,    virtualHost )  . append ( Constants . LOCATION ,    locationName )  ;", "}", "METHOD_END"], "methodName": ["locationServiceName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "this . listeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["registerListener"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "registeredServers . add ( server )  ;", "fireEvent ( new   EventInvoker (  )     {", "@ Override", "public   void   invoke ( EventListener   listener )     {", "listener . onServerStart ( server )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerServer"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "statisticsChangeListenters . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["registerStatisticsListener"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "this . statisticsEnabled    =    statisticsEnabled ;", "for    ( Consumer < Boolean >    liser    :    statisticsChangeListers )     {", "liser . accept ( statisticsEnabled )  ;", "}", "}", "METHOD_END"], "methodName": ["setStatisticsEnabled"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . virtualHostName ( server ,    virtualHost )  . append (  \" single - sign - on \"  )  ;", "}", "METHOD_END"], "methodName": ["ssoServiceName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "this . listeners . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["unregisterListener"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "registeredServers . remove ( server )  ;", "fireEvent ( new   EventInvoker (  )     {", "@ Override", "public   void   invoke ( EventListener   listener )     {", "listener . onServerStop ( server )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["unregisterServer"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "statisticsChangeListenters . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["unregisterStatisticsListener"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "return   UndertowService . SERVER . append ( server )  . append ( virtualHost )  ;", "}", "METHOD_END"], "methodName": ["virtualHostName"], "fileName": "org.wildfly.extension.undertow.UndertowService"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( UndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem10TestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( UndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeOther ( mainServices )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem11TestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( UndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem12TestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( UndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeOther ( mainServices )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem20TestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( AbstractUndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeOther ( mainServices )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeLast ( mainServices )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( AbstractUndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeOther ( mainServices )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeLast ( mainServices )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem31TestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( AbstractUndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeOther ( mainServices )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeLast ( mainServices )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem40TestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( AbstractUndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeOther ( mainServices )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeLast ( mainServices )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystem50TestCase"}, {"methodBody": ["METHOD_START", "{", "return   builder ( FilterRefDefinition . INSTANCE . getPathElement (  )  )  . addAttributes ( FilterRefDefinition . PREDICATE ,    FilterRefDefinition . PRIORITY )  ;", "}", "METHOD_END"], "methodName": ["filterRefBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_3_1"}, {"methodBody": ["METHOD_START", "{", "return   builder ( resource . getPathElement (  )  )  . addAttributes ( ListenerResourceDefinition . RECEIVE _ BUFFER ,    ListenerResourceDefinition . SEND _ BUFFER ,    ListenerResourceDefinition . BACKLOG ,    ListenerResourceDefinition . KEEP _ ALIVE ,    ListenerResourceDefinition . READ _ TIMEOUT ,    ListenerResourceDefinition . WRITE _ TIMEOUT ,    ListenerResourceDefinition . MAX _ CONNECTIONS )  . addAttributes ( ListenerResourceDefinition . SOCKET _ BINDING ,    ListenerResourceDefinition . WORKER ,    ListenerResourceDefinition . BUFFER _ POOL ,    ListenerResourceDefinition . ENABLED ,    ListenerResourceDefinition . RESOLVE _ PEER _ ADDRESS ,    ListenerResourceDefinition . MAX _ ENTITY _ SIZE ,    ListenerResourceDefinition . BUFFER _ PIPELINED _ DATA ,    ListenerResourceDefinition . MAX _ HEADER _ SIZE ,    ListenerResourceDefinition . MAX _ PARAMETERS ,    ListenerResourceDefinition . MAX _ HEADERS ,    ListenerResourceDefinition . MAX _ COOKIES ,    ListenerResourceDefinition . ALLOW _ ENCODED _ SLASH ,    ListenerResourceDefinition . DECODE _ URL ,    ListenerResourceDefinition . URL _ CHARSET ,    ListenerResourceDefinition . ALWAYS _ SET _ KEEP _ ALIVE ,    ListenerResourceDefinition . MAX _ BUFFERED _ REQUEST _ SIZE ,    ListenerResourceDefinition . RECORD _ REQUEST _ START _ TIME ,    ListenerResourceDefinition . ALLOW _ EQUALS _ IN _ COOKIE _ VALUE ,    ListenerResourceDefinition . NO _ REQUEST _ TIMEOUT ,    ListenerResourceDefinition . REQUEST _ PARSE _ TIMEOUT ,    ListenerResourceDefinition . DISALLOWED _ METHODS ,    ListenerResourceDefinition . SECURE )  ;", "}", "METHOD_END"], "methodName": ["listenerBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_3_1"}, {"methodBody": ["METHOD_START", "{", "return   builder ( FilterRefDefinition . INSTANCE . getPathElement (  )  )  . addAttributes ( FilterRefDefinition . PREDICATE ,    FilterRefDefinition . PRIORITY )  ;", "}", "METHOD_END"], "methodName": ["filterRefBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_4_0"}, {"methodBody": ["METHOD_START", "{", "return   builder ( resource . getPathElement (  )  )  . addAttributes ( ListenerResourceDefinition . RECEIVE _ BUFFER ,    ListenerResourceDefinition . SEND _ BUFFER ,    ListenerResourceDefinition . BACKLOG ,    ListenerResourceDefinition . KEEP _ ALIVE ,    ListenerResourceDefinition . READ _ TIMEOUT ,    ListenerResourceDefinition . WRITE _ TIMEOUT ,    ListenerResourceDefinition . MAX _ CONNECTIONS )  . addAttributes ( ListenerResourceDefinition . SOCKET _ BINDING ,    ListenerResourceDefinition . WORKER ,    ListenerResourceDefinition . BUFFER _ POOL ,    ListenerResourceDefinition . ENABLED ,    ListenerResourceDefinition . RESOLVE _ PEER _ ADDRESS ,    ListenerResourceDefinition . MAX _ ENTITY _ SIZE ,    ListenerResourceDefinition . BUFFER _ PIPELINED _ DATA ,    ListenerResourceDefinition . MAX _ HEADER _ SIZE ,    ListenerResourceDefinition . MAX _ PARAMETERS ,    ListenerResourceDefinition . MAX _ HEADERS ,    ListenerResourceDefinition . MAX _ COOKIES ,    ListenerResourceDefinition . ALLOW _ ENCODED _ SLASH ,    ListenerResourceDefinition . DECODE _ URL ,    ListenerResourceDefinition . URL _ CHARSET ,    ListenerResourceDefinition . ALWAYS _ SET _ KEEP _ ALIVE ,    ListenerResourceDefinition . MAX _ BUFFERED _ REQUEST _ SIZE ,    ListenerResourceDefinition . RECORD _ REQUEST _ START _ TIME ,    ListenerResourceDefinition . ALLOW _ EQUALS _ IN _ COOKIE _ VALUE ,    ListenerResourceDefinition . NO _ REQUEST _ TIMEOUT ,    ListenerResourceDefinition . REQUEST _ PARSE _ TIMEOUT ,    ListenerResourceDefinition . DISALLOWED _ METHODS ,    ListenerResourceDefinition . SECURE ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  ;", "}", "METHOD_END"], "methodName": ["listenerBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_4_0"}, {"methodBody": ["METHOD_START", "{", "return   builder ( FilterRefDefinition . INSTANCE . getPathElement (  )  )  . addAttributes ( FilterRefDefinition . PREDICATE ,    FilterRefDefinition . PRIORITY )  ;", "}", "METHOD_END"], "methodName": ["filterRefBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_5_0"}, {"methodBody": ["METHOD_START", "{", "return   builder ( resource . getPathElement (  )  )  . addAttributes ( ListenerResourceDefinition . RECEIVE _ BUFFER ,    ListenerResourceDefinition . SEND _ BUFFER ,    ListenerResourceDefinition . BACKLOG ,    ListenerResourceDefinition . KEEP _ ALIVE ,    ListenerResourceDefinition . READ _ TIMEOUT ,    ListenerResourceDefinition . WRITE _ TIMEOUT ,    ListenerResourceDefinition . MAX _ CONNECTIONS )  . addAttributes ( ListenerResourceDefinition . SOCKET _ BINDING ,    ListenerResourceDefinition . WORKER ,    ListenerResourceDefinition . BUFFER _ POOL ,    ListenerResourceDefinition . ENABLED ,    ListenerResourceDefinition . RESOLVE _ PEER _ ADDRESS ,    ListenerResourceDefinition . MAX _ ENTITY _ SIZE ,    ListenerResourceDefinition . BUFFER _ PIPELINED _ DATA ,    ListenerResourceDefinition . MAX _ HEADER _ SIZE ,    ListenerResourceDefinition . MAX _ PARAMETERS ,    ListenerResourceDefinition . MAX _ HEADERS ,    ListenerResourceDefinition . MAX _ COOKIES ,    ListenerResourceDefinition . ALLOW _ ENCODED _ SLASH ,    ListenerResourceDefinition . DECODE _ URL ,    ListenerResourceDefinition . URL _ CHARSET ,    ListenerResourceDefinition . ALWAYS _ SET _ KEEP _ ALIVE ,    ListenerResourceDefinition . MAX _ BUFFERED _ REQUEST _ SIZE ,    ListenerResourceDefinition . RECORD _ REQUEST _ START _ TIME ,    ListenerResourceDefinition . ALLOW _ EQUALS _ IN _ COOKIE _ VALUE ,    ListenerResourceDefinition . NO _ REQUEST _ TIMEOUT ,    ListenerResourceDefinition . REQUEST _ PARSE _ TIMEOUT ,    ListenerResourceDefinition . DISALLOWED _ METHODS ,    ListenerResourceDefinition . SECURE ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  ;", "}", "METHOD_END"], "methodName": ["listenerBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_5_0"}, {"methodBody": ["METHOD_START", "{", "return   builder ( FilterRefDefinition . INSTANCE . getPathElement (  )  )  . addAttributes ( FilterRefDefinition . PREDICATE ,    FilterRefDefinition . PRIORITY )  ;", "}", "METHOD_END"], "methodName": ["filterRefBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_6_0"}, {"methodBody": ["METHOD_START", "{", "return   builder ( resource . getPathElement (  )  )  . addAttributes ( ListenerResourceDefinition . RECEIVE _ BUFFER ,    ListenerResourceDefinition . SEND _ BUFFER ,    ListenerResourceDefinition . BACKLOG ,    ListenerResourceDefinition . KEEP _ ALIVE ,    ListenerResourceDefinition . READ _ TIMEOUT ,    ListenerResourceDefinition . WRITE _ TIMEOUT ,    ListenerResourceDefinition . MAX _ CONNECTIONS )  . addAttributes ( ListenerResourceDefinition . SOCKET _ BINDING ,    ListenerResourceDefinition . WORKER ,    ListenerResourceDefinition . BUFFER _ POOL ,    ListenerResourceDefinition . ENABLED ,    ListenerResourceDefinition . RESOLVE _ PEER _ ADDRESS ,    ListenerResourceDefinition . MAX _ ENTITY _ SIZE ,    ListenerResourceDefinition . BUFFER _ PIPELINED _ DATA ,    ListenerResourceDefinition . MAX _ HEADER _ SIZE ,    ListenerResourceDefinition . MAX _ PARAMETERS ,    ListenerResourceDefinition . MAX _ HEADERS ,    ListenerResourceDefinition . MAX _ COOKIES ,    ListenerResourceDefinition . ALLOW _ ENCODED _ SLASH ,    ListenerResourceDefinition . DECODE _ URL ,    ListenerResourceDefinition . URL _ CHARSET ,    ListenerResourceDefinition . ALWAYS _ SET _ KEEP _ ALIVE ,    ListenerResourceDefinition . MAX _ BUFFERED _ REQUEST _ SIZE ,    ListenerResourceDefinition . RECORD _ REQUEST _ START _ TIME ,    ListenerResourceDefinition . ALLOW _ EQUALS _ IN _ COOKIE _ VALUE ,    ListenerResourceDefinition . NO _ REQUEST _ TIMEOUT ,    ListenerResourceDefinition . REQUEST _ PARSE _ TIMEOUT ,    ListenerResourceDefinition . DISALLOWED _ METHODS ,    ListenerResourceDefinition . SECURE ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  ;", "}", "METHOD_END"], "methodName": ["listenerBuilder"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemParser_6_0"}, {"methodBody": ["METHOD_START", "{", "AbstractUndertowSubsystemTestCase . setProperty (  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( AbstractUndertowSubsystemTestCase . RUNTIME )  . setSubsystemXml ( getSubsystemXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "AbstractUndertowSubsystemTestCase . testRuntime ( mainServices ,    virtualHostName ,    flag )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeOther ( mainServices )  ;", "AbstractUndertowSubsystemTestCase . testRuntimeLast ( mainServices )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.undertow.UndertowSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "return   builder . addRejectCheck ( new   SimpleRejectAttributeChecker ( new   ModelNode ( true )  )  ,    HttpListenerResourceDefinition . REQUIRE _ HOST _ HTTP 1  1  . getName (  )  )  . setDiscard ( UndertowTransformers . FALSE _ DISCARD _ CHECKER ,    HttpListenerResourceDefinition . REQUIRE _ HOST _ HTTP 1  1  )  . setValueConverter ( new   DefaultValueAttributeConverter ( HttpListenerResourceDefinition . HTTP 2  _ HEADER _ TABLE _ SIZE )  ,    HttpListenerResourceDefinition . HTTP 2  _ HEADER _ TABLE _ SIZE )  . setValueConverter ( new   DefaultValueAttributeConverter ( HttpListenerResourceDefinition . HTTP 2  _ INITIAL _ WINDOW _ SIZE )  ,    HttpListenerResourceDefinition . HTTP 2  _ INITIAL _ WINDOW _ SIZE )  . setValueConverter ( new   DefaultValueAttributeConverter ( HttpListenerResourceDefinition . HTTP 2  _ MAX _ FRAME _ SIZE )  ,    HttpListenerResourceDefinition . HTTP 2  _ MAX _ FRAME _ SIZE )  . addRejectCheck ( new   SimpleRejectAttributeChecker ( new   ModelNode ( true )  )  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL . getName (  )  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL )  ;", "}", "METHOD_END"], "methodName": ["addCommonListenerRules_EAP_7_0_0"], "fileName": "org.wildfly.extension.undertow.UndertowTransformers"}, {"methodBody": ["METHOD_START", "{", "UndertowTransformers . convertCommonListenerAttributes ( listener )  ;", "listener . addRejectCheck ( DEFINED ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  . setDiscard ( UndertowTransformers . FALSE _ DISCARD _ CHECKER ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  ;", "}", "METHOD_END"], "methodName": ["addCommonListenerRules_EAP_7_1_0"], "fileName": "org.wildfly.extension.undertow.UndertowTransformers"}, {"methodBody": ["METHOD_START", "{", "builder . setValueConverter ( new   AttributeConverter . DefaultAttributeConverter (  )     {", "@ Override", "protected   void   convertAttribute ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    ationContext   context )     {", "if    (  ( attributeValue . isDefined (  )  )     &  &     (  ( attributeValue . asLong (  )  )     =  =     0 L )  )     {", "attributeValue . set ( Long . MAX _ VALUE )  ;", "}", "}", "}  ,    ListenerResourceDefinition . MAX _ ENTITY _ SIZE )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["convertCommonListenerAttributes"], "fileName": "org.wildfly.extension.undertow.UndertowTransformers"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   subsystemBuilder    =    Factory . createSubsystemInstance (  )  ;", "final   ResourceTransformationDescriptionBuilder   serverBuilder    =    subsystemBuilder . addChildResource ( UndertowExtension . SERVER _ PATH )  ;", "final   ResourceTransformationDescriptionBuilder   hostBuilder    =    serverBuilder . addChildResource ( UndertowExtension . HOST _ PATH )  ;", "AttributeTransformationDescriptionBuilder   https    =    serverBuilder . addChildResource ( UndertowExtension . HTTPS _ LISTENER _ PATH )  . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  . addRejectCheck ( DEFINED ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  . addRejectCheck ( DEFINED ,    HttpsListenerResourceDefinition . SSL _ CONTEXT )  . addRejectCheck ( UNDEFINED ,    Constants . SECURITY _ REALM )  . setDiscard ( DiscardAttributeChecker . UNDEFINED ,    HttpsListenerResourceDefinition . SSL _ CONTEXT )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    HttpListenerResourceDefinition . CERTIFICATE _ FORWARDING )  . addRejectCheck ( DEFINED ,    HttpListenerResourceDefinition . CERTIFICATE _ FORWARDING )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    HttpListenerResourceDefinition . PROXY _ ADDRESS _ FORWARDING )  . addRejectCheck ( DEFINED ,    HttpListenerResourceDefinition . PROXY _ ADDRESS _ FORWARDING )  ;", ". addCommonListenerRules _ EAP _  7  _  0  _  0  ( https )  . end (  )  ;", "AttributeTransformationDescriptionBuilder   http    =    serverBuilder . addChildResource ( UndertowExtension . HTTP _ LISTENER _ PATH )  . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  . addRejectCheck ( DEFINED ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  ;", ". addCommonListenerRules _ EAP _  7  _  0  _  0  ( http )  . end (  )  ;", "serverBuilder . addChildResource ( UndertowExtension . AJP _ LISTENER _ PATH )  . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ListenerResourceDefinition . RFC 6  2  6  5  _ COOKIE _ VALIDATION )  . addRejectCheck ( DEFINED ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL )  . end (  )  ;", "subsystemBuilder . addChildResource ( UndertowExtension . PATH _ SERVLET _ CONTAINER )  . getAttributeBuilder (  )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ServletContainerDefinition . DISABLE _ FILE _ WATCH _ SERVICE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . DISABLE _ FILE _ WATCH _ SERVICE )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    ServletContainerDefinition . DISABLE _ SESSION _ ID _ REUSE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . DISABLE _ SESSION _ ID _ REUSE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  (  (  1  0     *     1  0  2  4  )     *     1  0  2  4  )  )  )  ,    ServletContainerDefinition . FILE _ CACHE _ MAX _ FILE _ SIZE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . FILE _ CACHE _ MAX _ FILE _ SIZE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  1  0  0  )  )  ,    ServletContainerDefinition . FILE _ CACHE _ METADATA _ SIZE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . FILE _ CACHE _ METADATA _ SIZE )  . setDiscard ( DiscardAttributeChecker . UNDEFINED ,    ServletContainerDefinition . FILE _ CACHE _ TIME _ TO _ LIVE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . FILE _ CACHE _ TIME _ TO _ LIVE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  0  )  )  ,    ServletContainerDefinition . DEFAULT _ COOKIE _ VERSION )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . DEFAULT _ COOKIE _ VERSION )  . end (  )  . addChildResource ( UndertowExtension . PATH _ WEBSOCKETS )  . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    Constants . PER _ MESSAGE _ DEFLATE ,    Constants . DEFLATER _ LEVEL )  . setDiscard (  . FALSE _ DISCARD _ CHECKER ,    WebsocketsDefinition . PER _ MESSAGE _ DEFLATE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  0  )  )  ,    WebsocketsDefinition . DEFLATER _ LEVEL )  . end (  )  ;", "subsystemBuilder . addChildResource ( UndertowExtension . PATH _ HANDLERS )  . addChildResource ( PathElement . pathElement ( Constants . REVERSE _ PROXY )  )  . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  1 L )  )  ,    Constants . MAX _ RETRIES )  . addRejectCheck ( DEFINED ,    Constants . MAX _ RETRIES )  . setValueConverter ( new   DefaultValueAttributeConverter ( ReverseProxyHandler . CONNECTIONS _ PER _ THREAD )  ,    ReverseProxyHandler . CONNECTIONS _ PER _ THREAD )  . end (  )  . addChildResource ( PathElement . pathElement ( Constants . HOST )  )  . getAttributeBuilder (  )  . setDiscard ( DiscardAttributeChecker . UNDEFINED ,    HttpsListenerResourceDefinition . SSL _ CONTEXT )  . addRejectCheck ( DEFINED ,    Constants . SSL _ CONTEXT )  . setDiscard ( ALWAYS ,    Constants . ENABLE _ HTTP 2  )  . end (  )  ;", "subsystemBuilder . addChildResource ( UndertowExtension . PATH _ FILTERS )  . addChildResource ( PathElement . pathElement ( Constants . MOD _ CLUSTER )  )  . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( ModClusterDefinition . FAILOVER _ STRATEGY . getDefaultValue (  )  )  ,    ModClusterDefinition . FAILOVER _ STRATEGY )  . setDiscard ( new   DiscardAttributeValueChecker ( ModClusterDefinition . MAX _ RETRIES . getDefaultValue (  )  )  ,    ModClusterDefinition . MAX _ RETRIES )  . setValueConverter ( new   DefaultValueAttributeConverter ( ModClusterDefinition . MAX _ AJP _ PACKET _ SIZE )  ,    ModClusterDefinition . MAX _ AJP _ PACKET _ SIZE )  . setDiscard ( DiscardAttributeChecker . UNDEFINED ,    HttpsListenerResourceDefinition . SSL _ CONTEXT )  . addRejectCheck ( DEFINED ,    ModClusterDefinition . MAX _ RETRIES ,    ModClusterDefinition . FAILOVER _ STRATEGY )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,    ModClusterDefinition . MAX _ AJP _ PACKET _ SIZE )  . addRejectCheck ( DEFINED ,    HttpsListenerResourceDefinition . SSL _ CONTEXT )  . addRejectCheck ( UNDEFINED ,    Constants . SECURITY _ REALM )  . end (  )  ;", "hostBuilder . rejectChildResource ( UndertowExtension . PATH _ HTTP _ INVOKER )  ;", "subsystemBuilder . rejectChildResource ( UndertowExtension . PATH _ APPLICATION _ SECURITY _ DOMAIN )  ;", "Tools . register ( subsystemBuilder . build (  )  ,    subsystemRegistration ,     . MODEL _ VERSION _ EAP 7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_EAP_7_0_0"], "fileName": "org.wildfly.extension.undertow.UndertowTransformers"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   subsystemBuilder    =    Factory . createSubsystemInstance (  )  ;", "subsystemBuilder . addChildResource ( UndertowExtension . PATH _ SERVLET _ CONTAINER )  . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  (  (  1  0     *     1  0  2  4  )     *     1  0  2  4  )  )  )  ,    ServletContainerDefinition . FILE _ CACHE _ MAX _ FILE _ SIZE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . FILE _ CACHE _ MAX _ FILE _ SIZE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  1  0  0  )  )  ,    ServletContainerDefinition . FILE _ CACHE _ METADATA _ SIZE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . FILE _ CACHE _ METADATA _ SIZE )  . setDiscard ( UNDEFINED ,    ServletContainerDefinition . FILE _ CACHE _ TIME _ TO _ LIVE )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . FILE _ CACHE _ TIME _ TO _ LIVE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  0  )  )  ,    ServletContainerDefinition . DEFAULT _ COOKIE _ VERSION )  . addRejectCheck ( DEFINED ,    ServletContainerDefinition . DEFAULT _ COOKIE _ VERSION )  . end (  )  ;", "final   ResourceTransformationDescriptionBuilder   serverBuilder    =    subsystemBuilder . addChildResource ( UndertowExtension . SERVER _ PATH )  ;", "final   AttributeTransformationDescriptionBuilder   http    =    serverBuilder . addChildResource ( UndertowExtension . HTTP _ LISTENER _ PATH )  . getAttributeBuilder (  )  . addRejectCheck ( new   SimpleRejectAttributeChecker ( new   ModelNode ( true )  )  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL . getName (  )  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL )  ;", ". addCommonListenerRules _ EAP _  7  _  1  _  0  ( http )  ;", "http . end (  )  ;", "final   AttributeTransformationDescriptionBuilder   https    =    serverBuilder . addChildResource ( UndertowExtension . HTTPS _ LISTENER _ PATH )  . getAttributeBuilder (  )  . addRejectCheck ( new   SimpleRejectAttributeChecker ( new   ModelNode ( true )  )  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL . getName (  )  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL )  ;", ". addCommonListenerRules _ EAP _  7  _  1  _  0  ( https )  ;", "https . end (  )  ;", "final   AttributeTransformationDescriptionBuilder   ajp    =    serverBuilder . addChildResource ( UndertowExtension . AJP _ LISTENER _ PATH )  . getAttributeBuilder (  )  ;", ". addCommonListenerRules _ EAP _  7  _  1  _  0  ( ajp )  ;", "ajp . end (  )  ;", "Tools . register ( subsystemBuilder . build (  )  ,    subsystemRegistration ,     . MODEL _ VERSION _ EAP 7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_EAP_7_1_0"], "fileName": "org.wildfly.extension.undertow.UndertowTransformers"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    targetVersion )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . addSingleChildFirstClass ( DefaultInitialization . class )  . addMavenResourceURL ( UndertowDependencies . getUndertowDependencies ( controllerVersion )  )  . addMavenResourceURL ( String . format (  \"  % s : wildfly - undertow :  % s \"  ,    controllerVersion . getMavenGroupId (  )  ,    controllerVersion . getMavenGavVersion (  )  )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( targetVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource (  \" undertow - convert . xml \"  )  ;", "for    ( ModelNode   op    :    ops )     {", "if    (  ( op . hasDefined ( Constants . MAX _ POST _ SIZE )  )     &  &     (  ( op . get ( Constants . MAX _ POST _ SIZE )  . asLong (  )  )     =  =     0 L )  )     {", "dOperation   transformedOperation    =    mainServices . transformOperation ( targetVersion ,    op . clone (  )  )  ;", "ModelNode   transformed    =    transformedOperation . getdOperation (  )  . get ( Constants . MAX _ POST _ SIZE )  ;", "Assert . assertEquals (  (  ( Constants . MAX _ POST _ SIZE )     +     \"    should   be   transformed   for   value    0  .  \"  )  ,    Long . MAX _ VALUE ,    transformed . asLong (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doConvertTest"], "fileName": "org.wildfly.extension.undertow.UndertowTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    targetVersion )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . addSingleChildFirstClass ( DefaultInitialization . class )  . addMavenResourceURL ( String . format (  \"  % s : wildfly - undertow :  % s \"  ,    controllerVersion . getMavenGroupId (  )  ,    controllerVersion . getMavenGavVersion (  )  )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( targetVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource (  \" undertow - reject . xml \"  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( UndertowExtension . SUBSYSTEM _ PATH )  ;", "PathAddress   serverAddress    =    subsystemAddress . append ( UndertowExtension . SERVER _ PATH )  ;", "PathAddress   hostAddress    =    serverAddress . append ( UndertowExtension . HOST _ PATH )  ;", "PathAddress   httpsAddress    =    serverAddress . append ( UndertowExtension . HTTPS _ LISTENER _ PATH )  ;", "PathAddress   ajpAddress    =    serverAddress . append ( UndertowExtension . AJP _ LISTENER _ PATH )  ;", "PathAddress   httpAddress    =    serverAddress . append ( UndertowExtension . HTTP _ LISTENER _ PATH )  ;", "PathAddress   reverseProxy    =    subsystemAddress . append ( UndertowExtension . PATH _ HANDLERS )  . append ( Constants . REVERSE _ PROXY )  ;", "PathAddress   reverseProxyServerAddress    =    reverseProxy . append ( Constants . HOST )  ;", "PathAddress   modClusterPath    =    subsystemAddress . append ( UndertowExtension . PATH _ FILTERS )  . append ( Constants . MOD _ CLUSTER )  ;", "ModelTestUtils . checkFaileddBootOperations ( mainServices ,    targetVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( httpAddress ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( HttpListenerResourceDefinition . REQUIRE _ HOST _ HTTP 1  1  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL )  )  . addFailedAttribute ( httpsAddress ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( HttpListenerResourceDefinition . REQUIRE _ HOST _ HTTP 1  1  . getName (  )  ,    HttpListenerResourceDefinition . PROXY _ ADDRESS _ FORWARDING . getName (  )  ,    HttpListenerResourceDefinition . CERTIFICATE _ FORWARDING . getName (  )  ,    HttpsListenerResourceDefinition . SSL _ CONTEXT . getName (  )  ,    HttpsListenerResourceDefinition . ALLOW _ UNESCAPED _ CHARACTERS _ IN _ URL . getName (  )  ,    HttpListenerResourceDefinition . PROXY _ PROTOCOL . getName (  )  )  )  . addFailedAttribute ( reverseProxy ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ReverseProxyHandler . MAX _ RETRIES )  )  . addFailedAttribute ( reverseProxyServerAddress ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . SSL _ CONTEXT )  )  . addFailedAttribute ( hostAddress . append ( UndertowExtension . PATH _ HTTP _ INVOKER )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( subsystemAddress . append ( UndertowExtension . PATH _ APPLICATION _ SECURITY _ DOMAIN )  ,    DISCARDED _ RESOURCE )  . addFailedAttribute ( modClusterPath ,    new   FailedOperationTransformationConfig . RejectExpressionsConfig ( ModClusterDefinition . MAX _ AJP _ PACKET _ SIZE )  )  . addFailedAttribute ( modClusterPath ,    ChainedConfig . createBuilder ( HttpsListenerResourceDefinition . SSL _ CONTEXT ,    ModClusterDefinition . MAX _ RETRIES ,    ModClusterDefinition . FAILOVER _ STRATEGY ,    ModClusterDefinition . MAX _ AJP _ PACKET _ SIZE )  . addConfig ( new   FailedOperationTransformationConfig . RejectExpressionsConfig ( ModClusterDefinition . MAX _ AJP _ PACKET _ SIZE )  )  . addConfig ( new   FailedOperationTransformationConfig . NewAttributesConfig ( HttpsListenerResourceDefinition . SSL _ CONTEXT ,    ModClusterDefinition . MAX _ RETRIES ,    ModClusterDefinition . FAILOVER _ STRATEGY )  )  . build (  )  )  . addFailedAttribute ( subsystemAddress . append ( UndertowExtension . PATH _ APPLICATION _ SECURITY _ DOMAIN )  . append ( UndertowExtension . PATH _ SSO )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( subsystemAddress . append ( UndertowExtension . PATH _ APPLICATION _ SECURITY _ DOMAIN )  ,    REJECTED _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["doRejectTest"], "fileName": "org.wildfly.extension.undertow.UndertowTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "doConvertTest ( EAP _  7  _  1  _  0  ,    UndertowTransformersTestCase . EAP 7  _  1  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testConvertTransformersEAP_7_1_0"], "fileName": "org.wildfly.extension.undertow.UndertowTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "doRejectTest ( EAP _  7  _  0  _  0  ,    UndertowTransformersTestCase . EAP 7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.undertow.UndertowTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" undertow - transformers . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    undertowVersion )  . addMavenResourceURL ( String . format (  \"  % s : wildfly - undertow :  % s \"  ,    controllerVersion . getMavenGroupId (  )  ,    controllerVersion . getMavenGavVersion (  )  )  )  . addSingleChildFirstClass ( DefaultInitialization . class )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( undertowVersion )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    undertowVersion ,    null )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.wildfly.extension.undertow.UndertowTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  0  _  0  ,    UndertowTransformersTestCase . EAP 7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.undertow.UndertowTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.wildfly.extension.undertow.WebHostService"}, {"methodBody": ["METHOD_START", "{", "return   requestControllerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getRequestControllerInjectedValue"], "fileName": "org.wildfly.extension.undertow.WebHostService"}, {"methodBody": ["METHOD_START", "{", "return   server ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.undertow.WebHostService"}, {"methodBody": ["METHOD_START", "{", "HashMap < String ,    UndertowListener >    listeners    =    new   HashMap <  >  (  )  ;", "for    ( UndertowListener   listener    :    serverInjectedValue . getValue (  )  . getListeners (  )  )     {", "listeners . put ( listener . getProtocol (  )  ,    listener )  ;", "}", "return   listeners ;", "}", "METHOD_END"], "methodName": ["getListenerMap"], "fileName": "org.wildfly.extension.undertow.WebServerService"}, {"methodBody": ["METHOD_START", "{", "return   serverInjectedValue ;", "}", "METHOD_END"], "methodName": ["getServerInjectedValue"], "fileName": "org.wildfly.extension.undertow.WebServerService"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )     {", "return   null ;", "}", "boolean   dispatchToWorker    =     . DISPATCH _ TO _ WORKER . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "String   bufferPool    =     . BUFFER _ POOL . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "String   worker    =     . WORKER . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "boolean   perMessageDeflate    =     . PER _ MESSAGE _ DEFLATE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "int   deflaterLevel    =     . DEFLATER _ LEVEL . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "return   new    . WebSocketInfo ( worker ,    bufferPool ,    dispatchToWorker ,    perMessageDeflate ,    deflaterLevel )  ;", "}", "METHOD_END"], "methodName": ["getConfig"], "fileName": "org.wildfly.extension.undertow.WebsocketsDefinition"}, {"methodBody": ["METHOD_START", "{", "String   name    =    URLDecoder . decode ( part ,    AuthMethodParser . UTF _  8  )  ;", "if    ( replacements . containsKey ( name )  )     {", "return   new   AuthMethodConfig ( replacements . get ( name )  )  ;", "}", "return   new   AuthMethodConfig ( name )  ;", "}", "METHOD_END"], "methodName": ["createAuthMethodConfig"], "fileName": "org.wildfly.extension.undertow.deployment.AuthMethodParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( methods    =  =    null )     |  |     ( methods . isEmpty (  )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "final   List < AuthMethodConfig >    ret    =    new   ArrayList < AuthMethodConfig >  (  )  ;", "String [  ]    parts    =    methods . split (  \"  ,  \"  )  ;", "for    ( String   part    :    parts )     {", "if    ( part . isEmpty (  )  )     {", "continue ;", "}", "int   index    =    part . indexOf (  '  ?  '  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "ret . add (  . createAuthMethodConfig ( part ,    replacements )  )  ;", "} else    {", "final   String   name    =    part . substring (  0  ,    index )  ;", "Map < String ,    Deque < String >  >    props    =    QueryParameterUtils . parseQueryString ( part . substring (  ( index    +     1  )  )  ,     . UTF _  8  )  ;", "final   AuthMethodConfig   authMethodConfig    =     . createAuthMethodConfig ( name ,    replacements )  ;", "for    ( Map . Entry < String ,    Deque < String >  >    entry    :    props . entrySet (  )  )     {", "Deque < String >    val    =    entry . getValue (  )  ;", "if    ( val . isEmpty (  )  )     {", "authMethodConfig . getProperties (  )  . put ( entry . getKey (  )  ,     \"  \"  )  ;", "} else    {", "authMethodConfig . getProperties (  )  . put ( entry . getKey (  )  ,    val . getFirst (  )  )  ;", "}", "}", "ret . add ( authMethodConfig )  ;", "}", "}", "return   ret ;", "}    catch    ( UnsupportedEncodingException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.wildfly.extension.undertow.deployment.AuthMethodParser"}, {"methodBody": ["METHOD_START", "{", "String   pemOrig    =     \" MIGfMA 0 GCSqGSIb 3 DQEBAQUAA 4 GNADCBiQKBgQClH 5  +  5  2 mqHLdChbOfzuyue 5 FSDl 2 n 1 mOkpMlF 1  6  7  6 NT 7  9 AScHVMi 1 Io \"     +     (  \" hWkuSe 3 W + oPLE + GAwyyr 0 DyolUmTkrhrMID 6 LamgmH 8 IzhOeyaxDOjwbCIUeGM 1 V 9 Qht + nTneRMhGa / oL 6  8  7 XioZiE 1 Ev 5  2 D 8 kMa \"     +     \" KMNMHprL 9 oOZ / QM 4 wIDAQAB \"  )  ;", "String   pemEnc    =    URLEncoder . encode ( pemOrig ,     \" UTF -  8  \"  )  ;", "HashMap < String ,    String >    props    =    new   HashMap <  >  (  )  ;", "List < AuthMethodConfig >    authMethodConfigs    =     . parse (  (  \" CUSTOM ? publicKey =  \"     +    pemEnc )  ,    props )  ;", "AuthMethodConfig   authMethodConfig    =    authMethodConfigs . get (  0  )  ;", "String   pemDecode    =    authMethodConfig . getProperties (  )  . get (  \" publicKey \"  )  ;", "Assert . assertEquals (  \" publicKey    =    pemOrig ;    failed   probably   due   https :  /  / issues . jboss . org / browse / WFLY -  9  1  3  5  \"  ,    pemOrig ,    pemDecode )  ;", "}", "METHOD_END"], "methodName": ["testPEMEncoded"], "fileName": "org.wildfly.extension.undertow.deployment.AuthMethodParserTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mappings . putIfAbsent ( deploymentName ,    new   AbstractMap . SimpleEntry <  >  ( serverName ,    hostName )  )  )     !  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . duplicateDefaultWebModuleMapping ( deploymentName ,    serverName ,    hostName )  ;", "}", "}", "METHOD_END"], "methodName": ["addMapping"], "fileName": "org.wildfly.extension.undertow.deployment.DefaultDeploymentMappingProvider"}, {"methodBody": ["METHOD_START", "{", "mappings . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.wildfly.extension.undertow.deployment.DefaultDeploymentMappingProvider"}, {"methodBody": ["METHOD_START", "{", "return   mappings . get ( deploymentName )  ;", "}", "METHOD_END"], "methodName": ["getMapping"], "fileName": "org.wildfly.extension.undertow.deployment.DefaultDeploymentMappingProvider"}, {"methodBody": ["METHOD_START", "{", "return   DefaultDeploymentMappingProvider . INSTANCE ;", "}", "METHOD_END"], "methodName": ["instance"], "fileName": "org.wildfly.extension.undertow.deployment.DefaultDeploymentMappingProvider"}, {"methodBody": ["METHOD_START", "{", "mappings . remove ( deploymentName )  ;", "}", "METHOD_END"], "methodName": ["removeMapping"], "fileName": "org.wildfly.extension.undertow.deployment.DefaultDeploymentMappingProvider"}, {"methodBody": ["METHOD_START", "{", "DeploymentUnit   depUnit    =    phaseContext . getDeploymentUnit (  )  ;", "String   depName    =    depUnit . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    ( depName . endsWith (  . WAR _ EXTENSION )  )     {", "MountExplodedMarker . setMountExploded ( depUnit )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.wildfly.extension.undertow.deployment.DeploymentRootExplodedMountProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   WarMetaData   warMetaData    =    deploymentUnit . getAttachment ( ATTACHMENT _ KEY )  ;", "if    ( warMetaData    =  =    null )     {", "return ;", "}", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "if    ( deploymentRoot    =  =    null )     {", "return ;", "}", "final   DeploymentUnit   parent    =    deploymentUnit . getParent (  )  ;", "if    (  ( parent    =  =    null )     |  |     (  !  ( DeploymentTypeMarker . isType ( EAR ,    parent )  )  )  )     {", "return ;", "}", "final   EarMetaData   earMetaData    =    parent . getAttachment ( EAR _ METADATA )  ;", "if    ( earMetaData    =  =    null )     {", "return ;", "}", "final   ModulesMetaData   modulesMetaData    =    earMetaData . getModules (  )  ;", "if    ( modulesMetaData    !  =    null )", "for    ( ModuleMetaData   moduleMetaData    :    modulesMetaData )     {", "if    (  ( Web . equals ( moduleMetaData . getType (  )  )  )     &  &     ( moduleMetaData . getFileName (  )  . equals ( deploymentRoot . getRootName (  )  )  )  )     {", "String   contextRoot    =    cast ( moduleMetaData . getValue (  )  )  . get (  )  ;", "if    (  ( contextRoot    =  =    null )     &  &     (  (  ( warMetaData . getJBossWebMetaData (  )  )     =  =    null )     |  |     (  ( warMetaData . getJBossWebMetaData (  )  . get (  )  )     =  =    null )  )  )     {", "contextRoot    =     (  (  \"  /  \"     +     ( parent . getName (  )  . substring (  0  ,     (  ( parent . getName (  )  . length (  )  )     -     4  )  )  )  )     +     \"  /  \"  )     +     ( deploymentUnit . getName (  )  . substring (  0  ,     (  ( deploymentUnit . getName (  )  . length (  )  )     -     4  )  )  )  ;", "}", "if    ( contextRoot    !  =    null )     {", "JBossWebMetaData   jBossWebMetaData    =    warMetaData . getJBossWebMetaData (  )  ;", "if    ( jBossWebMetaData    =  =    null )     {", "jBossWebMetaData    =    new   JBossWebMetaData (  )  ;", "warMetaData . setJBossWebMetaData ( jBossWebMetaData )  ;", "}", "jBossWebMetaData . set ( contextRoot )  ;", "}", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.wildfly.extension.undertow.deployment.EarContextRootProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( ExternalTldParsingDeploymentProcessor . IMPLICIT _ TLD . equals ( tld . getName (  )  )  )     {", "return   new   TldMetaData (  )  ;", "}", "InputStream   is    =    null ;", "try    {", "is    =    tld . openStream (  )  ;", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( NoopXMLResolver . create (  )  )  ;", "XMLStreamReader   xmlReader    =    inputFactory . createXMLStreamReader ( is )  ;", "return   TldMetaDataParser . parse ( xmlReader )  ;", "}    catch    ( XMLStreamException   e )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . failToParseXMLDescriptor ( tld . getName (  )  ,    e . getLocation (  )  . getLineNumber (  )  ,    e . getLocation (  )  . getColumnNumber (  )  )  ,    e )  ;", "}    catch    ( IOException   e )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . failToParseXMLDescriptor ( tld . getName (  )  )  ,    e )  ;", "}    finally    {", "try    {", "if    ( is    !  =    null )     {", "is . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["parseTLD"], "fileName": "org.wildfly.extension.undertow.deployment.ExternalTldParsingDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "open    =    true ;", "for    (  . Holder   holder    :    held )     {", "holder . exchange . dispatch ( holder . next )  ;", "}", "held . clear (  )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.wildfly.extension.undertow.deployment.GateHandlerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   next ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.wildfly.extension.undertow.deployment.GlobalRequestControllerHandler"}, {"methodBody": ["METHOD_START", "{", "return    (    handler )     -  >    new   GlobalRequestControllerHandler ( handler ,    entryPoint ,    allowSuspendedRequests )  ;", "}", "METHOD_END"], "methodName": ["wrapper"], "fileName": "org.wildfly.extension.undertow.deployment.GlobalRequestControllerHandler"}, {"methodBody": ["METHOD_START", "{", "Principal   principal    =     ( account   instanceof   AccountImpl )     ?     (  ( AccountImpl )     ( account )  )  . getOriginalPrincipal (  )     :    account . getPrincipal (  )  ;", "if    ( principal    !  =    null )     {", "Subject   subject    =    SecurityActions . getSubject (  )  ;", "this . manager . l ( principal ,    subject )  ;", "}", "}", "METHOD_END"], "methodName": ["clearAccount"], "fileName": "org.wildfly.extension.undertow.deployment.LogoutSessionListener"}, {"methodBody": ["METHOD_START", "{", "ServletRequestContext   src    =    ServletRequestContext . current (  )  ;", "Account   requestAccount    =    null ;", "if    ( src    !  =    null )     {", "SecurityContext   securityContext    =    src . getExchange (  )  . getSecurityContext (  )  ;", "if    ( securityContext    !  =    null )     {", "requestAccount    =    securityContext . getAuthenticatedAccount (  )  ;", "if    ( requestAccount    !  =    null )     {", "clearAccount ( requestAccount )  ;", "}", "}", "}", "if    (  ( se . ge (  )  )    instanceof   HttpSessionImpl )     {", "final   HttpSessionImpl   impl    =     (  ( HttpSessionImpl )     ( se . ge (  )  )  )  ;", "Session   session    =    impl . ge (  )  ;", "if    ( session    !  =    null )     {", "AuthenticatedSessionManager . AuthenticatedSession   authenticatedSession    =     (  ( AuthenticatedSessionManager . AuthenticatedSession )     ( session . getAttribute (  (  ( CachedAuthenticatedSessionHandler . class . getName (  )  )     +     \"  . AuthenticatedSession \"  )  )  )  )  ;", "if    ( authenticatedSession    !  =    null )     {", "Account   sessionAccount    =    authenticatedSession . getAccount (  )  ;", "if    (  ( sessionAccount    !  =    null )     &  &     (  !  ( sessionAccount . equals ( requestAccount )  )  )  )     {", "clearAccount ( sessionAccount )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["sessionDestroyedImpl"], "fileName": "org.wildfly.extension.undertow.deployment.LogoutSessionListener"}, {"methodBody": ["METHOD_START", "{", "return   handlesTypes ;", "}", "METHOD_END"], "methodName": ["getHandlesTypes"], "fileName": "org.wildfly.extension.undertow.deployment.ScisMetaData"}, {"methodBody": ["METHOD_START", "{", "return   scis ;", "}", "METHOD_END"], "methodName": ["getScis"], "fileName": "org.wildfly.extension.undertow.deployment.ScisMetaData"}, {"methodBody": ["METHOD_START", "{", "this . handlesTypes    =    handlesTypes ;", "}", "METHOD_END"], "methodName": ["setHandlesTypes"], "fileName": "org.wildfly.extension.undertow.deployment.ScisMetaData"}, {"methodBody": ["METHOD_START", "{", "this . scis    =    scis ;", "}", "METHOD_END"], "methodName": ["setScis"], "fileName": "org.wildfly.extension.undertow.deployment.ScisMetaData"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < SecurityContext >  (  )     {", "public   SecurityContext   run (  )     {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}  )  ;", "} else    {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSecurityContext"], "fileName": "org.wildfly.extension.undertow.deployment.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < Subject >  (  )     {", "public   Subject   run (  )     {", "Subject   subject    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "subject    =    sc . getUtil (  )  . getSubject (  )  ;", "}", "return   subject ;", "}", "}  )  ;", "} else    {", "Subject   subject    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "subject    =    sc . getUtil (  )  . getSubject (  )  ;", "}", "return   subject ;", "}", "}", "METHOD_END"], "methodName": ["getSubject"], "fileName": "org.wildfly.extension.undertow.deployment.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "final   ServiceModuleLoader   loader    =    deploymentUnit . getAttachment ( SERVICE _ MODULE _ LOADER )  ;", "if    (  !  ( DeploymentTypeMarker . isType ( WAR ,    deploymentUnit )  )  )     {", "return ;", "}", "WarMetaData   warMetaData    =    deploymentUnit . getAttachment ( ATTACHMENT _ KEY )  ;", "assert   warMetaData    !  =    null ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "if    ( module    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . failedToResolveModule ( deploymentUnit )  ;", "}", "final   ClassLoader   classLoader    =    module . getClassLoader (  )  ;", "ScisMetaData   scisMetaData    =    deploymentUnit . getAttachment ( ScisMetaData . ATTACHMENT _ KEY )  ;", "if    ( scisMetaData    =  =    null )     {", "scisMetaData    =    new   ScisMetaData (  )  ;", "deploymentUnit . putAttachment ( ScisMetaData . ATTACHMENT _ KEY ,    scisMetaData )  ;", "}", "Set <  >    scis    =    scisMetaData . getScis (  )  ;", "Set < Class <  ?    extends    >  >    sciClasses    =    new   HashSet <  >  (  )  ;", "if    ( scis    =  =    null )     {", "scis    =    new   HashSet <  >  (  )  ;", "scisMetaData . setScis ( scis )  ;", "}", "Map <  ,    Set < Class <  ?  >  >  >    handlesTypes    =    scisMetaData . getHandlesTypes (  )  ;", "if    ( handlesTypes    =  =    null )     {", "handlesTypes    =    new   HashMap <  ,    Set < Class <  ?  >  >  >  (  )  ;", "scisMetaData . setHandlesTypes ( handlesTypes )  ;", "}", "for    ( ModuleDependency   dependency    :    moduleSpecification . getAllDependencies (  )  )     {", "if    (  !  ( dependency . isImportServices (  )  )  )     {", "continue ;", "}", "try    {", "Module   depModule    =    loader . loadModule ( dependency . getIdentifier (  )  )  ;", "ServiceLoader <  >    serviceLoader    =    depModule . loadService (  . class )  ;", "for    (    service    :    serviceLoader )     {", "if    ( sciClasses . add ( service . getClass (  )  )  )     {", "scis . add ( service )  ;", "}", "}", "}    catch    ( ModuleLoadException   e )     {", "if    (  !  ( dependency . isOptional (  )  )  )     {", "throw   UndertowLogger . ROOT _ LOGGER . errorLoadingSCIFromModule ( dependency . getIdentifier (  )  . toString (  )  ,    e )  ;", "}", "}", "}", "List < String >    order    =    warMetaData . getOrder (  )  ;", "Map < String ,    VirtualFile >    localScis    =    warMetaData . getScis (  )  ;", "if    (  ( order    !  =    null )     &  &     ( localScis    !  =    null )  )     {", "for    ( String   jar    :    order )     {", "VirtualFile   sci    =    localScis . get ( jar )  ;", "if    ( sci    !  =    null )     {", "scis . addAll ( loadSci ( classLoader ,    sci ,    jar ,    true ,    sciClasses )  )  ;", "}", "}", "}", "if    ( localScis    !  =    null )     {", "VirtualFile   warDeployedScis    =    localScis . get (  \" classes \"  )  ;", "if    ( warDeployedScis    !  =    null )     {", "scis . addAll ( loadSci ( classLoader ,    warDeployedScis ,    deploymentUnit . getName (  )  ,    true ,    sciClasses )  )  ;", "}", "}", "Map < Class <  ?  >  ,    Set <  >  >    typesMap    =    new   HashMap < Class <  ?  >  ,    Set <  >  >  (  )  ;", "for    (    service    :    scis )     {", "if    ( service . getClass (  )  . isAnnotationPresent ( HandlesTypes . class )  )     {", "HandlesTypes   handlesTypesAnnotation    =    service . getClass (  )  . getAnnotation ( HandlesTypes . class )  ;", "Class <  ?  >  [  ]    typesArray    =    handlesTypesAnnotation . value (  )  ;", "if    ( typesArray    !  =    null )     {", "for    ( Class <  ?  >    type    :    typesArray )     {", "Set <  >    servicesSet    =    typesMap . get ( type )  ;", "if    ( servicesSet    =  =    null )     {", "servicesSet    =    new   HashSet <  >  (  )  ;", "typesMap . put ( type ,    servicesSet )  ;", "}", "servicesSet . add ( service )  ;", "handlesTypes . put ( service ,    new   HashSet < Class <  ?  >  >  (  )  )  ;", "}", "}", "}", "}", "Class <  ?  >  [  ]    typesArray    =    typesMap . keySet (  )  . toArray ( new   Class <  ?  >  [  0  ]  )  ;", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "if    ( index    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . unableToResolveAnnotationIndex ( deploymentUnit )  ;", "}", "final   CompositeIndex   parent ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "parent    =    deploymentUnit . getParent (  )  . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "} else    {", "parent    =    null ;", "}", "CompositeIndex   parentIndex    =     (  ( deploymentUnit . getParent (  )  )     =  =    null )     ?    null    :    deploymentUnit . getParent (  )  . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "for    ( Class <  ?  >    type    :    typesArray )     {", "DotName   className    =    DotName . createSimple ( type . getName (  )  )  ;", "Set < ClassInfo >    classInfos    =    new   HashSet <  >  (  )  ;", "classInfos . addAll ( processHandlesType ( className ,    type ,    index ,    parent )  )  ;", "if    ( parentIndex    !  =    null )     {", "classInfos . addAll ( processHandlesType ( className ,    type ,    parentIndex ,    parent )  )  ;", "}", "Set < Class <  ?  >  >    classes    =    loadClassInfoSet ( classInfos ,    classLoader )  ;", "Set <  >    sciSet    =    typesMap . get ( type )  ;", "for    (    sci    :    sciSet )     {", "handlesTypes . get ( sci )  . addAll ( classes )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.wildfly.extension.undertow.deployment.ServletContainerInitializerDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?  >  >    classes    =    new   HashSet < Class <  ?  >  >  (  )  ;", "for    ( ClassInfo   classInfo    :    classInfos )     {", "Class <  ?  >    type ;", "try    {", "type    =    classLoader . loadClass ( classInfo . name (  )  . toString (  )  )  ;", "classes . add ( type )  ;", "}    catch    ( Exception   e )     {", "ULogger . ROOT _ LOGGER . cannotLoadDesignatedHandleTypes ( classInfo ,    e )  ;", "}", "}", "return   classes ;", "}", "METHOD_END"], "methodName": ["loadClassInfoSet"], "fileName": "org.wildfly.extension.undertow.deployment.ServletContainerInitializerDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < ServletContainerInitializer >    scis    =    new   ArrayList < ServletContainerInitializer >  (  )  ;", "InputStream   is    =    null ;", "try    {", "is    =    sci . openStream (  )  ;", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( is ,     \" UTF -  8  \"  )  )  ;", "String   servletContainerInitializerClassName    =    reader . readLine (  )  ;", "while    ( servletContainerInitializerClassName    !  =    null )     {", "try    {", "int   pos    =    servletContainerInitializerClassName . indexOf (  '  #  '  )  ;", "if    ( pos    >  =     0  )     {", "servletContainerInitializerClassName    =    servletContainerInitializerClassName . substring (  0  ,    pos )  ;", "}", "servletContainerInitializerClassName    =    servletContainerInitializerClassName . trim (  )  ;", "if    (  !  ( servletContainerInitializerClassName . isEmpty (  )  )  )     {", "ServletContainerInitializer   service    =     (  ( ServletContainerInitializer )     ( classLoader . loadClass ( servletContainerInitializerClassName )  . newInstance (  )  )  )  ;", "if    ( service    !  =    null )     {", "if    ( sciClasses . add ( service . getClass (  )  )  )     {", "scis . add ( service )  ;", "}", "}", "}", "servletContainerInitializerClassName    =    reader . readLine (  )  ;", "}    catch    ( Exception   e )     {", "if    ( error )     {", "throw   UndertowLogger . ROOT _ LOGGER . errorProcessingSCI ( jar ,    e )  ;", "} else    {", "UndertowLogger . ROOT _ LOGGER . skippedSCI ( jar ,    e )  ;", "}", "}", "}", "}    catch    ( Exception   e )     {", "if    ( error )     {", "throw   UndertowLogger . ROOT _ LOGGER . errorProcessingSCI ( jar ,    e )  ;", "} else    {", "UndertowLogger . ROOT _ LOGGER . skippedSCI ( jar ,    e )  ;", "}", "}    finally    {", "try    {", "if    ( is    !  =    null )", "is . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "return   scis ;", "}", "METHOD_END"], "methodName": ["loadSci"], "fileName": "org.wildfly.extension.undertow.deployment.ServletContainerInitializerDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "Set < ClassInfo >    classes    =    new   HashSet < ClassInfo >  (  )  ;", "if    ( type . isAnnotation (  )  )     {", "List < AnnotationInstance >    instances    =    index . getAnnotations ( typeName )  ;", "for    ( AnnotationInstance   instance    :    instances )     {", "AnnotationTarget   annotationTarget    =    instance . target (  )  ;", "if    ( annotationTarget   instanceof   ClassInfo )     {", "classes . add (  (  ( ClassInfo )     ( annotationTarget )  )  )  ;", "} else", "if    ( annotationTarget   instanceof   jboss . jandex . FieldInfo )     {", "classes . add (  (  ( jboss . jandex . FieldInfo )     ( annotationTarget )  )  . declaringClass (  )  )  ;", "} else", "if    ( annotationTarget   instanceof   jboss . jandex . MethodInfo )     {", "classes . add (  (  ( jboss . jandex . MethodInfo )     ( annotationTarget )  )  . declaringClass (  )  )  ;", "} else", "if    ( annotationTarget   instanceof   jboss . jandex . MethodParameterInfo )     {", "classes . add (  (  ( jboss . jandex . MethodParameterInfo )     ( annotationTarget )  )  . method (  )  . declaringClass (  )  )  ;", "}", "}", "} else    {", "classes . addAll ( index . getAllKnownSubclasses ( typeName )  )  ;", "classes . addAll ( index . getAllKnownImplementors ( typeName )  )  ;", "if    ( parent    !  =    null )     {", "Set < ClassInfo >    parentImplementors    =    new   HashSet <  >  (  )  ;", "parentImplementors . addAll ( parent . getAllKnownImplementors ( typeName )  )  ;", "parentImplementors . addAll ( parent . getAllKnownSubclasses ( typeName )  )  ;", "for    ( ClassInfo   pc    :    parentImplementors )     {", "classes . addAll ( index . getAllKnownSubclasses ( pc . name (  )  )  )  ;", "classes . addAll ( index . getAllKnownImplementors ( pc . name (  )  )  )  ;", "}", "}", "}", "return   classes ;", "}", "METHOD_END"], "methodName": ["processHandlesType"], "fileName": "org.wildfly.extension.undertow.deployment.ServletContainerInitializerDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "context . removeAttachment ( ScisMetaData . ATTACHMENT _ KEY )  ;", "}", "METHOD_END"], "methodName": ["undeploy"], "fileName": "org.wildfly.extension.undertow.deployment.ServletContainerInitializerDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getFile (  )  )     =  =    null )     {", "return   null ;", "}", "return   getFile (  )  . toPath (  )  ;", "}", "METHOD_END"], "methodName": ["getFilePath"], "fileName": "org.wildfly.extension.undertow.deployment.ServletResource"}, {"methodBody": ["METHOD_START", "{", "return   getResourceManagerRoot (  )  . toPath (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceManagerRootPath"], "fileName": "org.wildfly.extension.undertow.deployment.ServletResource"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   List < Resource >    ret    =    new   ArrayList <  >  (  )  ;", "Resource   res    =    deploymen . getResource ( path )  ;", "if    ( res    !  =    null )     {", "for    ( Resource   child    :    res . list (  )  )     {", "ret . add ( new   ServletResource ( this ,    child )  )  ;", "}", "}", "String   p    =    path ;", "if    ( p . startsWith (  \"  /  \"  )  )     {", "p    =    p . substring (  1  )  ;", "}", "if    (  ( overlays )     !  =    null )     {", "for    ( VirtualFile   overlay    :    overlays )     {", "VirtualFile   child    =    overlay . getChild ( p )  ;", "if    ( child . exists (  )  )     {", "VirtualFileResource   vfsResource    =    new   VirtualFileResource ( overlay . getPhysicalFile (  )  ,    child ,    path )  ;", "for    ( Resource   c    :    vfsResource . list (  )  )     {", "ret . add ( new   ServletResource ( this ,    c )  )  ;", "}", "}", "}", "}", "return   ret ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.wildfly.extension.undertow.deployment.ServletResourceManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TldParsingDeploymentProcessor . IMPLICIT _ TLD . equals ( tld . getName (  )  )  )     {", "return   new   TldMetaData (  )  ;", "}", "InputStream   is    =    null ;", "try    {", "is    =    tld . openStream (  )  ;", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( NoopXMLResolver . create (  )  )  ;", "XMLStreamReader   xmlReader    =    inputFactory . createXMLStreamReader ( is )  ;", "return   TldMetaDataParser . parse ( xmlReader )  ;", "}    catch    ( XMLStreamException   e )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . failToParseXMLDescriptor ( tld . toString (  )  ,    e . getLocation (  )  . getLineNumber (  )  ,    e . getLocation (  )  . getColumnNumber (  )  )  ,    e )  ;", "}    catch    ( IOException   e )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . failToParseXMLDescriptor ( tld . toString (  )  )  ,    e )  ;", "}    finally    {", "try    {", "if    ( is    !  =    null )     {", "is . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["parseTLD"], "fileName": "org.wildfly.extension.undertow.deployment.TldParsingDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( VirtualFile   file    :    files )     {", "if    (  ( file . isFile (  )  )     &  &     ( file . getName (  )  . toLowerCase ( Locale . ENGLISH )  . endsWith (  . TLD )  )  )     {", "String   pathNameRelativeToRoot ;", "try    {", "pathNameRelativeToRoot    =    file . getPathNameRelativeTo ( root )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . tldFileNotContainedInRoot ( file . getPathName (  )  ,    root . getPathName (  )  )  ,    e )  ;", "}", "final   TldMetaData   value    =    parseTLD ( file )  ;", "String   key    =     \"  /  \"     +    pathNameRelativeToRoot ;", "uniqueTlds . add ( value )  ;", "if    (  !  ( tlds . containsKey ( key )  )  )     {", "tlds . put ( key ,    value )  ;", "}", "} else", "if    ( file . isDirectory (  )  )     {", "processTlds ( root ,    file . getChildren (  )  ,    tlds ,    uniqueTlds )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processTlds"], "fileName": "org.wildfly.extension.undertow.deployment.TldParsingDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "return   sharedTlds . getSharedTlds ( deploymentUnit )  ;", "}", "METHOD_END"], "methodName": ["getSharedTlds"], "fileName": "org.wildfly.extension.undertow.deployment.TldsMetaData"}, {"methodBody": ["METHOD_START", "{", "return   tlds ;", "}", "METHOD_END"], "methodName": ["getTlds"], "fileName": "org.wildfly.extension.undertow.deployment.TldsMetaData"}, {"methodBody": ["METHOD_START", "{", "this . sharedTlds    =    sharedTlds ;", "}", "METHOD_END"], "methodName": ["setSharedTlds"], "fileName": "org.wildfly.extension.undertow.deployment.TldsMetaData"}, {"methodBody": ["METHOD_START", "{", "this . tlds    =    tlds ;", "}", "METHOD_END"], "methodName": ["setTlds"], "fileName": "org.wildfly.extension.undertow.deployment.TldsMetaData"}, {"methodBody": ["METHOD_START", "{", "executorsByName . put ( name ,    injected )  ;", "}", "METHOD_END"], "methodName": ["addInjectedExecutor"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "ListenerInfo   l ;", "final   Class <  ?    extends   EventListener >    listenerClass    =     (  ( Class <  ?    extends   EventListener >  )     ( classLoader . loadClass ( listener . getListenerClass (  )  )  )  )  ;", "ManagedReferenceFactory   creator    =    components . createInstanceFactory ( listenerClass )  ;", "if    ( creator    !  =    null )     {", "InstanceFactory < EventListener >    factory    =     . createInstanceFactory ( creator )  ;", "l    =    new   ListenerInfo ( listenerClass ,    factory ,    programatic )  ;", "} else    {", "l    =    new   ListenerInfo ( listenerClass ,    programatic )  ;", "}", "d . addListener ( l )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "if    ( configuredMethod    =  =    null )     {", "return   Collections . singletonList ( new   ioservlet . api . AuthMethodConfig ( HttpServletRequest . BASIC _ AUTH )  )  ;", "}", "return   AuthMethodParser . parse ( configuredMethod ,    Collections . singletonMap (  \" CLIENT - CERT \"  ,    CLIENT _ CERT _ AUTH )  )  ;", "}", "METHOD_END"], "methodName": ["authMethod"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   new   UndertowDeploymentInfoService . Builder (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   new   io . undertow . servlet . api . InstanceFactory < T >  (  )     {", "@ Override", "public   InstanceHandle < T >    createInstance (  )    throws   InstantiationException    {", "final   ManagedReference   instance    =    creator . getReference (  )  ;", "return   new   InstanceHandle < T >  (  )     {", "@ Override", "public   T   getInstance (  )     {", "return    (  ( T )     ( instance . getInstance (  )  )  )  ;", "}", "@ Override", "public   void   release (  )     {", "instance . release (  )  ;", "}", "}  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createInstanceFactory"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "final   HashMap < String ,    JspPropertyGroup >    result    =    new   HashMap <  >  (  )  ;", "JspConfigMetaData   config    =    metaData . getJspConfig (  )  ;", "if    ( config    !  =    null )     {", "List < JspPropertyGroupMetaData >    groups    =    config . getPropertyGroups (  )  ;", "if    ( groups    !  =    null )     {", "for    ( JspPropertyGroupMetaData   group    :    groups )     {", "JspPropertyGroup   jspPropertyGroup    =    new   JspPropertyGroup (  )  ;", "for    ( String   pattern    :    group . getUrlPatterns (  )  )     {", "jspPropertyGroup . addUrlPattern ( pattern )  ;", "}", "jspPropertyGroup . setElIgnored ( group . getElIgnored (  )  )  ;", "jspPropertyGroup . setPageEncoding ( group . getPageEncoding (  )  )  ;", "jspPropertyGroup . setScriptingInvalid ( group . getScriptingInvalid (  )  )  ;", "jspPropertyGroup . setIsXml ( group . getIsXml (  )  )  ;", "if    (  ( group . getIncludePreludes (  )  )     !  =    null )     {", "for    ( String   includePrelude    :    group . getIncludePreludes (  )  )     {", "jspPropertyGroup . addIncludePrelude ( includePrelude )  ;", "}", "}", "if    (  ( group . getIncludeCodas (  )  )     !  =    null )     {", "for    ( String   includeCoda    :    group . getIncludeCodas (  )  )     {", "jspPropertyGroup . addIncludeCoda ( includeCoda )  ;", "}", "}", "jspPropertyGroup . setDeferredSyntaxAllowedAsLiteral ( group . getDeferredSyntaxAllowedAsLiteral (  )  )  ;", "jspPropertyGroup . setTrimDirectiveWhitespaces ( group . getTrimDirectiveWhitespaces (  )  )  ;", "jspPropertyGroup . setDefaultContentType ( group . getDefaultContentType (  )  )  ;", "jspPropertyGroup . setBuffer ( group . getBuffer (  )  )  ;", "jspPropertyGroup . setErrorOnclaredNamespace ( group . getErrorOnclaredNamespace (  )  )  ;", "for    ( String   pattern    :    jspPropertyGroup . getUrlPatterns (  )  )     {", "result . put ( pattern ,    jspPropertyGroup )  ;", "}", "}", "}", "}", "final   LinkedHashMap < String ,    JspPropertyGroup >    ret    =    new   LinkedHashMap <  >  (  )  ;", "final   ArrayList < String >    paths    =    new   ArrayList ( result . keySet (  )  )  ;", "Collections . sort ( paths ,    new   Comparator < String >  (  )     {", "@ Override", "public   int   compare ( final   String   o 1  ,    final   String   o 2  )     {", "return    ( o 1  . length (  )  )     -     ( o 2  . length (  )  )  ;", "}", "}  )  ;", "for    ( String   path    :    paths )     {", "ret . put ( path ,    result . get ( path )  )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["createJspConfig"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "final   ComponentRegistry   componentRegistry    =    componentRegistryInjectedValue . getValue (  )  ;", "try    {", "if    (  !  ( mergedMetaData . isMetadataComplete (  )  )  )     {", "mergedMetaData . resolveAnnotations (  )  ;", "}", "mergedMetaData . resolveRunAs (  )  ;", "final   DeploymentInfo   d    =    new   DeploymentInfo (  )  ;", "d . setContextPath ( resolveContextPath (  )  )  ;", "if    (  ( mergedMetaData . getDescriptionGroup (  )  )     !  =    null )     {", "d . setDisplayName ( mergedMetaData . getDescriptionGroup (  )  . getDisplayName (  )  )  ;", "}", "d . setDeploymentName ( deploymentName )  ;", "d . setHostName ( host . getValue (  )  . getName (  )  )  ;", "final   ServletContainerService   servletContainer    =    container . getValue (  )  ;", "try    {", "List < String >    externalOverlays    =    mergedMetaData . getOverlays (  )  ;", "ResourceManager   resourceManager    =    new   ServletResourceManager ( deploymentRoot ,    overlays ,    explodedDeployment ,    mergedMetaData . isSymbolicLinkingEnabled (  )  ,    servletContainer . isDisableFileWatchService (  )  ,    externalOverlays )  ;", "resourceManager    =    new   io . undertow . server . handlers . resource . CachingResourceManager ( servletContainer . getFileCacheMetadataSize (  )  ,    servletContainer . getFileCacheMaxFileSize (  )  ,    servletContainer . getBufferCache (  )  ,    resourceManager ,     (  ( servletContainer . getFileCacheTimeToLive (  )  )     =  =    null    ?    explodedDeployment    ?     2  0  0  0     :     -  1     :    servletContainer . getFileCacheTimeToLive (  )  )  )  ;", "if    (  (  ( externalResources )     !  =    null )     &  &     (  !  ( externalResources . isEmpty (  )  )  )  )     {", "List < ResourceManager >    delegates    =    new   ArrayList <  >  (  )  ;", "for    ( File   resource    :    externalResources )     {", "delegates . add ( new   io . undertow . server . handlers . resource . FileResourceManager ( resource . getCanonicalFile (  )  ,     1  0  2  4  ,    true ,    mergedMetaData . isSymbolicLinkingEnabled (  )  ,     \"  /  \"  )  )  ;", "}", "delegates . add ( resourceManager )  ;", "resourceManager    =    new   DelegatingResourceManager ( delegates )  ;", "}", "d . setResourceManager ( resourceManager )  ;", "}    catch    ( IOException   e )     {", "throw   new   StartException ( e )  ;", "}", "d . setTempDir ( tempDir )  ;", "d . setClassLoader ( module . getClassLoader (  )  )  ;", "final   String   servletVersion    =    mergedMetaData . getServletVersion (  )  ;", "if    ( servletVersion    !  =    null )     {", "d . setMajorVersion ( Integer . parseInt (  (  ( servletVersion . charAt (  0  )  )     +     \"  \"  )  )  )  ;", "d . setMinorVersion ( Integer . parseInt (  (  ( servletVersion . charAt (  2  )  )     +     \"  \"  )  )  )  ;", "} else    {", "d . setMajorVersion (  3  )  ;", "d . setMinorVersion (  1  )  ;", "}", "d . setDefaultCookieVersion ( servletContainer . getDefaultCookieVersion (  )  )  ;", "d . setIgnoreFlush ( servletContainer . isIgnoreFlush (  )  )  ;", "d . setEagerFilterInit ( servletContainer . isEagerFilterInit (  )  )  ;", "d . setAllowNonStandardWrappers ( servletContainer . isAllowNonStandardWrappers (  )  )  ;", "d . setServletStackTraces ( servletContainer . getStackTraces (  )  )  ;", "d . setDisableCachingForSecuredPages ( servletContainer . isDisableCachingForSecuredPages (  )  )  ;", "if    ( servletContainer . isDisableSessionIdReuse (  )  )     {", "d . setCheckOtherSessionManagers ( false )  ;", "}", "if    (  ( servletContainer . getSessionPersistenceManager (  )  )     !  =    null )     {", "d . setSessionPersistenceManager ( servletContainer . getSessionPersistenceManager (  )  )  ;", "}", "boolean   is 2  2 OrOlder ;", "if    (  ( d . getMajorVersion (  )  )     =  =     1  )     {", "is 2  2 OrOlder    =    true ;", "} else", "if    (  ( d . getMajorVersion (  )  )     =  =     2  )     {", "is 2  2 OrOlder    =     ( d . getMinorVersion (  )  )     <     3  ;", "} else    {", "is 2  2 OrOlder    =    false ;", "}", "JSPConfig   jspConfig    =    servletContainer . getJspConfig (  )  ;", "final   Set < String >    seenMappings    =    new   HashSet <  >  (  )  ;", "final   ServletInfo   jspServlet    =     ( jspConfig    !  =    null )     ?    jspConfig . createJSPServletInfo (  )     :    null ;", "if    ( jspServlet    !  =    null )     {", "HashMap < String ,    JspPropertyGroup >    propertyGroups    =     . createJspConfig ( mergedMetaData )  ;", "JspServletBuilder . setupDeployment ( d ,    propertyGroups ,    tldInfo ,    new   UndertowJSPInstanceManager ( new   WebInjectionContainer ( module . getClassLoader (  )  ,    componentRegistryInjectedValue . getValue (  )  )  )  )  ;", "if    (  ( mergedMetaData . getJspConfig (  )  )     !  =    null )     {", "Collection < JspPropertyGroup >    values    =    new   LinkedHashSet ( propertyGroups . values (  )  )  ;", "d . setJspConfigDescriptor ( new   JspConfigDescriptorImpl ( tldInfo . values (  )  ,    values )  )  ;", "}", "d . addServlet ( jspServlet )  ;", "final   Set < String >    jspPropertyGroupMappings    =    propertyGroups . keySet (  )  ;", "for    ( final   String   mapping    :    jspPropertyGroupMappings )     {", "if    (  !  ( jspServlet . getMappings (  )  . contains ( mapping )  )  )     {", "jspServlet . addMapping ( mapping )  ;", "}", "}", "seenMappings . addAll ( jspPropertyGroupMappings )  ;", "d . addListener ( new   ListenerInfo ( JspInitializationListener . class )  )  ;", "d . addServletContextAttribute ( JspInitializationListener . CONTEXT _ KEY ,    expressionFactoryWrappers )  ;", "}", "d . setClassIntrospecter ( new    . ComponentClassIntrospector ( componentRegistry )  )  ;", "final   Map < String ,    List < ServletMappingMetaData >  >    servletMappings    =    new   HashMap <  >  (  )  ;", "if    (  ( mergedMetaData . getExecutorName (  )  )     !  =    null )     {", "d . setExecutor ( executorsByName . get ( mergedMetaData . getExecutorName (  )  )  . getValue (  )  )  ;", "}", "Boolean   proactiveAuthentication    =    mergedMetaData . getProactiveAuthentication (  )  ;", "if    ( proactiveAuthentication    =  =    null )     {", "proactiveAuthentication    =    container . getValue (  )  . isProactiveAuth (  )  ;", "}", "d . setAuthenticationMode (  ( proactiveAuthentication    ?    AuthenticationMode . PRO _ ACTIVE    :    AuthenticationMode . CONSTRAINT _ DRIVEN )  )  ;", "if    (  ( servletExtensions )     !  =    null )     {", "for    ( ServletExtension   extension    :    servletExtensions )     {", "d . addServletExtension ( extension )  ;", "}", "}", "if    (  ( mergedMetaData . getServletMappings (  )  )     !  =    null )     {", "for    ( final   ServletMappingMetaData   mapping    :    mergedMetaData . getServletMappings (  )  )     {", "List < ServletMappingMetaData >    list    =    servletMappings . get ( mapping . getServletName (  )  )  ;", "if    ( list    =  =    null )     {", "servletMappings . put ( mapping . getServletName (  )  ,     ( list    =    new   ArrayList (  )  )  )  ;", "}", "list . add ( mapping )  ;", "}", "}", "if    ( jspServlet    !  =    null )     {", "jspServlet . addHandlerChainWrapper ( JspFileHandler . jspFileHandlerWrapper ( null )  )  ;", "List < ServletMappingMetaData >    list    =    servletMappings . get ( jspServlet . getName (  )  )  ;", "if    (  ( list    !  =    null )     &  &     (  !  ( list . isEmpty (  )  )  )  )     {", "for    ( final   ServletMappingMetaData   mapping    :    list )     {", "for    ( String   urlPattern    :    mapping . getUrlPatterns (  )  )     {", "jspServlet . addMapping ( urlPattern )  ;", "}", "seenMappings . addAll ( mapping . getUrlPatterns (  )  )  ;", "}", "}", "}", "final   List < JBossServletMetaData >    servlets    =    new   ArrayList < JBossServletMetaData >  (  )  ;", "for    ( JBossServletMetaData   servlet    :    mergedMetaData . getServlets (  )  )     {", "servlets . add ( servlet )  ;", "}", "for    ( final   JBossServletMetaData   servlet    :    mergedMetaData . getServlets (  )  )     {", "final   ServletInfo   s ;", "if    (  ( servlet . getJspFile (  )  )     !  =    null )     {", "s    =    new   ServletInfo ( servlet . getName (  )  ,    JspServlet . class )  ;", "s . addHandlerChainWrapper ( JspFileHandler . jspFileHandlerWrapper ( servlet . getJspFile (  )  )  )  ;", "} else    {", "if    (  ( servlet . getServletClass (  )  )     =  =    null )     {", "if    (  . DEFAULT _ SERVLET _ NAME . equals ( servlet . getName (  )  )  )     {", "s    =    new   ServletInfo ( servlet . getName (  )  ,    DefaultServlet . class )  ;", "} else    {", "throw   UndertowLogger . ROOT _ LOGGER . servletClassNotDefined ( servlet . getServletName (  )  )  ;", "}", "} else    {", "Class <  ?    extends   Servlet >    servletClass    =     (  ( Class <  ?    extends   Servlet >  )     ( module . getClassLoader (  )  . loadClass ( servlet . getServletClass (  )  )  )  )  ;", "ManagedReferenceFactory   creator    =    componentRegistry . createInstanceFactory ( servletClass )  ;", "if    ( creator    !  =    null )     {", "InstanceFactory < Servlet >    factory    =     . createInstanceFactory ( creator )  ;", "s    =    new   ServletInfo ( servlet . getName (  )  ,    servletClass ,    factory )  ;", "} else    {", "s    =    new   ServletInfo ( servlet . getName (  )  ,    servletClass )  ;", "}", "}", "}", "s . setAsyncSupported ( servlet . isAsyncSupported (  )  )  . setJspFile ( servlet . getJspFile (  )  )  . setEnabled ( servlet . isEnabled (  )  )  ;", "if    (  ( servlet . getRunAs (  )  )     !  =    null )     {", "s . setRunAs ( servlet . getRunAs (  )  . getRoleName (  )  )  ;", "}", "if    ( servlet . getLoadOnStartupSet (  )  )     {", "s . setLoadOnStartup ( servlet . getLoadOnStartupInt (  )  )  ;", "}", "if    (  ( servlet . getExecutorName (  )  )     !  =    null )     {", "s . setExecutor ( executorsByName . get ( servlet . getExecutorName (  )  )  . getValue (  )  )  ;", "}", "handleServletMappings ( is 2  2 OrOlder ,    seenMappings ,    servletMappings ,    s )  ;", "if    (  ( servlet . getInitParam (  )  )     !  =    null )     {", "for    ( ParamValueMetaData   initParam    :    servlet . getInitParam (  )  )     {", "if    (  !  ( s . getInitParams (  )  . containsKey ( initParam . getParamName (  )  )  )  )     {", "s . addInitParam ( initParam . getParamName (  )  ,    initParam . getParamValue (  )  )  ;", "}", "}", "}", "if    (  ( servlet . getServletSecurity (  )  )     !  =    null )     {", "ServletSecurityInfo   securityInfo    =    new   ServletSecurityInfo (  )  ;", "s . setServletSecurityInfo ( securityInfo )  ;", "securityInfo . setEmptyRoleSemantic (  (  ( servlet . getServletSecurity (  )  . getEmptyRoleSemantic (  )  )     =  =     ( EmptyRoleSemanticType . DENY )     ?    EmptyRoleSemantic . DENY    :    EmptyRoleSemantic . PERMIT )  )  . setTransportGuaranteeType (  . transportGuaranteeType ( servlet . getServletSecurity (  )  . getTransportGuarantee (  )  )  )  . addRolesAllowed ( servlet . getServletSecurity (  )  . getRolesAllowed (  )  )  ;", "if    (  ( servlet . getServletSecurity (  )  . getHttpMethodConstraints (  )  )     !  =    null )     {", "for    ( HttpMethodConstraintMetaData   method    :    servlet . getServletSecurity (  )  . getHttpMethodConstraints (  )  )     {", "securityInfo . addHttpMethodSecurityInfo ( new   HttpMethodSecurityInfo (  )  . setEmptyRoleSemantic (  (  ( method . getEmptyRoleSemantic (  )  )     =  =     ( EmptyRoleSemanticType . DENY )     ?    EmptyRoleSemantic . DENY    :    EmptyRoleSemantic . PERMIT )  )  . setTransportGuaranteeType (  . transportGuaranteeType ( method . getTransportGuarantee (  )  )  )  . addRolesAllowed ( method . getRolesAllowed (  )  )  . setMethod ( method . getMethod (  )  )  )  ;", "}", "}", "}", "if    (  ( servlet . getSecurityRoleRefs (  )  )     !  =    null )     {", "for    ( final   SecurityRoleRefMetaData   ref    :    servlet . getSecurityRoleRefs (  )  )     {", "s . addSecurityRoleRef ( ref . getRoleName (  )  ,    ref . getRoleLink (  )  )  ;", "}", "}", "if    (  ( servlet . getMultipartConfig (  )  )     !  =    null )     {", "MultipartConfigMetaData   mp    =    servlet . getMultipartConfig (  )  ;", "s . setMultipartConfig ( Servlets . multipartConfig ( mp . getLocation (  )  ,    mp . getMaxFileSize (  )  ,    mp . getMaxRequestSize (  )  ,    mp . getFileSizeThreshold (  )  )  )  ;", "}", "d . addServlet ( s )  ;", "}", "if    ( jspServlet    !  =    null )     {", "if    (  !  ( seenMappings . contains (  \"  *  . jsp \"  )  )  )     {", "jspServlet . addMapping (  \"  *  . jsp \"  )  ;", "}", "if    (  !  ( seenMappings . contains (  \"  *  . jspx \"  )  )  )     {", "jspServlet . addMapping (  \"  *  . jspx \"  )  ;", "}", "}", "if    (  !  ( mergedMetaData . getServlets (  )  . containsKey ( DEFAULT _ SERVLET _ NAME )  )  )     {", "ServletInfo   defaultServlet    =    Servlets . servlet (  . DEFAULT _ SERVLET _ NAME ,    DefaultServlet . class )  ;", "handleServletMappings ( is 2  2 OrOlder ,    seenMappings ,    servletMappings ,    defaultServlet )  ;", "d . addServlet ( defaultServlet )  ;", "}", "if    (  ( servletContainer . getDirectoryListingEnabled (  )  )     !  =    null )     {", "ServletInfo   defaultServlet    =    d . getServlets (  )  . get (  . DEFAULT _ SERVLET _ NAME )  ;", "defaultServlet . addInitParam ( DIRECTORY _ LISTING ,    servletContainer . getDirectoryListingEnabled (  )  . toString (  )  )  ;", "}", "if    (  ( mergedMetaData . getFilters (  )  )     !  =    null )     {", "for    ( final   FilterMetaData   filter    :    mergedMetaData . getFilters (  )  )     {", "Class <  ?    extends   Filter >    filterClass    =     (  ( Class <  ?    extends   Filter >  )     ( module . getClassLoader (  )  . loadClass ( filter . getFilterClass (  )  )  )  )  ;", "ManagedReferenceFactory   creator    =    componentRegistry . createInstanceFactory ( filterClass )  ;", "FilterInfo   f ;", "if    ( creator    !  =    null )     {", "InstanceFactory < Filter >    instanceFactory    =     . createInstanceFactory ( creator )  ;", "f    =    new   FilterInfo ( filter . getName (  )  ,    filterClass ,    instanceFactory )  ;", "} else    {", "f    =    new   FilterInfo ( filter . getName (  )  ,    filterClass )  ;", "}", "f . setAsyncSupported ( filter . isAsyncSupported (  )  )  ;", "d . addFilter ( f )  ;", "if    (  ( filter . getInitParam (  )  )     !  =    null )     {", "for    ( ParamValueMetaData   initParam    :    filter . getInitParam (  )  )     {", "f . addInitParam ( initParam . getParamName (  )  ,    initParam . getParamValue (  )  )  ;", "}", "}", "}", "}", "if    (  ( mergedMetaData . getFilterMappings (  )  )     !  =    null )     {", "for    ( final   FilterMappingMetaData   mapping    :    mergedMetaData . getFilterMappings (  )  )     {", "if    (  ( mapping . getUrlPatterns (  )  )     !  =    null )     {", "for    ( String   url    :    mapping . getUrlPatterns (  )  )     {", "if    (  ( is 2  2 OrOlder    &  &     (  !  ( url . startsWith (  \"  *  \"  )  )  )  )     &  &     (  !  ( url . startsWith (  \"  /  \"  )  )  )  )     {", "url    =     \"  /  \"     +    url ;", "}", "if    (  (  ( mapping . getDispatchers (  )  )     !  =    null )     &  &     (  !  ( mapping . getDispatchers (  )  . isEmpty (  )  )  )  )     {", "for    ( DispatcherType   dispatcher    :    mapping . getDispatchers (  )  )     {", "d . addFilterUrlMapping ( mapping . getFilterName (  )  ,    url ,    valueOf ( dispatcher . name (  )  )  )  ;", "}", "} else    {", "d . addFilterUrlMapping ( mapping . getFilterName (  )  ,    url ,    REQUEST )  ;", "}", "}", "}", "if    (  ( mapping . getServletNames (  )  )     !  =    null )     {", "for    ( String   servletName    :    mapping . getServletNames (  )  )     {", "if    (  (  ( mapping . getDispatchers (  )  )     !  =    null )     &  &     (  !  ( mapping . getDispatchers (  )  . isEmpty (  )  )  )  )     {", "for    ( DispatcherType   dispatcher    :    mapping . getDispatchers (  )  )     {", "d . addFilterServletNameMapping ( mapping . getFilterName (  )  ,    servletName ,    valueOf ( dispatcher . name (  )  )  )  ;", "}", "} else    {", "d . addFilterServletNameMapping ( mapping . getFilterName (  )  ,    servletName ,    REQUEST )  ;", "}", "}", "}", "}", "}", "if    (  (  ( scisMetaData )     !  =    null )     &  &     (  ( scisMetaData . getHandlesTypes (  )  )     !  =    null )  )     {", "for    ( final   ServletContainerInitializer   sci    :    scisMetaData . getScis (  )  )     {", "final   ImmediateInstanceFactory < ServletContainerInitializer >    instanceFactory    =    new   ImmediateInstanceFactory ( sci )  ;", "d . addServletContainerInitalizer ( new   io . undertow . servlet . api . ServletContainerInitializerInfo ( sci . getClass (  )  ,    instanceFactory ,    scisMetaData . getHandlesTypes (  )  . get ( sci )  )  )  ;", "}", "}", "if    (  ( mergedMetaData . getListeners (  )  )     !  =    null )     {", "Set < String >    tldListeners    =    new   HashSet <  >  (  )  ;", "for    ( Map . Entry < String ,    TagLibraryInfo >    e    :    tldInfo . entrySet (  )  )     {", "tldListeners . addAll ( Arrays . asList ( e . getValue (  )  . getListeners (  )  )  )  ;", "}", "for    ( ListenerMetaData   listener    :    mergedMetaData . getListeners (  )  )     {", ". addListener ( module . getClassLoader (  )  ,    componentRegistry ,    d ,    listener ,    tldListeners . contains ( listener . getListenerClass (  )  )  )  ;", "}", "}", "if    (  ( mergedMetaData . getContextParams (  )  )     !  =    null )     {", "for    ( ParamValueMetaData   param    :    mergedMetaData . getContextParams (  )  )     {", "d . addInitParameter ( param . getParamName (  )  ,    param . getParamValue (  )  )  ;", "}", "}", "if    (  (  ( mergedMetaData . getWelcomeFileList (  )  )     !  =    null )     &  &     (  ( mergedMetaData . getWelcomeFileList (  )  . getWelcomeFiles (  )  )     !  =    null )  )     {", "List < String >    welcomeFiles    =    mergedMetaData . getWelcomeFileList (  )  . getWelcomeFiles (  )  ;", "for    ( String   file    :    welcomeFiles )     {", "if    ( file . startsWith (  \"  /  \"  )  )     {", "d . addWelcomePages ( file . substring (  1  )  )  ;", "} else    {", "d . addWelcomePages ( file )  ;", "}", "}", "} else    {", "d . addWelcomePages (  \" index . html \"  ,     \" index . htm \"  ,     \" index . jsp \"  )  ;", "}", "d . addWelcomePages ( servletContainer . getWelcomeFiles (  )  )  ;", "if    (  ( mergedMetaData . getErrorPages (  )  )     !  =    null )     {", "for    ( final   ErrorPageMetaData   page    :    mergedMetaData . getErrorPages (  )  )     {", "final   ErrorPage   errorPage ;", "if    (  (  ( page . getExceptionType (  )  )     !  =    null )     &  &     (  !  ( page . getExceptionType (  )  . isEmpty (  )  )  )  )     {", "errorPage    =    new   ErrorPage ( page . getLocation (  )  ,     (  ( Class <  ?    extends   Throwable >  )     ( module . getClassLoader (  )  . loadClass ( page . getExceptionType (  )  )  )  )  )  ;", "} else", "if    (  (  ( page . getErrorCode (  )  )     !  =    null )     &  &     (  !  ( page . getErrorCode (  )  . isEmpty (  )  )  )  )     {", "errorPage    =    new   ErrorPage ( page . getLocation (  )  ,    Integer . parseInt ( page . getErrorCode (  )  )  )  ;", "} else    {", "errorPage    =    new   ErrorPage ( page . getLocation (  )  )  ;", "}", "d . addErrorPages ( errorPage )  ;", "}", "}", "for    ( Map . Entry < String ,    String >    entry    :    servletContainer . getMimeMappings (  )  . entrySet (  )  )     {", "d . addMimeMapping ( new   MimeMapping ( entry . getKey (  )  ,    entry . getValue (  )  )  )  ;", "}", "if    (  ( mergedMetaData . getMimeMappings (  )  )     !  =    null )     {", "for    ( final   MimeMappingMetaData   mapping    :    mergedMetaData . getMimeMappings (  )  )     {", "d . addMimeMapping ( new   MimeMapping ( mapping . getExtension (  )  ,    mapping . getMimeType (  )  )  )  ;", "}", "}", "d . setDenyUncoveredHttpMethods (  (  ( mergedMetaData . getDenyUncoveredHttpMethods (  )  )     !  =    null )  )  ;", "Set < String >    securityRoleNames    =    mergedMetaData . getSecurityRoleNames (  )  ;", "if    (  ( mergedMetaData . getSecurityConstraints (  )  )     !  =    null )     {", "for    ( SecurityConstraintMetaData   constraint    :    mergedMetaData . getSecurityConstraints (  )  )     {", "SecurityConstraint   securityConstraint    =    new   SecurityConstraint (  )  . setTransportGuaranteeType (  . transportGuaranteeType ( constraint . getTransportGuarantee (  )  )  )  ;", "List < String >    roleNames    =    constraint . getRoleNames (  )  ;", "if    (  ( constraint . getAuthConstraint (  )  )     =  =    null )     {", "securityConstraint . setEmptyRoleSemantic ( EmptyRoleSemantic . PERMIT )  ;", "} else", "if    (  (  (  ( roleNames . size (  )  )     =  =     1  )     &  &     ( roleNames . contains (  \"  *  \"  )  )  )     &  &     ( securityRoleNames . contains (  \"  *  \"  )  )  )     {", "securityConstraint . setEmptyRoleSemantic ( EmptyRoleSemantic . AUTHENTICATE )  ;", "} else    {", "securityConstraint . addRolesAllowed ( roleNames )  ;", "}", "if    (  ( constraint . getResourceCollections (  )  )     !  =    null )     {", "for    ( final   WebResourceCollectionMetaData   resourceCollection    :    constraint . getResourceCollections (  )  )     {", "securityConstraint . addWebResourceCollection ( new   WebResourceCollection (  )  . addHttpMethods ( resourceCollection . getHttpMethods (  )  )  . addHttpMethodOmissions ( resourceCollection . getHttpMethodOmissions (  )  )  . addUrlPatterns ( resourceCollection . getUrlPatterns (  )  )  )  ;", "}", "}", "d . addSecurityConstraint ( securityConstraint )  ;", "}", "}", "final   LoginConfigMetaData   loginConfig    =    mergedMetaData . getLoginConfig (  )  ;", "if    ( loginConfig    !  =    null )     {", "List < AuthMethodConfig >    authMethod    =     . authMethod ( loginConfig . getAuthMethod (  )  )  ;", "if    (  ( loginConfig . getFormLoginConfig (  )  )     !  =    null )     {", "d . setLoginConfig ( new   io . undertow . servlet . api . LoginConfig ( loginConfig . getRealmName (  )  ,    loginConfig . getFormLoginConfig (  )  . getLoginPage (  )  ,    loginConfig . getFormLoginConfig (  )  . getErrorPage (  )  )  )  ;", "} else    {", "d . setLoginConfig ( new   io . undertow . servlet . api . LoginConfig ( loginConfig . getRealmName (  )  )  )  ;", "}", "for    ( AuthMethodConfig   method    :    authMethod )     {", "d . getLoginConfig (  )  . addLastAuthMethod ( method )  ;", "}", "}", "d . addSecurityRoles ( mergedMetaData . getSecurityRoleNames (  )  )  ;", "Map < String ,    Set < String >  >    principalVersusRolesMap    =    mergedMetaData . getPrincipalVersusRolesMap (  )  ;", "BiFunction < DeploymentInfo ,    Function < String ,    RunAsIdentityMetaData >  ,    ApplicationSecurityDomainDefinition . Registration >    securityFunction    =    this . securityFunction . getOptionalValue (  )  ;", "if    ( securityFunction    !  =    null )     {", "Map < String ,    RunAsIdentityMetaData >    runAsIdentityMap    =    mergedMetaData . getRunAsIdentity (  )  ;", "registration    =    securityFunction . apply ( d ,    runAsIdentityMap :  : get )  ;", "d . addOuterHandlerChainWrapper ( JACCContextIdHandler . wrapper ( jaccContextId )  )  ;", "if    ( mergedMetaData . isUseJBossAuthorization (  )  )     {", "UndertowLogger . ROOT _ LOGGER . configurationOptionIgnoredWhenUsingElytron (  \" use - jboss - authorization \"  )  ;", "}", "} else    {", "if    (  ( securityDomain )     !  =    null )     {", "d . addThreadSetupAction ( new   SecurityContextThreadSetupAction ( securityDomain ,    securityDomainContextValue . getValue (  )  ,    principalVersusRolesMap )  )  ;", "d . addInnerHandlerChainWrapper ( SecurityContextAssociationHandler . wrapper ( mergedMetaData . getRunAsIdentity (  )  )  )  ;", "d . addOuterHandlerChainWrapper ( JACCContextIdHandler . wrapper ( jaccContextId )  )  ;", "d . addLifecycleInterceptor ( new   RunAsLifecycleInterceptor ( mergedMetaData . getRunAsIdentity (  )  )  )  ;", "}", "}", "if    ( principalVersusRolesMap    !  =    null )     {", "for    ( Map . Entry < String ,    Set < String >  >    entry    :    principalVersusRolesMap . entrySet (  )  )     {", "d . addPrincipalVsRoleMappings ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "if    (  ( attributes )     !  =    null )     {", "for    ( ServletContextAttribute   attribute    :    attributes )     {", "d . addServletContextAttribute ( attribute . getName (  )  ,    attribute . getValue (  )  )  ;", "}", "}", "if    (  ( servletContainer . isWebsocketsEnabled (  )  )     &  &     (  ( webSocketDeploymentInfo )     !  =    null )  )     {", "webSocketDeploymentInfo . setBuffers ( servletContainer . getWebsocketsBufferPool (  )  . getValue (  )  )  ;", "webSocketDeploymentInfo . setWorker ( servletContainer . getWebsocketsWorker (  )  . getValue (  )  )  ;", "webSocketDeploymentInfo . setDispatchToWorkerThread ( servletContainer . isDispatchWebsocketInvocationToWorker (  )  )  ;", "if    ( servletContainer . isPerMessageDeflate (  )  )     {", "PerMessageDeflateHandshake   perMessageDeflate    =    new   PerMessageDeflateHandshake ( false ,    servletContainer . getDeflaterLevel (  )  )  ;", "webSocketDeploymentInfo . addExtension ( perMessageDeflate )  ;", "}", "final   AtomicReference < ServerActivity >    serverActivity    =    new   AtomicReference <  >  (  )  ;", "webSocketDeploymentInfo . addListener (  (    wsc )     -  >     {", "serverActivity . set ( new   ServerActivity (  )     {", "@ Override", "public   void   preSuspend ( ServerActivityCallback   listener )     {", "listener . done (  )  ;", "}", "@ Override", "public   void   suspended ( final   ServerActivityCallback   listener )     {", "if    ( wsc . getConfiguredServerEndpoints (  )  . isEmpty (  )  )     {", "listener . done (  )  ;", "return ;", "}", "wsc . pause ( new   ServerWebSocketContainer . PauseListener (  )     {", "@ Override", "public   void   paused (  )     {", "listener . done (  )  ;", "}", "@ Override", "public   void   resumed (  )     {", "}", "}  )  ;", "}", "@ Override", "public   void   resume (  )     {", "wsc . resume (  )  ;", "}", "}  )  ;", "suspendControllerInjectedValue . getValue (  )  . registerActivity ( serverActivity . get (  )  )  ;", "}  )  ;", "ServletContextListener   sl    =    new   ServletContextListener (  )     {", "@ Override", "public   void   contextInitialized ( ServletContextEvent   sce )     {", "}", "@ Override", "public   void   contextDestroyed ( ServletContextEvent   sce )     {", "final   ServerActivity   activity    =    serverActivity . get (  )  ;", "if    ( activity    !  =    null )     {", "suspendControllerInjectedValue . getValue (  )  . unRegisterActivity ( activity )  ;", "}", "}", "}  ;", "d . addListener ( new   ListenerInfo ( sl . getClass (  )  ,    new   ImmediateInstanceFactory < EventListener >  ( sl )  )  )  ;", "d . addServletContextAttribute ( ATTRIBUTE _ NAME ,    webSocketDeploymentInfo )  ;", "}", "if    (  (  ( mergedMetaData . getLocalEncodings (  )  )     !  =    null )     &  &     (  ( mergedMetaData . getLocalEncodings (  )  . getMappings (  )  )     !  =    null )  )     {", "for    ( LocaleEncodingMetaData   locale    :    mergedMetaData . getLocalEncodings (  )  . getMappings (  )  )     {", "d . addLocaleCharsetMapping ( locale . getLocale (  )  ,    locale . getEncoding (  )  )  ;", "}", "}", "if    (  (  ( predicatedHandlers )     !  =    null )     &  &     (  !  ( predicatedHandlers . isEmpty (  )  )  )  )     {", "d . addOuterHandlerChainWrapper ( new   RewriteCorrectingHandlerWrappers . PostWrapper (  )  )  ;", "d . addOuterHandlerChainWrapper ( new   HandlerWrapper (  )     {", "@ Override", "public   HttpHandler   wrap ( HttpHandler   handler )     {", "return   Handlers . predicates ( predicatedHandlers ,    handler )  ;", "}", "}  )  ;", "d . addOuterHandlerChainWrapper ( new   RewriteCorrectingHandlerWrappers . PreWrapper (  )  )  ;", "}", "if    (  ( mergedMetaData . getDefaultEncoding (  )  )     !  =    null )     {", "d . setDefaultEncoding ( mergedMetaData . getDefaultEncoding (  )  )  ;", "} else", "if    (  ( servletContainer . getDefaultEncoding (  )  )     !  =    null )     {", "d . setDefaultEncoding ( servletContainer . getDefaultEncoding (  )  )  ;", "}", "d . setCrawlerSessionManagerConfig ( servletContainer . getCrawlerSessionManagerConfig (  )  )  ;", "return   d ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   StartException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createServletConfig"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   componentRegistryInjectedValue ;", "}", "METHOD_END"], "methodName": ["getComponentRegistryInjectedValue"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   new   ConfidentialPortManager (  )     {", "@ Override", "public   int   getConfidentialPort ( HttpServerExchange   exchange )     {", "int   port    =    exchange . getConnection (  )  . getLocalAddress ( InetSocketAddress . class )  . getPort (  )  ;", "if    ( port    <     0  )     {", "Logger . ROOT _ LOGGER . debugf (  \" Confidential   port   not   defined   for   port    % s \"  ,    port )  ;", "}", "return   host . getValue (  )  . getServer (  )  . getValue (  )  . lookupSecurePort ( port )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getConfidentialPortManager"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   container ;", "}", "METHOD_END"], "methodName": ["getContainer"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   controlPointInjectedValue ;", "}", "METHOD_END"], "methodName": ["getControlPointInjectedValue"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   securityDomainContextValue ;", "}", "METHOD_END"], "methodName": ["getSecurityDomainContextValue"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   securityFunction ;", "}", "METHOD_END"], "methodName": ["getSecurityFunctionInjector"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   serverEnvironmentInjectedValue ;", "}", "METHOD_END"], "methodName": ["getServerEnvironmentInjectedValue"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionIdentifierCodec ;", "}", "METHOD_END"], "methodName": ["getSessionIdentifierCodecInjector"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionManagerFactory ;", "}", "METHOD_END"], "methodName": ["getSessionManagerFactoryInjector"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   suspendControllerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getSuspendControllerInjectedValue"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "return   undertowService ;", "}", "METHOD_END"], "methodName": ["getUndertowService"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    AuthenticationMechanism >    am    :    host . getValue (  )  . getAdditionalAuthenticationMechanisms (  )  . entrySet (  )  )     {", "d . addFirstAuthenticationMechanism ( am . getKey (  )  ,    am . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleAdditionalAuthenticationMechanisms"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( securityDomain )     =  =    null )     {", "return ;", "}", "AuthenticationManager   manager    =    securityDomainContextValue . getValue (  )  . getAuthenticationManager (  )  ;", "d . addNotificationReceiver ( new   LogoutNotificationReceiver ( manager ,    securityDomain )  )  ;", "if    ( mergedMetaData . isFlushOnSessionInvalidation (  )  )     {", "LogoutSessionListener   listener    =    new   LogoutSessionListener ( manager )  ;", "d . addListener ( Servlets . listener ( LogoutSessionListener . class ,    new   io . undertow . servlet . util . ImmediateInstanceFactory < EventListener >  ( listener )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleAuthManagerLogout"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "SessionManagerFactory   managerFactory    =    this . sessionManagerFactory . getOptionalValue (  )  ;", "if    ( managerFactory    !  =    null )     {", "d . setSessionManagerFactory ( managerFactory )  ;", "}", "SessionIdentifierCodec   codec    =    this . sessionIdentifierCodec . getOptionalValue (  )  ;", "if    ( codec    !  =    null )     {", "d . setSessionConfigWrapper ( new   CodecSessionConfigWrapper ( codec )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleDistributable"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( securityDomain )     !  =    null )     {", "SecurityDomainContext   sdc    =    securityDomainContextValue . getValue (  )  ;", "d . setIdentityManager ( new   JAASIdentityManagerImpl ( sdc )  )  ;", "AuditManager   auditManager    =    sdc . getAuditManager (  )  ;", "if    (  ( auditManager    !  =    null )     &  &     (  !  ( mergedMetaData . isDisableAudit (  )  )  )  )     {", "d . addNotificationReceiver ( new   AuditNotificationReceiver ( auditManager )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleIdentityManager"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( securityDomain )     =  =    null )     {", "return ;", "}", "ApplicationPolicy   applicationPolicy    =    SecurityConfiguration . getApplicationPolicy ( this . securityDomain )  ;", "if    ( applicationPolicy    !  =    null )     {", "AuthorizationInfo   authzInfo    =    applicationPolicy . getAuthorizationInfo (  )  ;", "if    ( authzInfo    !  =    null )     {", "for    ( AuthorizationModuleEntry   entry    :    authzInfo . getModuleEntries (  )  )     {", "if    ( JACCAuthorizationModule . class . getName (  )  . equals ( entry . getPolicyModuleName (  )  )  )     {", "d . setAuthorizationManager ( new   JACCAuthorizationManager (  )  )  ;", "break ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleJACCAuthorization"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( securityDomain )     =  =    null )     {", "return ;", "}", "ApplicationPolicy   applicationPolicy    =    SecurityConfiguration . getApplicationPolicy ( this . securityDomain )  ;", "if    (  ( applicationPolicy    !  =    null )     &  &     ( JASPIAuthenticationInfo . class . isInstance ( applicationPolicy . getAuthenticationInfo (  )  )  )  )     {", "String   authMethod    =    null ;", "LoginConfig   loginConfig    =    d . getLoginConfig (  )  ;", "if    (  ( loginConfig    !  =    null )     &  &     (  ( loginConfig . getAuthMethods (  )  . size (  )  )     >     0  )  )     {", "authMethod    =    loginConfig . getAuthMethods (  )  . get (  0  )  . getName (  )  ;", "}", "d . setJaspiAuthenticationMechanism ( new   JASPICAuthenticationMechanism ( securityDomain ,    authMethod )  )  ;", "d . setSecurityContextFactory ( new   JASPICSecurityContextFactory ( this . securityDomain )  )  ;", "d . addOuterHandlerChainWrapper (  (    next )     -  >    new   JASPICSecureResponseHandler ( next )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleJASPIMechanism"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "List < ServletMappingMetaData >    mappings    =    servletMappings . get ( s . getName (  )  )  ;", "if    ( mappings    !  =    null )     {", "for    ( ServletMappingMetaData   mapping    :    mappings )     {", "for    ( String   pattern    :    mapping . getUrlPatterns (  )  )     {", "if    (  ( is 2  2 OrOlder    &  &     (  !  ( pattern . startsWith (  \"  *  \"  )  )  )  )     &  &     (  !  ( pattern . startsWith (  \"  /  \"  )  )  )  )     {", "pattern    =     \"  /  \"     +    pattern ;", "}", "if    (  !  ( seenMappings . contains ( pattern )  )  )     {", "s . addMapping ( pattern )  ;", "seenMappings . add ( pattern )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleServletMappings"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "if    ( deploymentName . equals ( host . getValue (  )  . getDefaultWebModule (  )  )  )     {", "return    \"  /  \"  ;", "} else    {", "return   contextPath ;", "}", "}", "METHOD_END"], "methodName": ["resolveContextPath"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )     {", "return   TransportGuaranteeType . NONE ;", "}", "switch    ( type )     {", "case   CONFIDENTIAL    :", "return   TransportGuaranteeType . CONFIDENTIAL ;", "case   INTEGRAL    :", "return   TransportGuaranteeType . INTEGRAL ;", "case   NONE    :", "return   TransportGuaranteeType . NONE ;", "}", "throw   new   RuntimeExcept (  \" UNREACHABLE \"  )  ;", "}", "METHOD_END"], "methodName": ["transportGuaranteeType"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService"}, {"methodBody": ["METHOD_START", "{", "String   relativeLocat =    locat", "String   jarPath    =    null ;", "if    (  ( relativeLocat !  =    null )     &  &     ( relativeLocatstartsWith (  \"  / WEB - INF / lib /  \"  )  )  )     {", "int   pos    =    relativeLocatindexOf (  '  /  '  ,     \"  / WEB - INF / lib /  \"  . length (  )  )  ;", "if    ( pos    >     0  )     {", "jarPath    =    relativeLocatsubstring ( pos )  ;", "if    ( jarPath . startsWith (  \"  /  \"  )  )     {", "jarPath    =    jarPath . substring (  1  )  ;", "}", "relativeLocat =    relativeLocatsubstring (  0  ,    pos )  ;", "}", "}", "TagLibraryInfo   tagLibraryInfo    =    new   TagLibraryInfo (  )  ;", "if    (  ( tldMetaData . getListeners (  )  )     !  =    null )     {", "for    ( ListenerMetaData   l    :    tldMetaData . getListeners (  )  )     {", "tagLibraryInfo . addListener ( l . getListenerClass (  )  )  ;", "}", "}", "tagLibraryInfo . setTlibverstldMetaData . getTlibVers )  )  ;", "if    (  ( tldMetaData . getJspVers )  )     =  =    null )     {", "tagLibraryInfo . setJspverstldMetaData . getVers )  )  ;", "} else    {", "tagLibraryInfo . setJspverstldMetaData . getJspVers )  )  ;", "}", "tagLibraryInfo . setShortname ( tldMetaData . getShortName (  )  )  ;", "tagLibraryInfo . setUri ( tldMetaData . getUri (  )  )  ;", "if    (  ( tldMetaData . getDescriptroup (  )  )     !  =    null )     {", "tagLibraryInfo . setInfo ( tldMetaData . getDescriptroup (  )  . getDescript )  )  ;", "}", "if    (  ( tldMetaData . getValidator (  )  )     !  =    null )     {", "TagLibraryValidatorInfo   tagLibraryValidatorInfo    =    new   TagLibraryValidatorInfo (  )  ;", "tagLibraryValidatorInfo . setValidatorClass ( tldMetaData . getValidator (  )  . getValidatorClass (  )  )  ;", "if    (  ( tldMetaData . getValidator (  )  . getInitParams (  )  )     !  =    null )     {", "for    ( ParamValueMetaData   paramValueMetaData    :    tldMetaData . getValidator (  )  . getInitParams (  )  )     {", "tagLibraryValidatorInfo . addInitParam ( paramValueMetaData . getParamName (  )  ,    paramValueMetaData . getParamValue (  )  )  ;", "}", "}", "tagLibraryInfo . setValidator ( tagLibraryValidatorInfo )  ;", "}", "if    (  ( tldMetaData . getTags (  )  )     !  =    null )     {", "for    ( TagMetaData   tagMetaData    :    tldMetaData . getTags (  )  )     {", "TagInfo   tagInfo    =    new   TagInfo (  )  ;", "tagInfo . setTagName ( tagMetaData . getName (  )  )  ;", "tagInfo . setTagClassName ( tagMetaData . getTagClass (  )  )  ;", "tagInfo . setTagExtraInfo ( tagMetaData . getTeiClass (  )  )  ;", "if    (  ( tagMetaData . getBodyContent (  )  )     !  =    null )     {", "tagInfo . setBodyContent ( tagMetaData . getBodyContent (  )  . toString (  )  )  ;", "}", "tagInfo . setDynamicAttributes ( tagMetaData . getDynamicAttributes (  )  )  ;", "if    (  ( tagMetaData . getDescriptroup (  )  )     !  =    null )     {", "DescriptroupMetaData   descriptroup    =    tagMetaData . getDescriptroup (  )  ;", "if    (  (  (  ( descriptroup . getIcons (  )  )     !  =    null )     &  &     (  ( descriptroup . getIcons (  )  . value (  )  )     !  =    null )  )     &  &     (  ( descriptroup . getIcons (  )  . value (  )  . length )     >     0  )  )     {", "Icon   icon    =    descriptroup . getIcons (  )  . value (  )  [  0  ]  ;", "tagInfo . setLargeIcon ( icon . largeIcon (  )  )  ;", "tagInfo . setSmallIcon ( icon . smallIcon (  )  )  ;", "}", "tagInfo . setInfoString ( descriptroup . getDescript )  )  ;", "tagInfo . setDisplayName ( descriptroup . getDisplayName (  )  )  ;", "}", "if    (  ( tagMetaData . getVariables (  )  )     !  =    null )     {", "for    ( VariableMetaData   variableMetaData    :    tagMetaData . getVariables (  )  )     {", "TagVariableInfo   tagVariableInfo    =    new   TagVariableInfo (  )  ;", "tagVariableInfo . setNameGiven ( variableMetaData . getNameGiven (  )  )  ;", "tagVariableInfo . setNameFromAttribute ( variableMetaData . getNameFromAttribute (  )  )  ;", "tagVariableInfo . setClassName ( variableMetaData . getVariableClass (  )  )  ;", "tagVariableInfo . setDeclare ( variableMetaData . getDeclare (  )  )  ;", "if    (  ( variableMetaData . getScope (  )  )     !  =    null )     {", "tagVariableInfo . setScope ( variableMetaData . getScope (  )  . toString (  )  )  ;", "}", "tagInfo . addTagVariableInfo ( tagVariableInfo )  ;", "}", "}", "if    (  ( tagMetaData . getAttributes (  )  )     !  =    null )     {", "for    ( AttributeMetaData   attributeMetaData    :    tagMetaData . getAttributes (  )  )     {", "TagAttributeInfo   tagAttributeInfo    =    new   TagAttributeInfo (  )  ;", "tagAttributeInfo . setName ( attributeMetaData . getName (  )  )  ;", "tagAttributeInfo . setType ( attributeMetaData . getType (  )  )  ;", "tagAttributeInfo . setReqTime ( attributeMetaData . getRtexprvalue (  )  )  ;", "tagAttributeInfo . setRequired ( attributeMetaData . getRequired (  )  )  ;", "tagAttributeInfo . setFragment ( attributeMetaData . getFragment (  )  )  ;", "if    (  ( attributeMetaData . getDeferredValue (  )  )     !  =    null )     {", "tagAttributeInfo . setDeferredValue (  \" true \"  )  ;", "tagAttributeInfo . setExpectedTypeName ( attributeMetaData . getDeferredValue (  )  . getType (  )  )  ;", "} else    {", "tagAttributeInfo . setDeferredValue (  \" false \"  )  ;", "}", "if    (  ( attributeMetaData . getDeferredMethod (  )  )     !  =    null )     {", "tagAttributeInfo . setDeferredMethod (  \" true \"  )  ;", "tagAttributeInfo . setMethodSignature ( attributeMetaData . getDeferredMethod (  )  . getMethodSignature (  )  )  ;", "} else    {", "tagAttributeInfo . setDeferredMethod (  \" false \"  )  ;", "}", "tagInfo . addTagAttributeInfo ( tagAttributeInfo )  ;", "}", "}", "tagLibraryInfo . addTagInfo ( tagInfo )  ;", "}", "}", "if    (  ( tldMetaData . getTagFiles (  )  )     !  =    null )     {", "for    ( TagFileMetaData   tagFileMetaData    :    tldMetaData . getTagFiles (  )  )     {", "TagFileInfo   tagFileInfo    =    new   TagFileInfo (  )  ;", "tagFileInfo . setName ( tagFileMetaData . getName (  )  )  ;", "tagFileInfo . setPath ( tagFileMetaData . getPath (  )  )  ;", "tagLibraryInfo . addTagFileInfo ( tagFileInfo )  ;", "}", "}", "if    (  ( tldMetaData . getFunct (  )  )     !  =    null )     {", "for    ( FunctetaData   functetaData    :    tldMetaData . getFunct (  )  )     {", "Functnfo   functnfo    =    new   Functnfo (  )  ;", "functnfo . setName ( functetaData . getName (  )  )  ;", "functnfo . setFunctlass ( functetaData . getFunctlass (  )  )  ;", "functnfo . setFunctignature ( functetaData . getFunctignature (  )  )  ;", "tagLibraryInfo . addFunctnfo ( functnfo )  ;", "}", "}", "if    (  ( jarPath    =  =    null )     &  &     ( relativeLocat =  =    null )  )     {", "if    (  !  ( ret . containsKey ( tagLibraryInfo . getUri (  )  )  )  )     {", "ret . put ( tagLibraryInfo . getUri (  )  ,    tagLibraryInfo )  ;", "}", "} else", "if    ( jarPath    =  =    null )     {", "tagLibraryInfo . setLocat \"  \"  )  ;", "tagLibraryInfo . setPath ( relativeLocat ;", "if    (  !  ( ret . containsKey ( tagLibraryInfo . getUri (  )  )  )  )     {", "ret . put ( tagLibraryInfo . getUri (  )  ,    tagLibraryInfo )  ;", "}", "ret . put ( relativeLocat   tagLibraryInfo )  ;", "} else    {", "tagLibraryInfo . setLocatrelativeLocat ;", "tagLibraryInfo . setPath ( jarPath )  ;", "if    (  !  ( ret . containsKey ( tagLibraryInfo . getUri (  )  )  )  )     {", "ret . put ( tagLibraryInfo . getUri (  )  ,    tagLibraryInfo )  ;", "}", "if    ( jarPath . equals (  \" META - INF / taglib . tld \"  )  )     {", "ret . put ( relativeLocat   tagLibraryInfo )  ;", "}", "}", "return   tagLibraryInfo ;", "}", "METHOD_END"], "methodName": ["createTldInfo"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   HashMap < String ,    TagLibraryInfo >    ret    =    new   HashMap <  >  (  )  ;", "if    ( tldsMetaData    !  =    null )     {", "if    (  ( tldsMetaData . getTlds (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    TldMetaData >    tld    :    tldsMetaData . getTlds (  )  . entrySet (  )  )     {", ". createTldInfo ( tld . getKey (  )  ,    tld . getValue (  )  ,    ret )  ;", "}", "}", "if    ( sharedTlds    !  =    null )     {", "for    ( TldMetaData   metaData    :    sharedTlds )     {", ". createTldInfo ( null ,    metaData ,    ret )  ;", "}", "}", "}", "for    ( String   k    :    new   HashSet ( ret . keySet (  )  )  )     {", "if    ( k    !  =    null )     {", "if    ( k . startsWith (  . OLD _ URI _ PREFIX )  )     {", "String   newUri    =    k . replace (  . OLD _ URI _ PREFIX ,     . NEW _ URI _ PREFIX )  ;", "ret . put ( newUri ,    ret . get ( k )  )  ;", "}", "}", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["createTldsInfo"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "String   securityDomain    =    null ;", "Unit   parent    =    deploymentUnit . getParent (  )  ;", "if    ( parent    !  =    null )     {", "final   EarMetaData   jbossAppMetaData    =    parent . getAttachment ( EAR _ METADATA )  ;", "if    ( jbossAppMetaData   instanceof   JBossAppMetaData )     {", "securityDomain    =     (  ( JBossAppMetaData )     ( jbossAppMetaData )  )  . getSecurityDomain (  )  ;", "}", "}", "return   securityDomain ;", "}", "METHOD_END"], "methodName": ["getJBossAppSecurityDomain"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "ServiceName   name    =    deploymentServiceName . append (  \" codec \"  )  ;", "if    (  ( metaData . getDistributable (  )  )     !  =    null )     {", "if    ( DistributableSessionIdentifierCodecBuilderProvider . INSTANCE . isPresent (  )  )     {", "return   DistributableSessionIdentifierCodecBuilderProvider . INSTANCE . get (  )  . getDeploymentBuilder ( name ,    serverName ,    deploymentName )  ;", "}", "}", "return   new   SimpleSessionIdentifierCodecBuilder ( name ,    serverName )  ;", "}", "METHOD_END"], "methodName": ["getSessionIdentifierCodecBuilder"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "Integer   maxActiveSessions    =    metaData . getMaxActiveSessions (  )  ;", "if    (  ( maxActiveSessions    =  =    null )     &  &     ( servletContainerService    !  =    null )  )     {", "maxActiveSessions    =    servletContainerService . getMaxSessions (  )  ;", "}", "ServiceName   name    =    ServiceName . append (  \" session \"  )  ;", "if    (  ( metaData . getDistributable (  )  )     !  =    null )     {", "if    ( DistributableSessionManagerFactoryBuilderProvider . INSTANCE . isPresent (  )  )     {", "DistributableSessionManagerConfiguration   config    =    new   SimpleDistributableSessionManagerConfiguration ( maxActiveSessions ,    metaData . getReplicationConfig (  )  ,    serverName ,    Name ,    module )  ;", "return   DistributableSessionManagerFactoryBuilderProvider . INSTANCE . get (  )  . getBuilder ( name ,    config )  ;", "}", "UndertowLogger . ROOT _ LOGGER . clusteringNotSupported (  )  ;", "}", "return   new   SimpleCapabilityServiceBuilder ( name ,     ( maxActiveSessions    !  =    null    ?    new   InMemorySessionManagerFactory ( maxActiveSessions )     :    new   InMemorySessionManagerFactory (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionManagerFactoryBuilder"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    hostNames    =    null ;", "if    (  ( metaData . getMergedJBossWebMetaData (  )  )     !  =    null )     {", "hostNames    =    metaData . getMergedJBossWebMetaData (  )  . getVirtualHosts (  )  ;", "}", "if    (  ( hostNames    =  =    null )     |  |     ( hostNames . isEmpty (  )  )  )     {", "hostNames    =    Collections . singleton ( defaultHost )  ;", "}", "String   hostName    =    hostNames . iterator (  )  . next (  )  ;", "if    ( hostName    =  =    null )     {", "throw   Logger . ROOT _ LOGGER . nullHostName (  )  ;", "}", "return   hostName ;", "}", "METHOD_END"], "methodName": ["hostNameOfDeployment"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "String   pathName ;", "if    (  ( metaData . getContextRoot (  )  )     =  =    null )     {", "final   EEModuleDescription   description    =    Unit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "if    ( description    !  =    null )     {", "pathName    =     \"  /  \"     +     ( description . getModuleName (  )  )  ;", "} else    {", "pathName    =     \"  /  \"     +     ( Unit . getName (  )  . substring (  0  ,     (  ( Unit . getName (  )  . length (  )  )     -     4  )  )  )  ;", "}", "} else    {", "pathName    =    metaData . getContextRoot (  )  ;", "if    (  (  ( pathName . length (  )  )     >     0  )     &  &     (  ( pathName . charAt (  0  )  )     !  =     '  /  '  )  )     {", "pathName    =     \"  /  \"     +    pathName ;", "}", "}", "return   pathName ;", "}", "METHOD_END"], "methodName": ["pathNameOfDeployment"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "ResourceRoot   deploymentResourceRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   VirtualFile   deploymentRoot    =    deploymentResourceRoot . getRoot (  )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "if    ( module    =  =    null )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . failedToResolveModule ( deploymentUnit )  )  ;", "}", "final   JBossWebMetaData   metaData    =    warMetaData . getMergedJBossWebMetaData (  )  ;", "final   List < SetupAction >    setupActions    =    deploymentUnit . getAttachmentList ( WEB _ SETUP _ ACTIONS )  ;", "CapabilityServiceSupport   capabilitySupport    =    deploymentUnit . getAttachment ( CAPABILITY _ SERVICE _ SUPPORT )  ;", "ScisMetaData   scisMetaData    =    deploymentUnit . getAttachment ( ScisMetaData . ATTACHMENT _ KEY )  ;", "final   Set < ServiceName >    dependentComponents    =    new   HashSet <  >  (  )  ;", "final   List < ServiceName >    components    =    deploymentUnit . getAttachmentList ( WEB _ COMPONENTS )  ;", "final   Set < ServiceName >    failed    =    deploymentUnit . getAttachment ( FAILED _ COMPONENTS )  ;", "for    ( final   ServiceName   component    :    components )     {", "if    (  !  ( failed . contains ( component )  )  )     {", "dependentComponents . add ( component )  ;", "}", "}", "String   servletContainerName    =    metaData . getServletContainerName (  )  ;", "if    ( servletContainerName    =  =    null )     {", "servletContainerName    =    defaultContainer ;", "}", "boolean   componentRegistryExists    =    true ;", "ComponentRegistry   componentRegistry    =    deploymentUnit . getAttachment ( COMPONENT _ REGISTRY )  ;", "if    ( componentRegistry    =  =    null )     {", "componentRegistryExists    =    false ;", "componentRegistry    =    new   ComponentRegistry ( null )  ;", "}", "final   WebInjectionContainer   injectionContainer    =    new   WebInjectionContainer ( module . getClassLoader (  )  ,    componentRegistry )  ;", "String   jaccContextId    =    metaData . getJaccContextID (  )  ;", "if    ( jaccContextId    =  =    null )     {", "jaccContextId    =    deploymentUnit . getName (  )  ;", "}", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "jaccContextId    =     (  ( deploymentUnit . getParent (  )  . getName (  )  )     +     \"  !  \"  )     +    jaccContextId ;", "}", "final   String   pathName    =     . pathNameOfDeployment ( deploymentUnit ,    metaData )  ;", "boolean   securityEnabled    =    deploymentUnit . hasAttachment ( SECURITY _ ENABLED )  ;", "String   metaDataSecurityDomain    =    metaData . getSecurityDomain (  )  ;", "if    ( metaDataSecurityDomain    =  =    null )     {", "metaDataSecurityDomain    =    getJBossAppSecurityDomain ( deploymentUnit )  ;", "}", "if    ( metaDataSecurityDomain    !  =    null )     {", "metaDataSecurityDomain    =    metaDataSecurityDomain . trim (  )  ;", "}", "final   String   securityDomain ;", "if    ( securityEnabled )     {", "securityDomain    =     ( metaDataSecurityDomain    =  =    null )     ?    defaultSecurityDomain    :    SecurityUtil . unprefixSecurityDomain ( metaDataSecurityDomain )  ;", "} else    {", "securityDomain    =    null ;", "}", "final   Set < ServiceName >    additionalDependencies    =    new   HashSet <  >  (  )  ;", "for    ( final   SetupAction   setupAction    :    setupActions )     {", "Set < ServiceName >    dependencies    =    setupAction . dependencies (  )  ;", "if    ( dependencies    !  =    null )     {", "additionalDependencies . addAll ( dependencies )  ;", "}", "}", "SharedSessionManagerConfig   sharedSessionManagerConfig    =     (  ( deploymentUnit . getParent (  )  )     !  =    null )     ?    deploymentUnit . getParent (  )  . getAttachment ( UndertowAttachments . SHARED _ SESSION _ MANAGER _ CONFIG )     :    null ;", "if    (  !  ( deploymentResourceRoot . isUsePhysicalCodeSource (  )  )  )     {", "try    {", "deploymentUnit . addToAttachmentList ( ATTACHMENT _ KEY ,    new   ServletContextAttribute ( Constants . CODE _ SOURCE _ ATTRIBUTE _ NAME ,    deploymentRoot . toURL (  )  )  )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   new   DeploymentUnitProcessingException ( e )  ;", "}", "}", "deploymentUnit . addToAttachmentList ( ATTACHMENT _ KEY ,    new   ServletContextAttribute ( Constants . PERMISSION _ COLLECTION _ ATTRIBUTE _ NAME ,    deploymentUnit . getAttachment ( MODULE _ PERMISSIONS )  )  )  ;", "additionalDependencies . addAll ( warMetaData . getAdditionalDependencies (  )  )  ;", "try    {", "String   capability    =    HostSingleSignOnDefinition . HOST _ SSO _ CAPABILITY . fromBaseCapability ( serverInstanceName ,    hostName )  . getName (  )  ;", "capabilitySupport . getCapabilityRuntimeAPI ( capability ,    Object . class )  ;", "additionalDependencies . add ( capabilitySupport . getCapabilityServiceName ( capability )  )  ;", "}    catch    ( CapabilityServiceSupport   e )     {", "}", "final   ServiceName   hostServiceName    =    UndertowService . virtualHostName ( serverInstanceName ,    hostName )  ;", "final   ServiceName   deploymentServiceName    =    UndertowService . deploymentServiceName ( serverInstanceName ,    hostName ,    pathName )  ;", "TldsMetaData   tldsMetaData    =    deploymentUnit . getAttachment ( TldsMetaData . ATTACHMENT _ KEY )  ;", "UndertowDeploymentInfoService   undertowDeploymentInfoService    =    UndertowDeploymentInfoService . builder (  )  . setAttributes ( deploymentUnit . getAttachmentList ( ATTACHMENT _ KEY )  )  . setContextPath ( pathName )  . setDeploymentName ( deploymentName )  . setDeploymentRoot ( deploymentRoot )  . setMergedMetaData ( warMetaData . getMergedJBossWebMetaData (  )  )  . setModule ( module )  . setScisMetaData ( scisMetaData )  . setJaccContextId ( jaccContextId )  . setSecurityDomain ( securityDomain )  . setTldInfo (  . createTldsInfo ( tldsMetaData ,     ( tldsMetaData    =  =    null    ?    null    :    tldsMetaData . getSharedTlds ( deploymentUnit )  )  )  )  . setSetupActions ( setupActions )  . setSharedSessionManagerConfig ( sharedSessionManagerConfig )  . setOverlays ( warMetaData . getOverlays (  )  )  . setExpressionFactoryWrappers ( deploymentUnit . getAttachmentList ( ExpressionFactoryWrapper . ATTACHMENT _ KEY )  )  . setPredicatedHandlers ( deploymentUnit . getAttachment ( UndertowHandlersDeploymentProcessor . PREDICATED _ HANDLERS )  )  . setInitialHandlerChainWrappers ( deploymentUnit . getAttachmentList ( UndertowAttachments . UNDERTOW _ INITIAL _ HANDLER _ CHAIN _ WRAPPERS )  )  . setInnerHandlerChainWrappers ( deploymentUnit . getAttachmentList ( UndertowAttachments . UNDERTOW _ INNER _ HANDLER _ CHAIN _ WRAPPERS )  )  . setOuterHandlerChainWrappers ( deploymentUnit . getAttachmentList ( UndertowAttachments . UNDERTOW _ OUTER _ HANDLER _ CHAIN _ WRAPPERS )  )  . setThreadSetupActions ( deploymentUnit . getAttachmentList ( UndertowAttachments . UNDERTOW _ THREAD _ SETUP _ ACTIONS )  )  . setServletExtensions ( deploymentUnit . getAttachmentList ( UndertowAttachments . UNDERTOW _ SERVLET _ EXTENSIONS )  )  . setExplodedDeployment ( ExplodedDeploymentMarker . isExplodedDeployment ( deploymentUnit )  )  . setWebSocketDeploymentInfo ( deploymentUnit . getAttachment ( UndertowAttachments . WEB _ SOCKET _ DEPLOYMENT _ INFO )  )  . setTempDir ( warMetaData . getTempDir (  )  )  . setExternalResources ( deploymentUnit . getAttachmentList ( UndertowAttachments . EXTERNAL _ RESOURCES )  )  . setAllowSuspendedRequests ( deploymentUnit . getAttachmentList ( UndertowAttachments . ALLOW _ REQUEST _ WHEN _ SUSPENDED )  )  . createUndertowDeploymentInfoService (  )  ;", "final   ServiceName   deploymentInfoServiceName    =    deploymentServiceName . append ( UndertowDeploymentInfoService . SERVICE _ NAME )  ;", "ServiceBuilder < DeploymentInfo >    infoBuilder    =    serviceTarget . addService ( deploymentInfoServiceName ,    undertowDeploymentInfoService )  . addDependency ( UndertowService . SERVLET _ CONTAINER . append ( servletContainerName )  ,    ServletContainerService . class ,    undertowDeploymentInfoService . getContainer (  )  )  . addDependency ( UndertowService . UNDERTOW ,    UndertowService . class ,    undertowDeploymentInfoService . getUndertowService (  )  )  . addDependency ( hostServiceName ,    Host . class ,    undertowDeploymentInfoService . getHost (  )  )  . addDependency ( SERVICE _ NAME ,    ServerEnvironment . class ,    undertowDeploymentInfoService . getServerEnvironmentInjectedValue (  )  )  . addDependency ( SuspendController . SERVICE _ NAME ,    SuspendController . class ,    undertowDeploymentInfoService . getSuspendControllerInjectedValue (  )  )  . addDependencies ( additionalDependencies )  ;", "if    ( securityDomain    !  =    null )     {", "if    ( knownSecurityDomain . test ( securityDomain )  )     {", "infoBuilder . addDependency ( deploymentUnit . getAttachment ( CAPABILITY _ SERVICE _ SUPPORT )  . getCapabilityServiceName ( Capabilities . CAPABILITY _ APPLICATION _ SECURITY _ DOMAIN ,    securityDomain )  ,    BiFunction . class ,    undertowDeploymentInfoService . getSecurityFunctionInjector (  )  )  ;", "} else    {", "infoBuilder . addDependency ( SecurityDomainService . SERVICE _ NAME . append ( securityDomain )  ,    SecurityDomainContext . class ,    undertowDeploymentInfoService . getSecurityDomainContextValue (  )  )  ;", "}", "}", "if    ( RequestControllerActivationMarker . isRequestControllerEnabled ( deploymentUnit )  )     {", "String   topLevelName ;", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "topLevelName    =    deploymentUnit . getName (  )  ;", "} else    {", "topLevelName    =    deploymentUnit . getParent (  )  . getName (  )  ;", "}", "infoBuilder . addDependency ( ControlPointService . serviceName ( topLevelName ,    UndertowExtension . SUBSYSTEM _ NAME )  ,    ControlPoint . class ,    undertowDeploymentInfoService . getControlPointInjectedValue (  )  )  ;", "}", "final   Set < String >    seenExecutors    =    new   HashSet < String >  (  )  ;", "if    (  ( metaData . getExecutorName (  )  )     !  =    null )     {", "final   InjectedValue < Executor >    executor    =    new   InjectedValue < Executor >  (  )  ;", "infoBuilder . addDependency ( WORKER . append ( metaData . getExecutorName (  )  )  ,    Executor . class ,    executor )  ;", "undertowDeploymentInfoService . addInjectedExecutor ( metaData . getExecutorName (  )  ,    executor )  ;", "seenExecutors . add ( metaData . getExecutorName (  )  )  ;", "}", "if    (  ( metaData . getServlets (  )  )     !  =    null )     {", "for    ( JBossServletMetaData   servlet    :    metaData . getServlets (  )  )     {", "if    (  (  ( servlet . getExecutorName (  )  )     !  =    null )     &  &     (  !  ( seenExecutors . contains ( servlet . getExecutorName (  )  )  )  )  )     {", "final   InjectedValue < Executor >    executor    =    new   InjectedValue < Executor >  (  )  ;", "infoBuilder . addDependency ( WORKER . append ( servlet . getExecutorName (  )  )  ,    Executor . class ,    executor )  ;", "undertowDeploymentInfoService . addInjectedExecutor ( servlet . getExecutorName (  )  ,    executor )  ;", "seenExecutors . add ( servlet . getExecutorName (  )  )  ;", "}", "}", "}", "if    ( componentRegistryExists )     {", "infoBuilder . addDependency ( ComponentRegistry . serviceName ( deploymentUnit )  ,    ComponentRegistry . class ,    undertowDeploymentInfoService . getComponentRegistryInjectedValue (  )  )  ;", "} else    {", "undertowDeploymentInfoService . getComponentRegistryInjectedValue (  )  . setValue ( new   ImmediateValue ( componentRegistry )  )  ;", "}", "if    ( sharedSessionManagerConfig    !  =    null )     {", "infoBuilder . addDependency ( deploymentUnit . getParent (  )  . getServiceName (  )  . append ( SharedSessionManagerConfig . SHARED _ SESSION _ MANAGER _ SERVICE _ NAME )  ,    SessionManagerFactory . class ,    undertowDeploymentInfoService . getSessionManagerFactoryInjector (  )  )  ;", "infoBuilder . addDependency ( deploymentUnit . getParent (  )  . getServiceName (  )  . append ( SharedSessionManagerConfig . SHARED _ SESSION _ IDENTIFIER _ CODEC _ SERVICE _ NAME )  ,    SessionIdentifierCodec . class ,    undertowDeploymentInfoService . getSessionIdentifierCodecInjector (  )  )  ;", "} else    {", "CapabilityServiceSupport   support    =    deploymentUnit . getAttachment ( CAPABILITY _ SERVICE _ SUPPORT )  ;", "CapabilityServiceBuilder < SessionManagerFactory >    factoryBuilder    =     . getSessionManagerFactoryBuilder ( deploymentServiceName ,    serverInstanceName ,    deploymentName ,    module ,    metaData ,    deploymentUnit . getAttachment ( UndertowAttachments . SERVLET _ CONTAINER _ SERVICE )  )  ;", "infoBuilder . addDependency ( factoryBuilder . getServiceName (  )  ,    SessionManagerFactory . class ,    undertowDeploymentInfoService . getSessionManagerFactoryInjector (  )  )  ;", "CapabilityServiceBuilder < SessionIdentifierCodec >    codecBuilder    =     . getSessionIdentifierCodecBuilder ( deploymentServiceName ,    serverInstanceName ,    deploymentName ,    metaData )  ;", "infoBuilder . addDependency ( codecBuilder . getServiceName (  )  ,    SessionIdentifierCodec . class ,    undertowDeploymentInfoService . getSessionIdentifierCodecInjector (  )  )  ;", "for    ( CapabilityServiceBuilder <  ?  >    builder    :    Arrays . asList ( factoryBuilder ,    codecBuilder )  )     {", "builder . configure ( support )  . build ( serviceTarget )  . setInitialMode ( ON _ DEMAND )  . install (  )  ;", "}", "}", "infoBuilder . install (  )  ;", "final   UndertowDeploymentService   service    =    new   UndertowDeploymentService ( injectionContainer ,    true )  ;", "final   ServiceBuilder < UndertowDeploymentService >    builder    =    serviceTarget . addService ( deploymentServiceName ,    service )  . addDependencies ( dependentComponents )  . addDependency ( UndertowService . SERVLET _ CONTAINER . append ( defaultContainer )  ,    ServletContainerService . class ,    service . getContainer (  )  )  . addDependency ( hostServiceName ,    Host . class ,    service . getHost (  )  )  . addDependencies ( deploymentUnit . getAttachmentList ( WEB _ DEPENDENCIES )  )  . addDependency ( deploymentInfoServiceName ,    DeploymentInfo . class ,    service . getDeploymentInfoInjectedValue (  )  )  ;", "Services . addServerExecutorDependency ( builder ,    service . getServerExecutorInjector (  )  )  ;", "builder . install (  )  ;", "deploymentUnit . addToAttachmentList ( DEPLOYMENT _ COMPLETE _ SERVICES ,    deploymentServiceName )  ;", "if    ( securityEnabled )     {", "AbstractSecurityDeployer < WarMetaData >    deployer    =    new   WarJACCDeployer (  )  ;", "JaccService < WarMetaData >    jaccService    =    deployer . deploy ( deploymentUnit ,    jaccContextId )  ;", "if    ( jaccService    !  =    null )     {", "final   ServiceName   jaccServiceName    =    deploymentUnit . getServiceName (  )  . append ( JaccService . SERVICE _ NAME )  ;", "ServiceBuilder <  ?  >    jaccBuilder    =    serviceTarget . addService ( jaccServiceName ,    jaccService )  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "final   DeploymentUnit   parentDU    =    deploymentUnit . getParent (  )  ;", "jaccBuilder . addDependency ( parentDU . getServiceName (  )  . append ( JaccService . SERVICE _ NAME )  ,    PolicyConfiguration . class ,    jaccService . getParentPolicyInjector (  )  )  ;", "}", "jaccBuilder . addDependency ( deploymentServiceName )  ;", "jaccBuilder . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "}", "final   DeploymentResourceSupport   deploymentResourceSupport    =    deploymentUnit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "final   ModelNode   node    =    deploymentResourceSupport . getDeploymentSubsystemModel ( UndertowExtension . SUBSYSTEM _ NAME )  ;", "node . get ( DeploymentDefinition . CONTEXT _ ROOT . getName (  )  )  . set (  (  \"  \"  . equals ( pathName )     ?     \"  /  \"     :    pathName )  )  ;", "node . get ( DeploymentDefinition . VIRTUAL _ HOST . getName (  )  )  . set ( hostName )  ;", "node . get ( DeploymentDefinition . SERVER . getName (  )  )  . set ( serverInstanceName )  ;", "processManagement ( deploymentUnit ,    metaData )  ;", "}", "METHOD_END"], "methodName": ["processDeployment"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentResourceSupport   deploymentResourceSupport    =    unit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "for    ( final   JBossServletMetaData   servlet    :    metaData . getServlets (  )  )     {", "try    {", "final   String   name    =    servlet . getName (  )  ;", "final   ModelNode   node    =    deploymentResourceSupport . getDeploymentSubModel ( UndertowExtension . SUBSYSTEM _ NAME ,    PathElement . pathElement (  \" servlet \"  ,    name )  )  ;", "node . get (  \" servlet - class \"  )  . set ( servlet . getServletClass (  )  )  ;", "node . get (  \" servlet - name \"  )  . set ( servlet . getServletName (  )  )  ;", "}    catch    ( Exception   e )     {", "continue ;", "}", "}", "}", "METHOD_END"], "methodName": ["processManagement"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "return   container ;", "}", "METHOD_END"], "methodName": ["getContainer"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentManager . getDeployment (  )  ;", "}", "METHOD_END"], "methodName": ["getDeployment"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentInfoInjectedValue ;", "}", "METHOD_END"], "methodName": ["getDeploymentInfoInjectedValue"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   this . serverExecutor ;", "}", "METHOD_END"], "methodName": ["getServerExecutorInjector"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )     {", "return ;", "}", "File [  ]    files    =    file . listFiles (  )  ;", "if    ( files    !  =    null )     {", "for    ( File   f    :    files )     {", ". recursiveDelete ( f )  ;", "}", "}", "if    (  !  ( file . delete (  )  )  )     {", "UndertowLogger . ROOT _ LOGGER . couldNotDeleteTempFile ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["recursiveDelete"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   old    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "DeploymentInfo   Info    =    InfoInjectedValue . getValue (  )  ;", "Thread . currentThread (  )  . setContextClassLoader ( Info . getClassLoader (  )  )  ;", "try    {", "StartupContext . setInjectionContainer ( webInjectionContainer )  ;", "try    {", "Manager    =    container . getValue (  )  . getServletContainer (  )  . addDeployment ( Info )  ;", "Manager . deploy (  )  ;", "HttpHandler   handler    =    Manager . start (  )  ;", "Deployment       =    Manager . getDeployment (  )  ;", "host . getValue (  )  . registerDeployment (  ,    handler )  ;", "}    finally    {", "StartupContext . setInjectionContainer ( null )  ;", "}", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( old )  ;", "}", "}", "METHOD_END"], "methodName": ["startContext"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   old    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "DeploymentInfo   deploymentInfo    =    deploymentInfoInjectedValue . getValue (  )  ;", "Thread . currentThread (  )  . setContextClassLoader ( deploymentInfo . getClassLoader (  )  )  ;", "try    {", "if    (  ( deploymentManager )     !  =    null )     {", "Deployment   deployment    =    deploymentManager . getDeployment (  )  ;", "try    {", "host . getValue (  )  . unregisterDeployment ( deployment )  ;", "deploymentManager . stop (  )  ;", "}    catch    ( ServletException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "deploymentManager . undeploy (  )  ;", "container . getValue (  )  . getServletContainer (  )  . removeDeployment ( deploymentInfoInjectedValue . getValue (  )  )  ;", "}", ". recursiveDelete ( deploymentInfoInjectedValue . getValue (  )  . getTempDir (  )  )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( old )  ;", "}", "}", "METHOD_END"], "methodName": ["stopContext"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowDeploymentService"}, {"methodBody": ["METHOD_START", "{", "final   List < PredicatedHandler >    handlerWrappers    =    new   ArrayList <  >  (  )  ;", "ClassLoader   oldCl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "try    {", "ResourceRoot   root    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "VirtualFile   config    =    root . getRoot (  )  . getChild (  . WEB _ INF )  ;", "try    {", "if    ( config . exists (  )  )     {", "handlerWrappers . addAll ( PredicatedHandlersParser . parse ( config . openStream (  )  ,    module . getClassLoader (  )  )  )  ;", "}", "Enumeration < URL >    paths    =    module . getClassLoader (  )  . getResources (  . META _ INF )  ;", "while    ( paths . hasMoreElements (  )  )     {", "URL   path    =    paths . nextElement (  )  ;", "handlerWrappers . addAll ( PredicatedHandlersParser . parse ( path . openStream (  )  ,    module . getClassLoader (  )  )  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "if    (  !  ( handlerWrappers . isEmpty (  )  )  )     {", "deploymentUnit . putAttachment (  . PREDICATED _ HANDLERS ,    handlerWrappers )  ;", "}", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( oldCl )  ;", "}", "}", "METHOD_END"], "methodName": ["handleInfoFile"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowHandlersDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "WarMetaData   warMetadata    =    deploymentUnit . getAttachment ( ATTACHMENT _ KEY )  ;", "if    ( warMetadata    =  =    null )     {", "return ;", "}", "JBossWebMetaData   merged    =    warMetadata . getMergedJBossWebMetaData (  )  ;", "if    ( merged    =  =    null )     {", "return ;", "}", "List < HttpHandlerMetaData >    handlers    =    merged . getHandlers (  )  ;", "if    ( handlers    =  =    null )     {", "return ;", "}", "for    ( HttpHandlerMetaData   hander    :    handlers )     {", "try    {", "ClassLoader   cl    =    module . getClassLoader (  )  ;", "if    (  ( hander . getModule (  )  )     !  =    null )     {", "Module   handlerModule    =    deploymentUnit . getAttachment ( SERVICE _ MODULE _ LOADER )  . loadModule ( ModuleIdentifier . fromString ( hander . getModule (  )  )  )  ;", "cl    =    handlerModule . getClassLoader (  )  ;", "}", "Class <  ?  >    handlerClass    =    cl . loadClass ( hander . getHandlerClass (  )  )  ;", "Map < String ,    String >    params    =    new   HashMap <  >  (  )  ;", "if    (  ( hander . getParams (  )  )     !  =    null )     {", "for    ( ParamValueMetaData   param    :    hander . getParams (  )  )     {", "params . put ( param . getParamName (  )  ,    param . getParamValue (  )  )  ;", "}", "}", "deploymentUnit . addToAttachmentList ( UndertowAttachments . UNDERTOW _ OUTER _ HANDLER _ CHAIN _ WRAPPERS ,    new   ConfiguredHandlerWrapper ( handlerClass ,    params )  )  ;", "}    catch    ( Exception   e )     {", "throw   UndertowLogger . ROOT _ LOGGER . failedToConfigureHandlerClass ( hander . getHandlerClass (  )  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleJbossWebXml"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowHandlersDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   DeploymentResourceSupport   deploymentResourceSupport    =    unit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "final   ModelNode   node    =    deploymentResourceSupport . gSubModel ( UndertowExtension . SUBSYSTEM _ NAME ,    PathElement . pathElement (  \" websocket \"  ,    path )  )  ;", "node . get (  \" endpoint - class \"  )  . set ( endpoint . getName (  )  )  ;", "node . get (  \" path \"  )  . set ( path )  ;", "}    catch    ( Exception   e )     {", "UndertowLogger . ROOT _ LOGGER . failedToRegisterWebsocket ( endpoint ,    path ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["addManagementWebsocket"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowJSRWebSocketDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   Endpoint >  >    allScannedEndpointImplementations    =    new   HashSet ( endpoints )  ;", "Set < Class <  ?  >  >    allScannedAnnotatedEndpoints    =    new   HashSet <  >  ( annotatedEndpoints )  ;", "Set < Class <  ?  >  >    newAnnotatatedEndpoints    =    new   HashSet <  >  (  )  ;", "Set < ServerEndpointConfig >    serverEndpointConfigurations    =    new   HashSet <  >  (  )  ;", "final   Set < ServerApplicationConfig >    configInstances    =    new   HashSet <  >  (  )  ;", "for    ( Class <  ?    extends   ServerApplicationConfig >    clazz    :    serverApplicationConfigClasses )     {", "try    {", "configInstances . add ( clazz . newInstance (  )  )  ;", "}    catch    ( InstantiationException    |    IllegalAccessException   e )     {", "ROOT _ LOGGER . couldNotInitializeConfiguration ( clazz ,    e )  ;", "}", "}", "if    (  !  ( configInstances . isEmpty (  )  )  )     {", "for    ( ServerApplicationConfig   config    :    configInstances )     {", "Set < Class <  ?  >  >    returnedEndpoints    =    config . getAnnotatedEndpointClasses ( allScannedAnnotatedEndpoints )  ;", "if    ( returnedEndpoints    !  =    null )     {", "newAnnotatatedEndpoints . addAll ( returnedEndpoints )  ;", "}", "Set < ServerEndpointConfig >    endpointConfigs    =    config . getEndpointConfigs ( allScannedEndpointImplementations )  ;", "if    ( endpointConfigs    !  =    null )     {", "serverEndpointConfigurations . addAll ( endpointConfigs )  ;", "}", "}", "} else    {", "newAnnotatatedEndpoints . addAll ( allScannedAnnotatedEndpoints )  ;", "}", "for    ( Class <  ?  >    endpoint    :    newAnnotatatedEndpoints )     {", "if    ( endpoint    !  =    null )     {", "container . addEndpoint ( endpoint )  ;", "ServerEndpoint   annotation    =    endpoint . getAnnotation ( ServerEndpoint . class )  ;", "if    ( annotation    !  =    null )     {", "String   path    =    annotation . value (  )  ;", "addManagementWebsocket ( Unit ,    endpoint ,    path )  ;", "}", "}", "}", "for    ( final   ServerEndpointConfig   endpoint    :    serverEndpointConfigurations )     {", "if    ( endpoint    !  =    null )     {", "container . addEndpoint ( endpoint )  ;", "addManagementWebsocket ( Unit ,    endpoint . getEndpointClass (  )  ,    endpoint . getPath (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doDeployment"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowJSRWebSocketDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "deploymentUnit . putAttachment ( UndertowAttachments . WEB _ SOCKET _ DEPLOYMENT _ INFO ,    wInfo )  ;", "}", "METHOD_END"], "methodName": ["installWebsockets"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowJSRWebSocketDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( metrics . containsKey ( name )  )     {", "return   metrics . get ( name )  . get (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMetrics"], "fileName": "org.wildfly.extension.undertow.deployment.UndertowMetricsCollector"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getFile (  )  )     =  =    null )     {", "return   null ;", "}", "return   getFile (  )  . toPath (  )  ;", "}", "METHOD_END"], "methodName": ["getFilePath"], "fileName": "org.wildfly.extension.undertow.deployment.VirtualFileResource"}, {"methodBody": ["METHOD_START", "{", "return   getResourceManagerRoot (  )  . toPath (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceManagerRootPath"], "fileName": "org.wildfly.extension.undertow.deployment.VirtualFileResource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    (  !  ( DeploymentTypeMarker . isType ( WAR ,    deploymentUnit )  )  )     {", "return ;", "}", "WarMetaData   warMetaData    =    deploymentUnit . getAttachment ( ATTACHMENT _ KEY )  ;", "assert   warMetaData    !  =    null ;", "Map < String ,    WebMetaData >    annotationsMetaData    =    warMetaData . getAnnotationsMetaData (  )  ;", "if    ( annotationsMetaData    =  =    null )     {", "annotationsMetaData    =    new   HashMap < String ,    WebMetaData >  (  )  ;", "warMetaData . setAnnotationsMetaData ( annotationsMetaData )  ;", "}", "Map < ResourceRoot ,    Index >    indexes    =    AnnotationIndexUtils . getAnnotationIndexes ( deploymentUnit )  ;", "for    ( final   Map . Entry < ResourceRoot ,    Index >    entry    :    indexes . entrySet (  )  )     {", "final   Index   jarIndex    =    entry . getValue (  )  ;", "annotationsMetaData . put ( entry . getKey (  )  . getRootName (  )  ,    processAnnotations ( jarIndex )  )  ;", "}", "Map < ModuleIdentifier ,    CompositeIndex >    additionalModelAnnotations    =    deploymentUnit . getAttachment ( ADDITIONAL _ ANNOTATION _ INDEXES _ BY _ MODULE )  ;", "if    ( additionalModelAnnotations    !  =    null )     {", "final   List < WebMetaData >    additional    =    new   ArrayList < WebMetaData >  (  )  ;", "for    ( Map . Entry < ModuleIdentifier ,    CompositeIndex >    entry    :    additionalModelAnnotations . entrySet (  )  )     {", "for    ( Index   index    :    entry . getValue (  )  . getIndexes (  )  )     {", "additional . add ( processAnnotations ( index )  )  ;", "}", "}", "warMetaData . setAdditionalModuleAnnotationsMetadata ( additional )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.wildfly.extension.undertow.deployment.WarAnnotationDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "DescriptionsImpl   descriptions    =    null ;", "if    (  ( description . length (  )  )     >     0  )     {", "DescriptionImpl   di    =    new   DescriptionImpl (  )  ;", "di . setDescription ( description )  ;", "descriptions    =    new   DescriptionsImpl (  )  ;", "descriptions . add ( di )  ;", "}", "return   descriptions ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.wildfly.extension.undertow.deployment.WarAnnotationDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "DescriptionGroupMetaData   dg    =    null ;", "if    (  ( description . length (  )  )     >     0  )     {", "dg    =    new   DescriptionGroupMetaData (  )  ;", "Descriptions   descriptions    =    getDescription ( description )  ;", "dg . setDescriptions ( descriptions )  ;", "}", "return   dg ;", "}", "METHOD_END"], "methodName": ["getDescriptionGroup"], "fileName": "org.wildfly.extension.undertow.deployment.WarAnnotationDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "DescriptionGroupMetaData   dg    =    null ;", "if    (  (  (  (  ( description . length (  )  )     >     0  )     |  |     (  ( displayName . length (  )  )     >     0  )  )     |  |     (  ( smallIcon . length (  )  )     >     0  )  )     |  |     (  ( largeIcon . length (  )  )     >     0  )  )     {", "dg    =    new   DescriptionGroupMetaData (  )  ;", "Descriptions   descriptions    =    getDescription ( description )  ;", "if    ( descriptions    !  =    null )", "dg . setDescriptions ( descriptions )  ;", "DisplayNames   displayNames    =    getDisplayName ( displayName )  ;", "if    ( displayNames    !  =    null )", "dg . setDisplayNames ( displayNames )  ;", "Icons   icons    =    getIcons ( smallIcon ,    largeIcon )  ;", "if    ( icons    !  =    null )", "dg . setIcons ( icons )  ;", "}", "return   dg ;", "}", "METHOD_END"], "methodName": ["getDescriptionGroup"], "fileName": "org.wildfly.extension.undertow.deployment.WarAnnotationDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "DisplayNamesImpl   displayNames    =    null ;", "if    (  ( displayName . length (  )  )     >     0  )     {", "DisplayNameImpl   dn    =    new   DisplayNameImpl (  )  ;", "dn . setDisplayName ( displayName )  ;", "displayNames    =    new   DisplayNamesImpl (  )  ;", "displayNames . add ( dn )  ;", "}", "return   displayNames ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.wildfly.extension.undertow.deployment.WarAnnotationDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "IcImpl   ic    =    null ;", "if    (  (  ( smallIclength (  )  )     >     0  )     |  |     (  ( largeIclength (  )  )     >     0  )  )     {", "Icmpl   i    =    new   Icmpl (  )  ;", "i . setSmallIcsmallIc ;", "i . setLargeIclargeIc ;", "ic    =    new   IcImpl (  )  ;", "ic . add ( i )  ;", "}", "return   ic ;", "}", "METHOD_END"], "methodName": ["getIcons"], "fileName": "org.wildfly.extension.undertow.deployment.WarAnnotationDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "WebMetaData   metaData    =    new   WebMetaData (  )  ;", "final   List < AnnotationInstance >    webServletAnnotations    =    index . getAnnotations (  . webServlet )  ;", "if    (  ( webServletAnnotations    !  =    null )     &  &     (  ( webServletAnnotations . size (  )  )     >     0  )  )     {", "ServletsMetaData   servlets    =    new   ServletsMetaData (  )  ;", "List < ServletMappingMetaData >    servletMappings    =    new   ArrayList < ServletMappingMetaData >  (  )  ;", "for    ( final   AnnotationInstance   annotation    :    webServletAnnotations )     {", "ServletMetaData   servlet    =    new   ServletMetaData (  )  ;", "AnnotationTarget   target    =    annotation . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidWebServletAnnotation ( target )  )  ;", "}", "ClassInfo   classInfo    =    ClassInfo . class . cast ( target )  ;", "servlet . setServletClass ( classInfo . toString (  )  )  ;", "AnnotationValue   nameValue    =    annotation . value (  \" name \"  )  ;", "if    (  ( nameValue    =  =    null )     |  |     ( nameValue . asString (  )  . isEmpty (  )  )  )     {", "servlet . setName ( classInfo . toString (  )  )  ;", "} else    {", "servlet . setName ( nameValue . asString (  )  )  ;", "}", "AnnotationValue   loadOnStartup    =    annotation . value (  \" loadOnStartup \"  )  ;", "if    (  ( loadOnStartup    !  =    null )     &  &     (  ( loadOnStartup . asInt (  )  )     >  =     0  )  )     {", "servlet . setLoadOnStartupInt ( loadOnStartup . asInt (  )  )  ;", "}", "AnnotationValue   asyncSupported    =    annotation . value (  \" asyncSupported \"  )  ;", "if    ( asyncSupported    !  =    null )     {", "servlet . setAsyncSupported ( asyncSupported . asBoolean (  )  )  ;", "}", "AnnotationValue   initParamsValue    =    annotation . value (  \" initParams \"  )  ;", "if    ( initParamsValue    !  =    null )     {", "AnnotationInstance [  ]    initParamsAnnotations    =    initParamsValue . asNestedArray (  )  ;", "if    (  ( initParamsAnnotations    !  =    null )     &  &     (  ( initParamsAnnotations . length )     >     0  )  )     {", "List < ParamValueMetaData >    initParams    =    new   ArrayList < ParamValueMetaData >  (  )  ;", "for    ( AnnotationInstance   initParamsAnnotation    :    initParamsAnnotations )     {", "ParamValueMetaData   initParam    =    new   ParamValueMetaData (  )  ;", "AnnotationValue   initParamName    =    initParamsAnnotation . value (  \" name \"  )  ;", "AnnotationValue   initParamValue    =    initParamsAnnotation . value (  )  ;", "if    (  ( initParamName    =  =    null )     |  |     ( initParamValue    =  =    null )  )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidWebInitParamAnnotation ( target )  )  ;", "}", "AnnotationValue   initParamDescription    =    initParamsAnnotation . value (  \" description \"  )  ;", "initParam . setParamName ( initParamName . asString (  )  )  ;", "initParam . setParamValue ( initParamValue . asString (  )  )  ;", "if    ( initParamDescription    !  =    null )     {", "Descriptions   descriptions    =    getDescription ( initParamDescription . asString (  )  )  ;", "if    ( descriptions    !  =    null )     {", "initParam . setDescriptions ( descriptions )  ;", "}", "}", "initParams . add ( initParam )  ;", "}", "servlet . setInitParam ( initParams )  ;", "}", "}", "AnnotationValue   descriptionValue    =    annotation . value (  \" description \"  )  ;", "AnnotationValue   displayNameValue    =    annotation . value (  \" displayName \"  )  ;", "AnnotationValue   smallIconValue    =    annotation . value (  \" smallIcon \"  )  ;", "AnnotationValue   largeIconValue    =    annotation . value (  \" largeIcon \"  )  ;", "DescriptionGroupMetaData   descriptionGroup    =    getDescriptionGroup (  ( descriptionValue    =  =    null    ?     \"  \"     :    descriptionValue . asString (  )  )  ,     ( displayNameValue    =  =    null    ?     \"  \"     :    displayNameValue . asString (  )  )  ,     ( smallIconValue    =  =    null    ?     \"  \"     :    smallIconValue . asString (  )  )  ,     ( largeIconValue    =  =    null    ?     \"  \"     :    largeIconValue . asString (  )  )  )  ;", "if    ( descriptionGroup    !  =    null )     {", "servlet . setDescriptionGroup ( descriptionGroup )  ;", "}", "ServletMappingMetaData   servletMapping    =    new   ServletMappingMetaData (  )  ;", "servletMapping . setServletName ( servlet . getName (  )  )  ;", "List < String >    urlPatterns    =    new   ArrayList < String >  (  )  ;", "AnnotationValue   urlPatternsValue    =    annotation . value (  \" urlPatterns \"  )  ;", "if    ( urlPatternsValue    !  =    null )     {", "for    ( String   urlPattern    :    urlPatternsValue . asStringArray (  )  )     {", "urlPatterns . add ( urlPattern )  ;", "}", "}", "urlPatternsValue    =    annotation . value (  )  ;", "if    ( urlPatternsValue    !  =    null )     {", "for    ( String   urlPattern    :    urlPatternsValue . asStringArray (  )  )     {", "urlPatterns . add ( urlPattern )  ;", "}", "}", "if    (  ( urlPatterns . size (  )  )     >     0  )     {", "servletMapping . setUrlPatterns ( urlPatterns )  ;", "servletMappings . add ( servletMapping )  ;", "}", "servlets . add ( servlet )  ;", "}", "metaData . setServlets ( servlets )  ;", "metaData . setServletMappings ( servletMappings )  ;", "}", "final   List < AnnotationInstance >    webFilterAnnotations    =    index . getAnnotations (  . webFilter )  ;", "if    (  ( webFilterAnnotations    !  =    null )     &  &     (  ( webFilterAnnotations . size (  )  )     >     0  )  )     {", "FiltersMetaData   filters    =    new   FiltersMetaData (  )  ;", "List < FilterMappingMetaData >    filterMappings    =    new   ArrayList < FilterMappingMetaData >  (  )  ;", "for    ( final   AnnotationInstance   annotation    :    webFilterAnnotations )     {", "FilterMetaData   filter    =    new   FilterMetaData (  )  ;", "AnnotationTarget   target    =    annotation . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidWebFilterAnnotation ( target )  )  ;", "}", "ClassInfo   classInfo    =    ClassInfo . class . cast ( target )  ;", "filter . setFilterClass ( classInfo . toString (  )  )  ;", "AnnotationValue   nameValue    =    annotation . value (  \" filterName \"  )  ;", "if    (  ( nameValue    =  =    null )     |  |     ( nameValue . asString (  )  . isEmpty (  )  )  )     {", "filter . setName ( classInfo . toString (  )  )  ;", "} else    {", "filter . setName ( nameValue . asString (  )  )  ;", "}", "AnnotationValue   asyncSupported    =    annotation . value (  \" asyncSupported \"  )  ;", "if    ( asyncSupported    !  =    null )     {", "filter . setAsyncSupported ( asyncSupported . asBoolean (  )  )  ;", "}", "AnnotationValue   initParamsValue    =    annotation . value (  \" initParams \"  )  ;", "if    ( initParamsValue    !  =    null )     {", "AnnotationInstance [  ]    initParamsAnnotations    =    initParamsValue . asNestedArray (  )  ;", "if    (  ( initParamsAnnotations    !  =    null )     &  &     (  ( initParamsAnnotations . length )     >     0  )  )     {", "List < ParamValueMetaData >    initParams    =    new   ArrayList < ParamValueMetaData >  (  )  ;", "for    ( AnnotationInstance   initParamsAnnotation    :    initParamsAnnotations )     {", "ParamValueMetaData   initParam    =    new   ParamValueMetaData (  )  ;", "AnnotationValue   initParamName    =    initParamsAnnotation . value (  \" name \"  )  ;", "AnnotationValue   initParamValue    =    initParamsAnnotation . value (  )  ;", "if    (  ( initParamName    =  =    null )     |  |     ( initParamValue    =  =    null )  )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidWebInitParamAnnotation ( target )  )  ;", "}", "AnnotationValue   initParamDescription    =    initParamsAnnotation . value (  \" description \"  )  ;", "initParam . setParamName ( initParamName . asString (  )  )  ;", "initParam . setParamValue ( initParamValue . asString (  )  )  ;", "if    ( initParamDescription    !  =    null )     {", "Descriptions   descriptions    =    getDescription ( initParamDescription . asString (  )  )  ;", "if    ( descriptions    !  =    null )     {", "initParam . setDescriptions ( descriptions )  ;", "}", "}", "initParams . add ( initParam )  ;", "}", "filter . setInitParam ( initParams )  ;", "}", "}", "AnnotationValue   descriptionValue    =    annotation . value (  \" description \"  )  ;", "AnnotationValue   displayNameValue    =    annotation . value (  \" displayName \"  )  ;", "AnnotationValue   smallIconValue    =    annotation . value (  \" smallIcon \"  )  ;", "AnnotationValue   largeIconValue    =    annotation . value (  \" largeIcon \"  )  ;", "DescriptionGroupMetaData   descriptionGroup    =    getDescriptionGroup (  ( descriptionValue    =  =    null    ?     \"  \"     :    descriptionValue . asString (  )  )  ,     ( displayNameValue    =  =    null    ?     \"  \"     :    displayNameValue . asString (  )  )  ,     ( smallIconValue    =  =    null    ?     \"  \"     :    smallIconValue . asString (  )  )  ,     ( largeIconValue    =  =    null    ?     \"  \"     :    largeIconValue . asString (  )  )  )  ;", "if    ( descriptionGroup    !  =    null )     {", "filter . setDescriptionGroup ( descriptionGroup )  ;", "}", "filters . add ( filter )  ;", "FilterMappingMetaData   filterMapping    =    new   FilterMappingMetaData (  )  ;", "filterMapping . setFilterName ( filter . getName (  )  )  ;", "List < String >    urlPatterns    =    new   ArrayList < String >  (  )  ;", "List < String >    servletNames    =    new   ArrayList < String >  (  )  ;", "List < DispatcherType >    dispatchers    =    new   ArrayList < DispatcherType >  (  )  ;", "AnnotationValue   urlPatternsValue    =    annotation . value (  \" urlPatterns \"  )  ;", "if    ( urlPatternsValue    !  =    null )     {", "for    ( String   urlPattern    :    urlPatternsValue . asStringArray (  )  )     {", "urlPatterns . add ( urlPattern )  ;", "}", "}", "urlPatternsValue    =    annotation . value (  )  ;", "if    ( urlPatternsValue    !  =    null )     {", "for    ( String   urlPattern    :    urlPatternsValue . asStringArray (  )  )     {", "urlPatterns . add ( urlPattern )  ;", "}", "}", "if    (  ( urlPatterns . size (  )  )     >     0  )     {", "filterMapping . setUrlPatterns ( urlPatterns )  ;", "}", "AnnotationValue   servletNamesValue    =    annotation . value (  \" servletNames \"  )  ;", "if    ( servletNamesValue    !  =    null )     {", "for    ( String   servletName    :    servletNamesValue . asStringArray (  )  )     {", "servletNames . add ( servletName )  ;", "}", "}", "if    (  ( servletNames . size (  )  )     >     0  )     {", "filterMapping . setServletNames ( servletNames )  ;", "}", "AnnotationValue   dispatcherTypesValue    =    annotation . value (  \" dispatcherTypes \"  )  ;", "if    ( dispatcherTypesValue    !  =    null )     {", "for    ( String   dispatcherValue    :    dispatcherTypesValue . asEnumArray (  )  )     {", "dispatchers . add ( DispatcherType . valueOf ( dispatcherValue )  )  ;", "}", "}", "if    (  ( dispatchers . size (  )  )     >     0  )     {", "filterMapping . setDispatchers ( dispatchers )  ;", "}", "if    (  (  ( urlPatterns . size (  )  )     >     0  )     |  |     (  ( servletNames . size (  )  )     >     0  )  )     {", "filterMappings . add ( filterMapping )  ;", "}", "}", "metaData . setFilters ( filters )  ;", "metaData . setFilterMappings ( filterMappings )  ;", "}", "final   List < AnnotationInstance >    webListenerAnnotations    =    index . getAnnotations (  . webListener )  ;", "if    (  ( webListenerAnnotations    !  =    null )     &  &     (  ( webListenerAnnotations . size (  )  )     >     0  )  )     {", "List < ListenerMetaData >    listeners    =    new   ArrayList < ListenerMetaData >  (  )  ;", "for    ( final   AnnotationInstance   annotation    :    webListenerAnnotations )     {", "ListenerMetaData   listener    =    new   ListenerMetaData (  )  ;", "AnnotationTarget   target    =    annotation . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidWebListenerAnnotation ( target )  )  ;", "}", "ClassInfo   classInfo    =    ClassInfo . class . cast ( target )  ;", "listener . setListenerClass ( classInfo . toString (  )  )  ;", "AnnotationValue   descriptionValue    =    annotation . value (  )  ;", "if    ( descriptionValue    !  =    null )     {", "DescriptionGroupMetaData   descriptionGroup    =    getDescriptionGroup ( descriptionValue . asString (  )  )  ;", "if    ( descriptionGroup    !  =    null )     {", "listener . setDescriptionGroup ( descriptionGroup )  ;", "}", "}", "listeners . add ( listener )  ;", "}", "metaData . setListeners ( listeners )  ;", "}", "final   List < AnnotationInstance >    runAsAnnotations    =    index . getAnnotations (  . runAs )  ;", "if    (  ( runAsAnnotations    !  =    null )     &  &     (  ( runAsAnnotations . size (  )  )     >     0  )  )     {", "AnnotationsMetaData   annotations    =    metaData . getAnnotations (  )  ;", "if    ( annotations    =  =    null )     {", "annotations    =    new   AnnotationsMetaData (  )  ;", "metaData . setAnnotations ( annotations )  ;", "}", "for    ( final   AnnotationInstance   annotation    :    runAsAnnotations )     {", "AnnotationTarget   target    =    annotation . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "continue ;", "}", "ClassInfo   classInfo    =    ClassInfo . class . cast ( target )  ;", "AnnotationMetaData   annotationMD    =    annotations . get ( classInfo . toString (  )  )  ;", "if    ( annotationMD    =  =    null )     {", "annotationMD    =    new   AnnotationMetaData (  )  ;", "annotationMD . setClassName ( classInfo . toString (  )  )  ;", "annotations . add ( annotationMD )  ;", "}", "if    (  ( annotation . value (  )  )     =  =    null )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidRunAsAnnotation ( target )  )  ;", "}", "RunAsMetaData   runAs    =    new   RunAsMetaData (  )  ;", "runAs . setRoleName ( annotation . value (  )  . asString (  )  )  ;", "annotationMD . setRunAs ( runAs )  ;", "}", "}", "final   List < AnnotationInstance >    declareRolesAnnotations    =    index . getAnnotations (  . declareRoles )  ;", "if    (  ( declareRolesAnnotations    !  =    null )     &  &     (  ( declareRolesAnnotations . size (  )  )     >     0  )  )     {", "SecurityRolesMetaData   securityRoles    =    metaData . getSecurityRoles (  )  ;", "if    ( securityRoles    =  =    null )     {", "securityRoles    =    new   SecurityRolesMetaData (  )  ;", "metaData . setSecurityRoles ( securityRoles )  ;", "}", "for    ( final   AnnotationInstance   annotation    :    declareRolesAnnotations )     {", "if    (  ( annotation . value (  )  )     =  =    null )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidDeclareRolesAnnotation ( annotation . target (  )  )  )  ;", "}", "for    ( String   role    :    annotation . value (  )  . asStringArray (  )  )     {", "SecurityRoleMetaData   sr    =    new   SecurityRoleMetaData (  )  ;", "sr . setRoleName ( role )  ;", "securityRoles . add ( sr )  ;", "}", "}", "}", "final   List < AnnotationInstance >    multipartConfigAnnotations    =    index . getAnnotations (  . multipartConfig )  ;", "if    (  ( multipartConfigAnnotations    !  =    null )     &  &     (  ( multipartConfigAnnotations . size (  )  )     >     0  )  )     {", "AnnotationsMetaData   annotations    =    metaData . getAnnotations (  )  ;", "if    ( annotations    =  =    null )     {", "annotations    =    new   AnnotationsMetaData (  )  ;", "metaData . setAnnotations ( annotations )  ;", "}", "for    ( final   AnnotationInstance   annotation    :    multipartConfigAnnotations )     {", "AnnotationTarget   target    =    annotation . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidMultipartConfigAnnotation ( target )  )  ;", "}", "ClassInfo   classInfo    =    ClassInfo . class . cast ( target )  ;", "AnnotationMetaData   annotationMD    =    annotations . get ( classInfo . toString (  )  )  ;", "if    ( annotationMD    =  =    null )     {", "annotationMD    =    new   AnnotationMetaData (  )  ;", "annotationMD . setClassName ( classInfo . toString (  )  )  ;", "annotations . add ( annotationMD )  ;", "}", "MultipartConfigMetaData   multipartConfig    =    new   MultipartConfigMetaData (  )  ;", "AnnotationValue   locationValue    =    annotation . value (  \" location \"  )  ;", "if    (  ( locationValue    !  =    null )     &  &     (  ( locationValue . asString (  )  . length (  )  )     >     0  )  )     {", "multipartConfig . setLocation ( locationValue . asString (  )  )  ;", "}", "AnnotationValue   maxFileSizeValue    =    annotation . value (  \" maxFileSize \"  )  ;", "if    (  ( maxFileSizeValue    !  =    null )     &  &     (  ( maxFileSizeValue . asLong (  )  )     !  =     (  -  1 L )  )  )     {", "multipartConfig . setMaxFileSize ( maxFileSizeValue . asLong (  )  )  ;", "}", "AnnotationValue   maxRequestSizeValue    =    annotation . value (  \" maxRequestSize \"  )  ;", "if    (  ( maxRequestSizeValue    !  =    null )     &  &     (  ( maxRequestSizeValue . asLong (  )  )     !  =     (  -  1 L )  )  )     {", "multipartConfig . setMaxRequestSize ( maxRequestSizeValue . asLong (  )  )  ;", "}", "AnnotationValue   fileSizeThresholdValue    =    annotation . value (  \" fileSizeThreshold \"  )  ;", "if    (  ( fileSizeThresholdValue    !  =    null )     &  &     (  ( fileSizeThresholdValue . asInt (  )  )     !  =     0  )  )     {", "multipartConfig . setFileSizeThreshold ( fileSizeThresholdValue . asInt (  )  )  ;", "}", "annotationMD . setMultipartConfig ( multipartConfig )  ;", "}", "}", "final   List < AnnotationInstance >    servletSecurityAnnotations    =    index . getAnnotations (  . servletSecurity )  ;", "if    (  ( servletSecurityAnnotations    !  =    null )     &  &     (  ( servletSecurityAnnotations . size (  )  )     >     0  )  )     {", "AnnotationsMetaData   annotations    =    metaData . getAnnotations (  )  ;", "if    ( annotations    =  =    null )     {", "annotations    =    new   AnnotationsMetaData (  )  ;", "metaData . setAnnotations ( annotations )  ;", "}", "for    ( final   AnnotationInstance   annotation    :    servletSecurityAnnotations )     {", "AnnotationTarget   target    =    annotation . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . invalidServletSecurityAnnotation ( target )  )  ;", "}", "ClassInfo   classInfo    =    ClassInfo . class . cast ( target )  ;", "AnnotationMetaData   annotationMD    =    annotations . get ( classInfo . toString (  )  )  ;", "if    ( annotationMD    =  =    null )     {", "annotationMD    =    new   AnnotationMetaData (  )  ;", "annotationMD . setClassName ( classInfo . toString (  )  )  ;", "annotations . add ( annotationMD )  ;", "}", "ServletSecurityMetaData   servletSecurity    =    new   ServletSecurityMetaData (  )  ;", "AnnotationValue   httpConstraintValue    =    annotation . value (  )  ;", "List < String >    rolesAllowed    =    new   ArrayList < String >  (  )  ;", "if    ( httpConstraintValue    !  =    null )     {", "AnnotationInstance   httpConstraint    =    httpConstraintValue . asNested (  )  ;", "AnnotationValue   httpConstraintERSValue    =    httpConstraint . value (  )  ;", "if    ( httpConstraintERSValue    !  =    null )     {", "servletSecurity . setEmptyRoleSemantic ( EmptyRoleSemanticType . valueOf ( httpConstraintERSValue . asEnum (  )  )  )  ;", "}", "AnnotationValue   httpConstraintTGValue    =    httpConstraint . value (  \" transportGuarantee \"  )  ;", "if    ( httpConstraintTGValue    !  =    null )     {", "servletSecurity . setTransportGuarantee ( TransportGuaranteeType . valueOf ( httpConstraintTGValue . asEnum (  )  )  )  ;", "}", "AnnotationValue   rolesAllowedValue    =    httpConstraint . value (  \" rolesAllowed \"  )  ;", "if    ( rolesAllowedValue    !  =    null )     {", "for    ( String   role    :    rolesAllowedValue . asStringArray (  )  )     {", "rolesAllowed . add ( role )  ;", "}", "}", "}", "servletSecurity . setRolesAllowed ( rolesAllowed )  ;", "AnnotationValue   httpMethodConstraintsValue    =    annotation . value (  \" httpMethodConstraints \"  )  ;", "if    ( httpMethodConstraintsValue    !  =    null )     {", "AnnotationInstance [  ]    httpMethodConstraints    =    httpMethodConstraintsValue . asNestedArray (  )  ;", "if    (  ( httpMethodConstraints . length )     >     0  )     {", "List < HttpMethodConstraintMetaData >    methodConstraints    =    new   ArrayList < HttpMethodConstraintMetaData >  (  )  ;", "for    ( AnnotationInstance   httpMethodConstraint    :    httpMethodConstraints )     {", "HttpMethodConstraintMetaData   methodConstraint    =    new   HttpMethodConstraintMetaData (  )  ;", "AnnotationValue   httpMethodConstraintValue    =    httpMethodConstraint . value (  )  ;", "if    ( httpMethodConstraintValue    !  =    null )     {", "methodConstraint . setMethod ( httpMethodConstraintValue . asString (  )  )  ;", "}", "AnnotationValue   httpMethodConstraintERSValue    =    httpMethodConstraint . value (  \" emptyRoleSemantic \"  )  ;", "if    ( httpMethodConstraintERSValue    !  =    null )     {", "methodConstraint . setEmptyRoleSemantic ( EmptyRoleSemanticType . valueOf ( httpMethodConstraintERSValue . asEnum (  )  )  )  ;", "}", "AnnotationValue   httpMethodConstraintTGValue    =    httpMethodConstraint . value (  \" transportGuarantee \"  )  ;", "if    ( httpMethodConstraintTGValue    !  =    null )     {", "methodConstraint . setTransportGuarantee ( TransportGuaranteeType . valueOf ( httpMethodConstraintTGValue . asEnum (  )  )  )  ;", "}", "AnnotationValue   rolesAllowedValue    =    httpMethodConstraint . value (  \" rolesAllowed \"  )  ;", "rolesAllowed    =    new   ArrayList < String >  (  )  ;", "if    ( rolesAllowedValue    !  =    null )     {", "for    ( String   role    :    rolesAllowedValue . asStringArray (  )  )     {", "rolesAllowed . add ( role )  ;", "}", "}", "methodConstraint . setRolesAllowed ( rolesAllowed )  ;", "methodConstraints . add ( methodConstraint )  ;", "}", "servletSecurity . setHttpMethodConstraints ( methodConstraints )  ;", "}", "}", "annotationMD . setServletSecurity ( servletSecurity )  ;", "}", "}", "return   metaData ;", "}", "METHOD_END"], "methodName": ["processAnnotations"], "fileName": "org.wildfly.extension.undertow.deployment.WarAnnotationDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "String   deploymentName    =    deploymentUnit . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    ( deploymentName . endsWith (  \"  . war \"  )  )     {", "DeploymentTypeMarker . setType ( WAR ,    deploymentUnit )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.wildfly.extension.undertow.deployment.WarDeploymentInitializingProcessor"}, {"methodBody": ["METHOD_START", "{", "List < WarMetaDataProcessor . Ordering >    work    =    new   ArrayList < WarMetaDataProcessor . Ordering >  (  )  ;", "Iterator < WarMetaDataProcessor . WebOrdering >    webOrderingsIterator    =    webOrderings . iterator (  )  ;", "while    ( webOrderingsIterator . hasNext (  )  )     {", "WarMetaDataProcessor . WebOrdering   webOrdering    =    webOrderingsIterator . next (  )  ;", "WarMetaDataProcessor . Ordering   ordering    =    new   WarMetaDataProcessor . Ordering (  )  ;", "ordering . ordering    =    webOrdering ;", "ordering . afterOthers    =    webOrdering . isAfterOthers (  )  ;", "ordering . beforeOthers    =    webOrdering . isBeforeOthers (  )  ;", "if    (  ( ordering . afterOthers )     &  &     ( ordering . beforeOthers )  )     {", "throw   new   IllegalStateException ( UndertowLogger . ROOT _ LOGGER . invalidRelativeOrderingBeforeAndAfter ( webOrdering . getJar (  )  )  )  ;", "}", "work . add ( ordering )  ;", "}", "Iterator < WarMetaDataProcessor . Ordering >    workIterator    =    work . iterator (  )  ;", "while    ( workIterator . hasNext (  )  )     {", "WarMetaDataProcessor . Ordering   ordering    =    workIterator . next (  )  ;", "WarMetaDataProcessor . WebOrdering   webOrdering    =    ordering . ordering ;", "Iterator < String >    after    =    webOrdering . getAfter (  )  . iterator (  )  ;", "while    ( after . hasNext (  )  )     {", "String   name    =    after . next (  )  ;", "Iterator < WarMetaDataProcessor . Ordering >    workIterator 2     =    work . iterator (  )  ;", "boolean   found    =    false ;", "while    ( workIterator 2  . hasNext (  )  )     {", "WarMetaDataProcessor . Ordering   ordering 2     =    workIterator 2  . next (  )  ;", "if    ( name . equals ( ordering 2  . ordering . getName (  )  )  )     {", "if    ( found )     {", "throw   new   IllegalStateException ( UndertowLogger . ROOT _ LOGGER . invalidRelativeOrderingDuplicateName ( webOrdering . getJar (  )  )  )  ;", "}", "ordering . addAfter ( ordering 2  )  ;", "ordering 2  . addBefore ( ordering )  ;", "found    =    true ;", "}", "}", "if    (  ! found )     {", "UndertowLogger . ROOT _ LOGGER . invalidRelativeOrderingUnknownName ( webOrdering . getJar (  )  )  ;", "}", "}", "Iterator < String >    before    =    webOrdering . getBefore (  )  . iterator (  )  ;", "while    ( before . hasNext (  )  )     {", "String   name    =    before . next (  )  ;", "Iterator < WarMetaDataProcessor . Ordering >    workIterator 2     =    work . iterator (  )  ;", "boolean   found    =    false ;", "while    ( workIterator 2  . hasNext (  )  )     {", "WarMetaDataProcessor . Ordering   ordering 2     =    workIterator 2  . next (  )  ;", "if    ( name . equals ( ordering 2  . ordering . getName (  )  )  )     {", "if    ( found )     {", "throw   new   IllegalStateException ( UndertowLogger . ROOT _ LOGGER . invalidRelativeOrderingDuplicateName ( webOrdering . getJar (  )  )  )  ;", "}", "ordering . addBefore ( ordering 2  )  ;", "ordering 2  . addAfter ( ordering )  ;", "found    =    true ;", "}", "}", "if    (  ! found )     {", "UndertowLogger . ROOT _ LOGGER . invalidRelativeOrderingUnknownName ( webOrdering . getJar (  )  )  ;", "}", "}", "}", "workIterator    =    work . iterator (  )  ;", "while    ( workIterator . hasNext (  )  )     {", "workIterator . next (  )  . validate (  )  ;", "}", "List < WarMetaDataProcessor . Ordering >    tempOrder    =    new   ArrayList < WarMetaDataProcessor . Ordering >  (  )  ;", "workIterator    =    work . iterator (  )  ;", "while    ( workIterator . hasNext (  )  )     {", "WarMetaDataProcessor . Ordering   ordering    =    workIterator . next (  )  ;", "if    ( ordering . beforeOthers )     {", "int   insertAfter    =     -  1  ;", "boolean   last    =    ordering . isLastBeforeOthers (  )  ;", "int   lastBeforeOthers    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     ( tempOrder . size (  )  )  ;    i +  +  )     {", "if    ( ordering . isAfter ( tempOrder . get ( i )  )  )     {", "insertAfter    =    i ;", "}", "if    ( tempOrder . get ( i )  . beforeOthers )     {", "lastBeforeOthers    =    i ;", "}", "}", "int   pos    =    insertAfter ;", "if    ( last    &  &     ( lastBeforeOthers    >    insertAfter )  )     {", "pos    =    lastBeforeOthers ;", "}", "tempOrder . add (  ( pos    +     1  )  ,    ordering )  ;", "} else", "if    ( ordering . afterOthers )     {", "int   insertBefore    =    tempOrder . size (  )  ;", "boolean   first    =    ordering . isFirstAfterOthers (  )  ;", "int   firstAfterOthers    =    tempOrder . size (  )  ;", "for    ( int   i    =     ( tempOrder . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    ( ordering . isBefore ( tempOrder . get ( i )  )  )     {", "insertBefore    =    i ;", "}", "if    ( tempOrder . get ( i )  . afterOthers )     {", "firstAfterOthers    =    i ;", "}", "}", "int   pos    =    insertBefore ;", "if    ( first    &  &     ( firstAfterOthers    <    insertBefore )  )     {", "pos    =    firstAfterOthers ;", "}", "tempOrder . add ( pos ,    ordering )  ;", "} else    {", "int   insertAfter    =     -  1  ;", "int   insertBefore    =    tempOrder . size (  )  ;", "for    ( int   i    =     0  ;    i    <     ( tempOrder . size (  )  )  ;    i +  +  )     {", "if    (  ( ordering . isAfter ( tempOrder . get ( i )  )  )     |  |     ( tempOrder . get ( i )  . beforeOthers )  )     {", "insertAfter    =    i ;", "}", "if    (  ( ordering . isBefore ( tempOrder . get ( i )  )  )     |  |     ( tempOrder . get ( i )  . afterOthers )  )     {", "insertBefore    =    i ;", "}", "}", "if    ( insertAfter    >    insertBefore )     {", "throw   new   IllegalStateException ( UndertowLogger . ROOT _ LOGGER . invalidRelativeOrderingConflict ( ordering . ordering . getJar (  )  )  )  ;", "}", "tempOrder . add (  ( insertAfter    +     1  )  ,    ordering )  ;", "}", "}", "Iterator < WarMetaDataProcessor . Ordering >    tempOrderIterator    =    tempOrder . iterator (  )  ;", "while    ( tempOrderIterator . hasNext (  )  )     {", "WarMetaDataProcessor . Ordering   ordering    =    tempOrderIterator . next (  )  ;", "order . add ( ordering . ordering . getJar (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveOrder"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessor"}, {"methodBody": ["METHOD_START", "{", "WarMetaDataProcessor . WebOrdering   o    =    new   WarMetaDataProcessor . WebOrdering (  )  ;", "o . setName ( name )  ;", "o . setJar ( jarName )  ;", "if    (  !  ( Strings . isNullOrEmpty ( after )  )  )     {", "o . addAfter ( after )  ;", "}", "return   o ;", "}", "METHOD_END"], "methodName": ["createWebOrdering"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "return   createWebOrdering (  \" a \"  ,     \" WEB - INF / lib / a . jar \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["createWebOrdering1"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "return   createWebOrdering (  \" b \"  ,     \" WEB - INF / lib / b . jar \"  ,     \" a \"  )  ;", "}", "METHOD_END"], "methodName": ["createWebOrdering2"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "return   createWebOrdering (  \" c \"  ,     \" WEB - INF / lib / c . jar \"  ,     \" b \"  )  ;", "}", "METHOD_END"], "methodName": ["createWebOrdering3"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "List < String >    order    =    new   ArrayList <  >  (  )  ;", ". resolveOrder ( webOrderings ,    order )  ;", "Assert . assertEquals ( EXPECTED _ ORDER ,    order )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "test ( ImmutableList . of ( createWebOrdering 1  (  )  ,    createWebOrdering 2  (  )  ,    createWebOrdering 3  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "test ( ImmutableList . of ( createWebOrdering 1  (  )  ,    createWebOrdering 3  (  )  ,    createWebOrdering 2  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "test ( ImmutableList . of ( createWebOrdering 2  (  )  ,    createWebOrdering 1  (  )  ,    createWebOrdering 3  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test3"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "test ( ImmutableList . of ( createWebOrdering 2  (  )  ,    createWebOrdering 3  (  )  ,    createWebOrdering 1  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test4"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "test ( ImmutableList . of ( createWebOrdering 3  (  )  ,    createWebOrdering 1  (  )  ,    createWebOrdering 2  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test5"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "test ( ImmutableList . of ( createWebOrdering 3  (  )  ,    createWebOrdering 2  (  )  ,    createWebOrdering 1  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test6"], "fileName": "org.wildfly.extension.undertow.deployment.WarMetaDataProcessorTest"}, {"methodBody": ["METHOD_START", "{", "final   List < ResourceRoot >    entries    =    new   ArrayList < ResourceRoot >  (  )  ;", "final   VirtualFile   webinfClasses    =    deploymentRoot . getChild (  . WEB _ INF _ CLASSES )  ;", "if    ( webinfClasses . exists (  )  )     {", "final   ResourceRoot   webInfClassesRoot    =    new   ResourceRoot ( webinfClasses . getName (  )  ,    webinfClasses ,    null )  ;", "ModuleRootMarker . mark ( webInfClassesRoot )  ;", "entries . add ( webInfClassesRoot )  ;", "}", "Map < String ,    MountedDeploymentOverlay >    overlays    =    deploymentUnit . getAttachment ( DEPLOYMENT _ OVERLAY _ LOCATIONS )  ;", "final   VirtualFile   webinfLib    =    deploymentRoot . getChild (  . WEB _ INF _ LIB )  ;", "if    ( webinfLib . exists (  )  )     {", "final   List < VirtualFile >    archives    =    webinfLib . getChildren (  . DEFAULT _ WEB _ INF _ LIB _ FILTER )  ;", "for    ( final   VirtualFile   archive    :    archives )     {", "try    {", "String   relativeName    =    archive . getPathNameRelativeTo ( deploymentRoot )  ;", "MountedDeploymentOverlay   overlay    =    overlays . get ( relativeName )  ;", "Closeable   closable    =    null ;", "if    ( overlay    !  =    null )     {", "overlay . remountAsZip ( false )  ;", "} else", "if    ( archive . isFile (  )  )     {", "closable    =    mountZip ( archive ,    archive ,    provider (  )  )  ;", "} else    {", "closable    =    null ;", "}", "final   ResourceRoot   webInfArchiveRoot    =    new   ResourceRoot ( archive . getName (  )  ,    archive ,    new   MountHandle ( closable )  )  ;", "ModuleRootMarker . mark ( webInfArchiveRoot )  ;", "entries . add ( webInfArchiveRoot )  ;", "}    catch    ( IOException   e )     {", "throw   new   DeploymentUnitProcessingException ( UndertowLogger . ROOT _ LOGGER . failToProcessWebInfLib ( archive )  ,    e )  ;", "}", "}", "}", "return   entries ;", "}", "METHOD_END"], "methodName": ["createResourceRoots"], "fileName": "org.wildfly.extension.undertow.deployment.WarStructureDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   mounts    =    deploymentRoot . getChild ( WarStructureDeploymentProcessor . WEB _ INF _ EXTERNAL _ MOUNTS )  ;", "if    (  !  ( mounts . exists (  )  )  )     {", "return ;", "}", "try    ( InputStream   data    =    mounts . openStream (  )  )     {", "String   contents    =    FileUtils . readFile ( data )  ;", "String [  ]    lines    =    contents . split (  \"  \\ n \"  )  ;", "for    ( String   line    :    lines )     {", "String   trimmed    =    line ;", "int   commentIndex    =    trimmed . indexOf (  \"  #  \"  )  ;", "if    ( commentIndex    >     (  -  1  )  )     {", "trimmed    =    trimmed . substring (  0  ,    commentIndex )  ;", "}", "trimmed    =    trimmed . trim (  )  ;", "if    ( trimmed . isEmpty (  )  )     {", "continue ;", "}", "File   path    =    new   File ( trimmed )  ;", "if    ( path . exists (  )  )     {", "deploymentUnit . addToAttachmentList ( UndertowAttachments . EXTERNAL _ RESOURCES ,    path )  ;", "} else    {", "throw   UndertowLogger . ROOT _ LOGGER . couldNotFindExternalPath ( path )  ;", "}", "}", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["processExternalMounts"], "fileName": "org.wildfly.extension.undertow.deployment.WarStructureDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( index    !  =    null )     {", "Set < ClassInfo >    classInfos    =    index . getAllKnownImplementors (  . ASYNC _ LISTENER _ INTERFACE )  ;", "for    ( ClassInfo   classInfo    :    classInfos )     {", "if    (  (  !  ( Modifier . isAbstract ( classInfo . flags (  )  )  )  )     &  &     (  !  ( Modifier . isInterface ( classInfo . flags (  )  )  )  )  )     {", "classes . add ( classInfo . name (  )  . toString (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["getAllAsyncListenerClasses"], "fileName": "org.wildfly.extension.undertow.deployment.WebComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    classes    =    new   HashSet < String >  (  )  ;", "getAllComponentClasses ( metaData . getMergedJBossWebMetaData (  )  ,    classes )  ;", "if    ( tldsMetaData    =  =    null )", "return   classes ;", "if    (  ( tldsMetaData . getSharedTlds ( Unit )  )     !  =    null )", "for    ( TldMetaData   tldMetaData    :    tldsMetaData . getSharedTlds ( Unit )  )     {", "getAllComponentClasses ( tldMetaData ,    classes )  ;", "}", "if    (  ( tldsMetaData . getTlds (  )  )     !  =    null )", "for    ( Entry < String ,    TldMetaData >    tldMetaData    :    tldsMetaData . getTlds (  )  . entrySet (  )  )     {", "getAllComponentClasses ( tldMetaData . getValue (  )  ,    classes )  ;", "}", "getAllAsyncListenerClasses ( index ,    classes )  ;", "return   classes ;", "}", "METHOD_END"], "methodName": ["getAllComponentClasses"], "fileName": "org.wildfly.extension.undertow.deployment.WebComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( metaData . getServlets (  )  )     !  =    null )", "for    ( jboss . metadata . web . spec . ServletMetaData   servlet    :    metaData . getServlets (  )  )     {", "if    (  ( servlet . getServletClass (  )  )     !  =    null )     {", "classes . add ( servlet . getServletClass (  )  )  ;", "}", "}", "if    (  ( metaData . getFilters (  )  )     !  =    null )", "for    ( jboss . metadata . web . spec . FilterMetaData   filter    :    metaData . getFilters (  )  )     {", "classes . add ( filter . getFilterClass (  )  )  ;", "}", "if    (  ( metaData . getListeners (  )  )     !  =    null )", "for    ( jboss . metadata . web . spec . ListenerMetaData   listener    :    metaData . getListeners (  )  )     {", "classes . add ( listener . getListenerClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAllComponentClasses"], "fileName": "org.wildfly.extension.undertow.deployment.WebComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( metaData . getValidator (  )  )     !  =    null )     {", "classes . add ( metaData . getValidator (  )  . getValidatorClass (  )  )  ;", "}", "if    (  ( metaData . getListeners (  )  )     !  =    null )", "for    ( jboss . metadata . web . spec . ListenerMetaData   listener    :    metaData . getListeners (  )  )     {", "classes . add ( listener . getListenerClass (  )  )  ;", "}", "if    (  ( metaData . getTags (  )  )     !  =    null )", "for    ( jboss . metadata . web . spec . TagMetaData   tag    :    metaData . getTags (  )  )     {", "classes . add ( tag . getTagClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAllComponentClasses"], "fileName": "org.wildfly.extension.undertow.deployment.WebComponentProcessor"}, {"methodBody": ["METHOD_START", "{", "ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "try    {", "Module   filterModule    =    moduleLoader . loadModule ( ModuleIdentifier . fromString ( moduleName )  )  ;", "return   filterModule . getClassLoader (  )  . loadClassLocal ( className )  ;", "}    catch    ( ModuleLoadException    |    ClassNotFoundException   e )     {", "throw   ULogger . ROOT _ LOGGER . couldNotLoadHandlerFromModule ( className ,    moduleName ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getHandlerClass"], "fileName": "org.wildfly.extension.undertow.filters.CustomFilterDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . hasDefined ( CustomFilterDefinition . PARAMETERS . getName (  )  )  )  )     {", "return   Collections . emptyMap (  )  ;", "}", "ModelNode   modelProps    =    model . get ( CustomFilterDefinition . PARAMETERS . getName (  )  )  ;", "Map < String ,    String >    props    =    new   HashMap < String ,    String >  (  )  ;", "for    ( Property   p    :    modelProps . asPropertyList (  )  )     {", "props . put ( p . getName (  )  ,    p . getValue (  )  . asString (  )  )  ;", "}", "return   props ;", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "org.wildfly.extension.undertow.filters.CustomFilterDefinition"}, {"methodBody": ["METHOD_START", "{", "int   numOfParams    =    attributes . size (  )  ;", "if    ( next    !  =    null )     {", "numOfParams +  +  ;", "}", "try    {", "Constructor <  ?  >    c    =    handlerClass . getDeclaredConstructor ( getConstructorSignature (  )  )  ;", "if    (  ( c . getParameterTypes (  )  . length )     =  =    numOfParams )     {", "boolean   match    =    true ;", "Object [  ]    params    =    new   Object [ numOfParams ]  ;", "Class [  ]    parameterTypes    =    c . getParameterTypes (  )  ;", "int   attrCounter    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( parameterTypes . length )  ;    i +  +  )     {", "Class   param    =    parameterTypes [ i ]  ;", "if    ( param    =  =     ( String . class )  )     {", "params [ i ]     =    model . get ( attributes . get ( attrCounter )  . getName (  )  )  . asString (  )  ;", "attrCounter +  +  ;", "} else", "if    (  ( param    =  =     ( Integer . class )  )     |  |     ( param    =  =     ( int . class )  )  )     {", "params [ i ]     =    model . get ( attributes . get ( attrCounter )  . getName (  )  )  . asInt (  )  ;", "attrCounter +  +  ;", "} else", "if    (  ( param    =  =     ( Long . class )  )     |  |     ( param    =  =     ( long . class )  )  )     {", "params [ i ]     =    model . get ( attributes . get ( attrCounter )  . getName (  )  )  . asLong (  )  ;", "attrCounter +  +  ;", "} else", "if    ( param    =  =     ( HttpHandler . class )  )     {", "params [ i ]     =    next ;", "} else    {", "match    =    false ;", "break ;", "}", "}", "if    ( match )     {", "return    (  ( HttpHandler )     ( c . newInstance ( params )  )  )  ;", "}", "}", "}    catch    ( Throwable   e )     {", "throw   ULogger . ROOT _ LOGGER . cannotCreateHttpHandler ( handlerClass ,    model ,    e )  ;", "}", "throw   ULogger . ROOT _ LOGGER . cannotCreateHttpHandler ( handlerClass ,    model ,    null )  ;", "}", "METHOD_END"], "methodName": ["createHandler"], "fileName": "org.wildfly.extension.undertow.filters.Filter"}, {"methodBody": ["METHOD_START", "{", "List < AttributeDefinition >    attributes    =    new   ArrayList ( getAttributes (  )  )  ;", "HttpHandler   handler    =    createHandler ( getHandlerClass (  )  ,    model ,    attributes ,    next )  ;", "if    ( predicate    !  =    null )     {", "return   Handlpredicate ( predicate ,    handler ,    next )  ;", "} else    {", "return   handler ;", "}", "}", "METHOD_END"], "methodName": ["createHttpHandler"], "fileName": "org.wildfly.extension.undertow.filters.Filter"}, {"methodBody": ["METHOD_START", "{", "ModelNode   resolved    =    new   ModelNode (  )  ;", "for    ( AttributeDefinit   attribute    :    attributes )     {", "resolved . get ( attribute . getName (  )  )  . set ( attribute . resolveModelAttribute ( context ,    model )  )  ;", "}", "return   resolved ;", "}", "METHOD_END"], "methodName": ["getResolvedModel"], "fileName": "org.wildfly.extension.undertow.filters.FilterAdd"}, {"methodBody": ["METHOD_START", "{", "return   filter . getValue (  )  . createHttpHandler ( predicate ,    next )  ;", "}", "METHOD_END"], "methodName": ["createHttpHandler"], "fileName": "org.wildfly.extension.undertow.filters.FilterRef"}, {"methodBody": ["METHOD_START", "{", "return   filter ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "org.wildfly.extension.undertow.filters.FilterRef"}, {"methodBody": ["METHOD_START", "{", "return   location ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.wildfly.extension.undertow.filters.FilterRef"}, {"methodBody": ["METHOD_START", "{", "return   predicate ;", "}", "METHOD_END"], "methodName": ["getPredicate"], "fileName": "org.wildfly.extension.undertow.filters.FilterRef"}, {"methodBody": ["METHOD_START", "{", "return   priority ;", "}", "METHOD_END"], "methodName": ["getPriority"], "fileName": "org.wildfly.extension.undertow.filters.FilterRef"}, {"methodBody": ["METHOD_START", "{", "return   handler . createHttpHandler ( predicate ,    model ,    next )  ;", "}", "METHOD_END"], "methodName": ["createHttpHandler"], "fileName": "org.wildfly.extension.undertow.filters.FilterService"}, {"methodBody": ["METHOD_START", "{", "final   ServiceContainer   serviceContainer    =    CurrentServiceContainer . getServiceContainer (  )  ;", "if    ( serviceContainer    =  =    null )     {", "return   null ;", "}", "ServiceController <  ?  >    cluster    =    serviceContainer . getService ( UndertowService . FILTER . append ( name )  )  ;", "if    ( cluster    =  =    null )     {", "return   null ;", "}", "return    (  ( Service )     ( cluster . getService (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["service"], "fileName": "org.wildfly.extension.undertow.filters.ModClusterResource"}, {"methodBody": ["METHOD_START", "{", "return   modCluster ;", "}", "METHOD_END"], "methodName": ["getModCluster"], "fileName": "org.wildfly.extension.undertow.filters.ModClusterService"}, {"methodBody": ["METHOD_START", "{", "String   securityKey    =    null ;", "ModelNode   securityKeyNode    =    ModClusterDefinition . SECURITY _ KEY . resolveModelAttribute ( operationContext ,    model )  ;", "if    ( securityKeyNode . isDefined (  )  )     {", "securityKey    =    securityKeyNode . asString (  )  ;", "}", "String   managementAccessPredicateString    =    null ;", "ModelNode   managementAccessPredicateNode    =    ModClusterDefinition . MANAGEMENT _ ACCESS _ PREDICATE . resolveModelAttribute ( operationContext ,    model )  ;", "if    ( managementAccessPredicateNode . isDefined (  )  )     {", "managementAccessPredicateString    =    managementAccessPredicateNode . asString (  )  ;", "}", "Predicate   managementAccessPredicate    =    null ;", "if    ( managementAccessPredicateString    !  =    null )     {", "managementAccessPredicate    =    PredicateParser . parse ( managementAccessPredicateString ,     . class . getClassLoader (  )  )  ;", "}", "final   ModelNode   sslContext    =    ModClusterDefinition . SSL _ CONTEXT . resolveModelAttribute ( operationContext ,    model )  ;", "final   ModelNode   securityRealm    =    ModClusterDefinition . SECURITY _ REALM . resolveModelAttribute ( operationContext ,    model )  ;", "final   ModelNode   packetSizeNode    =    ModClusterDefinition . MAX _ AJP _ PACKET _ SIZE . resolveModelAttribute ( operationContext ,    model )  ;", "OptionMap . Builder   builder    =    OptionMap . builder (  )  ;", "if    ( packetSizeNode . isDefined (  )  )     {", "builder . set ( MAX _ AJP _ PACKET _ SIZE ,    packetSizeNode . asInt (  )  )  ;", "}", "builder . set ( ENABLE _ HTTP 2  ,    ModClusterDefinition . ENABLE _ HTTP 2  . resolveModelAttribute ( operationContext ,    model )  . asBoolean (  )  )  ;", "ModClusterDefinition . HTTP 2  _ ENABLE _ PUSH . resolveOption ( operationContext ,    model ,    builder )  ;", "ModClusterDefinition . HTTP 2  _ HEADER _ TABLE _ SIZE . resolveOption ( operationContext ,    model ,    builder )  ;", "ModClusterDefinition . HTTP 2  _ INITIAL _ WINDOW _ SIZE . resolveOption ( operationContext ,    model ,    builder )  ;", "ModClusterDefinition . HTTP 2  _ MAX _ CONCURRENT _ STREAMS . resolveOption ( operationContext ,    model ,    builder )  ;", "ModClusterDefinition . HTTP 2  _ MAX _ FRAME _ SIZE . resolveOption ( operationContext ,    model ,    builder )  ;", "ModClusterDefinition . HTTP 2  _ MAX _ HEADER _ LIST _ SIZE . resolveOption ( operationContext ,    model ,    builder )  ;", "service    =    new    ( model ,    ModClusterDefinition . HEALTH _ CHECK _ INTERVAL . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . MAX _ REQUEST _ TIME . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . BROKEN _ NODE _ TIMEOUT . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . ADVERTISE _ FREQUENCY . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . ADVERTISE _ PATH . resolveModelAttribute ( operationContext ,    model )  . asString (  )  ,    ModClusterDefinition . ADVERTISE _ PROTOCOL . resolveModelAttribute ( operationContext ,    model )  . asString (  )  ,    securityKey ,    managementAccessPredicate ,    ModClusterDefinition . CONNECTIONS _ PER _ THREAD . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . CACHED _ CONNECTIONS _ PER _ THREAD . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . CONNECTION _ IDLE _ TIMEOUT . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . REQUEST _ QUEUE _ SIZE . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    ModClusterDefinition . USE _ ALIAS . resolveModelAttribute ( operationContext ,    model )  . asBoolean (  )  ,    ModClusterDefinition . MAX _ RETRIES . resolveModelAttribute ( operationContext ,    model )  . asInt (  )  ,    Enum . valueOf ( FailoverStrategy . class ,    ModClusterDefinition . FAILOVER _ STRATEGY . resolveModelAttribute ( operationContext ,    model )  . asString (  )  )  ,    builder . getMap (  )  )  ;", "final   String   mgmtSocketBindingRef    =    ModClusterDefinition . MANAGEMENT _ SOCKET _ BINDING . resolveModelAttribute ( operationContext ,    model )  . asString (  )  ;", "final   ModelNode   advertiseSocketBindingRef    =    ModClusterDefinition . ADVERTISE _ SOCKET _ BINDING . resolveModelAttribute ( operationContext ,    model )  ;", "final   String   workerRef    =    ModClusterDefinition . WORKER . resolveModelAttribute ( operationContext ,    model )  . asString (  )  ;", "CapabilityServiceBuilder   serviceBuilder    =    serviceTarget . addCapability ( ModClusterDefinition . MOD _ CLUSTER _ FILTER _ CAPABILITY ,    service )  ;", "serviceBuilder . addCapabilityRequirement ( Capabilities . REF _ SOCKET _ BINDING ,    SocketBinding . class ,    service . managementSocketBinding ,    mgmtSocketBindingRef )  ;", "if    ( advertiseSocketBindingRef . isDefined (  )  )     {", "serviceBuilder . addCapabilityRequirement ( Capabilities . REF _ SOCKET _ BINDING ,    SocketBinding . class ,    service . advertiseSocketBinding ,    advertiseSocketBindingRef . asString (  )  )  ;", "}", "serviceBuilder . addCapabilityRequirement ( IO _ WORKER _ CAPABILITY _ NAME ,    XnioWorker . class ,    service . workerInjectedValue ,    workerRef )  ;", "if    ( sslContext . isDefined (  )  )     {", "serviceBuilder . addCapabilityRequirement ( Capabilities . REF _ SSL _ CONTEXT ,    SSLContext . class ,    service . sslContext ,    sslContext . asString (  )  )  ;", "}", "if    ( securityRealm . isDefined (  )  )     {", "ServiceUtil . addDependency ( serviceBuilder ,    service . securityRealm ,    securityRealm . asString (  )  )  ;", "}", "serviceBuilder . addAliases ( UndertowService . FILTER . append ( name )  )  ;", "serviceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["install"], "fileName": "org.wildfly.extension.undertow.filters.ModClusterService"}, {"methodBody": ["METHOD_START", "{", "if    ( redirect )     {", "return   new   RedirectHandler ( expression )  ;", "} else    {", "return   new   ioserver . handlers . SetAttributeHandler ( next ,    ExchangeAttributes . relativePath (  )  ,    ExchangeAttributes . parser ( getClass (  )  . getClassLoader (  )  )  . parse ( expression )  )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.wildfly.extension.undertow.filters.RewriteFilterDefinition"}, {"methodBody": ["METHOD_START", "{", "return   requestControllerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getRequestControllerInjectedValue"], "fileName": "org.wildfly.extension.undertow.handlers.HandlerService"}, {"methodBody": ["METHOD_START", "{", "return   credential ;", "}", "METHOD_END"], "methodName": ["getCredential"], "fileName": "org.wildfly.extension.undertow.security.AccountImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( originalPrincipal )     !  =    null )     {", "return   originalPrincipal ;", "}", "return   principal ;", "}", "METHOD_END"], "methodName": ["getOriginalPrincipal"], "fileName": "org.wildfly.extension.undertow.security.AccountImpl"}, {"methodBody": ["METHOD_START", "{", "this . roles . clear (  )  ;", "roles . addAll ( roles )  ;", "}", "METHOD_END"], "methodName": ["setRoles"], "fileName": "org.wildfly.extension.undertow.security.AccountImpl"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \"  [  \"  )  . append ( httpRequest . getContextPath (  )  )  ;", "sb . append (  \"  : cookies =  \"  )  . append ( Arrays . toString ( httpRequest . getCookies (  )  )  )  . append (  \"  : headers =  \"  )  ;", "Enumer <  ?  >    en    =    httpRequest . getHeaderNames (  )  ;", "while    ( en . hasMoreElements (  )  )     {", "String   headerName    =     (  ( String )     ( en . nextElement (  )  )  )  ;", "sb . append ( headerName )  . append (  \"  =  \"  )  ;", "if    (  !  ( headerName . contains (  \" authoriz \"  )  )  )     {", "sb . append ( httpRequest . getHeader ( headerName )  )  . append (  \"  ,  \"  )  ;", "}", "}", "sb . append (  \"  ]  \"  )  ;", "sb . append (  \"  [ parameters =  \"  )  ;", "Enumer <  ?  >    enparam    =    httpRequest . getParameterNames (  )  ;", "while    ( enparam . hasMoreElements (  )  )     {", "String   paramName    =     (  ( String )     ( enparam . nextElement (  )  )  )  ;", "String [  ]    paramValues    =    httpRequest . getParameterValues ( paramName )  ;", "int   len    =     ( paramValues    !  =    null )     ?    paramValues . length    :     0  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "sb . append ( paramValues [ i ]  )  . append (  \"  :  :  \"  )  ;", "}", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append (  \"  ]  [ attributes =  \"  )  ;", "Enumer <  ?  >    enu    =    httpRequest . getAttributeNames (  )  ;", "while    ( enu . hasMoreElements (  )  )     {", "String   attrName    =     (  ( String )     ( enu . nextElement (  )  )  )  ;", "sb . append ( attrName )  . append (  \"  =  \"  )  ;", "sb . append ( httpRequest . getAttribute ( attrName )  )  . append (  \"  ,  \"  )  ;", "}", "sb . append (  \"  ]  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["deriveUsefulInfo"], "fileName": "org.wildfly.extension.undertow.security.AuditNotificationReceiver"}, {"methodBody": ["METHOD_START", "{", "return   new   AccountImpl ( id )  ;", "}", "METHOD_END"], "methodName": ["getAccount"], "fileName": "org.wildfly.extension.undertow.security.JAASIdentityManagerImpl"}, {"methodBody": ["METHOD_START", "{", "Principal   principal    =    null ;", "Principal   callerPrincipal    =    null ;", "if    ( subject    !  =    null )     {", "Set < Principal >    principals    =    subject . getPrincipals (  )  ;", "if    (  ( principals    !  =    null )     &  &     (  !  ( principals . isEmpty (  )  )  )  )     {", "for    ( Principal   p    :    principals )     {", "if    (  (  !  ( p   instanceof   Group )  )     &  &     ( principal    =  =    null )  )     {", "principal    =    p ;", "}", "if    ( p   instanceof   Group )     {", "Group   g    =    Group . class . cast ( p )  ;", "if    (  ( g . getName (  )  . equals ( CALLER _ PRINCIPAL _ GROUP )  )     &  &     ( callerPrincipal    =  =    null )  )     {", "Enumeration <  ?    ds   Principal >    e    =    g . members (  )  ;", "if    ( e . hasMoreElements (  )  )", "callerPrincipal    =    e . nextElement (  )  ;", "}", "}", "}", "}", "}", "return   callerPrincipal    =  =    null    ?    principal    :    callerPrincipal ;", "}", "METHOD_END"], "methodName": ["getPrincipal"], "fileName": "org.wildfly.extension.undertow.security.JAASIdentityManagerImpl"}, {"methodBody": ["METHOD_START", "{", "final   AuthenticationManager   authenticationManager    =    securityDomainContext . getAuthenticationManager (  )  ;", "final   AuthorizationManager   authorizationManager    =    securityDomainContext . getAuthorizationManager (  )  ;", "final   SecurityContext   sc    =    SecurityActions . getSecurityContext (  )  ;", "Principal   incomingPrincipal    =    account . getOriginalPrincipal (  )  ;", "Subject   subject    =    new   Subject (  )  ;", "try    {", "boolean   isValid    =    authenticationManager . isValid ( incomingPrincipal ,    credential ,    subject )  ;", "if    ( isValid )     {", "UndertowLogger . ROOT _ LOGGER . tracef (  \" User :     % s   is   authenticated \"  ,    incomingPrincipal )  ;", "if    ( sc    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . noSecurityContext (  )  ;", "}", "Principal   userPrincipal    =    getPrincipal ( subject )  ;", "sc . getUtil (  )  . createSubjectInfo ( incomingPrincipal ,    credential ,    subject )  ;", "SecurityContextCallbackHandler   scb    =    new   SecurityContextCallbackHandler ( sc )  ;", "RoleGroup   roles    =    authorizationManager . getSubjectRoles ( subject ,    scb )  ;", "Set < String >    roleSet    =    new   HashSet <  >  (  )  ;", "for    ( Role   role    :    roles . getRoles (  )  )     {", "roleSet . add ( role . getRoleName (  )  )  ;", "}", "return   new   AccountImpl ( userPrincipal ,    roleSet ,    credential ,    account . getOriginalPrincipal (  )  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["verifyCredential"], "fileName": "org.wildfly.extension.undertow.security.JAASIdentityManagerImpl"}, {"methodBody": ["METHOD_START", "{", "final   Set < Principal >    roles    =    new   HashSet <  >  (  )  ;", "for    ( String   role    :    account . getRoles (  )  )     {", "roles . add ( new   SimplePrincipal ( role )  )  ;", "}", "return   roles ;", "}", "METHOD_END"], "methodName": ["getPrincipalRoles"], "fileName": "org.wildfly.extension.undertow.security.JbossAuthorizationManager"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap < String ,    Object >  (  )  ;", "map . put (  \" securityConstraints \"  ,    constraints )  ;", "map . put ( USERDATA _ PERM _ CHECK ,    Boolean . TRUE )  ;", "SecurityContext   sc    =    SecurityActions . getSecurityContext (  )  ;", "AbstractWebHelper   helper    =    null ;", "try    {", "helper    =    SecurityHelperFactory . getWebHelper ( sc )  ;", "}    catch    ( Exception   e )     {", "UndertowLogger . ROOT _ LOGGER . noHelper ( e )  ;", "return   false ;", "}", "Subject   callerSubject    =    sc . getUtil (  )  . getSubject (  )  ;", "if    ( callerSubject    =  =    null )     {", "callerSubject    =    new   Subject (  )  ;", "}", "ArrayList < String >    roles    =    new   ArrayList < String >  (  )  ;", "if    ( account    !  =    null )     {", "roles . addAll ( account . getRoles (  )  )  ;", "}", "boolean   ok    =    helper . hasUserDataPermission ( map ,    request ,    response ,    PolicyContext . getContextID (  )  ,    callerSubject ,    roles )  ;", "if    (  (  ! ok )     &  &     (  ( response . getStatus (  )  )     =  =     ( HttpServletResponse . SC _ OK )  )  )     {", "try    {", "response . sendError ( SC _ FORBIDDEN )  ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "return   ok ;", "}", "METHOD_END"], "methodName": ["hasUserDataPermission"], "fileName": "org.wildfly.extension.undertow.security.JbossAuthorizationManager"}, {"methodBody": ["METHOD_START", "{", "String   uri    =    request . getRelativePath (  )  ;", "if    (  ( uri    =  =    null )     |  |     ( uri . equals (  \"  /  \"  )  )  )     {", "uri    =     \"  \"  ;", "}", "return   uri ;", "}", "METHOD_END"], "methodName": ["requestURI"], "fileName": "org.wildfly.extension.undertow.security.JbossAuthorizationManager"}, {"methodBody": ["METHOD_START", "{", "RunAsIdentityMetaData   identity    =    null ;", "RunAs   old    =    null ;", "SContext   sc    =    SActions . getSContext (  )  ;", "if    ( sc    =  =    null )     {", "context . proceed (  )  ;", "return ;", "}", "try    {", "identity    =    runAsIdentityMetaDataMap . get ( servletInfo . getName (  )  )  ;", "RunAsIdentity   runAsIdentity    =    null ;", "if    ( identity    !  =    null )     {", "UndertowLogger . ROOT _ LOGGER . tracef (  \"  % s ,    runAs :     % s \"  ,    servletInfo . getName (  )  ,    identity )  ;", "runAsIdentity    =    new   RunAsIdentity ( identity . getRoleName (  )  ,    identity . getPrincipalName (  )  ,    identity . getRunAsRoles (  )  )  ;", "}", "old    =    SActions . setRunAsIdentity ( runAsIdentity ,    sc )  ;", "context . proceed (  )  ;", "}    finally    {", "if    ( identity    !  =    null )     {", "SActions . setRunAsIdentity ( old ,    sc )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.wildfly.extension.undertow.security.RunAsLifecycleInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < Void >  (  )     {", "public   Void   run (  )     {", "SecurityContextAssociation . clearSecurityContext (  )  ;", "return   null ;", "}", "}  )  ;", "} else    {", "SecurityContextAssociation . clearSecurityContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["clearSecurityContext"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < SecurityContext >  (  )     {", "@ Override", "public   SecurityContext   run (  )     {", "try    {", "return   SecurityContextFactory . createSecurityContext ( domain )  ;", "}    catch    ( Exception   e )     {", "throw   UndertowLogger . ROOT _ LOGGER . failToCreateSecurityContext ( e )  ;", "}", "}", "}  )  ;", "} else    {", "try    {", "return   SecurityContextFactory . createSecurityContext ( domain )  ;", "}    catch    ( Exception   e )     {", "throw   UndertowLogger . ROOT _ LOGGER . failToCreateSecurityContext ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createSecurityContext"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < RunAs >  (  )     {", "@ Override", "public   RunAs   run (  )     {", "if    ( sc    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . noSecurityContext (  )  ;", "}", "return   sc . getOutgoingRunAs (  )  ;", "}", "}  )  ;", "} else    {", "if    ( sc    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . noSecurityContext (  )  ;", "}", "return   sc . getOutgoingRunAs (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getRunAsIdentity"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < SecurityContext >  (  )     {", "public   SecurityContext   run (  )     {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}  )  ;", "} else    {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSecurityContext"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < Subject >  (  )     {", "public   Subject   run (  )     {", "Subject   subject    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "subject    =    sc . getUtil (  )  . getSubject (  )  ;", "}", "return   subject ;", "}", "}  )  ;", "} else    {", "Subject   subject    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "subject    =    sc . getUtil (  )  . getSubject (  )  ;", "}", "return   subject ;", "}", "}", "METHOD_END"], "methodName": ["getSubject"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < RunAs >  (  )     {", "@ Override", "public   RunAs   run (  )     {", "if    ( sc    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . noSecurityContext (  )  ;", "}", "RunAs   principal    =    sc . getOutgoingRunAs (  )  ;", "sc . setOutgoingRunAs ( null )  ;", "return   principal ;", "}", "}  )  ;", "} else    {", "if    ( sc    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . noSecurityContext (  )  ;", "}", "RunAs   principal    =    sc . getOutgoingRunAs (  )  ;", "sc . setOutgoingRunAs ( null )  ;", "return   principal ;", "}", "}", "METHOD_END"], "methodName": ["popRunAsIdentity"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < RunAs >  (  )     {", "@ Override", "public   RunAs   run (  )     {", "if    ( sc    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . noSecurityContext (  )  ;", "}", "RunAs   old    =    sc . getOutgoingRunAs (  )  ;", "sc . setOutgoingRunAs ( principal )  ;", "return   old ;", "}", "}  )  ;", "} else    {", "if    ( sc    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . noSecurityContext (  )  ;", "}", "RunAs   old    =    sc . getOutgoingRunAs (  )  ;", "sc . setOutgoingRunAs ( principal )  ;", "return   old ;", "}", "}", "METHOD_END"], "methodName": ["setRunAsIdentity"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < Void >  (  )     {", "@ Override", "public   Void   run (  )     {", "SecurityContextAssociation . setSecurityContext ( sc )  ;", "return   null ;", "}", "}  )  ;", "} else    {", "SecurityContextAssociation . setSecurityContext ( sc )  ;", "}", "}", "METHOD_END"], "methodName": ["setSecurityContextOnAssociation"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < Void >  (  )     {", "public   Void   run (  )     {", "SecurityRolesAssociation . setSecurityRoles ( roles )  ;", "return   null ;", "}", "}  )  ;", "} else    {", "SecurityRolesAssociation . setSecurityRoles ( roles )  ;", "}", "}", "METHOD_END"], "methodName": ["setSecurityRoles"], "fileName": "org.wildfly.extension.undertow.security.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "ServletRequestContext   current ;", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "current    =    ServletRequestContext . current (  )  ;", "} else    {", "current    =    AccessController . doPrivileged (  . CURRENT _ CONTEXT )  ;", "}", "if    ( current    =  =    null )     {", "return   null ;", "}", "return   current . getServletRequest (  )  ;", "}", "METHOD_END"], "methodName": ["getActiveRequest"], "fileName": "org.wildfly.extension.undertow.security.SecurityContextAssociationHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerWrapper (  )     {", "@ Override", "public   HttpHandler   wrap ( final   HttpHandler   handler )     {", "return   new   io . undertow . server . handlers . PredicateHandler ( Predicates . or ( REQUEST ,    ASYNC )  ,    new    ( runAsIdentityMetaDataMap ,    handler )  ,    handler )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["wrapper"], "fileName": "org.wildfly.extension.undertow.security.SecurityContextAssociationHandler"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    method    =    context . getMethod (  )  . getBytes ( StandardCharsets . UTF _  8  )  ;", "byte [  ]    digestUri    =    parsedHeader . get ( DIGEST _ URI )  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MessageDigest   digest    =    context . getDigest (  )  ;", "try    {", "digest . update ( method )  ;", "digest . update (  . COLON )  ;", "digest . update ( digestUri )  ;", "return   HexConverter . convertToHexBytes ( digest . digest (  )  )  ;", "}    finally    {", "digest . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createHA2Auth"], "fileName": "org.wildfly.extension.undertow.security.digest.DigestAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "return    ( identityManager )     !  =    null    ?    identityManager    :    securityContext . getIdentityManager (  )  ;", "}", "METHOD_END"], "methodName": ["getIdentityManager"], "fileName": "org.wildfly.extension.undertow.security.digest.DigestAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "DigestAuthenticationMechanism . DigestContext   context    =    exchange . getAttachment ( DigestAuthenticationMechanism . DigestContext . ATTACHMENT _ KEY )  ;", "Map < DigestAuthorizationToken ,    String >    parsedHeader    =    context . getParsedHeader (  )  ;", "Set < DigestAuthorizationToken >    mandatoryTokens    =    new   HashSet ( DigestAuthenticationMechanism . MANDATORY _ REQUEST _ TOKENS )  ;", "if    (  !  ( supportedAlgorithms . contains ( MD 5  )  )  )     {", "mandatoryTokens . add ( ALGORITHM )  ;", "}", "if    (  (  !  ( supportedQops . isEmpty (  )  )  )     &  &     (  !  ( supportedQops . contains ( AUTH )  )  )  )     {", "mandatoryTokens . add ( MESSAGE _ QOP )  ;", "}", "DigestQop   qop    =    null ;", "if    ( parsedHeader . containsKey ( MESSAGE _ QOP )  )     {", "qop    =    DigestQop . forName ( parsedHeader . get ( MESSAGE _ QOP )  )  ;", "if    (  ( qop    =  =    null )     |  |     (  !  ( supportedQops . contains ( qop )  )  )  )     {", "UndertowLogger . REQUEST _ LOGGER . invalidTokenReceived ( MESSAGE _ QOP . getName (  )  ,    parsedHeader . get ( MESSAGE _ QOP )  )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "context . setQop ( qop )  ;", "mandatoryTokens . add ( CNONCE )  ;", "mandatoryTokens . add ( NONCE _ COUNT )  ;", "}", "mandatoryTokens . removeAll ( parsedHeader . keySet (  )  )  ;", "if    (  ( mandatoryTokens . size (  )  )     >     0  )     {", "for    ( DigestAuthorizationToken   currentToken    :    mandatoryTokens )     {", "UndertowLogger . REQUEST _ LOGGER . missingAuthorizationToken ( currentToken . getName (  )  )  ;", "}", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "if    (  !  ( realmName . equals ( parsedHeader . get ( REALM )  )  )  )     {", "UndertowLogger . REQUEST _ LOGGER . invalidTokenReceived ( REALM . getName (  )  ,    parsedHeader . get ( REALM )  )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "if    ( validateDigestUrl )     {", "if    ( parsedHeader . containsKey ( DIGEST _ URI )  )     {", "String   uri    =    parsedHeader . get ( DIGEST _ URI )  ;", "String   requestURI    =    exchange . getRequestURI (  )  ;", "if    (  !  ( exchange . getQueryString (  )  . isEmpty (  )  )  )     {", "requestURI    =     ( requestURI    +     \"  ?  \"  )     +     ( exchange . getQueryString (  )  )  ;", "}", "if    (  !  ( uri . equals ( requestURI )  )  )     {", "requestURI    =    exchange . getRequestURL (  )  ;", "if    (  !  ( exchange . getQueryString (  )  . isEmpty (  )  )  )     {", "requestURI    =     ( requestURI    +     \"  ?  \"  )     +     ( exchange . getQueryString (  )  )  ;", "}", "if    (  !  ( uri . equals ( requestURI )  )  )     {", "exchange . setStatusCode ( BAD _ REQUEST )  ;", "exchange . endExchange (  )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "}", "} else    {", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "}", "if    ( parsedHeader . containsKey ( OPAQUE )  )     {", "if    (  !  ( DigestAuthenticationMechanism . OPAQUE _ VALUE . equals ( parsedHeader . get ( OPAQUE )  )  )  )     {", "UndertowLogger . REQUEST _ LOGGER . invalidTokenReceived ( OPAQUE . getName (  )  ,    parsedHeader . get ( OPAQUE )  )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "}", "DigestAlgorithm   algorithm ;", "if    ( parsedHeader . containsKey ( ALGORITHM )  )     {", "algorithm    =    DigestAlgorithm . forName ( parsedHeader . get ( ALGORITHM )  )  ;", "if    (  ( algorithm    =  =    null )     |  |     (  !  ( supportedAlgorithms . contains ( algorithm )  )  )  )     {", "UndertowLogger . REQUEST _ LOGGER . invalidTokenReceived ( ALGORITHM . getName (  )  ,    parsedHeader . get ( ALGORITHM )  )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "} else    {", "algorithm    =    DigestAlgorithm . MD 5  ;", "}", "try    {", "context . setAlgorithm ( algorithm )  ;", "}    catch    ( NoSuchAlgorithmException   e )     {", "UndertowLogger . REQUEST _ LOGGER . exceptionProcessingRequest ( e )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "final   String   userName    =    parsedHeader . get ( USERNAME )  ;", "final   IdentityManager   identityManager    =    getIdentityManager ( securityContext )  ;", "final   Account   account ;", "if    ( algorithm . isSession (  )  )     {", "throw   new   IllegalStateException (  \" Not   yet   implemented .  \"  )  ;", "} else    {", "final   DigestCredential   credential    =    new   DigestAuthenticationMechanism . DigestCredentialImpl ( context )  ;", "account    =    identityManager . verify ( userName ,    credential )  ;", "}", "if    ( account    =  =    null )     {", "securityContext . authenticationFailed ( UndertowMessages . MESSAGES . authenticationFailed ( userName )  ,    mechanismName )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "if    (  !  ( validateNonceUse ( context ,    parsedHeader ,    exchange )  )  )     {", "context . markStale (  )  ;", "return   AuthenticationMechanismOutcome . NOT _ AUTHENTICATED ;", "}", "securityContext . authenticationComplete ( account ,    mechanismName ,    true )  ;", "return   AuthenticationMechanismOutcome . AUTHENTICATED ;", "}", "METHOD_END"], "methodName": ["handleDigestHeader"], "fileName": "org.wildfly.extension.undertow.security.digest.DigestAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "String   suppliedNonce    =    parsedHeader . get ( NONCE )  ;", "int   nonceCount    =     -  1  ;", "if    ( parsedHeader . containsKey ( NONCE _ COUNT )  )     {", "String   nonceCountHex    =    parsedHeader . get ( NONCE _ COUNT )  ;", "nonceCount    =    Integer . parseInt ( nonceCountHex ,     1  6  )  ;", "}", "context . setNonce ( suppliedNonce )  ;", "return   nonceManager . validateNonce ( suppliedNonce ,    nonceCount ,    exge )  ;", "}", "METHOD_END"], "methodName": ["validateNonceUse"], "fileName": "org.wildfly.extension.undertow.security.digest.DigestAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "String   canonicalURI    =    request . getRequestURI (  )  . substring ( request . getContextPath (  )  . length (  )  )  ;", "if    (  ( canonicalURI    =  =    null )     |  |     ( canonicalURI . equals (  \"  /  \"  )  )  )", "canonicalURI    =     \"  \"  ;", "return   canonicalURI ;", "}", "METHOD_END"], "methodName": ["getCanonicalURI"], "fileName": "org.wildfly.extension.undertow.security.jacc.JACCAuthorizationManager"}, {"methodBody": ["METHOD_START", "{", "if    ( account    =  =    null )     {", "return   new   Principal [  ]  {        }  ;", "}", "Set < String >    roles    =    new   HashSet ( account . getRoles (  )  )  ;", "Map < String ,    Set < String >  >    principalVersusRolesMap    =    deployment . getDeploymentInfo (  )  . getPrincipalVersusRolesMap (  )  ;", "roles . addAll ( principalVersusRolesMap . getOrDefault ( account . getPrincipal (  )  . getName (  )  ,    Collecs . emptySet (  )  )  )  ;", "Principal [  ]    principals    =    new   Principal [ roles . size (  )  ]  ;", "int   index    =     0  ;", "for    ( String   role    :    roles )     {", "principals [  ( index +  +  )  ]     =     (  )     -  >    role ;", "}", "return   principals ;", "}", "METHOD_END"], "methodName": ["getGrantedRoles"], "fileName": "org.wildfly.extension.undertow.security.jacc.JACCAuthorizationManager"}, {"methodBody": ["METHOD_START", "{", "CodeSource   codeSource    =    servletInfo . getServletClass (  )  . getProtectionDomain (  )  . getCodeSource (  )  ;", "ProtectionDomain   domain    =    new   ProtectionDomain ( codeSource ,    null ,    null ,    getGrantedRoles ( account ,    deployment )  )  ;", "return   hasPermission ( domain ,    permission )  ;", "}", "METHOD_END"], "methodName": ["hasPermission"], "fileName": "org.wildfly.extension.undertow.security.jacc.JACCAuthorizationManager"}, {"methodBody": ["METHOD_START", "{", "Policy   policy    =     ( WildFlySecurityManager . isChecking (  )  )     ?    AccessController . doPrivileged (  (  ( PrivilegedAction < Policy >  )     ( Policy :  : getPolicy )  )  )     :    Policy . getPolicy (  )  ;", "return   policy . implies ( domain ,    permission )  ;", "}", "METHOD_END"], "methodName": ["hasPermission"], "fileName": "org.wildfly.extension.undertow.security.jacc.JACCAuthorizationManager"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   WildFlySecurityManager . doUnchecked ( action )  ;", "} else    {", "return   action . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setContextID"], "fileName": "org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerWrapper (  )     {", "@ Override", "public   HttpHandler   wrap ( final   HttpHandler   handler )     {", "return   new   io . undertow . server . handlers . PredicateHandler ( Predicates . or ( REQUEST ,    ASYNC )  ,    new    ( contextId ,    handler )  ,    handler )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["wrapper"], "fileName": "org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler"}, {"methodBody": ["METHOD_START", "{", "int   len    =    str . length ;", "Arrays . sort ( str )  ;", "StringBuer   buf    =    new   StringBuer (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "if    ( i    >     0  )", "buf . append (  \"  ,  \"  )  ;", "buf . append ( str [ i ]  )  ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getCommaSeparatedString"], "fileName": "org.wildfly.extension.undertow.security.jacc.WarJACCService"}, {"methodBody": ["METHOD_START", "{", "int   type    =    WarJACCService . EXACT ;", "if    ( urlPattern . startsWith (  \"  *  .  \"  )  )", "type    =    WarJACCService . EXTENSION ;", "else", "if    (  ( urlPattern . startsWith (  \"  /  \"  )  )     &  &     ( urlPattern . endsWith (  \"  /  *  \"  )  )  )", "type    =    WarJACCService . PREFIX ;", "else", "if    ( urlPattern . equals (  \"  /  \"  )  )", "type    =    WarJACCService . DEFAULT ;", "return   type ;", "}", "METHOD_END"], "methodName": ["getPatternType"], "fileName": "org.wildfly.extension.undertow.security.jacc.WarJACCService"}, {"methodBody": ["METHOD_START", "{", "ArrayList < WarJACCService . PatternInfo >    prefixList    =    new   ArrayList < WarJACCService . PatternInfo >  (  )  ;", "ArrayList < WarJACCService . PatternInfo >    extensionList    =    new   ArrayList < WarJACCService . PatternInfo >  (  )  ;", "ArrayList < WarJACCService . PatternInfo >    exactList    =    new   ArrayList < WarJACCService . PatternInfo >  (  )  ;", "HashMap < String ,    WarJACCService . PatternInfo >    patternMap    =    new   HashMap < String ,    WarJACCService . PatternInfo >  (  )  ;", "WarJACCService . PatternInfo   defaultInfo    =    null ;", "List < SecurityConstraintMetaData >    constraints    =    metaData . getSecurityConstraints (  )  ;", "if    ( constraints    !  =    null )     {", "for    ( SecurityConstraintMetaData   constraint    :    constraints )     {", "WebResourceCollectionsMetaData   resourceCollectionsMetaData    =    constraint . getResourceCollections (  )  ;", "if    ( resourceCollectionsMetaData    !  =    null )     {", "for    ( WebResourceCollectionMetaData   resourceCollectionMetaData    :    resourceCollectionsMetaData )     {", "List < String >    urlPatterns    =    resourceCollectionMetaData . getUrlPatterns (  )  ;", "for    ( String   url    :    urlPatterns )     {", "int   type    =    WarJACCService . getPatternType ( url )  ;", "WarJACCService . PatternInfo   info    =    patternMap . get ( url )  ;", "if    ( info    =  =    null )     {", "info    =    new   WarJACCService . PatternInfo ( url ,    type )  ;", "patternMap . put ( url ,    info )  ;", "switch    ( type )     {", "case   WarJACCService . PREFIX    :", "prefixList . add ( info )  ;", "break ;", "case   WarJACCService . EXTENSION    :", "extensionList . add ( info )  ;", "break ;", "case   WarJACCService . EXACT    :", "exactList . add ( info )  ;", "break ;", "case   WarJACCService . DEFAULT    :", "defaultInfo    =    info ;", "break ;", "}", "}", "}", "}", "}", "}", "}", "JBossServletsMetaData   servlets    =    metaData . getServlets (  )  ;", "List < ServletMappingMetaData >    mappings    =    metaData . getServletMappings (  )  ;", "if    (  (  (  !  ( metaData . isMetadataComplete (  )  )  )     &  &     ( servlets    !  =    null )  )     &  &     ( mappings    !  =    null )  )     {", "Map < String ,    List < String >  >    servletMappingMap    =    new   HashMap <  >  (  )  ;", "for    ( ServletMappingMetaData   mapping    :    mappings )     {", "List < String >    list    =    servletMappingMap . get ( mapping . getServletName (  )  )  ;", "if    ( list    =  =    null )     {", "servletMappingMap . put ( mapping . getServletName (  )  ,     ( list    =    new   ArrayList <  >  (  )  )  )  ;", "}", "list . addAll ( mapping . getUrlPatterns (  )  )  ;", "}", "for    ( JBossServletMetaData   servlet    :    servlets )     {", "ServletSecurityMetaData   security    =    servlet . getServletSecurity (  )  ;", "if    ( security    !  =    null )     {", "List < String >    servletMappings    =    servletMappingMap . get ( servlet . getServletName (  )  )  ;", "if    ( servletMappings    !  =    null )     {", "for    ( String   url    :    servletMappings )     {", "int   type    =    WarJACCService . getPatternType ( url )  ;", "WarJACCService . PatternInfo   info    =    patternMap . get ( url )  ;", "if    ( info    =  =    null )     {", "info    =    new   WarJACCService . PatternInfo ( url ,    type )  ;", "patternMap . put ( url ,    info )  ;", "switch    ( type )     {", "case   WarJACCService . PREFIX    :", "prefixList . add ( info )  ;", "break ;", "case   WarJACCService . EXTENSION    :", "extensionList . add ( info )  ;", "break ;", "case   WarJACCService . EXACT    :", "exactList . add ( info )  ;", "break ;", "case   WarJACCService . DEFAULT    :", "defaultInfo    =    info ;", "break ;", "}", "}", "}", "}", "}", "}", "}", "for    ( int   i    =     0  ;    i    <     ( prefixList . size (  )  )  ;    i +  +  )     {", "WarJACCService . PatternInfo   info    =    prefixList . get ( i )  ;", "for    ( int   j    =     0  ;    j    <     ( prefixList . size (  )  )  ;    j +  +  )     {", "if    ( i    =  =    j )", "continue ;", "WarJACCService . PatternInfo   other    =    prefixList . get ( j )  ;", "if    ( info . matches ( other )  )", "info . addQualifier ( other )  ;", "}", "for    ( WarJACCService . PatternInfo   other    :    exactList )     {", "if    ( info . matches ( other )  )", "info . addQualifier ( other )  ;", "}", "}", "for    ( WarJACCService . PatternInfo   info    :    extensionList )     {", "for    ( WarJACCService . PatternInfo   other    :    prefixList )     {", "info . addQualifier ( other )  ;", "}", "for    ( WarJACCService . PatternInfo   other    :    exactList )     {", "if    ( info . isExtensionFor ( other )  )", "info . addQualifier ( other )  ;", "}", "}", "if    ( defaultInfo    =  =    null )     {", "defaultInfo    =    new   WarJACCService . PatternInfo (  \"  /  \"  ,    WarJACCService . DEFAULT )  ;", "patternMap . put (  \"  /  \"  ,    defaultInfo )  ;", "}", "for    ( WarJACCService . PatternInfo   info    :    patternMap . values (  )  )     {", "if    ( info    =  =    defaultInfo )", "continue ;", "defaultInfo . addQualifier ( info )  ;", "}", "return   patternMap ;", "}", "METHOD_END"], "methodName": ["qualifyURLPatterns"], "fileName": "org.wildfly.extension.undertow.security.jacc.WarJACCService"}, {"methodBody": ["METHOD_START", "{", "ServletRequest   servletRequest    =    attachment . getServletRequest (  )  ;", "return    (  ( servletRequest . getServletContext (  )  . getVirtualServerName (  )  )     +     \"     \"  )     +     ( servletRequest . getServletContext (  )  . getContextPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildApplicationIdentifier"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "if    ( jbossSct    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . nullParamter (  \" jbossSecurityContext \"  )  ;", "}", "Principal   userPrincipal    =    jbossSct . getUtil (  )  . getUserPrincipal (  )  ;", "if    ( userPrincipal    =  =    null )     {", "return   null ;", "}", "if    (  ( cachedAccount    !  =    null )     &  &     (  ( cachedAccount . getPrincipal (  )  )     =  =    userPrincipal )  )     {", "jbossSct . getUtil (  )  . createSubjectInfo ( userPrincipal ,     (  ( AccountImpl )     ( cachedAccount )  )  . getCredential (  )  ,    jbossSct . getUtil (  )  . getSubject (  )  )  ;", "RoleGroup   roleGroup    =    new   SimpleRoleGroup ( SecurityConstants . ROLES _ IDENTIFIER )  ;", "for    ( String   role    :    cachedAccount . getRoles (  )  )", "roleGroup . addRole ( new   SimpleRole ( role )  )  ;", "jbossSct . getUtil (  )  . setRoles ( roleGroup )  ;", "return   cachedAccount ;", "}", "Set < String >    stringRoles    =    new   HashSet < String >  (  )  ;", "RoleGroup   roleGroup    =    jbossSct . getUtil (  )  . getRoles (  )  ;", "if    ( roleGroup    !  =    null )     {", "for    ( Role   role    :    roleGroup . getRoles (  )  )     {", "stringRoles . add ( role . getRoleName (  )  )  ;", "}", "}", "Object   credential    =    jbossSct . getUtil (  )  . getCredential (  )  ;", "Principal   original    =    null ;", "if    ( cachedAccount    !  =    null )     {", "original    =    cachedAccount . getPrincipal (  )  ;", "}", "return   new   AccountImpl ( userPrincipal ,    stringRoles ,    credential ,    original )  ;", "}", "METHOD_END"], "methodName": ["createAccount"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "return   new   JASPIServerAuthenticationManager ( this . securityDomain ,    new   JBossCallbackHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["createJASPIAuthenticationManager"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "ServletRequestContext   servletRequestContext    =    exchange . getAttachment ( ATTACHMENT _ KEY )  ;", "GenericMessageInfo   messageInfo    =    new   GenericMessageInfo (  )  ;", "messageInfo . setRequestMessage ( servletRequestContext . getServletRequest (  )  )  ;", "messageInfo . setResponseMessage ( servletRequestContext . getServletResponse (  )  )  ;", "messageInfo . getMap (  )  . put (  \" isMandatory \"  ,    isMandatory ( servletRequestContext )  . toString (  )  )  ;", "messageInfo . getMap (  )  . put (  . SECURITY _ CONTEXT _ ATTACHMENT _ KEY ,    securityContext )  ;", "messageInfo . getMap (  )  . put (  . HTTP _ SERVER _ EXCHANGE _ ATTACHMENT _ KEY ,    exchange )  ;", "return   messageInfo ;", "}", "METHOD_END"], "methodName": ["createMessageInfo"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "return    (  ( attachment . getExchange (  )  . getSecurityContext (  )  )     !  =    null )     &  &     ( attachment . getExchange (  )  . getSecurityContext (  )  . isAuthenticationRequired (  )  )  ;", "}", "METHOD_END"], "methodName": ["isMandatory"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "return    ( exchange . getResponseCode (  )  )     !  =     ( StatusCodes . OK )  ;", "}", "METHOD_END"], "methodName": ["statusIndicatesError"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "if    ( jbossSct    =  =    null )     {", "throw   UndertowLogger . ROOT _ LOGGER . nullParamter (  \" jbossSecurityContext \"  )  ;", "}", "RoleGroup   contextRoleGroup    =    jbossSct . getUtil (  )  . getRoles (  )  ;", "if    ( contextRoleGroup    =  =    null )     {", "return ;", "}", "Collection < Role >    contextRoles    =    contextRoleGroup . getRoles (  )  ;", "if    ( contextRoles . isEmpty (  )  )     {", "return ;", "}", "Subject   subject    =    jbossSct . getUtil (  )  . getSubject (  )  ;", "Set < Group >    groupPrincipals    =    subject . getPrincipals ( Group . class )  ;", "Group   subjectRoleGroup    =    null ;", "for    ( Group   candidate    :    groupPrincipals )     {", "if    ( candidate . getName (  )  . equals ( SecurityConstants . ROLES _ IDENTIFIER )  )     {", "subjectRoleGroup    =    candidate ;", "break ;", "}", "}", "if    ( subjectRoleGroup    =  =    null )     {", "subjectRoleGroup    =    new   jbossSimpleGroup ( SecurityConstants . ROLES _ IDENTIFIER )  ;", "subject . getPrincipals (  )  . add ( subjectRoleGroup )  ;", "}", "for    ( Role   role    :    contextRoles )     {", "Principal   rolePrincipal    =    new   jbossSimplePrincipal ( role . getRoleName (  )  )  ;", "subjectRoleGroup . addMember ( rolePrincipal )  ;", "}", "}", "METHOD_END"], "methodName": ["updateSubjectRoles"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "return    ( exchange . getAttachment ( UndertowSecurityAttachments . SECURITY _ CONTEXT _ ATTACHMENT )  . getData (  )  . get ( AuthException . class . getName (  )  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["wasAuthExceptionThrown"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICAuthenticationMechanism"}, {"methodBody": ["METHOD_START", "{", "return   cbh ;", "}", "METHOD_END"], "methodName": ["getCbh"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICContext"}, {"methodBody": ["METHOD_START", "{", "return   messageInfo ;", "}", "METHOD_END"], "methodName": ["getMessageInfo"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICContext"}, {"methodBody": ["METHOD_START", "{", "return   sam ;", "}", "METHOD_END"], "methodName": ["getSam"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICContext"}, {"methodBody": ["METHOD_START", "{", "final   ServletRequestContext   requestContext    =    exchange . getAttachment ( ATTACHMENT _ KEY )  ;", "ServletRequest   servletRequest    =    requestContext . getServletRequest (  )  ;", "return    (  ( servletRequest . getServletContext (  )  . getVirtualServerName (  )  )     +     \"     \"  )     +     ( servletRequest . getServletContext (  )  . getContextPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildAppContext"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICSecurityContext"}, {"methodBody": ["METHOD_START", "{", "ServletRequestContext   servletRequestContext    =    exchange . getAttachment ( ATTACHMENT _ KEY )  ;", "GenericMessageInfo   messageInfo    =    new   GenericMessageInfo (  )  ;", "messageInfo . setRequestMessage ( servletRequestContext . getServletRequest (  )  )  ;", "messageInfo . setResponseMessage ( servletRequestContext . getServletResponse (  )  )  ;", "messageInfo . getMap (  )  . put (  \" isMandatory \"  ,     \" true \"  )  ;", "return   messageInfo ;", "}", "METHOD_END"], "methodName": ["buildMessageInfo"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICSecurityContext"}, {"methodBody": ["METHOD_START", "{", "Subject   subject    =    null ;", "picketBoxContext    =    SecurityActions . get (  )  ;", "if    (  ( picketBoxContext    !  =    null )     &  &     (  ( picketBoxContext . getSubjectInfo (  )  )     !  =    null )  )", "subject    =    picketBoxContext . getSubjectInfo (  )  . getAuthenticatedSubject (  )  ;", "return   subject    !  =    null    ?    subject    :    new   Subject (  )  ;", "}", "METHOD_END"], "methodName": ["getAuthenticatedSubject"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICSecurityContext"}, {"methodBody": ["METHOD_START", "{", "this . cachedAuthenticatedAccount    =    account ;", "}", "METHOD_END"], "methodName": ["setCachedAuthenticatedAccount"], "fileName": "org.wildfly.extension.undertow.security.jaspi.JASPICSecurityContext"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   WildFlySecurityManager . doUnchecked ( new   PrivilegedAction < SecurityContext >  (  )     {", "@ Override", "public   SecurityContext   run (  )     {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}  )  ;", "} else    {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSecurityContext"], "fileName": "org.wildfly.extension.undertow.security.jaspi.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "String   encodedSessionId    =     \" route \"  ;", "String   d    =     \"  ;", "when ( this . codec . encode ( d )  )  . thenReturn ( encodedSessionId )  ;", "this . subject . clearSession ( exchange ,    d )  ;", "verify ( this . config )  . clearSession ( exchange ,    encodedSessionId )  ;", "}", "METHOD_END"], "methodName": ["clearSession"], "fileName": "org.wildfly.extension.undertow.session.CodecSessionConfigTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "when ( this . config . findSessionId ( exchange )  )  . thenReturn ( null )  ;", "String   result    =    this . subject . findSessionId ( exchange )  ;", "assertNull ( result )  ;", "String   encodedSessionId    =     \" route 1  \"  ;", "String   d    =     \"  ;", "when ( this . config . findSessionId ( exchange )  )  . thenReturn ( encodedSessionId )  ;", "when ( this . codec . decode ( encodedSessionId )  )  . thenReturn ( d )  ;", "when ( this . codec . encode ( d )  )  . thenReturn ( encodedSessionId )  ;", "result    =    this . subject . findSessionId ( exchange )  ;", "assertSame ( d ,    result )  ;", "verify ( this . config ,    never (  )  )  . setSessionId ( same ( exchange )  ,    anyString (  )  )  ;", "String   reencodedSessionId    =     \" route 2  \"  ;", "when ( this . codec . encode ( d )  )  . thenReturn ( reencodedSessionId )  ;", "result    =    this . subject . findSessionId ( exchange )  ;", "assertSame ( d ,    result )  ;", "verify ( this . config )  . setSessionId ( exchange ,    reencodedSessionId )  ;", "}", "METHOD_END"], "methodName": ["findSessionId"], "fileName": "org.wildfly.extension.undertow.session.CodecSessionConfigTestCase"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / test \"  ;", "String   encodedUrl    =     \" http :  /  / test /  ;", "String   encodedSessionId    =     \" route \"  ;", "String   d    =     \"  ;", "when ( this . codec . encode ( d )  )  . thenReturn ( encodedSessionId )  ;", "when ( this . config . rewriteUrl ( url ,    encodedSessionId )  )  . thenReturn ( encodedUrl )  ;", "String   result    =    this . subject . rewriteUrl ( url ,    d )  ;", "assertSame ( encodedUrl ,    result )  ;", "}", "METHOD_END"], "methodName": ["rewriteUrl"], "fileName": "org.wildfly.extension.undertow.session.CodecSessionConfigTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", ". SessionCookieSource   expected    =    SessionCookieSource . OTHER ;", "when ( this . config . sessionCookieSource ( exchange )  )  . thenReturn ( expected )  ;", ". SessionCookieSource   result    =    this . subject . sessionCookieSource ( exchange )  ;", "assertSame ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["sessionCookieSource"], "fileName": "org.wildfly.extension.undertow.session.CodecSessionConfigTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpServerExchange   exchange    =    new   HttpServerExchange ( null )  ;", "String   encodedSessionId    =     \" route \"  ;", "String   d    =     \"  ;", "when ( this . codec . encode ( d )  )  . thenReturn ( encodedSessionId )  ;", "this . subject . setSessionId ( exchange ,    d )  ;", "verify ( this . config )  . setSessionId ( exchange ,    encodedSessionId )  ;", "}", "METHOD_END"], "methodName": ["setSessionId"], "fileName": "org.wildfly.extension.undertow.session.CodecSessionConfigTestCase"}, {"methodBody": ["METHOD_START", "{", "return   ROOT _ LOGGER . unexpectedEndOfDocument ( location )  ;", "}", "METHOD_END"], "methodName": ["endOfDocument"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionConfigParser_1_0"}, {"methodBody": ["METHOD_START", "{", "return   propertyReplacer . replaceProperties ( reader . getElementText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getElementText"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionConfigParser_1_0"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "if    ( count    !  =     0  )     {", "throw   ParseUtils . unexpectedAttribute ( reader ,     0  )  ;", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final    . Element   element    =     . Element . of ( reader . getName (  )  )  ;", "switch    ( element )     {", "case   MAX _ ACTIVE _ SESSIONS    :", "final   String   value    =     . getElementText ( reader ,    propertyReplacer )  ;", "result . setMaxActiveSessions ( Integer . parseInt ( value )  )  ;", "break ;", "case   REPLICATION _ CONFIG    :", "result . setReplicationConfig ( ReplicationConfigParser . parse ( reader ,    propertyReplacer )  )  ;", "break ;", "case   SESSION _ CONFIG    :", "result . setSessionConfig ( SessionConfigMetaDataParser . parse ( reader ,    propertyReplacer )  )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "throw    . endOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionConfigParser_1_0"}, {"methodBody": ["METHOD_START", "{", "return   maxActiveSessions ;", "}", "METHOD_END"], "methodName": ["getMaxActiveSessions"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionManagerConfig"}, {"methodBody": ["METHOD_START", "{", "return   replicationConfig ;", "}", "METHOD_END"], "methodName": ["getReplicationConfig"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionManagerConfig"}, {"methodBody": ["METHOD_START", "{", "return   sessionConfig ;", "}", "METHOD_END"], "methodName": ["getSessionConfig"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionManagerConfig"}, {"methodBody": ["METHOD_START", "{", "this . maxActiveSessions    =    maxActiveSessions ;", "}", "METHOD_END"], "methodName": ["setMaxActiveSessions"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionManagerConfig"}, {"methodBody": ["METHOD_START", "{", "this . replicationConfig    =    replicationConfig ;", "}", "METHOD_END"], "methodName": ["setReplicationConfig"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionManagerConfig"}, {"methodBody": ["METHOD_START", "{", "this . sessionConfig    =    sessionConfig ;", "}", "METHOD_END"], "methodName": ["setSessionConfig"], "fileName": "org.wildfly.extension.undertow.session.SharedSessionManagerConfig"}]