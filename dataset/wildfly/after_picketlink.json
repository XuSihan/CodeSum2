[{"methodBody": ["METHOD_START", "{", "this . attributes . add ( attribute )  ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "addAttributeDefinition ( this . modelElement ,    definition )  ;", "resourceRegistration . registerReadWriteAttribute ( definition ,    null ,    writeHandler )  ;", "}", "METHOD_END"], "methodName": ["addAttributeDefinition"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "List < SimpleAttributeDefinition >    resourceAttributes    =    AbstractResourceDefinition . attributeDefinitions . get ( resourceDefinitionKey )  ;", "if    ( resourceAttributes    =  =    null )     {", "resourceAttributes    =    new   ArrayList < SimpleAttributeDefinition >  (  )  ;", "AbstractResourceDefinition . attributeDefinitions . put ( resourceDefinitionKey ,    resourceAttributes )  ;", "}", "if    (  !  ( resourceAttributes . contains ( attribute )  )  )     {", "resourceAttributes . add ( attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["addAttributeDefinition"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "addChildResourceDefinition ( this . modelElement ,    definition )  ;", "resourceRegistration . registerSubModel ( definition )  ;", "}", "METHOD_END"], "methodName": ["addChildResourceDefinition"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "List < ResourceDefinition >    childResources    =    AbstractResourceDefinition . childResourceDefinitions . get ( resourceDefinitionKey )  ;", "if    ( childResources    =  =    null )     {", "childResources    =    new   ArrayList < ResourceDefinition >  (  )  ;", "AbstractResourceDefinition . childResourceDefinitions . put ( resourceDefinitionKey ,    childResources )  ;", "}", "if    (  !  ( childResources . contains ( resourceDefinitionKey )  )  )     {", "for    ( ResourceDefinition   childResource    :    childResources )     {", "if    ( childResource . getPathElement (  )  . getKey (  )  . equals ( resourceDefinition . getPathElement (  )  . getKey (  )  )  )     {", "return ;", "}", "}", "childResources . add ( resourceDefinition )  ;", "}", "}", "METHOD_END"], "methodName": ["addChildResourceDefinition"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . alternativeAttributes ;", "}", "METHOD_END"], "methodName": ["getAlternativesAttributes"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "List < SimpleAttributeDefinition >    definitions    =    AbstractResourceDefinition . attributeDefinitions . get ( modelElement )  ;", "if    ( definitions    =  =    null )     {", "return   Collections . emptyList (  )  ;", "}", "return   definitions ;", "}", "METHOD_END"], "methodName": ["getAttributeDefinition"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . attributes )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( AbstractResourceDefinition . childResourceDefinitions )  ;", "}", "METHOD_END"], "methodName": ["getChildResourceDefinitions"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "Collections . addAll ( this . attributes ,    attributes )  ;", "for    ( SimpleAttribut   attribute    :    getAttributes (  )  )     {", "boolean   hasAlternatives    =     (  ( attribute . getAlternatives (  )  )     !  =    null )     &  &     (  ( attribute . getAlternatives (  )  . length )     >     0  )  ;", "if    ( hasAlternatives )     {", "alternativeAttributes . add ( attribute )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initializeAttributes"], "fileName": "org.wildfly.extension.picketlink.common.model.AbstractResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   ModelElement . modelElements . get ( name )  ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.wildfly.extension.picketlink.common.model.ModelElement"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.picketlink.common.model.ModelElement"}, {"methodBody": ["METHOD_START", "{", "return   XMLElement . xmlElements . get ( name )  ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.wildfly.extension.picketlink.common.model.XMLElement"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.picketlink.common.model.XMLElement"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( AttributeDefinition   a    :    this . attributes )     {", "if    (  ( builder . length (  )  )     >     0  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "builder . append ( a . getName (  )  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.wildfly.extension.picketlink.common.model.validator.AlternativeAttributeValidationStepHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   elementNode    =    context . readResource ( EMPTY _ ADDRESS ,    false )  . getModel (  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  ;", "ModelNode   definedAttribute    =    null ;", "for    ( AttributeDefinition   attribute    :    this . attributes )     {", "if    ( elementNode . hasDefined ( attribute . getName (  )  )  )     {", "if    ( definedAttribute    !  =    null )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . invalidOccurrence ( attribute . getName (  )  ,    address . getLastElement (  )  . toString (  )  ,    getAttributeNames (  )  )  ;", "}", "definedAttribute    =    attribute . resolveModelAttribute ( context ,    elementNode )  ;", "}", "}", "if    (  ( this . required )     &  &     ( definedAttribute    =  =    null )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . requireds ( address . getLastElement (  )  . toString (  )  ,    getAttributeNames (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateAlternatives"], "fileName": "org.wildfly.extension.picketlink.common.model.validator.AlternativeAttributeValidationStepHandler"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  ;", "PathAddress   parentAddress    =    Util . getParentAddressByKey ( address ,    this . parentElement . getName (  )  )  ;", "Set < String >    elements    =    context . readResourceFromRoot ( parentAddress ,    false )  . getChildrenNames ( this . element . getName (  )  )  ;", "if    (  ( elements . size (  )  )     >     ( this . maxOccurs )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . invalidChildType ( parentAddress . getLastElement (  )  . toString (  )  ,    this . maxOccurs ,    this . element . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateOccurrence"], "fileName": "org.wildfly.extension.picketlink.common.model.validator.ElementMaxOccurrenceValidationStepHandler"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    context . readResource ( EMPTY _ ADDRESS )  ;", "PathAddress   pathAddress    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  ;", "if    ( resource . getChildTypes (  )  . isEmpty (  )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . e ( pathAddress . getLastElement (  )  . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateChildren"], "fileName": "org.wildfly.extension.picketlink.common.model.validator.NotEmptyResourceValidationStepHandler"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    context . readResource ( EMPTY _ ADDRESS )  ;", "PathAddress   pathAddress    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  ;", "Set < ResourceEntry >    children    =    resource . getChildren ( this . childElement . getName (  )  )  ;", "if    ( children . isEmpty (  )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . r ( pathAddress . getLastElement (  )  . toString (  )  ,    this . childElement . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateRequiredChild"], "fileName": "org.wildfly.extension.picketlink.common.model.validator.RequiredChildValidationStepHandler"}, {"methodBody": ["METHOD_START", "{", "PathAddress   pathAddress    =    context . getCurrentAddress (  )  ;", "String   elementName    =    context . getCurrentAddressValue (  )  ;", "ModelNode   typeNode    =    context . readResource ( EMPTY _ ADDRESS ,    false )  . getModel (  )  ;", "String   type    =    getType ( context ,    typeNode )  ;", "PathAddress   parentAddress    =    pathAddress . getParent (  )  ;", "Set < Resource . ResourceEntry >    children    =    context . readResourceFromRoot ( parentAddress ,    true )  . getChildren ( this . element . getName (  )  )  ;", "for    ( Resource . ResourceEntry   child    :    children )     {", "String   existingResourceName    =    child . getName (  )  ;", "String   existingType    =    getType ( context ,    child . getModel (  )  )  ;", "if    (  (  !  ( elementName . equals ( existingResourceName )  )  )     &  &     ( type . equals ( existingType )  )  )     {", "throw   PLinkLogger . ROOT _ LOGGER . typeAlreadyDefined ( type )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateType"], "fileName": "org.wildfly.extension.picketlink.common.model.validator.UniqueTypeValidationStepHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . register . get ( writerKey )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.wildfly.extension.picketlink.common.parser.ModelXMLElementWriter"}, {"methodBody": ["METHOD_START", "{", "String   nodeName    =    modelNode . asProperty (  )  . getName (  )  ;", "if    ( nodeName . equals ( this . model . getName (  )  )  )     {", "List < ModelNode >    modelNodes    =    modelNode . asProperty (  )  . getValue (  )  . asList (  )  ;", "boolean   writeParrent    =     (  ( this . parent )     !  =    null )     &  &     (  !  ( modelNodes . isEmpty (  )  )  )  ;", "if    ( writeParrent )     {", "writer . writeStart ( this . parent . getName (  )  )  ;", "}", "for    ( ModelNode   valueNode    :    modelNodes )     {", "writer . writeStart ( this . model . getName (  )  )  ;", "if    (  ( this . nameAttribute )     !  =    null )     {", "writer . writeAttribute ( this . nameAttribute ,    valueNode . keys (  )  . iterator (  )  . next (  )  )  ;", "}", "ModelNode   value    =    valueNode . asProperty (  )  . getValue (  )  ;", "if    ( value . isDefined (  )  )     {", "writeAttributes ( writer ,    value )  ;", "for    ( ModelNode   propertyIdentity    :    value . asList (  )  )     {", "List < ResourceDefinition >    children    =    AbstractResourceDefinition . getChildResourceDefinitions (  )  . get ( this . model )  ;", "if    ( children    !  =    null )     {", "for    ( ResourceDefinition   child    :    children )     {", "get ( child . getPath (  )  . getKey (  )  )  . write ( writer ,    propertyIdentity )  ;", "}", "}", "}", "}", "writer . writeEnd (  )  ;", "}", "if    ( writeParrent )     {", "writer . writeEnd (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.wildfly.extension.picketlink.common.parser.ModelXMLElementWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( SimpleAttributeDefinition   simpleAttributeDefinition    :    AbstractResourceDefinition . getAttributeDefinition ( this . modelElement )  )     {", "simpleAttributeDefinition . marshallAsAttribute ( modelNode ,    writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.wildfly.extension.picketlink.common.parser.ModelXMLElementWriter"}, {"methodBody": ["METHOD_START", "{", "return   new   DeprecatedResourceDescriptionResolver ( FederationExtension . SUBSYSTEM _ NAME ,    keyPrefix ,    FederationExtension . RESOURCE _ NAME ,    FederationExtension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.wildfly.extension.picketlink.federation.FederationExtension"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", "ResourceTransformationDescriptionBuilder   TransfDescBuilder    =    builder . addChildResource ( new   FederationResourceDefinition ( context )  )  ;", "ResourceTransformationDescriptionBuilder   keyStoreTransfDescBuilder    =    TransfDescBuilder . addChildResource ( KeyStoreProviderResourceDefinition . INSTANCE )  ;", "keyStoreTransfDescBuilder . rejectChildResource ( KeyResourceDefinition . INSTANCE . getPathElement (  )  )  ;", "Tools . register ( builder . build (  )  ,    subsystemRegistration ,    ModelVersion . create (  1  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_1_0"], "fileName": "org.wildfly.extension.picketlink.federation.FederationExtension"}, {"methodBody": ["METHOD_START", "{", "return    ( Namespace . namespaces . get ( uri )  )     =  =    null    ?    null    :    Namespace . namespaces . get ( uri )  ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . major ;", "}", "METHOD_END"], "methodName": ["getMajor"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . minor ;", "}", "METHOD_END"], "methodName": ["getMinor"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . patch )     >     0  )     {", "return   ModelVercreate ( getMajor (  )  ,    getMinor (  )  ,    getPatch (  )  )  ;", "}", "return   ModelVercreate ( getMajor (  )  ,    getMinor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getModelVersion"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   patch ;", "}", "METHOD_END"], "methodName": ["getPatch"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "String   patchVersion    =     \"  \"  ;", "if    (  ( this . patch )     >     0  )     {", "patchVersion    =     \"  .  \"     +     ( this . patch )  ;", "}", "return    (  (  (  (  . BASE _ URN )     +     ( this . major )  )     +     \"  .  \"  )     +     ( this . minor )  )     +    patchVersion ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . reader ;", "}", "METHOD_END"], "methodName": ["getXMLReader"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . writer ;", "}", "METHOD_END"], "methodName": ["getXMLWriter"], "fileName": "org.wildfly.extension.picketlink.federation.Namespace"}, {"methodBody": ["METHOD_START", "{", "String   domainsList    =    getDomains (  )  ;", "if    (  !  ( StringUtil . isNullOrEmpty ( domainsList )  )  )     {", "domainsList    =    domainsList    +     \"  ,  \"  ;", "}", "getTrust (  )  . setDomains (  ( domainsList    +    domain )  )  ;", "this . trustDomainAlias . put ( domain . trim (  )  ,    domain . trim (  )  )  ;", "}", "METHOD_END"], "methodName": ["addTrustDomain"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTrust (  )  . getDomains (  )  )     =  =    null )     {", "getTrust (  )  . setDomains (  \"  \"  )  ;", "}", "return   getTrust (  )  . getDomains (  )  ;", "}", "METHOD_END"], "methodName": ["getDomains"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . trustDomainAlias )  ;", "}", "METHOD_END"], "methodName": ["getTrustDomainAlias"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . external ;", "}", "METHOD_END"], "methodName": ["isExternal"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   supportMetadata ;", "}", "METHOD_END"], "methodName": ["isSupportMetadata"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "String   domainsList    =    getDomains (  )  ;", "if    (  !  ( StringUtil . isNullOrEmpty ( domainsList )  )  )     {", "getTrust (  )  . setDomains (  \"  \"  )  ;", "for    ( String   currentDomain    :    domainsList . split (  \"  ,  \"  )  )     {", "if    (  (  !  ( domain . equals ( currentDomain )  )  )     &  &     (  !  ( StringUtil . isNullOrEmpty ( currentDomain )  )  )  )     {", "addTrustDomain ( currentDomain )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["removeTrustDomain"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . external    =    external ;", "}", "METHOD_END"], "methodName": ["setExternal"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . securityDomain    =    securityDomain ;", "}", "METHOD_END"], "methodName": ["setSecurityDomain"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . supportMetadata    =    supportMetadata ;", "}", "METHOD_END"], "methodName": ["setSupportMetadata"], "fileName": "org.wildfly.extension.picketlink.federation.config.IDPConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    \" POST \"  . equalsIgnoreCase ( getBindingType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPostBinding"], "fileName": "org.wildfly.extension.picketlink.federation.config.SPConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   supportMetadata ;", "}", "METHOD_END"], "methodName": ["isSupportMetadata"], "fileName": "org.wildfly.extension.picketlink.federation.config.SPConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( postBinding )     {", "super . setBindingType (  \" POST \"  )  ;", "} else    {", "super . setBindingType (  \" REDIRECT \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setPostBinding"], "fileName": "org.wildfly.extension.picketlink.federation.config.SPConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . securityDomain    =    securityDomain ;", "}", "METHOD_END"], "methodName": ["setSecurityDomain"], "fileName": "org.wildfly.extension.picketlink.federation.config.SPConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . supportMetadata    =    supportMetadata ;", "}", "METHOD_END"], "methodName": ["setSupportMetadata"], "fileName": "org.wildfly.extension.picketlink.federation.config.SPConfiguration"}, {"methodBody": ["METHOD_START", "{", "DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,     . MODULE _ ORG _ PICKETLINK ,    false ,    false ,    true ,    false )  )  ;", "phaseContext . addDeploymentDependency ( federationServiceName ,     . DEPLOYMENT _ ATTACHMENT _ KEY )  ;", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "org.wildfly.extension.picketlink.federation.deployment.FederationDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "DeploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "ServiceRegistry   serviceRegistry    =    phaseContext . getServiceRegistry (  )  ;", "ServiceController <  ?  >    service    =    serviceRegistry . getService ( IdentityProviderService . createServiceName ( getName (  )  )  )  ;", "if    ( service    =  =    null )     {", "service    =    serviceRegistry . getService ( ServiceProviderService . createServiceName ( getName (  )  )  )  ;", "} else    {", "IdentityProviderService   identityProviderService    =     (  ( IdentityProviderService )     ( service . getService (  )  )  )  ;", "IDPConfiguration   idpType    =    identityProviderService . getValue (  )  . getConfiguration (  )  ;", "if    ( idpType . isExternal (  )  )     {", "return   null ;", "}", "}", "if    ( service    =  =    null )     {", "return   null ;", "}", "return   service . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getFederationService"], "fileName": "org.wildfly.extension.picketlink.federation.deployment.FederationDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "return   this . createdAssertionsCount ;", "}", "METHOD_END"], "methodName": ["getCreatedAssertionsCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . errorResponseToSPCount ;", "}", "METHOD_END"], "methodName": ["getErrorResponseToSPCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . errorSignValidationCount ;", "}", "METHOD_END"], "methodName": ["getErrorSignValidationCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . errorTrustedDomainCount ;", "}", "METHOD_END"], "methodName": ["getErrorTrustedDomainCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . expiredAssertionsCount ;", "}", "METHOD_END"], "methodName": ["getExpiredAssertionsCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . loginCompleteCount ;", "}", "METHOD_END"], "methodName": ["getLoginCompleteCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . loginInitCount ;", "}", "METHOD_END"], "methodName": ["getLoginInitCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . requestFromIDPCount ;", "}", "METHOD_END"], "methodName": ["getRequestFromIDPCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . requestToIDPCount ;", "}", "METHOD_END"], "methodName": ["getRequestToIDPCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . responseFromIDPCount ;", "}", "METHOD_END"], "methodName": ["getResponseFromIDPCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "return   this . responseToSPCount ;", "}", "METHOD_END"], "methodName": ["getResponseToSPCount"], "fileName": "org.wildfly.extension.picketlink.federation.metrics.PicketLinkSubsystemMetrics"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( ModelElement . COMMON _ HANDLER . getName (  )  )  )     {", "for    ( Property   handlerProperty    :    model . get ( ModelElement . COMMON _ HANDLER . getName (  )  )  . asPropertyList (  )  )     {", "ModelNode   handler    =    handlerProperty . getValue (  )  ;", "Handler   newHandler    =    Handl . toHandlerConfig ( context ,    handler )  ;", "if    ( handler . hasDefined ( ModelElement . COMMON _ HANDLER _ PARAMETER . getName (  )  )  )     {", "for    ( Property   handlerParameter    :    handler . get ( ModelElement . COMMON _ HANDLER _ PARAMETER . getName (  )  )  . asPropertyList (  )  )     {", "String   paramName    =    handlerParameter . getName (  )  ;", "ModelNode   parameterNode    =    handlerParameter . getValue (  )  ;", "KeyValueType   kv    =    HandlerParamet . toHandlerParameterConfig ( context ,    paramName ,    parameterNode )  ;", "newHandler . add ( kv )  ;", "}", "}", "service . addHandler ( newHandler )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["configureHandler"], "fileName": "org.wildfly.extension.picketlink.federation.model.AbstractEntityProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "String   alias    =    PathAddress . pathAddress ( operation . get ( ADDRESS )  )  . getLastElement (  )  . getValue (  )  ;", "context . removeService ( Service . createServiceName ( alias )  )  ;", "}", "METHOD_END"], "methodName": ["removeFederationService"], "fileName": "org.wildfly.extension.picketlink.federation.model.FederationRemoveHandler"}, {"methodBody": ["METHOD_START", "{", "Handler   newHandler    =    new   Handler (  )  ;", "String   typeName    =    HandlerResourceDefinition . getHandlerType ( context ,    handler )  ;", "newHandler . setClazz ( typeName )  ;", "return   newHandler ;", "}", "METHOD_END"], "methodName": ["toHandlerConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.handlers.HandlerAddHandler"}, {"methodBody": ["METHOD_START", "{", "String   paramValue    =    HandlerParameterResourceDefinition . VALUE . resolveModelAttribute ( context ,    parameterNode )  . asString (  )  ;", "KeyValueType   kv    =    new   KeyValueType (  )  ;", "kv . setKey ( paramName )  ;", "kv . setValue ( paramValue )  ;", "return   kv ;", "}", "METHOD_END"], "methodName": ["toHandlerParameterConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.handlers.HandlerParameterAddHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   classNameNode    =    HandlerResourceDefinition . CLASS _ NAME . resolveModelAttribute ( context ,    elementNode )  ;", "ModelNode   codeNode    =    HandlerResourceDefinition . CODE . resolveModelAttribute ( context ,    elementNode )  ;", "if    ( classNameNode . isDefined (  )  )     {", "return   classNameNode . asString (  )  ;", "} else", "if    ( codeNode . isDefined (  )  )     {", "return   HandlerTypeEnum . forType ( codeNode . asString (  )  )  ;", "} else    {", "throw   logging . PicketLinkLogger . ROOT _ LOGGER . federationHandlerTypeNotProvided (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getHandlerType"], "fileName": "org.wildfly.extension.picketlink.federation.model.handlers.HandlerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "HandlerTypeEnum   resolvedType    =    HandlerTypeEnum . types . get ( alias )  ;", "if    ( resolvedType    !  =    null )     {", "return   resolvedType . getType (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.wildfly.extension.picketlink.federation.model.handlers.HandlerTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getAlias"], "fileName": "org.wildfly.extension.picketlink.federation.model.handlers.HandlerTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.wildfly.extension.picketlink.federation.model.handlers.HandlerTypeEnum"}, {"methodBody": ["METHOD_START", "{", "AttributeManagerTypeEnum   resolvedType    =    AttributeManagerTypeEnum . types . get ( alias )  ;", "if    ( resolvedType    !  =    null )     {", "return   resolvedType . getType (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.AttributeManagerTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getAlias"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.AttributeManagerTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.AttributeManagerTypeEnum"}, {"methodBody": ["METHOD_START", "{", "String   alias    =    pathAddress . getLastElement (  )  . getValue (  )  ;", "IdentityProviderService   service    =    new   IdentityProviderService (  . toIDPConfig ( context ,    model ,    alias )  )  ;", "ServiceBuilder < IdentityProviderService >    serviceBuilder    =    context . getServiceTarget (  )  . addService ( IdentityProviderService . createServiceName ( alias )  ,    service )  ;", "String   federationAlias    =    pathAddress . subAddress (  0  ,     (  ( pathAddress . size (  )  )     -     1  )  )  . getLastElement (  )  . getValue (  )  ;", "serviceBuilder . addDependency ( FederationService . createServiceName ( federationAlias )  ,    FederationService . class ,    service . getFederationService (  )  )  ;", "AbstractEntityProviderAddHandler . configureHandler ( context ,    model ,    service )  ;", "IDPConfiguration   configuration    =    service . getConfiguration (  )  ;", "if    (  !  ( configuration . isExternal (  )  )  )     {", "serviceBuilder . addDependency ( SERVICE _ NAME . append ( configuration . getSecurityDomain (  )  )  )  ;", "}", "serviceBuilder . install (  )  ;", "if    ( isRestart )     {", ". restartTrustDomains ( alias ,    model ,    context )  ;", "}", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.IdentityProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( modelNode . hasDefined ( ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN . getName (  )  )  )     {", "for    ( Property   handlerProperty    :    modelNode . get ( ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN . getName (  )  )  . asPropertyList (  )  )     {", "String   domainName    =    handlerProperty . getName (  )  ;", "TrustDomainAddHandler . restartServices ( context ,    iName ,    domainName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["restartTrustDomains"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.IdentityProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "IDPConfiguration   idpType    =    new   IDPConfiguration ( alias )  ;", "boolean   external    =    ResourceDefinition . EXTERNAL . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "idpType . setExternal ( external )  ;", "String   url    =    ResourceDefinition . URL . resolveModelAttribute ( context ,    fromModel )  . asString (  )  ;", "idpType . setIdentityURL ( url )  ;", "if    (  !  ( idpType . isExternal (  )  )  )     {", "ModelNode   securityDomain    =    ResourceDefinition . SECURITY _ DOMAIN . resolveModelAttribute ( context ,    fromModel )  ;", "if    ( securityDomain . isDefined (  )  )     {", "idpType . setSecurityDomain ( securityDomain . asString (  )  )  ;", "} else    {", "throw   PicketLinkLogger . ROOT _ LOGGER . requiredAttribute ( ModelElement . COMMON _ SECURITY _ DOMAIN . getName (  )  ,    alias )  ;", "}", "boolean   supportsSignatures    =    ResourceDefinition . SUPPORT _ SIGNATURES . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "idpType . setSupportsSignature ( supportsSignatures )  ;", "boolean   supportsMetadata    =    ResourceDefinition . SUPPORT _ METADATA . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "idpType . setSupportMetadata ( supportsMetadata )  ;", "boolean   encrypt    =    ResourceDefinition . ENCRYPT . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "idpType . setEncrypt ( encrypt )  ;", "boolean   sslAuthentication    =    ResourceDefinition . SSL _ AUTHENTICATION . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "idpType . setSSLClientAuthentication ( sslAuthentication )  ;", "boolean   strictPostBinding    =    ResourceDefinition . STRICT _ POST _ BINDING . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "idpType . setStrictPostBinding ( strictPostBinding )  ;", "ModelNode   roleGenerator    =    fromModel . get ( ModelElement . IDENTITY _ PROVIDER _ ROLE _ GENERATOR . getName (  )  )  ;", "String   roleGeneratorType ;", "if    ( roleGenerator . isDefined (  )  )     {", "ModelNode   roleGeneratorValue    =    roleGenerator . asProperty (  )  . getValue (  )  ;", "ModelNode   classNameNode    =    RoleGeneratorResourceDefinition . CLASS _ NAME . resolveModelAttribute ( context ,    roleGeneratorValue )  ;", "ModelNode   codeNode    =    RoleGeneratorResourceDefinition . CODE . resolveModelAttribute ( context ,    roleGeneratorValue )  ;", "if    ( classNameNode . isDefined (  )  )     {", "roleGeneratorType    =    classNameNode . asString (  )  ;", "} else", "if    ( codeNode . isDefined (  )  )     {", "roleGeneratorType    =    RoleGeneratorTypeEnum . forType ( codeNode . asString (  )  )  ;", "} else    {", "throw   PicketLinkLogger . ROOT _ LOGGER . typeNotProvided ( ModelElement . IDENTITY _ PROVIDER _ ROLE _ GENERATOR . getName (  )  )  ;", "}", "} else    {", "roleGeneratorType    =    UndertowRoleGenerator . class . getName (  )  ;", "}", "idpType . setRoleGenerator ( roleGeneratorType )  ;", "ModelNode   attributeManager    =    fromModel . get ( ModelElement . IDENTITY _ PROVIDER _ ATTRIBUTE _ MANAGER . getName (  )  )  ;", "String   attributeManagerType ;", "if    ( attributeManager . isDefined (  )  )     {", "ModelNode   attributeManagerValue    =    attributeManager . asProperty (  )  . getValue (  )  ;", "ModelNode   classNameNode    =    AttributeManagerResourceDefinition . CLASS _ NAME . resolveModelAttribute ( context ,    attributeManagerValue )  ;", "ModelNode   codeNode    =    AttributeManagerResourceDefinition . CODE . resolveModelAttribute ( context ,    attributeManagerValue )  ;", "if    ( classNameNode . isDefined (  )  )     {", "attributeManagerType    =    classNameNode . asString (  )  ;", "} else", "if    ( codeNode . isDefined (  )  )     {", "attributeManagerType    =    AttributeManagerTypeEnum . forType ( codeNode . asString (  )  )  ;", "} else    {", "throw   PicketLinkLogger . ROOT _ LOGGER . typeNotProvided ( ModelElement . IDENTITY _ PROVIDER _ ATTRIBUTE _ MANAGER . getName (  )  )  ;", "}", "} else    {", "attributeManagerType    =    UndertowAttributeManager . class . getName (  )  ;", "}", "idpType . setAttributeManager ( attributeManagerType )  ;", "}", "return   idpType ;", "}", "METHOD_END"], "methodName": ["toIDPConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.IdentityProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   identityProviderNode    =    context . readResource ( EMPTY _ ADDRESS ,    false )  . getModel (  )  ;", "boolean   external    =    ResourceDefinition . EXTERNAL . resolveModelAttribute ( context ,    identityProviderNode )  . asBoolean (  )  ;", "ModelNode   securityDomain    =    ResourceDefinition . SECURITY _ DOMAIN . resolveModelAttribute ( context ,    identityProviderNode )  ;", "if    (  (  ! external )     &  &     (  !  ( securityDomain . isDefined (  )  )  )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . requiredAttribute ( ModelElement . COMMON _ SECURITY _ DOMAIN . getName (  )  ,    ModelElement . IDENTITY _ PROVIDER . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateSecurityDomain"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.IdentityProviderValidationStepHandler"}, {"methodBody": ["METHOD_START", "{", "RoleGeneratorTypeEnum   resolvedType    =    RoleGeneratorTypeEnum . types . get ( alias )  ;", "if    ( resolvedType    !  =    null )     {", "return   resolvedType . getType (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.RoleGeneratorTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getAlias"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.RoleGeneratorTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.RoleGeneratorTypeEnum"}, {"methodBody": ["METHOD_START", "{", "TrustDomainService   service    =    new   TrustDomainService ( domainName )  ;", "ServiceName   serviceName    =    TrustDomainService . createServiceName ( identityProviderName ,    domainName )  ;", "context . getServiceTarget (  )  . addService ( serviceName ,    service )  . addDependency ( IdentityProviderService . createServiceName ( identityProviderName )  ,    IdentityProviderService . class ,    service . getIdentityProviderService (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.TrustDomainAddHandler"}, {"methodBody": ["METHOD_START", "{", "String   identityProviderName    =    pathAddress . subAddress (  0  ,     (  ( pathAddress . size (  )  )     -     1  )  )  . getLastElement (  )  . getValue (  )  ;", "String   domainName    =    pathAddress . getLastElement (  )  . getValue (  )  ;", ". launchServices ( context ,    identityProviderName ,    domainName )  ;", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.TrustDomainAddHandler"}, {"methodBody": ["METHOD_START", "{", "ServiceName   serviceName    =    TrustDomainService . createServiceName ( identityProviderName ,    domainName )  ;", "context . removeService ( serviceName )  ;", ". launchServices ( context ,    identityProviderName ,    domainName )  ;", "}", "METHOD_END"], "methodName": ["restartServices"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.TrustDomainAddHandler"}, {"methodBody": ["METHOD_START", "{", "String   certAliasAttribName    =    ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN _ CERT _ ALIAS . getName (  )  ;", "if    (  ( context . getProcessType (  )  . isServer (  )  )     &  &     ( hasDefined ( certAliasAttribName )  )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . attributeNoLongerSupported ( certAliasAttribName )  ;", "}", "}", "METHOD_END"], "methodName": ["validateModelInOperation"], "fileName": "org.wildfly.extension.picketlink.federation.model.idp.TrustDomainResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "String   federationAlias    =    pathAddress . subAddress (  0  ,     (  ( pathAddress . size (  )  )     -     2  )  )  . getLastElement (  )  . getValue (  )  ;", "String   keyName    =    pathAddress . getLastElement (  )  . getValue (  )  ;", "String   host    =    KeyResourceDefinition . HOST . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "KeyService   service    =    new   KeyService ( keyName ,    host )  ;", "context . getServiceTarget (  )  . addService ( KeyService . createServiceName ( federationAlias ,    keyName )  ,    service )  . addDependency ( KeyStoreProviderService . createServiceName ( federationAlias )  ,    KeyStoreProviderService . class ,    service . getKeyStoreProviderService (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.wildfly.extension.picketlink.federation.model.keystore.KeyAddHandler"}, {"methodBody": ["METHOD_START", "{", "PathAddress   pathAddress    =    PathAddress . pathAddress ( operation . get ( ADDRESS )  )  ;", "String   federationAlias    =    pathAddress . subAddress (  0  ,     (  ( pathAddress . size (  )  )     -     1  )  )  . getLastElement (  )  . getValue (  )  ;", "ModelNode   relativeToNode    =    KeyStoreProviderResourceDefinition . RELATIVE _ TO . resolveModelAttribute ( context ,    model )  ;", "String   relativeTo    =    null ;", "if    ( relativeToNode . isDefined (  )  )     {", "relativeTo    =    relativeToNode . asString (  )  ;", "}", "String   file    =    KeyStoreProviderResourceDefinition . FILE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "KeyStoreProviderService   service    =    new   KeyStoreProviderService (  . toKeyProviderType ( context ,    model )  ,    file ,    relativeTo )  ;", "context . getServiceTarget (  )  . addService ( KeyStoreProviderService . createServiceName ( federationAlias )  ,    service )  . addDependency ( FederationService . createServiceName ( federationAlias )  ,    FederationService . class ,    service . getFederationService (  )  )  . addDependency ( SERVICE _ NAME ,    PathManager . class ,    service . getPathManager (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.wildfly.extension.picketlink.federation.model.keystore.KeyStoreProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "KeyProviderType   keyProviderType    =    new   KeyProviderType (  )  ;", "keyProviderType . setClassName ( KeyStoreKeyManager . class . getName (  )  )  ;", "keyProviderType . setSigningAlias ( ResourceDefinition . SIGN _ KEY _ ALIAS . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "AuthPropertyType   keyStorePass    =    new   AuthPropertyType (  )  ;", "keyStorePass . setKey (  \" KeyStorePass \"  )  ;", "keyStorePass . setValue ( ResourceDefinition . PASSWORD . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "keyProviderType . add ( keyStorePass )  ;", "AuthPropertyType   signingKeyPass    =    new   AuthPropertyType (  )  ;", "signingKeyPass . setKey (  \" SigningKeyPass \"  )  ;", "signingKeyPass . setValue ( ResourceDefinition . SIGN _ KEY _ PASSWORD . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "keyProviderType . add ( signingKeyPass )  ;", "AuthPropertyType   signingKeyAlias    =    new   AuthPropertyType (  )  ;", "signingKeyAlias . setKey (  \" SigningKeyAlias \"  )  ;", "signingKeyAlias . setValue ( ResourceDefinition . SIGN _ KEY _ ALIAS . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "keyProviderType . add ( signingKeyAlias )  ;", "return   keyProviderType ;", "}", "METHOD_END"], "methodName": ["toKeyProviderType"], "fileName": "org.wildfly.extension.picketlink.federation.model.keystore.KeyStoreProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   subsystemAddress    =    new   ModelNode (  )  ;", "subsystemAddress . add ( SUBSYSTEM ,    Extension . SUBSYSTEM _ NAME )  ;", "subsystemAddress . protect (  )  ;", "return   Util . getEmptyOperation ( ADD ,    subsystemAddress )  ;", "}", "METHOD_END"], "methodName": ["createSubsystemRoot"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( reader . getLocalName (  )  . equals ( xmlElement . getName (  )  )  )  )     {", "return   null ;", "}", "ModelNode   modelNode    =    Util . getEmptyOp ( ADD ,    null )  ;", "int   attributeCount    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    attributeCount ;    i +  +  )     {", "String   attributeLocalName    =    reader . getAttributeLocalName ( i )  ;", "if    (  ( ModelElement . forName ( attributeLocalName )  )     =  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "for    ( SimpleAttributeDefinition   simpleAttributeDefinition    :    attributes )     {", "String   attributeValue    =    reader . getAttributeValue (  \"  \"  ,    simpleAttributeDefinition . getXmlName (  )  )  ;", "simpleAttributeDefinition . parseAndSetParameter ( attributeValue ,    modelNode ,    reader )  ;", "}", "String   name    =    xmlElement . getName (  )  ;", "if    ( key    !  =    null )     {", "name    =    key ;", "if    ( modelNode . hasDefined ( key )  )     {", "name    =    modelNode . get ( key )  . asString (  )  ;", "} else    {", "String   attributeValue    =    reader . getAttributeValue (  \"  \"  ,    key )  ;", "if    ( attributeValue    !  =    null )     {", "name    =    attributeValue ;", "}", "}", "}", "modelNode . get ( OP _ ADDR )  . set ( lastNode . clone (  )  . get ( OP _ ADDR )  . add ( xmlElement . getName (  )  ,    name )  )  ;", "addOps . add ( modelNode )  ;", "return   modelNode ;", "}", "METHOD_END"], "methodName": ["parseConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "Set < String >    visited    =    new   HashSet <  >  (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ DOCUMENT )  )  )     {", "String   tagName    =    reader . getLocalName (  )  ;", "if    (  !  ( reader . isStartElement (  )  )  )     {", "if    (  ( reader . isEndElement (  )  )     &  &     ( tagName . equals ( parentElement . getName (  )  )  )  )     {", "break ;", "}", "continue ;", "}", "if    (  !  ( tagName . equals ( parentElement . getName (  )  )  )  )     {", "ModelElement   element    =    ModelElement . forName ( tagName )  ;", "if    ( element    !  =    null )     {", "parse ( reader ,    element ,    parentNode ,    addOperations )  ;", "} else    {", "if    (  ( XMLElement . forName ( tagName )  )     !  =    null )     {", "if    ( visited . contains ( tagName )  )     {", "throw   duplicateNamedElement ( reader ,    tagName )  ;", "}", "} else    {", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "visited . add ( tagName )  ;", "}", "}", "METHOD_END"], "methodName": ["parseElement"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   federationNode    =    parseConfig ( reader ,    ModelElement . FEDERATION ,    ModelElement . COMMON _ NAME . getName (  )  ,    subsystemNode ,    Arrays . asList ( FederationResourceDefinition . ATTRIBUTE _ DEFINITIONS )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   KEY _ STORE    :", "parseKeyStore ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   SAML    :", "parseConfig ( reader ,    ModelElement . SAML ,    null ,    parentNode ,    SAMLResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "break ;", "case   IDENTITY _ PROVIDER    :", "parseIdentityProviderConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   SERVICE _ PROVIDER    :", "parseServiceProviderConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}  ,    ModelElement . FEDERATION ,    federationNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseFederation"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   handlerNode    =    parseConfig ( reader ,    ModelElement . COMMON _ HANDLER ,    ModelElement . COMMON _ NAME . getName (  )  ,    entityProviderNode ,    HandlerResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   COMMON _ HANDLER _ PARAMETER    :", "parseConfig ( reader ,    ModelElement . COMMON _ HANDLER _ PARAMETER ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    HandlerParameterResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}  ,    ModelElement . COMMON _ HANDLER ,    handlerNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseHandlerConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   identityProviderNode    =    parseConfig ( reader ,    ModelElement . IDENTITY _ PROVIDER ,    ModelElement . COMMON _ NAME . getName (  )  ,    federationNode ,    Arrays . asList ( IdentityProviderResourceDefinition . ATTRIBUTE _ DEFINITIONS )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   IDENTITY _ PROVIDER _ TRUST _ DOMAIN    :", "parseConfig ( reader ,    ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    TrustDomainResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "break ;", "case   IDENTITY _ PROVIDER _ ROLE _ GENERATOR    :", "parseConfig ( reader ,    ModelElement . IDENTITY _ PROVIDER _ ROLE _ GENERATOR ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    RoleGeneratorResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "break ;", "case   IDENTITY _ PROVIDER _ ATTRIBUTE _ MANAGER    :", "parseConfig ( reader ,    ModelElement . IDENTITY _ PROVIDER _ ATTRIBUTE _ MANAGER ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    AttributeManagerResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "break ;", "case   COMMON _ HANDLER    :", "parseHandlerConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}  ,    ModelElement . IDENTITY _ PROVIDER ,    identityProviderNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseIdentityProviderConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   identityProviderNode    =    parseConfig ( reader ,    ModelElement . KEY _ STORE ,    null ,    parentNode ,    KeyStoreProviderResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "throw   unexpectedElement ( reader )  ;", "}", "}  ,    ModelElement . KEY _ STORE ,    identityProviderNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseKeyStore"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   serviceProviderNode    =    parseConfig ( reader ,    ModelElement . SERVICE _ PROVIDER ,    ModelElement . COMMON _ NAME . getName (  )  ,    federationNode ,    Arrays . asList ( ServiceProviderResourceDefinition . ATTRIBUTE _ DEFINITIONS )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   COMMON _ HANDLER    :", "parseHandlerConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "}", "}", "}  ,    ModelElement . SERVICE _ PROVIDER ,    serviceProviderNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseServiceProviderConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ DOCUMENT )  )  )     {", "if    (  !  ( reader . isStartElement (  )  )  )     {", "continue ;", "}", "if    (  ( XMLElement . forName ( reader . getLocalName (  )  )  )     !  =    null )     {", "continue ;", "}", "ModelElement   modelKey    =    ModelElement . forName ( reader . getLocalName (  )  )  ;", "if    ( modelKey    =  =    null )     {", "throw   unexpectedElement ( reader )  ;", "}", "switch    ( modelKey )     {", "case   FEDERATION    :", "parse ( reader ,    subsystemNode ,    addOperations )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.AbstractFederationSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   identityProviderNode    =    parseConfig ( reader ,    ModelElement . KEY _ STORE ,    null ,    parentNode ,    KeyStoreProviderResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new   Abstract . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   KEY    :", "parseConfig ( reader ,    ModelElement . KEY ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    KeyResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}  ,    ModelElement . KEY _ STORE ,    identityProviderNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseKeyStore"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.FederationSubsystemReader_2_0"}, {"methodBody": ["METHOD_START", "{", "FederationSubsystemWriter . writers . put ( element . getName (  )  ,    new   ModelXMLElementWriter ( element ,    FederationSubsystemWriter . writers )  )  ;", "}", "METHOD_END"], "methodName": ["registerWriter"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.FederationSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "FederationSubsystemWriter . writers . put ( element . getName (  )  ,    new   ModelXMLElementWriter ( element ,    keyAttribute . getName (  )  ,    FederationSubsystemWriter . writers )  )  ;", "}", "METHOD_END"], "methodName": ["registerWriter"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.FederationSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "FederationSubsystemWriter . writers . put ( element . getName (  )  ,    new   ModelXMLElementWriter ( element ,    keyAttribute . getName (  )  ,    parent ,    FederationSubsystemWriter . writers )  )  ;", "}", "METHOD_END"], "methodName": ["registerWriter"], "fileName": "org.wildfly.extension.picketlink.federation.model.parser.FederationSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "PathAddress   pathAddress    =    PathAddress . pathAddress ( operation . get ( ADDRESS )  )  ;", "String   federationAlias    =    pathAddress . subAddress (  0  ,     (  ( pathAddress . size (  )  )     -     1  )  )  . getLastElement (  )  . getValue (  )  ;", "SAMLService   service    =    new   SAMLService (  . toSAMLConfig ( context ,    model )  )  ;", "context . getServiceTarget (  )  . addService ( SAMLService . createServiceName ( federationAlias )  ,    service )  . addDependency ( FederationService . createServiceName ( federationAlias )  ,    FederationService . class ,    service . getFederationService (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.wildfly.extension.picketlink.federation.model.saml.SAMLAddHandler"}, {"methodBody": ["METHOD_START", "{", "int   tokenTimeout    =    SAMLResourceDefinition . TOKEN _ TIMEOUT . resolveModelAttribute ( context ,    fromModel )  . asInt (  )  ;", "int   clockSkew    =    SAMLResourceDefinition . CLOCK _ SKEW . resolveModelAttribute ( context ,    fromModel )  . asInt (  )  ;", "STSType   stsType    =    new   STSType (  )  ;", "stsType . setTokenTimeout ( tokenTimeout )  ;", "stsType . setClockSkew ( clockSkew )  ;", "return   stsType ;", "}", "METHOD_END"], "methodName": ["toSAMLConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.saml.SAMLAddHandler"}, {"methodBody": ["METHOD_START", "{", "String   alias    =    pathAddress . getLastElement (  )  . getValue (  )  ;", "ServiceProviderService   service    =    new   ServiceProviderService (  . toSPConfig ( context ,    model ,    alias )  )  ;", "ServiceBuilder < ServiceProviderService >    serviceBuilder    =    context . getServiceTarget (  )  . addService ( ServiceProviderService . createServiceName ( alias )  ,    service )  ;", "String   federationAlias    =    pathAddress . subAddress (  0  ,     (  ( pathAddress . size (  )  )     -     1  )  )  . getLastElement (  )  . getValue (  )  ;", "serviceBuilder . addDependency ( FederationService . createServiceName ( federationAlias )  ,    FederationService . class ,    service . getFederationService (  )  )  ;", "AbstractEntityProviderAddHandler . configureHandler ( context ,    model ,    service )  ;", "SPConfiguration   configuration    =    service . getConfiguration (  )  ;", "serviceBuilder . addDependency ( SERVICE _ NAME . append ( configuration . getSecurityDomain (  )  )  )  ;", "serviceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["launchService"], "fileName": "org.wildfly.extension.picketlink.federation.model.sp.ServiceProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "SPConfiguration   spType    =    new   SPConfiguration ( alias )  ;", "String   url    =    ResourceDefinition . URL . resolveModelAttribute ( context ,    fromModel )  . asString (  )  ;", "spType . setServiceURL ( url )  ;", "String   securityDomain    =    ResourceDefinition . SECURITY _ DOMAIN . resolveModelAttribute ( context ,    fromModel )  . asString (  )  ;", "spType . setSecurityDomain ( securityDomain )  ;", "boolean   postBinding    =    ResourceDefinition . POST _ BINDING . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "spType . setPostBinding ( postBinding )  ;", "boolean   supportsSignatures    =    ResourceDefinition . SUPPORT _ SIGNATURES . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "spType . setSupportsSignature ( supportsSignatures )  ;", "boolean   supportsMetadata    =    ResourceDefinition . SUPPORT _ METADATA . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "spType . setSupportMetadata ( supportsMetadata )  ;", "boolean   strictPostBinding    =    ResourceDefinition . STRICT _ POST _ BINDING . resolveModelAttribute ( context ,    fromModel )  . asBoolean (  )  ;", "spType . setIdpUsesPostBinding ( strictPostBinding )  ;", "String   errorPage    =    ResourceDefinition . ERROR _ PAGE . resolveModelAttribute ( context ,    fromModel )  . asString (  )  ;", "spType . setErrorPage ( errorPage )  ;", "String   logoutPage    =    ResourceDefinition . LOGOUT _ PAGE . resolveModelAttribute ( context ,    fromModel )  . asString (  )  ;", "spType . setLogOutPage ( logoutPage )  ;", "return   spType ;", "}", "METHOD_END"], "methodName": ["toSPConfig"], "fileName": "org.wildfly.extension.picketlink.federation.model.sp.ServiceProviderAddHandler"}, {"methodBody": ["METHOD_START", "{", "return   IDPConfiguration . class . isInstance ( this . configuration . getIdpOrSP (  )  )  ;", "}", "METHOD_END"], "methodName": ["isIdentityProviderConfiguration"], "fileName": "org.wildfly.extension.picketlink.federation.service.DomainModelConfigProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( Handler   handler    :    handlers . getHandler (  )  )     {", "if    ( handler . getClazz (  )  . equals ( handlerClassName . getName (  )  )  )     {", "return ;", "}", "}", "Handler   handler    =    new   Handler (  )  ;", "handlertClazz ( handlerClassName . getName (  )  )  ;", "handlers . add ( handler )  ;", "}", "METHOD_END"], "methodName": ["addHandler"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "for    ( Handler   actualHandler    :    new   ArrayList < Handler >  ( this . handlers )  )     {", "if    ( actualHandler . getClazz (  )  . equals ( handler . getClazz (  )  )  )     {", "return ;", "}", "}", "this . handlers . add ( handler )  ;", "}", "METHOD_END"], "methodName": ["addHandler"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "removeHandlerParameter ( handlerType ,    keyValueType . getKey (  )  )  ;", "for    ( Handler   handler    :    this . handlers )     {", "if    ( handler . getClazz (  )  . equals ( handlerType )  )     {", "handler . add ( keyValueType )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addHandlerParameter"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "Handlers   actualHandlers    =    new   Handlers (  )  ;", "actualHandlers . setHandlers ( new   ArrayList < Handler >  (  )  )  ;", "if    ( this . handlers . isEmpty (  )  )     {", "for    ( Class <  ?    ds   SAML 2 Handler >    commonHandlerClass    :    getDefaultHandlers (  )  )     {", "addHandler ( commonHandlerClass ,    actualHandlers )  ;", "}", "} else    {", "for    ( Handler   handler    :    this . handlers )     {", "actualHandlers . add ( handler )  ;", "}", "}", "getPicketLinkType (  )  . setHandlers ( actualHandlers )  ;", "}", "METHOD_END"], "methodName": ["configureHandlers"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "getConfiguration (  )  . setKeyProvider ( getFederationService (  )  . getValue (  )  . getKeyProviderType (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureKeyProvider"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "STSType   stsType    =    getFederationService (  )  . getValue (  )  . getStsType (  )  ;", "if    ( stsType    !  =    null )     {", "int   tokenTimeout    =    stsType . getTokenTimeout (  )  ;", "int   clockSkew    =    stsType . getClockSkew (  )  ;", "STSType   providerStsType    =    getPicketLinkType (  )  . getStsType (  )  ;", "providerStsType . setTokenTimeout ( tokenTimeout )  ;", "providerStsType . setClockSkew ( clockSkew )  ;", "List < TokenProviderType >    tokenProviders    =    providerStsType . getTokenProviders (  )  . getTokenProvider (  )  ;", "for    ( TokenProviderType   tokenProviderType    :    tokenProviders )     {", "if    ( tokenProviderType . getTokenType (  )  . equals ( ASSERTION _ NSURI . get (  )  )  )     {", "KeyValueType   keyValueTypeTokenTimeout    =    new   KeyValueType (  )  ;", "keyValueTypeTokenTimeout . setKey ( ASSERTIONS _ VALIDITY )  ;", "keyValueTypeTokenTimeout . setValue ( String . valueOf ( tokenTimeout )  )  ;", "KeyValueType   keyValueTypeClockSkew    =    new   KeyValueType (  )  ;", "keyValueTypeClockSkew . setKey ( CLOCK _ SKEW )  ;", "keyValueTypeClockSkew . setValue ( String . valueOf ( clockSkew )  )  ;", "tokenProviderType . add ( keyValueTypeTokenTimeout )  ;", "tokenProviderType . add ( keyValueTypeClockSkew )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["configureTokenProviders"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "WarMetaData   warMetaData    =    deploymentUnit . getAttachment ( ATTACHMENT _ KEY )  ;", "warMetaData . getMergedJBossWebMetaData (  )  . setSecurityDomain ( this . getConfigu (  )  . getSecurityDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureWarMetadata"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "PicketLinkType   picketLinkType    =    new   PicketLinkType (  )  ;", "picketLinkType . setStsType ( createSTSType (  )  )  ;", "picketLinkType . setHandlers ( new   Handlers (  )  )  ;", "picketLinkType . setEnableAudit ( true )  ;", "picketLinkType . setIdpOrSP (  (  ( Type )     ( configuration )  )  )  ;", "return   picketLinkType ;", "}", "METHOD_END"], "methodName": ["createPicketLinkType"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "STSType   stsType    =    null ;", "InputStream   stream    =    null ;", "try    {", "URL   url    =    getClass (  )  . getClassLoader (  )  . getResource (  \" core - sts . xml \"  )  ;", "if    ( url    =  =    null )     {", "url    =    Thread . currentThread (  )  . getContextClassLoader (  )  . getResource (  \" core - sts \"  )  ;", "}", "if    ( url    !  =    null )     {", "stream    =    url . openStream (  )  ;", "stsType    =     (  ( STSType )     ( new   STSConfigParser (  )  . parse ( stream )  )  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   PicketLinkLogger . ROOT _ LOGGERCouldNotParseSTSConfig ( e )  ;", "}    finally    {", "try    {", "if    ( stream    !  =    null )     {", "stream . close (  )  ;", "}", "}    catch    ( IOException   ignored )     {", "}", "}", "return   stsType ;", "}", "METHOD_END"], "methodName": ["createSTSType"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "return    (  ( C )     ( getPicketLinkType (  )  . getIdpOrSP (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   SAML 2 Handler >  >    defaultHandlers    =    new   ArrayList < Class <  ?    extends   SAML 2 Handler >  >  (  )  ;", "defaultHandlers . add ( SAML 2 LogOutHandler . class )  ;", "defaultHandlers . add ( SAML 2 AuthenticationHandler . class )  ;", "defaultHandlers . add ( RolesGenHandler . class )  ;", "defaultHandlers . add ( SAML 2 EncryptionHandler . class )  ;", "defaultHandlers . add ( SAML 2 SignatureValidationHandler . class )  ;", "return   defaultHandlers ;", "}", "METHOD_END"], "methodName": ["getDefaultHandlers"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "return   this . federationService ;", "}", "METHOD_END"], "methodName": ["getFederationService"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "return   this . picketLinkType ;", "}", "METHOD_END"], "methodName": ["getPicketLinkType"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   serviceRegistry    =    context . getServiceRegistry ( false )  ;", "ServiceController <  >    service    =     (  ( ServiceController <  >  )     ( serviceRegistry . getService ( IdentityProviderService . createServiceName ( alias )  )  )  )  ;", "if    ( service    =  =    null )     {", "service    =     (  ( ServiceController <  >  )     ( serviceRegistry . getService ( ServiceProviderService . createServiceName ( alias )  )  )  )  ;", "}", "if    ( service    =  =    null )     {", "return   null ;", "}", "return   service . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getService"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "for    ( Handler   handler    :    new   ArrayList < Handler >  ( this . handlers )  )     {", "if    ( handler . getClazz (  )  . equals ( handlerType )  )     {", "this . handlers . remove ( handler )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeHandler"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "for    ( Handler   handler    :    this . handlers )     {", "if    ( handler . getClazz (  )  . equals ( handlerType )  )     {", "for    ( KeyValueType   kv    :    new   ArrayList < KeyValueType >  ( handler . getOp (  )  )  )     {", "if    ( kv . getKey (  )  . equals ( handlerParameterName )  )     {", "handler . remove ( kv )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["removeHandlerParameter"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "this . picketLinkType . setIdpOrSP (  (  ( ProviderType )     ( configuration )  )  )  ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.wildfly.extension.picketlink.federation.service.EntityProviderService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( FederationExtension . SUBSYSTEM _ NAME ,    FederationService . SERVICE _ NAME ,    alias )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getAlias"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "return   this . idpConfiguration ;", "}", "METHOD_END"], "methodName": ["getIdpConfiguration"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "return   this . keyProviderType ;", "}", "METHOD_END"], "methodName": ["getKeyProviderType"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "return   this . stsType ;", "}", "METHOD_END"], "methodName": ["getStsType"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "this . idpConfiguration    =    idpConfiguration ;", "}", "METHOD_END"], "methodName": ["setIdpConfiguration"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "this . keyProviderType    =    keyProviderType ;", "}", "METHOD_END"], "methodName": ["setKeyProviderType"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "this . stsType    =    STSType ;", "}", "METHOD_END"], "methodName": ["setSTSType"], "fileName": "org.wildfly.extension.picketlink.federation.service.FederationService"}, {"methodBody": ["METHOD_START", "{", "getConfiguration (  )  . addTrustDomain ( domainName )  ;", "}", "METHOD_END"], "methodName": ["addTrustedDomain"], "fileName": "org.wildfly.extension.picketlink.federation.service.IdentityProviderService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( FederationExtension . SUBSYSTEM _ NAME ,    IdentityProviderService . SERVICE _ NAME ,    alias )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.federation.service.IdentityProviderService"}, {"methodBody": ["METHOD_START", "{", "getConfiguration (  )  . removeTrustDomain ( domainName )  ;", "}", "METHOD_END"], "methodName": ["removeTrustedDomain"], "fileName": "org.wildfly.extension.picketlink.federation.service.IdentityProviderService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( FederationExtension . SUBSYSTEM _ NAME ,    KeyService . SERVICE _ NAME ,     (  ( federationAlias    +     \"  . keystore .  \"  )     +    keyName )  )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyService"}, {"methodBody": ["METHOD_START", "{", "return   this . keyStoreProviderService ;", "}", "METHOD_END"], "methodName": ["getKeyStoreProviderService"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyService"}, {"methodBody": ["METHOD_START", "{", "removeKey ( key )  ;", "String [  ]    hosts    =    validatingHost . split (  \"  ,  \"  )  ;", "for    ( String   host    :    hosts )     {", "KeyValueType   kv    =    new   KeyValueType (  )  ;", "kv . setKey ( host . trim (  )  )  ;", "kv . setValue ( key . trim (  )  )  ;", "this . keyType . add ( kv )  ;", "}", "}", "METHOD_END"], "methodName": ["addKey"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyStoreProviderService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . keyProviderType )     !  =    null )     {", "String   resolvedPath ;", "if    (  ( this . relativeTo )     !  =    null )     {", "resolvedPath    =    getPathManager (  )  . getValue (  )  . resolveRelativePathEntry ( this . filePath ,    this . relativeTo )  ;", "} else    {", "resolvedPath    =    this . filePath ;", "}", "AuthPropertyType   keyStoreURL    =    new   AuthPropertyType (  )  ;", "keyStoreURL . setKey (  \" KeyStoreURL \"  )  ;", "keyStoreURL . setValue ( resolvedPath )  ;", "this . keyProviderType . add ( keyStoreURL )  ;", "}", "}", "METHOD_END"], "methodName": ["configureKeyStoreFilePath"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyStoreProviderService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( FederationExtension . SUBSYSTEM _ NAME ,    KeyStoreProviderService . SERVICE _ NAME ,    alias )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyStoreProviderService"}, {"methodBody": ["METHOD_START", "{", "return   this . federationService ;", "}", "METHOD_END"], "methodName": ["getFederationService"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyStoreProviderService"}, {"methodBody": ["METHOD_START", "{", "return   this . pathManager ;", "}", "METHOD_END"], "methodName": ["getPathManager"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyStoreProviderService"}, {"methodBody": ["METHOD_START", "{", "for    ( KeyValueType   keyValueType    :    new   ArrayList < KeyValueType >  ( this . keyProviderType . getValidatingAlias (  )  )  )     {", "if    (  (  ( keyValueType . getValue (  )  )     !  =    null )     &  &     ( keyValueType . getValue (  )  . equals ( key )  )  )     {", "this . keyProviderType . remove ( keyValueType )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeKey"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyStoreProviderService"}, {"methodBody": ["METHOD_START", "{", "if    ( keyProviderType    !  =    null )     {", "for    ( KeyValueType   kv    :    this . keyProviderType . getValidatingAlias (  )  )     {", "keyProviderType . add ( kv )  ;", "}", "}", "this . filePath    =    file ;", "this . relativeTo    =    relativeTo ;", "this . keyProviderType    =    keyProviderType ;", "configureKeyStoreFilePath (  )  ;", "getFService (  )  . getValue (  )  . setKeyProviderType ( this . keyProviderType )  ;", "}", "METHOD_END"], "methodName": ["setKeyProviderType"], "fileName": "org.wildfly.extension.picketlink.federation.service.KeyStoreProviderService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( FederationExtension . SUBSYSTEM _ NAME ,    SAMLService . SERVICE _ NAME ,    alias )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.federation.service.SAMLService"}, {"methodBody": ["METHOD_START", "{", "return   this . federationService ;", "}", "METHOD_END"], "methodName": ["getFederationService"], "fileName": "org.wildfly.extension.picketlink.federation.service.SAMLService"}, {"methodBody": ["METHOD_START", "{", "this . stsType    =    stsType ;", "getFService (  )  . getValue (  )  . setSTSType ( this . stsType )  ;", "}", "METHOD_END"], "methodName": ["setStsType"], "fileName": "org.wildfly.extension.picketlink.federation.service.SAMLService"}, {"methodBody": ["METHOD_START", "{", "IDPConfiguration   idpConfiguration    =    getFederationService (  )  . getValue (  )  . getIdpConfiguration (  )  ;", "if    ( idpConfiguration    =  =    null )     {", "throw   PicketLinkLogger . ROOT _ LOGGERIdentityProviderNotConfigured ( getFederationService (  )  . getValue (  )  . getAlias (  )  )  ;", "}", "getConfiguration (  )  . setIdentityURL ( idpConfiguration . getIdentityURL (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureIdentityProvider"], "fileName": "org.wildfly.extension.picketlink.federation.service.ServiceProviderService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( FederationExtension . SUBSYSTEM _ NAME ,    ServiceProviderService . SERVICE _ NAME ,    alias )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.federation.service.ServiceProviderService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( FederationExtension . SUBSYSTEM _ NAME ,    TrustDomainService . SERVICE _ NAME ,     (  ( identityProviderName    +     \"  .  \"  )     +    domainName )  )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.federation.service.TrustDomainService"}, {"methodBody": ["METHOD_START", "{", "return   this . identityProviderService ;", "}", "METHOD_END"], "methodName": ["getIdentityProviderService"], "fileName": "org.wildfly.extension.picketlink.federation.service.TrustDomainService"}, {"methodBody": ["METHOD_START", "{", "return   new   DeprecatedResourceDescriptionResolver ( IDMExtension . SUBSYSTEM _ NAME ,    keyPrefix ,    IDMExtension . RESOURCE _ NAME ,    IDMExtension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.wildfly.extension.picketlink.idm.IDMExtension"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", "ResourceTransformationDescriptionBuilder   partitionManagerResourceBuilder    =    builder . addChildResource ( PartitionManagerResourceDefinition . INSTANCE )  ;", "ResourceTransformationDescriptionBuilder   identityConfigResourceBuilder    =    partitionManagerResourceBuilder . addChildResource ( IdentityConfigurationResourceDefinition . INSTANCE )  ;", "ResourceTransformationDescriptionBuilder   ldapTransfDescBuilder    =    identityConfigResourceBuilder . addChildResource ( LDAPStoreResourceDefinition . INSTANCE )  ;", "ldapTransfDescBuilder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    LDAPStoreResourceDefinition . ACTIVE _ DIRECTORY )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    LDAPStoreResourceDefinition . ACTIVE _ DIRECTORY )  ;", "ldapTransfDescBuilder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    LDAPStoreResourceDefinition . UNIQUE _ ID _ ATTRIBUTE _ NAME )  . setDiscard ( UNDEFINED ,    LDAPStoreResourceDefinition . UNIQUE _ ID _ ATTRIBUTE _ NAME )  ;", "Tools . register ( builder . build (  )  ,    subsystemRegistration ,    ModelVercreate (  1  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_1_0"], "fileName": "org.wildfly.extension.picketlink.idm.IDMExtension"}, {"methodBody": ["METHOD_START", "{", "return    ( Namespace . namespaces . get ( uri )  )     =  =    null    ?    null    :    Namespace . namespaces . get ( uri )  ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . major ;", "}", "METHOD_END"], "methodName": ["getMajor"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . minor ;", "}", "METHOD_END"], "methodName": ["getMinor"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . patch )     >     0  )     {", "return   ModelVercreate ( getMajor (  )  ,    getMinor (  )  ,    getPatch (  )  )  ;", "}", "return   ModelVercreate ( getMajor (  )  ,    getMinor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getModelVersion"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   patch ;", "}", "METHOD_END"], "methodName": ["getPatch"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "String   patchVersion    =     \"  \"  ;", "if    (  ( this . patch )     >     0  )     {", "patchVersion    =     \"  .  \"     +     ( this . patch )  ;", "}", "return    (  (  (  (  . BASE _ URN )     +     ( this . major )  )     +     \"  .  \"  )     +     ( this . minor )  )     +    patchVersion ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . reader ;", "}", "METHOD_END"], "methodName": ["getXMLReader"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . writer ;", "}", "METHOD_END"], "methodName": ["getXMLWriter"], "fileName": "org.wildfly.extension.picketlink.idm.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSourceJndiUrl ;", "}", "METHOD_END"], "methodName": ["getDataSourceJndiUrl"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   entityManagerFactoryJndiName ;", "}", "METHOD_END"], "methodName": ["getEntityManagerFactoryJndiName"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . entityModule ;", "}", "METHOD_END"], "methodName": ["getEntityModule"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . entityModuleUnitName ;", "}", "METHOD_END"], "methodName": ["getEntityModuleUnitName"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . dataSourceJndiUrl    =    dataSourceJndiUrl ;", "return   this ;", "}", "METHOD_END"], "methodName": ["dataSourceJndiUrl"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfigurationBuilder"}, {"methodBody": ["METHOD_START", "{", "this . entityManagerFactoryJndiName    =    entityManagerFactoryJndiName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["entityManagerFactoryJndiName"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfigurationBuilder"}, {"methodBody": ["METHOD_START", "{", "this . entityModule    =    entityModule ;", "return   this ;", "}", "METHOD_END"], "methodName": ["entityModule"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfigurationBuilder"}, {"methodBody": ["METHOD_START", "{", "this . entityModuleUnitName    =    entityModuleUnitName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["entityModuleUnitName"], "fileName": "org.wildfly.extension.picketlink.idm.config.JPAStoreSubsystemConfigurationBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( EntityManager )     ( this . transactionSynchronizationRegistry . getResource ( puScopedName )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionScopedEntityManager"], "fileName": "org.wildfly.extension.picketlink.idm.jpa.transaction.TransactionalEntityManagerHelper"}, {"methodBody": ["METHOD_START", "{", "try    {", "Transaction   transaction    =    this . transactionManager . getTransaction (  )  ;", "transaction . registerSynchronization ( new   Synchronization ( entityManager )  )  ;", "this . transactionSynchronizationRegistry . putResource ( scopedPuName ,    entityManager )  ;", "}    catch    ( Exception   e )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmJpaFailedCreateTransactionEntityManager ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["putEntityManagerInTransactionRegistry"], "fileName": "org.wildfly.extension.picketlink.idm.jpa.transaction.TransactionalEntityManagerHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( this . entityManager . isOpen (  )  )     {", "return    !  ( TxUtils . isTransactionManagerTimeoutThread (  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["safeToClose"], "fileName": "org.wildfly.extension.picketlink.idm.jpa.transaction.TransactionalEntityManagerSynchronization"}, {"methodBody": ["METHOD_START", "{", "AttributedTypeEnum   resolvedType    =    AttributedTypeEnum . types . get ( alias )  ;", "if    ( resolvedType    !  =    null )     {", "return   resolvedType . getType (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.wildfly.extension.picketlink.idm.model.AttributedTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getAlias"], "fileName": "org.wildfly.extension.picketlink.idm.model.AttributedTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.wildfly.extension.picketlink.idm.model.AttributedTypeEnum"}, {"methodBody": ["METHOD_START", "{", "ModelNode   classNameNode    =    CredentialHandlerResourceDefinition . CLASS _ NAME . resolveModelAttribute ( context ,    elementNode )  ;", "ModelNode   codeNode    =    CredentialHandlerResourceDefinition . CODE . resolveModelAttribute ( context ,    elementNode )  ;", "if    ( classNameNode . isDefined (  )  )     {", "return   classNameNode . asString (  )  ;", "}", "return   CredentialTypeEnum . forType ( codeNode . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCredentialType"], "fileName": "org.wildfly.extension.picketlink.idm.model.CredentialHandlerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelValidationStepHandler [  ]  {    new   UniqueTypeValidationStepHandler ( ModelElement . IDENTITY _ STORE _ CREDENTIAL _ HANDLER )     {", "@ Override", "protected   String   getType ( OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "return    . getCredentialType ( context ,    model )  ;", "}", "}     }  ;", "}", "METHOD_END"], "methodName": ["getModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.CredentialHandlerResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "CredentialTypeEnum   resolvedType    =    CredentialTypeEnum . types . get ( alias )  ;", "if    ( resolvedType    !  =    null )     {", "return   resolvedType . getType (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.wildfly.extension.picketlink.idm.model.CredentialTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getAlias"], "fileName": "org.wildfly.extension.picketlink.idm.model.CredentialTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.wildfly.extension.picketlink.idm.model.CredentialTypeEnum"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelValidationStepHandler [  ]  {    NotEmptyResourceValidationStepHandler . INSTANCE ,    new   RequiredChildValidationStepHandler ( ModelElement . SUPPORTED _ TYPES )     }  ;", "}", "METHOD_END"], "methodName": ["getModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.FileStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "List < AttributeDefinition >    alternativeAttributes    =    new   ArrayList < AttributeDefinition >  (  )  ;", "for    ( AttributeDefinition   attribute    :    this . attributes )     {", "if    (  (  ( attribute . getAlternatives (  )  )     !  =    null )     &  &     (  ( attribute . getAlternatives (  )  . length )     >     0  )  )     {", "alternativeAttributes . add ( attribute )  ;", "}", "}", "if    (  !  ( alternativeAttributes . isEmpty (  )  )  )     {", "this . modelValidators . add ( new   AlternativeAttributeValidation ( alternativeAttributes . toArray ( new   AttributeDefinition [ alternativeAttributes . size (  )  ]  )  ,    isAlternativesRequired (  )  )  )  ;", "}", "if    ( modelValidators    !  =    null )     {", "this . modelValidators . addAll ( Arrays . asList ( modelValidators )  )  ;", "}", "this . modelValidators . add ( new   ModelValidation (  )     {", "@ Override", "public   void   execute ( OperationContext   context ,    ModelNode   operation )    throws   OperationFailedException    {", "final   PathAddress   address    =    getParentAddress ( PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  )  ;", "Resource   resource    =    context . readResourceFromRoot ( address )  ;", "final   ModelNode   parentModel    =    Tools . readModel ( resource )  ;", "PartitionManagerAddHandler . INSTANCE . validateModel ( context ,    address . getLastElement (  )  . getValue (  )  ,    parentModel )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.IDMConfigAddStepHandler"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isAlternativesRequired"], "fileName": "org.wildfly.extension.picketlink.idm.model.IDMConfigAddStepHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelValidationStepHandler   validatonStepHandler    :    this . modelValidators )     {", "context . addStep ( validatonStepHandler ,    MODEL )  ;", "}", "}", "METHOD_END"], "methodName": ["performValidation"], "fileName": "org.wildfly.extension.picketlink.idm.model.IDMConfigAddStepHandler"}, {"methodBody": ["METHOD_START", "{", "Set < Resource . ResourceEntry >    configurations    =    partitionManagerResource . getChildren ( ModelElement . IDENTITY _ CONFIGURATION . getName (  )  )  ;", "if    (  ( configurations . isEmpty (  )  )     |  |     (  ( configurations . size (  )  )     =  =     1  )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmNoProvided (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkIfLastConfiguration"], "fileName": "org.wildfly.extension.picketlink.idm.model.IdentityConfigurationRemoveStepHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelValidationStepHandler [  ]  {    NotEmptyResourceValidationStepHandler . INSTANCE    }  ;", "}", "METHOD_END"], "methodName": ["getModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.IdentityConfigurationResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "PathAddress   parentAddress    =    Util . getParentAddressByKey ( context . getCurrentAddress (  )  ,    ModelElement . IDENTITY _ CONFIGURATION . getName (  )  )  ;", "if    (  ( context . readResourceFromRoot ( parentAddress ,    false )  . getChildTypes (  )  . size (  )  )     =  =     1  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmNoProvided ( parentAddress . getLastElement (  )  . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkIfLastIdentityStore"], "fileName": "org.wildfly.extension.picketlink.idm.model.IdentityStoreRemoveStepHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelValidationStepHandler [  ]  {    NotEmptyResourceValidationStepHandler . INSTANCE ,    new   RequiredChildValidationStepHandler ( ModelElement . SUPPORTED _ TYPES )     }  ;", "}", "METHOD_END"], "methodName": ["getModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.JPAStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ModelNode   classNameNode    =    LDAPStoreMappingResourceDefinition . CLASS _ NAME . resolveModelAttribute ( context ,    elementNode )  ;", "ModelNode   codeNode    =    LDAPStoreMappingResourceDefinition . CODE . resolveModelAttribute ( context ,    elementNode )  ;", "if    ( classNameNode . isDefined (  )  )     {", "return   classNameNode . asString (  )  ;", "}", "return   AttributedTypeEnum . forType ( codeNode . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMappingType"], "fileName": "org.wildfly.extension.picketlink.idm.model.LDAPStoreMappingResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelValidationStepHandler [  ]  {    new   UniqueTypeValidationStepHandler ( ModelElement . LDAP _ STORE _ MAPPING )     {", "@ Override", "protected   String   getType ( OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "return    . getMappingType ( context ,    model )  ;", "}", "}     }  ;", "}", "METHOD_END"], "methodName": ["getModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.LDAPStoreMappingResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelValidationStepHandler [  ]  {    NotEmptyResourceValidationStepHandler . INSTANCE ,    new   RequiredChildValidationStepHandler ( ModelElement . SUPPORTED _ TYPES )     }  ;", "}", "METHOD_END"], "methodName": ["getModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.LDAPStoreResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( identityStore . hasDefined ( ModelElement . IDENTITY _ STORE _ CREDENTIAL _ HANDLER . getName (  )  )  )     {", "for    ( Property   credentialHandler    :    identityStore . get ( ModelElement . IDENTITY _ STORE _ CREDENTIAL _ HANDLER . getName (  )  )  . asPropertyList (  )  )     {", "ModelNode   classNameNode    =    CredentialHandlerResourceDefinition . CLASS _ NAME . resolveModelAttribute ( context ,    credentialHandler . getValue (  )  )  ;", "ModelNode   codeNode    =    CredentialHandlerResourceDefinition . CODE . resolveModelAttribute ( context ,    credentialHandler . getValue (  )  )  ;", "ModelNode   moduleNode    =    CredentialHandlerResourceDefinition . MODULE . resolveModelAttribute ( context ,    credentialHandler . getValue (  )  )  ;", "String   typeName ;", "if    ( classNameNode . isDefined (  )  )     {", "typeName    =    classNameNode . asString (  )  ;", "} else", "if    ( codeNode . isDefined (  )  )     {", "typeName    =    CredentialTypeEnum . forType ( codeNode . asString (  )  )  ;", "} else    {", "throw   logging . PicketLinkLogger . ROOT _ LOGGER . typeNotProvided ( ModelElement . IDENTITY _ STORE _ CREDENTIAL _ HANDLER . getName (  )  )  ;", "}", "storeConfig . addCredentialHandler ( this .  < CredentialHandler > loadClass ( moduleNode ,    typeName )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["configureCredentialHandlers"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "FileStoreConfigurationBuilder   fileStoreBuilder    =    builder . stores (  )  . file (  )  ;", "String   workingDir    =    FileStoreResourceDefinition . WORKING _ DIR . resolveModelAttribute ( context ,    resource )  . asString (  )  ;", "String   relativeTo    =    FileStoreResourceDefinition . RELATIVE _ TO . resolveModelAttribute ( context ,    resource )  . asString (  )  ;", "ModelNode   alwaysCreateFiles    =    FileStoreResourceDefinition . ALWAYS _ CREATE _ FILE . resolveModelAttribute ( context ,    resource )  ;", "ModelNode   asyncWrite    =    FileStoreResourceDefinition . ASYNC _ WRITE . resolveModelAttribute ( context ,    resource )  ;", "ModelNode   asyncWriteThreadPool    =    FileStoreResourceDefinition . ASYNC _ WRITE _ THREAD _ POOL . resolveModelAttribute ( context ,    resource )  ;", "fileStoreBuilder . preserveState (  (  !  ( alwaysCreateFiles . asBoolean (  )  )  )  )  ;", "fileStoreBuilder . asyncWrite ( asyncWrite . asBoolean (  )  )  ;", "fileStoreBuilder . asyncWriteThreadPool ( asyncWriteThreadPool . asInt (  )  )  ;", "if    ( serviceBuilder    !  =    null )     {", "FileIdentityStoreService   storeService    =    new   FileIdentityStoreService ( fileStoreBuilder ,    workingDir ,    relativeTo )  ;", "ServiceName   storeServiceName    =    Service . createIdentityStoreServiceName ( partitionManagerService . getName (  )  ,    configurationName ,    ModelElement . FILE _ STORE . getName (  )  )  ;", "ServiceBuilder < FileIdentityStoreService >    storeServiceBuilder    =    context . getServiceTarget (  )  . addService ( storeServiceName ,    storeService )  ;", "storeServiceBuilder . addDependency ( SERVICE _ NAME ,    PathManager . class ,    storeService . getPathManager (  )  )  ;", "serviceBuilder . addDependency ( storeServiceName )  ;", "ServiceController < FileIdentityStoreService >    controller    =    storeServiceBuilder . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "return   fileStoreBuilder ;", "}", "METHOD_END"], "methodName": ["configureFileIdentityStore"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "Property   prop    =    modelNode . asProperty (  )  ;", "String   storeType    =    prop . getName (  )  ;", "ModelNode   identityStore    =    prop . getValue (  )  . asProperty (  )  . getValue (  )  ;", "IdentityStoreConfigurationBuilder <  ?  ,     ?  >    storeConfig    =    null ;", "if    ( storeType . equals ( ModelElement . JPA _ STORE . getName (  )  )  )     {", "storeConfig    =    configureJPAIdentityStore ( context ,    serviceBuilder ,    pService ,    identityStore ,    configurationName ,    namedIdentityConfigurationBuilder )  ;", "} else", "if    ( storeType . equals ( ModelElement . FILE _ STORE . getName (  )  )  )     {", "storeConfig    =    configureFileIdentityStore ( context ,    serviceBuilder ,    pService ,    identityStore ,    configurationName ,    namedIdentityConfigurationBuilder )  ;", "} else", "if    ( storeType . equals ( ModelElement . LDAP _ STORE . getName (  )  )  )     {", "storeConfig    =    configureLDAPIdentityStore ( context ,    identityStore ,    namedIdentityConfigurationBuilder )  ;", "}", "ModelNode   supportAttributeNode    =    JPAStoreResourceDefinition . SUPPORT _ ATTRIBUTE . resolveModelAttribute ( context ,    identityStore )  ;", "storeConfig . supportAttributes ( supportAttributeNode . asBoolean (  )  )  ;", "ModelNode   supportCredentialNode    =    JPAStoreResourceDefinition . SUPPORT _ CREDENTIAL . resolveModelAttribute ( context ,    identityStore )  ;", "storeConfig . supportCredentials ( supportCredentialNode . asBoolean (  )  )  ;", "configureSupportedTypes ( context ,    identityStore ,    storeConfig )  ;", "configureCredentialHandlers ( context ,    identityStore ,    storeConfig )  ;", "}", "METHOD_END"], "methodName": ["configureIdentityStore"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "JPAStoreSubsystemConfigurationBuilder   storeConfig    =    builder . stores (  )  . add ( JPAStoreSubsystemConfiguration . class ,    JPAStoreSubsystemConfigurationBuilder . class )  ;", "ModelNode   jpaDataSourceNode    =    JPAStoreResourceDefinition . DATA _ SOURCE . resolveModelAttribute ( context ,    identityStore )  ;", "ModelNode   jpaEntityModule    =    JPAStoreResourceDefinition . ENTITY _ MODULE . resolveModelAttribute ( context ,    identityStore )  ;", "ModelNode   jpaEntityModuleUnitName    =    JPAStoreResourceDefinition . ENTITY _ MODULE _ UNIT _ NAME . resolveModelAttribute ( context ,    identityStore )  ;", "ModelNode   jpaEntityManagerFactoryNode    =    JPAStoreResourceDefinition . ENTITY _ MANAGER _ FACTORY . resolveModelAttribute ( context ,    identityStore )  ;", "if    ( jpaEntityModule . isDefined (  )  )     {", "storeConfig . entityModule ( jpaEntityModule . asString (  )  )  ;", "}", "storeConfig . entityModuleUnitName ( jpaEntityModuleUnitName . asString (  )  )  ;", "if    ( serviceBuilder    !  =    null )     {", "JPAIdentityStoreService   storeService    =    new   JPAIdentityStoreService ( storeConfig )  ;", "ServiceName   storeServiceName    =    Service . createIdentityStoreServiceName ( partitionManagerService . getName (  )  ,    configurationName ,    ModelElement . JPA _ STORE . getName (  )  )  ;", "ServiceBuilder < JPAIdentityStoreService >    storeServiceBuilder    =    context . getServiceTarget (  )  . addService ( storeServiceName ,    storeService )  ;", "storeServiceBuilder . addDependency ( JBOSS _ TXN _ TRANSACTION _ MANAGER ,    TransactionManager . class ,    storeService . getTransactionManager (  )  )  ;", "storeServiceBuilder . addDependency ( JBOSS _ TXN _ SYNCHRONIZATION _ REGISTRY ,    TransactionSynchronizationRegistry . class ,    storeService . getTransactionSynchronizationRegistry (  )  )  ;", "if    ( jpaDataSourceNode . isDefined (  )  )     {", "storeConfig . dataSourceJndiUrl ( toJndiName ( jpaDataSourceNode . asString (  )  )  )  ;", "storeServiceBuilder . addDependency ( JAVA _ CONTEXT _ SERVICE _ NAME . append ( toJndiName ( jpaDataSourceNode . asString (  )  )  . split (  \"  /  \"  )  )  )  ;", "}", "if    ( jpaEntityManagerFactoryNode . isDefined (  )  )     {", "storeConfig . entityManagerFactoryJndiName ( jpaEntityManagerFactoryNode . asString (  )  )  ;", "storeServiceBuilder . addDependency ( JAVA _ CONTEXT _ SERVICE _ NAME . append ( jpaEntityManagerFactoryNode . asString (  )  . split (  \"  /  \"  )  )  ,    ValueManagedReferenceFactory . class ,    new   InjectedValue < ValueManagedReferenceFactory >  (  )  )  ;", "}", "serviceBuilder . addDependency ( storeServiceName )  ;", "ServiceController < JPAIdentityStoreService >    controller    =    storeServiceBuilder . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "return   storeConfig ;", "}", "METHOD_END"], "methodName": ["configureJPAIdentityStore"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "LDAPStoreConfigurationBuilder   storeConfig    =    builder . stores (  )  . ldap (  )  ;", "ModelNode   url    =    LDAPStoreResourceDefin . URL . resolveModelAttribute ( context ,    ldapIdentityStore )  ;", "ModelNode   bindDn    =    LDAPStoreResourceDefin . BIND _ DN . resolveModelAttribute ( context ,    ldapIdentityStore )  ;", "ModelNode   bindCredential    =    LDAPStoreResourceDefin . BIND _ CREDENTIAL . resolveModelAttribute ( context ,    ldapIdentityStore )  ;", "ModelNode   baseDn    =    LDAPStoreResourceDefin . BASE _ DN _ SUFFIX . resolveModelAttribute ( context ,    ldapIdentityStore )  ;", "ModelNode   uniqueIdAttributeName    =    LDAPStoreResourceDefin . UNIQUE _ ID _ ATTRIBUTE _ NAME . resolveModelAttribute ( context ,    ldapIdentityStore )  ;", "ModelNode   activeDirectory    =    LDAPStoreResourceDefin . ACTIVE _ DIRECTORY . resolveModelAttribute ( context ,    ldapIdentityStore )  ;", "if    ( url . isDefined (  )  )     {", "storeConfig . url ( url . asString (  )  )  ;", "}", "if    ( bindDn . isDefined (  )  )     {", "storeConfig . bindDN ( bindDn . asString (  )  )  ;", "}", "if    ( bindCredential . isDefined (  )  )     {", "storeConfig . bindCredential ( bindCredential . asString (  )  )  ;", "}", "if    ( baseDn . isDefined (  )  )     {", "storeConfig . baseDN ( baseDn . asString (  )  )  ;", "}", "if    ( uniqueIdAttributeName . isDefined (  )  )     {", "storeConfig . uniqueIdentifierAttributeName ( uniqueIdAttributeName . asString (  )  )  ;", "}", "storeConfig . activeDirectory ( activeDirectory . asBoolean (  )  )  ;", "if    ( ldapIdentityStore . hasDefined ( ModelElement . LDAP _ STORE _ MAPPING . getName (  )  )  )     {", "for    ( Property   mappingNode    :    ldapIdentityStore . get ( ModelElement . LDAP _ STORE _ MAPPING . getName (  )  )  . asPropertyList (  )  )     {", "ModelNode   ldapMapping    =    mappingNode . getValue (  )  ;", "ModelNode   classNameNode    =    LDAPStoreMappingResourceDefin . CLASS _ NAME . resolveModelAttribute ( context ,    ldapMapping )  ;", "ModelNode   codeNode    =    LDAPStoreMappingResourceDefin . CODE . resolveModelAttribute ( context ,    ldapMapping )  ;", "ModelNode   moduleNode    =    LDAPStoreMappingResourceDefin . MODULE . resolveModelAttribute ( context ,    ldapMapping )  ;", "String   typeName ;", "if    ( classNameNode . isDefined (  )  )     {", "typeName    =    classNameNode . asString (  )  ;", "} else", "if    ( codeNode . isDefined (  )  )     {", "typeName    =    AttributedTypeEnum . forType ( codeNode . asString (  )  )  ;", "} else    {", "throw   PicketLinkLogger . ROOT _ LOGGER . typeNotProvided ( ModelElement . LDAP _ STORE _ MAPPING . getName (  )  )  ;", "}", "LDAPMappingConfigurationBuilder   storeMapping    =    storeConfig . mapping ( this .  < AttributedType > loadClass ( moduleNode ,    typeName )  )  ;", "ModelNode   relatesToNode    =    LDAPStoreMappingResourceDefin . RELATES _ TO . resolveModelAttribute ( context ,    ldapMapping )  ;", "if    ( relatesToNode . isDefined (  )  )     {", "String   relatesTo    =    AttributedTypeEnum . forType ( relatesToNode . asString (  )  )  ;", "if    ( relatesTo    =  =    null )     {", "relatesTo    =    relatesToNode . asString (  )  ;", "}", "storeMapping . forMapping ( this .  < AttributedType > loadClass ( moduleNode ,    relatesTo )  )  ;", "} else    {", "String   baseDN    =    LDAPStoreMappingResourceDefin . BASE _ DN . resolveModelAttribute ( context ,    ldapMapping )  . asString (  )  ;", "storeMapping . baseDN ( baseDN )  ;", "String   objectClasses    =    LDAPStoreMappingResourceDefin . OBJECT _ CLASSES . resolveModelAttribute ( context ,    ldapMapping )  . asString (  )  ;", "for    ( String   objClass    :    objectClasses . split (  \"  ,  \"  )  )     {", "if    (  !  ( objClass . trim (  )  . isEmpty (  )  )  )     {", "storeMapping . objectClasses ( objClass )  ;", "}", "}", "ModelNode   parentAttributeName    =    LDAPStoreMappingResourceDefin . PARENT _ ATTRIBUTE . resolveModelAttribute ( context ,    ldapMapping )  ;", "if    ( parentAttributeName . isDefined (  )  )     {", "storeMapping . parentMembershipAttributeName ( parentAttributeName . asString (  )  )  ;", "}", "}", "if    ( ldapMapping . hasDefined ( ModelElement . LDAP _ STORE _ ATTRIBUTE . getName (  )  )  )     {", "for    ( Property   attributeNode    :    ldapMapping . get ( ModelElement . LDAP _ STORE _ ATTRIBUTE . getName (  )  )  . asPropertyList (  )  )     {", "ModelNode   attribute    =    attributeNode . getValue (  )  ;", "String   name    =    LDAPStoreAttributeResourceDefin . NAME . resolveModelAttribute ( context ,    attribute )  . asString (  )  ;", "String   ldapName    =    LDAPStoreAttributeResourceDefin . LDAP _ NAME . resolveModelAttribute ( context ,    attribute )  . asString (  )  ;", "boolean   readOnly    =    LDAPStoreAttributeResourceDefin . READ _ ONLY . resolveModelAttribute ( context ,    attribute )  . asBoolean (  )  ;", "if    ( readOnly )     {", "storeMapping . readOnlyAttribute ( name ,    ldapName )  ;", "} else    {", "boolean   isIdentifier    =    LDAPStoreAttributeResourceDefin . IS _ IDENTIFIER . resolveModelAttribute ( context ,    attribute )  . asBoolean (  )  ;", "storeMapping . attribute ( name ,    ldapName ,    isIdentifier )  ;", "}", "}", "}", "}", "} else    {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmLdapNoMappingDefined (  )  ;", "}", "return   storeConfig ;", "}", "METHOD_END"], "methodName": ["configureLDAPIdentityStore"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "boolean   hasSupportedType    =    identityStore . hasDefined ( ModelElement . SUPPORTED _ TYPES . getName (  )  )  ;", "if    ( hasSupportedType )     {", "ModelNode   featuresSetNode    =    identityStore . get ( ModelElement . SUPPORTED _ TYPES . getName (  )  )  . asProperty (  )  . getValue (  )  ;", "ModelNode   supportsAllNode    =    SupportedTypesResourceDefin . SUPPORTS _ ALL . resolveModelAttribute ( context ,    featuresSetNode )  ;", "if    ( supportsAllNode . asBoolean (  )  )     {", "storeConfig . supportAllFeatures (  )  ;", "}", "hasSupportedType    =    supportsAllNode . asBoolean (  )  ;", "if    ( featuresSetNode . hasDefined ( ModelElement . SUPPORTED _ TYPE . getName (  )  )  )     {", "for    ( Property   supportedTypeNode    :    featuresSetNode . get ( ModelElement . SUPPORTED _ TYPE . getName (  )  )  . asPropertyList (  )  )     {", "ModelNode   supportedType    =    supportedTypeNode . getValue (  )  ;", "ModelNode   classNameNode    =    SupportedTypeResourceDefin . CLASS _ NAME . resolveModelAttribute ( context ,    supportedType )  ;", "ModelNode   codeNode    =    SupportedTypeResourceDefin . CODE . resolveModelAttribute ( context ,    supportedType )  ;", "String   typeName ;", "if    ( classNameNode . isDefined (  )  )     {", "typeName    =    classNameNode . asString (  )  ;", "} else", "if    ( codeNode . isDefined (  )  )     {", "typeName    =    AttributedTypeEnum . forType ( codeNode . asString (  )  )  ;", "} else    {", "throw   PicketLinkLogger . ROOT _ LOGGER . typeNotProvided ( ModelElement . SUPPORTED _ TYPE . getName (  )  )  ;", "}", "ModelNode   moduleNode    =    SupportedTypeResourceDefin . MODULE . resolveModelAttribute ( context ,    supportedType )  ;", "Class <  ?    extends   AttributedType >    attributedTypeClass    =    loadClass ( moduleNode ,    typeName )  ;", "if    ( Relationship . class . isAssignableFrom ( attributedTypeClass )  )     {", "storeConfig . supportGlobalRelationship (  (  ( Class <  ?    extends   Relationship >  )     ( attributedTypeClass )  )  )  ;", "} else    {", "storeConfig . supportType ( attributedTypeClass )  ;", "}", "hasSupportedType    =    true ;", "}", "}", "}", "if    (  ! hasSupportedType )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmNoSupportedTypesDefined (  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureSupportedTypes"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "String   jndiName    =    PartitionManagerResourceDefinition . IDENTITY _ MANAGEMENT _ JNDI _ URL . resolveModelAttribute ( context ,    partitionManager )  . asString (  )  ;", "IdentityConfigurationBuilder   builder    =    new   IdentityConfigurationBuilder (  )  ;", "PartitionManagerService   partitionManagerService    =    new   PartitionManagerService ( partitionManagerName ,    jndiName ,    builder )  ;", "ServiceBuilder < PartitionManager >    serviceBuilder    =    null ;", "if    (  ! onlyValidate )     {", "serviceBuilder    =    context . getServiceTarget (  )  . addService ( PartitionManagerService . createServiceName ( partitionManagerName )  ,    partitionManagerService )  ;", "}", "ModelNode   identityConfigurationNode    =    partitionManager . get ( ModelElement . IDENTITY _ CONFIGURATION . getName (  )  )  ;", "if    (  !  ( identityConfigurationNode . isDefined (  )  )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmNoIdentityConfigurationProvided (  )  ;", "}", "for    ( Property   identityConfiguration    :    identityConfigurationNode . asPropertyList (  )  )     {", "String   configurationName    =    identityConfiguration . getName (  )  ;", "NamedIdentityConfigurationBuilder   namedIdentityConfigurationBuilder    =    builder . named ( configurationName )  ;", "if    (  !  ( identityConfiguration . getValue (  )  . isDefined (  )  )  )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmNoIdentityStoreProvided ( configurationName )  ;", "}", "List < ModelNode >    identityStores    =    identityConfiguration . getValue (  )  . asList (  )  ;", "for    ( ModelNode   store    :    identityStores )     {", "configureIdentityStore ( context ,    serviceBuilder ,    partitionManagerService ,    configurationName ,    namedIdentityConfigurationBuilder ,    store )  ;", "}", "}", "if    (  ! onlyValidate )     {", "ServiceController < PartitionManager >    controller    =    serviceBuilder . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createPartitionManagerService"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "Module   module ;", "if    ( moduleNode . isDefined (  )  )     {", "ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "try    {", "module    =    moduleLoader . loadModule ( ModuleIdentifier . fromString ( moduleNode . asString (  )  )  )  ;", "}    catch    ( ModuleLoadException   e )     {", "throw   PLinkLogger . ROOT _ LOGGER . moduleCouldNotLoad ( moduleNode . asString (  )  ,    e )  ;", "}", "} else    {", "module    =    Module . getCallerModule (  )  ;", "}", "return   module ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "Module   module    =    getModule ( moduleNode )  ;", "if    ( module    !  =    null )     {", "return    (  ( Class < T >  )     ( module . getClassLoader (  )  . loadClass ( typeName )  )  )  ;", "} else    {", "return    (  ( Class < T >  )     ( getClass (  )  . getClassLoader (  )  . loadClass ( typeName )  )  )  ;", "}", "}    catch    ( ClassNotFoundException   cnfe )     {", "throw   PLinkLogger . ROOT _ LOGGER . couldNotLoadClass ( typeName ,    cnfe )  ;", "}", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( jndiName    !  =    null )     {", "if    ( jndiName . stsWith (  \" java :  \"  )  )     {", "return   jndiName . substring (  (  ( jndiName . indexOf (  \"  :  \"  )  )     +     1  )  )  ;", "}", "}", "return   jndiName ;", "}", "METHOD_END"], "methodName": ["toJndiName"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "createPartitionManagerService ( context ,    partitionManagerName ,    partitionManager ,    true )  ;", "}", "METHOD_END"], "methodName": ["validateModel"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerAddHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   identityConfigurationNode    =    model . get ( ModelElement . IDENTITY _ CONFIGURATION . getName (  )  )  ;", "List < String >    expectedConfigNames    =    Arrays . asList ( configurationNames )  ;", "if    ( identityConfigurationNode . isDefined (  )  )     {", "for    ( Property   identityConfiguration    :    identityConfigurationNode . asPropertyList (  )  )     {", "String   configurationName    =    identityConfiguration . getName (  )  ;", "if    (  (  !  ( expectedConfigNames . isEmpty (  )  )  )     &  &     (  !  ( expectedConfigNames . contains ( configurationName )  )  )  )     {", "continue ;", "}", "ModelNode   value    =    identityConfiguration . getValue (  )  ;", "if    ( value . isDefined (  )  )     {", "for    ( Property   store    :    value . asPropertyList (  )  )     {", "context . removeService ( Service . createIdentityStoreServiceName ( partitionManagerName ,    configurationName ,    store . getName (  )  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["removeIdentityStoreServices"], "fileName": "org.wildfly.extension.picketlink.idm.model.PartitionManagerRemoveHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelValidationStepHandler [  ]  {    new   UniqueTypeValidationStepHandler ( ModelElement . SUPPORTED _ TYPE )     {", "@ Override", "protected   String   getType ( OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "return    . getSupportedType ( context ,    model )  ;", "}", "}     }  ;", "}", "METHOD_END"], "methodName": ["getModelValidators"], "fileName": "org.wildfly.extension.picketlink.idm.model.SupportedTypeResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ModelNode   classNameNode    =    SupportedTypeResourceDefinition . CLASS _ NAME . resolveModelAttribute ( context ,    elementNode )  ;", "ModelNode   codeNode    =    SupportedTypeResourceDefinition . CODE . resolveModelAttribute ( context ,    elementNode )  ;", "if    ( classNameNode . isDefined (  )  )     {", "return   classNameNode . asString (  )  ;", "} else", "if    ( codeNode . isDefined (  )  )     {", "return   AttributedTypeEnum . forType ( codeNode . asString (  )  )  ;", "} else    {", "throw   logging . PicketLinkLogger . ROOT _ LOGGER . idmNoSupportedTypesDefined (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSupportedType"], "fileName": "org.wildfly.extension.picketlink.idm.model.SupportedTypeResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ModelNode   subsystemAddress    =    new   ModelNode (  )  ;", "subsystemAddress . add ( SUBSYSTEM ,    IDMESUBSYSTEM _ NAME )  ;", "subsystemAddress . protect (  )  ;", "return   Util . getEmptyOperation ( ADD ,    subsystemAddress )  ;", "}", "METHOD_END"], "methodName": ["createSubsystemRoot"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( reader . getLocalName (  )  . equals ( xmlElement . getName (  )  )  )  )     {", "return   null ;", "}", "ModelNode   modelNode    =    Util . getEmptyOperation ( ADD ,    null )  ;", "int   attributeCount    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    attributeCount ;    i +  +  )     {", "String   attributeLocalName    =    reader . getAttributeLocalName ( i )  ;", "if    (  ( ModelElement . forName ( attributeLocalName )  )     =  =    null )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "for    ( SimpleAttributeDefinition   simpleAttributeDefinition    :    attributes )     {", "simpleAttributeDefinitionAndSetParameter ( reader . getAttributeValue (  \"  \"  ,    simpleAttributeDefinition . getXmlName (  )  )  ,    modelNode ,    reader )  ;", "}", "String   name    =    xmlElement . getName (  )  ;", "if    ( key    !  =    null )     {", "name    =    key ;", "if    ( modelNode . hasDefined ( key )  )     {", "name    =    modelNode . get ( key )  . asString (  )  ;", "} else    {", "String   attributeValue    =    reader . getAttributeValue (  \"  \"  ,    key )  ;", "if    ( attributeValue    !  =    null )     {", "name    =    attributeValue ;", "}", "}", "}", "modelNode . get ( OP _ ADDR )  . set ( lastNode . clone (  )  . get ( OP _ ADDR )  . add ( xmlElement . getName (  )  ,    name )  )  ;", "addOperations . add ( modelNode )  ;", "return   modelNode ;", "}", "METHOD_END"], "methodName": ["parseConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "return   parseConfig ( reader ,    ModelElement . IDENTITY _ STORE _ CREDENTIAL _ HANDLER ,    ModelElement . COMMON _ NAME . getName (  )  ,    identityProviderNode ,    CredentialHandlerResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseCredentialHandlerConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ DOCUMENT )  )  )     {", "if    (  !  ( reader . isStartElement (  )  )  )     {", "if    (  ( reader . isEndElement (  )  )     &  &     ( reader . getLocalName (  )  . equals ( parentElement . getName (  )  )  )  )     {", "break ;", "}", "continue ;", "}", "if    ( reader . getLocalName (  )  . equals ( parentElement . getName (  )  )  )     {", "continue ;", "}", "ModelElement   element    =    ModelElement . forName ( reader . getLocalName (  )  )  ;", "if    ( element    =  =    null )     {", "if    (  ( XMLElement . forName ( reader . getLocalName (  )  )  )     !  =    null )     {", "continue ;", "}", "throw   unexpectedElement ( reader )  ;", "}", "parse ( reader ,    element ,    parentNode ,    addOperations )  ;", "}", "}", "METHOD_END"], "methodName": ["parseElement"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   fileStoreNode    =    parseConfig ( reader ,    ModelElement . FILE _ STORE ,    null ,    identityManagementNode ,    FileStoreResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   IDENTITY _ STORE _ CREDENTIAL _ HANDLER    :", "parseCredentialHandlerConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   SUPPORTED _ TYPES    :", "parseSupportedTypesConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "}", "}", "}  ,    ModelElement . FILE _ STORE ,    fileStoreNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseFileStoreConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   identityConfigurationNode    =    parseConfig ( reader ,    ModelElement . IDENTITY _ CONFIGURATION ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    IdentityConfigurationResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   JPA _ STORE    :", "parseJPAStoreConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   FILE _ STORE    :", "parseFileStoreConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   LDAP _ STORE    :", "parseLDAPStoreConfig ( reader ,    addOperations ,    parentNode )  ;", "break ;", "}", "}", "}  ,    ModelElement . IDENTITY _ CONFIGURATION ,    identityConfigurationNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseIdentityConfigurationConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   identityManagementNode    =    parseConfig ( reader ,    ModelElement . PARTITION _ MANAGER ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    PartitionManagerResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   IDENTITY _ CONFIGURATION    :", "parseIdentityConfigurationConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "}", "}", "}  ,    ModelElement . PARTITION _ MANAGER ,    identityManagementNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseIdentityManagementConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   jpaStoreNode    =    parseConfig ( reader ,    ModelElement . JPA _ STORE ,    null ,    identityConfigurationNode ,    JPAStoreResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   IDENTITY _ STORE _ CREDENTIAL _ HANDLER    :", "parseCredentialHandlerConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   SUPPORTED _ TYPES    :", "parseSupportedTypesConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "}", "}", "}  ,    ModelElement . JPA _ STORE ,    jpaStoreNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseJPAStoreConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   ldapMappingConfig    =    parseConfig ( reader ,    ModelElement . LDAP _ STORE _ MAPPING ,    ModelElement . COMMON _ NAME . getName (  )  ,    identityProviderNode ,    LDAPStoreMappingResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   LDAP _ STORE _ ATTRIBUTE    :", "parseConfig ( reader ,    ModelElement . LDAP _ STORE _ ATTRIBUTE ,    LDAPStoreAttributeResourceDefinition . NAME . getName (  )  ,    parentNode ,    LDAPStoreAttributeResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "break ;", "}", "}", "}  ,    ModelElement . LDAP _ STORE _ MAPPING ,    ldapMappingConfig ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseLDAPMappingConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   ldapStoreNode    =    parseConfig ( reader ,    ModelElement . LDAP _ STORE ,    null ,    identityManagementNode ,    LDAPStoreResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   IDENTITY _ STORE _ CREDENTIAL _ HANDLER    :", "parseCredentialHandlerConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   LDAP _ STORE _ MAPPING    :", "parseLDAPMappingConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "case   SUPPORTED _ TYPES    :", "parseSupportedTypesConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "}", "}", "}  ,    ModelElement . LDAP _ STORE ,    ldapStoreNode ,    reader ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseLDAPStoreConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "parseConfig ( reader ,    ModelElement . SUPPORTED _ TYPE ,    ModelElement . COMMON _ NAME . getName (  )  ,    parentNode ,    SupportedTypeResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "}", "METHOD_END"], "methodName": ["parseSupportedTypeConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   supportedTypesNode    =    parseConfig ( reader ,    ModelElement . SUPPORTED _ TYPES ,    null ,    identityStoreNode ,    SupportedTypesResourceDefinition . INSTANCE . getAttributes (  )  ,    addOperations )  ;", "parseElement ( new    . ElementParser (  )     {", "@ Override", "public   void   parse ( final   XMLExtendedStreamReader   reader ,    final   ModelElement   element ,    final   ModelNode   parentNode ,    List < ModelNode >    addOperations )    throws   XMLStreamException    {", "switch    ( element )     {", "case   SUPPORTED _ TYPE    :", "parseSupportedTypeConfig ( reader ,    parentNode ,    addOperations )  ;", "break ;", "}", "}", "}  ,    ModelElement . SUPPORTED _ TYPES ,    supportedTypesNode ,    reader ,    addOperations )  ;", "return   supportedTypesNode ;", "}", "METHOD_END"], "methodName": ["parseSupportedTypesConfig"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ DOCUMENT )  )  )     {", "if    (  !  ( reader . isStartElement (  )  )  )     {", "continue ;", "}", "if    (  ( XMLElement . forName ( reader . getLocalName (  )  )  )     !  =    null )     {", "continue ;", "}", "ModelElement   modelKey    =    ModelElement . forName ( reader . getLocalName (  )  )  ;", "if    ( modelKey    =  =    null )     {", "throw   unexpectedElement ( reader )  ;", "}", "switch    ( modelKey )     {", "case   PARTITION _ MANAGER    :", "parseIdentityManagementConfig ( reader ,    sNode ,    addOperations )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.AbstractIDMSubsystemReader"}, {"methodBody": ["METHOD_START", "{", "IDMSubsystemWriter . writers . put ( element . getName (  )  ,    new   ModelXMLElementWriter ( element ,    IDMSubsystemWriter . writers )  )  ;", "}", "METHOD_END"], "methodName": ["registerWriter"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.IDMSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "IDMSubsystemWriter . writers . put ( element . getName (  )  ,    new   ModelXMLElementWriter ( element ,    keyAttribute . getName (  )  ,    IDMSubsystemWriter . writers )  )  ;", "}", "METHOD_END"], "methodName": ["registerWriter"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.IDMSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "IDMSubsystemWriter . writers . put ( element . getName (  )  ,    new   ModelXMLElementWriter ( element ,    keyAttribute . getName (  )  ,    parent ,    IDMSubsystemWriter . writers )  )  ;", "}", "METHOD_END"], "methodName": ["registerWriter"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.IDMSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "IDMSubsystemWriter . writers . put ( element . getName (  )  ,    new   ModelXMLElementWriter ( element ,    parent ,    IDMSubsystemWriter . writers )  )  ;", "}", "METHOD_END"], "methodName": ["registerWriter"], "fileName": "org.wildfly.extension.picketlink.idm.model.parser.IDMSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "return   this . pathManager ;", "}", "METHOD_END"], "methodName": ["getPathManager"], "fileName": "org.wildfly.extension.picketlink.idm.service.FileIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "Set < EntityType <  ?  >  >    mappedEntities    =    this . emf . getMetamodel (  )  . getEntities (  )  ;", "for    ( EntityType <  ?  >    entity    :    mappedEntities )     {", "Class <  ?  >    javaType    =    entity . getJavaType (  )  ;", "if    (  (  !  ( Modifier . isAbstract ( getModifiers (  )  )  )  )     &  &     ( isEntity ( javaType )  )  )     {", "PicketLinkLogger . ROOT _ LOGGER . debugf (  \" Mapping   entity    [  % s ]    to   JPA      Store .  \"  ,    getName (  )  )  ;", "this . configurationBuilder . mappedEntity ( javaType )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["configureEntities"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . storeConfig . getEntityManagerFactoryJndiName (  )  )     !  =    null )     {", "this . emf    =    lookupEntityManagerFactory (  )  ;", "} else    {", "this . emf    =    createEmbeddedEntityManagerFactory (  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureEntityManagerFactory"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "PicketLinkLogger . ROOT _ LOGGER . debugf (  \" Creating   embedded   EntityManagerFactory .  \"  )  ;", "ClassLoader   originalClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "try    {", "Map < Object ,    Object >    properties    =    new   HashMap < Object ,    Object >  (  )  ;", "String   dataSourceJndiUrl    =    this . storeConfig . getDataSourceJndiUrl (  )  ;", "if    (  !  ( StringUtil . isNullOrEmpty ( dataSourceJndiUrl )  )  )     {", "PicketLinkLogger . ROOT _ LOGGER . debugf (  \" Using   datasource    [  % s ]    for   embedded   EntityManagerFactory .  \"  ,    dataSourceJndiUrl )  ;", "properties . put (  \" jtaDataSource \"  ,    dataSourceJndiUrl )  ;", "}", "properties . put ( JTA _ PLATFORM ,    new   JBossAppServerJtaPlatform (  )  )  ;", "Module   Module    =    this . storeConfig . getEntityModule (  )  ;", "if    ( Module    !  =    null )     {", "Thread . currentThread (  )  . setContextClassLoader ( Module . getClassLoader (  )  )  ;", "}", "return   Persistence . createEntityManagerFactory ( this . storeConfig . getEntityModuleUnitName (  )  ,    properties )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( originalClassLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["createEmbeddedEntityManagerFactory"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "return    (  ( EntityManager )     ( Proxy . newProxyInstance ( Thread . currentThread (  )  . getContextClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    EntityManager . class    }  ,    new   JPAIdentityStoreService . EntityManagerInvocationHandler ( this . emf . createEntityManager (  )  ,    this . storeConfig . getEntityModule (  )  ,    transactionManager )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createEntityManager"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "EntityManager   entityManager    =    getOrCreateTransactionalEntityManager ( transactionManager )  ;", "if    (  ( entityManager    =  =    null )     |  |     (  !  ( entityManager . isOpen (  )  )  )  )     {", "entityManager    =    createEntityManager ( transactionManager )  ;", "}", "return   entityManager ;", "}", "METHOD_END"], "methodName": ["getEntityManager"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( transactionManager . getStatus (  )  )     =  =     ( Status . STATUS _ ACTIVE )  )     {", "EntityManager   Manager    =    this . transactionalEntityManagerHelper . getTransactionScopedEntityManager ( getPersistenceUnitName (  )  )  ;", "if    ( Manager    =  =    null )     {", "Manager    =    createEntityManager ( transactionManager )  ;", "this . transactionalEntityManagerHelper . putEntityManagerInTransactionRegistry ( getPersistenceUnitName (  )  ,    Manager )  ;", "}", "return   Manager ;", "}", "}    catch    ( Exception   e )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmJpaFailedCreateTransactionEntityManager ( e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getOrCreateTransactionalEntityManager"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "String   persistenceUnitName    =    this . storeConfig . getEntityModuleUnitName (  )  ;", "if    ( persistenceUnitName    =  =    null )     {", "persistenceUnitName    =     . DEFAULT _ PERSISTENCE _ UNIT _ NAME ;", "}", "return   persistenceUnitName ;", "}", "METHOD_END"], "methodName": ["getPersistenceUnitName"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionSynchronizationRegistry ;", "}", "METHOD_END"], "methodName": ["getTransactionSynchronizationRegistry"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    checkClass    =    cls ;", "while    (  !  ( checkClass . equals ( Object . class )  )  )     {", "for    ( Annotation   a    :    checkClass . getAnnotations (  )  )     {", "if    ( a . annotationType (  )  . getName (  )  . startsWith (  . JPA _ ANNOTATION _ PACKAGE )  )     {", "return   true ;", "}", "}", "for    ( Field   f    :    checkClass . getDeclaredFields (  )  )     {", "for    ( Annotation   a    :    f . getAnnotations (  )  )     {", "if    ( a . annotationType (  )  . getName (  )  . startsWith (  . JPA _ ANNOTATION _ PACKAGE )  )     {", "return   true ;", "}", "}", "}", "checkClass    =    checkClass . getSuperclass (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isIdentityEntity"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "PicketLinkLogger . ROOT _ LOGGER . debugf (  \" Looking   up   EntityManagerFactory   from    [  % s ]  \"  ,    this . storeConfig . getEntityManagerFactoryJndiName (  )  )  ;", "try    {", "return    (  ( EntityManagerFactory )     ( new   InitialContext (  )  . lookup ( this . storeConfig . getEntityManagerFactoryJndiName (  )  )  )  )  ;", "}    catch    ( NamingException   e )     {", "throw   PicketLinkLogger . ROOT _ LOGGER . idmJpaEMFLookupFailed ( this . storeConfig . getEntityManagerFactoryJndiName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupEntityManagerFactory"], "fileName": "org.wildfly.extension.picketlink.idm.service.JPAIdentityStoreService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( IDMExtension . SUBSYSTEM _ NAME ,    name ,    configurationName ,    storeType )  ;", "}", "METHOD_END"], "methodName": ["createIdentityStoreServiceName"], "fileName": "org.wildfly.extension.picketlink.idm.service.PartitionManagerService"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . bindInfoFor ( this . jndiName )  ;", "}", "METHOD_END"], "methodName": ["createPartitionManagerBindInfo"], "fileName": "org.wildfly.extension.picketlink.idm.service.PartitionManagerService"}, {"methodBody": ["METHOD_START", "{", "return   JBOSS . append ( IDMExtension . SUBSYSTEM _ NAME ,    PartitionManagerService . SERVICE _ NAME _ PREFIX ,    alias )  ;", "}", "METHOD_END"], "methodName": ["createServiceName"], "fileName": "org.wildfly.extension.picketlink.idm.service.PartitionManagerService"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.picketlink.idm.service.PartitionManagerService"}, {"methodBody": ["METHOD_START", "{", "BindInfo   bindInfo    =    createPartitionManagerBindInfo (  )  ;", "ServiceName   serviceName    =    bindInfo . getBinderServiceName (  )  ;", "final   BinderService   binderService    =    new   BinderService ( serviceName . getCanonicalName (  )  )  ;", "final   ServiceBuilder < ManagedReferenceFactory >    builder    =    context . getController (  )  . getServiceContainer (  )  . addService ( serviceName ,    binderService )  . addAliases ( JAVA _ CONTEXT _ SERVICE _ NAME . append ( this . jndiName )  )  ;", "builder . addDependency ( JAVA _ CONTEXT _ SERVICE _ NAME ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  ;", "builder . addDependency (  . createServiceName ( this . alias )  ,    PartitionManager . class ,    new   Injector < PartitionManager >  (  )     {", "@ Override", "public   void   inject ( final   PartitionManager   value )    throws   InjectionException    {", "binderService . getManagedObjectInjector (  )  . inject ( new   ValueManagedReferenceFactory ( new   ImmediateValue < Object >  ( value )  )  )  ;", "}", "@ Override", "public   void   uninject (  )     {", "binderService . getManagedObjectInjector (  )  . uninject (  )  ;", "}", "}  )  ;", "builder . setInitialMode ( PASSIVE )  . install (  )  ;", "PicketLinkLogger . ROOT _ LOGGER . boundToJndi (  (  \" PartitionManager    \"     +     ( this . alias )  )  ,    bindInfo . getAbsoluteJndiName (  )  )  ;", "}", "METHOD_END"], "methodName": ["publishPartitionManager"], "fileName": "org.wildfly.extension.picketlink.idm.service.PartitionManagerService"}, {"methodBody": ["METHOD_START", "{", "ServiceController <  ?  >    service    =    context . getController (  )  . getServiceContainer (  )  . getService ( createPartitionManagerBindInfo (  )  . getBinderServiceName (  )  )  ;", "if    ( service    !  =    null )     {", "service . setMode ( REMOVE )  ;", "}", "}", "METHOD_END"], "methodName": ["unpublishPartitionManager"], "fileName": "org.wildfly.extension.picketlink.idm.service.PartitionManagerService"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" federation - subsystem -  1  .  0  . xml \"  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( Extension . SUBSYSTEM _ PATH )  . append ( ModelElement . FEDERATION . getName (  )  ,     \" federation - without - signatures \"  )  . append ( ModelElement . IDENTITY _ PROVIDER . getName (  )  ,     \" idp . war \"  )  . append ( ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN . getName (  )  ,     \" invalid - trust - domain \"  )  ;", "ModelNode   operation    =    Util . createAddOperation ( address )  ;", "operation . get ( ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN _ CERT _ ALIAS . getName (  )  )  . set (  \" servercert \"  )  ;", "servicesA . executeForFailure ( operation )  ;", "}", "METHOD_END"], "methodName": ["failAddTrustDomainWithCertAlias"], "fileName": "org.wildfly.extension.picketlink.subsystem.FederationSubsystem_1_0_CertAliasUnsupportedTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" federation - subsystem -  1  .  0  . xml \"  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( Extension . SUBSYSTEM _ PATH )  . append ( ModelElement . FEDERATION . getName (  )  ,     \" federation - without - signatures \"  )  . append ( ModelElement . IDENTITY _ PROVIDER . getName (  )  ,     \" idp . war \"  )  . append ( ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN . getName (  )  ,     \" invalid - trust - domain \"  )  ;", "ModelNode   operation    =    Util . getWriteAttributeOperation ( address ,    ModelElement . IDENTITY _ PROVIDER _ TRUST _ DOMAIN _ CERT _ ALIAS . getName (  )  ,    new   ModelNode (  \" servercert \"  )  )  ;", "servicesA . executeForFailure ( operation )  ;", "}", "METHOD_END"], "methodName": ["failWriteTrustDomainWithCertAlias"], "fileName": "org.wildfly.extension.picketlink.subsystem.FederationSubsystem_1_0_CertAliasUnsupportedTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   oldVersion    =    ModelVersion . create (  1  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    oldVersion )  . setExtensionClassName ( FederationExtension . class . getName (  )  )  . addMavenResourceURL (  (  \" wildfly : wildfly \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  \" orgdistributionjbas 7  :  \"     +    picketLinkJBossAs 7 Version )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( oldVersion )  ;", "Assert . assertNotNull ( legacyServices )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource (  \" federation - subsystem -  2  .  0  . xml \"  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    oldVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( PathElement . pathElement ( SUBSYSTEM ,    FederationExtension . SUBSYSTEM _ NAME )  ,    PathElement . pathElement ( ModelElement . FEDERATION . getName (  )  )  ,    KeyStoreProviderResourceDefinition . INSTANCE . getPathElement (  )  ,    KeyResourceDefinition . INSTANCE . getPathElement (  )  )  ,    REJECTED _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionExpressions"], "fileName": "org.wildfly.extension.picketlink.subsystem.FederationSubsystem_1_0_TransformerUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "ignoreThisTestIfEAPRepositoryIsNotReachable (  )  ;", "testRejectionExpressions ( EAP _  6  _  3  _  0  ,     \"  2  .  5  .  3  . SP 1  0  - redhat -  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP_6_3"], "fileName": "org.wildfly.extension.picketlink.subsystem.FederationSubsystem_1_0_TransformerUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" federation - subsystem -  1  .  0  . xml \"  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   modelA    =    servicesA . readWholeModel (  )  ;", "String   marshalled    =    servicesA . getPersistedSubsystemXml (  )  ;", "servicesA . shutdown (  )  ;", "KernelServices   servicesB    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( marshalled )  . build (  )  ;", "ModelNode   modelB    =    servicesB . readWholeModel (  )  ;", "super . compare ( modelA ,    modelB )  ;", "assertRemoveSubsystemResources ( servicesB )  ;", "}", "METHOD_END"], "methodName": ["testParseAndMarshalModel"], "fileName": "org.wildfly.extension.picketlink.subsystem.FederationSubsystem_1_0_UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" federation - subsystem - expressions -  2  .  0  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.wildfly.extension.picketlink.subsystem.FederationSubsystem_2_0_UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . home . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . server . server . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( new   AdditionalInitialization (  )     {", "@ Override", "protected   RunningMode   getRunningMode (  )     {", "return   RunningMode . NORMAL ;", "}", "@ Override", "protected   void   setupController ( ControllerInitializer   controllerInitializer )     {", "super . setupController ( controllerInitializer )  ;", "controllerInitializer . addPath (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  ,    null )  ;", "}", "}  )  . setXml ( getXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.picketlink.subsystem.FederationSubsystem_2_0_UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . home . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . server . server . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( new   AdditionalInitialization (  )     {", "@ Override", "protected   RunningMode   getRunningMode (  )     {", "return   RunningMode . NORMAL ;", "}", "@ Override", "protected   void   setupController ( ControllerInitializer   controllerInitializer )     {", "super . setupController ( controllerInitializer )  ;", "controllerInitializer . addPath (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  ,    null )  ;", "}", "}  )  . setXml ( getXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.picketlink.subsystem.IDMSubsystemExampleConfigurationUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   addr    =    new   ModelNode (  )  ;", "addr . add ( SUBSYSTEM ,    IDMESUBSYSTEM _ NAME )  ;", "for    ( int   i    =     0  ;    i    <     ( addressElements . length )  ;    i +  +  )     {", "addr . add ( addressElements [ i ]  ,    addressElements [  (  +  + i )  ]  )  ;", "}", "return   Util . getEmptyOperation ( name ,    addr )  ;", "}", "METHOD_END"], "methodName": ["createOperation"], "fileName": "org.wildfly.extension.picketlink.subsystem.IDMSubsystem_1_0_TransformerUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   oldVersion    =    ModelVersion . create (  1  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    oldVersion )  . setExtensionClassName ( IDMExtension . class . getName (  )  )  . addMavenResourceURL (  (  \" wildfly : wildfly - picketlink :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  \" distribution : picketlink - jbas 7  :  \"     +    picketLinkJBossAs 7 Version )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( oldVersion )  ;", "Assert . assertNotNull ( legacyServices )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "ModelNode   op    =     . createOperation ( ADD ,    ModelElement . PARTITION _ MANAGER . getName (  )  ,     \" test . partition \"  ,    ModelElement . IDENTITY _ CONFIGURATION . getName (  )  ,     \" test . config \"  ,    ModelElement . LDAP _ STORE . getName (  )  ,     \" ldap - store \"  )  ;", "op . get ( ModelElement . LDAP _ STORE _ ACTIVE _ DIRECTORY . getName (  )  )  . set ( true )  ;", "TransformedOperation   transformedOperation    =    mainServices . transformOperation ( oldVersion ,    op )  ;", "Assert . assertTrue ( transformedOperation . rejectOperation ( null )  )  ;", "op    =     . createOperation ( ADD ,    ModelElement . PARTITION _ MANAGER . getName (  )  ,     \" test . partition \"  ,    ModelElement . IDENTITY _ CONFIGURATION . getName (  )  ,     \" test . config \"  ,    ModelElement . LDAP _ STORE . getName (  )  ,     \" ldap - store \"  )  ;", "op . get ( ModelElement . LDAP _ STORE _ UNIQUE _ ID _ ATTRIBUTE _ NAME . getName (  )  )  . set (  \" SOMEaTTRIBUTE \"  )  ;", "transformedOperation    =    mainServices . transformOperation ( oldVersion ,    op )  ;", "Assert . assertTrue ( transformedOperation . rejectOperation ( null )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionExpressions"], "fileName": "org.wildfly.extension.picketlink.subsystem.IDMSubsystem_1_0_TransformerUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "ignoreThisTestIfEAPRepositoryIsNotReachable (  )  ;", "testRejectionExpressions ( EAP _  6  _  3  _  0  ,     \"  2  .  5  .  3  . SP 1  0  - redhat -  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP_6_3"], "fileName": "org.wildfly.extension.picketlink.subsystem.IDMSubsystem_1_0_TransformerUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" identity - management - subsystem -  1  .  0  . xml \"  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   modelA    =    servicesA . readWholeModel (  )  ;", "String   marshalled    =    servicesA . getPersistedSubsystemXml (  )  ;", "servicesA . shutdown (  )  ;", "KernelServices   servicesB    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( marshalled )  . build (  )  ;", "ModelNode   modelB    =    servicesB . readWholeModel (  )  ;", "super . compare ( modelA ,    modelB )  ;", "}", "METHOD_END"], "methodName": ["testParseAndMarshalModel"], "fileName": "org.wildfly.extension.picketlink.subsystem.IDMSubsystem_1_0_UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" identity - management - subsystem - expressions -  2  .  0  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.wildfly.extension.picketlink.subsystem.IDMSubsystem_2_0_UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . home . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . server . server . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( new   AdditionalInitialization (  )     {", "@ Override", "protected   RunningMode   getRunningMode (  )     {", "return   RunningMode . NORMAL ;", "}", "@ Override", "protected   void   setupController ( ControllerInitializer   controllerInitializer )     {", "super . setupController ( controllerInitializer )  ;", "controllerInitializer . addPath (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  ,    null )  ;", "}", "}  )  . setXml ( getXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRuntime"], "fileName": "org.wildfly.extension.picketlink.subsystem.IDMSubsystem_2_0_UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . home . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . server . server . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( new   AdditionalInitialization (  )     {", "@ Override", "protected   RunningMode   getRunningMode (  )     {", "return   RunningMode . NORMAL ;", "}", "@ Override", "protected   void   setupController ( ControllerInitializer   controllerInitializer )     {", "super . setupController ( controllerInitializer )  ;", "controllerInitializer . addPath (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  ,    null )  ;", "}", "}  )  . setSXml ( getSXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertFalse ( mainServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystem"], "fileName": "org.wildfly.extension.picketlink.subsystem.InvalidAttributeManagerDeclarationUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . home . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "System . setProperty (  \" jboss . server . server . dir \"  ,    System . getProperty (  \" tmpdir \"  )  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( new   AdditionalInitialization (  )     {", "@ Override", "protected   RunningMode   getRunningMode (  )     {", "return   RunningMode . NORMAL ;", "}", "@ Override", "protected   void   setupController ( ControllerInitializer   controllerInitializer )     {", "super . setupController ( controllerInitializer )  ;", "controllerInitializer . addPath (  \" jboss . server . data . dir \"  ,    System . getProperty (  \" tmpdir \"  )  ,    null )  ;", "}", "}  )  . setSXml ( getSXml (  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertFalse ( mainServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystem"], "fileName": "org.wildfly.extension.picketlink.subsystem.RoleGeneratorDeclarationUnitTestCase"}]