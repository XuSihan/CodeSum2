[{"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "final   String   name    =    reader . getAttributeLocalName ( i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "if    ( attributeName . equals ( name )  )     {", "return   Boolean . valueOf ( value )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAttributeAsBoolean"], "fileName": "org.jboss.as.weld.AbstractWeldJBossAllParser"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotationType ( annotation . getDotName (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["asAnnotationType"], "fileName": "org.jboss.as.weld.CdiAnnotations"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotationType ( annotation . getDotName (  )  ,    inherited )  ;", "}", "METHOD_END"], "methodName": ["asAnnotationType"], "fileName": "org.jboss.as.weld.CdiAnnotations"}, {"methodBody": ["METHOD_START", "{", "return   dotName ;", "}", "METHOD_END"], "methodName": ["getDotName"], "fileName": "org.jboss.as.weld.CdiAnnotations"}, {"methodBody": ["METHOD_START", "{", "return   simpleName ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "org.jboss.as.weld.CdiAnnotations"}, {"methodBody": ["METHOD_START", "{", "return   beanManagerInjector ;", "}", "METHOD_END"], "methodName": ["getBeanManagerInjector"], "fileName": "org.jboss.as.weld.CdiValidatorFactoryService"}, {"methodBody": ["METHOD_START", "{", "Set < Bean <  ?  >  >    beans    =    beanManager . getBeans ( clazz ,    new   AnnotationLiteral < Default >  (  )     {  }  )  ;", "Iter < Bean <  ?  >  >    i    =    beans . iter (  )  ;", "if    (  !  ( i . hasNext (  )  )  )     {", "return   null ;", "}", "Bean <  ?  >    bean    =    i . next (  )  ;", "CreationalContext <  ?  >    context    =    beanManager . createCreationalContext ( bean )  ;", "return    (  ( T )     ( beanManager . getReference ( bean ,    clazz ,    context )  )  )  ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.jboss.as.weld.CdiValidatorFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append ( ServiceNames . BEAN _ MANAGER _ SERVICE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["beanManagerServiceName"], "fileName": "org.jboss.as.weld.ServiceNames"}, {"methodBody": ["METHOD_START", "{", "deployment . addWeldService ( type ,    service )  ;", "}", "METHOD_END"], "methodName": ["addWeldService"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   new   HashSet < BeanDeploymentArchive >  ( beanDeploymentArchives . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeanDeploymentArchives"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( started )  )     {", "throw   WeldLogger . ROOT _ LOGGER . notStarted (  \" WeldContainer \"  )  ;", "}", "return   b . getManager ( rootBeanDeploymentArchive )  ;", "}", "METHOD_END"], "methodName": ["getBeanManager"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( started )  )     {", "throw   WeldLogger . ROOT _ LOGGER . notStarted (  \" WeldContainer \"  )  ;", "}", "BeanDeploymentArchive   beanDeploymentArchive    =    beanDeploymentArchives . get ( beanArchiveId )  ;", "if    ( beanDeploymentArchive    =  =    null )     {", "throw   WeldLogger . ROOT _ LOGGER . beanDeploymentNotFound ( beanArchiveId )  ;", "}", "return   b . getManager ( beanDeploymentArchive )  ;", "}", "METHOD_END"], "methodName": ["getBeanManager"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   bootstrap ;", "}", "METHOD_END"], "methodName": ["getBootstrap"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   deployment ;", "}", "METHOD_END"], "methodName": ["getDeployment"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentName ;", "}", "METHOD_END"], "methodName": ["getDeploymentName"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   executorServices ;", "}", "METHOD_END"], "methodName": ["getExecutorServices"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   securityServices ;", "}", "METHOD_END"], "methodName": ["getSecurityServices"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   serverExecutor ;", "}", "METHOD_END"], "methodName": ["getServerExecutor"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   weldTransactionServices ;", "}", "METHOD_END"], "methodName": ["getWeldTransactionServices"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   started ;", "}", "METHOD_END"], "methodName": ["isStarted"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "this . started    =    started ;", "}", "METHOD_END"], "methodName": ["setStarted"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "if    ( started )     {", "throw   WeldLogger . ROOT _ LOGGER . alreadyRunning (  \" WeldContainer \"  )  ;", "}", "started    =    true ;", "WeldLogger . DEPLOYMENT _ LOGGER . startingWeldService ( deploymentName )  ;", "addWeldService ( SecurityServices . class ,    securityServices . getValue (  )  )  ;", "TransactionServices   transactionServices    =    weldTransactionServices . getOptionalValue (  )  ;", "if    ( transactionServices    !  =    null )     {", "addWeldService ( TransactionServices . class ,    transactionServices )  ;", "}", "if    (  !  ( deployment . getServices (  )  . contains ( ExecutorServices . class )  )  )     {", "addWeldService ( ExecutorServices . class ,    executorServices . getValue (  )  )  ;", "}", "ModuleGroupSingletonProvider . addClassLoaders ( deployment . getModule (  )  . getClassLoader (  )  ,    deployment . getSubDeploymentClassLoaders (  )  )  ;", "ClassLoader   oldTccl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule (  )  . getClassLoader (  )  )  ;", "b . startContainer ( deploymentName ,    environment ,    deployment )  ;", "WeldProvider . containerInitialized ( Container . instance ( deploymentName )  ,    getBeanManager (  )  ,    deployment )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "if    ( started )     {", "final   Container   container    =    Container . instance ( deploymentName )  ;", "if    (  ( container    !  =    null )     &  &     (  !  ( SHUTDOWN . equals ( container . getState (  )  )  )  )  )     {", "final   Executor   executor    =    serverExecutor . getValue (  )  ;", "final   Runnable   task    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "WeldLogger . DEPLOYMENT _ LOGGER . debugf (  \" Weld   container   cleanup   for   deployment    % s \"  ,    deploymentName )  ;", "ClassLoader   oldTccl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule (  )  . getClassLoader (  )  )  ;", "WeldProvider . containerShutDown ( container )  ;", "container . setState ( SHUTDOWN )  ;", "container . cleanup (  )  ;", "setStarted ( false )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "ModuleGroupSingletonProvider . removeClassLoader ( deployment . getModule (  )  . getClassLoader (  )  )  ;", "context . complete (  )  ;", "}", "}", "}  ;", "try    {", "executor . execute ( task )  ;", "}    catch    ( RejectedExecutionException   e )     {", "task . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.weld.WeldBootstrapService"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder ( WeldExtension . SUBSYSTEM _ NAME )  ;", "for    ( String   kp    :    keyPrefix )     {", "prefix . append (  '  .  '  )  . append ( kp )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,    WeldExtension . RESOURCE _ NAME ,    WeldExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.weld.WeldExtension"}, {"methodBody": ["METHOD_START", "{", "return   developmentMode ;", "}", "METHOD_END"], "methodName": ["getDevelopmentMode"], "fileName": "org.jboss.as.weld.WeldJBossAllConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   nonPortableMode ;", "}", "METHOD_END"], "methodName": ["getNonPortableMode"], "fileName": "org.jboss.as.weld.WeldJBossAllConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   requireBeanDescriptor ;", "}", "METHOD_END"], "methodName": ["getRequireBeanDescriptor"], "fileName": "org.jboss.as.weld.WeldJBossAllConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . classes . put ( clazz . getName (  )  ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["addAdditionalClass"], "fileName": "org.jboss.as.weld.WeldModuleResourceLoader"}, {"methodBody": ["METHOD_START", "{", "ContainerState   state    =    container . getState (  )  ;", "if    (  ( state . equals ( STOPPED )  )     |  |     ( state . equals ( SHUTDOWN )  )  )     {", "throw   LOG . beanManagerNotAvailable (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkContainerState"], "fileName": "org.jboss.as.weld.WeldProvider"}, {"methodBody": ["METHOD_START", "{", "WeldProvider . containers . put ( container ,    new   WeldProvider . CdiImpl ( container ,    new   BeanManagerProxy ( rootBeanManager )  ,    deployment )  )  ;", "}", "METHOD_END"], "methodName": ["containerInitialized"], "fileName": "org.jboss.as.weld.WeldProvider"}, {"methodBody": ["METHOD_START", "{", "WeldProvider . containers . remove ( container )  ;", "}", "METHOD_END"], "methodName": ["containerShutDown"], "fileName": "org.jboss.as.weld.WeldProvider"}, {"methodBody": ["METHOD_START", "{", "return   bootstrap ;", "}", "METHOD_END"], "methodName": ["getBootstrap"], "fileName": "org.jboss.as.weld.WeldStartCompletionService"}, {"methodBody": ["METHOD_START", "{", "return   bootstrap ;", "}", "METHOD_END"], "methodName": ["getBootstrap"], "fileName": "org.jboss.as.weld.WeldStartService"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   jtsNode    =    context . readResourceFromRoot ( PathAddress . pathAddress (  \" subsystem \"  ,     \" transactions \"  )  ,    false )  . getModel (  )  . get (  \" jts \"  )  ;", "return   jtsNode . isDefined (  )     ?    jtsNode . asBoolean (  )     :    false ;", "}", "METHOD_END"], "methodName": ["checkJtsEnabled"], "fileName": "org.jboss.as.weld.WeldSubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "builder . createLegacyKernelServicesBuilder ( MANAGEMENT ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - weld :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( mainServices . getLegacyServices ( modelVersion )  . isSuccessfulBoot (  )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    parse ( getSubsystemXml (  \" subsystem - reject . xml \"  )  )  ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( WeldExtension . PATH _ SUBSYSTEM )  ,    ChainedConfig . createBuilder ( WeldResourceDefinition . NON _ PORTABLE _ MODE _ ATTRIBUTE ,    WeldResourceDefinition . REQUIRE _ BEAN _ DESCRIPTOR _ ATTRIBUTE )  . addConfig ( new    . FalseOrUndefinedToTrueConfig ( WeldResourceDefinition . NON _ PORTABLE _ MODE _ ATTRIBUTE ,    WeldResourceDefinition . REQUIRE _ BEAN _ DESCRIPTOR _ ATTRIBUTE )  )  . addConfig ( new   NewAttributesConfig ( WeldResourceDefinition . DEVELOPMENT _ MODE _ ATTRIBUTE )  )  . addConfig ( new   NewAttributesConfig ( WeldResourceDefinition . THREAD _ POOL _ SIZE _ ATTRIBUTE )  )  . build (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectTransformers10"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  1  _  0  . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSubsystem10"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  2  _  0  . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSubsystem20"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  3  _  0  . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSubsystem30"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXmlResource (  \" subsystem _  3  _  0  - transformers . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( MANAGEMENT ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - weld :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformers10"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  0  ( EAP _  6  _  2  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersASEAP620"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  0  ( EAP _  6  _  3  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersASEAP630"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  0  ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersASEAP640"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  3  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXmlResource (  \" subsystem _  4  _  0  - transformers . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( MANAGEMENT ,    EAP _  7  _  0  _  0  ,    modelVersion )  . addMavenResourceURL (  (  \" eap : wildfly - weld :  \"     +     ( EAP _  7  _  0  _  0  . getMavenGavVersion (  )  )  )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP70"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectTransformers 1  0  ( EAP _  6  _  2  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersRejectionASEAP620"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectTransformers 1  0  ( EAP _  6  _  3  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersRejectionASEAP630"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectTransformers 1  0  ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersRejectionASEAP640"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  3  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "builder . createLegacyKernelServicesBuilder ( MANAGEMENT ,    EAP _  7  _  0  _  0  ,    modelVersion )  . addMavenResourceURL (  (  \" eap : wildfly - weld :  \"     +     ( EAP _  7  _  0  _  0  . getMavenGavVersion (  )  )  )  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( modelVersion )  . isSuccessfulBoot (  )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    parse ( getSubsystemXml (  \" subsystem - reject . xml \"  )  )  ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( WeldExtension . PATH _ SUBSYSTEM )  ,    ChainedConfig . createBuilder ( WeldResourceDefinition . NON _ PORTABLE _ MODE _ ATTRIBUTE ,    WeldResourceDefinition . REQUIRE _ BEAN _ DESCRIPTOR _ ATTRIBUTE )  . addConfig ( new   model . test . FailedOperationTransformationConfig . NewAttributesConfig ( WeldResourceDefinition . THREAD _ POOL _ SIZE _ ATTRIBUTE )  )  . build (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersRejectionEAP700"], "fileName": "org.jboss.as.weld.WeldSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   BeanManager   manager    =     (  ( BeanManager )     ( new   InitialContext (  )  . lookup (  . STANDARD _ BEAN _ MANAGER _ JNDI _ NAME )  )  )  ;", "if    (  ( manager    !  =    null )     &  &     ( Container . available (  )  )  )     {", "final   Bean < BoundSessionContext >    sessionContextBean    =     (  ( Bean < BoundSessionContext >  )     ( manager . resolve ( manager . getBeans ( BoundSessionContext . class ,    INSTANCE )  )  )  )  ;", "CreationalContext <  ?  >    ctx    =    manager . createCreationalContext ( sessionContextBean )  ;", "final   BoundSessionContext   sessionContext    =     (  ( BoundSessionContext )     ( manager . getReference ( sessionContextBean ,    BoundSessionContext . class ,    ctx )  )  )  ;", "sessionContext . associate ( sessionContexts . get (  )  )  ;", "sessionContext . activate (  )  ;", "final   Bean < BoundRequestContext >    requestContextBean    =     (  ( Bean < BoundRequestContext >  )     ( manager . resolve ( manager . getBeans ( BoundRequestContext . class ,    INSTANCE )  )  )  )  ;", "ctx    =    manager . createCreationalContext ( requestContextBean )  ;", "final   BoundRequestContext   requestContext    =     (  ( BoundRequestContext )     ( manager . getReference ( requestContextBean ,    BoundRequestContext . class ,    ctx )  )  )  ;", "requestContext . associate ( requestContexts . get (  )  )  ;", "requestContext . activate (  )  ;", "final   Bean < BoundConversationContext >    conversationContextBean    =     (  ( Bean < BoundConversationContext >  )     ( manager . resolve ( manager . getBeans ( BoundConversationContext . class ,    INSTANCE )  )  )  )  ;", "ctx    =    manager . createCreationalContext ( conversationContextBean )  ;", "final   BoundConversationContext   conversationContext    =     (  ( BoundConversationContext )     ( manager . getReference ( conversationContextBean ,    BoundConversationContext . class ,    ctx )  )  )  ;", "BoundRequest   request    =    new   MutableBoundRequest ( requestContexts . get (  )  ,    sessionContexts . get (  )  )  ;", "boundRequests . set ( request )  ;", "conversationContext . associate ( request )  ;", "conversationContext . activate (  )  ;", "}", "}    catch    ( NamingException   e )     {", "WeldLogger . ROOT _ LOGGER . failedToSetupWeldContexts ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.jboss.as.weld.arquillian.WeldContextSetup"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   BeanManager   manager    =     (  ( BeanManager )     ( new   InitialContext (  )  . lookup (  \" java : comp / BeanManager \"  )  )  )  ;", "if    (  ( manager    !  =    null )     &  &     ( Container . available (  )  )  )     {", "final   Bean < BoundSessionContext >    sessionContextBean    =     (  ( Bean < BoundSessionContext >  )     ( manager . resolve ( manager . getBeans ( BoundSessionContext . class ,    INSTANCE )  )  )  )  ;", "CreationalContext <  ?  >    ctx    =    manager . createCreationalContext ( sessionContextBean )  ;", "final   BoundSessionContext   sessionContext    =     (  ( BoundSessionContext )     ( manager . getReference ( sessionContextBean ,    BoundSessionContext . class ,    ctx )  )  )  ;", "sessionContext . invalidate (  )  ;", "sessionContext . deactivate (  )  ;", "sessionContext . dissociate ( sessionContexts . get (  )  )  ;", "final   Bean < BoundRequestContext >    requestContextBean    =     (  ( Bean < BoundRequestContext >  )     ( manager . resolve ( manager . getBeans ( BoundRequestContext . class ,    INSTANCE )  )  )  )  ;", "ctx    =    manager . createCreationalContext ( requestContextBean )  ;", "final   BoundRequestContext   requestContext    =     (  ( BoundRequestContext )     ( manager . getReference ( requestContextBean ,    BoundRequestContext . class ,    ctx )  )  )  ;", "requestContext . invalidate (  )  ;", "requestContext . deactivate (  )  ;", "requestContext . dissociate ( requestContexts . get (  )  )  ;", "final   Bean < BoundConversationContext >    conversationContextBean    =     (  ( Bean < BoundConversationContext >  )     ( manager . resolve ( manager . getBeans ( BoundConversationContext . class ,    INSTANCE )  )  )  )  ;", "ctx    =    manager . createCreationalContext ( conversationContextBean )  ;", "final   BoundConversationContext   conversationContext    =     (  ( BoundConversationContext )     ( manager . getReference ( conversationContextBean ,    BoundConversationContext . class ,    ctx )  )  )  ;", "conversationContext . invalidate (  )  ;", "conversationContext . deactivate (  )  ;", "conversationContext . dissociate ( boundRequests . get (  )  )  ;", "}", "}    catch    ( NamingException   e )     {", "WeldLogger . ROOT _ LOGGER . failedToTearDowns ( e )  ;", "}    finally    {", "sessionContexts . remove (  )  ;", "requestContexts . remove (  )  ;", "boundRequests . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.jboss.as.weld.arquillian.WeldContextSetup"}, {"methodBody": ["METHOD_START", "{", "this . resourceLoader . addAdditionalClass ( clazz )  ;", "}", "METHOD_END"], "methodName": ["addBeanClass"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "this . beanClasses . add ( clazz )  ;", "this . allKnownClasses . add ( clazz )  ;", "}", "METHOD_END"], "methodName": ["addBeanClass"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( archive    =  =     ( this )  )     {", "return ;", "}", "bs . add ( archive )  ;", "}", "METHOD_END"], "methodName": ["addBeanDeploymentArchive"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDeploymentArchive   bda    :    archives )     {", "if    ( bda    !  =     ( this )  )     {", "beanDeploymentArchives . add ( bda )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBeanDeploymentArchives"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "ejbDescriptors . add ( descriptor )  ;", "}", "METHOD_END"], "methodName": ["addEjbDescriptor"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "return   beanArchiveType ;", "}", "METHOD_END"], "methodName": ["getBeanArchiveType"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( module )     !  =    null )     {", "if    ( WiFlySecurityManager . isChecking (  )  )     {", "return   WiFlySecurityManager . doUnchecked ( new   PrivilegedAction < ClassLoader >  (  )     {", "@ Override", "public   ClassLoader   run (  )     {", "return   module . getClassLoader (  )  ;", "}", "}  )  ;", "} else    {", "return   module . getClassLoader (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "return   module ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    target )     {", "return   true ;", "}", "that    =     (  (  )     ( target )  )  ;", "if    (  ( that . getModule (  )  )     =  =    null )     {", "return   true ;", "}", "if    (  ( module )     =  =    null )     {", "return    ( that . getModule (  )  )     =  =    null ;", "}", "if    ( module . equals ( that . getModule (  )  )  )     {", "return   true ;", "}", "for    ( DependencySpec   dependency    :    module . getDependencies (  )  )     {", "if    ( dependency   instanceof   ModuleDependencySpec )     {", "ModuleDependencySpec   moduleDependency    =     (  ( ModuleDependencySpec )     ( dependency )  )  ;", "if    ( moduleDependency . getIdentifier (  )  . equals ( that . getModule (  )  . getIdentifier (  )  )  )     {", "return   true ;", "}", "}", "}", "Iterator < String >    iterator    =    target . getBeanClasses (  )  . iterator (  )  ;", "if    ( iterator . hasNext (  )  )     {", "Class <  ?  >    clazz    =    Reflections . loadClass ( iterator . next (  )  ,    module . getClassLoader (  )  )  ;", "if    ( clazz    !  =    null )     {", "Module   classModule    =    Module . forClass ( clazz )  ;", "return    ( classModule    !  =    null )     &  &     ( classModule . equals ( that . getModule (  )  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["isRoot"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentArchiveImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDeploymentArchiveImpl   bda    :    beanDeploymentArchives )     {", "bda . addBeanDeploymentArchive ( archive )  ;", "}", "}", "METHOD_END"], "methodName": ["addBeanDeploymentArchive"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentModule"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDeploymentArchiveImpl   bda    :    beanDeploymentArchives )     {", "bda . addBeanDeploymentArchives ( module . beanDeploymentArchives )  ;", "}", "}", "METHOD_END"], "methodName": ["addBeanDeploymentModule"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentModule"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDeploymentArchiveImpl   bda    :    beanDeploymentArchives )     {", "for    (    bdm    :    modules )     {", "bda . addBeanDeploymentArchives ( bdm . beanDeploymentArchives )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBeanDeploymentModules"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentModule"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDeploymentArchiveImpl   bda    :    beanDeploymentArchives )     {", "bda . getServices (  )  . add ( clazz ,    service )  ;", "}", "}", "METHOD_END"], "methodName": ["addService"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentModule"}, {"methodBody": ["METHOD_START", "{", "return   beanDeploymentArchives ;", "}", "METHOD_END"], "methodName": ["getBeanDeploymentArchives"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentModule"}, {"methodBody": ["METHOD_START", "{", "return   moduleDescriptor ;", "}", "METHOD_END"], "methodName": ["getModuleDescriptor"], "fileName": "org.jboss.as.weld.deployment.BeanDeploymentModule"}, {"methodBody": ["METHOD_START", "{", "Boolean   val    =    Utils . getRootDeploymentUnit ( deploymentUnit )  . getAttachment ( CdiAnnotationMarker . ATTACHMENT _ KEY )  ;", "return    ( val    !  =    null )     &  &    val ;", "}", "METHOD_END"], "methodName": ["cdiAnnotationsPresent"], "fileName": "org.jboss.as.weld.deployment.CdiAnnotationMarker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( deployment . getParent (  )  )     !  =    null )     {", "deployment . getParent (  )  . putAttachment (  . ATTACHMENT _ KEY ,    true )  ;", "} else    {", "deployment . putAttachment (  . ATTACHMENT _ KEY ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["mark"], "fileName": "org.jboss.as.weld.deployment.CdiAnnotationMarker"}, {"methodBody": ["METHOD_START", "{", "return   additionalBeansXmlFile ;", "}", "METHOD_END"], "methodName": ["getAdditionalBeansXmlFile"], "fileName": "org.jboss.as.weld.deployment.ExplicitBeanArchiveMetadata"}, {"methodBody": ["METHOD_START", "{", "return   beansXml ;", "}", "METHOD_END"], "methodName": ["getBeansXml"], "fileName": "org.jboss.as.weld.deployment.ExplicitBeanArchiveMetadata"}, {"methodBody": ["METHOD_START", "{", "return   beansXmlFile ;", "}", "METHOD_END"], "methodName": ["getBeansXmlFile"], "fileName": "org.jboss.as.weld.deployment.ExplicitBeanArchiveMetadata"}, {"methodBody": ["METHOD_START", "{", "return   resourceRoot ;", "}", "METHOD_END"], "methodName": ["getResourceRoot"], "fileName": "org.jboss.as.weld.deployment.ExplicitBeanArchiveMetadata"}, {"methodBody": ["METHOD_START", "{", "return   deploymentRoot ;", "}", "METHOD_END"], "methodName": ["isDeploymentRoot"], "fileName": "org.jboss.as.weld.deployment.ExplicitBeanArchiveMetadata"}, {"methodBody": ["METHOD_START", "{", "return   beanArchiveMetadata ;", "}", "METHOD_END"], "methodName": ["getBeanArchiveMetadata"], "fileName": "org.jboss.as.weld.deployment.ExplicitBeanArchiveMetadataContainer"}, {"methodBody": ["METHOD_START", "{", "return   new   PropertyReplacingBeansXmlHandler ( beansXml ,    replacer )  ;", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "org.jboss.as.weld.deployment.PropertyReplacingBeansXmlParser"}, {"methodBody": ["METHOD_START", "{", "return   beanManager ;", "}", "METHOD_END"], "methodName": ["getBeanManager"], "fileName": "org.jboss.as.weld.deployment.WeldClassIntrospector"}, {"methodBody": ["METHOD_START", "{", "InjectionTarget <  ?  >    target    =    injectionTargets . get ( clazz )  ;", "if    ( target    !  =    null )     {", "return   target ;", "}", "final   BeanManagerImpl   beanManager    =    BeanManagerProxy . unwrap ( this . beanManager . getValue (  )  )  ;", "Bean <  ?  >    bean    =    null ;", "Set < Bean <  ?  >  >    beans    =    new   HashSet ( beanManager . getBeans ( clazz ,    INSTANCE )  )  ;", "Iterator < Bean <  ?  >  >    it    =    beans . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "Bean <  ?  >    b    =    it . next (  )  ;", "if    (  ( b . getBean (  )  )     !  =    clazz )     {", "it . remove (  )  ;", "}", "}", "if    (  ( beans . size (  )  )     =  =     1  )     {", "bean    =    beans . iterator (  )  . next (  )  ;", "}", "InjectionTarget <  ?  >    newTarget    =    InjectionTargets . createInjectionTarget ( clazz ,    bean ,    beanManager ,    true )  ;", "target    =    injectionTargets . putIfAbsent ( clazz ,    newTarget )  ;", "if    ( target    =  =    null )     {", "return   newTarget ;", "} else    {", "return   target ;", "}", "}", "METHOD_END"], "methodName": ["getInjectionTarget"], "fileName": "org.jboss.as.weld.deployment.WeldClassIntrospector"}, {"methodBody": ["METHOD_START", "{", "final   WeldClassIntrospector   introspector    =    new   WeldClassIntrospector (  )  ;", "serviceTarget . addService ( WeldClassIntrospector . serviceName ( deploymentUnit )  ,    introspector )  . addDependency ( BeanManagerService . serviceName ( deploymentUnit )  ,    BeanManager . class ,    introspector . beanManager )  . addDependency ( Utils . getRootDeploymentUnit ( deploymentUnit )  . getServiceName (  )  . append ( WeldStartService . SERVICE _ NAME )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["install"], "fileName": "org.jboss.as.weld.deployment.WeldClassIntrospector"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append ( WeldClassIntrospector . SERVICE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["serviceName"], "fileName": "org.jboss.as.weld.deployment.WeldClassIntrospector"}, {"methodBody": ["METHOD_START", "{", "serviceRegistry . add ( type ,    service )  ;", "for    ( BeanArchiveImpl   bda    :    additionalBeanArchivesByClassloader . values (  )  )     {", "bda . getServices (  )  . add ( type ,    service )  ;", "}", "}", "METHOD_END"], "methodName": ["addWeldService"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDeploymentArchiveImpl   from    :    beanDeploymentArchives )     {", "for    ( BeanDeploymentArchiveImpl   target    :    beanDeploymentArchives )     {", "if    ( from . isAccessible ( target )  )     {", "from . addBeanDeploymentArchive ( target )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["calculateAccessibilityGraph"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "String   id    =    null ;", "if    ( module    =  =    null )     {", "id    =     . BOOTSTRAP _ CLASSLOADER _ BDA _ ID ;", "} else    {", "id    =     ( module . getIdentifier (  )  )     +     (  . ADDITIONAL _ CLASSES _ BDA _ SUFFIX )  ;", "}", "BeanDeploymentArchiveImpl   newBda    =    new   BeanDeploymentArchiveImpl ( Collections . singleton ( beanClass . getName (  )  )  ,    Collections . singleton ( beanClass . getName (  )  )  ,    BeansXml . EMPTY _ BEANS _ XML ,    module ,    id ,    BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC ,    false )  ;", "WeldLogger . DEPLOYMENT _ LOGGER . beanArchiveDiscovered ( newBda )  ;", "newBda . addBeanClass ( beanClass )  ;", "ServiceRegistry   newBdaServices    =    newBda . getServices (  )  ;", "for    ( Map . Entry < Class <  ?    extends   Service >  ,    Service >    entry    :    serviceRegistry . entrySet (  )  )     {", "if    (  !  ( newBdaServices . contains ( entry . getKey (  )  )  )  )     {", "newBdaServices . add ( entry . getKey (  )  ,    Reflections . cast ( entry . getValue (  )  )  )  ;", "}", "}", "if    ( module    =  =    null )     {", "newBdaServices . add ( ResourceLoader . class ,    serviceRegistry . get ( ResourceLoader . class )  )  ;", "}", "if    (  ( module    !  =    null )     &  &     ( eeModuleDescriptors . containsKey ( module . getIdentifier (  )  )  )  )     {", "newBda . getServices (  )  . add ( EEModuleDescriptor . class ,    eeModuleDescriptors . get ( module . getIdentifier (  )  )  )  ;", "}", "for    ( BeanDeploymentArchiveImpl   bda    :    beanDeploymentArchives )     {", "if    ( newBda . isAccessible ( bda )  )     {", "newBda . addBeanDeploymentArchive ( bda )  ;", "}", "}", "for    ( BeanDeploymentArchiveImpl   bda    :    beanDeploymentArchives )     {", "if    ( bda . isAccessible ( newBda )  )     {", "bda . addBeanDeploymentArchive ( newBda )  ;", "}", "}", "newBda . addBeanDeploymentArchives ( rootBeanDeploymentModule . getBeanDeploymentArchives (  )  )  ;", "final   ClassLoader   cl    =    beanClass . getClassLoader (  )  ;", "if    ( cl    !  =    null )     {", "additionalBeanDeploymentArchivesByClassloader . put ( cl ,    newBda )  ;", "}", "beanDeploymentArchives . add ( newBda )  ;", "return   newBda ;", "}", "METHOD_END"], "methodName": ["createAndRegisterAdditionalBeanDeploymentArchive"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( new   HashSet < BeanDeploymentArchive >  ( beanDeploymentArchives )  )  ;", "}", "METHOD_END"], "methodName": ["getBeanDeploymentArchives"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( extensions )  ;", "}", "METHOD_END"], "methodName": ["getExtensions"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "return   module ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "return   serviceRegistry ;", "}", "METHOD_END"], "methodName": ["getServices"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( subDeploymentClassLoaders )  ;", "}", "METHOD_END"], "methodName": ["getSubDeploymentClassLoaders"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "final   BeanDeploymentArchive   bda    =    this . getBeanDeploymentArchive ( beanClass )  ;", "if    ( bda    !  =    null )     {", "return   bda ;", "}", "Module   module    =    Module . forClass ( beanClass )  ;", "if    ( module    =  =    null )     {", "if    (  ( bootstrapClassLoaderBeanDeploymentArchive )     =  =    null )     {", "bootstrapClassLoaderBeanDeploymentArchive    =    createAndRegisterAdditionalBeanDeploymentArchive ( module ,    beanClass )  ;", "} else    {", "bootstrapClassLoaderBeanDeploymentArchive . addBeanClass ( beanClass )  ;", "}", "return   bootstrapClassLoaderBeanDeploymentArchive ;", "}", "return   createAndRegisterAdditionalBeanDeploymentArchive ( module ,    beanClass )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDeploymentArchive"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDeploymentArchiveImpl   bda    :    beanDeploymentArchives )     {", "if    (  ( bda . getBeanArchiveType (  )  . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . EXTERNAL )  )     |  |     ( bda . getBeanArchiveType (  )  . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC )  )  )     {", "for    ( BeanDeploymentArchiveImpl   topLevelBda    :    rootBeanDeploymentModule . getBeanDeploymentArchives (  )  )     {", "bda . addBeanDeploymentArchive ( topLevelBda )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["makeTopLevelBdasVisibleFromStaticModules"], "fileName": "org.jboss.as.weld.deployment.WeldDeployment"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentType   deploymentType    =    deploymentUnit . getAttachment ( DEPLOYMENT _ TYPE )  ;", "if    ( deploymentType    =  =    null )     {", "if    ( EjbDeploymentMarker . isEjbDeployment ( deploymentUnit )  )     {", "return   new    ( id ,    ModuleType . EJB _ JAR )  ;", "}", "return   null ;", "}", "switch    ( deploymentType )     {", "case   WAR    :", "return   new    ( id ,    ModuleType . WEB )  ;", "case   EAR    :", "return   new    ( id ,    ModuleType . EAR )  ;", "case   EJB _ JAR    :", "return   new    ( id ,    ModuleType . EJB _ JAR )  ;", "case   APPLICATION _ CLIENT    :", "return   new    ( id ,    ModuleType . APPLICATION _ CLIENT )  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unknown   deployment   type    \"     +    deploymentType )  )  ;", "}", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.jboss.as.weld.deployment.WeldEEModuleDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   HashSet ( extensions . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getExtensions"], "fileName": "org.jboss.as.weld.deployment.WeldPortableExtensions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "pes    =    deploymentUnit . getAttachment (  . ATTACHMENT _ KEY )  ;", "if    ( pes    =  =    null )     {", "deploymentUnit . putAttachment (  . ATTACHMENT _ KEY ,     ( pes    =    new    (  )  )  )  ;", "}", "return   pes ;", "} else    {", "return    . getPortableExtensions ( deploymentUnit . getParent (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPortableExtensions"], "fileName": "org.jboss.as.weld.deployment.WeldPortableExtensions"}, {"methodBody": ["METHOD_START", "{", "extensions . put ( extension . getClass (  )  ,    new   MetadataImpl ( extension ,    deploymentUnit . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerExtensionInstance"], "fileName": "org.jboss.as.weld.deployment.WeldPortableExtensions"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Extension . class . isAssignableFrom ( extensionClass )  )  )     {", "throw   WeldLogger . ROOT _ LOGGER . extensionDoesNotImplementExtension ( extensionClass )  ;", "}", "if    ( extensions . containsKey ( extensionClass )  )     {", "return ;", "}", "try    {", "extensions . put ( extensionClass ,    new   MetadataImpl (  (  ( Extension )     ( extensionClass . newInstance (  )  )  )  ,    deploymentUnit . getName (  )  )  )  ;", "}    catch    ( Exception   e )     {", "WeldLogger . DEPLOYMENT _ LOGGER . couldNotLoaceptionClass ( extensionClass . getName (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["tryRegisterExtension"], "fileName": "org.jboss.as.weld.deployment.WeldPortableExtensions"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . addToAttachmentList ( WeldAttachments . BEAN _ DEFINING _ ANNOTATIONS ,    annotation )  ;", "}", "METHOD_END"], "methodName": ["addAnnotation"], "fileName": "org.jboss.as.weld.deployment.processors.BeanDefiningAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( AnnotationType   annotation    :    annotations )     {", ". addAnnotation ( deploymentUnit ,    annotation )  ;", "}", "}", "METHOD_END"], "methodName": ["addAnnotations"], "fileName": "org.jboss.as.weld.deployment.processors.BeanDefiningAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "Set < AnnotationType >    annotations    =    new   HashSet <  >  (  )  ;", "for    ( ClassInfo   classInfo    :    Indices . getAnnotatedClasses ( index . getAnnotations ( annotationName )  )  )     {", "if    ( Indices . ANNOTATION _ PREDICATE . test ( classInfo )  )     {", "annotations . add ( AnnotationType . FOR _ CLASSINFO . apply ( classInfo )  )  ;", "}", "}", "return   annotations ;", "}", "METHOD_END"], "methodName": ["getAnnotationsAnnotatedWith"], "fileName": "org.jboss.as.weld.deployment.processors.BeanDefiningAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   parser . parse ( beansXmlFile . asFileURL (  )  )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   WeldLogger . ROOT _ LOGGER . couldNotGetBeansXmlAsURL ( beansXmlFile . toString (  )  ,    e )  ;", "}    catch    ( RuntimeException   e )     {", "throw   new   DUnitProcessingException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["parseBeansXml"], "fileName": "org.jboss.as.weld.deployment.processors.BeansXmlProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( webMetaData . getFilters (  )  )     =  =    null )     {", "webMetaData . setFilters ( new   FiltersMetaData (  )  )  ;", "}", "if    (  ( webMetaData . getFilterMappings (  )  )     =  =    null )     {", "webMetaData . setFilterMappings ( new   ArrayList < FilterMappingMetaData >  (  )  )  ;", "}", "webMetaData . getFilters (  )  . add (  . PROBE _ FILTER )  ;", "webMetaData . getFilterMappings (  )  . add (  0  ,     . PROBE _ FILTER _ MAPPING )  ;", "Utils . registerAsComponent (  . PROBE _ FILTER _ CLASS _ NAME ,    deploymentUnit )  ;", "}", "METHOD_END"], "methodName": ["registerProbeFilter"], "fileName": "org.jboss.as.weld.deployment.processors.DevelopmentModeProcessor"}, {"methodBody": ["METHOD_START", "{", "List < String >    discoveredBeanClasses    =    new   ArrayList < String >  (  )  ;", "List < String >    allKnownClasses    =    new   ArrayList < String >  (  )  ;", "BiConsumer < String ,    UrlScanner . ClassFile >    consumer ;", "if    ( ANNOTATED . equals ( beanDiscoveryMode )  )     {", "Index   index    =    tryLoadIndex ( indexUrl )  ;", "if    ( index    !  =    null )     {", "consumer    =     (    name ,    classFile )     -  >     {", "ClassInfo   classInfo    =    index . getClassByName ( DotName . createSimple ( name )  )  ;", "allKnownClasses . add ( name )  ;", "if    (  ( classInfo    !  =    null )     &  &     ( hasBeanDefiningAnnotation ( classInfo ,    beanDefiningAnnotations )  )  )     {", "discoveredBeanClasses . add ( name )  ;", "}", "}  ;", "} else    {", "Indexer   indexer    =    new   Indexer (  )  ;", "consumer    =     (    name ,    classFile )     -  >     {", "try    ( InputStream   in    =    classFile . openStream (  )  )     {", "ClassInfo   classInfo    =    indexer . index ( in )  ;", "allKnownClasses . add ( name )  ;", "if    (  ( classInfo    !  =    null )     &  &     ( hasBeanDefiningAnnotation ( classInfo ,    beanDefiningAnnotations )  )  )     {", "discoveredBeanClasses . add ( name )  ;", "}", "}    catch    ( IOException   e )     {", "WeldLogger . DEPLOYMENT _ LOGGER . cannotIndexClassName ( name ,    beansXmlUrl )  ;", "}", "}  ;", "}", "} else    {", "consumer    =     (    name ,    classFile )     -  >     {", "allKnownClasses . add ( name )  ;", "discoveredBeanClasses . add ( name )  ;", "}  ;", "}", "Map < String ,    List < String >  >    result    =    new   HashMap <  >  (  )  ;", "result . put ( ALL _ KNOWN _ CLASSES ,    allKnownClasses )  ;", "result . put ( BEAN _ CLASSES ,    discoveredBeanClasses )  ;", "UrlScanner   scanner    =    new   UrlScanner ( beansXmlUrl ,    consumer )  ;", "return   scanner . scan (  )     ?    result    :    null ;", "}", "METHOD_END"], "methodName": ["discover"], "fileName": "org.jboss.as.weld.deployment.processors.ExternalBeanArchiveProcessor"}, {"methodBody": ["METHOD_START", "{", "Enumeration < URL >    exported    =    dependencyModule . getExportedResources ( name )  ;", "return   new   HashSet <  >  ( Collections . list ( exported )  )  ;", "}", "METHOD_END"], "methodName": ["findExportedResource"], "fileName": "org.jboss.as.weld.deployment.processors.ExternalBeanArchiveProcessor"}, {"methodBody": ["METHOD_START", "{", "Set < URL >    beanXmls    =    findExportedResource ( dependencyModule ,    ExternalBeanArchiveProcessor . META _ INF _ BEANS _ XML )  ;", "if    ( beanXmls . isEmpty (  )  )     {", "return   Collections . emptyMap (  )  ;", "}", "Set < URL >    indexes    =    findExportedResource ( dependencyModule ,    ExternalBeanArchiveProcessor . META _ INF _ JANDEX _ IDX )  ;", "Map < URL ,    URL >    ret    =    new   HashMap <  >  (  )  ;", "for    ( URL   beansXml    :    beanXmls )     {", "String   urlBase    =    beansXml . toString (  )  . substring (  0  ,     (  ( beansXml . toString (  )  . length (  )  )     -     ( ExternalBeanArchiveProcessor . META _ INF _ BEANS _ XML . length (  )  )  )  )  ;", "URL   idx    =    null ;", "for    ( URL   index    :    indexes )     {", "if    ( index . toString (  )  . startsWith ( urlBase )  )     {", "idx    =    index ;", "break ;", "}", "}", "ret . put ( beansXml ,    idx )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["findExportedResources"], "fileName": "org.jboss.as.weld.deployment.processors.ExternalBeanArchiveProcessor"}, {"methodBody": ["METHOD_START", "{", "Map < DotName ,    List < AnnotationInstance >  >    annotationsMap    =    classInfo . annotations (  )  ;", "for    ( AnnotationType   bDefiningAnnotation    :    bDefiningAnnotations )     {", "List < AnnotationInstance >    annotations    =    annotationsMap . get ( bDefiningAnnotation . getName (  )  )  ;", "if    ( annotations    !  =    null )     {", "for    ( AnnotationInstance   annotationInstance    :    annotations )     {", "if    ( annotationInstance . target (  )  . equals ( classInfo )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasBeanDefiningAnnotation"], "fileName": "org.jboss.as.weld.deployment.processors.ExternalBeanArchiveProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( dep   instanceof   ModuleDependencySpec )     {", "ModuleDependencySpec   dependency    =     (  ( ModuleDependencySpec )     ( dep )  )  ;", "final   ModuleLoader   loader    =    dependency . getModuleLoader (  )  ;", "if    ( loader    !  =    null )     {", "try    {", "return   dependency . getModuleLoader (  )  . loadModule ( dependency . getIdentifier (  )  )  ;", "}    catch    ( ModuleLoadException   e )     {", "return   null ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["loadModuleDependency"], "fileName": "org.jboss.as.weld.deployment.processors.ExternalBeanArchiveProcessor"}, {"methodBody": ["METHOD_START", "{", "return   parser . parse ( beansXmlFile )  ;", "}", "METHOD_END"], "methodName": ["parseBeansXml"], "fileName": "org.jboss.as.weld.deployment.processors.ExternalBeanArchiveProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( indexUrl    =  =    null )     {", "return   null ;", "}", "try    ( InputStream   in    =    indexUrl . openStream (  )  )     {", "return   new   IndexReader ( in )  . read (  )  ;", "}    catch    ( Exception   e )     {", "WeldLogger . DEPLOYMENT _ LOGGER . cannotLoadAnnotationIndexOf ( indexUrl )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["tryLoadIndex"], "fileName": "org.jboss.as.weld.deployment.processors.ExternalBeanArchiveProcessor"}, {"methodBody": ["METHOD_START", "{", "return   filename . substring (  0  ,    filename . lastIndexOf (  \"  . class \"  )  )  . replace (  '  /  '  ,     '  .  '  )  . replace (  '  \\  \\  '  ,     '  .  '  )  ;", "}", "METHOD_END"], "methodName": ["filenameToClassname"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "try    {", "WeldLogger . DEPLOYMENT _ LOGGER . tracef (  \" sing :     % s \"  ,    urlPath )  ;", "if    ( urlPath . startsWith (  \" file :  \"  )  )     {", "urlPath    =    urlPath . substring (  5  )  ;", "}", "if    (  ( urlPath . indexOf (  '  !  '  )  )     >     0  )     {", "urlPath    =    urlPath . substring (  0  ,    urlPath . indexOf (  '  !  '  )  )  ;", "}", "File   file    =    new   File ( urlPath )  ;", "if    ( file . isDirectory (  )  )     {", "handleDirectory ( file ,    null )  ;", "} else    {", "handleArchiveByFile ( file )  ;", "}", "}    catch    ( IOException   ioe )     {", "WeldLogger . DEPLOYMENT _ LOGGER . couldNotReadEntries ( ioe )  ;", "}", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "WeldLogger . DEPLOYMENT _ LOGGER . tracef (  \" scanning :     % s \"  ,    urlPath )  ;", "handleDirectory ( urlPath ,    null )  ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "try    {", "WeldLogger . DEPLOYMENT _ LOGGER . trace (  (  \" archive :     \"     +    file )  )  ;", "try    ( ZipFile   zip    =    new   ZipFile ( file )  )     {", "Enumeration <  ?    extends   ZipEntry >    entries    =    zip . entries (  )  ;", "while    ( entries . hasMoreEles (  )  )     {", "ZipEntry   entry    =    entries . nextEle (  )  ;", "String   name    =    entry . getName (  )  ;", "handleFile ( name ,     (  )     -  >    zip . getInputStream ( entry )  )  ;", "}", "}", "}    catch    ( ZipException   e )     {", "throw   new   RuntimeException (  (  \" Error   handling   file    \"     +    file )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["handleArchiveByFile"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "WeldLogger . DEPLOYMENT _ LOGGER . tracef (  \" handling   directory :     % s \"  ,    file )  ;", "for    ( File   child    :    file . listFiles (  )  )     {", "String   newPath    =     ( path    =  =    null )     ?    child . getName (  )     :     ( path    +     '  /  '  )     +     ( child . getName (  )  )  ;", "if    ( child . isDirectory (  )  )     {", "handleDirectory ( child ,    newPath )  ;", "} else    {", "handleFile ( newPath ,     (  )     -  >    child . toURI (  )  . toURL (  )  . openStream (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleDirectory"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "WeldLogger . DEPLOYMENT _ LOGGER . tracef (  \" handling   directory :     % s \"  ,    file )  ;", "for    ( VirtualFile   child    :    file . getChildren (  )  )     {", "String   newPath    =     ( path    =  =    null )     ?    child . getName (  )     :     ( path    +     '  /  '  )     +     ( child . getName (  )  )  ;", "if    ( child . isDirectory (  )  )     {", "handleDirectory ( child ,    newPath )  ;", "} else    {", "handleFile ( newPath ,     (  )     -  >    file . toURL (  )  . openStream (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleDirectory"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "if    ( name . endsWith (  \"  . class \"  )  )     {", "classConsumer . accept (  . filenameToClassname ( name )  ,    loader )  ;", "}", "}", "METHOD_END"], "methodName": ["handleFile"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "String   urlPath    =    beansXmlUrl . toExternalForm (  )  ;", "String   urlType    =     \" file \"  ;", "int   colonIndex    =    urlPath . indexOf (  \"  :  \"  )  ;", "if    ( colonIndex    !  =     (  -  1  )  )     {", "urlType    =    urlPath . substring (  0  ,    colonIndex )  ;", "}", "if    (  (  \" file \"  . equals ( urlType )  )     |  |     (  \" jar \"  . equals ( urlType )  )  )     {", "urlPath    =    beansXmlUrl . getPath (  )  ;", "if    (  ( urlPath . indexOf (  '  !  '  )  )     >     0  )     {", "urlPath    =    urlPath . substring (  0  ,    urlPath . indexOf (  '  !  '  )  )  ;", "} else    {", "File   dirOrArchive    =    new   File ( urlPath )  ;", "dirOrArchive    =    dirOrArchive . getParentFile (  )  ;", "urlPath    =    dirOrArchive . getParent (  )  ;", "}", "try    {", "urlPath    =    URLDecoder . decode ( urlPath ,     \" UTF -  8  \"  )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "handle ( urlPath )  ;", "return   true ;", "} else", "if    (  \" vfs \"  . equals ( urlType )  )     {", "try    {", "VirtualFile   vfsRoot    =    getChild ( beansXmlUrl )  . getParent (  )  . getParent (  )  ;", "handle ( vfsRoot )  ;", "return   true ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "} else    {", "logging . WeldLogger . DEPLOYMENT _ LOGGER . doNotUnderstandProtocol ( beansXmlUrl )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["scan"], "fileName": "org.jboss.as.weld.deployment.processors.UrlScanner"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   weldStartService    =     (  ( deploymentUnit . getParent (  )  )     !  =    null    ?    deploymentUnit . getParent (  )     :    deploymentUnit )  . getServiceName (  )  . append ( WeldStartService . SERVICE _ NAME )  ;", "warMetaData . addAdditionalDependency ( weldStartService )  ;", "}", "METHOD_END"], "methodName": ["createDependency"], "fileName": "org.jboss.as.weld.deployment.processors.WebIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( ParamValueMetaData   param    :    contextParams )     {", "if    ( parameterName . equals ( param . getParamName (  )  )  )     {", "return ;", "}", "}", "ParamValueMetaData   parameter    =    new   ParamValueMetaData (  )  ;", "parameter . setParamName ( parameterName )  ;", "parameter . setParamValue (  \" false \"  )  ;", "contextParams . add ( parameter )  ;", "}", "METHOD_END"], "methodName": ["setupWeldContextIgnores"], "fileName": "org.jboss.as.weld.deployment.processors.WebIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   beanManagerBindingServiceName    =    contextServiceName . append (  \" BeanManager \"  )  ;", "dependencies . add ( beanManagerBindingServiceName )  ;", "BinderService   beanManagerBindingService    =    new   BinderService (  \" BeanManager \"  )  ;", "final    . BeanManagerManagedReferenceFactory   referenceFactory    =    new    . BeanManagerManagedReferenceFactory (  )  ;", "serviceTarget . addService ( beanManagerBindingServiceName ,    beanManagerBindingService )  . addInjection ( beanManagerBindingService . getManagedObjectInjector (  )  ,    referenceFactory )  . addDependency ( contextServiceName ,    ServiceBasedNamingStore . class ,    beanManagerBindingService . getNamingStoreInjector (  )  )  . addDependency ( beanManagerServiceName ,    BeanManager . class ,    referenceFactory . beanManager )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["bindBeanManager"], "fileName": "org.jboss.as.weld.deployment.processors.WeldBeanManagerServiceProcessor"}, {"methodBody": ["METHOD_START", "{", "configuration . addPreDestroyInterceptor ( Jsr 2  9  9 BindingsInterceptor . factory ( PRE _ DESTROY ,    builder ,    bindingServiceName ,    componentInterceptorSupport )  ,    CDI _ INTERCEPTORS )  ;", "configuration . addAroundConstructInterceptor ( Jsr 2  9  9 BindingsInterceptor . factory ( AROUND _ CONSTRUCT ,    builder ,    bindingServiceName ,    componentInterceptorSupport )  ,    WELD _ AROUND _ CONSTRUCT _ INTERCEPTORS )  ;", "configuration . addPostConstructInterceptor ( Jsr 2  9  9 BindingsInterceptor . factory ( POST _ CONSTRUCT ,    builder ,    bindingServiceName ,    componentInterceptorSupport )  ,    InterceptorOrder . ComponentPostConstruct . CDI _ INTERCEPTORS )  ;", "final   EjbRequestScopeActivationInterceptor . Factory   postConstructRequestContextActivationFactory    =    new   EjbRequestScopeActivationInterceptor . Factory ( beanManagerServiceName )  ;", "configuration . addPostConstructInterceptor ( postConstructRequestContextActivationFactory ,    REQUEST _ SCOPE _ ACTIVATING _ INTERCEPTOR )  ;", "configuration . addAroundConstructInterceptor ( new   ImmediateInterceptorFactory ( WeldConstructionStartInterceptor . INSTANCE )  ,    CONSTRUCTION _ START _ INTERCEPTOR )  ;", "}", "METHOD_END"], "methodName": ["addCommonLifecycleInterceptionSupport"], "fileName": "org.jboss.as.weld.deployment.processors.WeldComponentIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Jsr 2  9  9 BindingsCreateInterceptor   createInterceptor    =    new   Jsr 2  9  9 BindingsCreateInterceptor ( description . getBeanDeploymentArchiveId (  )  ,    beanName ,    componentInterceptorSupport )  ;", "configuration . addPostConstructInterceptor ( new   ImmediateInterceptorFactory ( createInterceptor )  ,    CREATE _ CDI _ INTERCEPTORS )  ;", "builder . addDependency ( weldServiceName ,    WeldBootstrapService . class ,    createInterceptor . getWeldContainer (  )  )  ;", "builder . addDependency ( bindingServiceName ,    InterceptorBindings . class ,    createInterceptor . getInterceptorBindings (  )  )  ;", "}", "METHOD_END"], "methodName": ["addJsr299BindingsCreateInterceptor"], "fileName": "org.jboss.as.weld.deployment.processors.WeldComponentIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    configuration . getComponentDescription (  )  . getServiceName (  )  . append (  \" WeldInstantiator \"  )  ;", "final   WeldComponentService   weldComponentService    =    new   WeldComponentService ( componentClass ,    beanName ,    interceptorClasses ,    classLoader ,    beanDeploymentArchiveId ,    description . isCDIInterceptorEnabled (  )  ,    description ,    isComponentWithView ( description ,    componentIntegrators )  )  ;", "final   ServiceBuilder < WeldComponentService >    builder    =    target . addService ( serviceName ,    weldComponentService )  . addDependency ( weldServiceName ,    WeldBootstrapService . class ,    weldComponentService . getWeldContainer (  )  )  . addDependency ( weldStartService )  ;", "configuration . setInstanceFactory ( WeldManagedReferenceFactory . INSTANCE )  ;", "configuration . getStartDependencies (  )  . add ( new   DependencyConfigurator < ComponentStartService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    ComponentStartService   service )    throws   DeploymentUnitProcessingException    {", "serviceBuilder . addDependency ( serviceName )  ;", "}", "}  )  ;", "boolean   isComponentIntegrationPerformed    =    false ;", "for    ( ComponentIntegrator   componentIntegrator    :    componentIntegrators )     {", "Supplier < ServiceName >    bindingServiceNameSupplier    =     (  )     -  >     {", "if    ( componentInterceptorSupport    =  =    null )     {", "throw   WeldLogger . DEPLOYMENT _ LOGGER . componentInterceptorSupportNotAvailable ( componentClass )  ;", "}", "return    . addWeldInterceptorBindingService ( target ,    configuration ,    componentClass ,    beanName ,    weldServiceName ,    weldStartService ,    beanDeploymentArchiveId ,    componentInterceptorSupport )  ;", "}  ;", "ComponentIntegrator . DefaultInterceptorIntegrationAction   integrationAction    =     (    bindingServiceName )     -  >     {", "if    ( componentInterceptorSupport    =  =    null )     {", "throw   WeldLogger . DEPLOYMENT _ LOGGER . componentInterceptorSupportNotAvailable ( componentClass )  ;", "}", ". addJsr 2  9  9 BindingsCreateInterceptor ( configuration ,    description ,    beanName ,    weldServiceName ,    builder ,    bindingServiceName ,    componentInterceptorSupport )  ;", ". addCommonLifecycleInterceptionSupport ( configuration ,    builder ,    bindingServiceName ,    beanManagerService ,    componentInterceptorSupport )  ;", "configuration . addComponentInterceptor ( new   UserInterceptorFactory ( Jsr 2  9  9 BindingsInterceptor . factory ( AROUND _ INVOKE ,    builder ,    bindingServiceName ,    componentInterceptorSupport )  ,    Jsr 2  9  9 BindingsInterceptor . factory ( AROUND _ TIMEOUT ,    builder ,    bindingServiceName ,    componentInterceptorSupport )  )  ,    CDI _ INTERCEPTORS ,    false )  ;", "}  ;", "if    ( componentIntegrator . integrate ( beanManagerService ,    configuration ,    description ,    builder ,    bindingServiceNameSupplier ,    integrationAction ,    componentInterceptorSupport )  )     {", "isComponentIntegrationPerformed    =    true ;", "break ;", "}", "}", "if    (  ! isComponentIntegrationPerformed )     {", "description . setIgnoreLifecycleInterceptors ( true )  ;", "configuration . addPostConstructInterceptor ( new   ImmediateInterceptorFactory ( new    . AbstractInjectionTargetDelegatingInterceptor (  )     {", "@ Override", "protected   void   run ( Object   instance )     {", "weldComponentService . getInjectionTarget (  )  . postConstruct ( instance )  ;", "}", "}  )  ,    InterceptorOrder . ComponentPostConstruct . CDI _ INTERCEPTORS )  ;", "configuration . addPreDestroyInterceptor ( new   ImmediateInterceptorFactory ( new    . AbstractInjectionTargetDelegatingInterceptor (  )     {", "@ Override", "protected   void   run ( Object   instance )     {", "weldComponentService . getInjectionTarget (  )  . preDestroy ( instance )  ;", "}", "}  )  ,    InterceptorOrder . ComponentPreDestroy . CDI _ INTERCEPTORS )  ;", "}", "builder . install (  )  ;", "configuration . addPostConstructInterceptor ( new   ImmediateInterceptorFactory ( new   WeldInjectionContextInterceptor ( weldComponentService )  )  ,    WELD _ INJECTION _ CONTEXT _ INTERCEPTOR )  ;", "configuration . addPostConstructInterceptor ( new   ImmediateInterceptorFactory ( new   WeldInterceptorInjectionInterceptor ( interceptorClasses )  )  ,    INTERCEPTOR _ WELD _ INJECTION )  ;", "configuration . addPostConstructInterceptor ( WeldInjectionInterceptor . FACTORY ,    COMPONENT _ WELD _ INJECTION )  ;", "}", "METHOD_END"], "methodName": ["addWeldIntegration"], "fileName": "org.jboss.as.weld.deployment.processors.WeldComponentIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   WeldInterceptorBindingsService   weldInterceptorBindingsService    =    new   WeldInterceptorBindingsService ( beanDeploymentArchiveId ,    beanName ,    componentClass ,    componentInterceptorSupport )  ;", "ServiceName   bindingServiceName    =    configuration . getComponentDescription (  )  . getServiceName (  )  . append ( WeldInterceptorBindingsService . SERVICE _ NAME )  ;", "target . addService ( bindingServiceName ,    weldInterceptorBindingsService )  . addDependency ( weldServiceName ,    WeldBootstrapService . class ,    weldInterceptorBindingsService . getWeldContainer (  )  )  . addDependency ( weldStartService )  . install (  )  ;", "return   bindingServiceName ;", "}", "METHOD_END"], "methodName": ["addWeldInterceptorBindingService"], "fileName": "org.jboss.as.weld.deployment.processors.WeldComponentIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( ComponentIntegrator   integrator    :    integrators )     {", "if    ( integrator . isBeanNameRequired ( component )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isBeanNameRequired"], "fileName": "org.jboss.as.weld.deployment.processors.WeldComponentIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( ComponentIntegrator   integrator    :    integrators )     {", "if    ( integrator . isComponentWithView ( component )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isComponentWithView"], "fileName": "org.jboss.as.weld.deployment.processors.WeldComponentIntegrationProcessor"}, {"methodBody": ["METHOD_START", "{", "return   developmentMode ;", "}", "METHOD_END"], "methodName": ["isDevelopmentMode"], "fileName": "org.jboss.as.weld.deployment.processors.WeldConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   nonPortableMode ;", "}", "METHOD_END"], "methodName": ["isNonPortableMode"], "fileName": "org.jboss.as.weld.deployment.processors.WeldConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   requireBeanDescriptor ;", "}", "METHOD_END"], "methodName": ["isRequireBeanDescriptor"], "fileName": "org.jboss.as.weld.deployment.processors.WeldConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "retn   value ;", "} else    {", "retn   globalValue ;", "}", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.weld.deployment.processors.WeldConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "addDependency ( moduleSpecification ,    moduleLoader ,    moduleIdentifier ,    false )  ;", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "org.jboss.as.weld.deployment.processors.WeldDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    moduleIdentifier ,    optional ,    false ,    true ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "org.jboss.as.weld.deployment.processors.WeldDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "final   ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . JAVAX _ ENTERPRISE _ API )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . JAVAX _ INJECT _ API )  ;", "if    (  !  ( WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit )  )  )     {", "return ;", "}", "addDependency ( moduleSpecification ,    moduleLoader ,     . JAVAX _ PERSISTENCE _ API _ ID )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . WELD _ CORE _ ID )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . WELD _ PROBE _ ID ,    true )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . WELD _ API _ ID )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . WELD _ SPI _ ID )  ;", "ModuleDependency   weldSubsystemDependency    =    new   ModuleDependency ( moduleLoader ,     . JBOSS _ AS _ WELD _ ID ,    false ,    false ,    false ,    false )  ;", "weldSubsystemDependency . addImportFilter ( PathFilters . getMetaInfFilter (  )  ,    true )  ;", "weldSubsystemDependency . addImportFilter ( PathFilters . is (  \" org / jboss / as / weld / injection \"  )  ,    true )  ;", "weldSubsystemDependency . addImportFilter ( PathFilters . acceptAll (  )  ,    false )  ;", "weldSubsystemDependency . addExportFilter ( PathFilters . getMetaInfFilter (  )  ,    true )  ;", "moduleSpecification . addSystemDependency ( weldSubsystemDependency )  ;", "ModuleDependency   weldEjbDependency    =    new   ModuleDependency ( moduleLoader ,     . JBOSS _ AS _ WELD _ EJB _ ID ,    true ,    false ,    false ,    false )  ;", "weldEjbDependency . addImportFilter ( PathFilters . is (  \" org / jboss / as / weld / ejb \"  )  ,    true )  ;", "weldEjbDependency . addImportFilter ( PathFilters . acceptAll (  )  ,    false )  ;", "moduleSpecification . addSystemDependency ( weldEjbDependency )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.weld.deployment.processors.WeldDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "List < ServiceName >    dependencies    =    new   ArrayList <  >  (  )  ;", "final   EEModuleDescription   eeModuleDescription    =    Unit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "for    ( ComponentDescription   component    :    eeModuleDescription . getComponentDescriptions (  )  )     {", "dependencies . add ( component . getStartServiceName (  )  )  ;", "}", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getComponentStartServiceNames"], "fileName": "org.jboss.as.weld.deployment.processors.WeldDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( DeploymentUnitDependenciesProvider   provider    :    providers )     {", "dependencies . addAll ( provider . getDependencies ( deploymentUnit )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.jboss.as.weld.deployment.processors.WeldDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "List < ServiceName >    dependencies    =    new   ArrayList <  >  (  )  ;", "dependencies . add ( JBOSS _ CONTEXT _ SERVICE _ NAME . append ( ServiceName . of (  \" UserTransaction \"  )  )  )  ;", "dependencies . add ( JBOSS _ CONTEXT _ SERVICE _ NAME . append ( ServiceName . of (  \" TransactionSynchronizationRegistry \"  )  )  )  ;", "dependencies . add ( SERVICE _ NAME )  ;", "dependencies . add ( DefaultNamespaceContextSelectorService . SERVICE _ NAME )  ;", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getJNDISubsytemDependencies"], "fileName": "org.jboss.as.weld.deployment.processors.WeldDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   boolean   nonPortableMode    =    parentDeploymentUnit . getAttachment ( WeldConfiguration . ATTACHMENT _ KEY )  . isNonPortableMode (  )  ;", "final   ExternalConfiguration   configuration    =    new   ExternalConfigurationBuilder (  )  . add ( NON _ PORTABLE _ MODE . get (  )  ,    nonPortableMode )  . add ( ALLOW _ OPTIMIZED _ CLEANUP . get (  )  ,    true )  . build (  )  ;", "getServices (  )  . add ( ExternalConfiguration . class ,    configuration )  ;", "}", "METHOD_END"], "methodName": ["installBootstrapConfigurationService"], "fileName": "org.jboss.as.weld.deployment.processors.WeldDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "Enumeration < URL >    resources    =    module . getClassLoader (  )  . getResources (  (  \" META - INF / services /  \"     +     ( Extension . class . getName (  )  )  )  )  ;", "final   List < String >    services    =    new   ArrayList <  >  (  )  ;", "while    ( resources . hasMoreElements (  )  )     {", "URL   resource    =    resources . nextElement (  )  ;", "final   InputStream   stream    =    resource . openStream (  )  ;", "try    {", "final   BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( stream ,    StandardCharsets . UTF _  8  )  )  ;", "String   line ;", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "final   int   commentIdx    =    line . indexOf (  '  #  '  )  ;", "final   String   className ;", "if    ( commentIdx    =  =     (  -  1  )  )     {", "className    =    line . trim (  )  ;", "} else    {", "className    =    line . substring (  0  ,    commentIdx )  . trim (  )  ;", "}", "if    (  ( className . length (  )  )     =  =     0  )     {", "continue ;", "}", "services . add ( className )  ;", "}", "}    finally    {", "VFSUtils . safeClose ( stream )  ;", "}", "}", "for    ( String   service    :    services )     {", "final   Class < Extension >    extensionClass    =    loadExtension ( service ,    module . getClassLoader (  )  )  ;", "if    ( extensionClass    =  =    null )     {", "continue ;", "}", "extensions . tryRegisterExtension ( extensionClass ,    Unit )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   DeploymentUnitProcessingException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["loadAttachments"], "fileName": "org.jboss.as.weld.deployment.processors.WeldPortableExtensionProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Class < Extension >  )     ( loader . loadClass ( serviceClassName )  )  )  ;", "}    catch    ( Exception   e )     {", "WeldLogger . DEPLOYMENT _ LOGGER . couldNotLoaceptionClass ( serviceClassName ,    e )  ;", "}    catch    ( LinkageError   e )     {", "WeldLogger . DEPLOYMENT _ LOGGER . couldNotLoaceptionClass ( serviceClassName ,    e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["loadExtension"], "fileName": "org.jboss.as.weld.deployment.processors.WeldPortableExtensionProcessor"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.weld.discovery.AnnotationType"}, {"methodBody": ["METHOD_START", "{", "return   inherited ;", "}", "METHOD_END"], "methodName": ["isInherited"], "fileName": "org.jboss.as.weld.discovery.AnnotationType"}, {"methodBody": ["METHOD_START", "{", "final   String   resourceName ;", "if    ( resource   instanceof   Class <  ?  >  )     {", "resourceName    =     (  (  ( Class <  ?  >  )     ( resource )  )  . getName (  )  . replace (  \"  .  \"  ,     \"  /  \"  )  )     +     \"  . class \"  ;", "} else", "if    ( resource   instanceof   String )     {", "resourceName    =    resource . toString (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Unsupported   resource   type \"  )  ;", "}", "indexer . index ( classLoader . getResourceAsStream ( resourceName )  )  ;", "if    ( resource   instanceof   Class <  ?  >  )     {", "for    ( Class <  ?  >    innerClass    :     (  ( Class <  ?  >  )     ( resource )  )  . getDeclaredClasses (  )  )     {", ". addResource ( innerClass ,    indexer ,    classLoader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addResource"], "fileName": "org.jboss.as.weld.discovery.IndexUtils"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   classLoader    =    IndexUtils . class . getClassLoader (  )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "for    ( Object   resource    :    resources )     {", "IndexUtils . addResource ( resource ,    indexer ,    classLoader )  ;", "}", "final   Index   index    =    indexer . complete (  )  ;", "return   new   server . deployment . annotation . CompositeIndex ( Collections . singleton ( index )  )  ;", "}", "METHOD_END"], "methodName": ["createIndex"], "fileName": "org.jboss.as.weld.discovery.IndexUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( classInfo . annotations (  )  . containsKey ( requiredAnnotationName )  )     {", "return   true ;", "}", "for    ( DotName   annotation    :    classInfo . annotations (  )  . keySet (  )  )     {", "if    ( annotationClassAnnotationsCache . getValue ( annotation )  . contains ( requiredAnnotationName . toString (  )  )  )     {", "return   true ;", "}", "}", "final   DotName   superName    =    classInfo . superName (  )  ;", "if    (  ( superName    !  =    null )     &  &     (  !  (  . OBJECT _ NAME . equals ( superName )  )  )  )     {", "final   ClassInfo   superClassInfo    =    index . getClassByName ( superName )  ;", "if    ( superClassInfo    =  =    null )     {", "return   Reflections . containsAnnotation ( loadClass ( superName . toString (  )  )  ,    requiredAnnotation )  ;", "}", "if    ( containsAnnotation ( superClassInfo ,    requiredAnnotationName ,    requiredAnnotation )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsAnnotation"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "if    ( name . isComponentized (  )  )     {", "while    ( name . isInner (  )  )     {", "name    =    name . prefix (  )  ;", "if    ( name    =  =    null )     {", "throw   new   IllegalStateException (  \" Could   not   determine   package   from   corrupted   c   name \"  )  ;", "}", "}", "return   name . prefix (  )  ;", "} else    {", "final   int   lastIndex    =    name . local (  )  . lastIndexOf (  \"  .  \"  )  ;", "if    ( lastIndex    =  =     (  -  1  )  )     {", "return   name ;", "}", "return   DotName . createSimple ( name . local (  )  . substring (  0  ,    name . local (  )  . lastIndexOf (  \"  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPackageName"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "List < AnnotationInstance >    annotationInstances    =    classInfo . annotations (  )  . get ( WeldClassFileInfo . DOT _ NAME _ INJECT )  ;", "if    ( annotationInstances    !  =    null )     {", "for    ( AnnotationInstance   instance    :    annotationInstances )     {", "AnnotationTarget   target    =    instance . target (  )  ;", "if    ( target   instanceof   MethodInfo )     {", "MethodInfo   methodInfo    =     (  ( MethodInfo )     ( target )  )  ;", "if    ( methodInfo . name (  )  . equals ( WeldClassFileInfo . CONSTRUCTOR _ METHOD _ NAME )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasInjectConstructor"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "return   isAnnotationDeclared ( classInfo ,    DotName . createSimple ( annotation . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationDeclared"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "List < AnnotationInstance >    annotations    =    classInfo . annotations (  )  . get ( requiredAnnotationName )  ;", "if    ( annotations    !  =    null )     {", "for    ( AnnotationInstance   annotationInstance    :    annotations )     {", "if    ( annotationInstance . target (  )  . equals ( classInfo )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAnnotationDeclared"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "if    ( className . equals ( fromClass . getName (  )  )  )     {", "return   true ;", "}", "if    ( Object . class . equals ( fromClass )  )     {", "return   false ;", "}", "Class <  ?  >    superClass    =    fromClass . getSuperclass (  )  ;", "if    (  ( superClass    !  =    null )     &  &     ( isAssignableFrom ( className ,    superClass )  )  )     {", "return   true ;", "}", "for    ( Class <  ?  >    interfaceClass    :    fromClass . getInterfaces (  )  )     {", "if    ( isAssignableFrom ( className ,    interfaceClass )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "if    ( to . getName (  )  . equals ( name . toString (  )  )  )     {", "return   true ;", "}", "if    (  . OBJECT _ NAME . equals ( name )  )     {", "return   false ;", "}", "ClassInfo   fromClassInfo    =    index . getClassByName ( name )  ;", "if    ( fromClassInfo    =  =    null )     {", "final   Class <  ?  >    clazz    =    loadClass ( name . toString (  )  )  ;", "return   to . isAssignableFrom ( clazz )  ;", "}", "DotName   superName    =    fromClassInfo . superName (  )  ;", "if    (  ( superName    !  =    null )     &  &     ( isAssignableTo ( superName ,    to )  )  )     {", "return   true ;", "}", "if    (  ( fromClassInfo . interfaces (  )  )     !  =    null )     {", "for    ( DotName   interfaceName    :    fromClassInfo . interfaces (  )  )     {", "if    ( isAssignableTo ( interfaceName ,    to )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAssignableTo"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "if    ( isAnnotationDeclared ( classInfo ,    WeldClassFileInfo . DOT _ NAME _ VETOED )  )     {", "return   true ;", "}", "final   DotName   packageInfoName    =    DotName . createComponentized ( getPackageName ( classInfo . name (  )  )  ,    WeldClassFileInfo . PACKAGE _ INFO _ NAME )  ;", "ClassInfo   packageInfo    =    index . getClassByName ( packageInfoName )  ;", "if    (  ( packageInfo    !  =    null )     &  &     ( isAnnotationDeclared ( packageInfo ,    WeldClassFileInfo . DOT _ NAME _ VETOED )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isVetoedTypeOrPackage"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "WeldLogger . DEPLOYMENT _ LOGGER . tracef (  \" Falling   back   to   reflection   for    % s \"  ,    className )  ;", "try    {", "return   classLoader . loa ( className )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   WeldLogger . ROOT _ LOGGER . cannotLoa ( className ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileInfo"}, {"methodBody": ["METHOD_START", "{", "ClassFileServices   service    =    new   WeldClassFileServices ( IndexUtils . createIndex ( Alpha . class ,    AlphaImpl . class ,    AbstractAlpha . class ,    InnerClasses . class ,    Bravo . class ,     \" org / jboss / as / weld / discovery / vetoed / package - info . class \"  ,    Inject . class ,    Named . class ,    Charlie . class )  ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", ". alpha    =    service . getClassFileInfo ( Alpha . class . getName (  )  )  ;", ". abstractAlpha    =    service . getClassFileInfo ( AbstractAlpha . class . getName (  )  )  ;", ". alphaImpl    =    service . getClassFileInfo ( AlphaImpl . class . getName (  )  )  ;", ". innerInterface    =    service . getClassFileInfo ( InnerClasses . InnerInterface . class . getName (  )  )  ;", ". bravo    =    service . getClassFileInfo ( Bravo . class . getName (  )  )  ;", ". charlie    =    service . getClassFileInfo ( Charlie . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . containsAnnotation ( Vetoed . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . innerInterface . containsAnnotation ( Named . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . bravo . containsAnnotation ( Vetoed . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . bravo . containsAnnotation ( Named . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . bravo . containsAnnotation ( Inject . class )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsAnnotation"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . charlie . containsAnnotation ( Target . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . bravo . containsAnnotation ( Target . class )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsAnnotationReflectionFallback"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . isAnnotationDeclared ( Vetoed . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . innerInterface . isAnnotationDeclared ( Named . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . bravo . isAnnotationDeclared ( Vetoed . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . bravo . isAnnotationDeclared ( Named . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . bravo . isAnnotationDeclared ( Inject . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsAnnotationDeclared"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . isAssignableFrom ( AlphaImpl . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . abstractAlpha . isAssignableFrom ( AlphaImpl . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . abstractAlpha . isAssignableFrom ( Alpha . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . innerInterface . isAssignableFrom ( Bravo . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . alphaImpl . isAssignableFrom ( Bravo . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsAssignableFrom"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertFalse ( WeldClassFileServicesTest . alpha . isAssignableFrom ( Object . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . abstractAlpha . isAssignableFrom ( Object . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . alphaImpl . isAssignableFrom ( Object . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . bravo . isAssignableFrom ( Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsAssignableFromObject"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . alphaImpl . isAssignableTo ( Alpha . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . abstractAlpha . isAssignableTo ( Alpha . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . abstractAlpha . isAssignableTo ( AlphaImpl . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . bravo . isAssignableTo ( InnerClasses . InnerInterface . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . bravo . isAssignableTo ( AbstractAlpha . class )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . bravo . isAssignableTo ( InnerClasses . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsAssignableTo"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . isAssignableTo ( Object . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . abstractAlpha . isAssignableTo ( Object . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . alphaImpl . isAssignableTo ( Object . class )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . bravo . isAssignableTo ( Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsAssignableToObject"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( Modifier . isAbstract ( WeldClassFileServicesTest . alpha . getModifiers (  )  )  )  ;", "Assert . assertTrue ( Modifier . isAbstract ( WeldClassFileServicesTest . abstractAlpha . getModifiers (  )  )  )  ;", "Assert . assertFalse ( Modifier . isAbstract ( WeldClassFileServicesTest . alphaImpl . getModifiers (  )  )  )  ;", "Assert . assertFalse ( Modifier . isStatic ( WeldClassFileServicesTest . alpha . getModifiers (  )  )  )  ;", "Assert . assertFalse ( Modifier . isStatic ( WeldClassFileServicesTest . abstractAlpha . getModifiers (  )  )  )  ;", "Assert . assertFalse ( Modifier . isStatic ( WeldClassFileServicesTest . alphaImpl . getModifiers (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testModifiers"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( Object . class . getName (  )  ,    WeldClassFileServicesTest . alpha . getSuperclassName (  )  )  ;", "Assert . assertEquals ( Object . class . getName (  )  ,    WeldClassFileServicesTest . abstractAlpha . getSuperclassName (  )  )  ;", "Assert . assertEquals ( AbstractAlpha . class . getName (  )  ,    WeldClassFileServicesTest . alphaImpl . getSuperclassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSuperclassName"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . isTopLevelClass (  )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . isTopLevelClass (  )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . isTopLevelClass (  )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . innerInterface . isTopLevelClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTopLevelClass"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( WeldClassFileServicesTest . alpha . isVetoed (  )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . abstractAlpha . isVetoed (  )  )  ;", "Assert . assertFalse ( WeldClassFileServicesTest . alphaImpl . isVetoed (  )  )  ;", "Assert . assertTrue ( WeldClassFileServicesTest . bravo . isVetoed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testVeto"], "fileName": "org.jboss.as.weld.discovery.WeldClassFileServicesTest"}, {"methodBody": ["METHOD_START", "{", "return   delegateInvocationContext . getContextData (  )  ;", "}", "METHOD_END"], "methodName": ["getContextData"], "fileName": "org.jboss.as.weld.ejb.DelegatingInterceptorInvocationContext"}, {"methodBody": ["METHOD_START", "{", "return   delegateInvocationContext . getMethod (  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.jboss.as.weld.ejb.DelegatingInterceptorInvocationContext"}, {"methodBody": ["METHOD_START", "{", "return   delegateInvocationContext . getParameters (  )  ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "org.jboss.as.weld.ejb.DelegatingInterceptorInvocationContext"}, {"methodBody": ["METHOD_START", "{", "return   delegateInvocationContext . getTarget (  )  ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.jboss.as.weld.ejb.DelegatingInterceptorInvocationContext"}, {"methodBody": ["METHOD_START", "{", "return   delegateInvocationContext . getTimer (  )  ;", "}", "METHOD_END"], "methodName": ["getTimer"], "fileName": "org.jboss.as.weld.ejb.DelegatingInterceptorInvocationContext"}, {"methodBody": ["METHOD_START", "{", "int   oldPosition    =    position ;", "try    {", "if    (  ( position )     <     ( invocationQueue . size (  )  )  )     {", "Object   interceptorInstance    =    interceptorInstances . get ( position )  ;", "try    {", "return   invocationQueue . get (  (  ( position )  +  +  )  )  . intercept ( interceptionType ,    interceptorInstance ,    this )  ;", "}    catch    ( Exception   e )     {", "if    (  ( e   instanceof   WeldException )     &  &     (  ( e . getCause (  )  )    instanceof   Exception )  )     {", "throw    (  ( Exception )     ( e . getCause (  )  )  )  ;", "} else    {", "throw   e ;", "}", "}", "} else    {", "return   delegate . proceed (  )  ;", "}", "}    finally    {", "position    =    oldPosition ;", "}", "}", "METHOD_END"], "methodName": ["proceed"], "fileName": "org.jboss.as.weld.ejb.DelegatingInterceptorInvocationContext"}, {"methodBody": ["METHOD_START", "{", "delegateInvocationContext . setParameters ( params )  ;", "}", "METHOD_END"], "methodName": ["setParameters"], "fileName": "org.jboss.as.weld.ejb.DelegatingInterceptorInvocationContext"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.jboss.as.weld.ejb.EjbDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   baseName . append (  \" CREATE \"  )  ;", "}", "METHOD_END"], "methodName": ["getCreateServiceName"], "fileName": "org.jboss.as.weld.ejb.EjbDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( view   instanceof   EJBViewDescription )     {", "final   EJBViewDescription   ejbView    =     (  ( EJBViewDescription )     ( view )  )  ;", "return   ejbView . getMethodIntf (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMethodIntf"], "fileName": "org.jboss.as.weld.ejb.EjbDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   baseName . append (  \" START \"  )  ;", "}", "METHOD_END"], "methodName": ["getStartServiceName"], "fileName": "org.jboss.as.weld.ejb.EjbDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "return   viewServices ;", "}", "METHOD_END"], "methodName": ["getViewServices"], "fileName": "org.jboss.as.weld.ejb.EjbDescriptorImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrentServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.weld.ejb.EjbRequestScopeActivationInterceptor"}, {"methodBody": ["METHOD_START", "{", "Map < Class <  ?  >  ,    ServiceName >    names    =    new   HashMap < Class <  ?  >  ,    ServiceName >  (  )  ;", "for    ( Map . Entry < Class <  ?  >  ,    String >    e    :    serviceNames . entrySet (  )  )     {", "names . put ( e . getKey (  )  ,    ServiceName . parse ( e . getValue (  )  )  )  ;", "}", "return   new   ReferenceImpl ( sessionID ,    ServiceName . parse ( componentServiceName )  ,    names )  ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.jboss.as.weld.ejb.SerializedStatefulSessionObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurtServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.weld.ejb.SessionObjectReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurtServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.weld.ejb.StatefulSessionObjectReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   SerializedStatefulSessionObject ( createServiceName ,    id ,    viewServices )  ;", "}", "METHOD_END"], "methodName": ["writeReplace"], "fileName": "org.jboss.as.weld.ejb.StatefulSessionObjectReferenceImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( ejbName    !  =    null )     {", "return   interceptorSupport . get ( ejbName ,    manager )  ;", "} else    {", "SlimAnnotatedType <  ?  >    type    =     (  ( SlimAnnotatedType <  ?  >  )     ( manager . createAnnotatedType ( componentClass )  )  )  ;", "if    (  !  ( manager . getInterceptorModelRegistry (  )  . containsKey ( type )  )  )     {", "EnhancedAnnotatedType <  ?  >    enhancedType    =    manager . getServices (  )  . get ( ClassTransformer . class )  . getEnhancedAnnotatedType ( type )  ;", "InterceptionModelInitializer . of ( manager ,    enhancedType ,    null )  . init (  )  ;", "}", "InterceptionModel   model    =    manager . getInterceptorModelRegistry (  )  . get ( type )  ;", "if    ( model    !  =    null )     {", "return   new   Adapter ( manager . getInterceptorModelRegistry (  )  . get ( type )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getInterceptorBindings"], "fileName": "org.jboss.as.weld.ejb.WeldInterceptorBindingsService"}, {"methodBody": ["METHOD_START", "{", "return   weldContainer ;", "}", "METHOD_END"], "methodName": ["getWeldContainer"], "fileName": "org.jboss.as.weld.ejb.WeldInterceptorBindingsService"}, {"methodBody": ["METHOD_START", "{", "final   ClassTransformer   transformer    =    beanManager . getServices (  )  . get ( ClassTransformer . class )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "final   Class < T >    clazz    =     (  ( Class < T >  )     ( componentClass )  )  ;", "EnhancedAnnotatedType < T >    type    =    transformer . getEnhancedAnnotatedType ( clazz ,    beanManager . getId (  )  )  ;", "if    (  !  ( type . getJavaClass (  )  . equals ( componentClass )  )  )     {", "final   String   bdaId    =     ( beanManager . getId (  )  )     +     ( componentClass . getClassLoader (  )  . hashCode (  )  )  ;", "type    =    transformer . getEnhancedAnnotatedType ( clazz ,    bdaId )  ;", "}", "if    (  ( Beans . getBeanConstructor ( type )  )     =  =    null )     {", "return   beanManager . getFactory ( type )  . createNonProducible (  )  ;", "}", "WeldBuilder < T >    builder    =    beanManager . createBuilder ( type )  ;", "builder . setBean ( bean )  ;", "builder . setResourceInjectionEnabled ( false )  ;", "if    ( interceptionSupport )     {", "return   builder . build (  )  ;", "} else    {", "return   builder . setInterceptionEnabled ( false )  . setTargetClassLifecycleCallbacksEnabled ( false )  . setDecorationEnabled ( false )  . build (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createInjectionTarget"], "fileName": "org.jboss.as.weld.injection.InjectionTargets"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "object . setAccessible ( true )  ;", "} else    {", "AccessController . doPrivileged ( new   PrivilegedAction < Object >  (  )     {", "public   Object   run (  )     {", "object . setAccessible ( true )  ;", "return   null ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAccessible"], "fileName": "org.jboss.as.weld.injection.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   new   WeldInjectionContext ( beanManager . createCreationalContext ( bean )  ,    bean ,    delegateProduce ,    injectionTarget ,    interceptorInjections )  ;", "}", "METHOD_END"], "methodName": ["createInjectionContext"], "fileName": "org.jboss.as.weld.injection.WeldComponentService"}, {"methodBody": ["METHOD_START", "{", "return   injectionTarget ;", "}", "METHOD_END"], "methodName": ["getInjectionTarget"], "fileName": "org.jboss.as.weld.injection.WeldComponentService"}, {"methodBody": ["METHOD_START", "{", "return   weldContainer ;", "}", "METHOD_END"], "methodName": ["getWeldContainer"], "fileName": "org.jboss.as.weld.injection.WeldComponentService"}, {"methodBody": ["METHOD_START", "{", "WeldCreationalContext < T >    ctxImpl    =     (  ( WeldCreationalContext < T >  )     ( ctx )  )  ;", "ctxImpl . setConstructorInterceptionSuppressed ( true )  ;", "ctxImpl . registerAroundConstructCallback ( new   AroundConstructCallback < T >  (  )     {", "@ SuppressWarnings (  \" unchecked \"  )", "@ Override", "public   T   aroundConstruct ( Handle < T >    ctx ,    AnnotatedConstructor < T >    constructor ,    Object [  ]    parameters ,    Map < String ,    Object >    data )    throws   Exception    {", "context . putPrivateData ( Handle . class ,    ctx )  ;", "context . setParameters ( parameters )  ;", "context . setContextData ( data )  ;", "context . setConstructor ( constructor . getJavaMember (  )  )  ;", "context . proceed (  )  ;", "return    (  ( T )     ( context . getTarget (  )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setupAroundConstructCallback"], "fileName": "org.jboss.as.weld.injection.WeldConstructionStartInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   context ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.jboss.as.weld.injection.WeldInjectionContext"}, {"methodBody": ["METHOD_START", "{", "return   injectionTarget ;", "}", "METHOD_END"], "methodName": ["getInjectionTarget"], "fileName": "org.jboss.as.weld.injection.WeldInjectionContext"}, {"methodBody": ["METHOD_START", "{", "injectionTarget . inject ( instance ,    context )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.jboss.as.weld.injection.WeldInjectionContext"}, {"methodBody": ["METHOD_START", "{", "final   InjectionTarget    =    interceptorInjections . get ( instance . getClass (  )  )  ;", "if    (  !  =    null )     {", "inject ( instance ,    context )  ;", "} else    {", "throw   WeldLogger . ROOT _ LOGGER . unknownInterceptorClassForCDIInjection ( instance . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["injectInterceptor"], "fileName": "org.jboss.as.weld.injection.WeldInjectionContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( delegateProduce )     &  &     (  ( bean )    instanceof   ManagedBean )  )     {", "return    (  ( ManagedBean )     ( bean )  )  . getTarget (  )  . produce ( context )  ;", "} else    {", "return   injectionTarget . produce ( context )  ;", "}", "}", "METHOD_END"], "methodName": ["produce"], "fileName": "org.jboss.as.weld.injection.WeldInjectionContext"}, {"methodBody": ["METHOD_START", "{", "context . release (  )  ;", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.jboss.as.weld.injection.WeldInjectionContext"}, {"methodBody": ["METHOD_START", "{", "Object   instance    =    beanManager . getReference ( interceptor ,    interceptor . getBeanClass (  )  ,    creationalContext ,    true )  ;", "SerializableContextualInstance < Interceptor < Object >  ,    Object >    serializableContextualInstance    =    beanManager . getServices (  )  . get ( ContextualStore . class )  .  < Interceptor < Object >  ,    Object > getSerializableContextualInstance ( interceptor ,    instance ,    creationalContext )  ;", "instances . put ( interceptor . getBeanClass (  )  . getName (  )  ,    serializableContextualInstance )  ;", "}", "METHOD_END"], "methodName": ["addInterceptorInstance"], "fileName": "org.jboss.as.weld.interceptors.Jsr299BindingsCreateInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   interceptorBindings ;", "}", "METHOD_END"], "methodName": ["getInterceptorBindings"], "fileName": "org.jboss.as.weld.interceptors.Jsr299BindingsCreateInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   weldContainer ;", "}", "METHOD_END"], "methodName": ["getWeldContainer"], "fileName": "org.jboss.as.weld.interceptors.Jsr299BindingsCreateInterceptor"}, {"methodBody": ["METHOD_START", "{", "List < Object >    currentInterceptorInstances    =    new   ArrayList < Object >  (  )  ;", "for    ( Interceptor <  ?  >    interceptor    :    currentInterceptors )     {", "currentInterceptorInstances . add ( interceptorInstances . getInstances (  )  . get ( interceptor . getBeanClass (  )  . getName (  )  )  . getInstance (  )  )  ;", "}", "if    (  ( currentInterceptorInstances . size (  )  )     >     0  )     {", "return   interceptorSupport . delegateInterception ( invocationContext ,    interceptionType ,    currentInterceptors ,    currentInterceptorInstances )  ;", "} else    {", "return   invocationContext . proceed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["delegateInterception"], "fileName": "org.jboss.as.weld.interceptors.Jsr299BindingsInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( interceptorBindings    =  =    null )     {", "return   context . proceed (  )  ;", "} else    {", "List < Interceptor <  ?  >  >    currentInterceptors    =    interceptorBindings . getLifecycleInterceptors ( interceptionType )  ;", "return   delegateInterception ( context . getInvocationContext (  )  ,    interceptionType ,    currentInterceptors ,    interceptorInstances )  ;", "}", "}", "METHOD_END"], "methodName": ["doLifecycleInterception"], "fileName": "org.jboss.as.weld.interceptors.Jsr299BindingsInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( interceptorBindings    !  =    null )     {", "List < Interceptor <  ?  >  >    currentInterceptors    =    interceptorBindings . getMethodInterceptors ( interceptionType ,    invocationContext . getMethod (  )  )  ;", "return   delegateInterception ( invocationContext ,    interceptionType ,    currentInterceptors ,    interceptorInstances )  ;", "} else    {", "return   invocationContext . proceed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doMethodInterception"], "fileName": "org.jboss.as.weld.interceptors.Jsr299BindingsInterceptor"}, {"methodBody": ["METHOD_START", "{", "Jsr 2  9  9 BindingsInterceptor   interceptor    =    new   Jsr 2  9  9 BindingsInterceptor ( interceptionType ,    interceptorSupport )  ;", "builder . addDependency ( interceptorBindingServiceName ,    InterceptorBindings . class ,    interceptor . interceptorBindings )  ;", "return   new   ImmediateInterceptorFactory ( interceptor )  ;", "}", "METHOD_END"], "methodName": ["factory"], "fileName": "org.jboss.as.weld.interceptors.Jsr299BindingsInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   weldContainer ;", "}", "METHOD_END"], "methodName": ["getWeldContainer"], "fileName": "org.jboss.as.weld.services.BeanManagerService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append ( BeanManagerService . NAME )  ;", "}", "METHOD_END"], "methodName": ["serviceName"], "fileName": "org.jboss.as.weld.services.BeanManagerService"}, {"methodBody": ["METHOD_START", "{", "ModuleGroupSingletonProvider . deploymentClassLoaders . put ( topLevel ,    allClassLoaders )  ;", "}", "METHOD_END"], "methodName": ["addClassLoaders"], "fileName": "org.jboss.as.weld.services.ModuleGroupSingletonProvider"}, {"methodBody": ["METHOD_START", "{", "ModuleGroupSingletonProvider . deploymentClassLoaders . remove ( topLevel )  ;", "}", "METHOD_END"], "methodName": ["removeClassLoader"], "fileName": "org.jboss.as.weld.services.ModuleGroupSingletonProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   ResourceReferenceFactory < Object >  (  )     {", "@ Override", "public   ResourceReference < Object >    createResource (  )     {", "final   ManagedReferenceFactory   factory    =    getManagedReferenceFactory ( ejbBindInfo )  ;", "if    ( factory    =  =    null )     {", "return   new   SimpleResourceReference ( null )  ;", "}", "final   ManagedReference   instance    =    factory . getReference (  )  ;", "return   new   ResourceReference < Object >  (  )     {", "@ Override", "public   Object   getInstance (  )     {", "return   instance . getInstance (  )  ;", "}", "@ Override", "public   void   release (  )     {", "instance . release (  )  ;", "}", "}  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createLazyResourceReferenceFactory"], "fileName": "org.jboss.as.weld.services.bootstrap.AbstractResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "try    {", "ServiceController <  ?  >    controller    =    Registry . getRequiredService ( ejbBindInfo . getBinderServiceName (  )  )  ;", "return    (  ( ManagedReferenceFactory )     ( controller . getValue (  )  )  )  ;", "}    catch    ( Exception   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getManagedReferenceFactory"], "fileName": "org.jboss.as.weld.services.bootstrap.AbstractResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "final   ContextNames . BindInfo   ejbBindInfo    =    getBindInfo ( result )  ;", "final   ManagedReferenceFactory   factory    =    getManagedReferenceFactory ( ejbBindInfo )  ;", "validatePointType ( factory ,    injectionPoint )  ;", "if    ( factory    !  =    null )     {", "return   new   ManagedReferenceFactoryToResourceReferenceFactoryAdapter < Object >  ( factory )  ;", "} else    {", "return   createLazyResourceReferenceFactory ( ejbBindInfo )  ;", "}", "}", "METHOD_END"], "methodName": ["handleServiceLookup"], "fileName": "org.jboss.as.weld.services.bootstrap.AbstractResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    injectionPointRawType    =    Reflections . getRawType ( injectionPoint . getType (  )  )  ;", "HierarchyDiscovery   discovery    =    new   HierarchyDiscovery ( resourceType )  ;", "for    ( Type   type    :    discovery . getTypeClosure (  )  )     {", "if    ( Reflections . getRawType ( type )  . equals ( injectionPointRawType )  )     {", "return ;", "}", "}", "if    (  ( resourceType . isPrimitive (  )  )     &  &     (  . BOXED _ TYPES . get ( resourceType )  . equals ( injectionPointRawType )  )  )     {", "return ;", "} else", "if    (  ( injectionPointRawType . isPrimitive (  )  )     &  &     (  . BOXED _ TYPES . get ( injectionPointRawType )  . equals ( resourceType )  )  )     {", "return ;", "}", "throw   LOG . invalidResourceProducerType ( injectionPoint . getAnnotated (  )  ,    resourceType . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateResourceInjectionPointType"], "fileName": "org.jboss.as.weld.services.bootstrap.AbstractResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( fact   instanceof   ContextListManagedReferenceFactory )  )     |  |     ( injectionPoint    =  =    null )  )     {", "return ;", "}", "final   ContextListManagedReferenceFactory   factory    =     (  ( ContextListManagedReferenceFactory )     ( fact )  )  ;", "Class <  ?  >    resourceClass    =    Reflections . loadClass ( factory . getInstanceClassName (  )  ,    factory . getClass (  )  . getClassLoader (  )  )  ;", "if    ( resourceClass    =  =    null )     {", "resourceClass    =    Reflections . loadClass ( factory . getInstanceClassName (  )  ,    module . getClassLoader (  )  )  ;", "}", "if    ( resourceClass    !  =    null )     {", ". validateResourceInjectionPointType ( resourceClass ,    injectionPoint )  ;", "}", "}", "METHOD_END"], "methodName": ["validateResourceInjectionPointType"], "fileName": "org.jboss.as.weld.services.bootstrap.AbstractResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "if    ( proxiedBeanType . getName (  )  . startsWith (  \" java \"  )  )     {", "return   module . getClassLoader (  )  ;", "} else", "if    (  ( proxiedBeanType . getClassLoader (  )  )    instanceof   ModuleClassLoader )     {", "final   ModuleClassLoader   loader    =     (  ( ModuleClassLoader )     ( proxiedBeanType . getClassLoader (  )  )  )  ;", "if    (  ( loader . getModule (  )  . getModuleLoader (  )  )    instanceof   ServiceModuleLoader )     {", "return   proxiedBeanType . getClassLoader (  )  ;", "} else    {", "final   Module   definingModule    =    loader . getModule (  )  ;", "Boolean   hasWeldDependencies    =    processedStaticModules . get ( definingModule . getIdentifier (  )  )  ;", "boolean   logWarning    =    false ;", "if    ( hasWeldDependencies    =  =    null )     {", "hasWeldDependencies    =    ProxyServicesImpl . canLoadWeldProxies ( definingModule )  ;", "logWarning    =     ( processedStaticModules . putIfAbsent ( definingModule . getIdentifier (  )  ,    hasWeldDependencies )  )     =  =    null ;", "}", "if    ( hasWeldDependencies )     {", "return   proxiedBeanType . getClassLoader (  )  ;", "} else    {", "if    ( logWarning )     {", "logging . WeldLogger . ROOT _ LOGGER . loadingProxiesUsingDeploymentClassLoader ( definingModule . getIdentifier (  )  ,    toString ( ProxyServicesImpl . REQUIRED _ WELD _ DEPENDENCIES )  )  ;", "}", "return   this . module . getClassLoader (  )  ;", "}", "}", "} else    {", "return   proxiedBeanType . getClassLoader (  )  ;", "}", "}", "METHOD_END"], "methodName": ["_getClassLoader"], "fileName": "org.jboss.as.weld.services.bootstrap.ProxyServicesImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( String   weldClass    :    ProxyServicesImpl . WELD _ CLASSES )     {", "if    (  !  ( Reflections . isAccessible ( weldClass ,    module . getClassLoader (  )  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["canLoadWeldProxies"], "fileName": "org.jboss.as.weld.services.bootstrap.ProxyServicesImpl"}, {"methodBody": ["METHOD_START", "{", "processedStaticModules . clear (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.jboss.as.weld.services.bootstrap.ProxyServicesImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < ClassLoader >  (  )     {", "public   ClassLoader   run (  )     {", "return    _ getClassLoader ( proxiedBeanType )  ;", "}", "}  )  ;", "} else    {", "return    _ getClassLoader ( proxiedBeanType )  ;", "}", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.jboss.as.weld.services.bootstrap.ProxyServicesImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Class <  ?  >  )     ( AcsController . doPrivileged ( new   PrivilegedExceptionAction < Object >  (  )     {", "public   Object   run (  )    throws   Exception    {", "return   Class . forName ( className ,    true ,    getClassLoader ( this . getClass (  )  )  )  ;", "}", "}  )  )  )  ;", "}    catch    ( PrivilegedActionException   pae )     {", "throw   LOG . cannotLoadClass ( className ,    pae . getException (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["loadBeanClass"], "fileName": "org.jboss.as.weld.services.bootstrap.ProxyServicesImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ResourceReferenceFactory < Object >  (  )     {", "@ Override", "public   ResourceReference < Object >    createResource (  )     {", "final   ManagedReference   instance ;", "try    {", "final   ServiceController <  ?  >    controller    =    serviceRegistry . getRequiredService ( viewDescription . getServiceName (  )  )  ;", "final   ComponentView   view    =     (  ( ComponentView )     ( controller . getValue (  )  )  )  ;", "instance    =    view . createInstance (  )  ;", "return   new   ResourceReference < Object >  (  )     {", "@ Override", "public   Object   getInstance (  )     {", "return   instance . getInstance (  )  ;", "}", "@ Override", "public   void   release (  )     {", "instance . release (  )  ;", "}", "}  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createLazyResourceReferenceFactory"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbInjectionServices"}, {"methodBody": ["METHOD_START", "{", "String   name    =    ResourceInjectionUtilities . getResourceName ( jndiName ,    mappedName )  ;", "try    {", "return   new   InitialContext (  )  . lookup ( name )  ;", "}    catch    ( NamingException   e )     {", "throw   WeldLogger . ROOT _ LOGGER . couldNotFindResource ( name ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["doLookup"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbInjectionServices"}, {"methodBody": ["METHOD_START", "{", "final   ServiceController <  ?  >    controller    =    serviceRegistry . getService ( viewDescription . getServiceName (  )  )  ;", "if    ( controller    =  =    null )     {", "return   null ;", "}", "return    (  ( ComponentView )     ( controller . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentView"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbInjectionServices"}, {"methodBody": ["METHOD_START", "{", "EJB   ejb    =    ResourceInjectionUtilities . getResourceAnnotated ( injectionPoint )  . getAnnotation ( EJB . class )  ;", "String   mappedName    =    ejb . mappedName (  )  ;", "if    (  !  ( mappedName . equals (  \"  \"  )  )  )     {", "return   mappedName ;", "}", "String   name    =    ejb . name (  )  ;", "if    (  !  ( name . equals (  \"  \"  )  )  )     {", "return    (  ( ResourceInjectionUtilities . RESOURCE _ LOOKUP _ PREFIX )     +     \"  /  \"  )     +    name ;", "}", "String   propertyName ;", "if    (  ( injectionPoint . getMember (  )  )    instanceof   Field )     {", "propertyName    =    injectionPoint . getMember (  )  . getName (  )  ;", "} else", "if    (  ( injectionPoint . getMember (  )  )    instanceof   Method )     {", "propertyName    =    ResourceInjectionUtilities . getPropertyName (  (  ( Method )     ( injectionPoint . getMember (  )  )  )  )  ;", "if    ( propertyName    =  =    null )     {", "throw   logging . WeldLogger . ROOT _ LOGGER . injectionPointNotAJavabean (  (  ( Method )     ( injectionPoint . getMember (  )  )  )  )  ;", "}", "} else    {", "throw   logging . WeldLogger . ROOT _ LOGGER . cannotInject ( injectionPoint )  ;", "}", "String   className    =    injectionPoint . getMember (  )  . getDeclaringClass (  )  . getName (  )  ;", "return    (  (  (  ( ResourceInjectionUtilities . RESOURCE _ LOOKUP _ PREFIX )     +     \"  /  \"  )     +    className )     +     \"  /  \"  )     +    propertyName ;", "}", "METHOD_END"], "methodName": ["getEjbBindLocation"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbInjectionServices"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( type )  )  ;", "} else", "if    ( type   instanceof   ParameterizedType )     {", "return    . getType (  (  ( ParameterizedType )     ( type )  )  . getRawType (  )  )  ;", "} else    {", "throw   couldNotDetermineUnderlyingType ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbInjectionServices"}, {"methodBody": ["METHOD_START", "{", "final   Set < ViewDescription >    viewService ;", "if    ( ejb . beanName (  )  . isEmpty (  )  )     {", "if    (  ( ejb . beanInterface (  )  )     !  =     ( Object . class )  )     {", "viewService    =    applicationDescription . getComponentsForViewName ( ejb . beanInterface (  )  . getName (  )  ,    deploymentRoot )  ;", "} else    {", "viewService    =    applicationDescription . getComponentsForViewName (  . getType ( injectionPoint . getType (  )  )  . getName (  )  ,    deploymentRoot )  ;", "}", "} else    {", "if    (  ( ejb . beanInterface (  )  )     !  =     ( Object . class )  )     {", "viewService    =    applicationDescription . getComponents ( ejb . beanName (  )  ,    ejb . beanInterface (  )  . getName (  )  ,    deploymentRoot )  ;", "} else    {", "viewService    =    applicationDescription . getComponents ( ejb . beanName (  )  ,     . getType ( injectionPoint . getType (  )  )  . getName (  )  ,    deploymentRoot )  ;", "}", "}", "if    ( injectionPoint . getAnnotated (  )  . isAnnotationPresent ( Produces . class )  )     {", "if    ( viewService . isEmpty (  )  )     {", "throw   WeldLogger . ROOT _ LOGGER . ejbNotResolved ( ejb ,    injectionPoint . getMember (  )  )  ;", "} else", "if    (  ( viewService . size (  )  )     >     1  )     {", "throw   WeldLogger . ROOT _ LOGGER . moreThanOneEjbResolved ( ejb ,    injectionPoint . getMember (  )  ,    viewService )  ;", "}", "} else    {", "if    ( viewService . isEmpty (  )  )     {", "return   null ;", "} else", "if    (  ( viewService . size (  )  )     >     1  )     {", "return   null ;", "}", "}", "return   viewService . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["getViewDescription"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbInjectionServices"}, {"methodBody": ["METHOD_START", "{", "final   ComponentView   view    =    getComponentView ( viewDescription )  ;", "if    (  ( view    !  =    null )     &  &     ( injectionPoint . getAnnotated (  )  . isAnnotationPresent ( Produces . class )  )  )     {", "Class <  ?  >    clazz    =    view . getViewClass (  )  ;", "Class <  ?  >    injectionPointRawType    =    Reflections . getRawType ( injectionPoint . getType (  )  )  ;", "Class <  ?  >    c    =    clazz ;", "boolean   found    =    false ;", "while    (  ( c    !  =    null )     &  &     ( c    !  =     ( Object . class )  )  )     {", "if    ( injectionPointRawType . getName (  )  . equals ( c . getName (  )  )  )     {", "found    =    true ;", "break ;", "}", "c    =    c . getSuperclass (  )  ;", "}", "if    (  ! found )     {", "throw   LOG . invalidResourceProducerType ( injectionPoint . getAnnotated (  )  ,    clazz . getName (  )  )  ;", "}", "return   new   ComponentViewToResourceReferenceFactoryAdapter < Object >  ( view )  ;", "} else    {", "return   new    . LazyResourceReferenceFactory ( viewDescription ,    serviceRegistry )  ;", "}", "}", "METHOD_END"], "methodName": ["handleServiceLookup"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbInjectionServices"}, {"methodBody": ["METHOD_START", "{", "return   bindings . get ( ejbName )  ;", "}", "METHOD_END"], "methodName": ["getBindings"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldEjbServices"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldExecutorServices"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   Class )     {", "return    (  ( Class )     ( type )  )  . getName (  )  ;", "} else", "if    ( type   instanceof   ParameterizedType )     {", "return   classNameFromType (  (  ( ParameterizedType )     ( type )  )  . getRawType (  )  )  ;", "} else    {", "return   type . toString (  )  ;", "}", "}", "METHOD_END"], "methodName": ["classNameFromType"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldJaxwsInjectionServices"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( annotation . name (  )  . isEmpty (  )  )  )     {", "return   annotation . name (  )  ;", "}", "return    (  ( injectionPoint . getMember (  )  . getDeclaringClass (  )  . getName (  )  )     +     \"  /  \"  )     +     ( ResourceUtilities . getPropertyName ( injectionPoint . getMember (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getBindingName"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldJaxwsInjectionServices"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    rawType    =    Reflections . getRawType ( ip . getType (  )  )  ;", "if    (  . class . isAssignableFrom ( rawType )  )     {", "return ;", "}", "if    (  !  ( rawType . isAnnotationPresent ( Web . class )  )  )     {", "throw   LOG . invalidResourceProducerType ( ip . getAnnotated (  )  ,    annotation . value (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateWebServiceRefInjectionPoint"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldJaxwsInjectionServices"}, {"methodBody": ["METHOD_START", "{", "PersistenceUnitMetadata   scopedPu ;", "scopedPu    =    PersistenceUnitSearch . resolvePersistenceUnitSupplier ( deploymentUnit ,    persistenceUnitName )  ;", "if    ( null    =  =    scopedPu )     {", "throw   WeldLogger . ROOT _ LOGGER . couldNotFindPersistenceUnit ( persistenceUnitName ,    deploymentUnit . getName (  )  ,    iPoint )  ;", "}", "return   scopedPu . getScopedPersistenceUnitName (  )  ;", "}", "METHOD_END"], "methodName": ["getScopedPUName"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldJpaInjectionServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( injectionPoint . getType (  )  )    instanceof   Class <  ?  >  )     {", "final   Class <  ?  >    type    =     (  ( Class <  ?  >  )     ( injectionPoint . getType (  )  )  )  ;", "final   String   typeName    =    type . getName (  )  ;", "if    (  . USER _ TRANSACTION _ CLASS _ NAME . equals ( typeName )  )     {", "return    . USER _ TRANSACTION _ LOCATION ;", "} else", "if    (  . HANDLE _ DELEGATE _ CLASS _ NAME . equals ( typeName )  )     {", "injectionTypeNotValue (  . HANDLE _ DELEGATE _ CLASS _ NAME ,    injectionPoint . getMember (  )  )  ;", "return   proposedName ;", "} else", "if    (  . ORB _ CLASS _ NAME . equals ( typeName )  )     {", "injectionTypeNotValue (  . ORB _ CLASS _ NAME ,    injectionPoint . getMember (  )  )  ;", "return   proposedName ;", "} else", "if    (  . TIMER _ SERVICE _ CLASS _ NAME . equals ( typeName )  )     {", "injectionTypeNotValue (  . TIMER _ SERVICE _ CLASS _ NAME ,    injectionPoint . getMember (  )  )  ;", "return   proposedName ;", "} else", "if    (  (  (  (  . EJB _ CONTEXT _ CLASS _ NAME . equals ( typeName )  )     |  |     (  . EJB _ SESSION _ CONTEXT _ CLASS _ NAME . equals ( typeName )  )  )     |  |     (  . EJB _ MESSAGE _ DRIVEN _ CONTEXT _ CLASS _ NAME . equals ( typeName )  )  )     |  |     (  . EJB _ ENTITY _ CONTEXT _ CLASS _ NAME . equals ( typeName )  )  )     {", "return    . EJB _ CONTEXT _ LOCATION ;", "} else", "if    (  . WEB _ SERVICE _ CONTEXT _ CLASS _ NAME . equals ( typeName )  )     {", "return    . WEB _ SERVICE _ CONTEXT _ CLASS _ NAME ;", "} else", "if    (  . TRANSACTION _ SYNC _ REGISTRY _ CLASS _ NAME . equals ( typeName )  )     {", "return    . TRANSACTION _ SYNC _ REGISTRY _ LOCATION ;", "} else    {", "EEDefaultResourceJndiNames   eeDefaultResourceJndiNames    =    moduleDescription . getDefaultResourceJndiNames (  )  ;", "if    (  (  ( eeDefaultResourceJndiNames . getContextService (  )  )     !  =    null )     &  &     (  . EE _ CONTEXT _ SERVICE _ CLASS _ NAME . equals ( typeName )  )  )     {", "return   eeDefaultResourceJndiNames . getContextService (  )  ;", "} else", "if    (  (  ( eeDefaultResourceJndiNames . getDataSource (  )  )     !  =    null )     &  &     (  . EE _ DATASOURCE _ CLASS _ NAME . equals ( typeName )  )  )     {", "return   eeDefaultResourceJndiNames . getDataSource (  )  ;", "} else", "if    (  (  ( eeDefaultResourceJndiNames . getJmsConnectionFactory (  )  )     !  =    null )     &  &     (  . EE _ JMS _ CONNECTION _ FACTORY _ CLASS _ NAME . equals ( typeName )  )  )     {", "return   eeDefaultResourceJndiNames . getJmsConnectionFactory (  )  ;", "} else", "if    (  (  ( eeDefaultResourceJndiNames . getManagedExecutorService (  )  )     !  =    null )     &  &     (  . EE _ MANAGED _ EXECUTOR _ SERVICE _ CLASS _ NAME . equals ( typeName )  )  )     {", "return   eeDefaultResourceJndiNames . getManagedExecutorService (  )  ;", "} else", "if    (  (  ( eeDefaultResourceJndiNames . getManagedScheduledExecutorService (  )  )     !  =    null )     &  &     (  . EE _ MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE _ CLASS _ NAME . equals ( typeName )  )  )     {", "return   eeDefaultResourceJndiNames . getManagedScheduledExecutorService (  )  ;", "} else", "if    (  (  ( eeDefaultResourceJndiNames . getManagedThreadFactory (  )  )     !  =    null )     &  &     (  . EE _ MANAGED _ THREAD _ FACTORY _ CLASS _ NAME . equals ( typeName )  )  )     {", "return   eeDefaultResourceJndiNames . getManagedThreadFactory (  )  ;", "}", "}", "}", "return   proposedName ;", "}", "METHOD_END"], "methodName": ["getEJBResourceName"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    ResourceInjectionUtilities . getResourceAnnotated ( injectionPoint )  . getAnnotation ( Resource . class )  ;", "String   mappedName    =    resource . mappedName (  )  ;", "String   lookup    =    resource . lookup (  )  ;", "if    (  !  ( lookup . isEmpty (  )  )  )     {", "return   lookup ;", "}", "if    (  !  ( mappedName . isEmpty (  )  )  )     {", "return   mappedName ;", "}", "String   proposedName    =    ResourceInjectionUtilities . getResourceName ( injectionPoint )  ;", "return   getEJBResourceName ( injectionPoint ,    proposedName )  ;", "}", "METHOD_END"], "methodName": ["getResourceName"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( name . startsWith (  \" java : global \"  )  )     |  |     ( name . startsWith (  \" java : app \"  )  )  )     |  |     ( name . startsWith (  \" java : module \"  )  )  )     |  |     ( name . startsWith (  \" java : comp \"  )  )  )     |  |     ( name . startsWith (  \" java : jboss \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isKnownNamespace"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldResourceInjectionServices"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged (  (  ( PrivilegedAction < SecurityDomain >  )     (  (  )     -  >    SecurityDomain . getCurrent (  )  )  )  )  ;", "} else    {", "return   SecurityDomain . getCurrent (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCurrentSecurityDomain"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldSecurityServices"}, {"methodBody": ["METHOD_START", "{", "return   securityManagerValue ;", "}", "METHOD_END"], "methodName": ["getSecurityManagerValue"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldSecurityServices"}, {"methodBody": ["METHOD_START", "{", "return   injectedTransaction ;", "}", "METHOD_END"], "methodName": ["getInjectedTransaction"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldTransactionServices"}, {"methodBody": ["METHOD_START", "{", "return   injectedTransactionManager ;", "}", "METHOD_END"], "methodName": ["getInjectedTransactionManager"], "fileName": "org.jboss.as.weld.services.bootstrap.WeldTransactionServices"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isDiscoveredExternalType"], "fileName": "org.jboss.as.weld.spi.ComponentSupport"}, {"methodBody": ["METHOD_START", "{", "return   beanManager . fireProcessInjectionTarget ( injectionTarget . getAnnotatedType (  )  ,    injectionTarget )  ;", "}", "METHOD_END"], "methodName": ["processInjectionTarget"], "fileName": "org.jboss.as.weld.spi.ComponentSupport"}, {"methodBody": ["METHOD_START", "{", "List < ClassInfo >    result    =    new   ArrayList < ClassInfo >  (  )  ;", "for    ( AnnotationInstance   instance    :    instan )     {", "AnnotationTarget   target    =    instance . target (  )  ;", "if    ( target   instanceof   ClassInfo )     {", "result . add (  (  ( ClassInfo )     ( target )  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAnnotatedClasses"], "fileName": "org.jboss.as.weld.util.Indices"}, {"methodBody": ["METHOD_START", "{", "return    (  ( clazz . flags (  )  )     &     ( Indices . ANNOTATION )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isAnnotation"], "fileName": "org.jboss.as.weld.util.Indices"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["cast"], "fileName": "org.jboss.as.weld.util.Reflections"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    clazz    =    javaClass ;     ( clazz    !  =    null )     &  &     ( clazz    !  =     ( Object . class )  )  ;    clazz    =    clazz . getSuperclass (  )  )     {", "if    (  ( clazz    =  =    javaClass )     |  |     ( requiredAnnotation . isAnnotationPresent ( Inherited . class )  )  )     {", "if    (  . containsAnnotations ( clazz . getAnnotations (  )  ,    requiredAnnotation )  )     {", "return   true ;", "}", "}", "for    ( Field   field    :    clazz . getDeclaredFields (  )  )     {", "if    (  . containsAnnotations ( field . getAnnotations (  )  ,    requiredAnnotation )  )     {", "return   true ;", "}", "}", "for    ( Constructor <  ?  >    constructor    :    clazz . getConstructors (  )  )     {", "if    (  . containsAnnotations ( constructor . getAnnotations (  )  ,    requiredAnnotation )  )     {", "return   true ;", "}", "for    ( Annotation [  ]    parameterAnnotations    :    constructor . getParameterAnnotations (  )  )     {", "if    (  . containsAnnotations ( parameterAnnotations ,    requiredAnnotation )  )     {", "return   true ;", "}", "}", "}", "for    ( Method   method    :    clazz . getDeclaredMethods (  )  )     {", "if    (  . containsAnnotations ( method . getAnnotations (  )  ,    requiredAnnotation )  )     {", "return   true ;", "}", "for    ( Annotation [  ]    parameterAnnotations    :    method . getParameterAnnotations (  )  )     {", "if    (  . containsAnnotations ( parameterAnnotations ,    requiredAnnotation )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsAnnotation"], "fileName": "org.jboss.as.weld.util.Reflections"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation   annotation    :    annotations )     {", "Class <  ?    extends   Annotation >    annotationType    =    annotation . annotationType (  )  ;", "if    ( requiredAnnotation . equals ( annotationType )  )     {", "return   true ;", "}", "if    ( checkMetaAnnotations    &  &     (  . containsAnnotation ( annotationType . getAnnotations (  )  ,    requiredAnnotation ,    false )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsAnnotation"], "fileName": "org.jboss.as.weld.util.Reflections"}, {"methodBody": ["METHOD_START", "{", "return   Reflections . containsAnnotation ( annotations ,    requiredAnnotation ,    true )  ;", "}", "METHOD_END"], "methodName": ["containsAnnotations"], "fileName": "org.jboss.as.weld.util.Reflections"}, {"methodBody": ["METHOD_START", "{", "return    ( Reflections . loadClass ( className ,    classLoader )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "org.jboss.as.weld.util.Reflections"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . cast ( classLoader . loadClass ( className )  )  ;", "}    catch    ( Throwable   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.weld.util.Reflections"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    clazz    =    classLoader . loadClass ( className )  ;", "return    (  ( T )     ( clazz . newInstance (  )  )  )  ;", "}    catch    ( IllegalAccessExcep   e )     {", "throw   new   RuntimeExcep ( e )  ;", "}    catch    ( ClassNotFoundExcep   e )     {", "throw   new   RuntimeExcep ( e )  ;", "}    catch    ( InstantiaExcep   e )     {", "throw   new   RuntimeExcep ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.jboss.as.weld.util.Reflections"}, {"methodBody": ["METHOD_START", "{", "if    ( member   instanceof   Method )     {", "return    . getPropertyName (  (  ( Method )     ( member )  )  )  ;", "}", "return   member . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.jboss.as.weld.util.ResourceInjectionUtilities"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =    method . getName (  )  ;", "if    (  ( methodName . matches (  \"  ^  ( get )  .  *  \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )  )     {", "return   Introspor . decapitalize ( methodName . substring (  3  )  )  ;", "} else", "if    (  ( methodName . matches (  \"  ^  ( is )  .  *  \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )  )     {", "return   Introspor . decapitalize ( methodName . substring (  2  )  )  ;", "} else", "if    (  ( methodName . matches (  \"  ^  ( set )  .  *  \"  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     1  )  )     {", "return   Introspor . decapitalize ( methodName . substring (  3  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.jboss.as.weld.util.ResourceInjectionUtilities"}, {"methodBody": ["METHOD_START", "{", "if    ( injectionPoint   instanceof   ParameterInjectionPoint )     {", "return    (  ( ParameterInjectionPoint <  ?  ,     ?  >  )     ( injectionPoint )  )  . getAnnotated (  )  . getDeclaringCallable (  )  ;", "}", "return   injectionPoint . getAnnotated (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceAnnotated"], "fileName": "org.jboss.as.weld.util.ResourceInjectionUtilities"}, {"methodBody": ["METHOD_START", "{", "if    ( mappedName    !  =    null )     {", "return   mappedName ;", "} else", "if    ( jndiName    !  =    null )     {", "return   jndiName ;", "} else    {", "throw   logging . WeldLogger . ROOT _ LOGGER . cannotDetermineResourceName (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceName"], "fileName": "org.jboss.as.weld.util.ResourceInjectionUtilities"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    ResourceInjectionUtilities . getResourceAnnotated ( injectionPoint )  . getAnnotation ( Resource . class )  ;", "String   mappedName    =    resource . mappedName (  )  ;", "if    (  !  ( mappedName . equals (  \"  \"  )  )  )     {", "return   mappedName ;", "}", "String   name    =    resource . name (  )  ;", "if    (  !  ( name . equals (  \"  \"  )  )  )     {", "int   firstSlash    =    name . indexOf (  \"  /  \"  )  ;", "int   colon    =    name . indexOf (  \"  :  \"  )  ;", "if    ( colon    !  =     (  -  1  )  )     {", "if    (  ( firstSlash    =  =     (  -  1  )  )     |  |     ( colon    <    firstSlash )  )     {", "return   name ;", "}", "}", "return    (  ( ResourceInjectionUtilities . RESOURCE _ LOOKUP _ PREFIX )     +     \"  /  \"  )     +    name ;", "}", "String   propertyName ;", "if    (  ( injectionPoint . getMember (  )  )    instanceof   Field )     {", "propertyName    =    injectionPoint . getMember (  )  . getName (  )  ;", "} else", "if    (  ( injectionPoint . getMember (  )  )    instanceof   Method )     {", "propertyName    =    ResourceInjectionUtilities . getPropertyName (  (  ( Method )     ( injectionPoint . getMember (  )  )  )  )  ;", "if    ( propertyName    =  =    null )     {", "throw   injectionPointNotAJavabean (  (  ( Method )     ( injectionPoint . getMember (  )  )  )  )  ;", "}", "} else    {", "throw   cannotInject ( injectionPoint )  ;", "}", "String   className    =    injectionPoint . getMember (  )  . getDeclaringClass (  )  . getName (  )  ;", "return    (  (  (  ( ResourceInjectionUtilities . RESOURCE _ LOOKUP _ PREFIX )     +     \"  /  \"  )     +    className )     +     \"  /  \"  )     +    propertyName ;", "}", "METHOD_END"], "methodName": ["getResourceName"], "fileName": "org.jboss.as.weld.util.ResourceInjectionUtilities"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( clazz    =  =    null )     |  |     ( Object . class . equals ( clazz )  )  )     |  |     ( BootstrapService . class . equals ( clazz )  )  )     {", "return   serviceInterfaces ;", "}", "for    ( Class <  ?  >    interfac 3     :    clazz . getInterfaces (  )  )     {", "if    (  ( Service . class . equals ( interfac 3  )  )     |  |     ( BootstrapService . class . equals ( interfac 3  )  )  )     {", "serviceInterfaces . add ( Reflections .  < Class <  ?    extends   Service >  > cast ( clazz )  )  ;", "}", "}", "for    ( Class <  ?  >    interfac 3     :    clazz . getInterfaces (  )  )     {", ". identifyServiceInterfaces ( interfac 3  ,    serviceInterfaces )  ;", "}", ". identifyServiceInterfaces ( clazz . getSuperclass (  )  ,    serviceInterfaces )  ;", "return   serviceInterfaces ;", "}", "METHOD_END"], "methodName": ["identifyServiceInterfaces"], "fileName": "org.jboss.as.weld.util.ServiceLoaders"}, {"methodBody": ["METHOD_START", "{", "ServiceLoader < BeanDeploymentArchiveServicesProvider >    serviceLoader    =    ServiceLoader . load ( BeanDeploymentArchiveServicesProvider . class ,    WildFlySecurityManager . getClassLoaderPrivileged ( clazz )  )  ;", "List < Service >    services    =    new   ArrayList <  >  (  )  ;", "for    ( BeanDeploymentArchiveServicesProvider   provider    :    serviceLoader )     {", "services . addAll ( provider . getServices ( archive )  )  ;", "}", "Map < Class <  ?    extends   Service >  ,    Service >    servicesMap    =    new   HashMap <  >  (  )  ;", "for    ( Service   service    :    services )     {", "for    ( Class <  ?    extends   Service >    serviceInterface    :     . identifyServiceInterfaces ( service . getClass (  )  ,    new   HashSet (  )  )  )     {", "servicesMap . put ( serviceInterface ,    service )  ;", "}", "}", "return   servicesMap ;", "}", "METHOD_END"], "methodName": ["loadBeanDeploymentArchiveServices"], "fileName": "org.jboss.as.weld.util.ServiceLoaders"}, {"methodBody": ["METHOD_START", "{", "List < Service >    services    =    new   ArrayList <  >  (  )  ;", "for    ( ModuleServicesProvider   provider    :    serviceLoader )     {", "services . addAll ( provider . getServices ( rootDeploymentUnit ,    deploymentUnit ,    module ,    resourceRoot )  )  ;", "}", "Map < Class <  ?    extends   Service >  ,    Service >    servicesMap    =    new   HashMap <  >  (  )  ;", "for    ( Service   service    :    services )     {", "for    ( Class <  ?    extends   Service >    serviceInterface    :     . identifyServiceInterfaces ( service . getClass (  )  ,    new   HashSet (  )  )  )     {", "servicesMap . put ( serviceInterface ,    service )  ;", "}", "}", "return   servicesMap ;", "}", "METHOD_END"], "methodName": ["loadModuleServices"], "fileName": "org.jboss.as.weld.util.ServiceLoaders"}, {"methodBody": ["METHOD_START", "{", "Iterator < T >    iterator    =    load ( serviceClass ,    getClassLoaderPrivileged ( loaderClass )  )  . iterator (  )  ;", "T   service    =    null ;", "while    ( iterator . hasNext (  )  )     {", "if    ( service    !  =    null )     {", "throw   new   IllegalStateException (  (  \" Exactly   one   service   provider   is   required   for :     \"     +    serviceClass )  )  ;", "}", "service    =    iterator . next (  )  ;", "}", "return   Optional . ofNullable ( service )  ;", "}", "METHOD_END"], "methodName": ["loadSingle"], "fileName": "org.jboss.as.weld.util.ServiceLoaders"}, {"methodBody": ["METHOD_START", "{", "String   id    =    deploymentUnit . getName (  )  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "id    =     (  ( deploymentUnit . getParent (  )  . getName (  )  )     +     \"  /  \"  )     +    id ;", "}", "return   id ;", "}", "METHOD_END"], "methodName": ["getDeploymentUnitId"], "fileName": "org.jboss.as.weld.util.Utils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "return   deploymentUnit ;", "}", "return   deploymentUnit . getParent (  )  ;", "}", "METHOD_END"], "methodName": ["getRootDeploymentUnit"], "fileName": "org.jboss.as.weld.util.Utils"}, {"methodBody": ["METHOD_START", "{", "return    \" classes \"  . equals ( resourceRoot . getRootName (  )  )  ;", "}", "METHOD_END"], "methodName": ["isClassesRoot"], "fileName": "org.jboss.as.weld.util.Utils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "map . p ( key ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["putIfValueNotNull"], "fileName": "org.jboss.as.weld.util.Utils"}, {"methodBody": ["METHOD_START", "{", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   EEModuleDescription   module    =    deploymentUnit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "final   WebComponentDescription   componentDescription    =    new   WebComponentDescription ( listener ,    listener ,    module ,    deploymentUnit . getServiceName (  )  ,    applicationClasses )  ;", "module . addComponent ( componentDescription )  ;", "deploymentUnit . addToAttachmentList ( WEB _ COMPONENTS ,    componentDescription . getStartServiceName (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerAsComponent"], "fileName": "org.jboss.as.weld.util.Utils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( BeanManager )     ( new   InitialContext (  )  . lookup (  \" java : comp / BeanManager \"  )  )  )  ;", "}    catch    ( NamingExcept   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getBeanManager"], "fileName": "org.jboss.as.weld.webtier.jsp.WeldJspExpressionFactoryWrapper"}]