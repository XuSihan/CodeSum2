[{"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( ACLResourceDefinition . ACL _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . ACL _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . ACL _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.ACLResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.security.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.security.Attribute"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( AuditResourceDefinition . PROVIDER _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . PROVIDER _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . PROVIDER _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.AuditResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( AuthorizationResourceDefinition . POLICY _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . POLICY _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . POLICY _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.AuthorizationResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( ClassicAuthenticationResourceDefinition . LOGIN _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . LOGIN _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . LOGIN _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.ClassicAuthenticationResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.security.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.security.Element"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( IdentityTrustResourceDefinition . TRUST _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . TRUST _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . TRUST _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.IdentityTrustResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( JASPIAuthenticationResourceDefinition . AUTH _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . AUTH _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . AUTH _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.JASPIAuthenticationResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "xmlMapper    =    null ;", "extensionRegistry    =    null ;", "testParser    =    null ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.jboss.as.security.JSSEParsingUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "xmlMapper    =    Factory . create (  )  ;", "extensionParsingRegistry    =    new   ExtensionRegistry ( ProcessType . EMBEDDED _ SERVER ,    new   RunningModeControl ( RunningMode . NORMAL )  ,    null ,    null ,    null ,    null )  ;", "testParser    =    new   ubsystem . test . TestParser ( mainSubsystemName ,    extensionParsingRegistry )  ;", "xmlMapper . registerRootElement ( new   QName ( TEST _ NAMESPACE ,     \" test \"  )  ,    testParser )  ;", "mainExtension . initializeParsers ( extensionParsingRegistry . getExtensionParsingContext (  \" Test \"  ,    xmlMapper )  )  ;", "}", "METHOD_END"], "methodName": ["initializeParser"], "fileName": "org.jboss.as.security.JSSEParsingUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     (  (  (  \"  < test   xmlns =  \\  \"  \"     +     ( TEST _ NAMESPACE )  )     +     \"  \\  \"  >  \"  )     +     ( ModelTestUtils . readResource ( getClass (  )  ,    subsystemXml )  )  )     +     \"  <  / test >  \"  ;", "final   XMLStreamReader   reader    =    XMLInputFactory . newInstance (  )  . createXMLStreamReader ( new   StringReader ( xml )  )  ;", "final   List < ModelNode >    operationList    =    new   ArrayList < ModelNode >  (  )  ;", "xmlMapper . parseDocument ( operationList ,    reader )  ;", "return   operationList ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.jboss.as.security.JSSEParsingUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "parse (  \" ErrorMissingPassword . xml \"  )  ;", "Assert . fail (  \" There   should   have   been   an   error .  \"  )  ;", "}    catch    ( XMLStreamException   ex )     {", "Assert . assertTrue ( ex . getMessage (  )  ,    ex . getMessage (  )  . contains (  \" WFLYSEC 0  0  2  3  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseMissingPasswordJSSE"], "fileName": "org.jboss.as.security.JSSEParsingUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "parse (  \" securityParserValidJSSE . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testParseValidJSSE"], "fileName": "org.jboss.as.security.JSSEParsingUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "parse (  \" ParserError . xml \"  )  ;", "Assert . fail (  \" There   should   have   been   an   error .  \"  )  ;", "}    catch    ( XMLStreamException   ex )     {", "Assert . assertTrue ( ex . getMessage (  )  ,    ex . getMessage (  )  . contains (  \" WFLYSEC 0  0  2  3  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseWrongJSSE"], "fileName": "org.jboss.as.security.JSSEParsingUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "SecurityDomainReloadWriteHandler   writeHandler    =    new   SecurityDomainReloadWriteHandler ( JSSEResourceDefinition . ATTRIBUTES )  ;", "for    ( AttributeDefinition   attr    :    JSSEResourceDefinition . ATTRIBUTES )     {", "resourceRegistration . registerReadWriteAttribute ( attr ,    null ,    writeHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.JSSEResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( LoginModuleStackResourceDefinition . LOGIN _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . LOGIN _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . LOGIN _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.LoginModuleStackResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   MappingModuleDefinition . ATTRIBUTES ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.jboss.as.security.MappingModuleDefinition"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( MappingResourceDefinition . MAPPING _ MODULES ,    new   LegacySupport . LegacyModulesAttributeReader ( Constants . MAPPING _ MODULE )  ,    new   LegacySupport . LegacyModulesAttributeWriter ( Constants . MAPPING _ MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.MappingResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.security.ModuleName"}, {"methodBody": ["METHOD_START", "{", "return   slot ;", "}", "METHOD_END"], "methodName": ["getSlot"], "fileName": "org.jboss.as.security.ModuleName"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.security.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.security.Namespace"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CurrentServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.security.RealmDirectLoginModule"}, {"methodBody": ["METHOD_START", "{", "if    (  ( callbackHandler )     =  =    null )     {", "callbackHandler    =    Realm . getAuthorizingCallbackHandler ( chosenMech )  ;", "}", "return   callbackHandler ;", "}", "METHOD_END"], "methodName": ["getCallbackHandler"], "fileName": "org.jboss.as.security.RealmDirectLoginModule"}, {"methodBody": ["METHOD_START", "{", "ObjectCallback   oc    =    new   ObjectCallback (  \" Credential :  \"  )  ;", "try    {", "super . callbackHandler . handle ( new   Callback [  ]  {    oc    }  )  ;", "}    catch    ( IOException    |    UnsupportedCallbackException   e )     {", "return   null ;", "}", "Object   credential    =    oc . getCredential (  )  ;", "if    ( credential   instanceof   DigestCredential )     {", "if    ( credential . getClass (  )  . getName (  )  . equals (  \" undertowDigestCredentialImpl \"  )  )     {", "return    (  ( DigestCredential )     ( credential )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDigestCredential"], "fileName": "org.jboss.as.security.RealmDirectLoginModule"}, {"methodBody": ["METHOD_START", "{", "try    {", "AuthorizingCallbackHandler   callbackHandler    =    getCallbackHandler (  )  ;", "callbackHandler . handle ( callbacks )  ;", "}    catch    ( IOException   e )     {", "throw   SLogger . ROOT _ LOGGER . failureCallingSRealm ( e . getMessage (  )  )  ;", "}    catch    ( UnsupportedCallbackException   e )     {", "throw   SLogger . ROOT _ LOGGER . failureCallingSRealm ( e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.jboss.as.security.RealmDirectLoginModule"}, {"methodBody": ["METHOD_START", "{", "final   ApplicationPolicy   applicationPolicy    =    new   ApplicationPolicy ( securityDomain )  ;", "boolean   create ;", "create    =    processClassicAuth ( context ,    securityDomain ,    model ,    applicationPolicy )  ;", "create    |  =    processJASPIAuth ( context ,    securityDomain ,    model ,    applicationPolicy )  ;", "create    |  =    processAuthorization ( context ,    securityDomain ,    model ,    applicationPolicy )  ;", "create    |  =    processACL ( context ,    securityDomain ,    model ,    applicationPolicy )  ;", "create    |  =    processAudit ( context ,    securityDomain ,    model ,    applicationPolicy )  ;", "create    |  =    processIdentityTrust ( context ,    securityDomain ,    model ,    applicationPolicy )  ;", "create    |  =    processMapping ( context ,    securityDomain ,    model ,    applicationPolicy )  ;", "return   create    ?    applicationPolicy    :    null ;", "}", "METHOD_END"], "methodName": ["createApplicationPolicy"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    Constants . JSSE ,    Constants . CLASSIC )  ;", "if    ( node    =  =    null )     {", "return   null ;", "}", "final   JBossJSSESecurityDomain   jsseSecurityDomain    =    new   JBossJSSESecurityDomain ( securityDomain )  ;", "processKeyStore ( context ,    node ,    Constants . KEYSTORE ,    new    . KeyStoreConfig (  )     {", "public   void   setKeyStorePassword ( String   value )    throws   Exception    {", "jsseSecurityDomain . setKeyStorePassword ( value )  ;", "}", "public   void   setKeyStoreType ( String   value )     {", "jsseSecurityDomain . setKeyStoreType ( value )  ;", "}", "public   void   setKeyStoreURL ( String   value )    throws   IOException    {", "jsseSecurityDomain . setKeyStoreURL ( value )  ;", "}", "public   void   setKeyStoreProvider ( String   value )     {", "jsseSecurityDomain . setKeyStoreProvider ( value )  ;", "}", "public   void   setKeyStoreProviderArgument ( String   value )     {", "jsseSecurityDomain . setKeyStoreProviderArgument ( value )  ;", "}", "}  )  ;", "processKeyStore ( context ,    node ,    Constants . TRUSTSTORE ,    new    . KeyStoreConfig (  )     {", "public   void   setKeyStorePassword ( String   value )    throws   Exception    {", "jsseSecurityDomain . setTrustStorePassword ( value )  ;", "}", "public   void   setKeyStoreType ( String   value )     {", "jsseSecurityDomain . setTrustStoreType ( value )  ;", "}", "public   void   setKeyStoreURL ( String   value )    throws   IOException    {", "jsseSecurityDomain . setTrustStoreURL ( value )  ;", "}", "public   void   setKeyStoreProvider ( String   value )     {", "jsseSecurityDomain . setTrustStoreProvider ( value )  ;", "}", "public   void   setKeyStoreProviderArgument ( String   value )     {", "jsseSecurityDomain . setTrustStoreProviderArgument ( value )  ;", "}", "}  )  ;", "processKeyManager ( context ,    node ,    Constants . KEY _ MANAGER ,    new    . KeyManagerConfig (  )     {", "public   void   setKeyManagerFactoryAlgorithm ( String   value )     {", "jsseSecurityDomain . setKeyManagerFactoryAlgorithm ( value )  ;", "}", "public   void   setKeyManagerFactoryProvider ( String   value )     {", "jsseSecurityDomain . setKeyManagerFactoryProvider ( value )  ;", "}", "}  )  ;", "processKeyManager ( context ,    node ,    Constants . TRUST _ MANAGER ,    new    . KeyManagerConfig (  )     {", "public   void   setKeyManagerFactoryAlgorithm ( String   value )     {", "jsseSecurityDomain . setTrustManagerFactoryAlgorithm ( value )  ;", "}", "public   void   setKeyManagerFactoryProvider ( String   value )     {", "jsseSecurityDomain . setTrustManagerFactoryProvider ( value )  ;", "}", "}  )  ;", "String   value ;", "if    ( node . hasDefined ( Constants . CLIENT _ ALIAS )  )     {", "value    =    JSSEResourceDefinition . CLIENT _ ALIAS . resolveModelAttribute ( context ,    node )  . asString (  )  ;", "jsseSecurityDomain . setClientAlias ( value )  ;", "}", "if    ( node . hasDefined ( Constants . SERVER _ ALIAS )  )     {", "value    =    JSSEResourceDefinition . SERVER _ ALIAS . resolveModelAttribute ( context ,    node )  . asString (  )  ;", "jsseSecurityDomain . setServerAlias ( value )  ;", "}", "if    ( node . hasDefined ( Constants . CLIENT _ AUTH )  )     {", "boolean   clientAuth    =    JSSEResourceDefinition . CLIENT _ AUTH . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "jsseSecurityDomain . setClientAuth ( clientAuth )  ;", "}", "if    ( node . hasDefined ( Constants . SERVICE _ AUTH _ TOKEN )  )     {", "value    =    JSSEResourceDefinition . SERVICE _ AUTH _ TOKEN . resolveModelAttribute ( context ,    node )  . asString (  )  ;", "try    {", "jsseSecurityDomain . setServiceAuthToken ( value )  ;", "}    catch    ( Exception   e )     {", "throw   SecurityLogger . ROOT _ LOGGER . runtimeException ( e )  ;", "}", "}", "if    ( node . hasDefined ( Constants . CIPHER _ SUITES )  )     {", "value    =    JSSEResourceDefinition . CIPHER _ SUITES . resolveModelAttribute ( context ,    node )  . asString (  )  ;", "jsseSecurityDomain . setCipherSuites ( value )  ;", "}", "if    ( node . hasDefined ( Constants . PROTOCOLS )  )     {", "value    =    JSSEResourceDefinition . PROTOCOLS . resolveModelAttribute ( context ,    node )  . asString (  )  ;", "jsseSecurityDomain . setProtocols ( value )  ;", "}", "if    ( node . hasDefined ( Constants . ADDITIONAL _ PROPERTIES )  )     {", "Properties   properties    =    new   Properties (  )  ;", "properties . putAll ( JSSEResourceDefinition . ADDITIONAL _ PROPERTIES . unwrap ( context ,    node )  )  ;", "jsseSecurityDomain . setAdditionalProperties ( properties )  ;", "}", "return   jsseSecurityDomain ;", "}", "METHOD_END"], "methodName": ["createJSSESecurityDomain"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "String   code    =    LoginModuleResourceDefinition . CODE . resolveModelAttribute ( context ,    node )  . asString (  )  ;", "if    ( substitutions . containsKey ( code )  )     {", "code    =    substitutions . get ( code )  ;", "}", "return   code ;", "}", "METHOD_END"], "methodName": ["extractCode"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashMap < String ,    Object >  ( MappingModuleDefinition . MODULE _ OPTIONS . unwrap ( context ,    module )  )  ;", "}", "METHOD_END"], "methodName": ["extractOptions"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "String   type    =    null ;", "if    ( node . Defined ( Constants . CACHE _ TYPE )  )     {", "type    =    node . get ( Constants . CACHE _ TYPE ) String (  )  ;", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["getAuthenticationCacheType"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "switch    ( ModuleFlag . valueOf ( flag . toUpperCase ( Locale . ENGLISH )  )  )     {", "case   SUFFICIENT    :", "return   AppConfigurationEntry . LoginModuleControlFlag . SUFFICIENT ;", "case   OPTIONAL    :", "return   AppConfigurationEntry . LoginModuleControlFlag . OPTIONAL ;", "case   REQUISITE    :", "return   AppConfigurationEntry . LoginModuleControlFlag . REQUISITE ;", "case   REQUIRED    :", "default    :", "return   AppConfigurationEntry . LoginModuleControlFlag . REQUIRED ;", "}", "}", "METHOD_END"], "methodName": ["getControlFlag"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "final   ApplicationPolicy   applicationPolicy    =    createApplicationPolicy ( context ,    securityDomain ,    model )  ;", "final   JSSESecurityDomain   jsseSecurityDomain    =    createJSSESecurityDomain ( context ,    securityDomain ,    model )  ;", "final   String   cacheType    =     . getAuthenticationCacheType ( model )  ;", "final   SecurityDomainService   securityDomainService    =    new   SecurityDomainService ( securityDomain ,    applicationPolicy ,    jsseSecurityDomain ,    cacheType )  ;", "final   ServiceTarget   target    =    context . getServiceTarget (  )  ;", "ServiceBuilder < SecurityDomainContext >    builder    =    target . addService ( SecurityDomainService . SERVICE _ NAME . append ( securityDomain )  ,    securityDomainService )  . addAliases ( SecurityDomainResourceDefinition . LEGACY _ SECURITY _ DOMAIN . getCapabilityServiceName ( securityDomain )  )  . addDependency ( SecurityManagementService . SERVICE _ NAME ,    ISecurityManagement . class ,    securityDomainService . getSecurityManagementInjector (  )  )  . addDependency ( JaasConfigurationService . SERVICE _ NAME ,    Configuration . class ,    securityDomainService . getConfigurationInjector (  )  )  ;", "if    ( jsseSecurityDomain    !  =    null )     {", "builder . addDependency ( JBOSS _ CONTEXT _ SERVICE _ NAME . append (  \" jaas \"  )  )  ;", "}", "if    ( SecurityDomainResourceDefinition . INFINISPAN _ CACHE _ TYPE . equals ( cacheType )  )     {", "String   defaultCacheRequirementName    =    CONFIGURATION . resolve ( SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME )  ;", "String   legacyCacheRequirementName    =    InfinispanCacheRequirement . CONFIGURATION . resolve ( SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME ,     . LEGACY _ CACHE _ NAME )  ;", "String   capabilityName    =    SecurityDomainResourceDefinition . LEGACY _ SECURITY _ DOMAIN . getDynamicName ( context . getCurrentAddress (  )  )  ;", "String   cacheTypeAttributeName    =    SecurityDomainResourceDefinition . CACHE _ TYPE . getName (  )  ;", "String   templateCacheName    =    null ;", "if    (  (  !  ( context . hasOptionalCapability ( defaultCacheRequirementName ,    capabilityName ,    cacheTypeAttributeName )  )  )     &  &     ( context . hasOptionalCapability ( legacyCacheRequirementName ,    capabilityName ,    cacheTypeAttributeName )  )  )     {", "SecurityLogger . ROOT _ LOGGER . defaultCacheRequirementMissing ( SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME ,     . LEGACY _ CACHE _ NAME )  ;", "templateCacheName    =     . LEGACY _ CACHE _ NAME ;", "}", "context . requireOptionalCapability ( InfinispanCacheRequirement . CONFIGURATION . resolve ( SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME ,    templateCacheName )  ,    capabilityName ,    cacheTypeAttributeName )  ;", "ServiceName   configurationServiceName    =    InfinispanCacheRequirement . CONFIGURATION . getServiceName ( context ,    SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME ,    securityDomain )  ;", "new   TemplateConfigurationBuilder ( configurationServiceName ,    SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME ,    securityDomain ,    templateCacheName )  . configure ( context )  . build ( target )  . install (  )  ;", "ServiceName   cacheServiceName    =    CACHE . getServiceName ( context ,    SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME ,    securityDomain )  ;", "new   CacheBuilder ( cacheServiceName ,    SecurityDomainResourceDefinition . CACHE _ CONTAINER _ NAME ,    securityDomain )  . configure ( context )  . build ( target )  . install (  )  ;", "builder . addDependency ( cacheServiceName ,    ConcurrentMap . class ,    securityDomainService . getCacheInjector (  )  )  ;", "}", "builder . setInitialMode ( ACTIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( String   arg    :    args )     {", "if    (  !  ( node . hasDefined ( arg )  )  )     {", "return   null ;", "}", "node    =    node . get ( arg )  ;", "}", "return   node ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    Constants . ACL ,    Constants . CLASSIC ,    Constants . ACL _ MODULE )  ;", "if    ( node    =  =    null )     {", "return   false ;", "}", "ACLInfo   aclInfo    =    new   ACLInfo ( securityDomain )  ;", "for    ( Property   moduleProperty    :    node . asPropertyList (  )  )     {", "ModelNode   module    =    moduleProperty . getValue (  )  ;", "String   codeName    =    LoginModuleResourceDefinition . CODE . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "String   flag    =    LoginModuleResourceDefinition . FLAG . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "ControlFlag   controlFlag    =    ControlFlag . valueOf ( flag )  ;", "Map < String ,    Object >    options    =    extractOptions ( context ,    module )  ;", "ACLProviderEntry   entry    =    new   ACLProviderEntry ( codeName ,    options )  ;", "entry . setControlFlag ( controlFlag )  ;", "aclInfo . add ( entry )  ;", "ModelNode   moduleName    =    LoginModuleResourceDefinition . MODULE . resolveModelAttribute ( context ,    module )  ;", "if    (  ( moduleName . isDefined (  )  )     &  &     (  !  ( moduleName . asString (  )  . isEmpty (  )  )  )  )     {", "aclInfo . addJBossModuleName ( moduleName . asString (  )  )  ;", "} else    {", "aclInfo . addJBossModuleName (  . DEFAULT _ MODULE )  ;", "}", "}", "applicationPolicy . setAclInfo ( aclInfo )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["processACL"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    Constants . AUDIT ,    Constants . CLASSIC ,    Constants . PROVIDER _ MODULE )  ;", "if    ( node    =  =    null )     {", "return   false ;", "}", "AuditInfo   auditInfo    =    new   AuditInfo ( securityDomain )  ;", "for    ( Property   moduleProperty    :    node . asPropertyList (  )  )     {", "ModelNode   module    =    moduleProperty . getValue (  )  ;", "String   codeName    =    MappingProviderModuleDefinition . CODE . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "Map < String ,    Object >    options    =    extractOptions ( context ,    module )  ;", "AuditProviderEntry   entry    =    new   AuditProviderEntry ( codeName ,    options )  ;", "auditInfo . add ( entry )  ;", "ModelNode   moduleName    =    MappingProviderModuleDefinition . MODULE . resolveModelAttribute ( context ,    module )  ;", "if    (  ( moduleName . isDefined (  )  )     &  &     (  !  ( moduleName . asString (  )  . isEmpty (  )  )  )  )     {", "auditInfo . addJBossModuleName ( moduleName . asString (  )  )  ;", "} else    {", "auditInfo . addJBossModuleName (  . DEFAULT _ MODULE )  ;", "}", "}", "applicationPolicy . setAuditInfo ( auditInfo )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["processAudit"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    Constants . AUTHORIZATION ,    Constants . CLASSIC ,    Constants . POLICY _ MODULE )  ;", "if    ( node    =  =    null )     {", "return   false ;", "}", "AuthorizationInfo   authzInfo    =    new   AuthorizationInfo ( securityDomain )  ;", "for    ( Property   moduleProperty    :    node . asPropertyList (  )  )     {", "ModelNode   module    =    moduleProperty . getValue (  )  ;", "String   codeName    =     . extractCode ( context ,    module ,    ModulesMap . AUTHORIZATION _ MAP )  ;", "String   flag    =    LoginModuleResourceDefinition . FLAG . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "ControlFlag   controlFlag    =    ControlFlag . valueOf ( flag )  ;", "Map < String ,    Object >    options    =    extractOptions ( context ,    module )  ;", "AuthorizationModuleEntry   authzModuleEntry    =    new   AuthorizationModuleEntry ( codeName ,    options )  ;", "authzModuleEntry . setControlFlag ( controlFlag )  ;", "authzInfo . add ( authzModuleEntry )  ;", "ModelNode   moduleName    =    LoginModuleResourceDefinition . MODULE . resolveModelAttribute ( context ,    module )  ;", "if    (  ( moduleName . isDefined (  )  )     &  &     (  !  ( moduleName . asString (  )  . isEmpty (  )  )  )  )     {", "authzInfo . addJBossModuleName ( moduleName . asString (  )  )  ;", "} else    {", "authzInfo . addJBossModuleName (  . DEFAULT _ MODULE )  ;", "}", "}", "applicationPolicy . setAuthorizationInfo ( authzInfo )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["processAuthorization"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    AUTHENTICATION ,    Constants . CLASSIC )  ;", "if    ( node    =  =    null )     {", "return   false ;", "}", "final   AuthenticationInfo   authenticationInfo    =    new   AuthenticationInfo ( securityDomain )  ;", "if    ( node . hasDefined ( Constants . LOGIN _ MODULE )  )     {", "processLoginModules ( context ,    node . get ( Constants . LOGIN _ MODULE )  ,    authenticationInfo ,    new    . LoginModuleContainer (  )     {", "public   void   addAppConfigurationEntry ( AppConfigurationEntry   entry )     {", "authenticationInfo . add ( entry )  ;", "}", "}  )  ;", "}", "applicationPolicy . setAuthenticationInfo ( authenticationInfo )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["processClassicAuth"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    Constants . IDENTITY _ TRUST ,    Constants . CLASSIC ,    Constants . TRUST _ MODULE )  ;", "if    ( node    =  =    null )     {", "return   false ;", "}", "IdentityTrustInfo   identityTrustInfo    =    new   IdentityTrustInfo ( securityDomain )  ;", "for    ( Property   moduleProperty    :    node . asPropertyList (  )  )     {", "ModelNode   module    =    moduleProperty . getValue (  )  ;", "String   codeName    =    LoginModuleResourceDefinition . CODE . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "String   flag    =    LoginModuleResourceDefinition . FLAG . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "ControlFlag   controlFlag    =    ControlFlag . valueOf ( flag )  ;", "Map < String ,    Object >    options    =    extractOptions ( context ,    module )  ;", "IdentityTrustModuleEntry   entry    =    new   IdentityTrustModuleEntry ( codeName ,    options )  ;", "entry . setControlFlag ( controlFlag )  ;", "identityTrustInfo . add ( entry )  ;", "ModelNode   moduleName    =    LoginModuleResourceDefinition . MODULE . resolveModelAttribute ( context ,    module )  ;", "if    (  ( moduleName . isDefined (  )  )     &  &     (  !  ( moduleName . asString (  )  . isEmpty (  )  )  )  )     {", "identityTrustInfo . addJBossModuleName ( moduleName . asString (  )  )  ;", "} else    {", "identityTrustInfo . addJBossModuleName (  . DEFAULT _ MODULE )  ;", "}", "}", "applicationPolicy . setIdentityTrustInfo ( identityTrustInfo )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["processIdentityTrust"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    AUTHENTICATION ,    Constants . JASPI )  ;", "if    ( node    =  =    null )     {", "return   false ;", "}", "JASPIAuthenticationInfo   authenticationInfo    =    new   JASPIAuthenticationInfo ( securityDomain )  ;", "Map < String ,    LoginModuleStackHolder >    holders    =    new   HashMap < String ,    LoginModuleStackHolder >  (  )  ;", "if    ( node . hasDefined ( Constants . LOGIN _ MODULE _ STACK )  )     {", "List < Property >    stacks    =    node . get ( Constants . LOGIN _ MODULE _ STACK )  . asPropertyList (  )  ;", "for    ( Property   stack    :    stacks )     {", "String   name    =    stack . getName (  )  ;", "ModelNode   stackNode    =    stack . getValue (  )  ;", "final   LoginModuleStackHolder   holder    =    new   LoginModuleStackHolder ( name ,    null )  ;", "holders . put ( name ,    holder )  ;", "authenticationInfo . add ( holder )  ;", "if    ( stackNode . hasDefined ( Constants . LOGIN _ MODULE )  )     {", "processLoginModules ( context ,    stackNode . get ( Constants . LOGIN _ MODULE )  ,    authenticationInfo ,    new    . LoginModuleContainer (  )     {", "public   void   addAppConfigurationEntry ( AppConfigurationEntry   entry )     {", "holder . addAppConfigurationEntry ( entry )  ;", "}", "}  )  ;", "}", "}", "}", "for    ( Property   moduleProperty    :    node . get ( Constants . AUTH _ MODULE )  . asPropertyList (  )  )     {", "ModelNode   authModule    =    moduleProperty . getValue (  )  ;", "String   code    =     . extractCode ( context ,    authModule ,    ModulesMap . AUTHENTICATION _ MAP )  ;", "String   loginStackRef    =    null ;", "if    ( authModule . hasDefined ( Constants . LOGIN _ MODULE _ STACK _ REF )  )     {", "loginStackRef    =    JASPIMappingModuleDefinition . LOGIN _ MODULE _ STACK _ REF . resolveModelAttribute ( context ,    authModule )  . asString (  )  ;", "}", "Map < String ,    Object >    options    =    extractOptions ( context ,    authModule )  ;", "AuthModuleEntry   entry    =    new   AuthModuleEntry ( code ,    options ,    loginStackRef )  ;", "if    ( authModule . hasDefined ( Constants . FLAG )  )     {", "String   flag    =    LoginModuleResourceDefinition . FLAG . resolveModelAttribute ( context ,    authModule )  . asString (  )  ;", "entry . setControlFlag ( ControlFlag . valueOf ( flag )  )  ;", "}", "if    ( loginStackRef    !  =    null )     {", "if    (  !  ( holders . containsKey ( loginStackRef )  )  )     {", "throw   SecurityLogger . ROOT _ LOGGER . loginModuleStackIllegalArgument ( loginStackRef )  ;", "}", "entry . setLoginModuleStackHolder ( holders . get ( loginStackRef )  )  ;", "}", "authenticationInfo . add ( entry )  ;", "ModelNode   moduleName    =    LoginModuleResourceDefinition . MODULE . resolveModelAttribute ( context ,    authModule )  ;", "if    (  ( moduleName . isDefined (  )  )     &  &     (  !  ( moduleName . asString (  )  . isEmpty (  )  )  )  )     {", "authenticationInfo . addJBossModuleName ( moduleName . asString (  )  )  ;", "} else    {", "authenticationInfo . addJBossModuleName (  . DEFAULT _ MODULE )  ;", "}", "}", "applicationPolicy . setAuthenticationInfo ( authenticationInfo )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["processJASPIAuth"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   algorithm    =    peek ( node ,    name ,    Constants . ALGORITHM )  ;", "final   ModelNode   provider    =    peek ( node ,    name ,    Constants . PROVIDER )  ;", "if    ( algorithm    !  =    null )     {", "config . setKeyManagerFactoryAlgorithm ( context . resolveExpressions ( algorithm )  . asString (  )  )  ;", "}", "if    ( provider    !  =    null )     {", "config . setKeyManagerFactoryProvider ( context . resolveExpressions ( provider )  . asString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processKeyManager"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   value    =    peek ( node ,    name ,    Constants . PASSWORD )  ;", "final   ModelNode   type    =    peek ( node ,    name ,    Constants . TYPE )  ;", "final   ModelNode   url    =    peek ( node ,    name ,    Constants . URL )  ;", "final   ModelNode   provider    =    peek ( node ,    name ,    Constants . PROVIDER )  ;", "final   ModelNode   providerArgument    =    peek ( node ,    name ,    Constants . PROVIDER _ ARGUMENT )  ;", "if    ( value    !  =    null )     {", "try    {", "config . setKeyStorePassword ( context . resolveExpressions ( value )  . asString (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   Logger . ROOT _ LOGGER . runtimeException ( e )  ;", "}", "}", "if    ( type    !  =    null )     {", "config . setKeyStoreType ( context . resolveExpressions ( type )  . asString (  )  )  ;", "}", "if    ( url    !  =    null )     {", "try    {", "config . setKeyStoreURL ( context . resolveExpressions ( url )  . asString (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   Logger . ROOT _ LOGGER . runtimeException ( e )  ;", "}", "}", "if    ( provider    !  =    null )     {", "config . setKeyStoreProvider ( context . resolveExpressions ( provider )  . asString (  )  )  ;", "}", "if    ( providerArgument    !  =    null )     {", "config . setKeyStoreProviderArgument ( context . resolveExpressions ( providerArgument )  . asString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processKeyStore"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( Property   moduleProperty    :    node . asPropertyList (  )  )     {", "ModelNode   module    =    moduleProperty . getValue (  )  ;", "String   codeName    =     . extractCode ( context ,    module ,    ModulesMap . AUTHENTICATION _ MAP )  ;", "String   flag    =    LoginModuleResourceDefinition . FLAG . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "AppConfigurationEntry . LoginModuleControlFlag   controlFlag    =    getControlFlag ( flag )  ;", "Map < String ,    Object >    options    =    extractOptions ( context ,    module )  ;", "AppConfigurationEntry   entry    =    new   AppConfigurationEntry ( codeName ,    controlFlag ,    options )  ;", "container . addAppConfigurationEntry ( entry )  ;", "ModelNode   moduleName    =    LoginModuleResourceDefinition . MODULE . resolveModelAttribute ( context ,    module )  ;", "if    (  ( moduleName . isDefined (  )  )     &  &     (  !  ( moduleName . asString (  )  . isEmpty (  )  )  )  )     {", "authInfo . addJBossModuleName ( moduleName . asString (  )  )  ;", "} else    {", "authInfo . addJBossModuleName (  . DEFAULT _ MODULE )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processLoginModules"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "node    =    peek ( node ,    Constants . MAPPING ,    Constants . CLASSIC ,    Constants . MAPPING _ MODULE )  ;", "if    ( node    =  =    null )     {", "return   false ;", "}", "for    ( Property   moduleProperty    :    node . asPropertyList (  )  )     {", "ModelNode   module    =    moduleProperty . getValue (  )  ;", "MappingInfo   mappingInfo    =    new   MappingInfo ( securityDomain )  ;", "String   codeName    =     . extractCode ( context ,    module ,    ModulesMap . MAPPING _ MAP )  ;", "String   mappingType ;", "if    ( module . hasDefined ( Constants . TYPE )  )     {", "mappingType    =    MappingModuleDefinition . TYPE . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "} else    {", "mappingType    =    ROLE . toString (  )  ;", "}", "Map < String ,    Object >    options    =    extractOptions ( context ,    module )  ;", "MappingModuleEntry   entry    =    new   MappingModuleEntry ( codeName ,    options ,    mappingType )  ;", "mappingInfo . add ( entry )  ;", "applicationPolicy . setMappingInfo ( mappingType ,    mappingInfo )  ;", "ModelNode   moduleName    =    LoginModuleResourceDefinition . MODULE . resolveModelAttribute ( context ,    module )  ;", "if    (  ( moduleName . isDefined (  )  )     &  &     (  !  ( moduleName . asString (  )  . isEmpty (  )  )  )  )     {", "mappingInfo . addJBossModuleName ( moduleName . asString (  )  )  ;", "} else    {", "mappingInfo . addJBossModuleName (  . DEFAULT _ MODULE )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["processMapping"], "fileName": "org.jboss.as.security.SecurityDomainAdd"}, {"methodBody": ["METHOD_START", "{", "super . standardSubsystemTest (  \" securitysubsystemJASPIv 1  1  . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testParseAndMarshalModelWithJASPI"], "fileName": "org.jboss.as.security.SecurityDomainModelv11UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( SecurityDomainModelv 1  2 UnitTestCase . oldConfig )     !  =    null )     {", "System . setProperty (  \" jboss . server . config . dir \"  ,    SecurityDomainModelv 1  2 UnitTestCase . oldConfig )  ;", "} else    {", "System . clearProperty (  \" jboss . server . config . dir \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["afterClass"], "fileName": "org.jboss.as.security.SecurityDomainModelv12UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   target    =    new   File ( SecurityDomainModelv 1  1 UnitTestCase . class . getProtectionDomain (  )  . getCodeSource (  )  . getLocation (  )  . toURI (  )  )  . getParentFile (  )  ;", "File   config    =    new   File ( target ,     \" config \"  )  ;", "config . mkdir (  )  ;", ". oldConfig    =    System . setProperty (  \" jboss . server . config . dir \"  ,    config . getAbsolutePath (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["beforeClass"], "fileName": "org.jboss.as.security.SecurityDomainModelv12UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   service    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" securitysubsystemv 1  2  . xml \"  )  . build (  )  ;", "PathAddress   address    =    PathAddress . pathAddress (  )  . append (  \" subsystem \"  ,     \" security \"  )  . append (  \" security - domain \"  ,     \" ordering \"  )  ;", "address    =    address . append (  \" authentication \"  ,     \" classic \"  )  ;", "ModelNode   writeOp    =    Util . createOperation (  \" write - attribute \"  ,    address )  ;", "writeOp . get (  \" name \"  )  . set (  \" login - modules \"  )  ;", "for    ( int   i    =     1  ;    i    <  =     6  ;    i +  +  )     {", "ModelNode   module    =    writeOp . get (  \" value \"  )  . add (  )  ;", "module . get (  \" code \"  )  . set (  (  \" module -  \"     +    i )  )  ;", "module . get (  \" flag \"  )  . set (  \" optional \"  )  ;", "module . get (  \" module - options \"  )  ;", "}", "service . executeOperation ( writeOp )  ;", "ModelNode   readOp    =    Util . createOperation (  \" read - attribute \"  ,    address )  ;", "readOp . get (  \" name \"  )  . set (  \" login - modules \"  )  ;", "ModelNode   result    =    service . executeForResult ( readOp )  ;", "List < ModelNode >    modules    =    result . asList (  )  ;", "Assert . assertEquals (  \" There   should   be   exactly    6    modules   but   there   are   not \"  ,     6  ,    modules . size (  )  )  ;", "for    ( int   i    =     1  ;    i    <  =     6  ;    i +  +  )     {", "ModelNode   module    =    modules . get (  ( i    -     1  )  )  ;", "Assert . assertEquals ( module . get (  \" code \"  )  . asString (  )  ,     (  \" module -  \"     +    i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testOrder"], "fileName": "org.jboss.as.security.SecurityDomainModelv12UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" securitysubsystemv 1  . xml \"  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   modelA    =    servicesA . readWholeModel (  )  ;", "String   marshalled    =    servicesA . getPersistedSubsystemXml (  )  ;", "servicesA . shutdown (  )  ;", "KernelServices   servicesB    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( marshalled )  . build (  )  ;", "ModelNode   modelB    =    servicesB . readWholeModel (  )  ;", "super . compare ( modelA ,    modelB )  ;", "}", "METHOD_END"], "methodName": ["testParseAndMarshalModel"], "fileName": "org.jboss.as.security.SecurityDomainModelv1UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" securitysubsystemJASPIv 1  . xml \"  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   modelA    =    servicesA . readWholeModel (  )  ;", "String   marshalled    =    servicesA . getPersistedSubsystemXml (  )  ;", "servicesA . shutdown (  )  ;", "KernelServices   servicesB    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( marshalled )  . build (  )  ;", "ModelNode   modelB    =    servicesB . readWholeModel (  )  ;", "super . compare ( modelA ,    modelB )  ;", "assertRemoveSubsystemResources ( servicesB )  ;", "}", "METHOD_END"], "methodName": ["testParseAndMarshalModelWithJASPI"], "fileName": "org.jboss.as.security.SecurityDomainModelv1UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( SecurityDomainModelv 2  0 UnitTestCase . oldConfig )     !  =    null )     {", "System . setProperty (  \" jboss . server . config . dir \"  ,    SecurityDomainModelv 2  0 UnitTestCase . oldConfig )  ;", "} else    {", "System . clearProperty (  \" jboss . server . config . dir \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["afterClass"], "fileName": "org.jboss.as.security.SecurityDomainModelv20UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   target    =    new   File (  . class . getProtectionDomain (  )  . getCodeSource (  )  . getLocation (  )  . toURI (  )  )  . getParentFile (  )  ;", "File   config    =    new   File ( target ,     \" config \"  )  ;", "config . mkdir (  )  ;", ". oldConfig    =    System . setProperty (  \" jboss . server . config . dir \"  ,    config . getAbsolutePath (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["beforeClass"], "fileName": "org.jboss.as.security.SecurityDomainModelv20UnitTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ServiceController < SecurityDomainContext >  )     ( context . getServiceRegistry ( false )  . getRequiredService ( SecurityDomainService . SERVICE _ NAME . append ( securityDomain )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSecurityDomainService"], "fileName": "org.jboss.as.security.SecurityDomainResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "PathAddress   domain    =    Util . getParentAddressByKey ( pathAddress ,    Constants . SECURITY _ DOMAIN )  ;", "if    ( domain    =  =    null )", "throw   logging . SecurityLogger . ROOT _ LOGGER . addressDidNotContainSecurityDomain (  )  ;", "return   SecurityDomainService . SERVICE _ NAME . append ( domain . getLastElement (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSecurityDomainServiceName"], "fileName": "org.jboss.as.security.SecurityDomainResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  ( controller . getState (  )  )     =  =     ( State . UP )  )", "return ;", "final   StabilityMonitor   monitor    =    new   StabilityMonitor (  )  ;", "monitor . addController ( controller )  ;", "try    {", "monitor . awaitStability (  1  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}    catch    ( final   InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "throw   SecurityLogger . ROOT _ LOGGER . interruptedWaitingFor ( controller . getName (  )  . getSimpleName (  )  )  ;", "}    finally    {", "monitor . removeController ( controller )  ;", "}", "if    (  ( controller . getState (  )  )     !  =     ( State . UP )  )     {", "throw   SecurityLogger . ROOT _ LOGGER . requiredServiceNotAvailable ( controller . getName (  )  . getSimpleName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForService"], "fileName": "org.jboss.as.security.SecurityDomainResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   DeprecatedResourceDescriptionResolver ( SecurityExtension . SUBSYSTEM _ NAME ,    keyPrefix ,    SecurityExtension . RESOURCE _ NAME ,    SecurityExtension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.security.SecurityExtension"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder (  )  ;", "for    ( String   kp    :    keyPrefix )     {", "if    (  ( prefix . length (  )  )     >     0  )     {", "prefix . append (  '  .  '  )  ;", "}", "prefix . append ( kp )  ;", "}", "return   new   DeprecatedResourceDescriptionResolver (  . SUBSYSTEM _ NAME ,    prefix . toString (  )  ,     . RESOURCE _ NAME ,     . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.security.SecurityExtension"}, {"methodBody": ["METHOD_START", "{", "ModelNode   op    =    createAddOperation ( parentAddress ,    name ,    value )  ;", "list . add ( op )  ;", "return   op ;", "}", "METHOD_END"], "methodName": ["appendAddOperation"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "return   Util . createAddOperation ( parentAddress . append ( name ,    value )  )  ;", "}", "METHOD_END"], "methodName": ["createAddOperation"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "PathAddreddress    =    parentAddreppend ( Constants . ACL ,    Constants . CLASSIC )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ACL _ MODULE    :", "{", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . CODE ,    Attribute . FLAG )  ;", "EnumSet < Attribute >    notAllowed    =    EnumSet . of ( Attribute . TYPE ,    Attribute . LOGIN _ MODULE _ STACK _ REF )  ;", "parseCommonModule ( reader ,    address ,    Constants . ACL _ MODULE ,    required ,    notAllowed ,    list )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseACL"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "PathAddreddress    =    parentAddreppend ( Constants . AUDIT ,    Constants . CLASSIC )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROVIDER _ MODULE    :", "{", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . CODE )  ;", "EnumSet < Attribute >    notAllowed    =    EnumSet . of ( Attribute . TYPE ,    Attribute . FLAG ,    Attribute . LOGIN _ MODULE _ STACK _ REF )  ;", "parseCommonModule ( reader ,    address ,    Constants . PROVIDER _ MODULE ,    required ,    notAllowed ,    list )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseAudit"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "Namespace   schemaVer    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . CODE )  ;", "final   EnumSet < Attribute >    notAllowed ;", "switch    ( schemaVer )     {", "case   SECURITY _  1  _  0     :", "case   SECURITY _  1  _  1     :", "notAllowed    =    EnumSet . of ( Attribute . TYPE ,    Attribute . FLAG )  ;", "break ;", "default    :", "notAllowed    =    EnumSet . of ( Attribute . TYPE )  ;", "}", "pCommonModule ( reader ,    parentAddress ,    Constants . AUTH _ MODULE ,    required ,    notAllowed ,    list )  ;", "}", "METHOD_END"], "methodName": ["parseAuthModule"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "PathAddreddress    =    parentAddreppend ( Constants . AUTHENTICATION ,    Constants . CLASSIC )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "parseLoginModules ( reader ,    address ,    list )  ;", "}", "METHOD_END"], "methodName": ["parseAuthentication"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "PathAddreddress    =    parentAddreppend ( Constants . AUTHENTICATION ,    Constants . JASPI )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   LOGIN _ MODULE _ STACK    :", "{", "parseLoginModuleStack ( list ,    address ,    reader )  ;", "break ;", "}", "case   AUTH _ MODULE    :", "{", "parseAuthModule ( list ,    reader ,    address )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseAuthenticationJaspi"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "PathAddreddress    =    parentAddreppend ( Constants . AUTHORIZATION ,    Constants . CLASSIC )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   POLICY _ MODULE    :", "{", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . CODE ,    Attribute . FLAG )  ;", "EnumSet < Attribute >    notAllowed    =    EnumSet . of ( Attribute . TYPE ,    Attribute . LOGIN _ MODULE _ STACK _ REF )  ;", "parseCommonModule ( reader ,    address ,    Constants . POLICY _ MODULE ,    required ,    notAllowed ,    list )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseAuthorization"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   node    =    Util . createAddOperation ( parentAddress )  ;", "String   code    =    null ;", "String   name    =    null ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "if    ( notAllowed . contains ( attribute )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   CODE    :", "{", "code    =    value ;", "LoginModuleResourceDefinition . CODE . pAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   FLAG    :", "{", "LoginModuleResourceDefinition . FLAG . pAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   TYPE    :", "{", "MappingModuleDefinition . TYPE . pAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   MODULE    :", "{", "LoginModuleResourceDefinition . MODULE . pAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   LOGIN _ MODULE _ STACK _ REF    :", "{", "JASPIMappingModuleDefinition . LOGIN _ MODULE _ STACK _ REF . pAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( name    =  =    null )     {", "name    =    code ;", "}", "String   key    =     ( keyName    +     \"  -  \"  )     +    name ;", "if    (  ( moduleNames . put ( key ,     1  )  )     !  =    null )     {", "for    ( int   i    =     2  ;     ;    i +  +  )     {", "name    =     ( code    +     \"  -  \"  )     +    i ;", "key    =     ( keyName    +     \"  -  \"  )     +    name ;", "if    (  !  ( moduleNames . containsKey ( key )  )  )     {", "moduleNames . put ( key ,    i )  ;", "break ;", "}", "}", "}", "node . get ( OP _ ADDR )  . set ( parentAddress . append ( keyName ,    name )  . toModelNode (  )  )  ;", "if    (  ( required . size (  )  )     >     0  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "pProperties ( Element . MODULE _ OPTION . getLocalName (  )  ,    reader ,    node ,    LoginModuleResourceDefinition . MODULE _ OPTIONS )  ;", "list . add ( node )  ;", "}", "METHOD_END"], "methodName": ["parseCommonModule"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "PathAddreddress    =    parentAddreppend ( Constants . IDENTITY _ TRUST ,    Constants . CLASSIC )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   TRUST _ MODULE    :", "{", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . CODE ,    Attribute . FLAG )  ;", "EnumSet < Attribute >    notAllowed    =    EnumSet . of ( Attribute . TYPE ,    Attribute . LOGIN _ MODULE _ STACK _ REF )  ;", "parseCommonModule ( reader ,    address ,    Constants . TRUST _ MODULE ,    required ,    notAllowed ,    list )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseIdentityTrust"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   op    =    appendAddOperation ( list ,    parentAddress ,    Constants . JSSE ,    Constants . CLASSIC )  ;", "EnumSet < Attribute >    visited    =    EnumSet . noneOf ( Attribute . class )  ;", "EnumSet < Attribute >    required    =    EnumSet . noneOf ( Attribute . class )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   KEYSTORE _ PASSWORD    :", "{", "ComplexAttributes . PASSWORD . parseAndSetParameter ( value ,    op . get ( Constants . KEYSTORE )  ,    reader )  ;", "visited . add ( attribute )  ;", "break ;", "}", "case   KEYSTORE _ TYPE    :", "{", "ComplexAttributes . TYPE . parseAndSetParameter ( value ,    op . get ( Constants . KEYSTORE )  ,    reader )  ;", "required . add ( Attribute . KEYSTORE _ PASSWORD )  ;", "break ;", "}", "case   KEYSTORE _ URL    :", "{", "ComplexAttributes . URL . parseAndSetParameter ( value ,    op . get ( Constants . KEYSTORE )  ,    reader )  ;", "required . add ( Attribute . KEYSTORE _ PASSWORD )  ;", "break ;", "}", "case   KEYSTORE _ PROVIDER    :", "{", "ComplexAttributes . PROVIDER . parseAndSetParameter ( value ,    op . get ( Constants . KEYSTORE )  ,    reader )  ;", "required . add ( Attribute . KEYSTORE _ PASSWORD )  ;", "break ;", "}", "case   KEYSTORE _ PROVIDER _ ARGUMENT    :", "{", "ComplexAttributes . PROVIDER _ ARGUMENT . parseAndSetParameter ( value ,    op . get ( Constants . KEYSTORE )  ,    reader )  ;", "required . add ( Attribute . KEYSTORE _ PASSWORD )  ;", "break ;", "}", "case   KEY _ MANAGER _ FACTORY _ PROVIDER    :", "{", "ComplexAttributes . PROVIDER . parseAndSetParameter ( value ,    op . get ( Constants . KEY _ MANAGER )  ,    reader )  ;", "break ;", "}", "case   KEY _ MANAGER _ FACTORY _ ALGORITHM    :", "{", "ComplexAttributes . ALGORITHM . parseAndSetParameter ( value ,    op . get ( Constants . KEY _ MANAGER )  ,    reader )  ;", "break ;", "}", "case   TRUSTSTORE _ PASSWORD    :", "{", "ComplexAttributes . PASSWORD . parseAndSetParameter ( value ,    op . get ( Constants . TRUSTSTORE )  ,    reader )  ;", "visited . add ( attribute )  ;", "break ;", "}", "case   TRUSTSTORE _ TYPE    :", "{", "ComplexAttributes . TYPE . parseAndSetParameter ( value ,    op . get ( Constants . TRUSTSTORE )  ,    reader )  ;", "required . add ( Attribute . TRUSTSTORE _ PASSWORD )  ;", "break ;", "}", "case   TRUSTSTORE _ URL    :", "{", "ComplexAttributes . URL . parseAndSetParameter ( value ,    op . get ( Constants . TRUSTSTORE )  ,    reader )  ;", "required . add ( Attribute . TRUSTSTORE _ PASSWORD )  ;", "break ;", "}", "case   TRUSTSTORE _ PROVIDER    :", "{", "ComplexAttributes . PROVIDER . parseAndSetParameter ( value ,    op . get ( Constants . TRUSTSTORE )  ,    reader )  ;", "required . add ( Attribute . TRUSTSTORE _ PASSWORD )  ;", "break ;", "}", "case   TRUSTSTORE _ PROVIDER _ ARGUMENT    :", "{", "ComplexAttributes . PROVIDER _ ARGUMENT . parseAndSetParameter ( value ,    op . get ( Constants . TRUSTSTORE )  ,    reader )  ;", "required . add ( Attribute . TRUSTSTORE _ PASSWORD )  ;", "break ;", "}", "case   TRUST _ MANAGER _ FACTORY _ PROVIDER    :", "{", "ComplexAttributes . PROVIDER . parseAndSetParameter ( value ,    op . get ( Constants . TRUST _ MANAGER )  ,    reader )  ;", "break ;", "}", "case   TRUST _ MANAGER _ FACTORY _ ALGORITHM    :", "{", "ComplexAttributes . ALGORITHM . parseAndSetParameter ( value ,    op . get ( Constants . TRUST _ MANAGER )  ,    reader )  ;", "break ;", "}", "case   CLIENT _ ALIAS    :", "{", "JSSEResourceDefinition . CLIENT _ ALIAS . parseAndSetParameter ( value ,    op ,    reader )  ;", "break ;", "}", "case   SERVER _ ALIAS    :", "{", "JSSEResourceDefinition . SERVER _ ALIAS . parseAndSetParameter ( value ,    op ,    reader )  ;", "break ;", "}", "case   CLIENT _ AUTH    :", "{", "JSSEResourceDefinition . CLIENT _ AUTH . parseAndSetParameter ( value ,    op ,    reader )  ;", "break ;", "}", "case   SERVICE _ AUTH _ TOKEN    :", "{", "JSSEResourceDefinition . SERVICE _ AUTH _ TOKEN . parseAndSetParameter ( value ,    op ,    reader )  ;", "break ;", "}", "case   CIPHER _ SUITES    :", "{", "JSSEResourceDefinition . CIPHER _ SUITES . parseAndSetParameter ( value ,    op ,    reader )  ;", "break ;", "}", "case   PROTOCOLS    :", "{", "JSSEResourceDefinition . PROTOCOLS . parseAndSetParameter ( value ,    op ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( visited . containsAll ( required )  )  )     {", "throw   Logger . ROOT _ LOGGER . xmlStreamExceptionMissingAttribute ( Attribute . KEYSTORE _ PASSWORD . getLocalName (  )  ,    Attribute . TRUSTSTORE _ PASSWORD . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "parseProperties ( Element . PROPERTY . getLocalName (  )  ,    reader ,    op ,    JSSEResourceDefinition . ADDITIONAL _ PROPERTIES )  ;", "}", "METHOD_END"], "methodName": ["parseJSSE"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . NAME )  ;", "String   name    =    null ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "if    ( value    =  =    null )     {", "throw   invalidAttributeValue ( reader ,    i )  ;", "}", "name    =    value ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( required . size (  )  )     >     0  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "PathAddreddress    =    parentAddreppend ( Constants . LOGIN _ MODULE _ STACK ,    name )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "parseLoginModules ( reader ,    address ,    list )  ;", "}", "METHOD_END"], "methodName": ["parseLoginModuleStack"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   LOGIN _ MODULE    :", "{", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . CODE ,    Attribute . FLAG )  ;", "EnumSet < Attribute >    notAllowed    =    EnumSet . of ( Attribute . TYPE ,    Attribute . LOGIN _ MODULE _ STACK _ REF )  ;", "pCommonModule ( reader ,    parentAddress ,    Constants . LOGIN _ MODULE ,    required ,    notAllowed ,    list )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseLoginModules"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "PathAddreddress    =    parentAddreppend ( Constants . MAPPING ,    Constants . CLASSIC )  ;", "ModelNode   op    =    Util . createAddOperation ( address )  ;", "list . add ( op )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   MAPPING _ MODULE    :", "{", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . CODE )  ;", "EnumSet < Attribute >    notAllowed    =    EnumSet . of ( Attribute . FLAG ,    Attribute . LOGIN _ MODULE _ STACK _ REF )  ;", "parseCommonModule ( reader ,    address ,    Constants . MAPPING _ MODULE ,    required ,    notAllowed ,    list )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseMapping"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    ( childElementName . equals ( element . getLocalName (  )  )  )     {", "final   String [  ]    array    =    requireAttributes ( reader ,    NAME . getLocalName (  )  ,    VALUE . getLocalName (  )  )  ;", "attribute . pAndAddParameterElement ( array [  0  ]  ,    array [  1  ]  ,    node ,    reader )  ;", "} else    {", "throw   unexpectedElement ( reader )  ;", "}", "requireNoContent ( reader )  ;", "}", "}", "METHOD_END"], "methodName": ["parseProperties"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   op    =    Util . createAddOperation (  )  ;", "list . add ( op )  ;", "PathElement   secDomainPath    =    null ;", "EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . NAME )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "if    (  ( value    =  =    null )     |  |     (  ( value . length (  )  )     =  =     0  )  )     {", "throw   invalidAttributeValue ( reader ,    i )  ;", "}", "secDomainPath    =    PathElement . pathElement ( Constants . SECURITY _ DOMAIN ,    value )  ;", "break ;", "}", "case   CACHE _ TYPE    :", "{", "DomainResourceDefinition . CACHE _ TYPE . parseAndSetParameter ( value ,    op ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( required . size (  )  )     >     0  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "final   PathAddress   address    =    parentAddress . append ( secDomainPath )  ;", "op . get ( OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "final   EnumSet < Element >    visited    =    EnumSet . noneOf ( Element . class )  ;", "moduleNames    =    new   HashMap < String ,    Integer >  (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( visited . add ( element )  )  )     {", "throw   unexpectedElement ( reader )  ;", "}", "switch    ( element )     {", "case   AUTHENTICATION    :", "{", "if    ( visited . contains ( Element . AUTHENTICATION _ JASPI )  )     {", "throw   Logger . ROOT _ LOGGER . xmlStreamExceptionAuth ( reader . getLocation (  )  )  ;", "}", "parseAuthentication ( list ,    address ,    reader )  ;", "break ;", "}", "case   AUTHORIZATION    :", "{", "parseAuthorization ( list ,    address ,    reader )  ;", "break ;", "}", "case   ACL    :", "{", "parseACL ( list ,    address ,    reader )  ;", "break ;", "}", "case   AUDIT    :", "{", "parseAudit ( list ,    address ,    reader )  ;", "break ;", "}", "case   IDENTITY _ TRUST    :", "{", "parseIdentityTrust ( list ,    address ,    reader )  ;", "break ;", "}", "case   MAPPING    :", "{", "parseMapping ( list ,    address ,    reader )  ;", "break ;", "}", "case   AUTHENTICATION _ JASPI    :", "{", "if    ( visited . contains ( Element . AUTHENTICATION )  )     {", "throw   Logger . ROOT _ LOGGER . xmlStreamExceptionAuth ( reader . getLocation (  )  )  ;", "}", "parseAuthenticationJaspi ( list ,    address ,    reader )  ;", "break ;", "}", "case   JSSE    :", "{", "parseJSSE ( list ,    address ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "moduleNames . clear (  )  ;", "}", "METHOD_END"], "methodName": ["parseSecurityDomain"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "List < ModelNode >    list    =    new   ArrayList < ModelNode >  (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   SECURITY _ DOMAIN    :", "{", "parseDomain ( list ,    reader ,    parentAddress )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["parseSecurityDomains"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   DEEP _ COPY _ SUBJECT _ MODE    :", "{", "RootResourceDefinition . DEEP _ COPY _ SUBJECT _ MODE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   INITIALIZE _ JACC    :", "{", "RootResourceDefinition . INITIALIZE _ JACC . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseSecurityManagement"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "switch    ( element )     {", "case   SECURITY _ MANAGEMENT    :", "{", "parseSecurityManagement ( reader ,    subsystemNode )  ;", "break ;", "}", "case   SECURITY _ DOMAINS    :", "{", "final   List < ModelNode >    securityDomainsUpdates    =    parseSecurityDomains ( reader ,    sth )  ;", "if    ( securityDomainsUpdates    !  =    null )     {", "operations . addAll ( securityDomainsUpdates )  ;", "}", "break ;", "}", "case   SECURITY _ PROPERTIES    :", "reader . discardRemainder (  )  ;", "break ;", "case   VAULT    :", "{", "final   Namespace   schemaVer    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "if    ( schemaVer    =  =     ( Namespace . SECURITY _  1  _  0  )  )     {", "throw   unexpectedElement ( reader )  ;", "}", "final   int   count    =    reader . getAttributeCount (  )  ;", "ModelNode   vault    =    createAddOperation ( sth ,    Constants . VAULT ,    Constants . CLASSIC )  ;", "if    ( count    >     1  )     {", "throw   unexpectedAttribute ( reader ,    count )  ;", "}", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   CODE    :", "{", "vault . get ( CODE )  . set ( value )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "parseProperties ( Element . VAULT _ OPTION . getLocalName (  )  ,    reader ,    vault ,    VaultResourceDefinition . OPTIONS )  ;", "operations . add ( vault )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.jboss.as.security.SecuritySubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   elytronRealmAddOperation    =    Util . createAddOperation (  )  ;", "PathElement   elytronRealmPath    =    null ;", "final   EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . NAME ,    Attribute . LEGACY _ JAAS _ CONFIG )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "if    (  ( value    =  =    null )     |  |     (  ( value . length (  )  )     =  =     0  )  )     {", "throw   invalidAttributeValue ( reader ,    i )  ;", "}", "elytronRealmPath    =    PathElement . pathElement ( Constants . ELYTRON _ REALM ,    value )  ;", "break ;", "}", "case   LEGACY _ JAAS _ CONFIG    :", "{", "ElytronIntegrationResourceDefinitions . LEGACY _ JAAS _ CONFIG . parseAndSetParameter ( value ,    elytronRealmAddOperation ,    reader )  ;", "break ;", "}", "case   APPLY _ ROLE _ MAPPERS    :", "{", "ElytronIntegrationResourceDefinitions . APPLY _ ROLE _ MAPPERS . parseAndSetParameter ( value ,    elytronRealmAddOperation ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( required . size (  )  )     >     0  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "elytronRealmAddOperation . get ( OP _ ADDR )  . set ( sth . append ( elytronRealmPath )  . toModelNode (  )  )  ;", "operations . add ( elytronRealmAddOperation )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseElytronRealm"], "fileName": "org.jboss.as.security.SecuritySubsystemParser_2_0"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ELYTRON _ REALM    :", "{", "parseElytronRealm ( reader ,    operations ,    sth )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseSecurityRealms"], "fileName": "org.jboss.as.security.SecuritySubsystemParser_2_0"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ELYTRON _ KEY _ STORE    :", "{", "parseTLSEntity ( reader ,    operations ,    sth ,    Constants . ELYTRON _ KEY _ STORE )  ;", "break ;", "}", "case   ELYTRON _ TRUST _ STORE    :", "{", "parseTLSEntity ( reader ,    operations ,    sth ,    Constants . ELYTRON _ TRUST _ STORE )  ;", "break ;", "}", "case   ELYTRON _ KEY _ MANAGER    :", "{", "parseTLSEntity ( reader ,    operations ,    sth ,    Constants . ELYTRON _ KEY _ MANAGER )  ;", "break ;", "}", "case   ELYTRON _ TRUST _ MANAGER    :", "{", "parseTLSEntity ( reader ,    operations ,    sth ,    Constants . ELYTRON _ TRUST _ MANAGER )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTLS"], "fileName": "org.jboss.as.security.SecuritySubsystemParser_2_0"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   elytronTLSEntityAddOperation    =    Util . createAddOperation (  )  ;", "PathElement   elytronTLSEntityPath    =    null ;", "final   EnumSet < Attribute >    required    =    EnumSet . of ( Attribute . NAME ,    Attribute . LEGACY _ JSSE _ CONFIG )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "if    (  ( value    =  =    null )     |  |     (  ( value . length (  )  )     =  =     0  )  )     {", "throw   invalidAttributeValue ( reader ,    i )  ;", "}", "elytronTLSEntityPath    =    PathElement . pathElement ( tlsEntityName ,    value )  ;", "break ;", "}", "case   LEGACY _ JSSE _ CONFIG    :", "{", "ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG . parseAndSetParameter ( value ,    elytronTLSEntityAddOperation ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( required . size (  )  )     >     0  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "elytronTLSEntityAddOperation . get ( OP _ ADDR )  . set ( sth . append ( elytronTLSEntityPath )  . toModelNode (  )  )  ;", "operations . add ( elytronTLSEntityAddOperation )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseTLSEntity"], "fileName": "org.jboss.as.security.SecuritySubsystemParser_2_0"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . ACL . getLocalName (  )  )  ;", "writeLoginModule ( writer ,    modelNode ,    Constants . ACL _ MODULE ,    Element . ACL _ MODULE . getLocalName (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeACL"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . AUDIT . getLocalName (  )  )  ;", "writeLoginModule ( writer ,    modelNode ,    Constants . PROVIDER _ MODULE ,    Element . PROVIDER _ MODULE . getLocalName (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAudit"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . AUTHENTICATION . getLocalName (  )  )  ;", "writeLoginModule ( writer ,    modelNode ,    Constants . LOGIN _ MODULE )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAuthentication"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . AUTHENTICATION _ JASPI . getLocalName (  )  )  ;", "ModelNode   moduleStack    =    modelNode . get ( Constants . LOGIN _ MODULE _ STACK )  ;", "writeLoginModuleStack ( writer ,    moduleStack )  ;", "writeLoginModule ( writer ,    modelNode ,    Constants . AUTH _ MODULE ,    Element . AUTH _ MODULE . getLocalName (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAuthenticationJaspi"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . AUTHORIZATION . getLocalName (  )  )  ;", "writeLoginModule ( writer ,    modelNode ,    Constants . POLICY _ MODULE ,    Element . POLICY _ MODULE . getLocalName (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAuthorization"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "boolean   integrationStarted    =    false ;", "integrationStarted    =    integrationStarted    |     ( writeRealms ( writer ,    modelNode ,    integrationStarted )  )  ;", "integrationStarted    =    integrationStarted    |     ( writeTLS ( writer ,    modelNode ,    integrationStarted )  )  ;", "if    ( integrationStarted )     {", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeElytronIntegration"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . IDENTITY _ TRUST . getLocalName (  )  )  ;", "writeLoginModule ( writer ,    modelNode ,    Constants . TRUST _ MODULE ,    Element . TRUST _ MODULE . getLocalName (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeIdentityTrust"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . JSSE . getLocalName (  )  )  ;", "JSSEResourceDefinition . KEYSTORE . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . TRUSTSTORE . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . KEYMANAGER . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . TRUSTMANAGER . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . CIPHER _ SUITES . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . SERVER _ ALIAS . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . SERVICE _ AUTH _ TOKEN . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . CLIENT _ ALIAS . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . CLIENT _ AUTH . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . PROTOCOLS . marshallAsAttribute ( modelNode ,    false ,    writer )  ;", "JSSEResourceDefinition . ADDITIONAL _ PROPERTIES . marshallAsElement ( modelNode ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeJSSE"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "writeLoginModule ( writer ,    modelNode ,    key ,    Element . LOGIN _ MODULE . getLocalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeLoginModule"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( modelNode . hasDefined ( key )  )  )     {", "return ;", "}", "final   ModelNode   modules    =    modelNode . get ( key )  ;", "for    ( Property   moduleProp    :    modulePropertyList (  )  )     {", "ModelNode   module    =    moduleProp . getValue (  )  ;", "writer . writeStartElement ( elementName )  ;", "if    (  !  ( moduleProp . getName (  )  . equals ( module . get ( Constants . CODE )  . asString (  )  )  )  )     {", "writer . writeAttribute ( Constants . NAME ,    moduleProp . getName (  )  )  ;", "}", "LoginModuleResourceDefinition . CODE . marshallAsAttribute ( module ,    writer )  ;", "LoginModuleResourceDefinition . FLAG . marshallAsAttribute ( module ,    writer )  ;", "MappingModuleDefinition . TYPE . marshallAsAttribute ( module ,    writer )  ;", "JASPIMappingModuleDefinition . LOGIN _ MODULE _ STACK _ REF . marshallAsAttribute ( module ,    writer )  ;", "LoginModuleResourceDefinition . MODULE . marshallAsAttribute ( module ,    false ,    writer )  ;", "if    ( module . hasDefined ( Constants . MODULE _ OPTIONS )  )     {", "for    ( ModelNode   option    :    module . get ( Constants . MODULE _ OPTIONS )  . asList (  )  )     {", "writer . writeEmptyElement ( Element . MODULE _ OPTION . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    option . asProperty (  )  . getName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    option . asProperty (  )  . getValue (  )  . asString (  )  )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeLoginModule"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "List < Property >    stacks    =    modelNode . asPropertyList (  )  ;", "for    ( Property   stack    :    stacks )     {", "writer . writeStartElement ( Element . LOGIN _ MODULE _ STACK . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    stack . getName (  )  )  ;", "writeLoginModule ( writer ,    stack . getValue (  )  ,    Constants . LOGIN _ MODULE )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeLoginModuleStack"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( modelNode . isDefined (  )  )     &  &     (  ( modelNode . asInt (  )  )     >     0  )  )     {", "writer . writeStartElement ( Element . MAPPING . getLocalName (  )  )  ;", "writeLoginModule ( writer ,    modelNode ,    Constants . MAPPING _ MODULE ,    Constants . MAPPING _ MODULE )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeMapping"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "Set < String >    keys    =    policyDetails . keys (  )  ;", "keys . remove ( Constants . NAME )  ;", "keys . remove ( Constants . CACHE _ TYPE )  ;", "for    ( String   key    :    keys )     {", "Element   element    =    Element . forName ( key )  ;", "switch    ( element )     {", "e   AUTHENTICATION    :", "{", "ModelNode   kind    =    policyDetails . get ( Constants . AUTHENTICATION )  ;", "for    ( Property   prop    :    kindPropertyList (  )  )     {", "if    ( Constants . CLASSIC . equals ( prop . getName (  )  )  )     {", "writeAuthentication ( writer ,    prop . getValue (  )  )  ;", "} else", "if    ( Constants . JASPI . equals ( prop . getName (  )  )  )     {", "writeAuthenticationpi ( writer ,    prop . getValue (  )  )  ;", "}", "}", "break ;", "}", "e   AUTHORIZATION    :", "{", "writeAuthorization ( writer ,    policyDetails . get ( Constants . AUTHORIZATION ,    Constants . CLASSIC )  )  ;", "break ;", "}", "e   ACL    :", "{", "writeACL ( writer ,    policyDetails . get ( Constants . ACL ,    Constants . CLASSIC )  )  ;", "break ;", "}", "e   AUDIT    :", "{", "writeAudit ( writer ,    policyDetails . get ( Constants . AUDIT ,    Constants . CLASSIC )  )  ;", "break ;", "}", "e   IDENTITY _ TRUST    :", "{", "writeIdentityTrust ( writer ,    policyDetails . get ( Constants . IDENTITY _ TRUST ,    Constants . CLASSIC )  )  ;", "break ;", "}", "e   MAPPING    :", "{", "writeMapping ( writer ,    policyDetails . get ( Constants . MAPPING ,    Constants . CLASSIC )  )  ;", "break ;", "}", "e   JSSE    :", "{", "writeJSSE ( writer ,    policyDetails . get ( Constants . JSSE ,    Constants . CLASSIC )  )  ;", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writeSecurityDomainContent"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( modelNode . hasDefined ( Constants . ELYTRON _ REALM )  )     {", "if    ( integrationStarted    =  =    false )     {", "wer . weStartElement ( Constants . ELYTRON _ INTEGRATION )  ;", "}", "wer . weStartElement ( Constants . SECURITY _ REALMS )  ;", "ModelNode   elytronRealms    =    modelNode . require ( Constants . ELYTRON _ REALM )  ;", "for    ( String   realmName    :    elytronRealms . keys (  )  )     {", "wer . weStartElement ( Constants . ELYTRON _ REALM )  ;", "wer . weAttribute ( Constants . NAME ,    realmName )  ;", "ElytronIntegrationResourceDefinitions . LEGACY _ JAAS _ CONFIG . marshallAsAttribute ( elytronRealms . require ( realmName )  ,    wer )  ;", "ElytronIntegrationResourceDefinitions . APPLY _ ROLE _ MAPPERS . marshallAsAttribute ( elytronRealms . require ( realmName )  ,    false ,    wer )  ;", "wer . weEndElement (  )  ;", "}", "wer . weEndElement (  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["writeSecurityRealms"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( modelNode . hasDefined ( Constants . ELYTRON _ KEY _ STORE )  )     |  |     ( modelNode . hasDefined ( Constants . ELYTRON _ TRUST _ STORE )  )  )     |  |     ( modelNode . hasDefined ( Constants . ELYTRON _ KEY _ MANAGER )  )  )     |  |     ( modelNode . hasDefined ( Constants . ELYTRON _ TRUST _ MANAGER )  )  )     {", "if    ( integrationStarted    =  =    false )     {", "wer . weStartElement ( Constants . ELYTRON _ INTEGRATION )  ;", "}", "wer . weStartElement ( Constants . TLS )  ;", "weTLSEntity ( wer ,    modelNode ,    Constants . ELYTRON _ KEY _ STORE )  ;", "weTLSEntity ( wer ,    modelNode ,    Constants . ELYTRON _ TRUST _ STORE )  ;", "weTLSEntity ( wer ,    modelNode ,    Constants . ELYTRON _ KEY _ MANAGER )  ;", "weTLSEntity ( wer ,    modelNode ,    Constants . ELYTRON _ TRUST _ MANAGER )  ;", "wer . weEndElement (  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["writeTLS"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "if    ( modelNode . hasDefined ( tlsEntityName )  )     {", "ModelNode   tlsEntities    =    modelNode . require ( tlsEntityName )  ;", "for    ( String   entityName    :    tlsEntities . keys (  )  )     {", "writer . writeStartElement ( tlsEntityName )  ;", "writer . writeAttribute ( Constants . NAME ,    entityName )  ;", "ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG . marshallAsAttribute ( tlsEntities . require ( entityName )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeTLSEntity"], "fileName": "org.jboss.as.security.SecuritySubsystemPersister"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    Factory . createSubsystemInstance (  )  ;", "builder . rejectChildResource ( PathElement . pathElement ( Constants . ELYTRON _ REALM )  )  ;", "builder . rejectChildResource ( PathElement . pathElement ( Constants . ELYTRON _ KEY _ STORE )  )  ;", "builder . rejectChildResource ( PathElement . pathElement ( Constants . ELYTRON _ TRUST _ STORE )  )  ;", "builder . rejectChildResource ( PathElement . pathElement ( Constants . ELYTRON _ KEY _ MANAGER )  )  ;", "builder . rejectChildResource ( PathElement . pathElement ( Constants . ELYTRON _ TRUST _ MANAGER )  )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( SecuritySubsystemRootResourceDefinition . INITIALIZE _ JACC . getDefaultValue (  )  )  ,    SecuritySubsystemRootResourceDefinition . INITIALIZE _ JACC )  . addRejectCheck ( DEFINED ,    SecuritySubsystemRootResourceDefinition . INITIALIZE _ JACC )  ;", "builder . addChildResource ( SecurityExtension . SECURITY _ DOMAIN _ PATH )  . addChildResource ( SecurityExtension . PATH _ AUDIT _ CLASSIC )  . addChildResource ( MappingProviderModuleDefinition . PATH _ PROVIDER _ MODULE )  . getAttributeBuilder (  )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( new   ModelNode ( ModuleName . PICKETBOX . getName (  )  )  )  ,    Constants . MODULE )  . addRejectCheck ( DEFINED ,    Constants . MODULE )  . end (  )  ;", "Tools . register ( builder . build (  )  ,    subsystemRegistration ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_1_3_0"], "fileName": "org.jboss.as.security.SecurityTransformers"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    targetVersion )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . addMavenResourceURL ( mavenGAV )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( targetVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( PathElement . pathElement ( SUBSYSTEM ,    getMainSubsystemName (  )  )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    targetVersion ,    builder . parseXmlResource (  \" security - t - reject _  2  .  0  . xml \"  )  ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( subsystemAddress ,    PathElement . pathElement ( Constants . ELYTRON _ REALM )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( subsystemAddress ,    PathElement . pathElement ( Constants . ELYTRON _ KEY _ STORE )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( subsystemAddress ,    PathElement . pathElement ( Constants . ELYTRON _ TRUST _ STORE )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( subsystemAddress ,    PathElement . pathElement ( Constants . ELYTRON _ KEY _ MANAGER )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( subsystemAddress ,    PathElement . pathElement ( Constants . ELYTRON _ TRUST _ MANAGER )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( subsystemAddress ,    PathElement . pathElement ( Constants . SECURITY _ DOMAIN ,     \" domain - with - custom - audit - provider \"  )  ,    SecurityExtension . PATH _ AUDIT _ CLASSIC ,    PathElement . pathElement ( Constants . PROVIDER _ MODULE ,     \" MyCustomLogAuditProvider \"  )  )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . MODULE )  )  . addFailedAttribute ( PathAddress . pathAddress ( subsystemAddress )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . INITIALIZE _ JACC )  )  )  ;", "legacyServices . shutdown (  )  ;", "mainServices . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["testReject"], "fileName": "org.jboss.as.security.SecurityTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   version    =    ModelVersion . create (  1  ,     3  ,     0  )  ;", "final   String   mavenGavVersion    =    controllerVersion . getMavenGavVersion (  )  ;", "final   String   artifactId ;", "if    (  ( controllerVersion . isEap (  )  )     &  &     ( mavenGavVersion . equals ( controllerVersion . getCoreVersion (  )  )  )  )     {", "artifactId    =     \" jboss - as - security \"  ;", "} else    {", "artifactId    =     \" wildfly - security \"  ;", "}", "String   mavenGav    =    String . format (  \"  % s :  % s :  % s \"  ,    controllerVersion . getMavenGroupId (  )  ,    artifactId ,    controllerVersion . getMavenGavVersion (  )  )  ;", "test ( controllerVersion ,    version ,    mavenGav )  ;", "testReject ( controllerVersion ,    version ,    mavenGav )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.jboss.as.security.SecurityTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" security - transformers _  2  .  0  . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    targetVersion )  . addMavenResourceURL ( mavenGAV )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( targetVersion )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    targetVersion ,    null )  ;", "mainServices . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.jboss.as.security.SecurityTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP64"], "fileName": "org.jboss.as.security.SecurityTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP70"], "fileName": "org.jboss.as.security.SecurityTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "return   transactionManagerInjectedValue ;", "}", "METHOD_END"], "methodName": ["getTransactionManagerInjectedValue"], "fileName": "org.jboss.as.security.TransactionManagerLocatorService"}, {"methodBody": ["METHOD_START", "{", "resourceRegistration . registerReadWriteAttribute ( VaultResourceDefinition . OPTIONS ,    null ,    new   ReloadRequiredWriteAttributeHandler ( VaultResourceDefinition . OPTIONS )  )  ;", "resourceRegistration . registerReadWriteAttribute ( VaultResourceDefinition . CODE ,    null ,    new   ReloadRequiredWriteAttributeHandler ( VaultResourceDefinition . CODE )  )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.security.VaultResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "RemoteConnection   con    =    RemotingContext . getRemoteConnection (  )  ;", "if    ( con    !  =    null )     {", "Collection < Principal >    principals    =    new   HashSet <  >  (  )  ;", "SecurityIdentity   localIdentity    =    con . getSecurityIdentity (  )  ;", "if    ( localIdentity    !  =    null )     {", "final   Principal   principal    =    localIdentity . getPrincipal (  )  ;", "final   String   realm    =     ( principal   instanceof   RealmPrincipal )     ?     (  ( RealmPrincipal )     ( principal )  )  . getRealm (  )     :    null ;", "principals . add ( new   RealmUser ( realm ,    principal . getName (  )  )  )  ;", "for    ( String   role    :    localIdentity . getRoles (  )  )     {", "principals . add ( new   RealmGroup ( role )  )  ;", "principals . add ( new   RealmRole ( role )  )  ;", "}", "return   principals ;", "} else    {", "return   Collections . emptySet (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getConnectionPrincipals"], "fileName": "org.jboss.as.security.api.ConnectionSecurityContext"}, {"methodBody": ["METHOD_START", "{", "RemotingContext . setConnection ( stateCache . getConnection (  )  )  ;", "Association . set ( stateCache . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["popIdentity"], "fileName": "org.jboss.as.security.api.ConnectionSecurityContext"}, {"methodBody": ["METHOD_START", "{", "SecurityContext   current    =    SecurityContextAssociation . getSecurityContext (  )  ;", "SecurityContext   nextContext    =    SecurityContextFactory . createSecurityContext ( principal ,    credential ,    new   Subject (  )  ,     \" USER _ DELEGATION \"  )  ;", "SecurityContextAssociation . setSecurityContext ( nextContext )  ;", "RemoteConnection   con    =    RemotingContext . getRemoteConnection (  )  ;", "RemotingContext . clear (  )  ;", "return   new   ContextStateCache ( con ,    current )  ;", "}", "METHOD_END"], "methodName": ["pushIdentity"], "fileName": "org.jboss.as.security.api.ConnectionSecurityContext"}, {"methodBody": ["METHOD_START", "{", "return   connection ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.jboss.as.security.api.ContextStateCache"}, {"methodBody": ["METHOD_START", "{", "return   securityContext ;", "}", "METHOD_END"], "methodName": ["getSecurityContext"], "fileName": "org.jboss.as.security.api.ContextStateCache"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "return    (  ( ModuleClassLoader )     (  . class . getClassLoader (  )  )  )  ;", "} else    {", "return    (  ( ModuleClassLoader )     ( AccessController . doPrivileged ( new   GetClassLoaderAction (  . class )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getModuleClassLoader"], "fileName": "org.jboss.as.security.context.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   loader ;", "try    {", "loader    =    SecurityActions . getModuleClassLoader (  )  ;", "}    catch    ( ModuleLoadException   e )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToGetModuleClassLoader ( e )  ;", "}", "Class <  ?  >  [  ]    interfaces    =    new   Class <  ?  >  [  ]  {    Context . class    }  ;", "return   new   naming . ValueManagedReference ( new   ImmediateValue < Object >  ( Proxy . newProxyInstance ( loader ,    interfaces ,    this )  )  )  ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.jboss.as.security.context.SecurityDomainJndiInjectable"}, {"methodBody": ["METHOD_START", "{", "return   securityManagementValue ;", "}", "METHOD_END"], "methodName": ["getSecurityManagementInjector"], "fileName": "org.jboss.as.security.context.SecurityDomainJndiInjectable"}, {"methodBody": ["METHOD_START", "{", "Context   ctx    =    new   InitialContext (  )  ;", "NameParser   parser    =    ctx . getNameParser (  \"  \"  )  ;", "String   securityDomain    =    null ;", "Name   name    =    null ;", "final   JNDIBasedSecurityManagement   securityManagement    =    JNDIBasedSecurityManagement . class . cast ( securityManagementValue . getValue (  )  )  ;", "final   ConcurrentHashMap < String ,    SecurityDomainContext >    securityManagerMap    =    securityManagement . getSecurityManagerMap (  )  ;", "String   methodName    =    method . getName (  )  ;", "if    ( methodName . equals (  \" toString \"  )  )", "return    ( JAAS _ CONTEXT _ ROOT )     +     \"    Context   proxy \"  ;", "if    ( methodName . equals (  \" list \"  )  )", "return   new    . DomainEnumeration ( securityManagerMap . keys (  )  ,    securityManagerMap )  ;", "if    (  ( methodName . equals (  \" bind \"  )  )     |  |     ( methodName . equals (  \" rebind \"  )  )  )     {", "if    (  ( args [  0  ]  )    instanceof   String )", "name    =    parser . parse (  (  ( String )     ( args [  0  ]  )  )  )  ;", "else", "name    =     (  ( Name )     ( args [  0  ]  )  )  ;", "securityDomain    =    name . get (  0  )  ;", "SecurityDomainContext   val    =     (  ( SecurityDomainContext )     ( args [  1  ]  )  )  ;", "securityManagerMap . put ( securityDomain ,    val )  ;", "return   proxy ;", "}", "if    (  !  ( methodName . equals (  \" lookup \"  )  )  )", "throw   operationNotSupported ( method )  ;", "if    (  ( args [  0  ]  )    instanceof   String )", "name    =    parser . parse (  (  ( String )     ( args [  0  ]  )  )  )  ;", "else", "name    =     (  ( Name )     ( args [  0  ]  )  )  ;", "securityDomain    =    name . get (  0  )  ;", "SecurityDomainContext   securityDomainCtx    =    lookupSecurityDomain ( securityManagement ,    securityManagerMap ,    securityDomain )  ;", "Object   binding    =    securityDomainCtx . getAuthenticationManager (  )  ;", "if    (  ( name . size (  )  )     =  =     2  )     {", "String   request    =    name . get (  1  )  ;", "binding    =     . lookup ( securityDomainCtx ,    request )  ;", "}", "return   binding ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.jboss.as.security.context.SecurityDomainJndiInjectable"}, {"methodBody": ["METHOD_START", "{", "Object   binding    =    null ;", "if    (  ( name    =  =    null )     |  |     (  ( name . length (  )  )     =  =     0  )  )", "throw   nullName (  )  ;", "if    ( name . equals (  . ACTIVE _ SUBJECT )  )", "binding    =    securityDomainContext . getSubject (  )  ;", "else", "if    ( name . equals (  . AUTHENTICATION _ MGR )  )", "binding    =    securityDomainContext . getAuthenticationManager (  )  ;", "else", "if    ( name . equals (  . AUTHORIZATION _ MGR )  )", "binding    =    securityDomainContext . getAuthorizationManager (  )  ;", "else", "if    ( name . equals (  . AUDIT _ MGR )  )", "binding    =    securityDomainContext . getAuditManager (  )  ;", "else", "if    ( name . equals (  . MAPPING _ MGR )  )", "binding    =    securityDomainContext . getMappingManager (  )  ;", "else", "if    ( name . equals (  . IDENTITY _ TRUST _ MGR )  )", "binding    =    securityDomainContext . getIdentityTrustManager (  )  ;", "else", "if    ( name . equals (  . DOMAIN _ CONTEXT )  )", "binding    =    securityDomainContext ;", "else", "if    ( name . equals (  . JSSE )  )", "binding    =    securityDomainContext . getJSSE (  )  ;", "return   binding ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.jboss.as.security.context.SecurityDomainJndiInjectable"}, {"methodBody": ["METHOD_START", "{", "SecurityDomainContext   sdc    =    securityManagerMap . get ( securityDomain )  ;", "if    ( sdc    =  =    null )     {", "sdc    =    securityManagement . createSecurityDomainContext ( securityDomain ,    new   DefaultAuthenticationCacheFactory (  )  )  ;", "securityManagerMap . put ( securityDomain ,    sdc )  ;", "}", "return   sdc ;", "}", "METHOD_END"], "methodName": ["lookupSecurityDomain"], "fileName": "org.jboss.as.security.context.SecurityDomainJndiInjectable"}, {"methodBody": ["METHOD_START", "{", "String   contextId    =    deploymentUnit . getName (  )  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "contextId    =     (  ( deploymentUnit . getParent (  )  . getName (  )  )     +     \"  !  \"  )     +    contextId ;", "}", "return   deploy ( deploymentUnit ,    contextId )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.security.deployment.AbstractSecurityDeployer"}, {"methodBody": ["METHOD_START", "{", "T   metaData    =    deploymentUnit . getAttachment ( getMetaDataType (  )  )  ;", "Boolean   standalone    =    Boolean . FALSE ;", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "standalone    =    Boolean . TRUE ;", "}", "return   createService ( jaccContextId ,    metaData ,    standalone )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.security.deployment.AbstractSecurityDeployer"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "final   ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,     . PICKETBOX _ ID ,    false ,    false ,    false ,    false )  )  ;", "final   ModuleDependency   remoting    =    new   ModuleDependency ( moduleLoader ,     . REMOTING _ LOGIN _ MODULE ,    false ,    false ,    false ,    false )  ;", "remoting . addImportFilter ( PathFilters . is ( RemotingLoginModule . class . getName (  )  . replace (  \"  .  \"  ,     \"  /  \"  )  )  ,    true )  ;", "moduleSpecification . addSystemDependency ( remoting )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,     . JACC _ API ,    false ,    false ,    true ,    false )  )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,     . AUTH _ MESSAGE _ API ,    false ,    false ,    true ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.security.deployment.SecurityDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "this . valueSupplier    =    BasicService . checkNotNullParam (  \" valueSupplier \"  ,    valueSupplier )  ;", "}", "METHOD_END"], "methodName": ["setValueSupplier"], "fileName": "org.jboss.as.security.elytron.BasicService"}, {"methodBody": ["METHOD_START", "{", "ModelNode   value    =    attributeDefinition . resolveModelAttribute ( context ,    model )  ;", "if    ( value . isDefined (  )  )     {", "return   value . asString (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["asStringIfDefined"], "fileName": "org.jboss.as.security.elytron.ElytronIntegrationResourceDefinitions"}, {"methodBody": ["METHOD_START", "{", "final   AttributeDefinition [  ]    attributes    =    new   AttributeDefinition [  ]  {    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG    }  ;", "final   AbstractAddStepHandler   addHandler    =    new   BasicAddHandler < KeyManager >  ( attributes ,    Capabilities . KEY _ MANAGER _ RUNTIME _ CAPABILITY )     {", "@ Override", "protected   BasicService . ValueSupplier < KeyManager >    getValueSupplier ( ServiceBuilder < KeyManager >    serviceBuilder ,    OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "final   String   legacyJSSEConfig    =    ElytronIntegrationResourceDefinitions . asStringIfDefined ( context ,    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG ,    model )  ;", "final   InjectedValue < SecurityDomainContext >    securityDomainContextInjector    =    new   InjectedValue (  )  ;", "if    ( legacyJSSEConfig    !  =    null )     {", "serviceBuilder . addDependency ( SecurityDomainService . SERVICE _ NAME . append ( legacyJSSEConfig )  ,    SecurityDomainContext . class ,    securityDomainContextInjector )  ;", "}", "return    (  )     -  >     {", "final   SecurityDomainContext   domainContext    =    securityDomainContextInjector . getValue (  )  ;", "final   JSSESecurityDomain   jsseDomain    =    domainContext . getJSSE (  )  ;", "if    ( jsseDomain    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig )  ;", "}", "final   KeyManager [  ]    keyManagers    =    jsseDomain . getKeyManagers (  )  ;", "if    ( keyManagers    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateComponentInJSSEDomain (  \" KeyManager \"  ,    legacyJSSEConfig )  ;", "}", "for    ( KeyManager   keyManager    :    keyManagers )     {", "if    ( keyManager   instanceof   X 5  0  9 ExtendedKeyManager )     {", "return   keyManager ;", "}", "}", "throw   SecurityLogger . ROOT _ LOGGER . expectedManagerTypeNotFound (  \" KeyManager \"  ,    X 5  0  9 ExtendedKeyManager . class . getSimpleName (  )  ,    legacyJSSEConfig )  ;", "}  ;", "}", "}  ;", "return   new   BasicResourceDefinition ( Constants . ELYTRON _ KEY _ MANAGER ,    addHandler ,    attributes ,    Capabilities . KEY _ MANAGER _ RUNTIME _ CAPABILITY )  ;", "}", "METHOD_END"], "methodName": ["getElytronKeyManagersResourceDefinition"], "fileName": "org.jboss.as.security.elytron.ElytronIntegrationResourceDefinitions"}, {"methodBody": ["METHOD_START", "{", "final   AttributeDefinition [  ]    attributes    =    new   AttributeDefinition [  ]  {    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG    }  ;", "final   AbstractAddStepHandler   addHandler    =    new   BasicAddHandler < KeyStore >  ( attributes ,    Capabilities . KEY _ STORE _ RUNTIME _ CAPABILITY )     {", "@ Override", "protected   BasicService . ValueSupplier < KeyStore >    getValueSupplier ( ServiceBuilder < KeyStore >    serviceBuilder ,    OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "final   String   legacyJSSEConfig    =    ElytronIntegrationResourceDefinitions . asStringIfDefined ( context ,    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG ,    model )  ;", "final   InjectedValue < SecurityDomainContext >    securityDomainContextInjector    =    new   InjectedValue (  )  ;", "if    ( legacyJSSEConfig    !  =    null )     {", "serviceBuilder . addDependency ( SecurityDomainService . SERVICE _ NAME . append ( legacyJSSEConfig )  ,    SecurityDomainContext . class ,    securityDomainContextInjector )  ;", "}", "return    (  )     -  >     {", "final   SecurityDomainContext   domainContext    =    securityDomainContextInjector . getValue (  )  ;", "final   JSSESecurityDomain   jsseDomain    =    domainContext . getJSSE (  )  ;", "if    ( jsseDomain    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig )  ;", "}", "final   KeyStore   keyStore    =    jsseDomain . getKeyStore (  )  ;", "if    ( keyStore    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateComponentInJSSEDomain (  \" KeyStore \"  ,    legacyJSSEConfig )  ;", "}", "return   keyStore ;", "}  ;", "}", "}  ;", "return   new   BasicResourceDefinition ( Constants . ELYTRON _ KEY _ STORE ,    addHandler ,    attributes ,    Capabilities . KEY _ STORE _ RUNTIME _ CAPABILITY )  ;", "}", "METHOD_END"], "methodName": ["getElytronKeyStoreResourceDefinition"], "fileName": "org.jboss.as.security.elytron.ElytronIntegrationResourceDefinitions"}, {"methodBody": ["METHOD_START", "{", "final   AttributeDefinition [  ]    attributes    =    new   AttributeDefinition [  ]  {    ElytronIntegrationResourceDefinitions . LEGACY _ JAAS _ CONFIG ,    ElytronIntegrationResourceDefinitions . APPLY _ ROLE _ MAPPERS    }  ;", "final   AbstractAddStepHandler   addHandler    =    new   BasicAddHandler < SecurityRealm >  ( attributes ,    Capabilities . SECURITY _ REALM _ RUNTIME _ CAPABILITY )     {", "@ Override", "protected   BasicService . ValueSupplier < SecurityRealm >    getValueSupplier ( ServiceBuilder < SecurityRealm >    serviceBuilder ,    OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "final   String   legacyJAASConfig    =    ElytronIntegrationResourceDefinitions . asStringIfDefined ( context ,    ElytronIntegrationResourceDefinitions . LEGACY _ JAAS _ CONFIG ,    model )  ;", "final   boolean   applyRoleMappers    =    ElytronIntegrationResourceDefinitions . APPLY _ ROLE _ MAPPERS . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   InjectedValue < SecurityDomainContext >    securityDomainContextInjector    =    new   InjectedValue (  )  ;", "if    ( legacyJAASConfig    !  =    null )     {", "serviceBuilder . addDependency ( SecurityDomainService . SERVICE _ NAME . append ( legacyJAASConfig )  ,    SecurityDomainContext . class ,    securityDomainContextInjector )  ;", "}", "return    (  )     -  >     {", "final   SecurityDomainContext   domainContext    =    securityDomainContextInjector . getValue (  )  ;", "return   new   SecurityDomainContextRealm ( domainContext ,    applyRoleMappers )  ;", "}  ;", "}", "}  ;", "return   new   BasicResourceDefinition ( Constants . ELYTRON _ REALM ,    addHandler ,    attributes ,    Capabilities . SECURITY _ REALM _ RUNTIME _ CAPABILITY )  ;", "}", "METHOD_END"], "methodName": ["getElytronRealmResourceDefinition"], "fileName": "org.jboss.as.security.elytron.ElytronIntegrationResourceDefinitions"}, {"methodBody": ["METHOD_START", "{", "final   AttributeDefinition [  ]    attributes    =    new   AttributeDefinition [  ]  {    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG    }  ;", "final   AbstractAddStepHandler   addHandler    =    new   BasicAddHandler < TrustManager >  ( attributes ,    Capabilities . TRUST _ MANAGER _ RUNTIME _ CAPABILITY )     {", "@ Override", "protected   BasicService . ValueSupplier < TrustManager >    getValueSupplier ( ServiceBuilder < TrustManager >    serviceBuilder ,    OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "final   String   legacyJSSEConfig    =    ElytronIntegrationResourceDefinitions . asStringIfDefined ( context ,    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG ,    model )  ;", "final   InjectedValue < SecurityDomainContext >    securityDomainContextInjector    =    new   InjectedValue (  )  ;", "if    ( legacyJSSEConfig    !  =    null )     {", "serviceBuilder . addDependency ( SecurityDomainService . SERVICE _ NAME . append ( legacyJSSEConfig )  ,    SecurityDomainContext . class ,    securityDomainContextInjector )  ;", "}", "return    (  )     -  >     {", "final   SecurityDomainContext   domainContext    =    securityDomainContextInjector . getValue (  )  ;", "final   JSSESecurityDomain   jsseDomain    =    domainContext . getJSSE (  )  ;", "if    ( jsseDomain    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig )  ;", "}", "final   TrustManager [  ]    trustManagers    =    jsseDomain . getTrustManagers (  )  ;", "if    ( trustManagers    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateComponentInJSSEDomain (  \" TrustManager \"  ,    legacyJSSEConfig )  ;", "}", "for    ( TrustManager   trustManager    :    trustManagers )     {", "if    ( trustManager   instanceof   X 5  0  9 ExtendedTrustManager )", "return   trustManager ;", "}", "throw   SecurityLogger . ROOT _ LOGGER . expectedManagerTypeNotFound (  \" TrustManager \"  ,    X 5  0  9 ExtendedTrustManager . class . getSimpleName (  )  ,    legacyJSSEConfig )  ;", "}  ;", "}", "}  ;", "return   new   BasicResourceDefinition ( Constants . ELYTRON _ TRUST _ MANAGER ,    addHandler ,    attributes ,    Capabilities . TRUST _ MANAGER _ RUNTIME _ CAPABILITY )  ;", "}", "METHOD_END"], "methodName": ["getElytronTrustManagersResourceDefinition"], "fileName": "org.jboss.as.security.elytron.ElytronIntegrationResourceDefinitions"}, {"methodBody": ["METHOD_START", "{", "final   AttributeDefinition [  ]    attributes    =    new   AttributeDefinition [  ]  {    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG    }  ;", "final   AbstractAddStepHandler   addHandler    =    new   BasicAddHandler < KeyStore >  ( attributes ,    Capabilities . KEY _ STORE _ RUNTIME _ CAPABILITY )     {", "@ Override", "protected   BasicService . ValueSupplier < KeyStore >    getValueSupplier ( ServiceBuilder < KeyStore >    serviceBuilder ,    OperationContext   context ,    ModelNode   model )    throws   OperationFailedException    {", "final   String   legacyJSSEConfig    =    ElytronIntegrationResourceDefinitions . asStringIfDefined ( context ,    ElytronIntegrationResourceDefinitions . LEGACY _ JSSE _ CONFIG ,    model )  ;", "final   InjectedValue < SecurityDomainContext >    securityDomainContextInjector    =    new   InjectedValue (  )  ;", "if    ( legacyJSSEConfig    !  =    null )     {", "serviceBuilder . addDependency ( SecurityDomainService . SERVICE _ NAME . append ( legacyJSSEConfig )  ,    SecurityDomainContext . class ,    securityDomainContextInjector )  ;", "}", "return    (  )     -  >     {", "final   SecurityDomainContext   domainContext    =    securityDomainContextInjector . getValue (  )  ;", "final   JSSESecurityDomain   jsseDomain    =    domainContext . getJSSE (  )  ;", "if    ( jsseDomain    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig )  ;", "}", "final   KeyStore   trustStore    =    jsseDomain . getTrustStore (  )  ;", "if    ( trustStore    =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToLocateComponentInJSSEDomain (  \" TrustStore \"  ,    legacyJSSEConfig )  ;", "}", "return   trustStore ;", "}  ;", "}", "}  ;", "return   new   BasicResourceDefinition ( Constants . ELYTRON _ TRUST _ STORE ,    addHandler ,    attributes ,    Capabilities . KEY _ STORE _ RUNTIME _ CAPABILITY )  ;", "}", "METHOD_END"], "methodName": ["getElytronTrustStoreResourceDefinition"], "fileName": "org.jboss.as.security.elytron.ElytronIntegrationResourceDefinitions"}, {"methodBody": ["METHOD_START", "{", "return   SupportLevel . UNSUPPORTED ;", "}", "METHOD_END"], "methodName": ["getCredentialAcquireSupport"], "fileName": "org.jboss.as.security.elytron.SecurityDomainContextRealm"}, {"methodBody": ["METHOD_START", "{", "return   SupportLevel . UNSUPPORTED ;", "}", "METHOD_END"], "methodName": ["getCredentialAcquireSupport"], "fileName": "org.jboss.as.security.elytron.SecurityDomainContextRealm"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . CONSTRUCTOR . newInstance (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.jboss.as.security.lru.ConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   offerLast ( e )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( c    =  =     ( this )  )", "throw   new   IllegalArgumentException (  )  ;", ". Node < E >    beginningOfTheEnd    =    null ;", ". Node < E >    last    =    null ;", "for    ( E   e    :    c )     {", ". checkNotNull ( e )  ;", ". Node < E >    newNode    =    new    . Node <  >  ( e )  ;", "if    ( beginningOfTheEnd    =  =    null )", "beginningOfTheEnd    =    last    =    newNode ;", "else    {", "last . lazySetNext ( newNode )  ;", "newNode . lazySetPrev ( last )  ;", "last    =    newNode ;", "}", "}", "if    ( beginningOfTheEnd    =  =    null )", "return   false ;", "restartFromTail    :    for    (  ;     ;  )", "for    (  . Node < E >    t    =    tail ,    p    =    t ,    q ;     ;  )     {", "if    (  (  ( q    =    p . next )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . next )     !  =    null )  )", "p    =     ( t    !  =     ( t    =    tail )  )     ?    t    :    q ;", "else", "if    (  ( p . prev )     =  =    p )", "continue   restartFromTail ;", "else    {", "beginningOfTheEnd . lazySetPrev ( p )  ;", "if    ( p . casNext ( null ,    beginningOfTheEnd )  )     {", "if    (  !  ( casTail ( t ,    last )  )  )     {", "t    =    tail ;", "if    (  ( last . next )     =  =    null )", "casTail ( t ,    last )  ;", "}", "return   true ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkFirst ( e )  ;", "}", "METHOD_END"], "methodName": ["addFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkLast ( e )  ;", "}", "METHOD_END"], "methodName": ["addLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   FastConcurrentDirectDeque . UNSAFE . compareAndSwapObject ( this ,    FastConcurrentDirectDeque . headOffset ,    cmp ,    val )  ;", "}", "METHOD_END"], "methodName": ["casHead"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   FastConcurrentDirectDeque . UNSAFE . compareAndSwapObject ( this ,    FastConcurrentDirectDeque . tailOffset ,    cmp ,    val )  ;", "}", "METHOD_END"], "methodName": ["casTail"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( v    =  =    null )", "throw   new   NullPoierException (  )  ;", "}", "METHOD_END"], "methodName": ["checkNotNull"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "while    (  ( pollFirst (  )  )     !  =    null )     {", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( o    =  =    null )", "return   false ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    (  ( item    !  =    null )     &  &     ( o . equals ( item )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   new   DescendingItr (  )  ;", "}", "METHOD_END"], "methodName": ["descendingIterator"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   getFirst (  )  ;", "}", "METHOD_END"], "methodName": ["element"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "restartFromHead    :    for    (  ;     ;  )", "for    (  . Node < E >    h    =    head ,    p    =    h ,    q ;     ;  )     {", "if    (  (  ( q    =    p . prev )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . prev )     !  =    null )  )", "p    =     ( h    !  =     ( h    =    head )  )     ?    h    :    q ;", "else", "if    (  ( p    =  =    h )     |  |     ( casHead ( h ,    p )  )  )", "return   p ;", "else", "continue   restartFromHead ;", "}", "}", "METHOD_END"], "methodName": ["first"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( peekFirst (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( peekLast (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "return   new   PrivilegedAction < Unsafe >  (  )     {", "public   Unsafe   run (  )     {", "return    . getUnsafe 0  (  )  ;", "}", "}  . run (  )  ;", "}", "return    . getUnsafe 0  (  )  ;", "}", "METHOD_END"], "methodName": ["getUnsafe"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "try    {", "Field   theUnsafe    =    Unsafe . clagetDeclaredField (  \" theUnsafe \"  )  ;", "theUnsafe . setAcceble ( true )  ;", "return    (  ( Unsafe )     ( theUnsafe . get ( null )  )  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   RuntimeException (  \" JDK   did   not   allow   acceng   unsafe \"  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["getUnsafe0"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( h    =  =    t )     {", "if    ( h    =  =    null )", "h    =    t    =    new    . Node <  >  ( null )  ;", "else    {", ". Node < E >    newNode    =    new    . Node <  >  ( null )  ;", "t . lazySetNext ( newNode )  ;", "newNode . lazySetPrev ( t )  ;", "t    =    newNode ;", "}", "}", "head    =    h ;", "tail    =    t ;", "}", "METHOD_END"], "methodName": ["initHeadTail"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return    ( peekFirst (  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   new   Itr (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "restartFromTail    :    for    (  ;     ;  )", "for    (  . Node < E >    t    =    tail ,    p    =    t ,    q ;     ;  )     {", "if    (  (  ( q    =    p . next )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . next )     !  =    null )  )", "p    =     ( t    !  =     ( t    =    tail )  )     ?    t    :    q ;", "else", "if    (  ( p    =  =    t )     |  |     ( casTail ( t ,    p )  )  )", "return   p ;", "else", "continue   restartFromTail ;", "}", "}", "METHOD_END"], "methodName": ["last"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . checkNotNull ( e )  ;", "final   FastConcurrentDirectDeque . Node < E >    newNode    =    new   FastConcurrentDirectDeque . Node <  >  ( e )  ;", "restartFromHead    :    for    (  ;     ;  )", "for    ( FastConcurrentDirectDeque . Node < E >    h    =    head ,    p    =    h ,    q ;     ;  )     {", "if    (  (  ( q    =    p . prev )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . prev )     !  =    null )  )", "p    =     ( h    !  =     ( h    =    head )  )     ?    h    :    q ;", "else", "if    (  ( p . next )     =  =    p )", "continue   restartFromHead ;", "else    {", "newNode . lazySetNext ( p )  ;", "if    ( p . casPrev ( null ,    newNode )  )     {", "if    ( p    !  =    h )", "casHead ( h ,    newNode )  ;", "return   newNode ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["linkFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . checkNotNull ( e )  ;", "final   FastConcurrentDirectDeque . Node < E >    newNode    =    new   FastConcurrentDirectDeque . Node <  >  ( e )  ;", "restartFromTail    :    for    (  ;     ;  )", "for    ( FastConcurrentDirectDeque . Node < E >    t    =    tail ,    p    =    t ,    q ;     ;  )     {", "if    (  (  ( q    =    p . next )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . next )     !  =    null )  )", "p    =     ( t    !  =     ( t    =    tail )  )     ?    t    :    q ;", "else", "if    (  ( p . prev )     =  =    p )", "continue   restartFromTail ;", "else    {", "newNode . lazySetPrev ( p )  ;", "if    ( p . casNext ( null ,    newNode )  )     {", "if    ( p    !  =    t )", "casTail ( t ,    newNode )  ;", "return   newNode ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["linkLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return    (  ( FastConcurrentDirectDeque . Node < E >  )     ( FastConcurrentDirectDeque . NEXT _ TERMINATOR )  )  ;", "}", "METHOD_END"], "methodName": ["nextTerminator"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   offerLast ( e )  ;", "}", "METHOD_END"], "methodName": ["offer"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkFirst ( e )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["offerFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   linkFirst ( e )  ;", "}", "METHOD_END"], "methodName": ["offerFirstAndReturnToken"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkLast ( e )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["offerLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   linkLast ( e )  ;", "}", "METHOD_END"], "methodName": ["offerLastAndReturnToken"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   peekFirst (  )  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "return   item ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["peekFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    last (  )  ;    p    !  =    null ;    p    =    pred ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "return   item ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["peekLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   pollFirst (  )  ;", "}", "METHOD_END"], "methodName": ["poll"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    (  ( item    !  =    null )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   item ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["pollFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    last (  )  ;    p    !  =    null ;    p    =    pred ( p )  )     {", "E   item    =    p . item ;", "if    (  ( item    !  =    null )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   item ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["pollLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   removeFirst (  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . Node < E >    q    =    p . prev ;", "return   p    =  =    q    ?    last (  )     :    q ;", "}", "METHOD_END"], "methodName": ["pred"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return    (  ( FastConcurrentDirectDeque . Node < E >  )     ( FastConcurrentDirectDeque . PREV _ TERMINATOR )  )  ;", "}", "METHOD_END"], "methodName": ["prevTerminator"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "addFirst ( e )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "s . defaultReadObject (  )  ;", ". Node < E >    h    =    null ;", ". Node < E >    t    =    null ;", "Object   item ;", "while    (  ( item    =    s . readObject (  )  )     !  =    null )     {", "@ SuppressWarnings (  \" unchecked \"  )", ". Node < E >    newNode    =    new    . Node <  >  (  (  ( E )     ( item )  )  )  ;", "if    ( h    =  =    null )", "h    =    t    =    newNode ;", "else    {", "t . lazySetNext ( newNode )  ;", "newNode . lazySetPrev ( t )  ;", "t    =    newNode ;", "}", "}", "initHeadTail ( h ,    t )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   removeFirst (  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   removeFirstOccurrence ( o )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( pollFirst (  )  )  ;", "}", "METHOD_END"], "methodName": ["removeFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . checkNotNull ( o )  ;", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    (  (  ( item    !  =    null )     &  &     ( o . equals ( item )  )  )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeFirstOccurrence"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( pollLast (  )  )  ;", "}", "METHOD_END"], "methodName": ["removeLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . checkNotNull ( o )  ;", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    last (  )  ;    p    !  =    null ;    p    =    pred ( p )  )     {", "E   item    =    p . item ;", "if    (  (  ( item    !  =    null )     &  &     ( o . equals ( item )  )  )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeLastOccurrence"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( token   instanceof   FastConcurrentDirectDeque . Node )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "FastConcurrentDirectDeque . Node   node    =     (  ( FastConcurrentDirectDeque . Node )     ( token )  )  ;", "for    (  ;     ;  )     {", "Object   item    =    node . item ;", "if    ( item    =  =    null )     {", "break ;", "}", "if    ( node . casItem ( item ,    null )  )     {", "unlink ( node )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeToken"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( v    =  =    null )", "throw   new   NoSuchElemException (  )  ;", "return   v ;", "}", "METHOD_END"], "methodName": ["screenNullResult"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )", "if    (  ( p . item )     !  =    null )", "if    (  (  +  + count )     =  =     ( Integer . MAX _ VALUE )  )", "break ;", "return   count ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "whileActive    :    do    {", ". Node < E >    prev    =    x . prev ;", ". Node < E >    p    =    prev ;", "findActive    :    for    (  ;     ;  )     {", "if    (  ( p . item )     !  =    null )", "break   findActive ;", ". Node < E >    q    =    p . prev ;", "if    ( q    =  =    null )     {", "if    (  ( p . next )     =  =    p )", "continue   whileActive ;", "break   findActive ;", "} else", "if    ( p    =  =    q )", "continue   whileActive ;", "else", "p    =    q ;", "}", "if    (  ( prev    =  =    p )     |  |     ( x . casPrev ( prev ,    p )  )  )", "return ;", "}    while    (  (  ( x . item )     !  =    null )     |  |     (  ( x . next )     =  =    null )     )  ;", "}", "METHOD_END"], "methodName": ["skipDeletedPredecessors"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "whileActive    :    do    {", ". Node < E >    next    =    x . next ;", ". Node < E >    p    =    next ;", "findActive    :    for    (  ;     ;  )     {", "if    (  ( p . item )     !  =    null )", "break   findActive ;", ". Node < E >    q    =    p . next ;", "if    ( q    =  =    null )     {", "if    (  ( p . prev )     =  =    p )", "continue   whileActive ;", "break   findActive ;", "} else", "if    ( p    =  =    q )", "continue   whileActive ;", "else", "p    =    q ;", "}", "if    (  ( next    =  =    p )     |  |     ( x . casNext ( next ,    p )  )  )", "return ;", "}    while    (  (  ( x . item )     !  =    null )     |  |     (  ( x . prev )     =  =    null )     )  ;", "}", "METHOD_END"], "methodName": ["skipDeletedSuccessors"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . Node < E >    q    =    p . next ;", "return   p    =  =    q    ?    first (  )     :    q ;", "}", "METHOD_END"], "methodName": ["succ"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   toArrayList (  )  . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   toArrayList (  )  . toArray ( a )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "ArrayList < E >    list    =    new   ArrayList <  >  (  )  ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "list . add ( item )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["toArrayList"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "final   FastConcurrentDirectDeque . Node < E >    prev    =    x . prev ;", "final   FastConcurrentDirectDeque . Node < E >    next    =    x . next ;", "if    ( prev    =  =    null )     {", "unlinkFirst ( x ,    next )  ;", "} else", "if    ( next    =  =    null )     {", "unlinkLast ( x ,    prev )  ;", "} else    {", "FastConcurrentDirectDeque . Node < E >    activePred ;", "FastConcurrentDirectDeque . Node < E >    activeSucc ;", "boolean   isFirst ;", "boolean   isLast ;", "int   hops    =     1  ;", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    prev ;     ;     +  + hops )     {", "if    (  ( p . item )     !  =    null )     {", "activePred    =    p ;", "isFirst    =    false ;", "break ;", "}", "FastConcurrentDirectDeque . Node < E >    q    =    p . prev ;", "if    ( q    =  =    null )     {", "if    (  ( p . next )     =  =    p )", "return ;", "activePred    =    p ;", "isFirst    =    true ;", "break ;", "} else", "if    ( p    =  =    q )", "return ;", "else", "p    =    q ;", "}", "for    ( FastConcurrentDirectDeque . Node < E >    p    =    next ;     ;     +  + hops )     {", "if    (  ( p . item )     !  =    null )     {", "activeSucc    =    p ;", "isLast    =    false ;", "break ;", "}", "FastConcurrentDirectDeque . Node < E >    q    =    p . next ;", "if    ( q    =  =    null )     {", "if    (  ( p . prev )     =  =    p )", "return ;", "activeSucc    =    p ;", "isLast    =    true ;", "break ;", "} else", "if    ( p    =  =    q )", "return ;", "else", "p    =    q ;", "}", "if    (  ( hops    <     ( FastConcurrentDirectDeque . HOPS )  )     &  &     ( isFirst    |    isLast )  )", "return ;", "skipDeletedSuccessors ( activePred )  ;", "skipDeletedPredecessors ( activeSucc )  ;", "if    (  (  (  (  ( isFirst    |    isLast )     &  &     (  ( activePred . next )     =  =    activeSucc )  )     &  &     (  ( activeSucc . prev )     =  =    activePred )  )     &  &     ( isFirst    ?     ( activePred . prev )     =  =    null    :     ( activePred . item )     !  =    null )  )     &  &     ( isLast    ?     ( activeSucc . next )     =  =    null    :     ( activeSucc . item )     !  =    null )  )     {", "updateHead (  )  ;", "updateTail (  )  ;", "x . lazySetPrev (  ( isFirst    ?    prevTerminator (  )     :    x )  )  ;", "x . lazySetNext (  ( isLast    ?    nextTerminator (  )     :    x )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["unlink"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( FastConcurrentDirectDeque . Node < E >    o    =    null ,    p    =    next ,    q ;     ;  )     {", "if    (  (  ( p . item )     !  =    null )     |  |     (  ( q    =    p . next )     =  =    null )  )     {", "if    (  (  ( o    !  =    null )     &  &     (  ( p . prev )     !  =    p )  )     &  &     ( first . casNext ( next ,    p )  )  )     {", "skipDeletedPredecessors ( p )  ;", "if    (  (  (  ( first . prev )     =  =    null )     &  &     (  (  ( p . next )     =  =    null )     |  |     (  ( p . item )     !  =    null )  )  )     &  &     (  ( p . prev )     =  =    first )  )     {", "updateHead (  )  ;", "updateTail (  )  ;", "o . lazySetNext ( o )  ;", "o . lazySetPrev ( prevTerminator (  )  )  ;", "}", "}", "return ;", "} else", "if    ( p    =  =    q )", "return ;", "else    {", "o    =    p ;", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["unlinkFirst"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( FastConcurrentDirectDeque . Node < E >    o    =    null ,    p    =    prev ,    q ;     ;  )     {", "if    (  (  ( p . item )     !  =    null )     |  |     (  ( q    =    p . prev )     =  =    null )  )     {", "if    (  (  ( o    !  =    null )     &  &     (  ( p . next )     !  =    p )  )     &  &     ( last . casPrev ( prev ,    p )  )  )     {", "skipDeletedSuccessors ( p )  ;", "if    (  (  (  ( last . next )     =  =    null )     &  &     (  (  ( p . prev )     =  =    null )     |  |     (  ( p . item )     !  =    null )  )  )     &  &     (  ( p . next )     =  =    last )  )     {", "updateHead (  )  ;", "updateTail (  )  ;", "o . lazySetPrev ( o )  ;", "o . lazySetNext ( nextTerminator (  )  )  ;", "}", "}", "return ;", "} else", "if    ( p    =  =    q )", "return ;", "else    {", "o    =    p ;", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["unlinkLast"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . Node < E >    h ;", "FastConcurrentDirectDeque . Node < E >    p ;", "FastConcurrentDirectDeque . Node < E >    q ;", "restartFromHead    :    while    (  (  (  ( h    =    head )  . item )     =  =    null )     &  &     (  ( p    =    h . prev )     !  =    null )  )     {", "for    (  ;     ;  )     {", "if    (  (  ( q    =    p . prev )     =  =    null )     |  |     (  ( q    =     ( p    =    q )  . prev )     =  =    null )  )     {", "if    ( casHead ( h ,    p )  )", "return ;", "else", "continue   restartFromHead ;", "} else", "if    ( h    !  =     ( head )  )", "continue   restartFromHead ;", "else", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateHead"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "FastConcurrentDirectDeque . Node < E >    t ;", "FastConcurrentDirectDeque . Node < E >    p ;", "FastConcurrentDirectDeque . Node < E >    q ;", "restartFromTail    :    while    (  (  (  ( t    =    tail )  . item )     =  =    null )     &  &     (  ( p    =    t . next )     !  =    null )  )     {", "for    (  ;     ;  )     {", "if    (  (  ( q    =    p . next )     =  =    null )     |  |     (  ( q    =     ( p    =    q )  . next )     =  =    null )  )     {", "if    ( casTail ( t ,    p )  )", "return ;", "else", "continue   restartFromTail ;", "} else", "if    ( t    !  =     ( tail )  )", "continue   restartFromTail ;", "else", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateTail"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "s . defaultWriteObject (  )  ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "s . writeObject ( item )  ;", "}", "s . writeObject ( null )  ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.jboss.as.security.lru.FastConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "Object   prevToken    =    cacheEntry . claimToken (  )  ;", "if    ( prevToken    =  =     ( Boolean . FALSE )  )", "return ;", "if    ( prevToken    !  =    null )     {", "accessQueue . removeToken ( prevToken )  ;", "}", "Object   token    =    null ;", "try    {", "token    =    accessQueue . offerLastAndReturnToken ( cacheEntry )  ;", "}    catch    ( Throwable   t )     {", "}", "if    (  (  !  ( cacheEntry . setToken ( token )  )  )     &  &     ( token    !  =    null )  )     {", "accessQueue . removeToken ( token )  ;", "}", "}", "METHOD_END"], "methodName": ["bumpAccess"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( removeCallback )     =  =    null )     {", "c . clear (  )  ;", "accessQueue . clear (  )  ;", "} else    {", "for    ( Iterator < Map . Entry < K ,    V >  >    iter    =    entrySet (  )  . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "iter . next (  )  ;", "iter . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "LRUCache . CacheEntry < K ,    V >    cacheEntry    =    get 0  ( key )  ;", "if    ( cacheEntry    =  =    null )", "return   null ;", "return   cacheEntry . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" SuspiciousMethodCalls \"  )", ". CacheEntry < K ,    V >    cacheEntry    =    cache . get ( key )  ;", "if    ( cacheEntry    =  =    null )     {", "return   null ;", "}", "if    (  (  ( cacheEntry . hit (  )  )     %     (  . SAMPLE _ INTERVAL )  )     =  =     0  )     {", "bumpAccess ( cacheEntry )  ;", "}", "return   cacheEntry ;", "}", "METHOD_END"], "methodName": ["get0"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "return   put ( key ,    newValue ,    false )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "LRUCache . CacheEntry < K ,    V >    entry    =    cache . get ( key )  ;", "V   old    =    null ;", "if    ( entry    =  =    null )     {", "entry    =    new   LRUCache . CacheEntry <  >  ( key ,    newValue )  ;", "LRUCache . CacheEntry < K ,    V >    result    =    cache . putIfAbsent ( key ,    entry )  ;", "if    ( result    !  =    null )     {", "return   this . put ( key ,    newValue )  ;", "}", "bumpAccess ( entry )  ;", "} else    {", "old    =    entry . getValue (  )  ;", "if    ( ifAbsent )     {", "return   old ;", "}", "entry . setValue ( newValue )  ;", "if    (  (  ( entry . hit (  )  )     %     ( LRUCache . SAMPLE _ INTERVAL )  )     =  =     0  )     {", "bumpAccess ( entry )  ;", "}", "}", "if    (  ( cache . size (  )  )     >     ( maxEntries )  )     {", "LRUCache . CacheEntry < K ,    V >    oldest    =    accessQueue . poll (  )  ;", "if    ( oldest    !  =    entry )     {", "this . remove ( oldest . key (  )  )  ;", "}", "}", "return   old ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "LRUCache . CacheEntry < K ,    V >    remove    =    cache . remove ( key )  ;", "if    ( remove    =  =    null )     {", "return   null ;", "}", "Object   old    =    remove . killToken (  )  ;", "if    ( old    !  =    null )     {", "accessQueue . removeToken ( old )  ;", "}", "if    (  ( removeCallback )     !  =    null )     {", "removeCallback . afterRemove ( remove . key (  )  ,    remove . getValue (  )  )  ;", "}", "return   remove . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "LRUCache . CacheEntry < K ,    V >    toRemove    =    cache . get ( key )  ;", "if    (  (  ( toRemove    =  =    null )     |  |     (  ( toRemove . getValue (  )  )     !  =    value )  )     |  |     (  !  ( cache . remove ( key ,    toRemove )  )  )  )     {", "return   false ;", "}", "Object   old    =    toRemove . killToken (  )  ;", "if    ( old    !  =    null )     {", "accessQueue . removeToken ( old )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "LRUCache . CacheEntry < K ,    V >    cacheEntry    =    get 0  ( key )  ;", "if    ( cacheEntry    =  =    null )", "return   null ;", "bumpAccess ( cacheEntry )  ;", "V   old    =    cacheEntry . getValue (  )  ;", "cacheEntry . setValue ( newValue )  ;", "if    (  ( removeCallback )     !  =    null )     {", "removeCallback . afterRemove ( key ,    old )  ;", "}", "return   old ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "LRUCache . CacheEntry < K ,    V >    cacheEntry    =    get 0  ( key )  ;", "if    (  ( cacheEntry    =  =    null )     |  |     (  ( cacheEntry . getValue (  )  )     !  =    oldValue )  )     {", "return   false ;", "}", "boolean   ret    =    cacheEntry . setValue ( oldValue ,    newValue )  ;", "if    ( ret )     {", "bumpAccess ( cacheEntry )  ;", "}", "if    (  ( removeCallback )     !  =    null )     {", "removeCallback . afterRemove ( key ,    oldValue )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "return   cache . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.jboss.as.security.lru.LRUCache"}, {"methodBody": ["METHOD_START", "{", "return   offerLast ( e )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( c    =  =     ( this )  )", "throw   new   IllegalArgumentException (  )  ;", ". Node < E >    beginningOfTheEnd    =    null ;", ". Node < E >    last    =    null ;", "for    ( E   e    :    c )     {", ". checkNotNull ( e )  ;", ". Node < E >    newNode    =    new    . Node <  >  ( e )  ;", "if    ( beginningOfTheEnd    =  =    null )", "beginningOfTheEnd    =    last    =    newNode ;", "else    {", "last . lazySetNext ( newNode )  ;", "newNode . lazySetPrev ( last )  ;", "last    =    newNode ;", "}", "}", "if    ( beginningOfTheEnd    =  =    null )", "return   false ;", "restartFromTail    :    for    (  ;     ;  )", "for    (  . Node < E >    t    =    tail ,    p    =    t ,    q ;     ;  )     {", "if    (  (  ( q    =    p . next )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . next )     !  =    null )  )", "p    =     ( t    !  =     ( t    =    tail )  )     ?    t    :    q ;", "else", "if    (  ( p . prev )     =  =    p )", "continue   restartFromTail ;", "else    {", "beginningOfTheEnd . lazySetPrev ( p )  ;", "if    ( p . casNext ( null ,    beginningOfTheEnd )  )     {", "if    (  !  ( casTail ( t ,    last )  )  )     {", "t    =    tail ;", "if    (  ( last . next )     =  =    null )", "casTail ( t ,    last )  ;", "}", "return   true ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkFirst ( e )  ;", "}", "METHOD_END"], "methodName": ["addFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkLast ( e )  ;", "}", "METHOD_END"], "methodName": ["addLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   PortableConcurrentDirectDeque . headUpdater . compareAndSet ( this ,    cmp ,    val )  ;", "}", "METHOD_END"], "methodName": ["casHead"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   PortableConcurrentDirectDeque . tailUpdater . compareAndSet ( this ,    cmp ,    val )  ;", "}", "METHOD_END"], "methodName": ["casTail"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( v    =  =    null )", "throw   new   NullinterException (  )  ;", "}", "METHOD_END"], "methodName": ["checkNotNull"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "while    (  ( pollFirst (  )  )     !  =    null )     {", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( o    =  =    null )", "return   false ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    (  ( item    !  =    null )     &  &     ( o . equals ( item )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   new   DescendingItr (  )  ;", "}", "METHOD_END"], "methodName": ["descendingIterator"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   getFirst (  )  ;", "}", "METHOD_END"], "methodName": ["element"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "restartFromHead    :    for    (  ;     ;  )", "for    (  . Node < E >    h    =    head ,    p    =    h ,    q ;     ;  )     {", "if    (  (  ( q    =    p . prev )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . prev )     !  =    null )  )", "p    =     ( h    !  =     ( h    =    head )  )     ?    h    :    q ;", "else", "if    (  ( p    =  =    h )     |  |     ( casHead ( h ,    p )  )  )", "return   p ;", "else", "continue   restartFromHead ;", "}", "}", "METHOD_END"], "methodName": ["first"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( peekFirst (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( peekLast (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( h    =  =    t )     {", "if    ( h    =  =    null )", "h    =    t    =    new    . Node <  >  ( null )  ;", "else    {", ". Node < E >    newNode    =    new    . Node <  >  ( null )  ;", "t . lazySetNext ( newNode )  ;", "newNode . lazySetPrev ( t )  ;", "t    =    newNode ;", "}", "}", "head    =    h ;", "tail    =    t ;", "}", "METHOD_END"], "methodName": ["initHeadTail"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return    ( peekFirst (  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   new   Itr (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "restartFromTail    :    for    (  ;     ;  )", "for    (  . Node < E >    t    =    tail ,    p    =    t ,    q ;     ;  )     {", "if    (  (  ( q    =    p . next )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . next )     !  =    null )  )", "p    =     ( t    !  =     ( t    =    tail )  )     ?    t    :    q ;", "else", "if    (  ( p    =  =    t )     |  |     ( casTail ( t ,    p )  )  )", "return   p ;", "else", "continue   restartFromTail ;", "}", "}", "METHOD_END"], "methodName": ["last"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . checkNotNull ( e )  ;", "final   PortableConcurrentDirectDeque . Node < E >    newNode    =    new   PortableConcurrentDirectDeque . Node <  >  ( e )  ;", "restartFromHead    :    for    (  ;     ;  )", "for    ( PortableConcurrentDirectDeque . Node < E >    h    =    head ,    p    =    h ,    q ;     ;  )     {", "if    (  (  ( q    =    p . prev )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . prev )     !  =    null )  )", "p    =     ( h    !  =     ( h    =    head )  )     ?    h    :    q ;", "else", "if    (  ( p . next )     =  =    p )", "continue   restartFromHead ;", "else    {", "newNode . lazySetNext ( p )  ;", "if    ( p . casPrev ( null ,    newNode )  )     {", "if    ( p    !  =    h )", "casHead ( h ,    newNode )  ;", "return   newNode ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["linkFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . checkNotNull ( e )  ;", "final   PortableConcurrentDirectDeque . Node < E >    newNode    =    new   PortableConcurrentDirectDeque . Node <  >  ( e )  ;", "restartFromTail    :    for    (  ;     ;  )", "for    ( PortableConcurrentDirectDeque . Node < E >    t    =    tail ,    p    =    t ,    q ;     ;  )     {", "if    (  (  ( q    =    p . next )     !  =    null )     &  &     (  ( q    =     ( p    =    q )  . next )     !  =    null )  )", "p    =     ( t    !  =     ( t    =    tail )  )     ?    t    :    q ;", "else", "if    (  ( p . prev )     =  =    p )", "continue   restartFromTail ;", "else    {", "newNode . lazySetPrev ( p )  ;", "if    ( p . casNext ( null ,    newNode )  )     {", "if    ( p    !  =    t )", "casTail ( t ,    newNode )  ;", "return   newNode ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["linkLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return    (  ( PortableConcurrentDirectDeque . Node < E >  )     ( PortableConcurrentDirectDeque . NEXT _ TERMINATOR )  )  ;", "}", "METHOD_END"], "methodName": ["nextTerminator"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   offerLast ( e )  ;", "}", "METHOD_END"], "methodName": ["offer"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkFirst ( e )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["offerFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   linkFirst ( e )  ;", "}", "METHOD_END"], "methodName": ["offerFirstAndReturnToken"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "linkLast ( e )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["offerLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   linkLast ( e )  ;", "}", "METHOD_END"], "methodName": ["offerLastAndReturnToken"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   peekFirst (  )  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "return   item ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["peekFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    last (  )  ;    p    !  =    null ;    p    =    pred ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "return   item ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["peekLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   pollFirst (  )  ;", "}", "METHOD_END"], "methodName": ["poll"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    (  ( item    !  =    null )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   item ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["pollFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    last (  )  ;    p    !  =    null ;    p    =    pred ( p )  )     {", "E   item    =    p . item ;", "if    (  ( item    !  =    null )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   item ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["pollLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   removeFirst (  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . Node < E >    q    =    p . prev ;", "return   p    =  =    q    ?    last (  )     :    q ;", "}", "METHOD_END"], "methodName": ["pred"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return    (  ( PortableConcurrentDirectDeque . Node < E >  )     ( PortableConcurrentDirectDeque . PREV _ TERMINATOR )  )  ;", "}", "METHOD_END"], "methodName": ["prevTerminator"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "addFirst ( e )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "s . defaultReadObject (  )  ;", ". Node < E >    h    =    null ;", ". Node < E >    t    =    null ;", "Object   item ;", "while    (  ( item    =    s . readObject (  )  )     !  =    null )     {", "@ SuppressWarnings (  \" unchecked \"  )", ". Node < E >    newNode    =    new    . Node <  >  (  (  ( E )     ( item )  )  )  ;", "if    ( h    =  =    null )", "h    =    t    =    newNode ;", "else    {", "t . lazySetNext ( newNode )  ;", "newNode . lazySetPrev ( t )  ;", "t    =    newNode ;", "}", "}", "initHeadTail ( h ,    t )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   removeFirst (  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   removeFirstOccurrence ( o )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( pollFirst (  )  )  ;", "}", "METHOD_END"], "methodName": ["removeFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . checkNotNull ( o )  ;", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    (  (  ( item    !  =    null )     &  &     ( o . equals ( item )  )  )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeFirstOccurrence"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   screenNullResult ( pollLast (  )  )  ;", "}", "METHOD_END"], "methodName": ["removeLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . checkNotNull ( o )  ;", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    last (  )  ;    p    !  =    null ;    p    =    pred ( p )  )     {", "E   item    =    p . item ;", "if    (  (  ( item    !  =    null )     &  &     ( o . equals ( item )  )  )     &  &     ( p . casItem ( item ,    null )  )  )     {", "unlink ( p )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeLastOccurrence"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( token   instanceof   PortableConcurrentDirectDeque . Node )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "PortableConcurrentDirectDeque . Node   node    =     (  ( PortableConcurrentDirectDeque . Node )     ( token )  )  ;", "for    (  ;     ;  )     {", "Object   item    =    node . item ;", "if    ( item    =  =    null )     {", "break ;", "}", "if    ( node . casItem ( item ,    null )  )     {", "unlink ( node )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeToken"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "if    ( v    =  =    null )", "throw   new   NoSuchElemException (  )  ;", "return   v ;", "}", "METHOD_END"], "methodName": ["screenNullResult"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )", "if    (  ( p . item )     !  =    null )", "if    (  (  +  + count )     =  =     ( Integer . MAX _ VALUE )  )", "break ;", "return   count ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "whileActive    :    do    {", ". Node < E >    prev    =    x . prev ;", ". Node < E >    p    =    prev ;", "findActive    :    for    (  ;     ;  )     {", "if    (  ( p . item )     !  =    null )", "break   findActive ;", ". Node < E >    q    =    p . prev ;", "if    ( q    =  =    null )     {", "if    (  ( p . next )     =  =    p )", "continue   whileActive ;", "break   findActive ;", "} else", "if    ( p    =  =    q )", "continue   whileActive ;", "else", "p    =    q ;", "}", "if    (  ( prev    =  =    p )     |  |     ( x . casPrev ( prev ,    p )  )  )", "return ;", "}    while    (  (  ( x . item )     !  =    null )     |  |     (  ( x . next )     =  =    null )     )  ;", "}", "METHOD_END"], "methodName": ["skipDeletedPredecessors"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "whileActive    :    do    {", ". Node < E >    next    =    x . next ;", ". Node < E >    p    =    next ;", "findActive    :    for    (  ;     ;  )     {", "if    (  ( p . item )     !  =    null )", "break   findActive ;", ". Node < E >    q    =    p . next ;", "if    ( q    =  =    null )     {", "if    (  ( p . prev )     =  =    p )", "continue   whileActive ;", "break   findActive ;", "} else", "if    ( p    =  =    q )", "continue   whileActive ;", "else", "p    =    q ;", "}", "if    (  ( next    =  =    p )     |  |     ( x . casNext ( next ,    p )  )  )", "return ;", "}    while    (  (  ( x . item )     !  =    null )     |  |     (  ( x . prev )     =  =    null )     )  ;", "}", "METHOD_END"], "methodName": ["skipDeletedSuccessors"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . Node < E >    q    =    p . next ;", "return   p    =  =    q    ?    first (  )     :    q ;", "}", "METHOD_END"], "methodName": ["succ"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   toArrayList (  )  . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   toArrayList (  )  . toArray ( a )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "ArrayList < E >    list    =    new   ArrayList <  >  (  )  ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "list . add ( item )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["toArrayList"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "final   PortableConcurrentDirectDeque . Node < E >    prev    =    x . prev ;", "final   PortableConcurrentDirectDeque . Node < E >    next    =    x . next ;", "if    ( prev    =  =    null )     {", "unlinkFirst ( x ,    next )  ;", "} else", "if    ( next    =  =    null )     {", "unlinkLast ( x ,    prev )  ;", "} else    {", "PortableConcurrentDirectDeque . Node < E >    activePred ;", "PortableConcurrentDirectDeque . Node < E >    activeSucc ;", "boolean   isFirst ;", "boolean   isLast ;", "int   hops    =     1  ;", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    prev ;     ;     +  + hops )     {", "if    (  ( p . item )     !  =    null )     {", "activePred    =    p ;", "isFirst    =    false ;", "break ;", "}", "PortableConcurrentDirectDeque . Node < E >    q    =    p . prev ;", "if    ( q    =  =    null )     {", "if    (  ( p . next )     =  =    p )", "return ;", "activePred    =    p ;", "isFirst    =    true ;", "break ;", "} else", "if    ( p    =  =    q )", "return ;", "else", "p    =    q ;", "}", "for    ( PortableConcurrentDirectDeque . Node < E >    p    =    next ;     ;     +  + hops )     {", "if    (  ( p . item )     !  =    null )     {", "activeSucc    =    p ;", "isLast    =    false ;", "break ;", "}", "PortableConcurrentDirectDeque . Node < E >    q    =    p . next ;", "if    ( q    =  =    null )     {", "if    (  ( p . prev )     =  =    p )", "return ;", "activeSucc    =    p ;", "isLast    =    true ;", "break ;", "} else", "if    ( p    =  =    q )", "return ;", "else", "p    =    q ;", "}", "if    (  ( hops    <     ( PortableConcurrentDirectDeque . HOPS )  )     &  &     ( isFirst    |    isLast )  )", "return ;", "skipDeletedSuccessors ( activePred )  ;", "skipDeletedPredecessors ( activeSucc )  ;", "if    (  (  (  (  ( isFirst    |    isLast )     &  &     (  ( activePred . next )     =  =    activeSucc )  )     &  &     (  ( activeSucc . prev )     =  =    activePred )  )     &  &     ( isFirst    ?     ( activePred . prev )     =  =    null    :     ( activePred . item )     !  =    null )  )     &  &     ( isLast    ?     ( activeSucc . next )     =  =    null    :     ( activeSucc . item )     !  =    null )  )     {", "updateHead (  )  ;", "updateTail (  )  ;", "x . lazySetPrev (  ( isFirst    ?    prevTerminator (  )     :    x )  )  ;", "x . lazySetNext (  ( isLast    ?    nextTerminator (  )     :    x )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["unlink"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( PortableConcurrentDirectDeque . Node < E >    o    =    null ,    p    =    next ,    q ;     ;  )     {", "if    (  (  ( p . item )     !  =    null )     |  |     (  ( q    =    p . next )     =  =    null )  )     {", "if    (  (  ( o    !  =    null )     &  &     (  ( p . prev )     !  =    p )  )     &  &     ( first . casNext ( next ,    p )  )  )     {", "skipDeletedPredecessors ( p )  ;", "if    (  (  (  ( first . prev )     =  =    null )     &  &     (  (  ( p . next )     =  =    null )     |  |     (  ( p . item )     !  =    null )  )  )     &  &     (  ( p . prev )     =  =    first )  )     {", "updateHead (  )  ;", "updateTail (  )  ;", "o . lazySetNext ( o )  ;", "o . lazySetPrev ( prevTerminator (  )  )  ;", "}", "}", "return ;", "} else", "if    ( p    =  =    q )", "return ;", "else    {", "o    =    p ;", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["unlinkFirst"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "for    ( PortableConcurrentDirectDeque . Node < E >    o    =    null ,    p    =    prev ,    q ;     ;  )     {", "if    (  (  ( p . item )     !  =    null )     |  |     (  ( q    =    p . prev )     =  =    null )  )     {", "if    (  (  ( o    !  =    null )     &  &     (  ( p . next )     !  =    p )  )     &  &     ( last . casPrev ( prev ,    p )  )  )     {", "skipDeletedSuccessors ( p )  ;", "if    (  (  (  ( last . next )     =  =    null )     &  &     (  (  ( p . prev )     =  =    null )     |  |     (  ( p . item )     !  =    null )  )  )     &  &     (  ( p . next )     =  =    last )  )     {", "updateHead (  )  ;", "updateTail (  )  ;", "o . lazySetPrev ( o )  ;", "o . lazySetNext ( nextTerminator (  )  )  ;", "}", "}", "return ;", "} else", "if    ( p    =  =    q )", "return ;", "else    {", "o    =    p ;", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["unlinkLast"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . Node < E >    h ;", "PortableConcurrentDirectDeque . Node < E >    p ;", "PortableConcurrentDirectDeque . Node < E >    q ;", "restartFromHead    :    while    (  (  (  ( h    =    head )  . item )     =  =    null )     &  &     (  ( p    =    h . prev )     !  =    null )  )     {", "for    (  ;     ;  )     {", "if    (  (  ( q    =    p . prev )     =  =    null )     |  |     (  ( q    =     ( p    =    q )  . prev )     =  =    null )  )     {", "if    ( casHead ( h ,    p )  )", "return ;", "else", "continue   restartFromHead ;", "} else", "if    ( h    !  =     ( head )  )", "continue   restartFromHead ;", "else", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateHead"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "PortableConcurrentDirectDeque . Node < E >    t ;", "PortableConcurrentDirectDeque . Node < E >    p ;", "PortableConcurrentDirectDeque . Node < E >    q ;", "restartFromTail    :    while    (  (  (  ( t    =    tail )  . item )     =  =    null )     &  &     (  ( p    =    t . next )     !  =    null )  )     {", "for    (  ;     ;  )     {", "if    (  (  ( q    =    p . next )     =  =    null )     |  |     (  ( q    =     ( p    =    q )  . next )     =  =    null )  )     {", "if    ( casTail ( t ,    p )  )", "return ;", "else", "continue   restartFromTail ;", "} else", "if    ( t    !  =     ( tail )  )", "continue   restartFromTail ;", "else", "p    =    q ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateTail"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "s . defaultWriteObject (  )  ;", "for    (  . Node < E >    p    =    first (  )  ;    p    !  =    null ;    p    =    succ ( p )  )     {", "E   item    =    p . item ;", "if    ( item    !  =    null )", "s . writeObject ( item )  ;", "}", "s . writeObject ( null )  ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.jboss.as.security.lru.PortableConcurrentDirectDeque"}, {"methodBody": ["METHOD_START", "{", "return   new   LRUCache <  >  (  1  0  0  0  ,     (    key ,    value )     -  >     {", "if    ( value    !  =    null )     {", "value . logout (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.jboss.as.security.plugins.DefaultAuthenticationCacheFactory"}, {"methodBody": ["METHOD_START", "{", "int   i    =    auditManagerClassName . lastIndexOf (  \"  :  \"  )  ;", "if    ( i    =  =     (  -  1  )  )", "throw   logging . SecurityLogger . ROOT _ LOGGER . missingModuleName (  \" audit   manager   class \"  )  ;", "String   moduleSpec    =    auditManagerClassName . substring (  0  ,    i )  ;", "String   className    =    auditManagerClassName . substring (  ( i    +     1  )  )  ;", "Class <  ?  >    clazz    =    SecurityActions . getModuleClassLoader ( loader ,    moduleSpec )  . loadClass ( className )  ;", "Constructor <  ?  >    ctr    =    clazz . getConstructor ( new   Class [  ]  {    String . class    }  )  ;", "return    (  ( AuditManager )     ( ctr . newInstance ( new   Object [  ]  {    securityDomain    }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createAuditManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "int   i    =    callbackHandlerClassName . lastIndexOf (  \"  :  \"  )  ;", "if    ( i    =  =     (  -  1  )  )", "throw   logging . SecurityLogger . ROOT _ LOGGER . missingModuleName (  \" default - callback - handler - class - name   attribute \"  )  ;", "String   moduleSpec    =    callbackHandlerClassName . substring (  0  ,    i )  ;", "String   className    =    callbackHandlerClassName . substring (  ( i    +     1  )  )  ;", "Class <  ?  >    callbackHandlerClazz    =    SecurityActions . getModuleClassLoader ( loader ,    moduleSpec )  . loadClass ( className )  ;", "CallbackHandler   ch    =     (  ( CallbackHandler )     ( callbackHandlerClazz . newInstance (  )  )  )  ;", "i    =    authenticationManagerClassName . lastIndexOf (  \"  :  \"  )  ;", "if    ( i    =  =     (  -  1  )  )", "throw   logging . SecurityLogger . ROOT _ LOGGER . missingModuleName (  \" authentication - manager - class - name   attribute \"  )  ;", "moduleSpec    =    authenticationManagerClassName . substring (  0  ,    i )  ;", "className    =    authenticationManagerClassName . substring (  ( i    +     1  )  )  ;", "Class <  ?  >    clazz    =    SecurityActions . getModuleClassLoader ( loader ,    moduleSpec )  . loadClass ( className )  ;", "Constructor <  ?  >    ctr    =    clazz . getConstructor ( new   Class [  ]  {    String . class ,    CallbackHandler . class    }  )  ;", "return    (  ( AuthenticationManager )     ( ctr . newInstance ( new   Object [  ]  {    securityDomain ,    ch    }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createAuthenticationManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "int   i    =    authorizationManagerClassName . lastIndexOf (  \"  :  \"  )  ;", "if    ( i    =  =     (  -  1  )  )", "throw   logging . SecurityLogger . ROOT _ LOGGER . missingModuleName (  \" authorization   manager   class \"  )  ;", "String   moduleSpec    =    authorizationManagerClassName . substring (  0  ,    i )  ;", "String   className    =    authorizationManagerClassName . substring (  ( i    +     1  )  )  ;", "Class <  ?  >    clazz    =    SecurityActions . getModuleClassLoader ( loader ,    moduleSpec )  . loadClass ( className )  ;", "Constructor <  ?  >    ctr    =    clazz . getConstructor ( new   Class [  ]  {    String . class    }  )  ;", "return    (  ( AuthorizationManager )     ( ctr . newInstance ( new   Object [  ]  {    securityDomain    }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createAuthorizationManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "int   i    =    identityTrustManagerClassName . lastIndexOf (  \"  :  \"  )  ;", "if    ( i    =  =     (  -  1  )  )", "throw   logging . SecurityLogger . ROOT _ LOGGER . missingModuleName (  \" identity   trust   manager   class \"  )  ;", "String   moduleSpec    =    identityTrustManagerClassName . substring (  0  ,    i )  ;", "String   className    =    identityTrustManagerClassName . substring (  ( i    +     1  )  )  ;", "Class <  ?  >    clazz    =    SecurityActions . getModuleClassLoader ( loader ,    moduleSpec )  . loadClass ( className )  ;", "Constructor <  ?  >    ctr    =    clazz . getConstructor ( new   Class [  ]  {    String . class    }  )  ;", "return    (  ( IdentityTrustManager )     ( ctr . newInstance ( new   Object [  ]  {    securityDomain    }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createIdentityTrustManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "int   i    =    mappingManagerClassName . lastIndexOf (  \"  :  \"  )  ;", "if    ( i    =  =     (  -  1  )  )", "throw   logging . SecurityLogger . ROOT _ LOGGER . missingModuleName (  \" mapping   manager   class \"  )  ;", "String   moduleSpec    =    mappingManagerClassName . substring (  0  ,    i )  ;", "String   className    =    mappingManagerClassName . substring (  ( i    +     1  )  )  ;", "Class <  ?  >    clazz    =    SecurityActions . getModuleClassLoader ( loader ,    moduleSpec )  . loadClass ( className )  ;", "Constructor <  ?  >    ctr    =    clazz . getConstructor ( new   Class [  ]  {    String . class    }  )  ;", "return    (  ( MappingManager )     ( ctr . newInstance ( new   Object [  ]  {    securityDomain    }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createMappingManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   createSecurityDomainContext ( securityDomain ,    cacheFactory ,    null )  ;", "}", "METHOD_END"], "methodName": ["createSecurityDomainContext"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "SecurityLogger . ROOT _ LOGGER . debugf (  \" Creating   SDC   for   domain    =     % s \"  ,    securityDomain )  ;", "AuthenticationManager   am    =    createAuthenticationManager ( securityDomain )  ;", "if    (  ( cacheFactory    !  =    null )     &  &     ( am   instanceof   CacheableManager )  )     {", "final   Map < Principal ,     ?  >    cache    =    cacheFactory . getCache (  )  ;", "if    ( cache    !  =    null )     {", "@ SuppressWarnings (  {     \" unchecked \"  ,     \" rawtypes \"     }  )", "CacheableManager < Map ,    Principal >    cm    =     (  ( CacheableManager < Map ,    Principal >  )     ( am )  )  ;", "cm . setCache ( cache )  ;", "}", "}", "if    ( deepCopySubjectMode )     {", ". setDeepCopySubjectMode ( am )  ;", "}", "return   new   SecurityDomainContext ( am ,    createAuthorizationManager ( securityDomain )  ,    createAuditManager ( securityDomain )  ,    createIdentityTrustManager ( securityDomain )  ,    createMappingManager ( securityDomain )  ,    jsseSecurityDomain )  ;", "}", "METHOD_END"], "methodName": ["createSecurityDomainContext"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "AuditManager   am    =    null ;", "try    {", "am    =    auditMgrMap . get ( Domain )  ;", "if    ( am    =  =    null )     {", "am    =     (  ( AuditManager )     ( lookUpJNDI (  ( Domain    +     \"  / auditMgr \"  )  )  )  )  ;", "auditMgrMap . put ( Domain ,    am )  ;", "}", "}    catch    ( Exception   e )     {", "SecurityLogger . ROOT _ LOGGER . tracef ( e ,     \" Exception   getting   AuditManager   for   domain =  % s \"  ,    Domain )  ;", "}", "return   am ;", "}", "METHOD_END"], "methodName": ["getAuditManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   auditManagerClassName ;", "}", "METHOD_END"], "methodName": ["getAuditManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "AuthenticationManager   am    =    null ;", "try    {", "am    =    authMgrMap . get ( Domain )  ;", "if    ( am    =  =    null )     {", "am    =     (  ( AuthenticationManager )     ( lookUpJNDI (  ( Domain    +     \"  / authenticationMgr \"  )  )  )  )  ;", "authMgrMap . put ( Domain ,    am )  ;", "}", "}    catch    ( Exception   e )     {", "SecurityLogger . ROOT _ LOGGER . tracef ( e ,     \" Exception   getting   AuthenticationManager   for   domain =  % s \"  ,    Domain )  ;", "}", "return   am ;", "}", "METHOD_END"], "methodName": ["getAuthenticationManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   authenticationManagerClassName ;", "}", "METHOD_END"], "methodName": ["getAuthenticationManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "AuthorizationManager   am    =    null ;", "try    {", "am    =    authzMgrMap . get ( Domain )  ;", "if    ( am    =  =    null )     {", "am    =     (  ( AuthorizationManager )     ( lookUpJNDI (  ( Domain    +     \"  / authorizationMgr \"  )  )  )  )  ;", "authzMgrMap . put ( Domain ,    am )  ;", "}", "}    catch    ( Exception   e )     {", "SecurityLogger . ROOT _ LOGGER . tracef ( e ,     \" Exception   getting   AuthorizationManager   for   domain =  % s \"  ,    Domain )  ;", "}", "return   am ;", "}", "METHOD_END"], "methodName": ["getAuthorizationManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   authorizationManagerClassName ;", "}", "METHOD_END"], "methodName": ["getAuthorizationManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   callbackHandlerClassName ;", "}", "METHOD_END"], "methodName": ["getCallbackHandlerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "IdentityTrustManager   itm    =    null ;", "try    {", "itm    =    idmMgrMap . get ( Domain )  ;", "if    ( itm    =  =    null )     {", "itm    =     (  ( IdentityTrustManager )     ( lookUpJNDI (  ( Domain    +     \"  / identityTrustMgr \"  )  )  )  )  ;", "idmMgrMap . put ( Domain ,    itm )  ;", "}", "}    catch    ( Exception   e )     {", "SecurityLogger . ROOT _ LOGGER . tracef ( e ,     (  \" Exception   getting   IdentityTrustManager   for   domain =  % s \"     +    Domain )  )  ;", "}", "return   itm ;", "}", "METHOD_END"], "methodName": ["getIdentityTrustManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   identityTrustManagerClassName ;", "}", "METHOD_END"], "methodName": ["getIdentityTrustManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "JSSESecurityDomain   jsse    =    null ;", "try    {", "jsse    =    jsseMap . get ( securityDomain )  ;", "if    ( jsse    =  =    null )     {", "jsse    =     (  ( JSSESecurityDomain )     ( lookUpJNDI (  ( securityDomain    +     \"  / jsse \"  )  )  )  )  ;", "jsseMap . put ( securityDomain ,    jsse )  ;", "}", "}    catch    ( Exception   e )     {", "SecurityLogger . ROOT _ LOGGER . tracef ( e ,     \" Exception   getting   JSSESecurityDomain   for   domain =  % s \"  ,    securityDomain )  ;", "}", "return   jsse ;", "}", "METHOD_END"], "methodName": ["getJSSE"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "MappingManager   mm    =    null ;", "try    {", "mm    =    mappingMgrMap . get ( Domain )  ;", "if    ( mm    =  =    null )     {", "mm    =     (  ( MappingManager )     ( lookUpJNDI (  ( Domain    +     \"  / mappingMgr \"  )  )  )  )  ;", "mappingMgrMap . put ( Domain ,    mm )  ;", "}", "}    catch    ( Exception   e )     {", "SecurityLogger . ROOT _ LOGGER . tracef ( e ,     \" Exception   getting   MappingManager   for   domain =  % s \"  ,    Domain )  ;", "}", "return   mm ;", "}", "METHOD_END"], "methodName": ["getMappingManager"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   mappingManagerClassName ;", "}", "METHOD_END"], "methodName": ["getMappingManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   securityMgrMap ;", "}", "METHOD_END"], "methodName": ["getSecurityManagerMap"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "return   deepCopySubjectMode ;", "}", "METHOD_END"], "methodName": ["isDeepCopySubjectMode"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    null ;", "try    {", "Context   ctx    =    new   InitialContext (  )  ;", "if    ( contextName . startsWith ( JAAS _ CONTEXT _ ROOT )  )", "result    =    ctx . lookup ( contextName )  ;", "else", "result    =    ctx . lookup (  (  ( JAAS _ CONTEXT _ ROOT )     +    contextName )  )  ;", "}    catch    ( Exception   e )     {", "SecurityLogger . ROOT _ LOGGER . tracef (  \" Look   up   of   JNDI   for    % s   failed   with    % s \"  ,    contextName ,    e . getLocalizedMessage (  )  )  ;", "return   null ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["lookUpJNDI"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "securityMgrMap . remove ( securityDomain )  ;", "auditMgrMap . remove ( securityDomain )  ;", "authMgrMap . remove ( securityDomain )  ;", "authzMgrMap . remove ( securityDomain )  ;", "idmMgrMap . remove ( securityDomain )  ;", "mappingMgrMap . remove ( securityDomain )  ;", "jsseMap . remove ( securityDomain )  ;", "}", "METHOD_END"], "methodName": ["removeSecurityDomain"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "this . auditManagerClassName    =    auditManagerClassName ;", "}", "METHOD_END"], "methodName": ["setAuditManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "this . authenticationManagerClassName    =    authenticationManagerClassName ;", "}", "METHOD_END"], "methodName": ["setAuthenticationManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "this . authorizationManagerClassName    =    authorizationManagerClassName ;", "}", "METHOD_END"], "methodName": ["setAuthorizationManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "this . callbackHandlerClassName    =    callbackHandlerClassName ;", "}", "METHOD_END"], "methodName": ["setCallbackHandlerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "this . deepCopySubjectMode    =    deepCopySubjectMode ;", "}", "METHOD_END"], "methodName": ["setDeepCopySubjectMode"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >  [  ]    argsType    =    new   Class <  ?  >  [  ]  {    Boolean . class    }  ;", "Method   m    =    authenticationManager . getClass (  )  . getMethod (  \" setDeepCopySubjectOption \"  ,    argsType )  ;", "Object [  ]    deepCopyArgs    =    new   Object [  ]  {    Boolean . TRUE    }  ;", "m . invoke ( authenticationManager ,    deepCopyArgs )  ;", "}    catch    ( Exception   e )     {", "Logger . ROOT _ LOGGER . tracef (  \" Optional   setDeepCopySubjectMode   failed :     % s \"  ,    e . getLocalizedMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDeepCopySubjectMode"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "this . identityTrustManagerClassName    =    identityTrustManagerClassName ;", "}", "METHOD_END"], "methodName": ["setIdentityTrustManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "this . mappingManagerClassName    =    mappingManagerClassName ;", "}", "METHOD_END"], "methodName": ["setMappingManagerClassName"], "fileName": "org.jboss.as.security.plugins.JNDIBasedSecurityManagement"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < ModuleClassLoaderLocator . CombinedClassLoader >  (  )     {", "@ Override", "public   ModuleClassLoaderLocator . CombinedClassLoader   run (  )     {", "return   new   ModuleClassLoaderLocator . CombinedClassLoader ( classLoaders )  ;", "}", "}  )  ;", "} else    {", "return   new   ModuleClassLoaderLocator . CombinedClassLoader ( classLoaders )  ;", "}", "}", "METHOD_END"], "methodName": ["createCombinedClassLoader"], "fileName": "org.jboss.as.security.plugins.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < Object >  (  )     {", "public   Object   run (  )     {", "Object   credential    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "credential    =    sc . getUtil (  )  . getCredential (  )  ;", "}", "return   credential ;", "}", "}  )  ;", "} else    {", "Object   credential    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "credential    =    sc . getUtil (  )  . getCredential (  )  ;", "}", "return   credential ;", "}", "}", "METHOD_END"], "methodName": ["getCredential"], "fileName": "org.jboss.as.security.plugins.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "final   Module   module    =    loader . loadModule ( ModuleIdentifier . fromString ( moduleSpec )  )  ;", "return   WildFlySecurityManager . isChecking (  )     ?    AccessController . doPrivileged ( new   GetModuleClassLoaderAction ( module )  )     :    module . getClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getModuleClassLoader"], "fileName": "org.jboss.as.security.plugins.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < Principal >  (  )     {", "public   Principal   run (  )     {", "Principal   principal    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "principal    =    sc . getUtil (  )  . getUserPrincipal (  )  ;", "}", "return   principal ;", "}", "}  )  ;", "} else    {", "Principal   principal    =    null ;", "SecurityContext   sc    =     . getSecurityContext (  )  ;", "if    ( sc    !  =    null )     {", "principal    =    sc . getUtil (  )  . getUserPrincipal (  )  ;", "}", "return   principal ;", "}", "}", "METHOD_END"], "methodName": ["getPrincipal"], "fileName": "org.jboss.as.security.plugins.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction < SecurityContext >  (  )     {", "public   SecurityContext   run (  )     {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}  )  ;", "} else    {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSecurityContext"], "fileName": "org.jboss.as.security.plugins.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   auditMgr ;", "}", "METHOD_END"], "methodName": ["getAuditManager"], "fileName": "org.jboss.as.security.plugins.SecurityDomainContext"}, {"methodBody": ["METHOD_START", "{", "return   authenticationMgr ;", "}", "METHOD_END"], "methodName": ["getAuthenticationManager"], "fileName": "org.jboss.as.security.plugins.SecurityDomainContext"}, {"methodBody": ["METHOD_START", "{", "return   authorizationMgr ;", "}", "METHOD_END"], "methodName": ["getAuthorizationManager"], "fileName": "org.jboss.as.security.plugins.SecurityDomainContext"}, {"methodBody": ["METHOD_START", "{", "return   identityTrustMgr ;", "}", "METHOD_END"], "methodName": ["getIdentityTrustManager"], "fileName": "org.jboss.as.security.plugins.SecurityDomainContext"}, {"methodBody": ["METHOD_START", "{", "return   jsseSecurityDomain ;", "}", "METHOD_END"], "methodName": ["getJSSE"], "fileName": "org.jboss.as.security.plugins.SecurityDomainContext"}, {"methodBody": ["METHOD_START", "{", "return   mappingMgr ;", "}", "METHOD_END"], "methodName": ["getMappingManager"], "fileName": "org.jboss.as.security.plugins.SecurityDomainContext"}, {"methodBody": ["METHOD_START", "{", "Subject   subject    =    null ;", "try    {", "subject    =     (  ( Subject )     ( PolicyContext . getContext (  . SUBJECT _ CONTEXT _ KEY )  )  )  ;", "}    catch    ( PolicyContextException   pce )     {", "}", "return   subject ;", "}", "METHOD_END"], "methodName": ["getSubject"], "fileName": "org.jboss.as.security.plugins.SecurityDomainContext"}, {"methodBody": ["METHOD_START", "{", "return    ( connection . equals ( obj . connection )  )     &  &     ( securityIdentity . equals ( obj . securityIdentity )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.security.remoting.RemotingConnectionCredential"}, {"methodBody": ["METHOD_START", "{", "return   connection . getSslSession (  )  ;", "}", "METHOD_END"], "methodName": ["getSSLSession"], "fileName": "org.jboss.as.security.remoting.RemotingConnectionCredential"}, {"methodBody": ["METHOD_START", "{", "return   securityIdentity ;", "}", "METHOD_END"], "methodName": ["getSecurityIdentity"], "fileName": "org.jboss.as.security.remoting.RemotingConnectionCredential"}, {"methodBody": ["METHOD_START", "{", "return   subject ;", "}", "METHOD_END"], "methodName": ["getSubject"], "fileName": "org.jboss.as.security.remoting.RemotingConnectionCredential"}, {"methodBody": ["METHOD_START", "{", "SecurityManager   securityManager    =    System . getSecurityManager (  )  ;", "if    ( securityManager    !  =    null )     {", "securityManager . checkPermission ( permission )  ;", "}", "}", "METHOD_END"], "methodName": ["checkPermission"], "fileName": "org.jboss.as.security.remoting.RemotingContext"}, {"methodBody": ["METHOD_START", "{", "RemotingContext . checkPermission ( RemotingContext . CLEAR _ CONNECTION )  ;", "RemotingContext . connection . set ( null )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jboss.as.security.remoting.RemotingContext"}, {"methodBody": ["METHOD_START", "{", "RemotingContext . checkPermission ( RemotingContext . GET _ CONNECTION )  ;", "RemoteConnection   remoteConnection    =    RemotingContext . connection . get (  )  ;", "if    ( remoteConnection   instanceof   RemotingContext . RemotingRemoteConnection )     {", "return    (  ( RemotingContext . RemotingRemoteConnection )     ( remoteConnection )  )  . connection ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.jboss.as.security.remoting.RemotingContext"}, {"methodBody": ["METHOD_START", "{", "RemotingContext . checkPermission ( RemotingContext . GET _ CONNECTION )  ;", "return   RemotingContext . connection . get (  )  ;", "}", "METHOD_END"], "methodName": ["getRemoteConnection"], "fileName": "org.jboss.as.security.remoting.RemotingContext"}, {"methodBody": ["METHOD_START", "{", "RemotingContext . checkPermission ( RemotingContext . IS _ CONNECTION _ SET )  ;", "return    ( RemotingContext . connection . get (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSet"], "fileName": "org.jboss.as.security.remoting.RemotingContext"}, {"methodBody": ["METHOD_START", "{", "RemotingContext . checkPermission ( RemotingContext . SET _ CONNECTION )  ;", "RemotingContext . connection . set ( connection )  ;", "}", "METHOD_END"], "methodName": ["setConnection"], "fileName": "org.jboss.as.security.remoting.RemotingContext"}, {"methodBody": ["METHOD_START", "{", "RemotingContext . checkPermission ( RemotingContext . SET _ CONNECTION )  ;", "RemotingContext . connection . set ( new   RemotingContext . RemotingRemoteConnection ( connection )  )  ;", "}", "METHOD_END"], "methodName": ["setConnection"], "fileName": "org.jboss.as.security.remoting.RemotingContext"}, {"methodBody": ["METHOD_START", "{", "NameCallback   nc    =    new   NameCallback (  \" Alias :     \"  )  ;", "ObjectCallback   oc    =    new   ObjectCallback (  \" Credential :     \"  )  ;", "Callback [  ]    callbacks    =    new   Callback [  ]  {    nc ,    oc    }  ;", "try    {", "callbackHandler . handle ( callbacks )  ;", "return   oc . getCredential (  )  ;", "}    catch    ( IOException   ioe )     {", "Exception   le    =    new   Exception (  )  ;", "le . initCause ( ioe )  ;", "throw   le ;", "}    catch    ( UnsupportedCallbackException   uce )     {", "Exception   le    =    new   Exception (  )  ;", "le . initCause ( uce )  ;", "throw   le ;", "}", "}", "METHOD_END"], "methodName": ["getCredential"], "fileName": "org.jboss.as.security.remoting.RemotingLoginModule"}, {"methodBody": ["METHOD_START", "{", "return    !  ( WildFlySecurityManager . isChecking (  )  )     ?    SecurityActions . RemotingContextAssociationActions . NON _ PRIVILEGED    :    SecurityActions . RemotingContextAssociationActions . PRIVILEGED ;", "}", "METHOD_END"], "methodName": ["remotingContextAssociationActions"], "fileName": "org.jboss.as.security.remoting.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   SecurityActions . remotingContextAssociationActions (  )  . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["remotingContextGetConnection"], "fileName": "org.jboss.as.security.remoting.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   parentPolicy ;", "}", "METHOD_END"], "methodName": ["getParentPolicyInjector"], "fileName": "org.jboss.as.security.service.JaccService"}, {"methodBody": ["METHOD_START", "{", "String   module    =    WildFlySecurityManager . getPropertyPrivileged ( SecurityBootstrapService . JACC _ MODULE ,    null )  ;", "final   ClassLoader   originalClassLoader ;", "final   ClassLoader   jaccClassLoader ;", "if    ( module    !  =    null )     {", "jaccClassLoader    =    SecurityActions . getModuleClassLoader ( module )  ;", "originalClassLoader    =    SecurityActions . setThreadContextClassLoader ( jaccClassLoader )  ;", "} else    {", "jaccClassLoader    =    null ;", "originalClassLoader    =    null ;", "}", "try    {", "return   PolicyConfigurationFactory . getPolicyConfigurationFactory (  )  ;", "}    finally    {", "if    ( originalClassLoader    !  =    null )     {", "SecurityActions . setThreadContextClassLoader ( originalClassLoader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getPolicyConfigurationFactory"], "fileName": "org.jboss.as.security.service.JaccService"}, {"methodBody": ["METHOD_START", "{", "return   WildFlySecurityManager . isChecking (  )     ?    SecurityActions . ClassLoaderActions . PRIVILEGED    :    SecurityActions . ClassLoaderActions . NON _ PRIVILEGED ;", "}", "METHOD_END"], "methodName": ["classLoaderActions"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "ModuleLoader   loader    =    Module . getCallerModuleLoader (  )  ;", "final   Module   module    =    loader . loadModule ( ModuleIdentifier . fromString ( moduleSpec )  )  ;", "GetModuleClassLoaderAction   action    =    new   GetModuleClassLoaderAction ( module )  ;", "return   WildFlyManager . isChecking (  )     ?    AccessController . doPrivileged ( action )     :    action . run (  )  ;", "}", "METHOD_END"], "methodName": ["getModuleClassLoader"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   SecurityActions . classLoaderActions (  )  . loadClass ( name )  ;", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return    !  ( WildFlySecurityManager . isChecking (  )  )     ?    SecurityActions . RemotingContextAssociationActions . NON _ PRIVILEGED    :    SecurityActions . RemotingContextAssociationActions . PRIVILEGED ;", "}", "METHOD_END"], "methodName": ["remotingContextAccociationActions"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "SecurityActions . remotingContextAccociationActions (  )  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["remotingContextClear"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   SecurityActions . remotingContextAccociationActions (  )  . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["remotingContextGetConnection"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   SecurityActions . remotingContextAccociationActions (  )  . isSet (  )  ;", "}", "METHOD_END"], "methodName": ["remotingContextIsSet"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   SecurityActions . classLoaderActions (  )  . setThreadContextClassLoader ( toSet )  ;", "}", "METHOD_END"], "methodName": ["setThreadContextClassLoader"], "fileName": "org.jboss.as.security.service.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "return   moduleLoaderValue ;", "}", "METHOD_END"], "methodName": ["getServiceModuleLoaderInjectedValue"], "fileName": "org.jboss.as.security.service.SecurityBootstrapService"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initializeJacc )  )     {", "SecurityLogger . ROOT _ LOGGER . debugf (  \" Legacy   subsystem   configured   to   not   initialize   JACC .    If   you   want   JACC   support ,    make   sure   you   have   it   properly   configured   in   Elytron   subsystem .  \"  )  ;", "return ;", "}", "SecurityLogger . ROOT _ LOGGER . debugf (  \" Initializing   JACC   from   legacy   subsystem .  \"  )  ;", "try    {", "oldPolicy    =    Policy . getPolicy (  )  ;", "if    (  (  . jaccPolicy )     =  =    null )     {", "String   module    =    WildFlySecurityManager . getPropertyPrivileged (  . JACC _ MODULE ,    null )  ;", "String   provider    =    WildFlySecurityManager . getPropertyPrivileged (  . JACC _ POLICY _ PROVIDER ,     \" DelegatingPolicy \"  )  ;", "Class <  ?  >    providerClass    =    loadClass ( module ,    provider )  ;", "try    {", "Class <  ?  >  [  ]    ctorSig    =    new   Class <  ?  >  [  ]  {    Policy . class    }  ;", "Constructor <  ?  >    ctor    =    providerClass . getConstructor ( ctorSig )  ;", "Object [  ]    ctorArgs    =    new   Object [  ]  {    oldPolicy    }  ;", ". jaccPolicy    =     (  ( Policy )     ( ctor . newInstance ( ctorArgs )  )  )  ;", "}    catch    ( NoSuchMethodException   e )     {", ". log . debugf (  \" Provider   does   not   support   ctor ( Policy )  \"  )  ;", "try    {", ". jaccPolicy    =     (  ( Policy )     ( providerClass . newInstance (  )  )  )  ;", "}    catch    ( Exception   e 1  )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToStartException (  \"  \"  ,    e 1  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToStartException (  \"  \"  ,    e )  ;", "}", "}", "Policy . setPolicy (  . jaccPolicy )  ;", ". jaccPolicy . refresh (  )  ;", "SubjectPolicyContextHandler   handler    =    new   SubjectPolicyContextHandler (  )  ;", "PolicyContext . registerHandler ( SUBJECT _ CONTEXT _ KEY ,    handler ,    true )  ;", "CallbackHandlerPolicyContextHandler   chandler    =    new   CallbackHandlerPolicyContextHandler (  )  ;", "PolicyContext . registerHandler ( CALLBACK _ HANDLER _ KEY ,    chandler ,    true )  ;", "ClassLoaderLocatorFactory . set ( new   ModuleClassLoaderLocator ( moduleLoaderValue . getValue (  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   SecurityLogger . ROOT _ LOGGER . unableToStartException (  \"  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeJacc"], "fileName": "org.jboss.as.security.service.SecurityBootstrapService"}, {"methodBody": ["METHOD_START", "{", "if    ( module    !  =    null )     {", "return   Actions . getModuleClassLoader ( module )  . loadClass ( className )  ;", "}", "return   Actions . loadClass ( className )  ;", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.security.service.SecurityBootstrapService"}, {"methodBody": ["METHOD_START", "{", "ServiceTarget   target    =    context . getChildTarget (  )  ;", "final   BinderService   binderService    =    new   BinderService (  . POLICY _ REGISTRATION )  ;", "target . addService ( ContextNames . buildServiceName ( JAVA _ CONTEXT _ SERVICE _ NAME ,     . POLICY _ REGISTRATION )  ,    binderService )  . addDependency ( JAVA _ CONTEXT _ SERVICE _ NAME ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . addInjection ( binderService . getManagedObjectInjector (  )  ,    new   ValueManagedReferenceFactory ( Values . immediateValue ( new   JBossPolicyRegistration (  )  )  )  )  . setInitialMode ( ACTIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["setupPolicyRegistration"], "fileName": "org.jboss.as.security.service.SecurityBootstrapService"}, {"methodBody": ["METHOD_START", "{", "return   cacheValue ;", "}", "METHOD_END"], "methodName": ["getCacheInjector"], "fileName": "org.jboss.as.security.service.SecurityDomainService"}, {"methodBody": ["METHOD_START", "{", "return   configurationValue ;", "}", "METHOD_END"], "methodName": ["getConfigurationInjector"], "fileName": "org.jboss.as.security.service.SecurityDomainService"}, {"methodBody": ["METHOD_START", "{", "return   securityManagementValue ;", "}", "METHOD_END"], "methodName": ["getSecurityManagementInjector"], "fileName": "org.jboss.as.security.service.SecurityDomainService"}, {"methodBody": ["METHOD_START", "{", "return   serviceModuleLoaderValue ;", "}", "METHOD_END"], "methodName": ["getServiceModuleLoaderInjectedValue"], "fileName": "org.jboss.as.security.service.SecurityManagementService"}, {"methodBody": ["METHOD_START", "{", "AuditEvent   auditEvent    =    new   AuditEvent ( level )  ;", "Map < String ,    Object >    ctxMap    =    new   HashMap < String ,    Object >  (  )  ;", "ctxMap . put (  \" principal \"  ,     ( userPrincipal    !  =    null    ?    userPrincipal . getName (  )     :     \" null \"  )  )  ;", "ctxMap . put (  \" Source \"  ,    getClass (  )  . getCanonicalName (  )  )  ;", "ctxMap . put (  \" Action \"  ,     \" authentication \"  )  ;", "auditEvent . setContextMap ( ctxMap )  ;", "audit . audit ( auditEvent )  ;", "}", "METHOD_END"], "methodName": ["audit"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "authenticate ( null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["authenticate"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "SecurityContext   current    =    SecurityContextAssociation . getSecurityContext (  )  ;", "SecurityContext   previous    =    contexts . peek (  )  ;", "boolean   skipReauthentication    =     (  (  (  ( current . getSubjectInfo (  )  )     !  =    null )     &  &     (  ( current . getSubjectInfo (  )  . getAuthenticatedSubject (  )  )     !  =    null )  )     &  &     (  !  ( current . getSubjectInfo (  )  . getAuthenticatedSubject (  )  . getPrincipals (  )  . isEmpty (  )  )  )  )     &  &     (  (  ( previous    !  =    null )     &  &     ( current . getSecurityDomain (  )  . equals ( previous . getSecurityDomain (  )  )  )  )     |  |     (  ( current . getIncomingRunAs (  )  )    instanceof   RunAsIdentity )  )  ;", "if    (  ! skipReauthentication )     {", "SecurityContextUtil   util    =    current . getUtil (  )  ;", "Object   credential    =    util . getCredential (  )  ;", "Subject   subject    =    null ;", "if    ( credential   instanceof   RemotingConnectionCredential )     {", "subject    =     (  ( RemotingConnectionCredential )     ( credential )  )  . getSubject (  )  ;", "}", "if    (  ( authenticate ( current ,    subject )  )     =  =    false )     {", "throw   SecurityLogger . ROOT _ LOGGER . invalidUserException (  )  ;", "}", "}", "if    ( runAs    !  =    null )     {", "RunAs   runAsIdentity    =    new   RunAsIdentity ( runAs ,    runAsPrincipal ,    extraRoles )  ;", "current . setOutgoingRunAs ( runAsIdentity )  ;", "} else", "if    (  (  ( propagate )     &  &     ( previous    !  =    null )  )     &  &     (  ( previous . getOutgoingRunAs (  )  )     !  =    null )  )     {", "current . setOutgoingRunAs ( previous . getOutgoingRunAs (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["authenticate"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "SecurityContextUtil   util    =    context . getUtil (  )  ;", "SubjectInfo   subjectInfo    =    getSubjectInfo ( context )  ;", "if    ( subject    =  =    null )     {", "subject    =    new   Subject (  )  ;", "}", "Principal   principal    =    util . getUserPrincipal (  )  ;", "Principal   auditPrincipal    =    principal ;", "Object   credential    =    util . getCredential (  )  ;", "Identity   unauthenticatedIdentity    =    null ;", "boolean   authenticated    =    false ;", "if    ( principal    =  =    null )     {", "unauthenticatedIdentity    =    getUnauthenticatedIdentity (  )  ;", "subjectInfo . addIdentity ( unauthenticatedIdentity )  ;", "auditPrincipal    =    unauthenticatedIdentity . asPrincipal (  )  ;", "subject . getPrincipals (  )  . add ( auditPrincipal )  ;", "authenticated    =    true ;", "} else    {", "subject . getPrincipals (  )  . add ( principal )  ;", "}", "if    ( authenticated    =  =    false )     {", "AuthenticationManager   authenticationManager    =    context . getAuthenticationManager (  )  ;", "authenticated    =    authenticationManager . isValid ( principal ,    credential ,    subject )  ;", "}", "if    ( authenticated    =  =    true )     {", "subjectInfo . setAuthenticatedSubject ( subject )  ;", "}", "AuditManager   auditManager    =    context . getAuditManager (  )  ;", "if    ( auditManager    !  =    null )     {", "audit (  ( authenticated    ?    AuditLevel . SUCCESS    :    AuditLevel . FAILURE )  ,    auditManager ,    auditPrincipal )  ;", "}", "return   authenticated ;", "}", "METHOD_END"], "methodName": ["authenticate"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "final   SecurityContext   securityContext    =    AccessController . doPrivileged ( securityContext (  )  )  ;", "if    ( securityContext    =  =    null )     {", "return   false ;", "}", "EJBResource   resource    =    new   EJBResource ( new   HashMap < String ,    Object >  (  )  )  ;", "resource . setEjbName ( ejbName )  ;", "resource . setEjbMethod ( ejbMethod )  ;", "resource . setEjbMethodInterface ( ejbMethodIntf )  ;", "resource . setEjbMethodRoles ( new   SimpleRoleGroup ( methodRoles )  )  ;", "resource . setCodeSource ( ejbCodeSource )  ;", "resource . setPolicyContextID ( contextID )  ;", "resource . setCallerRunAsIdentity ( securityContext . getIncomingRunAs (  )  )  ;", "resource . setCallerSubject ( securityContext . getUtil (  )  . getSubject (  )  )  ;", "Principal   userPrincipal    =    securityContext . getUtil (  )  . getUserPrincipal (  )  ;", "resource . setPrincipal ( userPrincipal )  ;", "try    {", "AbstractEJBAuthorizationHelper   helper    =    SecurityHelperFactory . getEJBAuthorizationHelper ( securityContext )  ;", "return   helper . authorize ( resource )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["authorize"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   SecurityContext   securityContext    =    SecurityContextFactory . createSecurityContext ( securityDomain )  ;", "if    (  ( securityManagement )     =  =    null )", "throw   SecurityLogger . ROOT _ LOGGER . securityManagementNotInjected (  )  ;", "securityContext . setment ( securityManagement )  ;", "SecurityContextAssociation . setSecurityContext ( securityContext )  ;", "return   securityContext ;", "}    catch    ( Exception   e )     {", "throw   SecurityLogger . ROOT _ LOGGER . securityException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["establishSecurityContext"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "final   SecurityContext   securityContext    =    AccessController . doPrivileged ( securityContext (  )  )  ;", "if    ( securityContext    =  =    null )     {", "return   getUnauthenticatedIdentity (  )  . asPrincipal (  )  ;", "}", "Principal   principal    =    securityContext . getIncomingRunAs (  )  ;", "if    ( principal    =  =    null )", "principal    =    getPrincipal ( getSubjectInfo ( securityContext )  . getAuthenticatedSubject (  )  )  ;", "if    ( principal    =  =    null )", "return   getUnauthenticatedIdentity (  )  . asPrincipal (  )  ;", "return   principal ;", "}", "METHOD_END"], "methodName": ["getCallerPrincipal"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "Principal   principal    =    null ;", "Principal   callerPrincipal    =    null ;", "if    ( subject    !  =    null )     {", "Set < Principal >    principals    =    subject . getPrincipals (  )  ;", "if    (  ( principals    !  =    null )     &  &     (  !  ( principals . isEmpty (  )  )  )  )     {", "for    ( Principal   p    :    principals )     {", "if    (  (  !  ( p   instanceof   Group )  )     &  &     ( principal    =  =    null )  )     {", "principal    =    p ;", "}", "if    ( p   instanceof   Group )     {", "Group   g    =    Group . clacast ( p )  ;", "if    (  ( g . getName (  )  . equals (  \" CallerPrincipal \"  )  )     &  &     ( callerPrincipal    =  =    null )  )     {", "Enumeration <  ?    extends   Principal >    e    =    g . members (  )  ;", "if    ( e . hasMoreElements (  )  )", "callerPrincipal    =    e . nextElement (  )  ;", "}", "}", "}", "}", "}", "return   callerPrincipal    =  =    null    ?    principal    :    callerPrincipal ;", "}", "METHOD_END"], "methodName": ["getPrincipal"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "final   SecurityContext   securityContext    =    AccessController . doPrivileged ( securityContext (  )  )  ;", "if    ( securityContext    !  =    null )     {", "return   getSubjectInfo ( securityContext )  . getAuthenticatedSubject (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSubject"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   context . getSubjectInfo (  )  ;", "}", "return   AccessController . doPrivileged ( new   PrivilegedAction < SubjectInfo >  (  )     {", "@ Override", "public   SubjectInfo   run (  )     {", "return   context . getSubjectInfo (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getSubjectInfo"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleIdentity (  \" anonymous \"  )  ;", "}", "METHOD_END"], "methodName": ["getUnauthenticatedIdentity"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "final   SecurityContext   securityContext    =    AccessController . doPrivileged ( securityContext (  )  )  ;", "if    ( securityContext    =  =    null )     {", "return   false ;", "}", "final   EJBResource   resource    =    new   EJBResource ( new   HashMap < String ,    Object >  (  )  )  ;", "resource . setEjbName ( ejbName )  ;", "resource . setPolicyContextID ( policyContextID )  ;", "resource . setCallerRunAsIdentity ( securityContext . getIncomingRunAs (  )  )  ;", "resource . setCallerSubject ( securityContext . getUtil (  )  . getSubject (  )  )  ;", "Principal   userPrincipal    =    securityContext . getUtil (  )  . getUserPrincipal (  )  ;", "resource . setPrincipal ( userPrincipal )  ;", "if    ( roleLinks    !  =    null )     {", "final   Set < SecurityRoleRef >    roleRefs    =    new   HashSet < SecurityRoleRef >  (  )  ;", "for    ( String   key    :    roleLinks . keySet (  )  )     {", "Collection < String >    values    =    roleLinks . get ( key )  ;", "if    ( values    !  =    null )     {", "for    ( String   value    :    values )", "roleRefs . add ( new   SecurityRoleRef ( key ,    value )  )  ;", "}", "}", "resource . setSecurityRoleReferences ( roleRefs )  ;", "}", "Map < String ,    Set < String >  >    previousRolesAssociationMap    =    null ;", "try    {", "if    ( incommingMappedRoles    !  =    null )     {", "SecurityRolesMetaData   rolesMetaData    =     (  ( SecurityRolesMetaData )     ( incommingMappedRoles )  )  ;", "previousRolesAssociationMap    =    this . setSecurityRolesAssociation ( rolesMetaData . getPrincipalVersusRolesMap (  )  )  ;", "}", "AbstractEJBAuthorizationHelper   helper    =    SecurityHelperFactory . getEJBAuthorizationHelper ( securityContext )  ;", "for    ( String   roleName    :    roleNames )     {", "if    ( helper . isCallerInRole ( resource ,    roleName )  )     {", "return   true ;", "}", "}", "return   false ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}    finally    {", "if    ( incommingMappedRoles    !  =    null )     {", "this . setSecurityRolesAssociation ( previousRolesAssociationMap )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["isCallerInRole"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "final   SecurityContext   sc    =    contexts . pop (  )  ;", "SecurityContextAssociation . setSecurityContext ( sc )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "final   SecurityContext   previous    =    SecurityContextAssociation . getSecurityContext (  )  ;", "contexts . push ( previous )  ;", "SecurityContext   current    =    establishSecurityContext ( securityDomain )  ;", "if    (  ( propagate )     &  &     ( previous    !  =    null )  )     {", "current . setSubjectInfo ( getSubjectInfo ( previous )  )  ;", "if    (  ( previous . getOutgoingRunAs (  )  )     !  =    null )     {", "current . setIncomingRunAs ( previous . getOutgoingRunAs (  )  )  ;", "} else    {", "current . setIncomingRunAs ( previous . getIncomingRunAs (  )  )  ;", "}", "}", "RunAs   currentRunAs    =    current . getIncomingRunAs (  )  ;", "boolean   trusted    =     ( currentRunAs    !  =    null )     &  &     ( currentRunAs   instanceof   RunAsIdentity )  ;", "if    ( trusted    =  =    false )     {", "if    ( SecurityActions . remotingContextIsSet (  )  )     {", "SecurityContextUtil   util    =    current . getUtil (  )  ;", "RemoteConnection   connection    =    SecurityActions . remotingContextGetConnection (  )  ;", "Principal   p    =    null ;", "Object   credential    =    null ;", "SecurityIdentity   localIdentity    =    SecurityDomain . forIdentity ( connection . getSecurityIdentity (  )  )  . getCurrentSecurityIdentity (  )  ;", "if    ( localIdentity    !  =    null )     {", "p    =    new   jbosSimplePrincipal ( localIdentity . getPrincipal (  )  . getName (  )  )  ;", "IdentityCredentials   privateCredentials    =    localIdentity . getPrivateCredentials (  )  ;", "PasswordCredential   passwordCredential    =    privateCredentials . getCredential ( PasswordCredential . class ,    ALGORITHM _ CLEAR )  ;", "if    ( passwordCredential    !  =    null )     {", "credential    =    new   String ( passwordCredential . getPassword ( ClearPassword . class )  . getPassword (  )  )  ;", "} else    {", "credential    =    new   RemotingConnectionCredential ( connection ,    localIdentity )  ;", "}", "} else    {", "throw   SecurityLogger . ROOT _ LOGGER . noUserPrincipalFound (  )  ;", "}", "SecurityActions . remotingContextClear (  )  ;", "util . createSubjectInfo ( p ,    credential ,    null )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "final   SecurityContext   previous    =    SecurityContextAssociation . getSecurityContext (  )  ;", "contexts . push ( previous )  ;", "SecurityContext   current    =    establishSecurityContext ( securityDomain )  ;", "if    (  ( propagate )     &  &     ( previous    !  =    null )  )     {", "current . setSubjectInfo ( getSubjectInfo ( previous )  )  ;", "current . setIncomingRunAs ( previous . getOutgoingRunAs (  )  )  ;", "}", "RunAs   currentRunAs    =    current . getIncomingRunAs (  )  ;", "boolean   trusted    =     ( currentRunAs    !  =    null )     &  &     ( currentRunAs   instanceof   RunAsIdentity )  ;", "if    ( trusted    =  =    false )     {", "SecurityContextUtil   util    =    current . getUtil (  )  ;", "util . createSubjectInfo ( new   SimplePrincipal ( userName )  ,    new   String ( password )  ,    subject )  ;", "}", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "return   new   PrivilegedAction < SecurityContext >  (  )     {", "public   SecurityContext   run (  )     {", "return   SecurityContextAssociation . getSecurityContext (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["securityContext"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "securityManagement    =    iSecurityManagement ;", "}", "METHOD_END"], "methodName": ["setSecurityManagement"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "Map < String ,    Set < String >  >    previousMappedRoles    =    SecurityRolesAssociation . getSecurityRoles (  )  ;", "SecurityRolesAssociation . setSecurityRoles ( mappedRoles )  ;", "return   previousMappedRoles ;", "} else    {", ". SetSecurityRolesAssociationAction   action    =    new    . SetSecurityRolesAssociationAction ( mappedRoles )  ;", "return   AccessController . doPrivileged ( action )  ;", "}", "}", "METHOD_END"], "methodName": ["setSecurityRolesAssociation"], "fileName": "org.jboss.as.security.service.SimpleSecurityManager"}, {"methodBody": ["METHOD_START", "{", "SecurityContextAssociation . setSecurityContext ( orig )  ;", "}", "METHOD_END"], "methodName": ["after"], "fileName": "org.jboss.as.security.service.SimpleSecurityServiceManagerMockTest"}, {"methodBody": ["METHOD_START", "{", "orig    =    SecurityContextAssociation . getSecurityContext (  )  ;", "ISecurityManagement   delegate    =    mock ( ISecurityManagement . class )  ;", "simpleSecurityManager    =    new   Manager (  )  ;", "simpleSecurityManager . setSecurityManagement ( delegate )  ;", "}", "METHOD_END"], "methodName": ["before"], "fileName": "org.jboss.as.security.service.SimpleSecurityServiceManagerMockTest"}, {"methodBody": ["METHOD_START", "{", "RunAs   runAs 1     =    mock ( RunAs . class )  ;", "when ( runAs 1  . toString (  )  )  . thenReturn (  \" RunAs -  1  \"  )  ;", "RunAs   runAs 2     =    mock ( RunAs . class )  ;", "when ( runAs 2  . toString (  )  )  . thenReturn (  \" RunAs -  2  \"  )  ;", "testHandlingRunAs ( runAs 1  ,    runAs 2  )  ;", "testHandlingRunAs ( null ,    runAs 2  )  ;", "testHandlingRunAs ( runAs 1  ,    null )  ;", "testHandlingRunAs ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testHandlingRunAs"], "fileName": "org.jboss.as.security.service.SimpleSecurityServiceManagerMockTest"}, {"methodBody": ["METHOD_START", "{", "SecurityContext   context    =    mock ( SecurityContext . class )  ;", "if    ( outgoingRunAs    !  =    null )     {", "when ( context . getOutgoingRunAs (  )  )  . thenReturn ( outgoingRunAs )  ;", "}", "if    ( incomingRunAs    !  =    null )     {", "when ( context . getIncomingRunAs (  )  )  . thenReturn ( incomingRunAs )  ;", "}", "SecurityContextAssociation . setSecurityContext ( context )  ;", "sManager . push (  \" test \"  )  ;", "SecurityContext   result    =    SecurityContextAssociation . getSecurityContext (  )  ;", "if    ( outgoingRunAs    !  =    null )     {", "Assert . assertEquals (  \" RunAs   identity   has   to   be   same   as   previous   outgoing   RunAs .  \"  ,    outgoingRunAs ,    result . getIncomingRunAs (  )  )  ;", "} else", "if    ( incomingRunAs    !  =    null )     {", "Assert . assertEquals (  \" RunAs   identity   has   to   be   same   as   previous   incoming   RunAs .  \"  ,    incomingRunAs ,    result . getIncomingRunAs (  )  )  ;", "} else    {", "Assert . assertNull (  \" RunAs   identity   has   to   be   null .  \"  ,    result . getIncomingRunAs (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHandlingRunAs"], "fileName": "org.jboss.as.security.service.SimpleSecurityServiceManagerMockTest"}, {"methodBody": ["METHOD_START", "{", "return   securityManagementValue ;", "}", "METHOD_END"], "methodName": ["getSecurityManagementInjector"], "fileName": "org.jboss.as.security.service.SubjectFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   deque . get (  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.security.service.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "Object   o    =    st . peek (  )  ;", "if    ( o    =  =     (  . NULL _ VALUE )  )     {", "return   null ;", "} else    {", "return    (  ( E )     ( o )  )  ;", "}", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.jboss.as.security.service.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "Object   o    =    st . pop (  )  ;", "if    ( o    =  =     (  . NULL _ VALUE )  )     {", "return   null ;", "} else    {", "return    (  ( E )     ( o )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jboss.as.security.service.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Deque < Object >    st    =    deque . get (  )  ;", "if    ( item    =  =    null )     {", "st . push (  . NULL _ VALUE )  ;", "} else    {", "st . push ( item )  ;", "}", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jboss.as.security.service.ThreadLocalStack"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    vaultOptions    =    new   HashMap < String ,    Object >  ( options )  ;", "SecurityVault   vault    =    null ;", "try    {", "vault    =    AccessController . doPrivileged ( new   PrivilegedExceptionAction < SecurityVault >  (  )     {", "@ Override", "public   SecurityVault   run (  )    throws   Exception    {", "if    (  ( fqn    =  =    null )     |  |     ( fqn . isEmpty (  )  )  )     {", "return   SecurityVaultFactory . get (  )  ;", "} else    {", "return   SecurityVaultFactory . get ( fqn )  ;", "}", "}", "}  )  ;", "}    catch    ( PrivilegedActionException   e )     {", "Throwable   t    =    e . getCause (  )  ;", "if    ( t   instanceof   SecurityVaultException )     {", "throw   SecurityLogger . ROOT _ LOGGER . vException ( t )  ;", "}", "if    ( t   instanceof   RuntimeException )     {", "throw   SecurityLogger . ROOT _ LOGGER . runtimeException ( t )  ;", "}", "throw   SecurityLogger . ROOT _ LOGGER . runtimeException ( t )  ;", "}", "try    {", "vault . init ( vaultOptions )  ;", "}    catch    ( SecurityVaultException   e )     {", "e . printStackTrace (  )  ;", "throw   SecurityLogger . ROOT _ LOGGER . vException ( e )  ;", "}", "this . vault    =    vault ;", "}", "METHOD_END"], "methodName": ["createVault"], "fileName": "org.jboss.as.security.vault.MockRuntimeVaultReader"}, {"methodBody": ["METHOD_START", "{", "String [  ]    tokens    =    tokens ( tring )  ;", "return   retrieve ( tokens [  1  ]  ,    tokens [  2  ]  ,    tokens [  3  ]  . getBytes ( VaultSession . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.security.vault.MockRuntimeVaultReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    val    =    getValue ( vaultString )  ;", "if    ( val    !  =    null )", "return   new   String ( val )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getValueAsString"], "fileName": "org.jboss.as.security.vault.MockRuntimeVaultReader"}, {"methodBody": ["METHOD_START", "{", "return    ( str    !  =    null )     &  &     ( MockRuntimeVaultReader . VAULT _ PATTERN . matcher ( str )  . matches (  )  )  ;", "}", "METHOD_END"], "methodName": ["isVaultFormat"], "fileName": "org.jboss.as.security.vault.MockRuntimeVaultReader"}, {"methodBody": ["METHOD_START", "{", "if    ( isVaultFormat ( password )  )     {", "if    (  ( vault )     =  =    null )     {", "throw   SecurityLogger . ROOT _ LOGGER . vaultNotInitializedException (  )  ;", "}", "try    {", "return   getValueAsString ( password )  ;", "}    catch    ( SecurityVaultException   e )     {", "throw   SecurityLogger . ROOT _ LOGGERException ( e )  ;", "}", "}", "return   password ;", "}", "METHOD_END"], "methodName": ["retrieveFromVault"], "fileName": "org.jboss.as.security.vault.MockRuntimeVaultReader"}, {"methodBody": ["METHOD_START", "{", "StringTokenizer   tokenizer    =    new   StringTokenizer ( vaultString ,     \"  :  :  \"  )  ;", "int   length    =    tokenizer . countTokens (  )  ;", "String [  ]    tokens    =    new   String [ length ]  ;", "int   index    =     0  ;", "while    (  ( tokenizer    !  =    null )     &  &     ( tokenizer . hasMoreTokens (  )  )  )     {", "tokens [  ( index +  +  )  ]     =    tokenizer . nextToken (  )  ;", "}", "return   tokens ;", "}", "METHOD_END"], "methodName": ["tokens"], "fileName": "org.jboss.as.security.vault.MockRuntimeVaultReader"}, {"methodBody": ["METHOD_START", "{", "Console   console    =    System . console (  )  ;", "if    ( console    =  =    null )     {", "System . err . println ( SecurityLogger . ROOT _ LOGGER . noConsole (  )  )  ;", "System . exit (  1  )  ;", "}", "Scanner   in    =    new   Scanner ( System . in )  ;", "while    ( true )     {", "String   commandStr    =    SecurityLogger . ROOT _ LOGGER . interactionCommandOptions (  )  ;", "System . out . println ( commandStr )  ;", "int   choice    =    in . nextInt (  )  ;", "switch    ( choice )     {", "case    0     :", "System . out . println ( SecurityLogger . ROOT _ LOGGER . taskStoreSecuredAttribute (  )  )  ;", "char [  ]    attributeValue    =    veSession . getSensitiveValue ( SecurityLogger . ROOT _ LOGGER . interactivePromptSecureAttributeValue (  )  ,    SecurityLogger . ROOT _ LOGGER . interactivePromptSecureAttributeValueAgain (  )  )  ;", "String   vaultBlock    =    null ;", "while    (  ( vaultBlock    =  =    null )     |  |     (  ( vaultBlock . length (  )  )     =  =     0  )  )     {", "vaultBlock    =    console . readLine ( SecurityLogger . ROOT _ LOGGER . interactivePromptVaultBlock (  )  )  ;", "}", "String   attributeName    =    null ;", "while    (  ( attributeName    =  =    null )     |  |     (  ( attributeName . length (  )  )     =  =     0  )  )     {", "attributeName    =    console . readLine ( SecurityLogger . ROOT _ LOGGER . interactivePromptAttributeName (  )  )  ;", "}", "try    {", "vaultNISession . addSecuredAttributeWithDisplay ( vaultBlock ,    attributeName ,    attributeValue )  ;", "}    catch    ( Exception   e )     {", "System . out . println (  (  (  ( SecurityLogger . ROOT _ LOGGER . problemOcurred (  )  )     +     \"  \\ n \"  )     +     ( e . getLocalizedMessage (  )  )  )  )  ;", "}", "break ;", "case    1     :", "System . out . println ( SecurityLogger . ROOT _ LOGGER . taskVerifySecuredAttributeExists (  )  )  ;", "try    {", "vaultBlock    =    null ;", "while    (  ( vaultBlock    =  =    null )     |  |     (  ( vaultBlock . length (  )  )     =  =     0  )  )     {", "vaultBlock    =    console . readLine ( SecurityLogger . ROOT _ LOGGER . interactivePromptVaultBlock (  )  )  ;", "}", "attributeName    =    null ;", "while    (  ( attributeName    =  =    null )     |  |     (  ( attributeName . length (  )  )     =  =     0  )  )     {", "attributeName    =    console . readLine ( SecurityLogger . ROOT _ LOGGER . interactivePromptAttributeName (  )  )  ;", "}", "if    (  !  ( vaultNISession . checkSecuredAttribute ( vaultBlock ,    attributeName )  )  )     {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . interactiveMessageNoValueStored ( VaultSession . blockAttributeDisplayFormat ( vaultBlock ,    attributeName )  )  )  ;", "} else    {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . interactiveMessageValueStored ( VaultSession . blockAttributeDisplayFormat ( vaultBlock ,    attributeName )  )  )  ;", "}", "}    catch    ( Exception   e )     {", "System . out . println (  (  (  ( SecurityLogger . ROOT _ LOGGER . problemOcurred (  )  )     +     \"  \\ n \"  )     +     ( e . getLocalizedMessage (  )  )  )  )  ;", "}", "break ;", "case    2     :", "System . out . println ( SecurityLogger . ROOT _ LOGGER . taskRemoveSecuredAttribute (  )  )  ;", "try    {", "vaultBlock    =    null ;", "while    (  ( vaultBlock    =  =    null )     |  |     (  ( vaultBlock . length (  )  )     =  =     0  )  )     {", "vaultBlock    =    console . readLine ( SecurityLogger . ROOT _ LOGGER . interactivePromptVaultBlock (  )  )  ;", "}", "attributeName    =    null ;", "while    (  ( attributeName    =  =    null )     |  |     (  ( attributeName . length (  )  )     =  =     0  )  )     {", "attributeName    =    console . readLine ( SecurityLogger . ROOT _ LOGGER . interactivePromptAttributeName (  )  )  ;", "}", "if    (  !  ( vaultNISession . removeSecuredAttribute ( vaultBlock ,    attributeName )  )  )     {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . messageAttributeNotRemoved ( VaultSession . blockAttributeDisplayFormat ( vaultBlock ,    attributeName )  )  )  ;", "} else    {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . messageAttributeRemovedSuccessfuly ( VaultSession . blockAttributeDisplayFormat ( vaultBlock ,    attributeName )  )  )  ;", "}", "}    catch    ( Exception   e )     {", "System . out . println (  (  (  ( SecurityLogger . ROOT _ LOGGER . problemOcurred (  )  )     +     \"  \\ n \"  )     +     ( e . getLocalizedMessage (  )  )  )  )  ;", "}", "break ;", "default    :", "in . close (  )  ;", "System . exit (  0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.security.vault.VaultInteraction"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "if    ( passwordPrompt    =  =    null )", "passwordPrompt    =    SLogger . ROOT _ LOGGER . enterYourPassword (  )  ;", "if    ( confirmationPrompt    =  =    null )     {", "confirmationPrompt    =    SLogger . ROOT _ LOGGER . enterYourPasswordAgain (  )  ;", "}", "Console   console    =    System . console (  )  ;", "char [  ]    passwd    =    console . readPassword (  ( passwordPrompt    +     \"     \"  )  )  ;", "char [  ]    passwd 1     =    console . readPassword (  ( confirmationPrompt    +     \"     \"  )  )  ;", "boolean   noMatch    =     !  ( Arrays . equals ( passwd ,    passwd 1  )  )  ;", "if    ( noMatch )", "System . out . println ( SLogger . ROOT _ LOGGER . passwordsDoNotMatch (  )  )  ;", "else    {", "System . out . println ( SLogger . ROOT _ LOGGER . passwordsMatch (  )  )  ;", "return   passwd ;", "}", "}", "}", "METHOD_END"], "methodName": ["getSensitiveValue"], "fileName": "org.jboss.as.security.vault.VaultInteractiveSession"}, {"methodBody": ["METHOD_START", "{", "Console   console    =    System . console (  )  ;", "if    ( console    =  =    null )     {", "System . err . println ( SecurityLogger . ROOT _ LOGGER . noConsole (  )  )  ;", "System . exit (  1  )  ;", "}", "while    (  (  ( encDir )     =  =    null )     |  |     (  ( encDir . length (  )  )     =  =     0  )  )     {", "encDir    =    console . readLine (  (  ( SecurityLogger . ROOT _ LOGGER . enterEncryptionDirectory (  )  )     +     \"     \"  )  )  ;", "}", "while    (  (  ( keystoreURL )     =  =    null )     |  |     (  ( keystoreURL . length (  )  )     =  =     0  )  )     {", "keystoreURL    =    console . readLine (  (  ( SecurityLogger . ROOT _ LOGGER . enterKeyStoreURL (  )  )     +     \"     \"  )  )  ;", "}", "char [  ]    keystorePasswd    =     . getSensitiveValue ( SecurityLogger . ROOT _ LOGGER . enterKeyStorePassword (  )  ,    SecurityLogger . ROOT _ LOGGER . enterKeyStorePasswordAgain (  )  )  ;", "try    {", "while    (  (  ( salt )     =  =    null )     |  |     (  ( salt . length (  )  )     !  =     8  )  )     {", "salt    =    console . readLine (  (  ( SecurityLogger . ROOT _ LOGGER . enterSalt (  )  )     +     \"     \"  )  )  ;", "}", "String   ic    =    console . readLine (  (  ( SecurityLogger . ROOT _ LOGGER . enterIterationCount (  )  )     +     \"     \"  )  )  ;", "iterationCount    =    Integer . parseInt ( ic )  ;", "vaultNISession    =    new   VaultSession ( keystoreURL ,    new   String ( keystorePasswd )  ,    encDir ,    salt ,    iterationCount ,    true )  ;", "while    (  (  ( keystoreAlias )     =  =    null )     |  |     (  ( keystoreAlias . length (  )  )     =  =     0  )  )     {", "keystoreAlias    =    console . readLine (  (  ( SecurityLogger . ROOT _ LOGGER . enterKeyStoreAlias (  )  )     +     \"     \"  )  )  ;", "}", "System . out . println ( SecurityLogger . ROOT _ LOGGER . initializingVault (  )  )  ;", "vaultNISession . startVaultSession ( keystoreAlias )  ;", "vaultNISession . vaultConfigurationDisplay (  )  ;", "System . out . println ( SecurityLogger . ROOT _ LOGGER . vaultInitialized (  )  )  ;", "System . out . println ( SecurityLogger . ROOT _ LOGGER . handshakeComplete (  )  )  ;", "VaultInteraction   vaultInteraction    =    new   VaultInteraction ( vaultNISession )  ;", "vaultInteraction . start (  )  ;", "}    catch    ( Exception   e )     {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . exceptionEncountered (  )  )  ;", "e . printStackTrace ( System . err )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.security.vault.VaultInteractiveSession"}, {"methodBody": ["METHOD_START", "{", "vault . store ( vaultBlock ,    attributeName ,    attributeValue ,    null )  ;", "return   securedAttributeConfigurationString ( vaultBlock ,    attributeName )  ;", "}", "METHOD_END"], "methodName": ["addSecuredAttribute"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "vault . store ( vaultBlock ,    attributeName ,    attributeValue ,    null )  ;", "attributeCreatedDisplay ( vaultBlock ,    attributeName )  ;", "}", "METHOD_END"], "methodName": ["addSecuredAttributeWithDisplay"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( SecurityLogger . ROOT _ LOGGER . vaultAttributeCreateDisplay ( vaultBlock ,    attributeName ,    securedAttributeConfigurationString ( vaultBlock ,    attributeName )  )  )  ;", "}", "METHOD_END"], "methodName": ["attributeCreatedDisplay"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \"  [  \"     +    vaultBlock )     +     \"  :  :  \"  )     +    attributeName )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["blockAttributeDisplayFormat"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "return   vault . exists ( vaultBlock ,    attributeName )  ;", "}", "METHOD_END"], "methodName": ["checkSecuredAttribute"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "SecretKeyFactory   factory    =    SecretKeyFactory . getInstance ( VaultSession . VAULT _ ENC _ ALGORITHM )  ;", "char [  ]    password    =     \" somearbitrarycrazystringthatdoesnotmatter \"  . toCharArray (  )  ;", "PBEParameterSpec   cipherSpec    =    new   PBEParameterSpec ( salt . getBytes (  )  ,    iterationCount )  ;", "PBEKeySpec   keySpec    =    new   PBEKeySpec ( password )  ;", "SecretKey   cipherKey    =    factory . generateSecret ( keySpec )  ;", "String   maskedPass    =    PBEUtils . encode 6  4  ( keystorePassword . getBytes (  )  ,    VaultSession . VAULT _ ENC _ ALGORITHM ,    cipherKey ,    cipherSpec )  ;", "return    ( PicketBoxSecurityVault . PASS _ MASK _ PREFIX )     +    maskedPass ;", "}", "METHOD_END"], "methodName": ["computeMaskedPassword"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "return   keystoreMaskedPassword ;", "}", "METHOD_END"], "methodName": ["getKeystoreMaskedPassword"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    options    =    new   HashMap < String ,    Object >  (  )  ;", "options . put ( KEYSTORE _ URL ,    keystoreURL )  ;", "options . put ( KEYSTORE _ PASSWORD ,    keystoreMaskedPassword )  ;", "options . put ( KEYSTORE _ ALIAS ,    Alias )  ;", "options . put ( SALT ,    salt )  ;", "options . put ( ITERATION _ COUNT ,    Integer . toString ( iterationCount )  )  ;", "options . put ( ENC _ FILE _ DIR ,    encryptionDirectory )  ;", "if    (  ( createKeystore )     &  &     (  !  ( new   File ( keystoreURL )  . exists (  )  )  )  )     {", "options . put ( CREATE _ KEYSTORE ,    Boolean . toString ( createKeystore )  )  ;", "}", "return   options ;", "}", "METHOD_END"], "methodName": ["getVaultOptionsMap"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    handshakeOptions    =    new   HashMap < String ,    Object >  (  )  ;", "handshakeOptions . put ( PUBLIC _ CERT ,    lias )  ;", "handshake ( handshakeOptions )  ;", "}", "METHOD_END"], "methodName": ["handshake"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . vault    =    SecurityVaultFactory . get (  )  ;", "this . vault . init ( getVaultOptionsMap (  )  )  ;", "handshake (  )  ;", "}    catch    ( SecurityVaultException   e )     {", "throw   SecurityLogger . ROOT _ LOGGERVaultException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["initSecurityVault"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "return   vault . remove ( vaultBlock ,    attributeName ,    null )  ;", "}", "METHOD_END"], "methodName": ["removeSecuredAttribute"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "return   vault . retrieve ( vaultBlock ,    attributeName ,    null )  ;", "}", "METHOD_END"], "methodName": ["retrieveSecuredAttribute"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" VAULT :  :  \"     +    vaultBlock )     +     \"  :  :  \"  )     +    attributeName )     +     \"  :  :  1  \"  ;", "}", "METHOD_END"], "methodName": ["securedAttributeConfigurationString"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "if    ( vaultAlias    =  =    null )     {", "throw   SLogger . ROOT _ LOGGER . vaultAliasNotSpecified (  )  ;", "}", "this . keystoreMaskedPassword    =     ( Util . isPasswordCommand ( keystorePassword )  )     ?    keystorePassword    :    computeMaskedPassword (  )  ;", "this . vaultAlias    =    vaultAlias ;", "initSVault (  )  ;", "}", "METHOD_END"], "methodName": ["startVaultSession"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "validateKeystoreURL (  )  ;", "validateEncryptDirectory (  )  ;", "validateSalt (  )  ;", "validateIteratCount (  )  ;", "validateKeystorePassword (  )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "if    (  ( encryptionDirectory )     =  =    null )     {", "throw   new   Exception (  \" Encryption   directory   has   to   be   specified .  \"  )  ;", "}", "if    (  (  !  ( encryptionDirectory . endsWith (  \"  /  \"  )  )  )     |  |     ( encryptionDirectory . endsWith (  \"  \\  \\  \"  )  )  )     {", "encryptionDirectory    =     ( encryptionDirectory )     +     \"  /  \"  ;", "}", "File   d    =    new   File ( encryptionDirectory )  ;", "if    (  !  ( d . exists (  )  )  )     {", "if    (  !  ( d . mkdirs (  )  )  )     {", "throw   SLogger . ROOT _ LOGGER . cannotCreateEncryptionDirectory ( d . getAbsolutePath (  )  )  ;", "}", "}", "if    (  !  ( d . isDirectory (  )  )  )     {", "throw   SLogger . ROOT _ LOGGER . encryptionDirectoryDoesNotExist ( encryptionDirectory )  ;", "}", "}", "METHOD_END"], "methodName": ["validateEncryptionDirectory"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( iterationCount )     <     1  )     &  &     (  ( iterationCount )     >     ( Integer . MAX _ VALUE )  )  )     {", "throw   SLogger . ROOT _ LOGGER . iterationCountOutOfRange ( String . valueOf ( iterationCount )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateIterationCount"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keystorePassword )     =  =    null )     {", "throw   SLogger . ROOT _ LOGGER . keyStorePasswordNotSpecified (  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateKeystorePassword"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "File   f    =    new   File ( keystoreURL )  ;", "if    (  !  ( f . exists (  )  )  )     {", "if    (  !  ( createKeystore )  )     {", "throw   SLogger . ROOT _ LOGGER . keyStoreDoesnotExistWithExample ( keystoreURL ,    keystoreURL )  ;", "}", "} else", "if    (  (  !  ( f . canWrite (  )  )  )     |  |     (  !  ( f . isFile (  )  )  )  )     {", "throw   SLogger . ROOT _ LOGGER . keyStoreNotWritable ( keystoreURL )  ;", "}", "}", "METHOD_END"], "methodName": ["validateKeystoreURL"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( salt )     =  =    null )     |  |     (  ( salt . length (  )  )     !  =     8  )  )     {", "throw   SLogger . ROOT _ LOGGER . saltWrongLength (  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateSalt"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \"  / core - service =  : add (  - options =  [  \"  )  ;", "sb . append (  \"  (  \\  \" KEYSTORE _ URL \\  \"     =  >     \\  \"  \"  )  . append ( keystoreURL )  . append (  \"  \\  \"  )  \"  )  . append (  \"  ,  \"  )  ;", "sb . append (  \"  (  \\  \" KEYSTORE _ PASSWORD \\  \"     =  >     \\  \"  \"  )  . append ( keystoreMaskedPassword )  . append (  \"  \\  \"  )  \"  )  . append (  \"  ,  \"  )  ;", "sb . append (  \"  (  \\  \" KEYSTORE _ ALIAS \\  \"     =  >     \\  \"  \"  )  . append ( Alias )  . append (  \"  \\  \"  )  \"  )  . append (  \"  ,  \"  )  ;", "sb . append (  \"  (  \\  \" SALT \\  \"     =  >     \\  \"  \"  )  . append ( salt )  . append (  \"  \\  \"  )  \"  )  . append (  \"  ,  \"  )  ;", "sb . append (  \"  (  \\  \" ITERATION _ COUNT \\  \"     =  >     \\  \"  \"  )  . append ( iterationCount )  . append (  \"  \\  \"  )  \"  )  . append (  \"  ,  \"  )  ;", "sb . append (  \"  (  \\  \" ENC _ FILE _ DIR \\  \"     =  >     \\  \"  \"  )  . append ( encryptionDirectory )  . append (  \"  \\  \"  )  \"  )  ;", "sb . append (  \"  ]  )  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["vaultConfiguration"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "final   String   configuration    =    vaultConfiguration (  )  ;", "System . out . println ( SLogger . ROOT _ LOGGER . vaultConfigurationTitle (  )  )  ;", "System . out . println (  \"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  \"  )  ;", "System . out . println (  \" For   standalone   mode :  \"  )  ;", "System . out . println ( configuration )  ;", "System . out . println (  \"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  \"  )  ;", "System . out . println (  \" For   domain   mode :  \"  )  ;", "System . out . println (  (  \"  / host = the _ host \"     +    configuration )  )  ;", "System . out . println (  \"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["vaultConfigurationDisplay"], "fileName": "org.jboss.as.security.vault.VaultSession"}, {"methodBody": ["METHOD_START", "{", "VaultTest . cleanDirectory ( VaultTest . ENC _ FILE _ DIR _ VALUE )  ;", "System . setSManager ( new   VaultTest . NoExitSManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.jboss.as.security.vault.VaultSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setSecurityManager ( null )  ;", "VaultTest . cleanDirectory ( VaultTest . ENC _ FILE _ DIR _ VALUE )  ;", "File   keyStoreFile    =    new   File ( VaultTest . KEYSTORE _ URL _ VALUE )  ;", "if    ( keyStoreFile . exists (  )  )     {", "keyStoreFile . delete (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.jboss.as.security.vault.VaultSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "final   String   expectedCommand    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  / core - service = vault : add ( vault - options =  [  (  \\  \" KEYSTORE _ URL \\  \"     =  >     \\  \"  \"     +     ( VaultTest . KEYSTORE _ URL _ VALUE )  )     +     \"  \\  \"  )  ,  \"  )     +     \"  (  \\  \" KEYSTORE _ PASSWORD \\  \"     =  >     \\  \"  \"  )     +     ( VaultTest . MASKED _ MYPASSWORD _ VALUE )  )     +     \"  \\  \"  )  ,  (  \\  \" KEYSTORE _ ALIAS \\  \"     =  >     \\  \"  \"  )     +     ( VaultTest . KEYSTORE _ ALIAS _ VALUE )  )     +     \"  \\  \"  )  ,  \"  )     +     \"  (  \\  \" SALT \\  \"     =  >     \\  \"  \"  )     +     ( VaultTest . SALT _ VALUE )  )     +     \"  \\  \"  )  ,  (  \\  \" ITERATION _ COUNT \\  \"     =  >     \\  \"  \"  )     +     ( VaultTest . ITERATION _ COUNT _ VALUE )  )     +     \"  \\  \"  )  ,  \"  )     +     \"  (  \\  \" ENC _ FILE _ DIR \\  \"     =  >     \\  \"  \"  )     +     ( VaultTest . ENC _ FILE _ DIR _ VALUE )  )     +     \"  /  \\  \"  )  ]  )  \"  ;", "vaultSession    =    null ;", "try    {", "vaultSession    =    new    ( VaultTest . KEYSTORE _ URL _ VALUE ,    VaultTest . KEYSTORE _ PASSWORD ,    VaultTest . ENC _ FILE _ DIR _ VALUE ,    VaultTest . SALT _ VALUE ,    Integer . valueOf ( VaultTest . ITERATION _ COUNT _ VALUE )  ,    true )  ;", "vaultSession . start ( VaultTest . KEYSTORE _ ALIAS _ VALUE )  ;", "}    catch    ( Exception   e )     {", "Assert . fail (  (  \" Failed   while   initializing   vault   session   with   exception    \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "Assert . assertEquals ( expectedCommand ,    vaultSession . vaultConfiguration (  )  )  ;", "}", "METHOD_END"], "methodName": ["testVaultConfiguration"], "fileName": "org.jboss.as.security.vault.VaultSessionTestCase"}, {"methodBody": ["METHOD_START", "{", "File   directory    =    new   File ( dir )  ;", "if    ( directory . exists (  )  )     {", "for    ( File   f    :    directory . listFiles (  )  )     {", "f . delete (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["cleanDirectory"], "fileName": "org.jboss.as.security.vault.VaultTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   String (  (  ( URLDecoder . decode (  . CODE _ LOCATION ,     \" UTF -  8  \"  )  )     +     \" org / jboss / as / security / vault . keystore \"  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   Error (  \" Unable   to   decode   url \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getKeystorePath"], "fileName": "org.jboss.as.security.vault.VaultTest"}, {"methodBody": ["METHOD_START", "{", "if    ( cmdLine . hasOption ( VaultTool . HELP _ PARAM )  )     {", "printUsage (  )  ;", "return    1  0  0  ;", "}", "String   keystoreURL    =    cmdLine . getOptionValue ( VaultTool . KEYSTORE _ PARAM ,     \" vault . keystore \"  )  ;", "String   keystorePassword    =    cmdLine . getOptionValue ( VaultTool . KEYSTORE _ PASSWORD _ PARAM ,     \"  \"  )  ;", "String   encryptionDirectory    =    cmdLine . getOptionValue ( VaultTool . ENC _ DIR _ PARAM ,     \" vault \"  )  ;", "String   salt    =    cmdLine . getOptionValue ( VaultTool . SALT _ PARAM ,     \"  1  2  3  4  5  6  7  8  \"  )  ;", "int   iterationCount    =    Integer . parseInt ( cmdLine . getOptionValue ( VaultTool . ITERATION _ PARAM ,     \"  2  3  \"  )  )  ;", "boolean   createKeyStore    =    cmdLine . hasOption ( VaultTool . CREATE _ KEYSTORE _ PARAM )  ;", "nonInteractiveSession    =    new   VaultSession ( keystoreURL ,    keystorePassword ,    encryptionDirectory ,    salt ,    iterationCount ,    createKeyStore )  ;", "nonInteractiveSession . startVaultSession ( cmdLine . getOptionValue (  \" alias \"  ,     \" vault \"  )  )  ;", "String   vaultBlock    =    cmdLine . getOptionValue ( VaultTool . VAULT _ BLOCK _ PARAM ,     \" vb \"  )  ;", "String   attributeName    =    cmdLine . getOptionValue ( VaultTool . ATTRIBUTE _ PARAM ,     \" password \"  )  ;", "if    ( cmdLine . hasOption ( VaultTool . CHECK _ SEC _ ATTR _ EXISTS _ PARAM )  )     {", "if    ( nonInteractiveSession . checkSecuredAttribute ( vaultBlock ,    attributeName )  )     {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . cmdLineSecuredAttributeAlreadyExists (  )  )  ;", "return    0  ;", "} else    {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . cmdLineSecuredAttributeDoesNotExist (  )  )  ;", "return    5  ;", "}", "}", "if    ( cmdLine . hasOption ( VaultTool . REMOVE _ SEC _ ATTR _ PARAM )  )     {", "if    ( nonInteractiveSession . removeSecuredAttribute ( vaultBlock ,    attributeName )  )     {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . messageAttributeRemovedSuccessfuly ( VaultSession . blockAttributeDisplayFormat ( vaultBlock ,    attributeName )  )  )  ;", "return    0  ;", "} else    {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . messageAttributeNotRemoved ( VaultSession . blockAttributeDisplayFormat ( vaultBlock ,    attributeName )  )  )  ;", "return    6  ;", "}", "} else", "if    ( cmdLine . hasOption ( VaultTool . SEC _ ATTR _ VALUE _ PARAM )  )     {", "String   password    =    cmdLine . getOptionValue ( VaultTool . SEC _ ATTR _ VALUE _ PARAM ,     \" password \"  )  ;", "nonInteractiveSession . addSecuredAttributeWithDisplay ( vaultBlock ,    attributeName ,    password . toCharArray (  )  )  ;", "summary (  )  ;", "return    0  ;", "} else    {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . actionNotSpecified (  )  )  ;", "return    -  1  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "return   session ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "options    =    new   Options (  )  ;", "options . addOption (  \" k \"  ,     . KEYSTORE _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineKeyStoreURL (  )  )  ;", "options . addOption (  \" p \"  ,     . KEYSTORE _ PASSWORD _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineKeyStorePassword (  )  )  ;", "options . addOption (  \" e \"  ,     . ENC _ DIR _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineEncryptionDirectory (  )  )  ;", "options . addOption (  \" s \"  ,     . SALT _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineSalt (  )  )  ;", "options . addOption (  \" i \"  ,     . ITERATION _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineIterationCount (  )  )  ;", "options . addOption (  \" v \"  ,     . ALIAS _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineVaultKeyStoreAlias (  )  )  ;", "options . addOption (  \" b \"  ,     . VAULT _ BLOCK _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineVaultBlock (  )  )  ;", "options . addOption (  \" a \"  ,     . ATTRIBUTE _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineAttributeName (  )  )  ;", "options . addOption (  \" t \"  ,     . CREATE _ KEYSTORE _ PARAM ,    false ,    SecurityLogger . ROOT _ LOGGER . cmdLineAutomaticallyCreateKeystore (  )  )  ;", "OptionGroup   og    =    new   OptionGroup (  )  ;", "Option   x    =    new   Option (  \" x \"  ,     . SEC _ ATTR _ VALUE _ PARAM ,    true ,    SecurityLogger . ROOT _ LOGGER . cmdLineSecuredAttribute (  )  )  ;", "Option   c    =    new   Option (  \" c \"  ,     . CHECK _ SEC _ ATTR _ EXISTS _ PARAM ,    false ,    SecurityLogger . ROOT _ LOGGER . cmdLineCheckAttribute (  )  )  ;", "Option   r    =    new   Option (  \" r \"  ,     . REMOVE _ SEC _ ATTR _ PARAM ,    false ,    SecurityLogger . ROOT _ LOGGER . cmdLineRemoveSecuredAttribute (  )  )  ;", "Option   h    =    new   Option (  \" h \"  ,     . HELP _ PARAM ,    false ,    SecurityLogger . ROOT _ LOGGER . cmdLineHelp (  )  )  ;", "og . addOption ( x )  ;", "og . addOption ( c )  ;", "og . addOption ( r )  ;", "og . addOption ( h )  ;", "og . setRequired ( true )  ;", "options . addOptionGroup ( og )  ;", "}", "METHOD_END"], "methodName": ["initOptions"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "String   opsys    =    System . getProperty (  \" os . name \"  )  . toLowerCase (  )  ;", "return    ( opsys . indexOf (  \" win \"  )  )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["isWindows"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "VaultTool   tool    =    null ;", "if    (  ( args    !  =    null )     &  &     (  ( args . length )     >     0  )  )     {", "int   returnVal    =     0  ;", "try    {", "tool    =    new   VaultTool ( args )  ;", "returnVal    =    tool . execute (  )  ;", "}    catch    ( Exception   e )     {", "System . err . println ( SecurityLogger . ROOT _ LOGGER . problemOcurred (  )  )  ;", "e . printStackTrace ( System . err )  ;", "System . exit (  1  )  ;", "}", "System . exit ( returnVal )  ;", "} else    {", "tool    =    new   VaultTool (  )  ;", "System . out . println (  \"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  \"  )  ;", "System . out . println (  \"  *  *  *  *       JBoss   Vault       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  \"  )  ;", "System . out . println (  \"  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  \"  )  ;", "Console   console    =    System . console (  )  ;", "if    ( console    =  =    null )     {", "System . err . println ( SecurityLogger . ROOT _ LOGGER . noConsole (  )  )  ;", "System . exit (  1  )  ;", "}", "Scanner   in    =    new   Scanner ( System . in )  ;", "while    ( true )     {", "System . out . println ( SecurityLogger . ROOT _ LOGGER . interactiveCommandString (  )  )  ;", "try    {", "int   choice    =    in . nextInt (  )  ;", "switch    ( choice )     {", "case    0     :", "System . out . println ( SecurityLogger . ROOT _ LOGGER . startingInteractiveSession (  )  )  ;", "VaultInteractiveSession   vsession    =    new   VaultInteractiveSession (  )  ;", "tool . setSession ( vsession )  ;", "vsession . start (  )  ;", "break ;", "case    1     :", "System . out . println ( SecurityLogger . ROOT _ LOGGER . removingInteractiveSession (  )  )  ;", "tool . setSession ( null )  ;", "break ;", "default    :", "in . close (  )  ;", "System . exit (  0  )  ;", "}", "}    catch    ( InputMismatchException   e )     {", "in . close (  )  ;", "System . exit (  0  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "HelpFormatter   help    =    new   HelpFormatter (  )  ;", "String   suffix    =     (  . isWindows (  )  )     ?     \"  . bat \"     :     \"  . sh \"  ;", "help . printHelp (  (  (  \" vault \"     +    suffix )     +     \"     < empty >     |     \"  )  ,    options ,    true )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "session    =    sess ;", "}", "METHOD_END"], "methodName": ["setSession"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "nonInteractiveSession . vaultConfigurationDisplay (  )  ;", "}", "METHOD_END"], "methodName": ["summary"], "fileName": "org.jboss.as.security.vault.VaultTool"}, {"methodBody": ["METHOD_START", "{", "KeyStore   ks    =    KeyStore . getInstance (  \" JCEKS \"  )  ;", "ks . load ( null ,    est . KEYSTORE _ PASSWORD . toCharArray (  )  )  ;", "KeyGenerator   keyGenerator    =    KeyGenerator . getInstance (  \" AES \"  )  ;", "keyGenerator . init (  1  2  8  )  ;", "SecretKey   secretKey    =    keyGenerator . generateKey (  )  ;", "KeyStore . SecretKeyEntry   skEntry    =    new   KeyStore . SecretKeyEntry ( secretKey )  ;", "KeyStore . PasswordProtection   p    =    new   KeyStore . PasswordProtection ( est . KEYSTORE _ PASSWORD . toCharArray (  )  )  ;", "ks . setEntry ( est . KEYSTORE _ ALIAS _ VALUE ,    skEntry ,    p )  ;", "ks . store ( new   FileOutputStream ( fileName )  ,    est . KEYSTORE _ PASSWORD . toCharArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["createAndFillKeystore"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( prepareKeystore )     {", ". createAndFillKeystore ( VaultTest . KEYSTORE _ URL _ VALUE )  ;", "}", "System . setOut ( new   PrintStream ( VaultTest . SYSTEM _ OUT )  )  ;", "try    {", "String [  ]    args    =    generateArgs (  )  ;", "VaultTool . main ( args )  ;", "}    catch    ( VaultTest . ExitException   e )     {", "Assert . assertEquals (  \" Exit   status   is   equal   to    0  \"  ,     0  ,    e . status )  ;", "}", "VaultTest . SYSTEM _ OUT . flush (  )  ;", "String   ouput    =    new   String ( VaultTest . SYSTEM _ OUT . toByteArray (  )  )  ;", "String [  ]    outputLines    =    ouput . split (  \"  \\ n \"  )  ;", "String   vaultSharedKey    =    getStoredAttributeSharedKey ( outputLines )  ;", "Assert . assertNotNull (  \" VaultTool   did   not   return   a   line   starting   with   VAULT :  :  \"  ,    vaultSharedKey )  ;", "MockRuntimeVaultReader   rvr    =    new   MockRuntimeVaultReader (  )  ;", "Map < String ,    Object >    options    =    generateVaultOptionsMap ( testFallbackFromIncorrectPasswordValue )  ;", "rvr . createVault (  \"  \"  ,    options )  ;", "String   retrievedValueFromVault    =    rvr . retrieveFromVault ( vaultSharedKey )  ;", "Assert . assertEquals (  \" The   value   retrieved   from   vault   is   not   the   same   as   the   one   initially   stored \"  ,    VaultTest . VALUE _ TO _ STORE ,    retrievedValueFromVault )  ;", "}", "METHOD_END"], "methodName": ["doTestVaultTool"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "List < String >    args    =    new   ArrayList < String >  (  )  ;", "Collections . addAll ( args ,     \"  - k \"  ,    est . KEYSTORE _ URL _ VALUE )  ;", "Collections . addAll ( args ,     \"  - p \"  ,    est . KEYSTORE _ PASSWORD )  ;", "Collections . addAll ( args ,     \"  - e \"  ,    est . ENC _ FILE _ DIR _ VALUE )  ;", "Collections . addAll ( args ,     \"  - s \"  ,    est . SALT _ VALUE )  ;", "Collections . addAll ( args ,     \"  - i \"  ,    est . ITERATION _ COUNT _ VALUE )  ;", "Collections . addAll ( args ,     \"  - b \"  ,    est . BLOCK _ NAME )  ;", "Collections . addAll ( args ,     \"  - a \"  ,    est . ATTRIBUTE _ NAME )  ;", "Collections . addAll ( args ,     \"  - x \"  ,    est . VALUE _ TO _ STORE )  ;", "Collections . addAll ( args ,     \"  - t \"  )  ;", "return   args . toArray ( new   String [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["generateArgs"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    options    =    new   HashMap < String ,    Object >  (  )  ;", "options . put (  \" KEYSTORE _ URL \"  ,    est . KEYSTORE _ URL _ VALUE )  ;", "if    ( testFallbackFromIncorrectPasswordValue )     {", "options . put (  \" KEYSTORE _ PASSWORD \"  ,    est . MASKED _ MYPASSWORD _ VALUE _ INCORRECT )  ;", "} else    {", "options . put (  \" KEYSTORE _ PASSWORD \"  ,    est . MASKED _ MYPASSWORD _ VALUE )  ;", "}", "options . put (  \" SALT \"  ,    est . SALT _ VALUE )  ;", "options . put (  \" ITERATION _ COUNT \"  ,    est . ITERATION _ COUNT _ VALUE )  ;", "options . put (  \" KEYSTORE _ ALIAS \"  ,    est . KEYSTORE _ ALIAS _ VALUE )  ;", "options . put (  \" ENC _ FILE _ DIR \"  ,    est . ENC _ FILE _ DIR _ VALUE )  ;", "return   options ;", "}", "METHOD_END"], "methodName": ["generateVaultOptionsMap"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "String   vaultSharedKey    =    null ;", "for    ( String   line    :    linesOfOutput )     {", "if    ( line . startsWith (  \" VAULT :  :  \"  )  )     {", "vaultSharedKey    =    line ;", "break ;", "}", "}", "return   vaultSharedKey ;", "}", "METHOD_END"], "methodName": ["getStoredAttributeSharedKey"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "VaultTest . cleanDirectory ( VaultTest . ENC _ FILE _ DIR _ VALUE )  ;", "System . setSManager ( new   VaultTest . NoExitSManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "System . setSecurityManager ( null )  ;", "VaultTest . cleanDirectory ( VaultTest . ENC _ FILE _ DIR _ VALUE )  ;", "File   keyStoreFile    =    new   File ( VaultTest . KEYSTORE _ URL _ VALUE )  ;", "if    ( keyStoreFile . exists (  )  )     {", "keyStoreFile . delete (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "doTestVaultTool ( false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testNoKeyStoreFile"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "doTestVaultTool ( true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testVaultFallback"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}, {"methodBody": ["METHOD_START", "{", "doTestVaultTool ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testVaultTool"], "fileName": "org.jboss.as.security.vault.VaultToolTestCase"}]