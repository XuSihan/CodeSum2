[{"methodBody": ["METHOD_START", "{", "WildFlyBindingRegistry   registry    =    new   WildFlyBindingRegistry ( container )  ;", "Object   obj    =    new   Object (  )  ;", "String   name    =    UUID . randomUUID (  )  . toString (  )  ;", "assertNull ( getBinderServiceFor ( name )  )  ;", "assertTrue ( registry . bind ( name ,    obj )  )  ;", "assertNotNull ( getBinderServiceFor ( name )  )  ;", "registry . unbind ( name )  ;", "assertNull ( getBinderServiceFor ( name )  )  ;", "assertTrue ( registry . bind ( name ,    obj )  )  ;", "assertNotNull ( getBinderServiceFor ( name )  )  ;", "}", "METHOD_END"], "methodName": ["bindUnbindBind"], "fileName": "org.wildfly.extension.messaging.activemq.AS7BindingRegistryTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( name )  ;", "return   container . getService ( bindInfo . getBinderServiceName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBinderServiceFor"], "fileName": "org.wildfly.extension.messaging.activemq.AS7BindingRegistryTestCase"}, {"methodBody": ["METHOD_START", "{", "container    =    Factory . create (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.wildfly.extension.messaging.activemq.AS7BindingRegistryTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( container )     !  =    null )     {", "container . shutdown (  )  ;", "{", "container . awaitTermination (  5  ,    TimeUnit . SECONDS )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}    finally    {", "container    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.wildfly.extension.messaging.activemq.AS7BindingRegistryTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   artemisServiceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "ServiceController <  ?  >    artemisService    =    context . getServiceRegistry ( forWrite )  . getService ( artemisServiceName )  ;", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( artemisService . getValue (  )  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "T   control    =    ge ( server ,    address )  ;", "if    ( control    =  =    null )     {", "throw   ROOT _ LOGGER . managementResourceNotFound ( address )  ;", "}", "return   control ;", "}", "METHOD_END"], "methodName": ["getActiveMQComponentControl"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractActiveMQComponentControlHandler"}, {"methodBody": ["METHOD_START", "{", "unsupportedOperation ( operationName )  ;", "throw   MLogger . ROOT _ LOGGER . unsupportedOperation ( operationName )  ;", "}", "METHOD_END"], "methodName": ["handleOperation"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractActiveMQComponentControlHandler"}, {"methodBody": ["METHOD_START", "{", "unsupportedAttribute ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["handleReadAttribute"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractActiveMQComponentControlHandler"}, {"methodBody": ["METHOD_START", "{", "registry . registerReadOnlyAttribute ( AbstractActiveMQComponentControlHandler . STARTED ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractActiveMQComponentControlHandler"}, {"methodBody": ["METHOD_START", "{", "final   OperationDefinition   startOp    =    new   SimpleOperationDefinitionBuilder ( ModelDescriptionConstants . START ,    resolver )  . setRuntimeOnly (  )  . build (  )  ;", "registry . registerOperation ( startOp ,    this )  ;", "final   OperationDefinition   stopOp    =    new   SimpleOperationDefinitionBuilder ( ModelDescriptionConstants . STOP ,    resolver )  . setRuntimeOnly (  )  . build (  )  ;", "registry . registerOperation ( stopOp ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractActiveMQComponentControlHandler"}, {"methodBody": ["METHOD_START", "{", "throw   MessagingLogger . ROOT _ LOGGER . unsupportedAttribute ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["unsupportedAttribute"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractActiveMQComponentControlHandler"}, {"methodBody": ["METHOD_START", "{", "throw   MessagingLogger . ROOT _ LOGGER . unsupportedOperation ( operationName )  ;", "}", "METHOD_END"], "methodName": ["unsupportedOperation"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractActiveMQComponentControlHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   AttributeDefinition [  ]  {    OperationDefinitionHelper . createNonEmptyStringAttribute (  \" consumerName \"  )  ,    new   Builder (  \" elements \"  ,    new   Builder (  \" element \"  ,    getReplyMessageParameterDefinitions (  )  )  . build (  )  )  . build (  )     }  ;", "}", "METHOD_END"], "methodName": ["getReplyMapConsumerMessageParameterDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractQueueControlHandler"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ MESSAGES ,    resolver )  . setParameters ( CommonAttributes . FILTER )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( getReplyMessageParameterDefinitions (  )  )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ MESSAGES _ AS _ JSON ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( CommonAttributes . FILTER )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . COUNT _ MESSAGES ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( CommonAttributes . FILTER )  . setReplyType ( ModelType . LONG )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . REMOVE _ MESSAGE ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( getMessageIDAttributeDefinition (  )  )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . REMOVE _ MESSAGES ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( CommonAttributes . FILTER )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . EXPIRE _ MESSAGE ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( getMessageIDAttributeDefinition (  )  )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . EXPIRE _ MESSAGES ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( CommonAttributes . FILTER )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . SEND _ MESSAGE _ TO _ DEAD _ LETTER _ ADDRESS ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( getMessageIDAttributeDefinition (  )  )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . SEND _ MESSAGES _ TO _ DEAD _ LETTER _ ADDRESS ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( CommonAttributes . FILTER )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . CHANGE _ MESSAGE _ PRIORITY ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( getMessageIDAttributeDefinition (  )  ,    AbstractQueueControlHandler . NEW _ PRIORITY )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . CHANGE _ MESSAGES _ PRIORITY ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( CommonAttributes . FILTER ,    AbstractQueueControlHandler . NEW _ PRIORITY )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . MOVE _ MESSAGE ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( getMessageIDAttributeDefinition (  )  ,    AbstractQueueControlHandler . OTHER _ QUEUE _ NAME ,    AbstractQueueControlHandler . REJECT _ DUPLICATES )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . MOVE _ MESSAGES ,    AbstractQueueControlHandler . RESOLVER )  . setParameters ( CommonAttributes . FILTER ,    AbstractQueueControlHandler . OTHER _ QUEUE _ NAME ,    AbstractQueueControlHandler . REJECT _ DUPLICATES )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ MESSAGE _ COUNTER _ AS _ JSON ,    AbstractQueueControlHandler . RESOLVER )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ MESSAGE _ COUNTER _ AS _ HTML ,    AbstractQueueControlHandler . RESOLVER )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . RESET _ MESSAGE _ COUNTER ,    AbstractQueueControlHandler . RESOLVER )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ MESSAGE _ COUNTER _ HISTORY _ AS _ JSON ,    AbstractQueueControlHandler . RESOLVER )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ MESSAGE _ COUNTER _ HISTORY _ AS _ HTML ,    AbstractQueueControlHandler . RESOLVER )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . PAUSE ,    AbstractQueueControlHandler . RESOLVER )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( AbstractQueueControlHandler . RESUME ,    AbstractQueueControlHandler . RESOLVER )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ CONSUMERS _ AS _ JSON ,    AbstractQueueControlHandler . RESOLVER )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ DELIVERING _ MESSAGES ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( getReplyMapConsumerMessageParameterDefinition (  )  )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ DELIVERING _ MESSAGES _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ SCHEDULED _ MESSAGES ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( getReplyMessageParameterDefinitions (  )  )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( AbstractQueueControlHandler . LIST _ SCHEDULED _ MESSAGES _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractQueueControlHandler"}, {"methodBody": ["METHOD_START", "{", "throw   MessagingLogger . ROOT _ LOGGER . unsupportedOperation ( operationName )  ;", "}", "METHOD_END"], "methodName": ["throwUnimplementedOperationException"], "fileName": "org.wildfly.extension.messaging.activemq.AbstractQueueControlHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   activMQServerServiceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP _ ADDR )  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( false )  . getService ( activMQServerServiceName )  ;", "if    ( controller    !  =    null )     {", "return   ActiveMQServer . class . cast ( controller . getValue (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getActiveMQServer"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQActivationService"}, {"methodBody": ["METHOD_START", "{", "return   serverName . append (  \" activation \"  )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQActivationService"}, {"methodBody": ["METHOD_START", "{", "if    ( ActiveMQActivationService . isActiveMQServerActive ( context ,    operation )  )     {", "return   false ;", "}", "context . getResult (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["ignoreOperationIfServerNotActive"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQActivationService"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "return    . isActiveMQServerActive ( context . getServiceRegistry ( false )  ,    MessagingServices . getActiveMQServiceName ( address )  )  ;", "}", "METHOD_END"], "methodName": ["isActiveMQServerActive"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQActivationService"}, {"methodBody": ["METHOD_START", "{", "ServiceController <  ?  >    service    =    serviceRegistry . getService ( activeMQServerServiceName )  ;", "if    ( service    !  =    null )     {", "Server   server    =    Server . class . cast ( service . getValue (  )  )  ;", "if    (  ( server . isStarted (  )  )     &  &     ( server . isActive (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isActiveMQServerActive"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQActivationService"}, {"methodBody": ["METHOD_START", "{", "if    ( ActiveMQActivationService . isActiveMQServerActive ( context ,    operation )  )     {", "return   false ;", "}", "context . getFailureDescription (  )  . set ( MessagingLogger . ROOT _ LOGGER . serverInBackupMode ( PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  )  )  ;", "context . setRollbackOnly (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["rollbackOperationIfServerNotActive"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQActivationService"}, {"methodBody": ["METHOD_START", "{", "return    ( System . getSecurityManager (  )  )     =  =    null    ?    CurrentServiceContainer . getServiceContainer (  )     :    AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "ServiceController <  ?  >    service    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "if    (  ( service    =  =    null )     |  |     (  ( service . getState (  )  )     !  =     ( State . UP )  )  )     {", "throw   MessagingLogger . ROOT _ LOGGER . activeMQServerNotInstalled ( serviceName . getSimpleName (  )  )  ;", "}", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( service . getValue (  )  )  ;", "return   server . get (  )  ;", "}", "METHOD_END"], "methodName": ["getServerControl"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerControlHandler"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    operation . require ( NAME )  . asString (  )  ;", "if    ( ActiveMQServerControlHandler . STARTED . getName (  )  . equals ( name )  )     {", "boolean   started    =     ( server    !  =    null )     ?    server . isStarted (  )     :    false ;", "context . getResult (  )  . set ( started )  ;", "} else", "if    ( ActiveMQServerControlHandler . VERSION . getName (  )  . equals ( name )  )     {", "if    ( server    !  =    null )     {", "String   version    =    server . getVersion (  )  . getFullVersion (  )  ;", "context . getResult (  )  . set ( version )  ;", "}", "} else", "if    ( ActiveMQServerControlHandler . ACTIVE . getName (  )  . equals ( name )  )     {", "boolean   active    =     ( server    !  =    null )     ?    server . isActive (  )     :    false ;", "context . getResult (  )  . set ( active )  ;", "} else    {", "throw   logging . MessagingLogger . ROOT _ LOGGER . unsupportedAttribute ( name )  ;", "}", "}", "METHOD_END"], "methodName": ["handleReadAttribute"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerControlHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attr    :    ActiveMQServerControlHandler . ATTRIBUTES )     {", "registry . registerReadOnlyAttribute ( attr ,    this )  ;", "}", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerControlHandler"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . GET _ CONNECTORS _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . RESET _ ALL _ MESSAGE _ COUNTERS ,    resolver )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . RESET _ ALL _ MESSAGE _ COUNTER _ HISTORIES ,    resolver )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ PREPARED _ TRANSACTIONS ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyValueType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ PREPARED _ TRANSACTION _ DETAILS _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ PREPARED _ TRANSACTION _ DETAILS _ AS _ HTML ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ HEURISTIC _ COMMITTED _ TRANSACTIONS ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyValueType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ HEURISTIC _ ROLLED _ BACK _ TRANSACTIONS ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyValueType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . COMMIT _ PREPARED _ TRANSACTION ,    resolver )  . setParameters ( ActiveMQServerControlHandler . TRANSACTION _ AS _ BASE _  6  4  )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . ROLLBACK _ PREPARED _ TRANSACTION ,    resolver )  . setParameters ( ActiveMQServerControlHandler . TRANSACTION _ AS _ BASE _  6  4  )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ REMOTE _ ADDRESSES ,    resolver )  . setParameters ( ActiveMQServerControlHandler . OPTIONAL _ IP _ ADDRESS )  . setReplyType ( ModelType . LIST )  . setReplyValueType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . CLOSE _ CONNECTIONS _ FOR _ ADDRESS ,    resolver )  . setParameters ( ActiveMQServerControlHandler . REQUIRED _ IP _ ADDRESS )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . CLOSE _ CONNECTIONS _ FOR _ USER ,    resolver )  . setParameters ( ActiveMQServerControlHandler . USER )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . CLOSE _ CONSUMER _ CONNECTIONS _ FOR _ ADDRESS ,    resolver )  . setParameters ( ActiveMQServerControlHandler . ADDRESS _ MATCH )  . setReplyType ( ModelType . BOOLEAN )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ CONNECTION _ IDS ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyValueType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ PRODUCERS _ INFO _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . LIST _ SESSIONS ,    resolver )  . setParameters ( ActiveMQServerControlHandler . CONNECTION _ ID )  . setReplyType ( ModelType . LIST )  . setReplyValueType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . GET _ ROLES _ AS _ JSON ,    resolver )  . setParameters ( ActiveMQServerControlHandler . ADDRESS _ MATCH )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . GET _ ADDRESS _ SETTINGS _ AS _ JSON ,    resolver )  . setParameters ( ActiveMQServerControlHandler . ADDRESS _ MATCH )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( ActiveMQServerControlHandler . FORCE _ FAILOVER ,    resolver )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( ActiveMQServerControlHandler . GET _ ROLES ,    resolver )  . setParameters ( ActiveMQServerControlHandler . ADDRESS _ MATCH )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( SecurityRoleDefinition . NAME ,    SecurityRoleDefinition . SEND ,    SecurityRoleDefinition . CONSUME ,    SecurityRoleDefinition . CREATE _ DURABLE _ QUEUE ,    SecurityRoleDefinition . DELETE _ DURABLE _ QUEUE ,    SecurityRoleDefinition . CREATE _ NON _ DURABLE _ QUEUE ,    SecurityRoleDefinition . DELETE _ NON _ DURABLE _ QUEUE ,    SecurityRoleDefinition . MANAGE )  . build (  )  ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerControlHandler"}, {"methodBody": ["METHOD_START", "{", "ActiveMQServerControl   serverControl    =    ActiveMQServer . class . cast ( activeMQServiceController . getValue (  )  )  . getActiveMQServerControl (  )  ;", "if    ( serverControl    =  =    null )     {", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "throw   ROOT _ LOGGER . managementResourceNotFound ( address )  ;", "}", "try    {", "if    ( attributeName . equals ( ServerDefinition . MESSAGE _ COUNTER _ SAMPLE _ PERIOD . getName (  )  )  )     {", "serverControl . setMessageCounterSamplePeriod ( newValue . asLong (  )  )  ;", "} else", "if    ( attributeName . equals ( ServerDefinition . MESSAGE _ COUNTER _ MAX _ DAY _ HISTORY . getName (  )  )  )     {", "serverControl . setMessageCounterMaxDayCount ( newValue . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ServerDefinition . STATISTICS _ ENABLED . getName (  )  )  )     {", "if    ( newValue . asBoolean (  )  )     {", "serverControl . enableMessageCounters (  )  ;", "} else    {", "serverControl . disableMessageCounters (  )  ;", "}", "} else    {", "throw   logging . MessagingLogger . ROOT _ LOGGER . unsupportedRuntimeAttribute ( attributeName )  ;", "}", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["applyOperationToActiveMQService"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerControlWriteHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attr    :    ServerDefinition . ATTRIBUTES )     {", "if    ( registerRuntimeOnly    |  |     (  !  ( attr . getFlags (  )  . contains ( STORAGE _ RUNTIME )  )  )  )     {", "registry . registerReadWriteAttribute ( attr ,    null ,    this )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerControlWriteHandler"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServerServiceController ;", "}", "METHOD_END"], "methodName": ["getActiveMQServerServiceController"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerResource"}, {"methodBody": ["METHOD_START", "{", "final   ManagementService   managementService    =    getManagementService (  )  ;", "if    ( managementService    =  =    null )     {", "return   Collections . emptySet (  )  ;", "} else    {", "Set < String >    result    =    new   HashSet < String >  (  )  ;", "for    ( Object   obj    :    managementService . gets ( AddressControl . class )  )     {", "AddressControl   ac    =    AddressControl . class . cast ( obj )  ;", "result . add ( ac . getAddress (  )  )  ;", "}", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["getCoreAddressNames"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerResource"}, {"methodBody": ["METHOD_START", "{", "final   ManagementService   managementService    =    getManagementService (  )  ;", "if    ( managementService    =  =    null )     {", "return   Collections . emptySet (  )  ;", "} else    {", "Set < String >    result    =    new   HashSet < String >  (  )  ;", "for    ( Object   obj    :    managementService . gets ( QueueControl . class )  )     {", "QueueControl   qc    =    QueueControl . class . cast ( obj )  ;", "result . add ( qc . getName (  )  )  ;", "}", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["getCoreQueueNames"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerResource"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( activeMQServerServiceController )     =  =    null )     |  |     (  ( activeMQServerServiceController . getState (  )  )     !  =     ( State . UP )  )  )     {", "return   null ;", "} else    {", "return   activeMQServerServiceController . getValue (  )  . getManagementService (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getManagementService"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerResource"}, {"methodBody": ["METHOD_START", "{", "final   ManagementService   managementService    =    getManagementService (  )  ;", "return   managementService    =  =    null    ?    false    :     ( managementService . get (  (  ( Names . CORE _ ADDRESS )     +     ( element . getValue (  )  )  )  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasAddressControl"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerResource"}, {"methodBody": ["METHOD_START", "{", "final   ManagementService   managementService    =    getManagementService (  )  ;", "return   managementService    =  =    null    ?    false    :     ( managementService . get (  (  ( Names . CORE _ QUEUE )     +    name )  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasQueueControl"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerResource"}, {"methodBody": ["METHOD_START", "{", "this . activeMQServerServiceController    =    activeMQServerServiceController ;", "}", "METHOD_END"], "methodName": ["setActiveMQServerServiceController"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerResource"}, {"methodBody": ["METHOD_START", "{", "if    ( bridgeCredentialSource . containsKey ( name )  )     {", "return   bridgeCredentialSource . get ( name )  ;", "} else    {", "InjectedValue < ExceptSupplier < CredentialSource ,    Except >  >    injector    =    new   InjectedValue (  )  ;", "bridgeCredentialSource . put ( name ,    injector )  ;", "return   injector ;", "}", "}", "METHOD_END"], "methodName": ["getBridgeCredentialSourceSupplierInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   clusterCredentialSource ;", "}", "METHOD_END"], "methodName": ["getClusterCredentialSourceSupplierInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   clusterNames ;", "}", "METHOD_END"], "methodName": ["getClusterNames"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   this . commandDispatcherFactories . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getCommandDispatcherFactory"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   new   MapInjector ( this . commandDispatcherFactories ,    name )  ;", "}", "METHOD_END"], "methodName": ["getCommandDispatcherFactoryInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   this . elytronSecurityDomain ;", "}", "METHOD_END"], "methodName": ["getElytronDomainInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   new   MapInjector < String ,    SocketBinding >  ( groupBindings ,    name )  ;", "}", "METHOD_END"], "methodName": ["getGroupBindingInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   incomingInterceptors ;", "}", "METHOD_END"], "methodName": ["getIncomingInterceptors"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   mbeanServer ;", "}", "METHOD_END"], "methodName": ["getMBeanServer"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   new   MapInjector < String ,    OutboundSocketBinding >  ( outboundSocketBindings ,    name )  ;", "}", "METHOD_END"], "methodName": ["getOutboundSocketBindingInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   outgoingInterceptors ;", "}", "METHOD_END"], "methodName": ["getOutgoingInterceptors"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   pathManager ;", "}", "METHOD_END"], "methodName": ["getPathManagerInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   securityDomainContextValue ;", "}", "METHOD_END"], "methodName": ["getSecurityDomainContextInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "return   new   MapInjector < String ,    SocketBinding >  ( socketBindings ,    name )  ;", "}", "METHOD_END"], "methodName": ["getSocketBindingInjector"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "final   ActiveMQServer   server    =    this . server ;", "if    ( server    =  =    null )     {", "throw   new   IllegalStateException (  )  ;", "}", "return   server ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "if    ( context . isNormalServer (  )  )     {", "final   ServiceName   serviceName    =    MessagingServices . geticeName ( context . getCurrentAddress (  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "return   controller    !  =    null ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isServiceInstalled"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( configurat    !  =    null )     {", "for    ( BridgeConfiguratbridgeConfigurat :    configuratgetBridgeConfigurat (  )  )     {", "setNewPassword ( getBridgeCredentialSourceSupplierInjector ( bridgeConfiguratgetName (  )  )  . getOptlValue (  )  ,    bridgeConfigurat : setPassword )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setBridgePasswordsFromCredentialSource"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( configuration )     !  =    null )", "setNewPassword ( getClusterCredentialSourceSupplierInjector (  )  . getOptionalValue (  )  ,    configuration :  : setClusterPassword )  ;", "}", "METHOD_END"], "methodName": ["setClusterPasswordFromCredentialSource"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "if    ( credentialSourceSupplier    !  =    null )     {", "try    {", "CredentialSource   credentialSource    =    credentialSourceSupplier . get (  )  ;", "if    ( credentialSource    !  =    null )     {", "char [  ]    password    =    credentialSource . getCredential ( PasswordCredential . class )  . getPassword ( ClearPassword . class )  . getPassword (  )  ;", "if    ( password    !  =    null )     {", "passwordConsumer . accept ( new   Str ( password )  )  ;", "}", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setNewPassword"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   origTCCL    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "JournalType   jtype    =    configuration . getJournalType (  )  ;", "if    ( jtype    =  =     ( JournalType . ASYNCIO )  )     {", "boolean   supportsAIO    =    AIOSequentialFileFactory . isSupported (  )  ;", "if    ( supportsAIO    =  =    false )     {", "String   osName    =    System . getProperty (  \" os . name \"  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    ( osName . contains (  \" nux \"  )  )     {", "MessagingLogger . ROOT _ LOGGER . aioInfoLinux (  )  ;", "} else    {", "MessagingLogger . ROOT _ LOGGER . aioInfo (  )  ;", "}", "configuration . setJournalType ( NIO )  ;", "}", "}", "PathManager   pathManager    =    this . pathManager . getValue (  )  ;", "configuration . setBindingsDirectory ( pathConfig . resolveBindingsPath ( pathManager )  )  ;", "configuration . setLargeMessagesDirectory ( pathConfig . resolveLargeMessagePath ( pathManager )  )  ;", "configuration . setJournalDirectory ( pathConfig . resolveJournalPath ( pathManager )  )  ;", "configuration . setPagingDirectory ( pathConfig . resolvePagingPath ( pathManager )  )  ;", "pathConfig . registerCallbacks ( pathManager )  ;", "try    {", "Collection < TransportConfiguration >    acceptors    =    configuration . getAcceptorConfigurations (  )  ;", "Collection < TransportConfiguration >    connectors    =    configuration . getConnectorConfigurations (  )  . values (  )  ;", "Collection < BroadcastGroupConfiguration >    broadcastGroups    =    configuration . getBroadcastGroupConfigurations (  )  ;", "Map < String ,    DiscoveryGroupConfiguration >    discoveryGroups    =    configuration . getDiscoveryGroupConfigurations (  )  ;", "if    ( connectors    !  =    null )     {", "for    ( TransportConfiguration   tc    :    connectors )     {", "Object   socketRef    =    tc . getParams (  )  . remove (  . SOCKET _ REF )  ;", "if    ( socketRef    !  =    null )     {", "String   name    =    socketRef . toString (  )  ;", "String   host ;", "int   port ;", "OutboundSocketBinding   binding    =    outboundSocketBindings . get ( name )  ;", "if    ( binding    =  =    null )     {", "final   SocketBinding   socketBinding    =    socketBindings . get ( name )  ;", "if    ( socketBinding    =  =    null )     {", "throw   MessagingLogger . ROOT _ LOGGER . failedToFindConnectorSocketBinding ( tc . getName (  )  )  ;", "}", "if    (  (  ( socketBinding . getClientMappings (  )  )     !  =    null )     &  &     (  !  ( socketBinding . getClientMappings (  )  . isEmpty (  )  )  )  )     {", "ClientMapping   clientMapping    =    socketBinding . getClientMappings (  )  . get (  0  )  ;", "host    =    NetworkUtils . canonize ( clientMapping . getDestinationAddress (  )  )  ;", "port    =    clientMapping . getDestinationPort (  )  ;", "if    (  ( socketBinding . getClientMappings (  )  . size (  )  )     >     1  )     {", "MessagingLogger . ROOT _ LOGGER . multipleClientMappingsFound ( socketBinding . getName (  )  ,    tc . getName (  )  ,    host ,    port )  ;", "}", "} else    {", "InetSocketAddress   sa    =    socketBinding . getSocketAddress (  )  ;", "port    =    sa . getPort (  )  ;", "if    ( sa . getAddress (  )  . isLoopbackAddress (  )  )     {", "host    =    NetworkUtils . canonize ( sa . getAddress (  )  . getHostName (  )  )  ;", "} else    {", "host    =    NetworkUtils . canonize ( sa . getAddress (  )  . getHostAddress (  )  )  ;", "}", "}", "} else    {", "port    =    binding . getDestinationPort (  )  ;", "host    =    NetworkUtils . canonize ( binding . getUnresolvedDestinationAddress (  )  )  ;", "if    (  ( binding . getSourceAddress (  )  )     !  =    null )     {", "tc . getParams (  )  . put ( LOCAL _ ADDRESS _ PROP _ NAME ,    NetworkUtils . canonize ( binding . getSourceAddress (  )  . getHostAddress (  )  )  )  ;", "}", "if    (  ( binding . getSourcePort (  )  )     !  =    null )     {", "tc . getParams (  )  . put ( LOCAL _ PORT _ PROP _ NAME ,    binding . getAbsoluteSourcePort (  )  )  ;", "}", "}", "tc . getParams (  )  . put (  . HOST ,    host )  ;", "tc . getParams (  )  . put (  . PORT ,    port )  ;", "}", "}", "}", "if    ( acceptors    !  =    null )     {", "for    ( TransportConfiguration   tc    :    acceptors )     {", "Object   socketRef    =    tc . getParams (  )  . remove (  . SOCKET _ REF )  ;", "if    ( socketRef    !  =    null )     {", "String   name    =    socketRef . toString (  )  ;", "SocketBinding   binding    =    socketBindings . get ( name )  ;", "if    ( binding    =  =    null )     {", "throw   MessagingLogger . ROOT _ LOGGER . failedToFindConnectorSocketBinding ( tc . getName (  )  )  ;", "}", "binding . getSocketBindings (  )  . getNamedRegistry (  )  . registerBinding ( Factory . createSimpleManagedBinding ( binding )  )  ;", "InetSocketAddress   socketAddress    =    binding . getSocketAddress (  )  ;", "tc . getParams (  )  . put (  . HOST ,    socketAddress . getAddress (  )  . getHostAddress (  )  )  ;", "tc . getParams (  )  . put (  . PORT ,    socketAddress . getPort (  )  )  ;", "}", "}", "}", "if    ( broadcastGroups    !  =    null )     {", "final   List < BroadcastGroupConfiguration >    newConfigs    =    new   ArrayList < BroadcastGroupConfiguration >  (  )  ;", "for    ( final   BroadcastGroupConfiguration   config    :    broadcastGroups )     {", "final   String   name    =    config . getName (  )  ;", "final   String   key    =     \" broadcast \"     +    name ;", "if    ( commandDispatcherFactories . containsKey ( key )  )     {", "CommandDispatcherFactory   commandDispatcherFactory    =    commandDispatcherFactories . get ( key )  ;", "String   clusterName    =    clusterNames . get ( key )  ;", "newConfigs . add ( BroadcastGroupAdd . createBroadcastGroupConfiguration ( name ,    config ,    commandDispatcherFactory ,    clusterName )  )  ;", "} else    {", "final   SocketBinding   binding    =    groupBindings . get ( key )  ;", "if    ( binding    =  =    null )     {", "throw   MessagingLogger . ROOT _ LOGGER . failedToFindBroadcastSocketBinding ( name )  ;", "}", "binding . getSocketBindings (  )  . getNamedRegistry (  )  . registerBinding ( Factory . createSimpleManagedBinding ( binding )  )  ;", "newConfigs . add ( BroadcastGroupAdd . createBroadcastGroupConfiguration ( name ,    config ,    binding )  )  ;", "}", "}", "configuration . getBroadcastGroupConfigurations (  )  . clear (  )  ;", "configuration . getBroadcastGroupConfigurations (  )  . addAll ( newConfigs )  ;", "}", "if    ( discoveryGroups    !  =    null )     {", "configuration . setDiscoveryGroupConfigurations ( new   HashMap < String ,    DiscoveryGroupConfiguration >  (  )  )  ;", "for    ( final   Map . Entry < String ,    DiscoveryGroupConfiguration >    entry    :    discoveryGroups . entrySet (  )  )     {", "final   String   name    =    entry . getKey (  )  ;", "final   String   key    =     \" discovery \"     +    name ;", "final   DiscoveryGroupConfiguration   config ;", "if    ( commandDispatcherFactories . containsKey ( key )  )     {", "CommandDispatcherFactory   commandDispatcherFactory    =    commandDispatcherFactories . get ( key )  ;", "String   clusterName    =    clusterNames . get ( key )  ;", "config    =    DiscoveryGroupAdd . createDiscoveryGroupConfiguration ( name ,    entry . getValue (  )  ,    commandDispatcherFactory ,    clusterName )  ;", "} else    {", "final   SocketBinding   binding    =    groupBindings . get ( key )  ;", "if    ( binding    =  =    null )     {", "throw   MessagingLogger . ROOT _ LOGGER . failedToFindDiscoverySocketBinding ( name )  ;", "}", "config    =    DiscoveryGroupAdd . createDiscoveryGroupConfiguration ( name ,    entry . getValue (  )  ,    binding )  ;", "binding . getSocketBindings (  )  . getNamedRegistry (  )  . registerBinding ( Factory . createSimpleManagedBinding ( binding )  )  ;", "}", "configuration . getDiscoveryGroupConfigurations (  )  . put ( name ,    config )  ;", "}", "}", "ActiveMQSecurityManager   securityManager    =    null ;", "final   SecurityDomain   elytronDomain    =    this . elytronSecurityDomain . getOptionalValue (  )  ;", "if    ( elytronDomain    !  =    null )     {", "securityManager    =    new   ElytronSecurityManager ( elytronDomain )  ;", "} else    {", "securityManager    =    new   WildFlySecurityManager ( securityDomainContextValue . getValue (  )  )  ;", "}", "setBridgePasswordsFromCredentialSource (  )  ;", "setClusterPasswordFromCredentialSource (  )  ;", "DataSource   ds    =    dataSource . getOptionalValue (  )  ;", "if    ( ds    !  =    null )     {", "DatabaseStorageConfiguration   dbConfiguration    =     (  ( DatabaseStorageConfiguration )     ( configuration . getStoreConfiguration (  )  )  )  ;", "dbConfiguration . setDataSource ( ds )  ;", "PropertySQLProviderFactory   sqlProviderFactory    =     (  ( PropertySQLProviderFactory )     ( dbConfiguration . getSqlProviderFactory (  )  )  )  ;", "sqlProviderFactory . investigateDialect ( ds )  ;", "configuration . setStoreConfiguration ( dbConfiguration )  ;", "MessagingLogger . ROOT _ LOGGER . infof (  \" use   JDBC   store   for   Artemis   server ,    bindingsTable :  % s \"  ,    dbConfiguration . getBindingsTableName (  )  )  ;", "}", "server    =    new   ActiveMQServerImpl ( configuration ,    mbeanServer . getOptionalValue (  )  ,    securityManager )  ;", "if    ( ActiveMQDefaultConfiguration . getDefaultClusterPassword (  )  . equals ( server . getConfiguration (  )  . getClusterPassword (  )  )  )     {", "server . getConfiguration (  )  . setClusterPassword ( UUID . randomUUID (  )  . toString (  )  )  ;", "}", "for    ( Interceptor   incomingInterceptor    :    incomingInterceptors )     {", "server . getServiceRegistry (  )  . addIncomingInterceptor ( incomingInterceptor )  ;", "}", "for    ( Interceptor   outgoingInterceptor    :    outgoingInterceptors )     {", "server . getServiceRegistry (  )  . addOutgoingInterceptor ( outgoingInterceptor )  ;", "}", "}    catch    ( Exception   e )     {", "throw   MessagingLogger . ROOT _ LOGGER . failedToStartService ( e )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( origTCCL )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( server )     !  =    null )     {", "for    ( SocketBinding   binding    :    socketBindings . values (  )  )     {", "if    ( binding    !  =    null )     {", "binding . getSocketBindings (  )  . getNamedRegistry (  )  . unregisterBinding ( binding . getName (  )  )  ;", "}", "}", "for    ( SocketBinding   binding    :    groupBindings . values (  )  )     {", "if    ( binding    !  =    null )     {", "binding . getSocketBindings (  )  . getNamedRegistry (  )  . unregisterBinding ( binding . getName (  )  )  ;", "}", "}", "}", "pathConfig . closeCallbacks ( pathManager . getValue (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   MLogger . ROOT _ LOGGER . failedToShutdownServer ( e ,     \" Artemis \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.wildfly.extension.messaging.activemq.ActiveMQServerService"}, {"methodBody": ["METHOD_START", "{", "final   String   addressName    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  . getLastElement (  )  . getValue (  )  ;", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "ServiceController <  ?  >    service    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( service . getValue (  )  )  ;", "return    . class . cast ( server . getManagementService (  )  . getResource (  (  ( ResourceNames . CORE _ ADDRESS )     +    addressName )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAddressControl"], "fileName": "org.wildfly.extension.messaging.activemq.AddressControlHandler"}, {"methodBody": ["METHOD_START", "{", "final   AddressControl   addressControl    =    getAddressControl ( context ,    operation )  ;", "try    {", "String   json    =    addressControl . getRolesAsJSON (  )  ;", "ManagementUtil . reportRolesAsJSON ( context ,    json )  ;", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "context . getFailureDescription (  )  . set ( e . getLocalizedMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleGetRolesAsJson"], "fileName": "org.wildfly.extension.messaging.activemq.AddressControlHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( ActiveMQActivationService . ignoreOperationIfServerNotActive ( context ,    operation )  )     {", "return ;", "}", "final   AddressControl   addressControl    =    getAddressControl ( context ,    operation )  ;", "if    ( addressControl    =  =    null )     {", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "throw   ROOT _ LOGGER . managementResourceNotFound ( address )  ;", "}", "final   String   name    =    operation . require ( NAME )  . asString (  )  ;", "try    {", "if    ( CommonAttributes . ROLES _ ATTR _ NAME . equals ( name )  )     {", "String   json    =    addressControl . getRolesAsJSON (  )  ;", "ManagementUtil . reportRoles ( context ,    json )  ;", "} else", "if    ( CommonAttributes . QUEUE _ NAMES . equals ( name )  )     {", "String [  ]    queues    =    addressControl . getQueueNames (  )  ;", "ManagementUtil . reportListOfStrings ( context ,    queues )  ;", "} else", "if    ( CommonAttributes . NUMBER _ OF _ BYTES _ PER _ PAGE . equals ( name )  )     {", "long   l    =    addressControl . getNumberOfBytesPerPage (  )  ;", "context . getResult (  )  . set ( l )  ;", "} else", "if    ( CommonAttributes . NUMBER _ OF _ PAGES . equals ( name )  )     {", "int   i    =    addressControl . getNumberOfPages (  )  ;", "context . getResult (  )  . set ( i )  ;", "} else", "if    ( CommonAttributes . BINDING _ NAMES . equals ( name )  )     {", "String [  ]    bindings    =    addressControl . getBindingNames (  )  ;", "ManagementUtil . reportListOfStrings ( context ,    bindings )  ;", "} else    {", "throw   logging . MessagingLogger . ROOT _ LOGGER . unsupportedAttribute ( name )  ;", "}", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "context . getFailureDescription (  )  . set ( e . getLocalizedMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleReadAttribute"], "fileName": "org.wildfly.extension.messaging.activemq.AddressControlHandler"}, {"methodBody": ["METHOD_START", "{", "return   SimpleString . toSimpleString (  (  ( node . getType (  )  )     !  =     ( ModelType . UNDEFINED )     ?    node . asString (  )     :    defVal )  )  ;", "}", "METHOD_END"], "methodName": ["asSimpleString"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingAdd"}, {"methodBody": ["METHOD_START", "{", "final   AddressSettings   settings    =    new   AddressSettings (  )  ;", "if    ( config . hasDefined ( AddressSettingDefinition . ADDRESS _ FULL _ MESSAGE _ POLICY . getName (  )  )  )     {", "final   AddressFullMessagePolicy   addressPolicy    =    AddressFullMessagePolicy . valueOf ( AddressSettingDefinition . ADDRESS _ FULL _ MESSAGE _ POLICY . resolveModelAttribute ( context ,    config )  . asString (  )  )  ;", "settings . setAddressFullMessagePolicy ( addressPolicy )  ;", "}", "if    ( config . hasDefined ( CommonAttributes . DEAD _ LETTER _ ADDRESS . getName (  )  )  )     {", "settings . setDeadLetterAddress (  . asSimpleString ( CommonAttributes . DEAD _ LETTER _ ADDRESS . resolveModelAttribute ( context ,    config )  ,    null )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . LAST _ VALUE _ QUEUE . getName (  )  )  )     {", "settings . setLastValueQueue ( AddressSettingDefinition . LAST _ VALUE _ QUEUE . resolveModelAttribute ( context ,    config )  . asBoolean (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . MAX _ DELIVERY _ ATTEMPTS . getName (  )  )  )     {", "settings . setMaxDeliveryAttempts ( AddressSettingDefinition . MAX _ DELIVERY _ ATTEMPTS . resolveModelAttribute ( context ,    config )  . asInt (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . MAX _ SIZE _ BYTES . getName (  )  )  )     {", "settings . setMaxSizeBytes ( AddressSettingDefinition . MAX _ SIZE _ BYTES . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . MESSAGE _ COUNTER _ HISTORY _ DAY _ LIMIT . getName (  )  )  )     {", "settings . setMessageCounterHistoryDayLimit ( AddressSettingDefinition . MESSAGE _ COUNTER _ HISTORY _ DAY _ LIMIT . resolveModelAttribute ( context ,    config )  . asInt (  )  )  ;", "}", "if    ( config . hasDefined ( CommonAttributes . EXPIRY _ ADDRESS . getName (  )  )  )     {", "settings . setExpiryAddress (  . asSimpleString ( CommonAttributes . EXPIRY _ ADDRESS . resolveModelAttribute ( context ,    config )  ,    null )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . EXPIRY _ DELAY . getName (  )  )  )     {", "settings . setExpiryDelay ( AddressSettingDefinition . EXPIRY _ DELAY . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . REDELIVERY _ DELAY . getName (  )  )  )     {", "settings . setRedeliveryDelay ( AddressSettingDefinition . REDELIVERY _ DELAY . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . REDELIVERY _ MULTIPLIER . getName (  )  )  )     {", "settings . setRedeliveryMultiplier ( AddressSettingDefinition . REDELIVERY _ MULTIPLIER . resolveModelAttribute ( context ,    config )  . asDouble (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . MAX _ REDELIVERY _ DELAY . getName (  )  )  )     {", "settings . setMaxRedeliveryDelay ( AddressSettingDefinition . MAX _ REDELIVERY _ DELAY . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . REDISTRIBUTION _ DELAY . getName (  )  )  )     {", "settings . setRedistributionDelay ( AddressSettingDefinition . REDISTRIBUTION _ DELAY . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . PAGE _ SIZE _ BYTES . getName (  )  )  )     {", "settings . setPageSizeBytes ( AddressSettingDefinition . PAGE _ SIZE _ BYTES . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . PAGE _ MAX _ CACHE _ SIZE . getName (  )  )  )     {", "settings . setPageCacheMaxSize ( AddressSettingDefinition . PAGE _ MAX _ CACHE _ SIZE . resolveModelAttribute ( context ,    config )  . asInt (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . SEND _ TO _ DLA _ ON _ NO _ ROUTE . getName (  )  )  )     {", "settings . setSendToDLAOnNoRoute ( AddressSettingDefinition . SEND _ TO _ DLA _ ON _ NO _ ROUTE . resolveModelAttribute ( context ,    config )  . asBoolean (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . SLOW _ CONSUMER _ CHECK _ PERIOD . getName (  )  )  )     {", "settings . setSlowConsumerCheckPeriod ( AddressSettingDefinition . SLOW _ CONSUMER _ CHECK _ PERIOD . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . SLOW _ CONSUMER _ POLICY . getName (  )  )  )     {", "final   SlowConsumerPolicy   slowConsumerPolicy    =    SlowConsumerPolicy . valueOf ( AddressSettingDefinition . SLOW _ CONSUMER _ POLICY . resolveModelAttribute ( context ,    config )  . asString (  )  )  ;", "settings . setSlowConsumerPolicy ( slowConsumerPolicy )  ;", "}", "if    ( config . hasDefined ( AddressSettingDefinition . SLOW _ CONSUMER _ THRESHOLD . getName (  )  )  )     {", "settings . setSlowConsumerThreshold ( AddressSettingDefinition . SLOW _ CONSUMER _ THRESHOLD . resolveModelAttribute ( context ,    config )  . asLong (  )  )  ;", "}", "settings . setAutoCreateJmsQueues ( AddressSettingDefinition . AUTO _ CREATE _ JMS _ QUEUES . resolveModelAttribute ( context ,    config )  . asBoolean (  )  )  ;", "settings . setAutoDeleteJmsQueues ( AddressSettingDefinition . AUTO _ DELETE _ JMS _ QUEUES . resolveModelAttribute ( context ,    config )  . asBoolean (  )  )  ;", "return   settings ;", "}", "METHOD_END"], "methodName": ["createSettings"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingAdd"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( true )  . getService ( serviceName )  ;", "if    ( controller    !  =    null )     {", "return   ActiveMQServer . class . cast ( controller . getValue (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingRemove"}, {"methodBody": ["METHOD_START", "{", "SimpleOperationDefinition   op    =    new   SimpleOperationDefinitionBuilder ( CommonAttributes . RESOLVE _ ADDRESS _ SETTING ,    resolver )  . setReadOnly (  )  . setRuntimeOnly (  )  . addParameter ( AddressSettingsResolveHandler . ACTIVEMQ _ ADDRESS )  . setReplyType ( LIST )  . setReplyParameters ( AddressSettingDefinition . ATTRIBUTES )  . build (  )  ;", "registry . registerOperationHandler ( op ,    AddressSettingsResolveHandler . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["registerOperationHandler"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingsResolveHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   deadLetterAddress    =    CommonAttributes . DEAD _ LETTER _ ADDRESS . resolveModelAttribute ( context ,    model )  ;", "if    (  !  (  . findMatchingResource ( deadLetterAddress ,    activeMQServer )  )  )     {", "MessagingLogger . ROOT _ LOGGER . noMatchingDeadLetterAddress ( deadLetterAddress . asString (  )  ,    addressSetting )  ;", "}", "}", "METHOD_END"], "methodName": ["checkDeadLetterAddress"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingsValidator"}, {"methodBody": ["METHOD_START", "{", "ModelNode   expiryAddress    =    CommonAttributes . EXPIRY _ ADDRESS . resolveModelAttribute ( context ,    model )  ;", "if    (  !  (  . findMatchingResource ( expiryAddress ,    activeMQServer )  )  )     {", "MessagingLogger . ROOT _ LOGGER . noMatchingExpiryAddress ( expiryAddress . asString (  )  ,    addressSetting )  ;", "}", "}", "METHOD_END"], "methodName": ["checkExpiryAddress"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingsValidator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( addressNode . isDefined (  )  )  )     {", "return   true ;", "}", "final   String   address    =    addressNode . asString (  )  ;", "final   String   addressPrefix ;", "final   String   childType ;", "if    ( address . startsWith ( JMS _ QUEUE _ ADDRESS _ PREFIX )  )     {", "childType    =    CommonAttributes . JMS _ QUEUE ;", "addressPrefix    =    JMS _ QUEUE _ ADDRESS _ PREFIX ;", "} else", "if    ( address . startsWith ( JMS _ TOPIC _ ADDRESS _ PREFIX )  )     {", "childType    =    CommonAttributes . JMS _ TOPIC ;", "addressPrefix    =    JMS _ TOPIC _ ADDRESS _ PREFIX ;", "} else    {", "childType    =    CommonAttributes . CORE _ QUEUE ;", "addressPrefix    =     \"  \"  ;", "}", "for    ( String   childName    :    activeMQServer . getChildrenNames ( childType )  )     {", "if    ( address . equals (  ( addressPrefix    +    childName )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["findMatchingResource"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingsValidator"}, {"methodBody": ["METHOD_START", "{", "String   addressSetting    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  . getLastElement (  )  . getValue (  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  ;", "Resource   activeMQServer    =    context . readResourceFromRoot ( MessagingServices . getActiveMQServerPathAddress ( address )  ,    true )  ;", ". checkExpiryAddress ( context ,    resource . getModel (  )  ,    activeMQServer ,    addressSetting )  ;", ". checkDeadLetterAddress ( context ,    resource . getModel (  )  ,    activeMQServer ,    addressSetting )  ;", "}", "METHOD_END"], "methodName": ["validateModel"], "fileName": "org.wildfly.extension.messaging.activemq.AddressSettingsValidator"}, {"methodBody": ["METHOD_START", "{", "final   ContextNames . BindInfo   aliasBindInfo    =    ContextNames . bindInfoFor ( alias )  ;", "final   BinderService   aliasBinderService    =    new   BinderService ( alias )  ;", "aliasBinderService . getManagedObjectInjector (  )  . inject ( new    . AliasManagedReferenceFactory ( bindInfo . getAbsoluteJndiName (  )  )  )  ;", "serviceTarget . addService ( aliasBindInfo . getBinderServiceName (  )  ,    aliasBinderService )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    aliasBinderService . getNamingStoreInjector (  )  )  . addDependency ( bindInfo . getBinderServiceName (  )  )  . addListener ( new   AbstractServiceListener < ManagedReferenceFactory >  (  )     {", "@ Override", "public   void   transition ( ServiceController <  ?    extends   ManagedReferenceFactory >    controller ,    ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "MessagingLogger . ROOT _ LOGGER . boundJndiName ( alias )  ;", "break ;", "}", "case   STOPPING _ to _ DOWN    :", "{", "MessagingLogger . ROOT _ LOGGER . unboundJndiName ( alias )  ;", "break ;", "}", "case   REMOVING _ to _ REMOVED    :", "{", "MessagingLogger . ROOT _ LOGGER . debugf (  \" Removed   messaging   object    [  % s ]  \"  ,    alias )  ;", "break ;", "}", "}", "}", "}  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installAliasBinderService"], "fileName": "org.wildfly.extension.messaging.activemq.BinderServiceUtil"}, {"methodBody": ["METHOD_START", "{", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( name )  ;", "final      binderService    =    new    ( bindInfo . getBindName (  )  )  ;", "serviceTarget . addService ( bindInfo . getName (  )  ,    binderService )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . addInjection ( binderService . getManagedObjectInjector (  )  ,    new   ValueManagedReferenceFactory ( Values . immediateValue ( obj )  )  )  . setInitialMode ( ACTIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installBinderService"], "fileName": "org.wildfly.extension.messaging.activemq.BinderServiceUtil"}, {"methodBody": ["METHOD_START", "{", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( name )  ;", "final      binderService    =    new    ( bindInfo . getBindName (  )  )  ;", "final   ServiceBuilder   serviceBuilder    =    serviceTarget . addService ( bindInfo . getName (  )  ,    binderService )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . addInjection ( binderService . getManagedObjectInjector (  )  ,    new   ValueManagedReferenceFactory ( service )  )  . setInitialMode ( PASSIVE )  ;", "if    (  ( dependencies    !  =    null )     &  &     (  ( dependencies . length )     >     0  )  )     {", "serviceBuilder . addDependencies ( dependencies )  ;", "}", "serviceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["installBinderService"], "fileName": "org.wildfly.extension.messaging.activemq.BinderServiceUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . BRIDGE )  )     {", "final   List < BridgeConfiguration >    configs    =    configuration . getBridgeConfigurations (  )  ;", "for    ( Property   prop    :    model . get ( CommonAttributes . BRIDGE )  . asPropertyList (  )  )     {", "configs . add (  . createBridgeConfiguration ( context ,    prop . getName (  )  ,    prop . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBridgeConfigs"], "fileName": "org.wildfly.extension.messaging.activemq.BridgeAdd"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( bridgeConfig . getDiscoveryGroupName (  )  )     !  =    null )     {", "serverControl . create ( name ,    bridgeConfig . getQueueName (  )  ,    bridgeConfig . getForwardingAddress (  )  ,    bridgeConfig . getFilterString (  )  ,    bridgeConfig . getTransformerClassName (  )  ,    bridgeConfig . getRetryInterval (  )  ,    bridgeConfig . getRetryIntervalMultiplier (  )  ,    bridgeConfig . getInitialConnectAttempts (  )  ,    bridgeConfig . getReconnectAttempts (  )  ,    bridgeConfig . isUseDuplicateDetection (  )  ,    bridgeConfig . getConfirmationWindowSize (  )  ,    bridgeConfig . getClientFailureCheckPeriod (  )  ,    bridgeConfig . getDiscoveryGroupName (  )  ,    true ,    bridgeConfig . isHA (  )  ,    bridgeConfig . getUser (  )  ,    bridgeConfig . getPassword (  )  )  ;", "} else    {", "boolean   first    =    true ;", "String   connectors    =     \"  \"  ;", "for    ( String   connector    :    bridgeConfig . getStaticConnectors (  )  )     {", "if    (  ! first )     {", "connectors    +  =     \"  ,  \"  ;", "} else    {", "first    =    false ;", "}", "connectors    +  =    connector ;", "}", "serverControl . create ( name ,    bridgeConfig . getQueueName (  )  ,    bridgeConfig . getForwardingAddress (  )  ,    bridgeConfig . getFilterString (  )  ,    bridgeConfig . getTransformerClassName (  )  ,    bridgeConfig . getRetryInterval (  )  ,    bridgeConfig . getRetryIntervalMultiplier (  )  ,    bridgeConfig . getInitialConnectAttempts (  )  ,    bridgeConfig . getReconnectAttempts (  )  ,    bridgeConfig . isUseDuplicateDetection (  )  ,    bridgeConfig . getConfirmationWindowSize (  )  ,    bridgeConfig . getClientFailureCheckPeriod (  )  ,    connectors ,    false ,    bridgeConfig . isHA (  )  ,    bridgeConfig . getUser (  )  ,    bridgeConfig . getPassword (  )  )  ;", "}", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createBridge"], "fileName": "org.wildfly.extension.messaging.activemq.BridgeAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   queueName    =    BridgeDefinition . QUEUE _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ModelNode   forwardingNode    =    BridgeDefinition . FORWARDING _ ADDRESS . resolveModelAttribute ( context ,    model )  ;", "final   String   forwardingAddress    =     ( forwardingNode . isDefined (  )  )     ?    forwardingNode . asString (  )     :    null ;", "final   ModelNode   filterNode    =    CommonAttributes . FILTER . resolveModelAttribute ( context ,    model )  ;", "final   String   filterString    =     ( filterNode . isDefined (  )  )     ?    filterNode . asString (  )     :    null ;", "final   ModelNode   transformerNode    =    CommonAttributes . TRANSFORMER _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  ;", "final   String   transformerClassName    =     ( transformerNode . isDefined (  )  )     ?    transformerNode . asString (  )     :    null ;", "final   int   minLargeMessageSize    =    CommonAttributes . MIN _ LARGE _ MESSAGE _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   long   retryInterval    =    CommonAttributes . RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   double   retryIntervalMultiplier    =    CommonAttributes . RETRY _ INTERVAL _ MULTIPLIER . resolveModelAttribute ( context ,    model )  . asDouble (  )  ;", "final   long   maxRetryInterval    =    CommonAttributes . MAX _ RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   int   initialConnectAttempts    =    BridgeDefinition . INITIAL _ CONNECT _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   reconnectAttempts    =    BridgeDefinition . RECONNECT _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   reconnectAttemptsOnSameNode    =    BridgeDefinition . RECONNECT _ ATTEMPTS _ ON _ SAME _ NODE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   boolean   useDuplicateDetection    =    BridgeDefinition . USE _ DUPLICATE _ DETECTION . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   int   confirmationWindowSize    =    CommonAttributes . BRIDGE _ CONFIRMATION _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   producerWindowSize    =    BridgeDefinition . PRODUCER _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   long   clientFailureCheckPeriod    =    CommonAttributes . CHECK _ PERIOD . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   long   connectionTTL    =    CommonAttributes . CONNECTION _ TTL . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   ModelNode   discoveryNode    =    BridgeDefinition . DISCOVERY _ GROUP _ NAME . resolveModelAttribute ( context ,    model )  ;", "final   String   discoveryGroupName    =     ( discoveryNode . isDefined (  )  )     ?    discoveryNode . asString (  )     :    null ;", "List < String >    staticConnectors    =     ( discoveryGroupName    =  =    null )     ?     . getStaticConnectors ( model )     :    null ;", "final   boolean   ha    =    CommonAttributes . HA . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   String   user    =    BridgeDefinition . USER . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   password    =    BridgeDefinition . PASSWORD . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "BridgeConfiguration   config    =    new   BridgeConfiguration (  )  . setName ( name )  . setQueueName ( queueName )  . setForwardingAddress ( forwardingAddress )  . setFilterString ( filterString )  . setTransformerClassName ( transformerClassName )  . setMinLargeMessageSize ( minLargeMessageSize )  . setClientFailureCheckPeriod ( clientFailureCheckPeriod )  . setConnectionTTL ( connectionTTL )  . setRetryInterval ( retryInterval )  . setMaxRetryInterval ( maxRetryInterval )  . setRetryIntervalMultiplier ( retryIntervalMultiplier )  . setInitialConnectAttempts ( initialConnectAttempts )  . setReconnectAttempts ( reconnectAttempts )  . setReconnectAttemptsOnSameNode ( reconnectAttemptsOnSameNode )  . setUseDuplicateDetection ( useDuplicateDetection )  . setConfirmationWindowSize ( confirmationWindowSize )  . setProducerWindowSize ( producerWindowSize )  . setHA ( ha )  . setUser ( user )  . setPassword ( password )  ;", "if    ( discoveryGroupName    !  =    null )     {", "config . setDiscoveryGroupName ( discoveryGroupName )  ;", "} else    {", "config . setStaticConnectors ( staticConnectors )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["createBridgeConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.BridgeAdd"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList < String >  (  )  ;", "for    ( ModelNode   connector    :    model . require ( CommonAttributes . STATIC _ CONNECTORS )  . asList (  )  )     {", "result . add ( connector . asString (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getStaticConnectors"], "fileName": "org.wildfly.extension.messaging.activemq.BridgeAdd"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . BROADCAST _ GROUP )  )     {", "final   List < BroadcastGroupConfiguration >    configs    =    configuration . getBroadcastGroupConfigurations (  )  ;", "final   Set < String >    connectors    =    configuration . getConnectorConfigurations (  )  . keySet (  )  ;", "for    ( Property   prop    :    model . get ( CommonAttributes . BROADCAST _ GROUP )  . asPropertyList (  )  )     {", "configs . add (  . createBroadcastGroupConfiguration ( context ,    connectors ,    prop . getName (  )  ,    prop . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBroadcastGroupConfigs"], "fileName": "org.wildfly.extension.messaging.activemq.BroadcastGroupAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   localAddress    =    socketBinding . getAddress (  )  . getHostAddress (  )  ;", "final   String   groupAddress    =    socketBinding . getMulticastAddress (  )  . getHostAddress (  )  ;", "final   int   localPort    =    socketBinding . getPort (  )  ;", "final   int   groupPort    =    socketBinding . getMulticastPort (  )  ;", "final   long   broadcastPeriod    =    config . getBroadcastPeriod (  )  ;", "final   List < String >    connectorRefs    =    config . getConnectorInfos (  )  ;", "final   BroadcastEndpointFactory   endpointFactory    =    new   UDPBroadcastEndpointFactory (  )  . setGroupAddress ( groupAddress )  . setGroupPort ( groupPort )  . setLocalBindAddress ( localAddress )  . setLocalBindPort ( localPort )  ;", "return   new   Configuration (  )  . setName ( name )  . setBroadcastPeriod ( broadcastPeriod )  . setConnectorInfos ( connectorRefs )  . setEndpointFactory ( endpointFactory )  ;", "}", "METHOD_END"], "methodName": ["createBroadcastGroupConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.BroadcastGroupAdd"}, {"methodBody": ["METHOD_START", "{", "final   long   broadcastPeriod    =    config . getBroadcastPeriod (  )  ;", "final   List < String >    connectorRefs    =    config . getConnectorInfos (  )  ;", "final   BroadcastEndpointFactory   endpointFactory    =    new   CommandDispatcherBroadcastEndpointFactory ( commandDispatcherFactory ,    channelName )  ;", "return   new   Configuration (  )  . setName ( name )  . setBroadcastPeriod ( broadcastPeriod )  . setConnectorInfos ( connectorRefs )  . setEndpointFactory ( endpointFactory )  ;", "}", "METHOD_END"], "methodName": ["createBroadcastGroupConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.BroadcastGroupAdd"}, {"methodBody": ["METHOD_START", "{", "final   long   broadcastPeriod    =    BroadcastGroupDefinition . BROADCAST _ PERIOD . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   List < String >    connectorRefs    =    new   ArrayList < String >  (  )  ;", "if    ( model . hasDefined ( CommonAttributes . CONNECTORS )  )     {", "for    ( ModelNode   ref    :    model . get ( CommonAttributes . CONNECTORS )  . asList (  )  )     {", "final   String   refName    =    ref . asString (  )  ;", "if    (  !  ( connectors . contains ( refName )  )  )     {", "throw   MessagingLogger . ROOT _ LOGGER . wrongConnectorRefInBroadCastGroup ( name ,    refName ,    connectors )  ;", "}", "connectorRefs . add ( refName )  ;", "}", "}", "return   new   BroadcastGroupConfiguration (  )  . setName ( name )  . setBroadcastPeriod ( broadcastPeriod )  . setConnectorInfos ( connectorRefs )  ;", "}", "METHOD_END"], "methodName": ["createBroadcastGroupConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.BroadcastGroupAdd"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  ;", "PathAddress   active    =    MServices . getActiveMQServerPathAddress ( address )  ;", "Resource   activeMQServerResource    =    context . readResourceFromRoot ( active ,    false )  ;", "Set < String >    availableConnectors    =    new   HashSet < String >  (  )  ;", "availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . HTTP _ CONNECTOR )  )  ;", "availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . IN _ VM _ CONNECTOR )  )  ;", "availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . REMOTE _ CONNECTOR )  )  ;", "availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . CONNECTOR )  )  ;", "return   availableConnectors ;", "}", "METHOD_END"], "methodName": ["getAvailableConnectors"], "fileName": "org.wildfly.extension.messaging.activemq.BroadcastGroupDefinition"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    availableConnectors    =    BroadcastGroupDefinition . getAvailableConnectors ( context ,    operation )  ;", "final   List < ModelNode >    operationAddress    =    operation . get ( ADDRESS )  . asList (  )  ;", "final   String   broadCastGroup    =    operationAddress . get (  (  ( operationAddress . size (  )  )     -     1  )  )  . get ( CommonAttributes . BROADCAST _ GROUP )  . asString (  )  ;", "for    ( ModelNode   connectorRef    :    connectorRefs . asList (  )  )     {", "final   String   connectorName    =    connectorRef . asString (  )  ;", "if    (  !  ( availableConnectors . contains ( connectorName )  )  )     {", "throw   MessagingLogger . ROOT _ LOGGER . wrongConnectorRefInBroadCastGroup ( broadCastGroup ,    connectorName ,    availableConnectors )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateConnectors"], "fileName": "org.wildfly.extension.messaging.activemq.BroadcastGroupDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . CLUSTER _ CONNECTION )  )     {", "final   List < ClusterConnectionConfiguration >    configs    =    configuration . getClusterConfigurations (  )  ;", "for    ( Property   prop    :    model . get ( CommonAttributes . CLUSTER _ CONNECTION )  . asPropertyList (  )  )     {", "configs . add (  . createClusterConnectionConfiguration ( context ,    prop . getName (  )  ,    prop . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addClusterConnectionConfigs"], "fileName": "org.wildfly.extension.messaging.activemq.ClusterConnectionAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   address    =    ClusterConnectionDefinition . ADDRESS . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   connectorName    =    ClusterConnectionDefinition . CONNECTOR _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   long   retryInterval    =    ClusterConnectionDefinition . RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   boolean   duplicateDetection    =    ClusterConnectionDefinition . USE _ DUPLICATE _ DETECTION . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   long   connectionTTL    =    ClusterConnectionDefinition . CONNECTION _ TTL . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   initialConnectAttempts    =    ClusterConnectionDefinition . INITIAL _ CONNECT _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   reconnectAttempts    =    ClusterConnectionDefinition . RECONNECT _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   long   maxRetryInterval    =    ClusterConnectionDefinition . MAX _ RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   double   retryIntervalMultiplier    =    ClusterConnectionDefinition . RETRY _ INTERVAL _ MULTIPLIER . resolveModelAttribute ( context ,    model )  . asDouble (  )  ;", "final   long   clientFailureCheckPeriod    =    ClusterConnectionDefinition . CHECK _ PERIOD . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   String   messageLoadBalancingType    =    ClusterConnectionDefinition . MESSAGE _ LOAD _ BALANCING _ TYPE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   int   maxHops    =    ClusterConnectionDefinition . MAX _ HOPS . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   confirmationWindowSize    =    CommonAttributes . BRIDGE _ CONFIRMATION _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   int   producerWindowSize    =    ClusterConnectionDefinition . PRODUCER _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   ModelNode   discoveryNode    =    ClusterConnectionDefinition . DISCOVERY _ GROUP _ NAME . resolveModelAttribute ( context ,    model )  ;", "final   int   minLargeMessageSize    =    CommonAttributes . MIN _ LARGE _ MESSAGE _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   long   callTimeout    =    CommonAttributes . CALL _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   long   callFailoverTimeout    =    ClusterConnectionDefinition . CALL _ FAILOVER _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   long   clusterNotificationInterval    =    ClusterConnectionDefinition . NOTIFICATION _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   int   clusterNotificationAttempts    =    ClusterConnectionDefinition . NOTIFICATION _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "ClusterConnectionConfiguration   config    =    new   ClusterConnectionConfiguration (  )  . setName ( name )  . setAddress ( address )  . setConnectorName ( connectorName )  . setMinLargeMessageSize ( minLargeMessageSize )  . setClientFailureCheckPeriod ( clientFailureCheckPeriod )  . setConnectionTTL ( connectionTTL )  . setRetryInterval ( retryInterval )  . setRetryIntervalMultiplier ( retryIntervalMultiplier )  . setMaxRetryInterval ( maxRetryInterval )  . setInitialConnectAttempts ( initialConnectAttempts )  . setReconnectAttempts ( reconnectAttempts )  . setCallTimeout ( callTimeout )  . setCallFailoverTimeout ( callFailoverTimeout )  . setDuplicateDetection ( duplicateDetection )  . setMessageLoadBalancingType ( MessageLoadBalancingType . valueOf ( messageLoadBalancingType )  )  . setMaxHops ( maxHops )  . setConfirmationWindowSize ( confirmationWindowSize )  . setProducerWindowSize ( producerWindowSize )  . setClusterNotificationInterval ( clusterNotificationInterval )  . setClusterNotificationAttempts ( clusterNotificationAttempts )  ;", "final   String   discoveryGroupName    =     ( discoveryNode . isDefined (  )  )     ?    discoveryNode . asString (  )     :    null ;", "final   List < String >    staticConnectors    =     ( discoveryGroupName    =  =    null )     ?     . getStaticConnectors ( model )     :    null ;", "final   boolean   allowDirectOnly    =    ClusterConnectionDefinition . ALLOW _ DIRECT _ CONNECTIONS _ ONLY . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "if    ( discoveryGroupName    !  =    null )     {", "config . setDiscoveryGroupName ( discoveryGroupName )  ;", "} else    {", "config . setStaticConnectors ( staticConnectors )  . setAllowDirectConnectionsOnly ( allowDirectOnly )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["createClusterConnectionConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ClusterConnectionAdd"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . hasDefined ( CommonAttributes . STATIC _ CONNECTORS )  )  )", "return   null ;", "List < String >    result    =    new   ArrayList < String >  (  )  ;", "for    ( ModelNode   cor    :    model . require ( CommonAttributes . STATIC _ CONNECTORS )  . asList (  )  )     {", "result . add ( cor . asString (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getStaticConnectors"], "fileName": "org.wildfly.extension.messaging.activemq.ClusterConnectionAdd"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( operation . hasDefined ( CommonAttributes . JGROUPS _ CLUSTER . getName (  )  )  )  )     &  &     ( operation . hasDefined ( CommonAttributes . JGROUPS _ CHANNEL . getName (  )  )  )  )     {", "operation . get ( CommonAttributes . JGROUPS _ CLUSTER . getName (  )  )  . set ( operation . get ( CommonAttributes . JGROUPS _ CHANNEL . getName (  )  )  )  ;", "operation . remove ( CommonAttributes . JGROUPS _ CHANNEL . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["renameChannelToCluster"], "fileName": "org.wildfly.extension.messaging.activemq.CommonAttributes"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . CONNECTOR _ SERVICE )  )     {", "final   List < ConnectorServiceConfiguration >    configs    =    configuration . getConnectorServiceConfigurations (  )  ;", "for    ( Property   prop    :    model . get ( CommonAttributes . CONNECTOR _ SERVICE )  . asPropertyList (  )  )     {", "configs . add (  . createConnectorServiceConfiguration ( context ,    prop . getName (  )  ,    prop . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addConnectorServiceConfigs"], "fileName": "org.wildfly.extension.messaging.activemq.ConnectorServiceDefinition"}, {"methodBody": ["METHOD_START", "{", "try    {", "ClassloadingUtil . newInstanceFromClassLoader ( factoryClass )  ;", "}    catch    ( Throwable   t )     {", "throw   MessagingLogger . ROOT _ LOGGER . unableToLoadFactoryClass ( factoryClass )  ;", "}", "}", "METHOD_END"], "methodName": ["checkFactoryClass"], "fileName": "org.wildfly.extension.messaging.activemq.ConnectorServiceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   String   factoryClass    =    CommonAttributes . FACTORY _ CLASS . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "Map < String ,    String >    unwrappedParameters    =    CommonAttributes . PARAMS . unwrap ( context ,    model )  ;", "Map < String ,    Object >    parameters    =    new   HashMap < String ,    Object >  ( unwrappedParameters )  ;", "return   new   Configuration (  )  . setFactoryClassName ( factoryClass )  . setParams ( parameters )  . setName ( name )  ;", "}", "METHOD_END"], "methodName": ["createConnectorServiceConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ConnectorServiceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  ( managementService )     =  =    null )     {", "return   null ;", "}", "Object   obj    =    managementService . get (  (  ( Names . CORE _ ADDRESS )     +     ( name )  )  )  ;", "return   AddressControl . class . cast ( obj )  ;", "}", "METHOD_END"], "methodName": ["getAddressControl"], "fileName": "org.wildfly.extension.messaging.activemq.CoreAddressResource"}, {"methodBody": ["METHOD_START", "{", "AddressControl   addressControl    =    getAddressControl (  )  ;", "if    ( addressControl    =  =    null )     {", "return   Collections . emptySet (  )  ;", "} else    {", "Set < String >    names    =    new   HashSet < String >  (  )  ;", "try    {", "ModelNode   res    =    ModelNode . fromJSONString ( addressControl . getRolesAsJSON (  )  )  ;", "ModelNode   converted    =    ManagementUtil . convertSecurityRole ( res )  ;", "for    ( ModelNode   role    :    converted . asList (  )  )     {", "names . add ( role . get ( CommonAttributes . NAME )  . asString (  )  )  ;", "}", "return   names ;", "}    catch    ( Exception   e )     {", "return   Collections . emptySet (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getSecurityRoles"], "fileName": "org.wildfly.extension.messaging.activemq.CoreAddressResource"}, {"methodBody": ["METHOD_START", "{", "String   role    =    element . getValue (  )  ;", "return   getSecurityRoles (  )  . contains ( role )  ;", "}", "METHOD_END"], "methodName": ["hasSecurityRole"], "fileName": "org.wildfly.extension.messaging.activemq.CoreAddressResource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DefaultCredentials . password )     =  =    null )     {", "DefaultCredentials . password    =    UUID . randomUUID (  )  . toString (  )  ;", "}", "return   DefaultCredentials . password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.wildfly.extension.messaging.activemq.DefaultCredentials"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DefaultCredentials . username )     =  =    null )     {", "DefaultCredentials . username    =    UUID . randomUUID (  )  . toString (  )  ;", "}", "return   DefaultCredentials . username ;", "}", "METHOD_END"], "methodName": ["getUsername"], "fileName": "org.wildfly.extension.messaging.activemq.DefaultCredentials"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . DISCOVERY _ GROUP )  )     {", "Map < String ,    DiscoveryGroupConfiguration >    configs    =    configuration . getDiscoveryGroupConfigurations (  )  ;", "if    ( configs    =  =    null )     {", "configs    =    new   HashMap < String ,    DiscoveryGroupConfiguration >  (  )  ;", "configuration . setDiscoveryGroupConfigurations ( configs )  ;", "}", "for    ( Property   prop    :    model . get ( CommonAttributes . DISCOVERY _ GROUP )  . asPropertyList (  )  )     {", "configs . put ( prop . getName (  )  ,     . createDiscoveryGroupConfiguration ( context ,    prop . getName (  )  ,    prop . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addDiscoveryGroupConfigs"], "fileName": "org.wildfly.extension.messaging.activemq.DiscoveryGroupAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   localAddress    =    socketBinding . getAddress (  )  . getHostAddress (  )  ;", "final   String   groupAddress    =    socketBinding . getMulticastAddress (  )  . getHostAddress (  )  ;", "final   int   groupPort    =    socketBinding . getMulticastPort (  )  ;", "final   long   refreshTimeout    =    config . getRefreshTimeout (  )  ;", "final   long   initialWaitTimeout    =    config . getDiscoveryInitialWaitTimeout (  )  ;", "final   BroadcastEndpointFactory   endpointFactory    =    new   UDPBroadcastEndpointFactory (  )  . setGroupAddress ( groupAddress )  . setGroupPort ( groupPort )  . setLocalBindAddress ( localAddress )  . setLocalBindPort (  (  -  1  )  )  ;", "return   new   Configuration (  )  . setName ( name )  . setRefreshTimeout ( refreshTimeout )  . setDiscoveryInitialWaitTimeout ( initialWaitTimeout )  . setBroadcastEndpointFactory ( endpointFactory )  ;", "}", "METHOD_END"], "methodName": ["createDiscoveryGroupConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.DiscoveryGroupAdd"}, {"methodBody": ["METHOD_START", "{", "final   long   refreshTimeout    =    config . getRefreshTimeout (  )  ;", "final   long   initialWaitTimeout    =    config . getDiscoveryInitialWaitTimeout (  )  ;", "final   BroadcastEndpointFactory   endpointFactory    =    new   CommandDispatcherBroadcastEndpointFactory ( commandDispatcherFactory ,    channelName )  ;", "return   new   Configuration (  )  . setName ( name )  . setRefreshTimeout ( refreshTimeout )  . setDiscoveryInitialWaitTimeout ( initialWaitTimeout )  . setBroadcastEndpointFactory ( endpointFactory )  ;", "}", "METHOD_END"], "methodName": ["createDiscoveryGroupConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.DiscoveryGroupAdd"}, {"methodBody": ["METHOD_START", "{", "final   long   refreshTimeout    =    DiscoveryGroupDefinition . REFRESH _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   long   initialWaitTimeout    =    DiscoveryGroupDefinition . INITIAL _ WAIT _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "return   new   DiscoveryGroupConfiguration (  )  . setName ( name )  . setRefreshTimeout ( refreshTimeout )  . setDiscoveryInitialWaitTimeout ( initialWaitTimeout )  ;", "}", "METHOD_END"], "methodName": ["createDiscoveryGroupConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.DiscoveryGroupAdd"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . DIVERT )  )     {", "final   List < DivertConfiguration >    configs    =    configuration . getDivertConfigurations (  )  ;", "for    ( Property   prop    :    model . get ( CommonAttributes . DIVERT )  . asPropertyList (  )  )     {", "configs . add (  . createDivertConfiguration ( context ,    prop . getName (  )  ,    prop . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addDivertConfigs"], "fileName": "org.wildfly.extension.messaging.activemq.DivertAdd"}, {"methodBody": ["METHOD_START", "{", "try    {", "serverControl . create ( name ,    divertConfiguration . getRoutingName (  )  ,    divertConfiguration . getAddress (  )  ,    divertConfiguration . getForwardingAddress (  )  ,    divertConfiguration . isExclusive (  )  ,    divertConfiguration . getFilterString (  )  ,    divertConfiguration . getTransformerClassName (  )  )  ;", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createDivert"], "fileName": "org.wildfly.extension.messaging.activemq.DivertAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   routingNode    =    DivertDefinition . ROUTING _ NAME . resolveModelAttribute ( context ,    model )  ;", "final   String   routingName    =     ( routingNode . isDefined (  )  )     ?    routingNode . asString (  )     :    null ;", "final   String   address    =    DivertDefinition . ADDRESS . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   forwardingAddress    =    DivertDefinition . FORWARDING _ ADDRESS . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   boolean   exclusive    =    DivertDefinition . EXCLUSIVE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   ModelNode   filterNode    =    CommonAttributes . FILTER . resolveModelAttribute ( context ,    model )  ;", "final   String   filter    =     ( filterNode . isDefined (  )  )     ?    filterNode . asString (  )     :    null ;", "final   ModelNode   transformerNode    =    CommonAttributes . TRANSFORMER _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  ;", "final   String   transformerClassName    =     ( transformerNode . isDefined (  )  )     ?    transformerNode . asString (  )     :    null ;", "return   new   DivertConfiguration (  )  . setName ( name )  . setRoutingName ( routingName )  . setAddress ( address )  . setForwardingAddress ( forwardingAddress )  . setExclusive ( exclusive )  . setFilterString ( filter )  . setTransformerClassName ( transformerClassName )  ;", "}", "METHOD_END"], "methodName": ["createDivertConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.DivertAdd"}, {"methodBody": ["METHOD_START", "{", "ServerAuthenticationContext   context    =    this . securityDomain . createNewAuthenticationContext (  )  ;", "PasswordGuessEvidence   evidence    =    null ;", "try    {", "if    ( password    =  =    null )     {", "if    ( username    =  =    null )     {", "if    ( context . authorizeAnonymous (  )  )     {", "context . succeed (  )  ;", "return   context . getAuthorizedIdentity (  )  ;", "} else    {", "context . fail (  )  ;", "return   null ;", "}", "} else    {", "context . fail (  )  ;", "return   null ;", "}", "}", "context . setAuthenticationName ( username )  ;", "evidence    =    new   PasswordGuessEvidence ( password . toCharArray (  )  )  ;", "if    ( context . verifyEvidence ( evidence )  )     {", "if    ( context . authorize (  )  )     {", "context . succeed (  )  ;", "return   context . getAuthorizedIdentity (  )  ;", "} else    {", "context . fail (  )  ;", "MLogger . ROOT _ LOGGER . failedAuthorization ( username )  ;", "}", "} else    {", "context . fail (  )  ;", "MLogger . ROOT _ LOGGER . failedAuthentication ( username )  ;", "}", "}    catch    ( IllegalArgumentException    |    IllegalStateException    |    RealmUnavailableException   e )     {", "context . fail (  )  ;", "MLogger . ROOT _ LOGGER . failedAuthenticationWithException ( e ,    username ,    e . getMessage (  )  )  ;", "}    finally    {", "if    ( evidence    !  =    null )     {", "evidence . destroy (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["authenticate"], "fileName": "org.wildfly.extension.messaging.activemq.ElytronSecurityManager"}, {"methodBody": ["METHOD_START", "{", "ModelNode   journalDatasource    =    ServerDefinition . JOURNAL _ DATASOURCE . resolveModelAttribute ( context ,    context . readResource ( PathAddress . EMPTY _ ADDRESS )  . getModel (  )  )  ;", "if    (  (  ( journalDatasource . isDefined (  )  )     &  &     (  ( journalDatasource . asString (  )  )     !  =    null )  )     &  &     (  !  (  \"  \"  . equals ( journalDatasource . asString (  )  )  )  )  )     {", "throw   MLogger . ROOT _ LOGGER . operationNotAllowedOnJdbcStore ( operationName )  ;", "}", "}", "METHOD_END"], "methodName": ["checkAllowedOnJournal"], "fileName": "org.wildfly.extension.messaging.activemq.ExportJournalOperation"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( ExportJournalOperation . OPERATION _ NAME ,    resourceDescriptionResolver )  . setRuntimeOnly (  )  . setReplyValueType ( STRING )  . build (  )  ,    ExportJournalOperation . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["registerOperation"], "fileName": "org.wildfly.extension.messaging.activemq.ExportJournalOperation"}, {"methodBody": ["METHOD_START", "{", "Resource   serverResource    =    context . readResource ( PathAddress . EMPTY _ ADDRESS )  ;", "final   ModelNode   model    =     ( serverResource . hasChild ( pathElement )  )     ?    serverResource . getChild ( pathElement )  . getModel (  )     :    new   ModelNode (  )  ;", "final   String   path    =    PathDefinitPATHS . get ( pathElement . getValue (  )  )  . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   relativeToPath    =    PathDefinitRELATIVE _ TO . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   String   relativeTo    =     ( AbsolutePathService . isAbsoluteUnixOrWindowsPath ( path )  )     ?    null    :    relativeToPath ;", "return   pathManager . resolveRelativePathEntry ( path ,    relativeTo )  ;", "}", "METHOD_END"], "methodName": ["resolvePath"], "fileName": "org.wildfly.extension.messaging.activemq.ExportJournalOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericTransportDefinition ( true ,    registerRuntimeOnly ,    CommonAttributes . ACCEPTOR )  ;", "}", "METHOD_END"], "methodName": ["createAcceptorDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.GenericTransportDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericTransportDefinition ( false ,    registerRuntimeOnly ,    CommonAttributes . CONNECTOR )  ;", "}", "METHOD_END"], "methodName": ["createConnectorDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.GenericTransportDefinition"}, {"methodBody": ["METHOD_START", "{", "return   bindingRef ;", "}", "METHOD_END"], "methodName": ["getBindingRef"], "fileName": "org.wildfly.extension.messaging.activemq.GroupBindingService"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServiceName . append ( GroupBindingService . BASE )  . append ( GroupBindingService . BROADCAST )  ;", "}", "METHOD_END"], "methodName": ["getBroadcastBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.GroupBindingService"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServiceName . append ( GroupBindingService . BASE )  . append ( GroupBindingService . DISCOVERY )  ;", "}", "METHOD_END"], "methodName": ["getDiscoveryBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.GroupBindingService"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . GROUPING _ HANDLER )  )     {", "final   Property   prop    =    model . get ( CommonAttributes . GROUPING _ HANDLER )  . asProperty (  )  ;", "final   String   name    =    prop . getName (  )  ;", "final   ModelNode   node    =    prop . getValue (  )  ;", "final   Configuration . TYPE   type    =    TYPE . valueOf ( Definition . TYPE . resolveModelAttribute ( context ,    node )  . asString (  )  )  ;", "final   String   address    =    Definition . GROUPING _ HANDLER _ ADDRESS . resolveModelAttribute ( context ,    node )  . asString (  )  ;", "final   int   timeout    =    Definition . TIMEOUT . resolveModelAttribute ( context ,    node )  . asInt (  )  ;", "final   long   groupTimeout    =    Definition . GROUP _ TIMEOUT . resolveModelAttribute ( context ,    node )  . asLong (  )  ;", "final   long   reaperPeriod    =    Definition . REAPER _ PERIOD . resolveModelAttribute ( context ,    node )  . asLong (  )  ;", "final   Configuration   conf    =    new   Configuration (  )  . setName ( SimpleString . toSimpleString ( name )  )  . setType ( type )  . setAddress ( SimpleString . toSimpleString ( address )  )  . setTimeout ( timeout )  . setGroupTimeout ( groupTimeout )  . setReaperPeriod ( reaperPeriod )  ;", "configuration . setConfiguration ( conf )  ;", "}", "}", "METHOD_END"], "methodName": ["addGroupingHandlerConfig"], "fileName": "org.wildfly.extension.messaging.activemq.GroupingHandlerAdd"}, {"methodBody": ["METHOD_START", "{", "String   httpConnectorName    =    HTTPAcceptorDefinition . HTTP _ LISTENER . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "HTTPUpgradeService . installService ( context . getServiceTarget (  )  ,    activeMQServerName ,    acceptorName ,    httpConnectorName )  ;", "boolean   upgradeLegacy    =    HTTPAcceptorDefinition . UPGRADE _ LEGACY . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "if    ( upgradeLegacy )     {", "HTTPUpgradeService . LegacyHttpUpgradeService . installService ( context . getServiceTarget (  )  ,    activeMQServerName ,    acceptorName ,    httpConnectorName )  ;", "}", "}", "METHOD_END"], "methodName": ["launchServices"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPAcceptorAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   acceptorName    =    context . getCurrentAddressValue (  )  ;", "final   String   serverName    =    context . getCurrentAddress (  )  . getParent (  )  . getLastElement (  )  . getValue (  )  ;", "context . removeService ( MessagingServices . getHttpUpgradeServiceName ( serverName ,    acceptorName )  )  ;", "boolean   upgradeLegacy    =    Definition . UPGRADE _ LEGACY . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "if    ( upgradeLegacy )     {", "context . removeService ( MessagingServices . getLegacyHttpUpgradeServiceName ( serverName ,    acceptorName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPAcceptorRemove"}, {"methodBody": ["METHOD_START", "{", "final   String   acceptorName    =    context . getCurrentAddressValue (  )  ;", "final   String   serverName    =    context . getCurrentAddress (  )  . getParent (  )  . getLastElement (  )  . getValue (  )  ;", "Add . INSTANCE . launchServices ( context ,    serverName ,    acceptorName ,    model )  ;", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPAcceptorRemove"}, {"methodBody": ["METHOD_START", "{", "return   TransportConstants . HTTP _ UPGRADE _ ENDPOINT _ PROP _ NAME ;", "}", "METHOD_END"], "methodName": ["getHttpUpgradeEndpointKey"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPUpgradeService"}, {"methodBody": ["METHOD_START", "{", "return   NettyConnector . ACTIVEMQ _ REMOTING ;", "}", "METHOD_END"], "methodName": ["getProtocol"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPUpgradeService"}, {"methodBody": ["METHOD_START", "{", "return   NettyConnector . SEC _ ACTIVEMQ _ REMOTING _ ACCEPT ;", "}", "METHOD_END"], "methodName": ["getSecAcceptHeader"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPUpgradeService"}, {"methodBody": ["METHOD_START", "{", "return   NettyConnector . SEC _ ACTIVEMQ _ REMOTING _ KEY ;", "}", "METHOD_END"], "methodName": ["getSecKeyHeader"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPUpgradeService"}, {"methodBody": ["METHOD_START", "{", "final   HTTPUpgradeService   service    =    new   HTTPUpgradeService ( activeMQServerName ,    acceptorName ,    httpListenerName )  ;", "serviceTarget . addService ( MessagingServices . getHttpUpgradeServiceName ( activeMQServerName ,    acceptorName )  ,    service )  . addDependency ( MessagingServices . HTTP _ UPGRADE _ REGISTRY . append ( httpListenerName )  ,    ChannelUpgradeHandler . class ,    service . injectedRegistry )  . addDependency ( SERVICE _ NAME ,    ListenerRegistry . class ,    service . listenerRegistry )  . addDependency ( ActiveMQActivationService . getServiceName ( MessagingServices . getActiveMQServiceName ( activeMQServerName )  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installService"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPUpgradeService"}, {"methodBody": ["METHOD_START", "{", "String   activemqServerName    =    exchange . getRequestHeaders (  )  . getFirst ( ACTIVEMQ _ SERVER _ NAME )  ;", "if    ( activemqServerName    =  =    null )     {", "return   rootServer ;", "}", "ClusterManager   clusterManager    =    rootServer . getClusterManager (  )  ;", "if    ( clusterManager    !  =    null )     {", "HAManager   haManager    =    clusterManager . getHAManager (  )  ;", "if    ( haManager    !  =    null )     {", "for    ( Map . Entry < String ,    ActiveMQServer >    entry    :    haManager . getBackupServers (  )  . entrySet (  )  )     {", "if    ( entry . getKey (  )  . equals ( activemqServerName )  )     {", "return   entry . getValue (  )  ;", "}", "}", "}", "}", "if    ( activemqServerName . equals ( rootServer . getConfiguration (  )  . getName (  )  )  )     {", "return   rootServer ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["selectServer"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPUpgradeService"}, {"methodBody": ["METHOD_START", "{", "return   new   HttpUpgradeListener (  )     {", "@ Override", "public   void   handleUpgrade ( StreamConnection   streamConnection ,    HttpServerExchange   exchange )     {", "ChannelListener < StreamConnection >    listener    =    new   ChannelListener < StreamConnection >  (  )     {", "@ Override", "public   void   handleEvent ( StreamConnection   connection )     {", "MessagingLogger . ROOT _ LOGGER . debugf (  \" Switching   to    % s   protocol   for    % s   http - acceptor \"  ,    protocolName ,    acceptorName )  ;", "ActiveMQServer   server    =     . selectServer ( exchange ,    activemqServer )  ;", "RemotingService   remotingService    =    server . getRemotingService (  )  ;", "if    (  (  !  ( server . isActive (  )  )  )     |  |     (  !  ( remotingService . isStarted (  )  )  )  )     {", "IoUtils . safeClose ( connection )  ;", "return ;", "}", "NettyAcceptor   acceptor    =     (  ( NettyAcceptor )     ( remotingService . getAcceptor ( acceptorName )  )  )  ;", "SocketChannel   channel    =    new   WrappingXnioSocketChannel ( connection )  ;", "try    {", "acceptor . transfer ( channel )  ;", "connection . getSourceChannel (  )  . resumeReads (  )  ;", "}    catch    ( IllegalStateException   e )     {", "IoUtils . safeClose ( connection )  ;", "}", "}", "}  ;", "ChannelListeners . invokeChannelListener ( streamConnection ,    listener )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["switchToMessagingProtocol"], "fileName": "org.wildfly.extension.messaging.activemq.HTTPUpgradeService"}, {"methodBody": ["METHOD_START", "{", "final   Resource   serverResource    =    context . readResource ( PathAddress . EMPTY _ ADDRESS ,    false )  ;", "Set < Resource . ResourceEntry >    invmConnectors    =    serverResource . getChildren ( CommonAttributes . IN _ VM _ CONNECTOR )  ;", "if    ( invmConnectors . isEmpty (  )  )     {", "throw   MLogger . ROOT _ LOGGER . noInVMConnector (  )  ;", "}", "Resource . ResourceEntry   connectorEntry    =    invmConnectors . iterator (  )  . next (  )  ;", "Resource   connectorResource    =    context . readResource ( PathAddress . pathAddress ( connectorEntry . getPathElement (  )  )  ,    false )  ;", "ModelNode   model    =    connectorResource . getModel (  )  ;", "Map < String ,    Object >    params    =    new   HashMap ( CommonAttributes . PARAMS . unwrap ( context ,    model )  )  ;", "params . put ( InVMTransportDefinition . SERVER _ ID . getName (  )  ,    InVMTransportDefinition . SERVER _ ID . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "TransportConfiguration   transportConfiguration    =    new   TransportConfiguration ( InVMConnectorFactory . class . getName (  )  ,    params )  ;", "return   transportConfiguration ;", "}", "METHOD_END"], "methodName": ["createInVMTransportConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ImportJournalOperation"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( ImportJournalOperation . OPERATION _ NAME ,    resourceDescriptionResolver )  . addParameter ( ImportJournalOperation . FILE )  . setRuntimeOnly (  )  . setReplyValueType ( BOOLEAN )  . build (  )  ,    ImportJournalOperation . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["registerOperation"], "fileName": "org.wildfly.extension.messaging.activemq.ImportJournalOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   InVMTransportDefinition ( registerRuntimeOnly ,    true ,    CommonAttributes . IN _ VM _ ACCEPTOR )  ;", "}", "METHOD_END"], "methodName": ["createAcceptorDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.InVMTransportDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   InVMTransportDefinition ( registerRuntimeOnly ,    false ,    CommonAttributes . IN _ VM _ CONNECTOR )  ;", "}", "METHOD_END"], "methodName": ["createConnectorDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.InVMTransportDefinition"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   result    =    new   ModelNode (  )  ;", "result . setEmptyList (  )  ;", "if    ( camelCase . isDefined (  )  )     {", "for    ( ModelNode   role    :    camelCase . asList (  )  )     {", "final   ModelNode   roleNode    =    result . add (  )  ;", "for    ( Property   prop    :    role . asPropertyList (  )  )     {", "String   key    =    prop . getName (  )  ;", "if    (  \" createDurableQueue \"  . equals ( key )  )     {", "key    =    SecurityRoleDefinitCREATE _ DURABLE _ QUEUE . getName (  )  ;", "} else", "if    (  \" deleteDurableQueue \"  . equals ( key )  )     {", "key    =    SecurityRoleDefinitDELETE _ DURABLE _ QUEUE . getName (  )  ;", "} else", "if    (  \" createNonDurableQueue \"  . equals ( key )  )     {", "key    =    SecurityRoleDefinitCREATE _ NON _ DURABLE _ QUEUE . getName (  )  ;", "} else", "if    (  \" deleteNonDurableQueue \"  . equals ( key )  )     {", "key    =    SecurityRoleDefinitDELETE _ NON _ DURABLE _ QUEUE . getName (  )  ;", "}", "roleNode . get ( key )  . set ( prop . getValue (  )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertSecurityRole"], "fileName": "org.wildfly.extension.messaging.activemq.ManagementUtil"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   result    =    context . getResult (  )  ;", "result . setEmptyList (  )  ;", "for    ( String   str    :    strings )     {", "result . add ( str )  ;", "}", "}", "METHOD_END"], "methodName": ["reportListOfStrings"], "fileName": "org.wildfly.extension.messaging.activemq.ManagementUtil"}, {"methodBody": ["METHOD_START", "{", "ModelNode   camelCase    =    ModelNode . fromJSONString ( rolesAsJSON )  ;", "ModelNode   converted    =     . convertSecurityRole ( camelCase )  ;", "context . getResult (  )  . set ( converted )  ;", "}", "METHOD_END"], "methodName": ["reportRoles"], "fileName": "org.wildfly.extension.messaging.activemq.ManagementUtil"}, {"methodBody": ["METHOD_START", "{", "ModelNode   camelCase    =    ModelNode . fromJSONString ( rolesAsJSON )  ;", "ModelNode   converted    =     . convertSecurityRole ( camelCase )  ;", "String   json    =    converted . toJSONString ( true )  ;", "context . getResult (  )  . set ( json )  ;", "}", "METHOD_END"], "methodName": ["reportRolesAsJSON"], "fileName": "org.wildfly.extension.messaging.activemq.ManagementUtil"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  1  _  0  _ ha - policy . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testHAPolicyConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_1_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  2  _  0  _ ha - policy . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testHAPolicyConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_2_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addSingleChildFirstClass ( JGroupsSubsystemInitialization . class )  . addSingleChildFirstClass ( AdditionalInitialization . class )  . addMavenResourceURL ( MessagingDependencies . getMessagingActiveMQGAV ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getActiveMQDependencies ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getJGroupsDependencies ( controllerVersion )  )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( messagingVersion )  . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource (  \" subsystem _  2  _  0  _ reject _ transform . xml \"  )  ;", "System . out . println (  (  \" ops    =     \"     +    ops )  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( MessagingExtension . SUBSYSTEM _ PATH )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    messagingVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ THREAD _ POOL _ MAX _ SIZE ,    MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ SCHEDULED _ THREAD _ POOL _ MAX _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ServerDefinition . ELYTRON _ DOMAIN ,    ServerDefinition . JOURNAL _ DATASOURCE ,    ServerDefinition . JOURNAL _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ JMS _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ LARGE _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ PAGE _ STORE _ TABLE ,    ServerDefinition . JOURNAL _ DATABASE ,    ServerDefinition . JOURNAL _ JDBC _ NETWORK _ TIMEOUT )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . REPLICATION _ MASTER _ PATH )  ,    new    . ChangeToTrueConfig ( HAAttributes . CHECK _ FOR _ LIVE _ SERVER . getName (  )  )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . REPLICATION _ COLOCATED _ PATH ,    MessagingExtension . CONFIGURATION _ MASTER _ PATH )  ,    new    . ChangeToTrueConfig ( HAAttributes . CHECK _ FOR _ LIVE _ SERVER . getName (  )  )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    PathElement . pathElement ( CommonAttributes . HTTP _ CONNECTOR )  )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( HTTPConnectorDefinition . SERVER _ NAME )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . BRIDGE _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( BridgeDefinition . PRODUCER _ WINDOW _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . CLUSTER _ CONNECTION _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ClusterConnectionDefinition . PRODUCER _ WINDOW _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . CONNECTION _ FACTORY _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . POOLED _ CONNECTION _ FACTORY _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ConnectionFactoryAttributes . Pooled . ALLOW _ LOCAL _ TRANSACTIONS ,    ConnectionFactoryAttributes . Pooled . REBALANCE _ CONNECTIONS ,    ConnectionFactoryAttributes . Pooled . STATISTICS _ ENABLED ,    ConnectionFactoryAttributes . Pooled . CREDENTIAL _ REFERENCE ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformers"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_2_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformers ( EAP _  7  _  0  _  0  ,    MessagingExtension . VERSION _  1  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_2_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" subsystem _  2  _  0  _ transform . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addSingleChildFirstClass ( JGroupsSubsystemInitialization . class )  . addSingleChildFirstClass ( AdditionalInitialization . class )  . addMavenResourceURL ( MessagingDependencies . getGAV ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getActiveMQDependencies ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getJGroupsDependencies ( controllerVersion )  )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( messagingVersion )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    messagingVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_2_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  0  _  0  ,    MessagingExtension . VERSION _  1  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_2_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  3  _  0  _ ha - policy . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHAPolicyConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addMavenResourceURL ( MessagingDependencies . getMessagingActiveMQGAV ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getActiveMQDependencies ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getJGroupsDependencies ( controllerVersion )  )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( messagingVersion )  . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource (  \" subsystem _  3  _  0  _ reject _ transform . xml \"  )  ;", "System . out . println (  (  \" ops    =     \"     +    ops )  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( MessagingExtension . SUBSYSTEM _ PATH )  ;", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  ;", "if    ( messagingVersion . equals ( MessagingExtension . VERSION _  1  _  0  _  0  )  )     {", "config . addFailedAttribute ( subsystemAddress ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ THREAD _ POOL _ MAX _ SIZE ,    MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ SCHEDULED _ THREAD _ POOL _ MAX _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ServerDefinition . ELYTRON _ DOMAIN ,    ServerDefinition . JOURNAL _ DATASOURCE ,    ServerDefinition . JOURNAL _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ JMS _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ LARGE _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ PAGE _ STORE _ TABLE ,    ServerDefinition . JOURNAL _ DATABASE ,    ServerDefinition . JOURNAL _ JDBC _ NETWORK _ TIMEOUT )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . REPLICATION _ MASTER _ PATH )  ,    new    . ChangeToTrueConfig ( HAAttributes . CHECK _ FOR _ LIVE _ SERVER . getName (  )  )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . REPLICATION _ COLOCATED _ PATH ,    MessagingExtension . CONFIGURATION _ MASTER _ PATH )  ,    new    . ChangeToTrueConfig ( HAAttributes . CHECK _ FOR _ LIVE _ SERVER . getName (  )  )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    PathElement . pathElement ( CommonAttributes . HTTP _ CONNECTOR )  )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( HTTPConnectorDefinition . SERVER _ NAME )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . BRIDGE _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( BridgeDefinition . PRODUCER _ WINDOW _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . CLUSTER _ CONNECTION _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ClusterConnectionDefinition . PRODUCER _ WINDOW _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . CONNECTION _ FACTORY _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . POOLED _ CONNECTION _ FACTORY _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ConnectionFactoryAttributes . Pooled . ALLOW _ LOCAL _ TRANSACTIONS ,    ConnectionFactoryAttributes . Pooled . REBALANCE _ CONNECTIONS ,    ConnectionFactoryAttributes . Pooled . STATISTICS _ ENABLED ,    ConnectionFactoryAttributes . Pooled . CREDENTIAL _ REFERENCE ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST )  )  ;", "}", "config . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . BROADCAST _ GROUP _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( BroadcastGroupDefinition . JGROUPS _ CHANNEL )  )  ;", "config . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    DiscoveryGroupDefinition . PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( DiscoveryGroupDefinition . JGROUPS _ CHANNEL )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    messagingVersion ,    ops ,    config )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformers"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformers ( EAP _  7  _  0  _  0  ,    MessagingExtension . VERSION _  1  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformers ( EAP _  7  _  1  _  0  ,    MessagingExtension . VERSION _  2  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformersEAP_7_1_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" subsystem _  3  _  0  _ transform . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addMavenResourceURL ( MessagingDependencies . getGAV ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getActiveMQDependencies ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getJGroupsDependencies ( controllerVersion )  )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( messagingVersion )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    messagingVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  0  _  0  ,    MessagingExtension . VERSION _  1  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  1  _  0  ,    MessagingExtension . VERSION _  2  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_7_1_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_0_TestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  3  _  1  _ ha - policy . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testHAPolicyConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_1_TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addMavenResourceURL ( MessagingDependencies . getMessagingActiveMQGAV ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getActiveMQDependencies ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getJGroupsDependencies ( controllerVersion )  )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( messagingVersion )  . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource (  \" subsystem _  3  _  1  _ reject _ transform . xml \"  )  ;", "System . out . println (  (  \" ops    =     \"     +    ops )  )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( MessagingExtension . SUBSYSTEM _ PATH )  ;", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  ;", "if    ( messagingVersion . equals ( MessagingExtension . VERSION _  1  _  0  _  0  )  )     {", "config . addFailedAttribute ( subsystemAddress ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ THREAD _ POOL _ MAX _ SIZE ,    MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ SCHEDULED _ THREAD _ POOL _ MAX _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ServerDefinition . ELYTRON _ DOMAIN ,    ServerDefinition . JOURNAL _ DATASOURCE ,    ServerDefinition . JOURNAL _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ JMS _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ LARGE _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ PAGE _ STORE _ TABLE ,    ServerDefinition . JOURNAL _ DATABASE ,    ServerDefinition . JOURNAL _ JDBC _ NETWORK _ TIMEOUT )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . REPLICATION _ MASTER _ PATH )  ,    new    . ChangeToTrueConfig ( HAAttributes . CHECK _ FOR _ LIVE _ SERVER . getName (  )  )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . REPLICATION _ COLOCATED _ PATH ,    MessagingExtension . CONFIGURATION _ MASTER _ PATH )  ,    new    . ChangeToTrueConfig ( HAAttributes . CHECK _ FOR _ LIVE _ SERVER . getName (  )  )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    PathElement . pathElement ( CommonAttributes . HTTP _ CONNECTOR )  )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( HTTPConnectorDefinition . SERVER _ NAME )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . BRIDGE _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( BridgeDefinition . PRODUCER _ WINDOW _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . CLUSTER _ CONNECTION _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ClusterConnectionDefinition . PRODUCER _ WINDOW _ SIZE )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . CONNECTION _ FACTORY _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST )  )  . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . POOLED _ CONNECTION _ FACTORY _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( ConnectionFactoryAttributes . Pooled . ALLOW _ LOCAL _ TRANSACTIONS ,    ConnectionFactoryAttributes . Pooled . REBALANCE _ CONNECTIONS ,    ConnectionFactoryAttributes . Pooled . STATISTICS _ ENABLED ,    ConnectionFactoryAttributes . Pooled . CREDENTIAL _ REFERENCE ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST )  )  ;", "}", "config . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    MessagingExtension . BROADCAST _ GROUP _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( BroadcastGroupDefinition . JGROUPS _ CHANNEL )  )  ;", "config . addFailedAttribute ( subsystemAddress . append ( MessagingExtension . SERVER _ PATH ,    DiscoveryGroupDefinition . PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( DiscoveryGroupDefinition . JGROUPS _ CHANNEL )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    messagingVersion ,    ops ,    config )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformers"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_1_TestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformers ( EAP _  7  _  0  _  0  ,    MessagingExtension . VERSION _  1  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_1_TestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformers ( EAP _  7  _  1  _  0  ,    MessagingExtension . VERSION _  2  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformersEAP_7_1_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_1_TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" subsystem _  3  _  1  _ transform . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addMavenResourceURL ( MessagingDependencies . getGAV ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getActiveMQDependencies ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getJGroupsDependencies ( controllerVersion )  )  . skipReverseControllerCheck (  )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( messagingVersion )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    messagingVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_1_TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  0  _  0  ,    MessagingExtension . VERSION _  1  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_7_0_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_1_TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  7  _  1  _  0  ,    MessagingExtension . VERSION _  2  _  0  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_7_1_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingActiveMQSubsystem_3_1_TestCase"}, {"methodBody": ["METHOD_START", "{", "return   MessagingDependencies . ACTIVEMQ _ DEPENDENCIES . get ( controllerVersion )  ;", "}", "METHOD_END"], "methodName": ["getActiveMQDependencies"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingDependencies"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {    String . format (  \" eap : wildfly - clustering - common :  % s \"  ,    version . getMavenGavVersion (  )  )  ,    String . format (  \" eap : wildfly - clustering - jgroups - api :  % s \"  ,    version . getMavenGavVersion (  )  )  ,    String . format (  \" eap : wildfly - clustering - jgroups - extension :  % s \"  ,    version . getMavenGavVersion (  )  )  ,    String . format (  \" eap : wildfly - clustering - jgroups - spi :  % s \"  ,    version . getMavenGavVersion (  )  )  ,     \" jgroups : jgroups :  3  .  6  .  1  2  . Final - redhat -  1  \"     }  ;", "}", "METHOD_END"], "methodName": ["getJGroupsDependencies"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingDependencies"}, {"methodBody": ["METHOD_START", "{", "return    \" eap : wildfly - messaging - activemq :  \"     +     ( version . getMavenGavVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessagingActiveMQGAV"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingDependencies"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder (  )  ;", "for    ( String   kp    :    keyPrefix )     {", "if    (  ( prefix . length (  )  )     >     0  )     {", "prefix . append (  '  .  '  )  ;", "}", "prefix . append ( kp )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,     . RESOURCE _ NAME ,     . class . getClassLoader (  )  ,    true ,    useUnprefixedChildTypes )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingExtension"}, {"methodBody": ["METHOD_START", "{", "return   MessagingExtension . getResourceDescriptionResolver ( true ,    keyPrefix )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingExtension"}, {"methodBody": ["METHOD_START", "{", "container    =    Factory . create (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["setupContainer"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingPathsTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( container )     !  =    null )     {", "container . shutdown (  )  ;", "try    {", "container . awaitTerminat (  5  ,    TimeUnit . SECONDS )  ;", "}    catch    ( InterruptedExcept   e )     {", "e . printStackTrace (  )  ;", "}    finally    {", "container    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["shutdownContainer"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingPathsTestCase"}, {"methodBody": ["METHOD_START", "{", "PathManagerService   pathManagerService    =    new   PathManagerService (  )     {", "{", "super . addHardcodedAbsolutePath ( container ,    SERVER _ DATA _ DIR ,     . MY _ SERVER _ DATA _ DIR )  ;", "super . addHardcodedAbsolutePath ( container ,     . MY _ PAGING _ RELATIVE _ TO ,     . MY _ PAGING _ RELATIVE _ TO _ DIR )  ;", "}", "}  ;", "ActiveMQServerService . PathConfig   pathConfig    =    new   ActiveMQServerService . PathConfig (  . MY _ ABSOLUTE _ BINDINGS _ DIR ,    PathDefinition . DEFAULT _ RELATIVE _ TO ,     . MY _ RELATIVE _ JOURNAL _ DIR ,    PathDefinition . DEFAULT _ RELATIVE _ TO ,    PathDefinition . DEFAULT _ LARGE _ MESSAGE _ DIR ,    PathDefinition . DEFAULT _ RELATIVE _ TO ,    PathDefinition . DEFAULT _ PAGING _ DIR ,     . MY _ PAGING _ RELATIVE _ TO )  ;", "String   resolvedJournalPath    =    pathConfig . resolveJournalPath ( pathManagerService )  ;", "assertTrue (  (  (  (  \" the   specific   relative   path   must   be   prepended   by   the   resolved   default   relative - to ,    resolvedJournalPath =  \"     +    resolvedJournalPath )     +     \"  ,    MY _ SERVER _ DATA _ DIR \"  )     +     (  . MY _ SERVER _ DATA _ DIR )  )  ,    resolvedJournalPath . startsWith (  . MY _ SERVER _ DATA _ DIR )  )  ;", "assertTrue ( resolvedJournalPath . endsWith (  . MY _ RELATIVE _ JOURNAL _ DIR )  )  ;", "String   resolvedBindingsPath    =    pathConfig . resolveBindingsPath ( pathManagerService )  ;", "assertEquals (  (  \" the   speficic   absolute   path   must   not   be   prepended   by   the   resolved   default   relative - to ,    resolvedBindingsPath =  \"     +    resolvedBindingsPath )  ,     . MY _ ABSOLUTE _ BINDINGS _ DIR ,    resolvedBindingsPath )  ;", "String   resolvedPagingPath    =    pathConfig . resolvePagingPath ( pathManagerService )  ;", "assertTrue (  (  \" the   default   path   must   be   prepended   by   the   resolved   specific   relative - to ,    resolvedPagingPath =  \"     +    resolvedPagingPath )  ,    resolvedPagingPath . startsWith (  . MY _ PAGING _ RELATIVE _ TO _ DIR )  )  ;", "assertTrue ( resolvedPagingPath . endsWith ( PathDefinition . DEFAULT _ PAGING _ DIR )  )  ;", "String   resolvedLargeMessagePath    =    pathConfig . resolveLargeMessagePath ( pathManagerService )  ;", "assertTrue (  (  \" by   default ,    the   default   path   MUST   prepended   by   the   resolved   default   relative - to ,    resolvedLargeMessagePath =  \"     +    resolvedLargeMessagePath )  ,    resolvedLargeMessagePath . startsWith (  . MY _ SERVER _ DATA _ DIR )  )  ;", "assertTrue ( resolvedLargeMessagePath . endsWith ( PathDefinition . DEFAULT _ LARGE _ MESSAGE _ DIR )  )  ;", "}", "METHOD_END"], "methodName": ["testAddPath"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingPathsTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( pathAddress . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "PathElement   pe    =    pathAddress . getElement ( i )  ;", "if    ( CommonAttributes . SERVER . equals ( pe . getKey (  )  )  )     {", "return   pathAddress . subAddress (  0  ,     ( i    +     1  )  )  ;", "}", "}", "return   PathAddress . EMPTY _ ADDRESS ;", "}", "METHOD_END"], "methodName": ["getActiveMQServerPathAddress"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   MessagingServices . JBOSS _ MESSAGING _ ACTIVEMQ . append ( serverName )  ;", "}", "METHOD_END"], "methodName": ["getActiveMQServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "String   serverName    =    null ;", "PathAddress   serverPathAddress    =     . getActiveMQServerPathAddress ( pathAddress )  ;", "if    ( serverPathAddress    !  =    null )     {", "serverName    =    serverPathAddress . getLastElement (  )  . getValue (  )  ;", "}", "return    . JBOSS _ MESSAGING _ ACTIVEMQ . append ( serverName )  ;", "}", "METHOD_END"], "methodName": ["getActiveMQServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   MessagingServices . getActiveMQServiceName ( activemqServerName )  . append (  \" http - upgrade - service \"  ,    acceptorName )  ;", "}", "METHOD_END"], "methodName": ["getHttpUpgradeServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   MessagingServices . JBOSS _ MESSAGING _ ACTIVEMQ . append ( CommonAttributes . JMS _ BRIDGE )  . append ( bridgeName )  ;", "}", "METHOD_END"], "methodName": ["getJMSBridgeServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   MessagingServices . getActiveMQServiceName ( activemqServerName )  . append ( CommonAttributes . LEGACY ,     \" http - upgrade - service \"  ,    acceptorName )  ;", "}", "METHOD_END"], "methodName": ["getLegacyHttpUpgradeServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   serverServiceName . append ( CommonAttributes . QUEUE )  ;", "}", "METHOD_END"], "methodName": ["getQueueBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "builder . getAttributeBuilder (  )  . setValueConverter ( new   DefaultValueAttributeConverter ( attr )  ,    attr )  ;", "}", "METHOD_END"], "methodName": ["defaultValueAttributeConverter"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingTransformerRegistration"}, {"methodBody": ["METHOD_START", "{", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( subsystem ,    MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ THREAD _ POOL _ MAX _ SIZE ,    MessagingSubsystemRootResourceDefinition . GLOBAL _ CLIENT _ SCHEDULED _ THREAD _ POOL _ MAX _ SIZE )  ;", "ResourceTransformationDescriptionBuilder   server    =    subsystem . addChildResource ( MessagingExtension . SERVER _ PATH )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( server ,    ServerDefinition . ELYTRON _ DOMAIN ,    ServerDefinition . JOURNAL _ DATASOURCE ,    ServerDefinition . JOURNAL _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ JMS _ BINDINGS _ TABLE ,    ServerDefinition . JOURNAL _ LARGE _ MESSAGES _ TABLE ,    ServerDefinition . JOURNAL _ PAGE _ STORE _ TABLE ,    ServerDefinition . JOURNAL _ DATABASE ,    ServerDefinition . JOURNAL _ JDBC _ NETWORK _ TIMEOUT )  ;", "server . getAttributeBuilder (  )  . setDiscard ( ALWAYS ,    ServerDefinition . CREDENTIAL _ REFERENCE )  . addRejectCheck ( DEFINED ,    ServerDefinition . CREDENTIAL _ REFERENCE )  ;", "ResourceTransformationDescriptionBuilder   replicationMaster    =    server . addChildResource ( MessagingExtension . REPLICATION _ MASTER _ PATH )  ;", "replicationMaster . getAttributeBuilder (  )  . addRejectCheck ( UNDEFINED ,    HAAttributes . CHECK _ FOR _ LIVE _ SERVER )  ;", "ResourceTransformationDescriptionBuilder   replicationColocated    =    server . addChildResource ( MessagingExtension . REPLICATION _ COLOCATED _ PATH )  ;", "ResourceTransformationDescriptionBuilder   masterForReplicationColocated    =    replicationColocated . addChildResource ( MessagingExtension . CONFIGURATION _ MASTER _ PATH )  ;", "masterForReplicationColocated . getAttributeBuilder (  )  . addRejectCheck ( UNDEFINED ,    HAAttributes . CHECK _ FOR _ LIVE _ SERVER )  ;", "ResourceTransformationDescriptionBuilder   bridge    =    server . addChildResource ( MessagingExtension . BRIDGE _ PATH )  ;", "bridge . getAttributeBuilder (  )  . setDiscard ( ALWAYS ,    BridgeDefinition . CREDENTIAL _ REFERENCE )  . addRejectCheck ( DEFINED ,    BridgeDefinition . CREDENTIAL _ REFERENCE )  ;", "ResourceTransformationDescriptionBuilder   httpConnector    =    server . addChildResource ( MessagingExtension . HTTP _ CONNECTOR _ PATH )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( httpConnector ,    HTTPConnectorDefinition . SERVER _ NAME )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( bridge ,    BridgeDefinition . PRODUCER _ WINDOW _ SIZE )  ;", "ResourceTransformationDescriptionBuilder   jmsBridge    =    server . addChildResource ( MessagingExtension . JMS _ BRIDGE _ PATH )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( jmsBridge ,    JMSBridgeDefinition . SOURCE _ CREDENTIAL _ REFERENCE )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( jmsBridge ,    JMSBridgeDefinition . TARGET _ CREDENTIAL _ REFERENCE )  ;", "ResourceTransformationDescriptionBuilder   clusterConnection    =    server . addChildResource ( MessagingExtension . CLUSTER _ CONNECTION _ PATH )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( clusterConnection ,    ClusterConnectionDefinition . PRODUCER _ WINDOW _ SIZE )  ;", "ResourceTransformationDescriptionBuilder   connectionFactory    =    server . addChildResource ( MessagingExtension . CONNECTION _ FACTORY _ PATH )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( connectionFactory ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST )  ;", "MessagingTransformerRegistration . defaultValueAttributeConverter ( connectionFactory ,    CommonAttributes . CALL _ FAILOVER _ TIMEOUT )  ;", "ResourceTransformationDescriptionBuilder   pooledConnectionFactory    =    server . addChildResource ( MessagingExtension . POOLED _ CONNECTION _ FACTORY _ PATH )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( pooledConnectionFactory ,    ConnectionFactoryAttributes . Pooled . REBALANCE _ CONNECTIONS )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( pooledConnectionFactory ,    ConnectionFactoryAttributes . Pooled . STATISTICS _ ENABLED )  ;", "MessagingTransformerRegistration . defaultValueAttributeConverter ( pooledConnectionFactory ,    ConnectionFactoryAttributes . Pooled . MAX _ POOL _ SIZE )  ;", "MessagingTransformerRegistration . defaultValueAttributeConverter ( pooledConnectionFactory ,    CommonAttributes . CALL _ FAILOVER _ TIMEOUT )  ;", "MessagingTransformerRegistration . defaultValueAttributeConverter ( pooledConnectionFactory ,    ConnectionFactoryAttributes . Pooled . MIN _ POOL _ SIZE )  ;", "MessagingTransformerRegistration . rejectDefinedAttributeWithDefaultValue ( pooledConnectionFactory ,    ConnectionFactoryAttributes . Pooled . CREDENTIAL _ REFERENCE ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST ,    ConnectionFactoryAttributes . Pooled . ALLOW _ LOCAL _ TRANSACTIONS )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_EAP_7_0_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingTransformerRegistration"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   server    =    subsystem . addChildResource ( MessagingExtension . SERVER _ PATH )  ;", "server . addChildResource ( MessagingExtension . BROADCAST _ GROUP _ PATH )  . getAttributeBuilder (  )  . setDiscard ( new    . JGroupsChannelDiscardAttributeChecker (  )  ,    BroadcastGroupDefinition . JGROUPS _ CHANNEL )  . addRejectCheck ( DEFINED ,    BroadcastGroupDefinition . JGROUPS _ CHANNEL )  . addRename ( CommonAttributes . JGROUPS _ CLUSTER ,    CommonAttributes . JGROUPS _ CHANNEL . getName (  )  )  . end (  )  ;", "server . addChildResource ( DiscoveryGroupDefinition . PATH )  . getAttributeBuilder (  )  . setDiscard ( new    . JGroupsChannelDiscardAttributeChecker (  )  ,    DiscoveryGroupDefinition . JGROUPS _ CHANNEL )  . addRejectCheck ( DEFINED ,    DiscoveryGroupDefinition . JGROUPS _ CHANNEL )  . addRename ( CommonAttributes . JGROUPS _ CLUSTER ,    CommonAttributes . JGROUPS _ CHANNEL . getName (  )  )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_EAP_7_1_0"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingTransformerRegistration"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attr    :    attrs )     {", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( attr . getDefaultValue (  )  )  ,    attr )  . addRejectCheck ( DEFINED ,    attr )  ;", "}", "}", "METHOD_END"], "methodName": ["rejectDefinedAttributeWithDefaultValue"], "fileName": "org.wildfly.extension.messaging.activemq.MessagingTransformerRegistration"}, {"methodBody": ["METHOD_START", "{", "return   SimpleAttributeDefinitionBuilder . create ( attributeName ,    STRING )  . setRequired ( true )  . setValidator ( new   StringLengthValidator (  1  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createNonEmptyStringAttribute"], "fileName": "org.wildfly.extension.messaging.activemq.OperationDefinitionHelper"}, {"methodBody": ["METHOD_START", "{", "ModelNode   filter    =    CommonAttributes . FILTER . resolveModelAttribute ( context ,    operation )  ;", "return   filter . isDefined (  )     ?    filter . asString (  )     :    null ;", "}", "METHOD_END"], "methodName": ["resolveFilter"], "fileName": "org.wildfly.extension.messaging.activemq.OperationDefinitionHelper"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleOperationDefinitionBuilder ( operationName ,    resolver )  . setRuntimeOnly (  )  ;", "}", "METHOD_END"], "methodName": ["runtimeOnlyOperation"], "fileName": "org.wildfly.extension.messaging.activemq.OperationDefinitionHelper"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleOperationDefinitionBuilder ( operationName ,    resolver )  . setRuntimeOnly (  )  . setReadOnly (  )  ;", "}", "METHOD_END"], "methodName": ["runtimeReadOnlyOperation"], "fileName": "org.wildfly.extension.messaging.activemq.OperationDefinitionHelper"}, {"methodBody": ["METHOD_START", "{", "return   new   AttributeDefinition [  ]  {    PathDefinition . PATHS . get ( path )  ,    PathDefinition . RELATIVE _ TO    }  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.wildfly.extension.messaging.activemq.PathDefinition"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getMinOccurs"], "fileName": "org.wildfly.extension.messaging.activemq.PathDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( context . getProcessType (  )  . isServer (  )  )     {", "final   ResolvePathHandler   resolvePathHandler    =    Builder . of ( context . getPathManager (  )  )  . setPathAttribute (  . PATHS . get ( registry . getPathAddress (  )  . getLastElement (  )  . getValue (  )  )  )  . setRelativeToAttribute (  . RELATIVE _ TO )  . setCheckAbsolutePath ( true )  . build (  )  ;", "registry . registerOperationHandler ( resolvePathHandler . getOperationDefinition (  )  ,    resolvePathHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["registerResolveOperationHandler"], "fileName": "org.wildfly.extension.messaging.activemq.PathDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( context . isNormalServer (  )  )     {", "context . addStep ( new   OperationStepHandler (  )     {", "@ Override", "public   void   execute ( final   OperationContext   context ,    final   ModelNode   operation )    throws   OperationFailedException    {", "final   ServiceName   serviceName    =    MServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "OperationContext . RollbackHandler   rh ;", "if    ( controller    !  =    null )     {", "context . reloadRequired (  )  ;", "rh    =    RollbackHandler . REVERT _ RELOAD _ REQUIRED _ ROLLBACK _ HANDLER ;", "} else    {", "rh    =    RollbackHandler . NOOP _ ROLLBACK _ HANDLER ;", "}", "context . completeStep ( rh )  ;", "}", "}  ,    RUNTIME )  ;", "}", "}", "METHOD_END"], "methodName": ["reloadRequiredStep"], "fileName": "org.wildfly.extension.messaging.activemq.PathDefinition"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   prop    :    sql . keySet (  )  )     {", "int   dot    =     (  ( String )     ( prop )  )  . indexOf (  '  .  '  )  ;", "if    ( dot    >     0  )     {", "databaseDialects . add (  (  ( String )     ( prop )  )  . substring (  ( dot    +     1  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["extractDialects"], "fileName": "org.wildfly.extension.messaging.activemq.PropertySQLProviderFactory"}, {"methodBody": ["METHOD_START", "{", "String   unified    =    null ;", "if    ( name    !  =    null )     {", "if    ( name . toLowerCase (  )  . contains (  \" postgres \"  )  )     {", "unified    =     \" postgresql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" mysql \"  )  )     {", "unified    =     \" mysql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" db 2  \"  )  )     {", "unified    =     \" db 2  \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" derby \"  )  )     {", "unified    =     \" derby \"  ;", "} else", "if    (  ( name . toLowerCase (  )  . contains (  \" hsql \"  )  )     |  |     ( name . toLowerCase (  )  . contains (  \" hypersonic \"  )  )  )     {", "unified    =     \" hsql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" h 2  \"  )  )     {", "unified    =     \" h 2  \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  . ORACLE )  )     {", "unified    =     . ORACLE ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" microsoft \"  )  )     {", "unified    =     \" mssql \"  ;", "} else", "if    ( name . toLowerCase (  )  . contains (  \" jconnect \"  )  )     {", "unified    =     \" sybase \"  ;", "}", "}", "MessagingLogger . ROOT _ LOGGER . debugf (  \" Check   dialect   for    '  % s '  ,    result   is    '  % s '  \"  ,    name ,    unified )  ;", "return   unified ;", "}", "METHOD_END"], "methodName": ["identifyDialect"], "fileName": "org.wildfly.extension.messaging.activemq.PropertySQLProviderFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( database )     !  =    null )     {", "return ;", "}", "try    ( Connection   connection    =    dataSource . getConnection (  )  )     {", "DatabaseMetaData   metaData    =    connection . getMetaData (  )  ;", "String   dbProduct    =    metaData . getDatabaseProductName (  )  ;", "database    =    identifyDialect ( dbProduct )  ;", "if    (  ( database )     =  =    null )     {", "MLogger . ROOT _ LOGGER . debug (  \" Attempting   to   guess   on   driver   name .  \"  )  ;", "database    =    identifyDialect ( metaData . getDriverName (  )  )  ;", "}", "if    ( dataSource    =  =    null )     {", "MLogger . ROOT _ LOGGER . jdbcDatabaseDialectDetectionFailed ( databaseDialects . toString (  )  )  ;", "} else    {", "MLogger . ROOT _ LOGGER . debugf (  \" Detect   database   dialect   as    '  % s '  .       If   this   is   incorrect ,    please   specify   the   correct   dialect   using   the    ' database '    attribute   in   your   configuration .       Supported   database   dialect   strings   are    % s \"  ,    database ,    databaseDialects )  ;", "}", "}    catch    ( Exception   e )     {", "MLogger . ROOT _ LOGGER . debug (  \" Unable   to   read   JDBC   metadata .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["investigateDialect"], "fileName": "org.wildfly.extension.messaging.activemq.PropertySQLProviderFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( CommonAttributes . QUEUE )  )     {", "final   List < CoreQueueConfiguration >    configs    =    configuration . getQueueConfigurations (  )  ;", "for    ( Property   prop    :    model . get ( CommonAttributes . QUEUE )  . asPropertyList (  )  )     {", "configs . add (  . createCoreQueueConfiguration ( context ,    prop . getName (  )  ,    prop . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addQueueConfigs"], "fileName": "org.wildfly.extension.messaging.activemq.QueueAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   queueAddress    =    QueueDefinition . ADDRESS . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ModelNode   filterNode    =    CommonAttributes . FILTER . resolveModelAttribute ( context ,    model )  ;", "final   String   filter    =     ( filterNode . isDefined (  )  )     ?    filterNode . asString (  )     :    null ;", "final   boolean   durable    =    CommonAttributes . DURABLE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "return   new   CoreQueueConfiguration (  )  . setAddress ( queueAddress )  . setName ( name )  . setFilterString ( filter )  . setDurable ( durable )  ;", "}", "METHOD_END"], "methodName": ["createCoreQueueConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.QueueAdd"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceName   serviceName    =    MServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "ServiceController <  ?  >    serverService    =    registry . getService ( serviceName )  ;", "if    ( serverService    !  =    null )     {", "PathAddress   address    =    PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   String   queueName    =    address . getLastElement (  )  . getValue (  )  ;", "final   CoreQueueConfiguration   queueConfiguration    =    QueueAdd . createCoreQueueConfiguration ( context ,    queueName ,    model )  ;", "final   QueueService   service    =    new   QueueService ( queueConfiguration ,    false )  ;", "final   ServiceName   queueServiceName    =    MServices . getQueueBaseServiceName ( serviceName )  . append ( queueName )  ;", "context . getServiceTarget (  )  . addService ( queueServiceName ,    service )  . addDependency ( ActiveMQActivationService . getServiceName ( serviceName )  )  . addDependency ( serviceName ,    ActiveMQServer . class ,    service . getActiveMQServer (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.QueueAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( final   AttributeDefinition   attributeDefinition    :    QueueDefinition . ATTRIBUTES )     {", "attributeDefinition . validateAndSet ( operation ,    model )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.wildfly.extension.messaging.activemq.QueueAdd"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  ;", "if    ( CommonAttributes . RUNTIME _ QUEUE . equals ( address . getLastElement (  )  . getKey (  )  )  )     {", "return   false ;", "}", "String   queueName    =    address . getLastElement (  )  . getValue (  )  ;", "PathAddress   activeMQPathAddress    =    MServices . getActiveMQServerPathAddress ( address )  ;", "if    ( context . readResourceFromRoot ( activeMQPathAddress ,    false )  . hasChild ( address . getLastElement (  )  )  )     {", "return   false ;", "} else    {", "ModelNode   forwardOperation    =    operation . clone (  )  ;", "forwardOperation . get ( OP _ ADDR )  . set ( activeMQPathAddress . append ( CommonAttributes . RUNTIME _ QUEUE ,    queueName )  . toModelNode (  )  )  ;", "context . addStep ( forwardOperation ,    handler ,    RUNTIME ,    true )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["forwardToRuntimeQueue"], "fileName": "org.wildfly.extension.messaging.activemq.QueueDefinition"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    new   ArrayList < String >  (  )  ;", "for    ( SimpleDefinition   attr    :    QueueDefinition . ATTRIBUTES )     {", "names . add ( attr . getName (  )  )  ;", "}", "return   names ;", "}", "METHOD_END"], "methodName": ["getStorageAttributeNames"], "fileName": "org.wildfly.extension.messaging.activemq.QueueReadAttributeHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   String   name    =    address . getLastElement (  )  . getValue (  )  ;", "final   ServiceName   queueServiceName    =    MessagingServices . getQueueBaseServiceName ( serviceName )  . append ( name )  ;", "context . removeService ( queueServiceName )  ;", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.QueueRemove"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServer ;", "}", "METHOD_END"], "methodName": ["getActiveMQServer"], "fileName": "org.wildfly.extension.messaging.activemq.QueueService"}, {"methodBody": ["METHOD_START", "{", "return   new   RemoteTransportDefinition ( true ,    CommonAttributes . REMOTE _ ACCEPTOR ,    registerRuntimeOnly )  ;", "}", "METHOD_END"], "methodName": ["createAcceptorDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.RemoteTransportDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   RemoteTransportDefinition ( false ,    CommonAttributes . REMOTE _ CONNECTOR ,    registerRuntimeOnly )  ;", "}", "METHOD_END"], "methodName": ["createConnectorDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.RemoteTransportDefinition"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( true )  . getService ( serviceName )  ;", "if    ( controller    !  =    null )     {", "return   ActiveMQServer . class . cast ( controller . getValue (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.messaging.activemq.SecurityRoleAdd"}, {"methodBody": ["METHOD_START", "{", "return   SimpleAttributeDefinitionBuilder . create ( name ,    ModelType . BOOLEAN )  . setDefaultValue ( new   ModelNode ( false )  )  . setRequired ( false )  . setFlags ( RESTART _ NONE )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.wildfly.extension.messaging.activemq.SecurityRoleDefinition"}, {"methodBody": ["METHOD_START", "{", "SimpleAttributeDefinition [  ]    attrs    =    new   SimpleAttributeDefinition [  ( SecurityRoleDefinition . ATTRIBUTES . length )     +     1  ]  ;", "attrs [  0  ]     =    SecurityRoleDefinition . NAME ;", "System . arraycopy ( SecurityRoleDefinition . ATTRIBUTES ,     0  ,    attrs ,     1  ,    SecurityRoleDefinition . ATTRIBUTES . length )  ;", "return   Builder . of ( CommonAttributes . ROLE ,    attrs )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getObjectTypeAttributeDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.SecurityRoleDefinition"}, {"methodBody": ["METHOD_START", "{", "final   boolean   send    =    SecurityRoleDefinition . SEND . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "final   boolean   consume    =    SecurityRoleDefinition . CONSUME . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "final   boolean   createDurableQueue    =    SecurityRoleDefinition . CREATE _ DURABLE _ QUEUE . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "final   boolean   deleteDurableQueue    =    SecurityRoleDefinition . DELETE _ DURABLE _ QUEUE . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "final   boolean   createNonDurableQueue    =    SecurityRoleDefinition . CREATE _ NON _ DURABLE _ QUEUE . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "final   boolean   deleteNonDurableQueue    =    SecurityRoleDefinition . DELETE _ NON _ DURABLE _ QUEUE . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "final   boolean   manage    =    SecurityRoleDefinition . MANAGE . resolveModelAttribute ( context ,    node )  . asBoolean (  )  ;", "return   new   Role ( name ,    send ,    consume ,    createDurableQueue ,    deleteDurableQueue ,    createNonDurableQueue ,    deleteNonDurableQueue ,    manage )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.wildfly.extension.messaging.activemq.SecurityRoleDefinition"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelNode   role    :    roles . asList (  )  )     {", "if    ( role . get ( Commons . NAME )  . asString (  )  . equals ( roleName )  )     {", "return   role ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findRole"], "fileName": "org.wildfly.extension.messaging.activemq.SecurityRoleReadAttributeHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( true )  . getService ( serviceName )  ;", "if    ( controller    !  =    null )     {", "return   ActiveMQServer . class . cast ( controller . getValue (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.messaging.activemq.SecurityRoleRemove"}, {"methodBody": ["METHOD_START", "{", "if    ( server    !  =    null )     {", "final   Set < Role >    roles    =    server . getepository (  )  . getMatch ( match )  ;", "final   Set < Role >    newRoles    =    new   HashSet < Role >  (  )  ;", "for    ( final   Role   role    :    roles )     {", "if    (  !  ( roleName . equals ( role . getName (  )  )  )  )     {", "newRoles . add ( role )  ;", "}", "}", "server . getepository (  )  . addMatch ( match ,    newRoles )  ;", "}", "}", "METHOD_END"], "methodName": ["removeRole"], "fileName": "org.wildfly.extension.messaging.activemq.SecurityRoleRemove"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( true )  . getService ( serviceName )  ;", "if    ( controller    !  =    null )     {", "return   ActiveMQServer . class . cast ( controller . getValue (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.messaging.activemq.SecuritySettingAdd"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( true )  . getService ( serviceName )  ;", "if    ( controller    !  =    null )     {", "return   ActiveMQServer . class . cast ( controller . getValue (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.messaging.activemq.SecuritySettingRemove"}, {"methodBody": ["METHOD_START", "{", "for    ( BridgeConfiguration   bridgeConfiguration    :    configuration . getBridgeConfigurations (  )  )     {", "String   name    =    bridgeConfiguration . getName (  )  ;", "InjectedValue < ExceptionSupplier < CredentialSource ,    Exception >  >    injector    =    amqService . getBridgeCredentialSourceSupplierInjector ( name )  ;", "String [  ]    modelFilter    =    new   String [  ]  {    CommonAttributes . BRIDGE ,    name    }  ;", "ModelNode   filteredModelNode    =    model ;", "if    (  ( modelFilter    !  =    null )     &  &     (  ( modelFilter . length )     >     0  )  )     {", "for    ( String   path    :    modelFilter )     {", "if    ( filteredModelNode . get ( path )  . isDefined (  )  )", "filteredModelNode    =    filteredModelNode . get ( path )  ;", "else", "break ;", "}", "}", "ModelNode   value    =    credentialReferenceAttributeDefinition . resolveModelAttribute ( context ,    filteredModelNode )  ;", "if    ( value . isDefined (  )  )     {", "injector . inject ( CredentialReference . getCredentialSourceSupplier ( context ,    credentialReferenceAttributeDefinition ,    filteredModelNode ,    serviceBuilder )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBridgeCredentialStoreReference"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "ModelNode   value    =    credentialReferenceAttributeDefinition . resolveModelAttribute ( context ,    model )  ;", "if    ( value . isDefined (  )  )     {", "amqService . getClusterCredentialSourceSupplierInjector (  )  . inject ( CredentialReference . getCredentialSourceSupplier ( context ,    credentialReferenceAttributeDefinition ,    model ,    serviceBuilder )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addClusterCredentialStoreReference"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "List < String >    definedAttributes    =    new   ArrayList <  >  (  )  ;", "for    ( AttributeDefinition   attr    :    attrs )     {", "if    ( model . get ( attr . getName (  )  )  . isDefined (  )  )     {", "definedAttributes . add ( attr . getName (  )  )  ;", "}", "}", "if    (  !  ( definedAttributes . isEmpty (  )  )  )     {", "MLogger . ROOT _ LOGGER . invalidConfiguration ( address ,    definedAttributeName ,    definedAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNoAttributesIsDefined"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "Resource   root    =    context . readResourceFromRoot ( EMPTY _ ADDRESS )  ;", "for    ( Resource . ResourceEntry   resource    :    root . getChildren ( SOCKET _ BINDING _ GROUP )  )     {", "if    ( resource . getChildrenNames ( SOCKET _ BINDING )  . contains ( name )  )     {", "return   false ;", "} else", "if    (  ( resource . getChildrenNames ( ModelDescriptionConstants . LOCAL _ DESTINATION _ OUTBOUND _ SOCKET _ BINDING )  . contains ( name )  )     |  |     ( resource . getChildrenNames ( ModelDescriptionConstants . REMOTE _ DESTINATION _ OUTBOUND _ SOCKET _ BINDING )  . contains ( name )  )  )", "return   true ;", "}", "throw   MLogger . ROOT _ LOGGER . noSocketBinding ( name )  ;", "}", "METHOD_END"], "methodName": ["isOutBoundSocketBinding"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "if    ( params . hasDefined ( CommonAttributes . ADDRESS _ SETTING )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . ADDRESS _ SETTING )  . asPropertyList (  )  )     {", "final   String   match    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   AddressSettings   settings    =    AddressSettingAdd . createSettings ( context ,    config )  ;", "configuratgetAddressesSettings (  )  . put ( match ,    settings )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processAddressSettings"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )     {", "return ;", "}", "List < ModelNode >    interceptors    =    model . asList (  )  ;", "for    ( Class   clazz    :    unwrapClasses ( interceptors )  )     {", "try    {", "Interceptor   interceptor    =    Interceptor . class . cast ( clazz . newInstance (  )  )  ;", "sService . getIncomingInterceptors (  )  . add ( interceptor )  ;", "}    catch    ( Exception   e )     {", "throw   new   OperationFailedException ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processIncomingInterceptors"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )     {", "return ;", "}", "List < ModelNode >    interceptors    =    model . asList (  )  ;", "for    ( Class   clazz    :    unwrapClasses ( interceptors )  )     {", "try    {", "Interceptor   interceptor    =    Interceptor . class . cast ( clazz . newInstance (  )  )  ;", "sService . getOutgoingInterceptors (  )  . add ( interceptor )  ;", "}    catch    ( Exception   e )     {", "throw   new   OperationFailedException ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processOutgoingInterceptors"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "if    ( params . get ( CommonAttributes . SECURITY _ SETTING )  . isDefined (  )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . SECURITY _ SETTING )  . asPropertyList (  )  )     {", "final   String   match    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "if    ( config . hasDefined ( CommonAttributes . ROLE )  )     {", "final   Set < Role >    roles    =    new   HashSet < Role >  (  )  ;", "for    ( final   Property   role    :    config . get ( CommonAttributes . ROLE )  . asPropertyList (  )  )     {", "roles . add ( SecurityRoleDefinittransform ( context ,    role . getName (  )  ,    role . getValue (  )  )  )  ;", "}", "configuratgetSecurityRoles (  )  . put ( match ,    roles )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processSecuritySettings"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "ModelNode   journalDataSource    =    ServerDefinition . JOURNAL _ DATASOURCE . resolveModelAttribute ( context ,    model )  ;", "if    (  !  ( journalDataSource . isDefined (  )  )  )     {", "return ;", "}", "DatabaseStorageConfiguration   storageConfiguration    =    new   DatabaseStorageConfiguration (  )  ;", "storageConfiguration . setBindingsTableName ( ServerDefinition . JOURNAL _ BINDINGS _ TABLE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "storageConfiguration . setJMSBindingsTableName ( ServerDefinition . JOURNAL _ JMS _ BINDINGS _ TABLE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "storageConfiguration . setMessageTableName ( ServerDefinition . JOURNAL _ MESSAGES _ TABLE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "storageConfiguration . setLargeMessageTableName ( ServerDefinition . JOURNAL _ LARGE _ MESSAGES _ TABLE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "storageConfiguration . setPageStoreTableName ( ServerDefinition . JOURNAL _ PAGE _ STORE _ TABLE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "storageConfiguration . setJdbcNetworkTimeout ( ServerDefinition . JOURNAL _ JDBC _ NETWORK _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "ModelNode   databaseNode    =    ServerDefinition . JOURNAL _ DATABASE . resolveModelAttribute ( context ,    model )  ;", "final   String   database    =     ( databaseNode . isDefined (  )  )     ?    databaseNode . asString (  )     :    null ;", "try    {", "storageConfiguration . setSqlProvider ( new   PropertySQLProviderFactory ( database )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   OperationFailedException ( e )  ;", "}", "configuration . setStoreConfiguration ( storageConfiguration )  ;", "}", "METHOD_END"], "methodName": ["processStorageConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "Configuration   configuration    =    new   ConfigurationImpl (  )  ;", "configuration . setName ( serverName )  ;", "configuration . setEnabledAsyncConnectionExecution ( ServerDefinition . ASYNC _ CONNECTION _ EXECUTION _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setClusterPassword ( ServerDefinition . CLUSTER _ PASSWORD . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "configuration . setClusterUser ( ServerDefinition . CLUSTER _ USER . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "configuration . setConnectionTTLOverride ( ServerDefinition . CONNECTION _ TTL _ OVERRIDE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setCreateBindingsDir ( ServerDefinition . CREATE _ BINDINGS _ DIR . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setCreateJournalDir ( ServerDefinition . CREATE _ JOURNAL _ DIR . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setIDCacheSize ( ServerDefinition . ID _ CACHE _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setJMXDomain ( ServerDefinition . JMX _ DOMAIN . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "configuration . setJMXManagementEnabled ( ServerDefinition . JMX _ MANAGEMENT _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "final   JournalType   journalType    =    JournalType . valueOf ( ServerDefinition . JOURNAL _ TYPE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "configuration . setJournalType ( journalType )  ;", "configuration . setJournalBufferSize _ AIO ( ServerDefinition . JOURNAL _ BUFFER _ SIZE . resolveModelAttribute ( context ,    model )  . asInt ( ActiveMQDefaultConfiguration . getDefaultJournalBufferSizeAio (  )  )  )  ;", "configuration . setJournalBufferTimeout _ AIO ( ServerDefinition . JOURNAL _ BUFFER _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asInt ( ActiveMQDefaultConfiguration . getDefaultJournalBufferTimeoutAio (  )  )  )  ;", "configuration . setJournalMaxIO _ AIO ( ServerDefinition . JOURNAL _ MAX _ IO . resolveModelAttribute ( context ,    model )  . asInt ( ActiveMQDefaultConfiguration . getDefaultJournalMaxIoAio (  )  )  )  ;", "configuration . setJournalBufferSize _ NIO ( ServerDefinition . JOURNAL _ BUFFER _ SIZE . resolveModelAttribute ( context ,    model )  . asInt ( ActiveMQDefaultConfiguration . getDefaultJournalBufferSizeNio (  )  )  )  ;", "configuration . setJournalBufferTimeout _ NIO ( ServerDefinition . JOURNAL _ BUFFER _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asInt ( ActiveMQDefaultConfiguration . getDefaultJournalBufferTimeoutNio (  )  )  )  ;", "configuration . setJournalMaxIO _ NIO ( ServerDefinition . JOURNAL _ MAX _ IO . resolveModelAttribute ( context ,    model )  . asInt ( ActiveMQDefaultConfiguration . getDefaultJournalMaxIoNio (  )  )  )  ;", "configuration . setJournalCompactMinFiles ( ServerDefinition . JOURNAL _ COMPACT _ MIN _ FILES . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setJournalCompactPercentage ( ServerDefinition . JOURNAL _ COMPACT _ PERCENTAGE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setJournalFileSize ( ServerDefinition . JOURNAL _ FILE _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setJournalMinFiles ( ServerDefinition . JOURNAL _ MIN _ FILES . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setJournalPoolFiles ( ServerDefinition . JOURNAL _ POOL _ FILES . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setJournalSyncNonTransactional ( ServerDefinition . JOURNAL _ SYNC _ NON _ TRANSACTIONAL . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setJournalSyncTransactional ( ServerDefinition . JOURNAL _ SYNC _ TRANSACTIONAL . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setLogJournalWriteRate ( ServerDefinition . LOG _ JOURNAL _ WRITE _ RATE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setManagementAddress ( SimpleString . toSimpleString ( ServerDefinition . MANAGEMENT _ ADDRESS . resolveModelAttribute ( context ,    model )  . asString (  )  )  )  ;", "configuration . setManagementNotificationAddress ( SimpleString . toSimpleString ( ServerDefinition . MANAGEMENT _ NOTIFICATION _ ADDRESS . resolveModelAttribute ( context ,    model )  . asString (  )  )  )  ;", "configuration . setMemoryMeasureInterval ( ServerDefinition . MEMORY _ MEASURE _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "configuration . setMemoryWarningThreshold ( ServerDefinition . MEMORY _ WARNING _ THRESHOLD . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setMessageCounterEnabled ( ServerDefinition . STATISTICS _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setMessageCounterSamplePeriod ( ServerDefinition . MESSAGE _ COUNTER _ SAMPLE _ PERIOD . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setMessageCounterMaxDayHistory ( ServerDefinition . MESSAGE _ COUNTER _ MAX _ DAY _ HISTORY . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setMessageExpiryScanPeriod ( ServerDefinition . MESSAGE _ EXPIRY _ SCAN _ PERIOD . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "configuration . setMessageExpiryThreadPriority ( ServerDefinition . MESSAGE _ EXPIRY _ THREAD _ PRIORITY . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setJournalPerfBlastPages ( ServerDefinition . PERF _ BLAST _ PAGES . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setPersistDeliveryCountBeforeDelivery ( ServerDefinition . PERSIST _ DELIVERY _ COUNT _ BEFORE _ DELIVERY . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setPageMaxConcurrentIO ( ServerDefinition . PAGE _ MAX _ CONCURRENT _ IO . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setPersistenceEnabled ( ServerDefinition . PERSISTENCE _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setPersistIDCache ( ServerDefinition . PERSIST _ ID _ CACHE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setRunSyncSpeedTest ( ServerDefinition . RUN _ SYNC _ SPEED _ TEST . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setScheduledThreadPoolMaxSize ( ServerDefinition . SCHEDULED _ THREAD _ POOL _ MAX _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setSecurityEnabled ( ServerDefinition . SECURITY _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "configuration . setSecurityInvalidationInterval ( ServerDefinition . SECURITY _ INVALIDATION _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "configuration . setServerDumpInterval ( ServerDefinition . SERVER _ DUMP _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "configuration . setThreadPoolMaxSize ( ServerDefinition . THREAD _ POOL _ MAX _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "configuration . setTransactionTimeout ( ServerDefinition . TRANSACTION _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "configuration . setTransactionTimeoutScanPeriod ( ServerDefinition . TRANSACTION _ TIMEOUT _ SCAN _ PERIOD . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "configuration . setWildcardRoutingEnabled ( ServerDefinition . WILD _ CARD _ ROUTING _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", ". processStorageConfiguration ( context ,    model ,    configuration )  ;", "HAPolicyConfigurationBuilder . addHAPolicyConfiguration ( context ,    configuration ,    model )  ;", ". processAddressSettings ( context ,    configuration ,    model )  ;", ". processSecuritySettings ( context ,    configuration ,    model )  ;", "GroupingHandlerAdd . addGroupingHandlerConfig ( context ,    configuration ,    model )  ;", "DiscoveryGroupAdd . addDiscoveryGroupConfigs ( context ,    configuration ,    model )  ;", "DivertAdd . addDivertConfigs ( context ,    configuration ,    model )  ;", "QueueAdd . addQueueConfigs ( context ,    configuration ,    model )  ;", "BridgeAdd . addBridgeConfigs ( context ,    configuration ,    model )  ;", "ClusterConnectionAdd . addClusterConnectionConfigs ( context ,    configuration ,    model )  ;", "ConnectorServiceDefinition . addConnectorServiceConfigs ( context ,    configuration ,    model )  ;", "return   configuration ;", "}", "METHOD_END"], "methodName": ["transformConfig"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "String   className    =    classModel . get ( CommonAttributes . NAME )  . asString (  )  ;", "String   moduleName    =    classModel . get ( CommonAttributes . MODULE )  . asString (  )  ;", "try    {", "ModuleIdentifier   moduleID    =    ModuleIdentifier . fromString ( moduleName )  ;", "Module   module    =    Module . getCallerModuleLoader (  )  . loadModule ( moduleID )  ;", "Class <  ?  >    clazz    =    module . getClassLoader (  )  . loadClass ( className )  ;", "return   clazz ;", "}    catch    ( Exception   e )     {", "throw   MLogger . ROOT _ LOGGER . unableToLoadClassFromModule ( className ,    moduleName )  ;", "}", "}", "METHOD_END"], "methodName": ["unwrapClass"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "List < Class >    classes    =    new   ArrayList <  >  (  )  ;", "for    ( ModelNode   classModel    :    classesModel )     {", "Class <  ?  >    clazz    =     . unwrapClass ( classModel )  ;", "classes . add ( clazz )  ;", "}", "return   classes ;", "}", "METHOD_END"], "methodName": ["unwrapClasses"], "fileName": "org.wildfly.extension.messaging.activemq.ServerAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add (  \" subsystem \"  ,     \"  - activemq \"  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( OP )  . set ( READ _ RESOURCE _ DESCRIPTION _ OPERATION )  ;", "operation . get ( OP _ ADDR )  . set ( address )  ;", "operation . get ( RECURSIVE )  . set ( true )  ;", "operation . get ( OPERATIONS )  . set ( true )  ;", "operation . get ( INHERITED )  . set ( false )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createReadResourceDescriptionOperation"], "fileName": "org.wildfly.extension.messaging.activemq.SubsystemDescriptionsUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    empty    =    Collections . emptyList (  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( null )  . setBootOperations ( empty )  . build (  )  ;", "final   ModelNode   operation    =     . createReadResourceDescriptionOperation (  )  ;", "final   ModelNode   result    =    servicesA . executeOperation ( operation )  ;", "Assert . assertEquals ( SUCCESS ,    result . get ( OUTCOME )  . asString (  )  )  ;", "servicesA . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystemDescriptions"], "fileName": "org.wildfly.extension.messaging.activemq.SubsystemDescriptionsUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    fromModel    =    CommonAttributes . PARAMS . unwrap ( context ,    config )  ;", "Map < String ,    Object >    parameters    =    new   HashMap <  >  (  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    fromModel . entrySet (  )  )     {", "String   key    =    entry . getKey (  )  ;", "String   value    =    entry . getValue (  )  ;", "parameters . put ( mapping . getOrDefault ( key ,    key )  ,    value )  ;", "}", "return   parameters ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "org.wildfly.extension.messaging.activemq.TransportConfigOperationHandlers"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    TransportConfiguration >    acceptors    =    new   HashMap < String ,    TransportConfiguration >  (  )  ;", "if    ( params . hasDefined ( CommonAttributes . ACCEPTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . ACCEPTOR )  . asPropertyList (  )  )     {", "final   String   acceptorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . ACCEPTOR _ KEYS _ MAP )  ;", "final   String   clazz    =    config . get ( CommonAttributes . FACTORY _ CLASS . getName (  )  )  . asString (  )  ;", "ModelNode   socketBinding    =    GenericTransportDefinition . SOCKET _ BINDING . resolveModelAttribute ( context ,    config )  ;", "if    ( socketBinding . isDefined (  )  )     {", "bindings . add ( socketBinding . asString (  )  )  ;", "parameters . put ( GenericTransportDefinition . SOCKET _ BINDING . getName (  )  ,    socketBinding . asString (  )  )  ;", "}", "acceptors . put ( acceptorName ,    new   TransportConfiguration ( clazz ,    parameters ,    acceptorName )  )  ;", "}", "}", "if    ( params . hasDefined ( CommonAttributes . REMOTE _ ACCEPTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . REMOTE _ ACCEPTOR )  . asPropertyList (  )  )     {", "final   String   acceptorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . ACCEPTOR _ KEYS _ MAP )  ;", "final   String   binding    =    config . get ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  )  . asString (  )  ;", "bindings . add ( binding )  ;", "parameters . put ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  ,    binding )  ;", "acceptors . put ( acceptorName ,    new   TransportConfiguration ( NettyAcceptorFactory . class . getName (  )  ,    parameters ,    acceptorName )  )  ;", "}", "}", "if    ( params . hasDefined ( CommonAttributes . IN _ VM _ ACCEPTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . IN _ VM _ ACCEPTOR )  . asPropertyList (  )  )     {", "final   String   acceptorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . ACCEPTOR _ KEYS _ MAP )  ;", "parameters . put ( TransportConstants . SERVER _ ID _ PROP _ NAME ,    InVMTransportDefinition . SERVER _ ID . resolveModelAttribute ( context ,    config )  . asInt (  )  )  ;", "acceptors . put ( acceptorName ,    new   TransportConfiguration ( InVMAcceptorFactory . class . getName (  )  ,    parameters ,    acceptorName )  )  ;", "}", "}", "if    ( params . hasDefined ( CommonAttributes . HTTP _ ACCEPTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . HTTP _ ACCEPTOR )  . asPropertyList (  )  )     {", "final   String   acceptorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . ACCEPTOR _ KEYS _ MAP )  ;", "parameters . put ( HTTP _ UPGRADE _ ENABLED _ PROP _ NAME ,    true )  ;", "acceptors . put ( acceptorName ,    new   TransportConfiguration ( NettyAcceptorFactory . class . getName (  )  ,    parameters ,    acceptorName )  )  ;", "}", "}", "configuration . setAcceptorConfigurations ( new   HashSet < TransportConfiguration >  ( acceptors . values (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["processAcceptors"], "fileName": "org.wildfly.extension.messaging.activemq.TransportConfigOperationHandlers"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    TransportConfiguration >    connectors    =    new   HashMap < String ,    TransportConfiguration >  (  )  ;", "if    ( params . hasDefined ( CommonAttributes . CONNECTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . CONNECTOR )  . asPropertyList (  )  )     {", "final   String   connectorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . CONNECTORS _ KEYS _ MAP )  ;", "ModelNode   socketBinding    =    GenericTransportDefinition . SOCKET _ BINDING . resolveModelAttribute ( context ,    config )  ;", "if    ( socketBinding . isDefined (  )  )     {", "bindings . add ( socketBinding . asString (  )  )  ;", "parameters . put ( GenericTransportDefinition . SOCKET _ BINDING . getName (  )  ,    socketBinding . asString (  )  )  ;", "}", "final   String   clazz    =    CommonAttributes . FACTORY _ CLASS . resolveModelAttribute ( context ,    config )  . asString (  )  ;", "connectors . put ( connectorName ,    new   TransportConfiguration ( clazz ,    parameters ,    connectorName )  )  ;", "}", "}", "if    ( params . hasDefined ( CommonAttributes . REMOTE _ CONNECTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . REMOTE _ CONNECTOR )  . asPropertyList (  )  )     {", "final   String   connectorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . CONNECTORS _ KEYS _ MAP )  ;", "final   String   binding    =    config . get ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  )  . asString (  )  ;", "bindings . add ( binding )  ;", "parameters . put ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  ,    binding )  ;", "connectors . put ( connectorName ,    new   TransportConfiguration ( NettyConnectorFactory . class . getName (  )  ,    parameters ,    connectorName )  )  ;", "}", "}", "if    ( params . hasDefined ( CommonAttributes . IN _ VM _ CONNECTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . IN _ VM _ CONNECTOR )  . asPropertyList (  )  )     {", "final   String   connectorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . CONNECTORS _ KEYS _ MAP )  ;", "parameters . put (  . CONNECTORS _ KEYS _ MAP . get ( InVMTransportDefinition . SERVER _ ID . getName (  )  )  ,    InVMTransportDefinition . SERVER _ ID . resolveModelAttribute ( context ,    config )  . asInt (  )  )  ;", "connectors . put ( connectorName ,    new   TransportConfiguration ( InVMConnectorFactory . class . getName (  )  ,    parameters ,    connectorName )  )  ;", "}", "}", "if    ( params . hasDefined ( CommonAttributes . HTTP _ CONNECTOR )  )     {", "for    ( final   Property   property    :    params . get ( CommonAttributes . HTTP _ CONNECTOR )  . asPropertyList (  )  )     {", "final   String   connectorName    =    property . getName (  )  ;", "final   ModelNode   config    =    property . getValue (  )  ;", "final   Map < String ,    Object >    parameters    =     . getParameters ( context ,    config ,     . CONNECTORS _ KEYS _ MAP )  ;", "final   String   binding    =    HTTPConnectorDefinition . SOCKET _ BINDING . resolveModelAttribute ( context ,    config )  . asString (  )  ;", "bindings . add ( binding )  ;", "parameters . put ( HTTP _ UPGRADE _ ENABLED _ PROP _ NAME ,    true )  ;", "parameters . put ( HTTP _ UPGRADE _ ENDPOINT _ PROP _ NAME ,    HTTPConnectorDefinition . ENDPOINT . resolveModelAttribute ( context ,    config )  . asString (  )  )  ;", "parameters . put ( HTTPConnectorDefinition . SOCKET _ BINDING . getName (  )  ,    binding )  ;", "ModelNode   serverNameModelNode    =    HTTPConnectorDefinition . SERVER _ NAME . resolveModelAttribute ( context ,    config )  ;", "String   serverName    =     ( serverNameModelNode . isDefined (  )  )     ?    serverNameModelNode . asString (  )     :    configuration . getName (  )  ;", "parameters . put ( TransportConstants . ACTIVEMQ _ SERVER _ NAME ,    serverName )  ;", "connectors . put ( connectorName ,    new   TransportConfiguration ( NettyConnectorFactory . class . getName (  )  ,    parameters ,    connectorName )  )  ;", "}", "}", "configuration . setConnectorConfigurations ( connectors )  ;", "}", "METHOD_END"], "methodName": ["processConnectors"], "fileName": "org.wildfly.extension.messaging.activemq.TransportConfigOperationHandlers"}, {"methodBody": ["METHOD_START", "{", "this . dispatcher    =    this . factory . createCommandDispatcher ( this . name ,    this . manager )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.wildfly.extension.messaging.activemq.broadcast.CommandDispatcherBroadcastEndpoint"}, {"methodBody": ["METHOD_START", "{", "final   JMSConnectionFactoryDefinitionInjectionSource   source    =    new   JMSConnectionFactoryDefinitionInjectionSource ( metadata . getName (  )  )  ;", "source . setInterfaceName ( metadata . getInterfaceName (  )  )  ;", "source . setClassName ( metadata . getClassName (  )  )  ;", "source . setResourceAdapter ( metadata . getResourceAdapter (  )  )  ;", "source . setUser ( metadata . getUser (  )  )  ;", "source . setPassword ( metadata . getPassword (  )  )  ;", "source . setClientId ( metadata . getClientId (  )  )  ;", "source . addProperties ( metadata . getProperties (  )  )  ;", "source . setTransactional ( metadata . isTransactional (  )  )  ;", "source . setMaxPoolSize ( metadata . getMaxPoolSize (  )  )  ;", "source . setMinPoolSize ( metadata . getMinPoolSize (  )  )  ;", "return   source ;", "}", "METHOD_END"], "methodName": ["getResourceDefinitionInjectionSource"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "Set < String >    attributeNames    =    PooledConnectionFactoryDefinition . getAttributesMap (  )  . keySet (  )  ;", "final   Iterator < Map . Entry < String ,    String >  >    it    =    props . entrySet (  )  . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "final   Map . Entry < String ,    String >    entry    =    it . next (  )  ;", "String   value    =    entry . getKey (  )  ;", "if    (  ( value    =  =    null )     |  |     (  \"  \"  . equals ( value )  )  )     {", "it . remove (  )  ;", "} else", "if    (  !  ( attributeNames . contains ( entry . getKey (  )  )  )  )     {", "logging . MessagingLogger . ROOT _ LOGGER . unknownPooledConnectionFactoryAttribute ( entry . getKey (  )  )  ;", "it . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clearUnknownProperties"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   properties . containsKey ( CommonAttributes . SERVER )     ?    properties . get ( CommonAttributes . SERVER )     :    CommonAttributes . DEFAULT ;", "}", "METHOD_END"], "methodName": ["getActiveMQServerName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ConnectionFactoryAttribute >    attributes    =    PooledConnectionFactoryDefinition . getAttributesMap (  )  ;", "List < PooledConnectionFactoryConfigProperties >    props    =    new   ArrayList <  >  (  )  ;", "for    ( Property   property    :    model . asPropertyList (  )  )     {", "ConnectionFactoryAttribute   attribute    =    attributes . get ( property . getName (  )  )  ;", "if    (  ( attribute . getPropertyName (  )  )     =  =    null )     {", "continue ;", "}", "props . add ( new   PooledConnectionFactoryConfigProperties ( attribute . getPropertyName (  )  ,    property . getValue (  )  . asString (  )  ,    attribute . getClassType (  )  ,    attribute . getConfigType (  )  )  )  ;", "}", "return   props ;", "}", "METHOD_END"], "methodName": ["getAdapterParams"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "List < String >    connectors    =    new   ArrayList <  >  (  )  ;", "if    ( props . containsKey ( CommonAttributes . CONNECTORS )  )     {", "String   connectorsStr    =    properties . remove ( CommonAttributes . CONNECTORS )  ;", "for    ( String   s    :    connectorsStr . split (  \"  ,  \"  )  )     {", "String   connector    =    s . trim (  )  ;", "if    (  !  ( connector . isEmpty (  )  )  )     {", "connectors . add ( connector )  ;", "}", "}", "}", "return   connectors ;", "}", "METHOD_END"], "methodName": ["getConnectors"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   uniqueName    =    new   StringBuilder (  )  ;", "uniqueName . append (  (  ( context . getModuleName (  )  )     +     \"  _  \"  )  )  ;", "if    (  ( context . getComponentName (  )  )     !  =    null )     {", "uniqueName . append (  (  ( context . getComponentName (  )  )     +     \"  _  \"  )  )  ;", "}", "return   uniqueName . append ( jndiName . replace (  '  :  '  ,     '  _  '  )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["managementName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . className    =    className ;", "}", "METHOD_END"], "methodName": ["setClassName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . clientId    =    clientId ;", "}", "METHOD_END"], "methodName": ["setClientId"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . interfaceName    =    interfaceName ;", "}", "METHOD_END"], "methodName": ["setInterfaceName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . maxPoolSize    =    maxPoolSize ;", "}", "METHOD_END"], "methodName": ["setMaxPoolSize"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . minPoolSize    =    minPoolSize ;", "}", "METHOD_END"], "methodName": ["setMinPoolSize"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . resourceAdapter    =    resourceAdapter ;", "}", "METHOD_END"], "methodName": ["setResourceAdapter"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . transactional    =    transactional ;", "}", "METHOD_END"], "methodName": ["setTransactional"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . user    =    user ;", "}", "METHOD_END"], "methodName": ["setUser"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    props    =    new   HashMap ( properties )  ;", "List < String >    connectors    =    getConnectors ( props )  ;", "clearUnknownProperties ( properties )  ;", "ModelNode   model    =    new   ModelNode (  )  ;", "for    ( String   connector    :    connectors )     {", "model . get ( CommonAttributes . CONNECTORS )  . add ( connector )  ;", "}", "for    ( Map . Entry < String ,    String >    entry    :    properties . entrySet (  )  )     {", "model . get ( entry . getKey (  )  )  . set ( entry . getValue (  )  )  ;", "}", "model . get ( ConnectionFactoryAttributes . Pooled . MIN _ POOL _ SIZE . getName (  )  )  . set ( minPoolSize )  ;", "model . get ( ConnectionFactoryAttributes . Pooled . MAX _ POOL _ SIZE . getName (  )  )  . set ( maxPoolSize )  ;", "if    (  (  ( user )     !  =    null )     &  &     (  !  ( user . isEmpty (  )  )  )  )     {", "model . get ( ConnectionFactoryAttributes . Pooled . USER . getName (  )  )  . set ( user )  ;", "}", "if    (  (  ( password )     !  =    null )     &  &     (  !  ( password . isEmpty (  )  )  )  )     {", "model . get ( ConnectionFactoryAttributes . Pooled . PASSWORD . getName (  )  )  . set ( password )  ;", "}", "if    (  (  ( clientId )     !  =    null )     &  &     (  !  ( clientId . isEmpty (  )  )  )  )     {", "model . get ( CommonAttributes . CLIENT _ ID . getName (  )  )  . set ( clientId )  ;", "}", "final   String   discoveryGroupName    =     ( properties . containsKey ( ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP . getName (  )  )  )     ?    properties . get ( ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP . getName (  )  )     :    null ;", "if    ( discoveryGroupName    !  =    null )     {", "model . get ( ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP . getName (  )  )  . set ( discoveryGroupName )  ;", "}", "final   String   jgroupsChannelName    =     ( properties . containsKey ( CommonAttributes . JGROUPS _ CLUSTER . getName (  )  )  )     ?    properties . get ( CommonAttributes . JGROUPS _ CLUSTER . getName (  )  )     :    null ;", "if    ( jgroupsChannelName    !  =    null )     {", "model . get ( CommonAttributes . JGROUPS _ CLUSTER . getName (  )  )  . set ( jgroupsChannelName )  ;", "}", "final   String   managedConnectionPoolClassName    =     ( properties . containsKey ( ConnectionFactoryAttributes . Pooled . MANAGED _ CONNECTION _ POOL . getName (  )  )  )     ?    properties . get ( ConnectionFactoryAttributes . Pooled . MANAGED _ CONNECTION _ POOL . getName (  )  )     :    null ;", "if    ( managedConnectionPoolClassName    !  =    null )     {", "model . get ( ConnectionFactoryAttributes . Pooled . MANAGED _ CONNECTION _ POOL . getName (  )  )  . set ( managedConnectionPoolClassName )  ;", "}", "final   Boolean   enlistmentTrace    =     ( properties . containsKey ( ConnectionFactoryAttributes . Pooled . ENLISTMENT _ TRACE . getName (  )  )  )     ?    Boolean . valueOf ( properties . get ( ConnectionFactoryAttributes . Pooled . ENLISTMENT _ TRACE . getName (  )  )  )     :    null ;", "List < PooledConnectionFactoryConfigProperties >    adapterParams    =    getAdapterParams ( model )  ;", "String   txSupport    =     ( transactional )     ?    CommonAttributes . XA _ TX    :    CommonAttributes . NO _ TX ;", "final   String   serverName    =     . getActiveMQServerName ( properties )  ;", "final   String   pcfName    =     . uniqueName ( context ,    name )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( context . getApplicationName (  )  ,    context . getModuleName (  )  ,    context . getComponentName (  )  ,     (  !  ( context . isCompUsesModule (  )  )  )  ,    name )  ;", "PooledConnectionFactoryService . installService ( serviceTarget ,    pcfName ,    serverName ,    connectors ,    discoveryGroupName ,    jgroupsChannelName ,    adapterParams ,    bindInfo ,    txSupport ,    minPoolSize ,    maxPoolSize ,    managedConnectionPoolClassName ,    enlistmentTrace ,    true )  ;", "final   ServiceName   referenceFactoryServiceName    =    SERVICE _ NAME _ BASE . append ( bindInfo . getBinderServiceName (  )  )  ;", "serviceBuilder . addDependency ( referenceFactoryServiceName ,    ManagedReferenceFactory . class ,    injector )  ;", "String   managementName    =     . managementName ( context ,    name )  ;", "final   PathElement   serverElement    =    PathElement . pathElement ( CommonAttributes . SERVER ,    serverName )  ;", "final   DeploymentResourceSupport   deploymentResourceSupport    =    deploymentUnit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "deploymentResourceSupport . getDeploymentSubModel ( MessagingExtension . SUBSYSTEM _ NAME ,    serverElement )  ;", "final   PathElement   pcfPath    =    PathElement . pathElement ( CommonAttributes . POOLED _ CONNECTION _ FACTORY ,    managementName )  ;", "PathAddress   registration    =    PathAddress . pathAddress ( serverElement ,    pcfPath )  ;", "MessagingXmlInstallDeploymentUnitProcessor . createDeploymentSubModel ( registration ,    deploymentUnit )  ;", "PooledConnectionFactoryConfigurationRuntimeHandler . INSTANCE . registerResource ( serverName ,    managementName ,    model )  ;", "}", "METHOD_END"], "methodName": ["startedPooledConnectionFactory"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resourceAdapter    =  =    null )     |  |     ( resourceAdapter . isEmpty (  )  )  )     {", "return   true ;", "}", "ServiceName   activeMQServiceName    =    MessagingServices . getActiveMQServiceName ( server )  ;", "ServiceName   pcfName    =    JMSServices . getPooledBaseServiceName ( activeMQServiceName )  . append ( resourceAdapter )  ;", "return   serviceRegistry . getServiceNames (  )  . contains ( pcfName )  ;", "}", "METHOD_END"], "methodName": ["targetsPooledConnectionFactory"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   uniqueName    =    new   StringBuilder (  )  ;", "return   uniqueName . append (  (  ( context . getApplicationName (  )  )     +     \"  _  \"  )  )  . append (  . managementName ( context ,    jndiName )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["uniqueName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   JMSDestinationDefinitionInjectionSource   source    =    new   JMSDestinationDefinitionInjectionSource ( metadata . getName (  )  ,    metadata . getInterfaceName (  )  )  ;", "source . setDestinationName ( metadata . getDestinationName (  )  )  ;", "source . setResourceAdapter ( metadata . getResourceAdapter (  )  )  ;", "source . setClassName ( metadata . getClassName (  )  )  ;", "source . addProperties ( metadata . getProperties (  )  )  ;", "return   source ;", "}", "METHOD_END"], "methodName": ["getResourceDefinitionInjectionSource"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( JMSConnectionFactoryDefinitionInjectionSource . targetsPooledConnectionFactory ( JMSConnectionFactoryDefinitionInjectionSource . getActiveMQServerName ( properties )  ,    resourceAdapter ,    phaseContext . getServiceRegistry (  )  )  )     {", "startActiveMQDestination ( context ,    serviceBuilder ,    phaseContext ,    injector )  ;", "} else    {", "AdministeredObjectDefinitionInjectionSource   aodis    =    new   AdministeredObjectDefinitionInjectionSource ( jndiName ,    className ,    resourceAdapter )  ;", "aodis . setInterface ( interfaceName )  ;", "aodis . setDescription ( description )  ;", "for    ( Map . Entry < String ,    String >    property    :    properties . entrySet (  )  )     {", "aodis . addProperty ( property . getKey (  )  ,    property . getValue (  )  )  ;", "}", "aodis . getResourceValue ( context ,    serviceBuilder ,    phaseContext ,    injector )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   ContextListAndJndiViewManagedReferenceFactory   referenceFactoryService    =    new   MessagingJMSDestinationManagedReferenceFactory ( destinationService )  ;", "serviceBuilder . addInjection ( injector ,    referenceFactoryService )  . addListener ( new   AbstractServiceListener < Object >  (  )     {", "public   void   transition ( final   ServiceController <  ?    extends   Object >    controller ,    final   ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "MessagingLogger . ROOT _ LOGGER . boundJndiName ( jndiName )  ;", "break ;", "}", "case   START _ REQUESTED _ to _ DOWN    :", "{", "MessagingLogger . ROOT _ LOGGER . unboundJndiName ( jndiName )  ;", "break ;", "}", "case   REMOVING _ to _ REMOVED    :", "{", "MessagingLogger . ROOT _ LOGGER . debugf (  \" Removed   messaging   object    [  % s ]  \"  ,    jndiName )  ;", "break ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . className    =    className ;", "}", "METHOD_END"], "methodName": ["setClassName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . destinationName    =    destinationName ;", "}", "METHOD_END"], "methodName": ["setDestinationName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . resourceAdapter    =    resourceAdapter ;", "}", "METHOD_END"], "methodName": ["setResourceAdapter"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   String   uniqueName    =    uniqueName ( context )  ;", "try    {", "ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( JMSConnectionFactory . getActiveMQServerName ( properties )  )  ;", "if    ( interfaceName . equals ( Queue . class . getName (  )  )  )     {", "startQueue ( uniqueName ,    phaseContext . getServiceTarget (  )  ,    serviceName ,    serviceBuilder ,    deploymentUnit ,    injector )  ;", "} else    {", "startTopic ( uniqueName ,    phaseContext . getServiceTarget (  )  ,    serviceName ,    serviceBuilder ,    deploymentUnit ,    injector )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   DeploymentUnitProcessingException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["startActiveMQDestination"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   String   selector    =     ( properties . containsKey ( CommonAttributes . SELECTOR . getName (  )  )  )     ?    properties . get ( CommonAttributes . SELECTOR . getName (  )  )     :    null ;", "final   boolean   durable    =     ( properties . containsKey ( CommonAttributes . DURABLE . getName (  )  )  )     ?    Boolean . valueOf ( properties . get ( CommonAttributes . DURABLE . getName (  )  )  )     :    CommonAttributes . DURABLE . getDefaultValue (  )  . asBoolean (  )  ;", "ModelNode   destination    =    new   ModelNode (  )  ;", "destination . get ( CommonAttributes . NAME )  . set ( queueName )  ;", "destination . get ( CommonAttributes . DURABLE . getName (  )  )  . set ( durable )  ;", "if    ( selector    !  =    null )     {", "destination . get ( CommonAttributes . SELECTOR . getName (  )  )  . set ( selector )  ;", "}", "destination . get ( CommonAttributes . ENTRIES )  . add ( jndiName )  ;", "Service < Queue >    queueService    =    JMSQueueService . installService ( queueName ,    serviceTarget ,    serverServiceName ,    selector ,    durable ,    new   String [  0  ]  )  ;", "inject ( serviceBuilder ,    injector ,    queueService )  ;", "String   serverName    =    JMSConnectionFactory . getActiveMQServerName ( properties )  ;", "final   PathElement   serverElement    =    PathElement . pathElement ( CommonAttributes . SERVER ,    serverName )  ;", "final   PathElement   dest    =    PathElement . pathElement ( CommonAttributes . JMS _ QUEUE ,    queueName )  ;", "final   DeploymentResourceSupport   deploymentResourceSupport    =    deploymentUnit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "deploymentResourceSupport . getDeploymentSubModel ( MessagingExtension . SUBSYSTEM _ NAME ,    serverElement )  ;", "PathAddress   registration    =    PathAddress . pathAddress ( serverElement ,    dest )  ;", "MessagingXmlInstallDeploymentUnitProcessor . createDeploymentSubModel ( registration ,    deploymentUnit )  ;", "JMSQueueConfigurationRuntimeHandler . INSTANCE . registerResource ( serverName ,    queueName ,    destination )  ;", "}", "METHOD_END"], "methodName": ["startQueue"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "ModelNode   destination    =    new   ModelNode (  )  ;", "destination . get ( CommonAttributes . NAME )  . set ( topicName )  ;", "destination . get ( CommonAttributes . ENTRIES )  . add ( jndiName )  ;", "Service < Topic >    topicService    =    JMSTopicService . installService ( topicName ,    serverServiceName ,    serviceTarget ,    new   String [  0  ]  )  ;", "inject ( serviceBuilder ,    injector ,    topicService )  ;", "String   serverName    =    JMSConnectionFactory . getActiveMQServerName ( properties )  ;", "final   PathElement   serverElement    =    PathElement . pathElement ( CommonAttributes . SERVER ,    serverName )  ;", "final   PathElement   dest    =    PathElement . pathElement ( CommonAttributes . JMS _ TOPIC ,    topicName )  ;", "final   DeploymentResourceSupport   deploymentResourceSupport    =    deploymentUnit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "deploymentResourceSupport . getDeploymentSubModel ( MessagingExtension . SUBSYSTEM _ NAME ,    serverElement )  ;", "PathAddress   registration    =    PathAddress . pathAddress ( serverElement ,    dest )  ;", "MessagingXmlInstallDeploymentUnitProcessor . createDeploymentSubModel ( registration ,    deploymentUnit )  ;", "JMSTopicConfigurationRuntimeHandler . INSTANCE . registerResource ( serverName ,    topicName ,    destination )  ;", "}", "METHOD_END"], "methodName": ["startTopic"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( destinationName )     !  =    null )     &  &     (  !  ( destinationName . isEmpty (  )  )  )  )     {", "return   destinationName ;", "}", "StringBuilder   uniqueName    =    new   StringBuilder (  )  ;", "uniqueName . append (  (  ( context . getApplicationName (  )  )     +     \"  _  \"  )  )  ;", "uniqueName . append (  (  ( context . getModuleName (  )  )     +     \"  _  \"  )  )  ;", "if    (  ( context . getComponentName (  )  )     !  =    null )     {", "uniqueName . append (  (  ( context . getComponentName (  )  )     +     \"  _  \"  )  )  ;", "}", "uniqueName . append ( jndiName )  ;", "return   uniqueName . toString (  )  ;", "}", "METHOD_END"], "methodName": ["uniqueName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JMSDestinationDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   destination ;", "}", "METHOD_END"], "methodName": ["getDestination"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JmsDestination"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JmsDestination"}, {"methodBody": ["METHOD_START", "{", "return   server ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.JmsDestination"}, {"methodBody": ["METHOD_START", "{", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    moduleIdentifier ,    false ,    false ,    true ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "final   ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . JMS _ API )  ;", "if    ( WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit )  )     {", "addDependency ( moduleSpecification ,    moduleLoader ,     . AS _ MESSAGING )  ;", "addDependency ( moduleSpecification ,    moduleLoader ,     . JTS )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( reader . getLocalName (  )  )     {", "case   CommonAttributes . SERVER    :", "processServer ( reader ,    result )  ;", "break ;", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processDeployment"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDeploymentParser_1_0"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "final   String   name    =    propertyReplacer . replaceProperties ( reader . getAttributeValue (  0  )  )  ;", "if    ( name    =  =    null )     {", "throw   ParseUtils . missingRequired ( reader ,    Collections . singleton (  \" name \"  )  )  ;", "}", "final   ModelNode   queue    =    new   ModelNode (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( reader . getLocalName (  )  )     {", "case   CommonAttributes . ENTRY    :", "{", "final   String   entry    =    propertyReplacer . replaceProperties ( ParseUtils . readStringAttributeElement ( reader ,    CommonAttributes . NAME )  )  ;", "CommonAttributes . DESTINATION _ ENTRIES . parseAndAddParameterElement ( entry ,    queue ,    reader )  ;", "break ;", "}", "case    \" selector \"     :", "{", "if    ( queue . has ( CommonAttributes . SELECTOR . getName (  )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    reader . getLocalName (  )  )  ;", "}", "ParseUtils . requireSingleAttribute ( reader ,    CommonAttributes . STRING )  ;", "final   String   selector    =    propertyReplacer . replaceProperties ( ParseUtils . readStringAttributeElement ( reader ,    CommonAttributes . STRING )  )  ;", "CommonAttributes . SELECTOR . parseAndSetParameter ( selector ,    queue ,    reader )  ;", "break ;", "}", "case    \" durable \"     :", "{", "if    ( queue . has ( CommonAttributes . DURABLE . getName (  )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    reader . getLocalName (  )  )  ;", "}", "CommonAttributes . DURABLE . parseAndSetParameter ( propertyReplacer . replaceProperties ( reader . getElementText (  )  )  ,    queue ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "result . getQueues (  )  . add ( new   JmsDestination ( queue ,    serverName ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["processJMSQueue"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDeploymentParser_1_0"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    propertyReplacer . replaceProperties ( reader . getAttributeValue (  0  )  )  ;", "if    ( name    =  =    null )     {", "throw   Utils . missingRequired ( reader ,    Collections . singleton (  \" name \"  )  )  ;", "}", "final   ModelNode   topic    =    new   ModelNode (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( reader . getLocalName (  )  )     {", "case   CommonAttributes . ENTRY    :", "{", "final   String   entry    =    propertyReplacer . replaceProperties ( Utils . readStringAttributeElement ( reader ,    CommonAttributes . NAME )  )  ;", "CommonAttributes . DESTINATION _ ENTRIES . parseAndAddParameterElement ( entry ,    topic ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "result . getTopics (  )  . add ( new   JmsDestination ( topic ,    serverName ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["processJMSTopic"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDeploymentParser_1_0"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( reader . getLocalName (  )  )     {", "case   CommonAttributes . JMS _ QUEUE    :", "processJMSQueue ( reader ,    serverName ,    result )  ;", "break ;", "case   CommonAttributes . JMS _ TOPIC    :", "processJMSTopic ( reader ,    serverName ,    result )  ;", "break ;", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processJmsDestinations"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDeploymentParser_1_0"}, {"methodBody": ["METHOD_START", "{", "String   serverName    =    null ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "if    ( count    >     0  )     {", "Utils . requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "serverName    =    propertyReplacer . replaceProperties ( reader . getAttributeValue (  0  )  . trim (  )  )  ;", "}", "if    (  ( serverName    =  =    null )     |  |     (  ( serverName . length (  )  )     =  =     0  )  )     {", "serverName    =     \" default \"  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( reader . getLocalName (  )  )     {", "case   CommonAttributes . JMS _ DESTINATIONS    :", "processJmsDestinations ( reader ,    result ,    serverName )  ;", "break ;", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processServer"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDeploymentParser_1_0"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   schemaVer    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "switch    ( schemaVer )     {", "case   MESSAGING _ DEPLOYMENT _  1  _  0     :", "process ( reader ,    result )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingDeploymentParser_1_0"}, {"methodBody": ["METHOD_START", "{", "final   Resource   root    =    unit . getAttachment ( DEPLOYMENT _ RESOURCE )  ;", "synchronized ( root )     {", "final   ManagementResourceRegistration   registration    =    unit . getAttachment ( MUTABLE _ REGISTRATION _ ATTACHMENT )  ;", "final   PathAddress   subsystemAddress    =    PathAddress . pathAddress ( PathElement . pathElement ( SUBSYSTEM ,    MessagingExtension . SUBSYSTEM _ NAME )  )  ;", "final   Resource   subsystem    =     . getOrCreate ( root ,    subsystemAddress )  ;", "Set < String >    childTypes    =    subsystem . getChildTypes (  )  ;", "final   ManagementResourceRegistration   subModel    =    registration . getSubModel ( subsystemAddress . append ( address )  )  ;", "if    ( subModel    =  =    null )     {", "throw   new   IllegalStateException ( address . toString (  )  )  ;", "}", ". getOrCreate ( subsystem ,    address )  ;", "return   subModel ;", "}", "}", "METHOD_END"], "methodName": ["createDeploymentSubModel"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingXmlInstallDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "Resource   current    =    parent ;", "for    ( final   PathEle   ele    :    address )     {", "synchronized ( current )     {", "if    ( current . hasChild ( ele )  )     {", "current    =    current . requireChild ( ele )  ;", "} else    {", "final   Resource   resource    =    Factory . create (  )  ;", "current . registerChild ( ele ,    resource )  ;", "current    =    resource ;", "}", "}", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["getOrCreate"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingXmlInstallDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  . getRoot (  )  ;", "if    (  ( deploymentRoot    =  =    null )     |  |     (  !  ( deploymentRoot . exists (  )  )  )  )     {", "return   Collections . emptySet (  )  ;", "}", "final   String   deploymentRootName    =    deploymentRoot . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    ( deploymentRootName . endsWith (  \"  - jms . xml \"  )  )     {", "return   Collections . singleton ( deploymentRoot )  ;", "}", "final   Set < VirtualFile >    ret    =    new   HashSet < VirtualFile >  (  )  ;", "for    ( String   location    :     . LOCATIONS )     {", "final   VirtualFile   loc    =    deploymentRoot . getChild ( location )  ;", "if    ( loc . exists (  )  )     {", "for    ( final   VirtualFile   file    :    loc . getChildren (  )  )     {", "if    ( file . getName (  )  . endsWith (  \"  - jms . xml \"  )  )     {", "ret . add ( file )  ;", "}", "}", "}", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["messageDestinations"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingXmlParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( closeable    !  =    null )     {", "try    {", "closeable . close (  )  ;", "}    catch    ( XMLStreamException   e )     {", "Logger . ROOT _ LOGGER . couldNotCloseFile ( file ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingXmlParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( inputFactory . isPropertySupported ( property )  )     {", "inputFactory . seperty ( property ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setIfSupported"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.MessagingXmlParsingDeploymentUnitProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   queues ;", "}", "METHOD_END"], "methodName": ["getQueues"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.ParseResult"}, {"methodBody": ["METHOD_START", "{", "return   topics ;", "}", "METHOD_END"], "methodName": ["getTopics"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.ParseResult"}, {"methodBody": ["METHOD_START", "{", "MessagingLogger . ROOT _ LOGGER . debugf (  \" Clean   up   JMSContext   created   from    % s \"  ,    this )  ;", "for    ( JMSContext   jmsContext    :    contexts . values (  )  )     {", "jmsContext . close (  )  ;", "}", "contexts . clear (  )  ;", "}", "METHOD_END"], "methodName": ["cleanUp"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.AbstractJMSContext"}, {"methodBody": ["METHOD_START", "{", "MessagingLogger . ROOT _ LOGGER . debugf (  \" Create   JMSContext   from    % s    -     % s \"  ,    info ,    connectionFactory )  ;", "int   sessionMode    =    info . getSessionMode (  )  ;", "String   userName    =    info . getUserName (  )  ;", "final   JMSContext   context ;", "if    ( userName    =  =    null )     {", "context    =    connectionFactory . createContext ( sessionMode )  ;", "} else    {", "String   password    =    info . getPassword (  )  ;", "context    =    connectionFactory . createContext ( userName ,    password ,    sessionMode )  ;", "}", "return   context ;", "}", "METHOD_END"], "methodName": ["createContext"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.AbstractJMSContext"}, {"methodBody": ["METHOD_START", "{", "JMSContext   context    =    contexts . get ( injectionPointId )  ;", "if    ( context    =  =    null )     {", "context    =    createContext ( info ,    connectionFactory )  ;", "contexts . put ( injectionPointId ,    context )  ;", "}", "return   context ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.AbstractJMSContext"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   DeploymentUnit   parent    =     (  ( deploymentUnit . getParent (  )  )     =  =    null )     ?    deploymentUnit    :    deploymentUnit . getParent (  )  ;", "PropertyReplacer   propertyReplacer    =    EJBAnnotationPropertyReplacement . propertyReplacer ( deploymentUnit )  ;", "if    ( WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit )  )     {", "WeldPortableExtensions   extensions    =    WeldPortableExtensions . getPortableExtensions ( parent )  ;", "extensions . registerExtensionInstance ( new   JMSCDIExtension ( propertyReplacer )  ,    parent )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.CDIDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cachedCF    =    connectionFactory ;", "if    ( cachedCF    =  =    null )     {", "cachedCF    =     (  ( ConnectionFactory )     ( lookup ( info . getConnectionFactoryLookup (  )  )  )  )  ;", "connectionFactory    =    cachedCF ;", "}", "return   cachedCF ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.InjectedJMSContext"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationRegistry   cachedTSR    =    transactionSynchronizationRegistry ;", "if    ( cachedTSR    =  =    null )     {", "cachedTSR    =     (  ( TransactionSynchronizationRegistry )     ( lookup (  . TRANSACTION _ SYNCHRONIZATION _ REGISTRY _ LOOKUP )  )  )  ;", "transactionSynchronizationRegistry    =    cachedTSR ;", "}", "return   cachedTSR ;", "}", "METHOD_END"], "methodName": ["getTransactionSynchronizationRegistry"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.InjectedJMSContext"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationRegistry   tsr    =    getTransactionSynchronizationRegistry (  )  ;", "boolean   inTx    =     ( tsr . getTransactionStatus (  )  )     =  =     ( Status . STATUS _ ACTIVE )  ;", "return   inTx ;", "}", "METHOD_END"], "methodName": ["isInTransaction"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.InjectedJMSContext"}, {"methodBody": ["METHOD_START", "{", "Context   ctx    =    null ;", "try    {", "ctx    =    new   InitialContext (  )  ;", "return   ctx . lookup ( name )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}    finally    {", "if    ( ctx    !  =    null )     {", "try    {", "ctx . close (  )  ;", "}    catch    ( NamingException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.InjectedJMSContext"}, {"methodBody": ["METHOD_START", "{", "AnnotatedType < RequestedJMSContext >    requestedContextBean    =    bm . createAnnotatedType ( RequestedJMSContext . class )  ;", "bbd . addAnnotatedType ( requestedContextBean ,     (  (  (  . class . getName (  )  )     +     \"  -  \"  )     +     ( RequestedJMSContext . class . getName (  )  )  )  )  ;", "AnnotatedType < TransactedJMSContext >    transactedContextBean    =    bm . createAnnotatedType ( TransactedJMSContext . class )  ;", "bbd . addAnnotatedType ( transactedContextBean ,     (  (  (  . class . getName (  )  )     +     \"  -  \"  )     +     ( TransactedJMSContext . class . getName (  )  )  )  )  ;", "AnnotatedType < InjectedJMSContext >    contextBean    =    bm . createAnnotatedType ( InjectedJMSContext . class )  ;", "bbd . addAnnotatedType ( contextBean ,     (  (  (  . class . getName (  )  )     +     \"  -  \"  )     +     ( InjectedJMSContext . class . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["beforeBeanDiscovery"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.JMSCDIExtension"}, {"methodBody": ["METHOD_START", "{", "return   connectionFactoryLookup ;", "}", "METHOD_END"], "methodName": ["getConnectionFactoryLookup"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.JMSInfo"}, {"methodBody": ["METHOD_START", "{", "return   password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.JMSInfo"}, {"methodBody": ["METHOD_START", "{", "return   sessionMode ;", "}", "METHOD_END"], "methodName": ["getSessionMode"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.JMSInfo"}, {"methodBody": ["METHOD_START", "{", "return   userName ;", "}", "METHOD_END"], "methodName": ["getUserName"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.JMSInfo"}, {"methodBody": ["METHOD_START", "{", "Object   alreadyRegistered    =    transactionSynchronizationRegistry . getResource ( TransactedJMSContext . AfterCompletionSynchronization . class . getName (  )  )  ;", "if    ( alreadyRegistered    =  =    null )     {", "transactionSynchronizationRegistry . registerInterposedSynchronization ( new   TransactedJMSContext . AfterCompletionSynchronization ( contextInstance )  )  ;", "transactionSynchronizationRegistry . putResource ( TransactedJMSContext . AfterCompletionSynchronization . class . getName (  )  ,    contextInstance )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCleanUpListener"], "fileName": "org.wildfly.extension.messaging.activemq.deployment.injection.TransactedJMSContext"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . hasDefined ( CommonAttributes . HA _ POLICY )  )  )     {", "return ;", "}", "Property   prop    =    model . get ( CommonAttributes . HA _ POLICY )  . asProperty (  )  ;", "ModelNode   haPolicy    =    prop . getValue (  )  ;", "final      haPolicyConfiguration ;", "String   type    =    prop . getName (  )  ;", "switch    ( type )     {", "case   CommonAttributes . LIVE _ ONLY    :", "{", "haPolicyConfiguration    =    LiveOnlyDefinition . buildConfiguration ( context ,    haPolicy )  ;", "break ;", "}", "case   CommonAttributes . REPLICATION _ MASTER    :", "{", "haPolicyConfiguration    =    ReplicationMasterDefinition . buildConfiguration ( context ,    haPolicy )  ;", "break ;", "}", "case   CommonAttributes . REPLICATION _ SLAVE    :", "{", "haPolicyConfiguration    =    ReplicationSlaveDefinition . buildConfiguration ( context ,    haPolicy )  ;", "break ;", "}", "case   CommonAttributes . REPLICATION _ COLOCATED    :", "{", "haPolicyConfiguration    =    ReplicationColocatedDefinition . buildConfiguration ( context ,    haPolicy )  ;", "break ;", "}", "case   CommonAttributes . SHARED _ STORE _ MASTER    :", "{", "haPolicyConfiguration    =    SharedStoreMasterDefinition . buildConfiguration ( context ,    haPolicy )  ;", "break ;", "}", "case   CommonAttributes . SHARED _ STORE _ SLAVE    :", "{", "haPolicyConfiguration    =    SharedStoreSlaveDefinition . buildConfiguration ( context ,    haPolicy )  ;", "break ;", "}", "case   CommonAttributes . SHARED _ STORE _ COLOCATED    :", "{", "haPolicyConfiguration    =    SharedStoreColocatedDefinition . buildConfiguration ( context ,    haPolicy )  ;", "break ;", "}", "default    :", "{", "throw   new   OperationFailedException (  \" unknown   ha   policy   type \"  )  ;", "}", "}", "configuration . set ( haPolicyConfiguration )  ;", "}", "METHOD_END"], "methodName": ["addHAPolicyConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.HAPolicyConfigurationBuilder"}, {"methodBody": ["METHOD_START", "{", "ScaleDownConfiguration   scaleDownConfiguration    =    ScaleDownAttributes . addScaleDownConfiguration ( context ,    model )  ;", "return   new   configPolicyConfiguration ( scaleDownConfiguration )  ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.LiveOnlyDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   OperationStepHandler (  )     {", "@ Override", "public   void   execute ( OperationContext   context ,    ModelNode   operation )    throws   OperationFailedException    {", "PathAddress   parentAddress    =    context . getCurrentAddress (  )  . getParent (  )  ;", "Resource   parent    =    context . readResourceFromRoot ( parentAddress ,    false )  ;", "Set < String >    children    =    parent . getChildrenNames ( childType )  ;", "if    (  ( children . size (  )  )     >     1  )     {", "throw   MLogger . ROOT _ LOGGER . onlyOneChildIsAllowed ( childType ,    children )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["checkNoOtherSibling"], "fileName": "org.wildfly.extension.messaging.activemq.ha.ManagementHelper"}, {"methodBody": ["METHOD_START", "{", "return   new   ActiveMQReloadRequiredHandlers . AddStepHandler ( attributes )     {", "@ Override", "public   void   execute ( OperationContext   context ,    ModelNode   operation )    throws   OperationFailedException    {", "super . execute ( context ,    operation )  ;", "if    (  ! allowSibling )     {", "context . addStep (  . checkNoOtherSibling ( childType )  ,    Stage . MODEL )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createAddOperation"], "fileName": "org.wildfly.extension.messaging.activemq.ha.ManagementHelper"}, {"methodBody": ["METHOD_START", "{", "ColocatedPolicyConfiguration   haPolicyConfiguration    =    new   ColocatedPolicyConfiguration (  )  . setRequestBackup ( HAAttributes . REQUEST _ BACKUP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  . setBackupRequestRetries ( HAAttributes . BACKUP _ REQUEST _ RETRIES . resolveModelAttribute ( context ,    model )  . asInt (  )  )  . setBackupRequestRetryInterval ( HAAttributes . BACKUP _ REQUEST _ RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  . setMaxBackups ( HAAttributes . MAX _ BACKUPS . resolveModelAttribute ( context ,    model )  . asInt (  )  )  . setBackupPortOffset ( HAAttributes . BACKUP _ PORT _ OFFSET . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "List < String >    connectors    =    HAAttributes . EXCLUDED _ CONNECTORS . unwrap ( context ,    model )  ;", "if    (  !  ( connectors . isEmpty (  )  )  )     {", "haPolicyConfiguration . setExcludedConnectors ( connectors )  ;", "}", "ModelNode   masterConfigurationModel    =    model . get ( CommonAttributes . CONFIGURATION ,    CommonAttributes . MASTER )  ;", "HAPolicyConfiguration   masterConfiguration    =    MasterDefinition . buildConfiguration ( context ,    masterConfigurationModel )  ;", "haPolicyConfiguration . setLiveConfig ( masterConfiguration )  ;", "ModelNode   slaveConfigurationModel    =    model . get ( CommonAttributes . CONFIGURATION ,    CommonAttributes . SLAVE )  ;", "HAPolicyConfiguration   slaveConfiguration    =    SlaveDefinition . buildConfiguration ( context ,    slaveConfigurationModel )  ;", "haPolicyConfiguration . setBackupConfig ( slaveConfiguration )  ;", "return   haPolicyConfiguration ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.ReplicationColocatedDefinition"}, {"methodBody": ["METHOD_START", "{", "ReplicatedPolicyConfiguration   haPolicyConfiguration    =    new   ReplicatedPolicyConfiguration (  )  ;", "haPolicyConfiguration . setCheckForLiveServer ( HAAttributes . CHECK _ FOR _ LIVE _ SERVER . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  . setInitialSyncTimeout ( HAAttributes . INITIAL _ REPLICATION _ SYNC _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "ModelNode   clusterName    =    HAAttributes . CLUSTER _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( clusterName . isDefined (  )  )     {", "haPolicyConfiguration . setClusterName ( clusterName . asString (  )  )  ;", "}", "ModelNode   groupName    =    HAAttributes . GROUP _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( groupName . isDefined (  )  )     {", "haPolicyConfiguration . setGroupName ( groupName . asString (  )  )  ;", "}", "return   haPolicyConfiguration ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.ReplicationMasterDefinition"}, {"methodBody": ["METHOD_START", "{", "ReplicaPolicyConfiguration   haPolicyConfiguration    =    new   ReplicaPolicyConfiguration (  )  . setAllowFailBack ( HAAttributes . ALLOW _ FAILBACK . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  . setInitialReplicationSyncTimeout ( HAAttributes . INITIAL _ REPLICATION _ SYNC _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  )  . setMaxSavedReplicatedJournalsSize ( HAAttributes . MAX _ SAVED _ REPLICATED _ JOURNAL _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  . setScaleDownConfiguration ( ScaleDownAttributes . addScaleDownConfiguration ( context ,    model )  )  . setRestartBackup ( HAAttributes . RESTART _ BACKUP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "ModelNode   clusterName    =    HAAttributes . CLUSTER _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( clusterName . isDefined (  )  )     {", "haPolicyConfiguration . setClusterName ( clusterName . asString (  )  )  ;", "}", "ModelNode   groupName    =    HAAttributes . GROUP _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( groupName . isDefined (  )  )     {", "haPolicyConfiguration . setGroupName ( groupName . asString (  )  )  ;", "}", "return   haPolicyConfiguration ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.ReplicationSlaveDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . hasDefined ( ScaleDownAttributes . SCALE _ DOWN . getName (  )  )  )  )     {", "return   null ;", "}", "ScaleDownConfiguration   scaleDownConfiguration    =    new   ScaleDownConfiguration (  )  ;", "scaleDownConfiguration . setEnabled ( ScaleDownAttributes . SCALE _ DOWN . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "ModelNode   clusterName    =    ScaleDownAttributes . SCALE _ DOWN _ CLUSTER _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( clusterName . isDefined (  )  )     {", "scaleDownConfiguration . setClusterName ( clusterName . asString (  )  )  ;", "}", "ModelNode   groupName    =    ScaleDownAttributes . SCALE _ DOWN _ GROUP _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( groupName . isDefined (  )  )     {", "scaleDownConfiguration . setGroupName ( groupName . asString (  )  )  ;", "}", "ModelNode   discoveryGroupName    =    ScaleDownAttributes . SCALE _ DOWN _ DISCOVERY _ GROUP . resolveModelAttribute ( context ,    model )  ;", "if    ( discoveryGroupName . isDefined (  )  )     {", "scaleDownConfiguration . setDiscoveryGroup ( discoveryGroupName . asString (  )  )  ;", "}", "ModelNode   connectors    =    ScaleDownAttributes . SCALE _ DOWN _ CONNECTORS . resolveModelAttribute ( context ,    model )  ;", "if    ( connectors . isDefined (  )  )     {", "List < String >    connectorNames    =    new   ArrayList ( connectors . keys (  )  )  ;", "scaleDownConfiguration . setConnectors ( connectorNames )  ;", "}", "return   scaleDownConfiguration ;", "}", "METHOD_END"], "methodName": ["addScaleDownConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.ScaleDownAttributes"}, {"methodBody": ["METHOD_START", "{", "ColocatedPolicyConfiguration   haPolicyConfiguration    =    new   ColocatedPolicyConfiguration (  )  . setRequestBackup ( HAAttributes . REQUEST _ BACKUP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  . setBackupRequestRetries ( HAAttributes . BACKUP _ REQUEST _ RETRIES . resolveModelAttribute ( context ,    model )  . asInt (  )  )  . setBackupRequestRetryInterval ( HAAttributes . BACKUP _ REQUEST _ RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  . setMaxBackups ( HAAttributes . MAX _ BACKUPS . resolveModelAttribute ( context ,    model )  . asInt (  )  )  . setBackupPortOffset ( HAAttributes . BACKUP _ PORT _ OFFSET . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "ModelNode   masterConfigurationModel    =    model . get ( CommonAttributes . CONFIGURATION ,    CommonAttributes . MASTER )  ;", "HAPolicyConfiguration   masterConfiguration    =    MasterDefinition . buildConfiguration ( context ,    masterConfigurationModel )  ;", "haPolicyConfiguration . setLiveConfig ( masterConfiguration )  ;", "ModelNode   slaveConfigurationModel    =    model . get ( CommonAttributes . CONFIGURATION ,    CommonAttributes . SLAVE )  ;", "HAPolicyConfiguration   slaveConfiguration    =    SlaveDefinition . buildConfiguration ( context ,    slaveConfigurationModel )  ;", "haPolicyConfiguration . setBackupConfig ( slaveConfiguration )  ;", "return   haPolicyConfiguration ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.SharedStoreColocatedDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SharedStoreMasterPolicyConfiguration (  )  . setFailoverOnServerShutdown ( HAAttributes . FAILOVER _ ON _ SERVER _ SHUTDOWN . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.SharedStoreMasterDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   SharedStoreSlavePolicyConfiguration (  )  . setAllowFailBack ( HAAttributes . ALLOW _ FAILBACK . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  . setFailoverOnServerShutdown ( HAAttributes . FAILOVER _ ON _ SERVER _ SHUTDOWN . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  . setRestartBackup ( HAAttributes . RESTART _ BACKUP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  . setScaleDownConfiguration ( ScaleDownAttributes . addScaleDownConfiguration ( context ,    model )  )  ;", "}", "METHOD_END"], "methodName": ["buildConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.ha.SharedStoreSlaveDefinition"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    operationAddress . getLastElement (  )  . getValue (  )  ;", "final   String   server    =    operationAddress . getElement (  (  ( operationAddress . size (  )  )     -     2  )  )  . getValue (  )  ;", "T   config    =    resources . get ( new    . ResourceConfig ( server ,    name )  )  ;", "if    ( config    =  =    null )     {", "throw   new   OperationFailedException ( MessagingLogger . ROOT _ LOGGER . noDestinationRegisteredForAddress ( operationAddress )  )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["getResourceConfig"], "fileName": "org.wildfly.extension.messaging.activemq.jms.AbstractJMSRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "resources . put ( new   AbstractJMSRuntimeHandler . ResourceConfig ( server ,    name )  ,    resource )  ;", "}", "METHOD_END"], "methodName": ["registerResource"], "fileName": "org.wildfly.extension.messaging.activemq.jms.AbstractJMSRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "throw   MessagingLogger . ROOT _ LOGGER . operationNotValid ( opName )  ;", "}", "METHOD_END"], "methodName": ["unknownOperation"], "fileName": "org.wildfly.extension.messaging.activemq.jms.AbstractJMSRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "resources . remove ( new   AbstractJMSRuntimeHandler . ResourceConfig ( server ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterResource"], "fileName": "org.wildfly.extension.messaging.activemq.jms.AbstractJMSRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "SimpleOperationDefinition   operation    =    new   SimpleOperationDefinition (  ( addOperation    ?    AbstractUpdateJndiHandler . ADD _ JNDI    :    AbstractUpdateJndiHandler . REMOVE _ JNDI )  ,    resolver ,    AbstractUpdateJndiHandler . JNDI _ BINDING )  ;", "registry . registerOperationHandler ( operation ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerOperation"], "fileName": "org.wildfly.extension.messaging.activemq.jms.AbstractUpdateJndiHandler"}, {"methodBody": ["METHOD_START", "{", "Set < Str   onlyInSet 1     =    new   TreeSet < Str ( set 1  )  ;", "onlyInSet 1  . removeAll ( set 2  )  ;", "Set < Str   onlyInSet 2     =    new   TreeSet < Str ( set 2  )  ;", "onlyInSet 2  . removeAll ( set 1  )  ;", "if    (  (  !  ( onlyInSet 1  . isEmpty (  )  )  )     |  |     (  !  ( onlyInSet 2  . isEmpty (  )  )  )  )     {", "fail ( Strformat (  \" in    % s   only :     % s \\ nin    % s   only :     % s \"  ,    name 1  ,    onlyInSet 1  ,    name 2  ,    onlyInSet 2  )  )  ;", "}", "assertEquals ( set 2  ,    set 1  )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.wildfly.extension.messaging.activemq.jms.AttributesTestBase"}, {"methodBody": ["METHOD_START", "{", "SortedSet < String >    names    =    new   TreeSet < String >  (  )  ;", "for    ( PropertyDescriptor   propDesc    :    Introspector . getBeanInfo ( clazz )  . getPropertyDescriptors (  )  )     {", "if    (  ( propDesc    =  =    null )     |  |     (  ( propDesc . getWriteMethod (  )  )     =  =    null )  )     {", "continue ;", "}", "names . add ( propDesc . getDisplayName (  )  )  ;", "}", "return   names ;", "}", "METHOD_END"], "methodName": ["findAllPropertyNames"], "fileName": "org.wildfly.extension.messaging.activemq.jms.AttributesTestBase"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    entries    =    ConnectionFactoryAttributes . Common . ENTRIES . unwrap ( context ,    model )  ;", "final   ConnectionFactoryConfiguration   config    =    new   ConnectionFactoryConfigurationImpl (  )  . setName ( name )  . setHA ( DEFAULT _ HA )  . setBindings ( entries . toArray ( new   String [ entries . size (  )  ]  )  )  ;", "config . setHA ( CommonAttributes . HA . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setAutoGroup ( ConnectionFactoryAttributes . Common . AUTO _ GROUP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setBlockOnAcknowledge ( ConnectionFactoryAttributes . Common . BLOCK _ ON _ ACKNOWLEDGE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setBlockOnDurableSend ( ConnectionFactoryAttributes . Common . BLOCK _ ON _ DURABLE _ SEND . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setBlockOnNonDurableSend ( ConnectionFactoryAttributes . Common . BLOCK _ ON _ NON _ DURABLE _ SEND . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setCacheLargeMessagesClient ( ConnectionFactoryAttributes . Common . CACHE _ LARGE _ MESSAGE _ CLIENT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setCallTimeout ( CommonAttributes . CALL _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "config . setClientFailureCheckPeriod ( ConnectionFactoryAttributes . Common . CLIENT _ FAILURE _ CHECK _ PERIOD . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setCallFailoverTimeout ( CommonAttributes . CALL _ FAILOVER _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "final   ModelNode   clientId    =    CommonAttributes . CLIENT _ ID . resolveModelAttribute ( context ,    model )  ;", "if    ( clientId . isDefined (  )  )     {", "config . setClientID ( clientId . asString (  )  )  ;", "}", "config . setCompressLargeMessages ( ConnectionFactoryAttributes . Common . COMPRESS _ LARGE _ MESSAGES . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setConfirmationWindowSize ( ConnectionFactoryAttributes . Common . CONFIRMATION _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setConnectionTTL ( ConnectionFactoryAttributes . Common . CONNECTION _ TTL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "List < String >    connectorNames    =    ConnectionFactoryAttributes . Common . CONNECTORS . unwrap ( context ,    model )  ;", "config . setConnectorNames ( connectorNames )  ;", "config . setConsumerMaxRate ( ConnectionFactoryAttributes . Common . CONSUMER _ MAX _ RATE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setConsumerWindowSize ( ConnectionFactoryAttributes . Common . CONSUMER _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "final   ModelNode   discoveryGroupName    =    ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP . resolveModelAttribute ( context ,    model )  ;", "if    ( discoveryGroupName . isDefined (  )  )     {", "config . setDiscoveryGroupName ( discoveryGroupName . asString (  )  )  ;", "}", "config . setDupsOKBatchSize ( ConnectionFactoryAttributes . Common . DUPS _ OK _ BATCH _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setFailoverOnInitialConnection ( ConnectionFactoryAttributes . Common . FAILOVER _ ON _ INITIAL _ CONNECTION . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "final   ModelNode   groupId    =    ConnectionFactoryAttributes . Common . GROUP _ ID . resolveModelAttribute ( context ,    model )  ;", "if    ( groupId . isDefined (  )  )     {", "config . setGroupID ( groupId . asString (  )  )  ;", "}", "final   ModelNode   lbcn    =    ConnectionFactoryAttributes . Common . CONNECTION _ LOAD _ BALANCING _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( lbcn . isDefined (  )  )     {", "config . setLoadBalancingPolicyClassName ( lbcn . asString (  )  )  ;", "}", "config . setMaxRetryInterval ( ConnectionFactoryAttributes . Common . MAX _ RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "config . setMinLargeMessageSize ( ConnectionFactoryAttributes . Common . MIN _ LARGE _ MESSAGE _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setPreAcknowledge ( ConnectionFactoryAttributes . Common . PRE _ ACKNOWLEDGE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setProducerMaxRate ( ConnectionFactoryAttributes . Common . PRODUCER _ MAX _ RATE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setProducerWindowSize ( ConnectionFactoryAttributes . Common . PRODUCER _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setReconnectAttempts ( ConnectionFactoryAttributes . Common . RECONNECT _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setRetryInterval ( ConnectionFactoryAttributes . Common . RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "config . setRetryIntervalMultiplier ( ConnectionFactoryAttributes . Common . RETRY _ INTERVAL _ MULTIPLIER . resolveModelAttribute ( context ,    model )  . asDouble (  )  )  ;", "config . setScheduledThreadPoolMaxSize ( ConnectionFactoryAttributes . Common . SCHEDULED _ THREAD _ POOL _ MAX _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setThreadPoolMaxSize ( ConnectionFactoryAttributes . Common . THREAD _ POOL _ MAX _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setTransactionBatchSize ( ConnectionFactoryAttributes . Common . TRANSACTION _ BATCH _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "config . setUseGlobalPools ( ConnectionFactoryAttributes . Common . USE _ GLOBAL _ POOLS . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "config . setLoadBalancingPolicyClassName ( ConnectionFactoryAttributes . Common . CONNECTION _ LOAD _ BALANCING _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "final   ModelNode   clientProtocolManagerFactory    =    ConnectionFactoryAttributes . Common . PROTOCOL _ MANAGER _ FACTORY . resolveModelAttribute ( context ,    model )  ;", "if    ( clientProtocolManagerFactory . isDefined (  )  )     {", "config . setProtocolManagerFactoryStr ( clientProtocolManagerFactory . asString (  )  )  ;", "}", "List < String >    deserializationBlackList    =    ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST . unwrap ( context ,    model )  ;", "if    (  ( deserializationBlackList . size (  )  )     >     0  )     {", "config . setDeserializationBlackList ( String . join (  \"  ,  \"  ,    deserializationBlackList )  )  ;", "}", "List < String >    deserializationWhiteList    =    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST . unwrap ( context ,    model )  ;", "if    (  ( deserializationWhiteList . size (  )  )     >     0  )     {", "config . setDeserializationWhiteList ( String . join (  \"  ,  \"  ,    deserializationWhiteList )  )  ;", "}", "JMSFactoryType   jmsFactoryType    =    ConnectionFactoryType . valueOf ( ConnectionFactoryAttributes . Regular . FACTORY _ TYPE . resolveModelAttribute ( context ,    model )  . asString (  )  )  . getType (  )  ;", "config . setFactoryType ( jmsFactoryType )  ;", "return   config ;", "}", "METHOD_END"], "methodName": ["createConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAdd"}, {"methodBody": ["METHOD_START", "{", "return   new   ConnectionFactoryAttribute ( attributeDefinition ,    propertyName ,    resourceAdapterProperty ,    null )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ConnectionFactoryAttribute ( attributeDefinition ,    propertyName ,    resourceAdapterProperty ,    inboundConfig )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "switch    ( attributeDefinition . getType (  )  )     {", "case   BOOLEAN    :", "return   Boolean . class . getName (  )  ;", "case   BIG _ DECIMAL    :", "return   Double . class . getName (  )  ;", "case   LONG    :", "return   Long . class . getName (  )  ;", "case   INT    :", "return   Integer . class . getName (  )  ;", "case   STRING    :", "case   LIST    :", "return   String . class . getName (  )  ;", "default    :", "throw   MessagingLogger . ROOT _ LOGGER . invalidType ( attributeDefinition . getName (  )  ,    attributeDefinition . getType (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getClassType"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   configType ;", "}", "METHOD_END"], "methodName": ["getConfigType"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   attributeDefinition ;", "}", "METHOD_END"], "methodName": ["getDefinition"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition [  ]    definitions    =    new   AttributeDefinition [ attrs . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( attrs . length )  ;    i +  +  )     {", "attr    =    attrs [ i ]  ;", "definitions [ i ]     =    attr . getDefinition (  )  ;", "}", "return   definitions ;", "}", "METHOD_END"], "methodName": ["getDefinitions"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdapterProperty ;", "}", "METHOD_END"], "methodName": ["isResourceAdapterProperty"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "int   size    =     ( common . length )     +     ( specific . length )  ;", "Attribute [  ]    result    =    new   Attribute [ size ]  ;", "System . arraycopy ( common ,     0  ,    result ,     0  ,    common . length )  ;", "System . arraycopy ( specific ,     0  ,    result ,    common . length ,    specific . length )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["concat"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryDefinition"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    context . getCurrentAddressValue (  )  ;", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( context . getCurrentAddress (  )  )  ;", "context . removeService ( JMSServices . getBaseServiceName ( serviceName )  . append ( name )  )  ;", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryRemove"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactoryAdd . INSTANCE . performRuntime ( context ,    operation ,    model )  ;", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryRemove"}, {"methodBody": ["METHOD_START", "{", "return   executorInjector ;", "}", "METHOD_END"], "methodName": ["getExecutorInjector"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   jmsServer ;", "}", "METHOD_END"], "methodName": ["getJmsServer"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "final   JMSServerManager   jmsManager    =    jmsServer . getValue (  )  ;", "final   Runnable   task    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "jmsManager . create ( false ,    configuration ,    configuration . getBindings (  )  )  ;", "context . complete (  )  ;", "}    catch    ( Throwable   e )     {", "context . failed ( MessagingLogger . ROOT _ LOGGER . failedToCreate ( e ,     \" connection - factory \"  )  )  ;", "}", "}", "}  ;", "try    {", "executorInjector . getValue (  )  . execute ( task )  ;", "}    catch    ( RejectedExecutionException   e )     {", "task . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "final   JMSServerManager   jmsManager    =    jmsServer . getValue (  )  ;", "final   Runnable   task    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "jmsManager . destroy ( name )  ;", "}    catch    ( Throwable   e )     {", "MessagingLogger . ROOT _ LOGGER . failedToDestroy (  \" connection - factory \"  ,    name )  ;", "}", "context . complete (  )  ;", "}", "}  ;", "try    {", "executorInjector . getValue (  )  . execute ( task )  ;", "}    catch    ( RejectedExecutionException   e )     {", "task . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryType"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactoryUpdateJndiHandler   add    =    new   ConnectionFactoryUpdateJndiHandler ( true )  ;", "add . registerOperation ( registry ,    resolver )  ;", "ConnectionFactoryUpdateJndiHandler   remove    =    new   ConnectionFactoryUpdateJndiHandler ( false )  ;", "remove . registerOperation ( registry ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryUpdateJndiHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( attributeName . equals ( ConnectionFactoryAttributes . Common . CONNECTORS . getName (  )  )  )     |  |     ( attributeName . equals ( ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP . getName (  )  )  )  )     {", "return ;", "}", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( serverServiceController . getValue (  )  )  ;", "ConnectionFactoryControl   control    =    ConnectionFactoryControl . class . cast ( server . getManagementService (  )  . getResource (  (  ( ResourceNames . JMS _ CONNECTION _ FACTORY )     +    name )  )  )  ;", "try    {", "if    ( attributeName . equals ( CommonAttributes . CLIENT _ ID . getName (  )  )  )     {", "control . setClientID (  ( value . isDefined (  )     ?    value . asString (  )     :    null )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . COMPRESS _ LARGE _ MESSAGES . getName (  )  )  )     {", "control . setCompressLargeMessages ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . CLIENT _ FAILURE _ CHECK _ PERIOD . getName (  )  )  )     {", "control . setClientFailureCheckPeriod ( value . asLong (  )  )  ;", "} else", "if    ( attributeName . equals ( CommonAttributes . CALL _ TIMEOUT . getName (  )  )  )     {", "control . setCallTimeout ( value . asLong (  )  )  ;", "} else", "if    ( attributeName . equals ( CommonAttributes . CALL _ FAILOVER _ TIMEOUT . getName (  )  )  )     {", "control . setCallFailoverTimeout ( value . asLong (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . DUPS _ OK _ BATCH _ SIZE . getName (  )  )  )     {", "control . setDupsOKBatchSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . CONSUMER _ MAX _ RATE . getName (  )  )  )     {", "control . setConsumerMaxRate ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . CONSUMER _ WINDOW _ SIZE . getName (  )  )  )     {", "control . setConsumerWindowSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . PRODUCER _ MAX _ RATE . getName (  )  )  )     {", "control . setProducerMaxRate ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . CONFIRMATION _ WINDOW _ SIZE . getName (  )  )  )     {", "control . setConfirmationWindowSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . BLOCK _ ON _ ACKNOWLEDGE . getName (  )  )  )     {", "control . setBlockOnAcknowledge ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . BLOCK _ ON _ DURABLE _ SEND . getName (  )  )  )     {", "control . setBlockOnDurableSend ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . BLOCK _ ON _ NON _ DURABLE _ SEND . getName (  )  )  )     {", "control . setBlockOnNonDurableSend ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . PRE _ ACKNOWLEDGE . getName (  )  )  )     {", "control . setPreAcknowledge ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . CONNECTION _ TTL . getName (  )  )  )     {", "control . setConnectionTTL ( value . asLong (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . TRANSACTION _ BATCH _ SIZE . getName (  )  )  )     {", "control . setTransactionBatchSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( CommonAttributes . MIN _ LARGE _ MESSAGE _ SIZE . getName (  )  )  )     {", "control . setMinLargeMessageSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . AUTO _ GROUP . getName (  )  )  )     {", "control . setAutoGroup ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . RETRY _ INTERVAL . getName (  )  )  )     {", "control . setRetryInterval ( value . asLong (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . RETRY _ INTERVAL _ MULTIPLIER . getName (  )  )  )     {", "control . setRetryIntervalMultiplier ( value . asDouble (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . RECONNECT _ ATTEMPTS . getName (  )  )  )     {", "control . setReconnectAttempts ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . FAILOVER _ ON _ INITIAL _ CONNECTION . getName (  )  )  )     {", "control . setFailoverOnInitialConnection ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . PRODUCER _ WINDOW _ SIZE . getName (  )  )  )     {", "control . setProducerWindowSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . CACHE _ LARGE _ MESSAGE _ CLIENT . getName (  )  )  )     {", "control . setCacheLargeMessagesClient ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( CommonAttributes . MAX _ RETRY _ INTERVAL . getName (  )  )  )     {", "control . setMaxRetryInterval ( value . asLong (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . SCHEDULED _ THREAD _ POOL _ MAX _ SIZE . getName (  )  )  )     {", "control . setScheduledThreadPoolMaxSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . THREAD _ POOL _ MAX _ SIZE . getName (  )  )  )     {", "control . setThreadPoolMaxSize ( value . asInt (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . GROUP _ ID . getName (  )  )  )     {", "control . setGroupID (  ( value . isDefined (  )     ?    value . asString (  )     :    null )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . USE _ GLOBAL _ POOLS . getName (  )  )  )     {", "control . setUseGlobalPools ( value . asBoolean (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . CONNECTION _ LOAD _ BALANCING _ CLASS _ NAME . getName (  )  )  )     {", "control . setConnectionLoadBalancingPolicyClassName ( value . asString (  )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . PROTOCOL _ MANAGER _ FACTORY . getName (  )  )  )     {", "control . setProtocolManagerFactoryStr ( value . asString (  )  )  ;", "} else    {", "throw   logging . MessagingLogger . ROOT _ LOGGER . unsupportedRuntimeAttribute ( attributeName )  ;", "}", "}    catch    ( RuntimeException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["applyOperationToActiveMQService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryWriteAttributeHandler"}, {"methodBody": ["METHOD_START", "{", "return   PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  . getLastElement (  )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.ConnectionFactoryWriteAttributeHandler"}, {"methodBody": ["METHOD_START", "{", "final   JMSQueueControl   control    =    JMSQueueControl . class . cast ( server . getManagementService (  )  . getResource (  (  ( ResourceNames . JMS _ QUEUE )     +    queueName )  )  )  ;", "if    ( control    =  =    null )     {", "return   null ;", "}", "return   new   Abstract . DelegatingQueueControl < JMSQueueControl >  (  )     {", "@ Override", "public   JMSQueueControl   getDelegate (  )     {", "return   control ;", "}", "@ Override", "public   String   listMessagesAsJSON ( String   filter )    throws   Exception    {", "return   control . listMessagesAsJSON ( filter )  ;", "}", "@ Override", "public   long   countMessages ( String   filter )    throws   Exception    {", "return   control . countMessages ( filter )  ;", "}", "@ Override", "public   boolean   removeMessage ( ModelNode   id )    throws   Exception    {", "return   control . removeMessage ( id . asString (  )  )  ;", "}", "@ Override", "public   int   removeMessages ( String   filter )    throws   Exception    {", "return   control . removeMessages ( filter )  ;", "}", "@ Override", "public   int   expireMessages ( String   filter )    throws   Exception    {", "return   control . expireMessages ( filter )  ;", "}", "@ Override", "public   boolean   expireMessage ( ModelNode   id )    throws   Exception    {", "return   control . expireMessage ( id . asString (  )  )  ;", "}", "@ Override", "public   boolean   sendMessageToDeadLetterAddress ( ModelNode   id )    throws   Exception    {", "return   control . sendMessageToDeadLetterAddress ( id . asString (  )  )  ;", "}", "@ Override", "public   int   sendMessagesToDeadLetterAddress ( String   filter )    throws   Exception    {", "return   control . sendMessagesToDeadLetterAddress ( filter )  ;", "}", "@ Override", "public   boolean   changeMessagePriority ( ModelNode   id ,    int   priority )    throws   Exception    {", "return   control . changeMessagePriority ( id . asString (  )  ,    priority )  ;", "}", "@ Override", "public   int   changeMessagesPriority ( String   filter ,    int   priority )    throws   Exception    {", "return   control . changeMessagesPriority ( filter ,    priority )  ;", "}", "@ Override", "public   boolean   moveMessage ( ModelNode   id ,    String   otherQueue )    throws   Exception    {", "return   control . moveMessage ( id . asString (  )  ,    otherQueue )  ;", "}", "@ Override", "public   boolean   moveMessage ( ModelNode   id ,    String   otherQueue ,    boolean   rejectDuplicates )    throws   Exception    {", "return   control . moveMessage ( id . asString (  )  ,    otherQueue ,    rejectDuplicates )  ;", "}", "@ Override", "public   int   moveMessages ( String   filter ,    String   otherQueue )    throws   Exception    {", "return   control . moveMessages ( filter ,    otherQueue )  ;", "}", "@ Override", "public   int   moveMessages ( String   filter ,    String   otherQueue ,    boolean   rejectDuplicates )    throws   Exception    {", "return   control . moveMessages ( filter ,    otherQueue ,    rejectDuplicates )  ;", "}", "@ Override", "public   String   listMessageCounter (  )    throws   Exception    {", "return   control . listMessageCounter (  )  ;", "}", "@ Override", "public   void   resetMessageCounter (  )    throws   Exception    {", "control . resetMessageCounter (  )  ;", "}", "@ Override", "public   String   listMessageCounterAsHTML (  )    throws   Exception    {", "return   control . listMessageCounterAsHTML (  )  ;", "}", "@ Override", "public   String   listMessageCounterHistory (  )    throws   Exception    {", "return   control . listMessageCounterHistory (  )  ;", "}", "@ Override", "public   String   listMessageCounterHistoryAsHTML (  )    throws   Exception    {", "return   control . listMessageCounterHistoryAsHTML (  )  ;", "}", "@ Override", "public   void   pause (  )    throws   Exception    {", "control . pause (  )  ;", "}", "@ Override", "public   void   resume (  )    throws   Exception    {", "control . resume (  )  ;", "}", "@ Override", "public   String   listConsumersAsJSON (  )    throws   Exception    {", "return   control . listConsumersAsJSON (  )  ;", "}", "@ Override", "public   String   listScheduledMessagesAsJSON (  )    throws   Exception    {", "return   control . listScheduledMessagesAsJSON (  )  ;", "}", "@ Override", "public   String   listDeliveringMessagesAsJSON (  )    throws   Exception    {", "return   control . listDeliveringMessagesAsJSON (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getQueueControl"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSQueueControlHandler"}, {"methodBody": ["METHOD_START", "{", "String   queueName    =    PathAddress . pathAddress ( operation . require ( OP _ ADDR )  )  . getLastElement (  )  . getValue (  )  ;", "final   ServiceName   serviceName    =    MServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "ServiceController <  ?  >    service    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( service . getValue (  )  )  ;", "JMSQueueControl   control    =    JMSQueueControl . class . cast ( server . getManagementService (  )  . getResource (  (  ( ResourceNames . JMS _ QUEUE )     +    queueName )  )  )  ;", "return   control ;", "}", "METHOD_END"], "methodName": ["getControl"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSQueueReadAttributeHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   String   name    =    address . getLastElement (  )  . getValue (  )  ;", "ServiceController <  ?  >    service    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( service . getValue (  )  )  ;", "JMSServerControl   control    =    JMSServerControl . class . cast ( server . getManagementService (  )  . getResource ( JMS _ SERVER )  )  ;", "if    ( control    !  =    null )     {", "try    {", "control . destroyQueue ( name ,    true )  ;", "}    catch    ( Exception   e )     {", "throw   new   OperationFailedException ( e )  ;", "}", "}", "context . removeService ( JMSServices . getJmsQueueBaseServiceName ( serviceName )  . append ( name )  )  ;", "for    ( String   entry    :    CommonAttributes . DESTINATION _ ENTRIES . unwrap ( context ,    model )  )     {", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( entry )  ;", "ServiceName   binderServiceName    =    bindInfo . getBinderServiceName (  )  ;", "context . removeService ( binderServiceName )  ;", "}", "for    ( String   legacyEntry    :    CommonAttributes . LEGACY _ ENTRIES . unwrap ( context ,    model )  )     {", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( legacyEntry )  ;", "ServiceName   binderServiceName    =    bindInfo . getBinderServiceName (  )  ;", "context . removeService ( binderServiceName )  ;", "}", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSQueueRemove"}, {"methodBody": ["METHOD_START", "{", "JMSQueueAdd . INSTANCE . performRuntime ( context ,    operation ,    model )  ;", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSQueueRemove"}, {"methodBody": ["METHOD_START", "{", "final   JMSQueueService   service    =    new   JMSQueueService ( name ,    selector ,    durable ,    jndiBindings )  ;", "final   ServiceName   serviceName    =    JMSServices . getJmsQueueBaseServiceName ( serverServiceName )  . append ( name )  ;", "final   ServiceBuilder < Queue >    serviceBuilder    =    serviceTarget . addService ( serviceName ,    service )  . addDependency ( ActiveMQActivationService . getServiceName ( serverServiceName )  )  . addDependency ( JMSServices . getJmsManagerBaseServiceName ( serverServiceName )  ,    JMSServerManager . class ,    service . jmsServer )  . setInitialMode ( PASSIVE )  ;", "addServerExecutorDependency ( serviceBuilder ,    service . executorInjector )  ;", "serviceBuilder . install (  )  ;", "return   service ;", "}", "METHOD_END"], "methodName": ["installService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSQueueService"}, {"methodBody": ["METHOD_START", "{", "JMSQueueUpdateJndiHandler   add    =    new   JMSQueueUpdateJndiHandler ( true )  ;", "add . registerOperation ( registry ,    resolver )  ;", "JMSQueueUpdateJndiHandler   remove    =    new   JMSQueueUpdateJndiHandler ( false )  ;", "remove . registerOperation ( registry ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSQueueUpdateJndiHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "ServiceController <  ?  >    service    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( service . getValue (  )  )  ;", "return    . class . cast ( server . getManagementService (  )  . getResource ( JMS _ SERVER )  )  ;", "}", "METHOD_END"], "methodName": ["getServerControl"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServerControlHandler"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . LIST _ CONNECTIONS _ AS _ JSON ,    resolver )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . LIST _ CONSUMERS _ AS _ JSON ,    resolver )  . setParameters ( JMSServerControlHandler . CONNECTION _ ID )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . LIST _ ALL _ CONSUMERS _ AS _ JSON ,    resolver )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . LIST _ TARGET _ DESTINATIONS ,    resolver )  . setParameters ( JMSServerControlHandler . SESSION _ ID )  . setReplyType ( ModelType . LIST )  . setReplyValueType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . GET _ LAST _ SENT _ MESSAGE _ ID ,    resolver )  . setParameters ( JMSServerControlHandler . SESSION _ ID ,    JMSServerControlHandler . ADDRESS _ NAME )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . GET _ SESSION _ CREATION _ TIME ,    resolver )  . setParameters ( JMSServerControlHandler . SESSION _ ID )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . LIST _ SESSIONS _ AS _ JSON ,    resolver )  . setParameters ( JMSServerControlHandler . CONNECTION _ ID )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . LIST _ PREPARED _ TRANSACTION _ JMS _ DETAILS _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSServerControlHandler . LIST _ PREPARED _ TRANSACTION _ JMS _ DETAILS _ AS _ HTML ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServerControlHandler"}, {"methodBody": ["METHOD_START", "{", "final   JMSService   service    =    new   JMSService ( serverServiceName ,    overrideInVMSecurity )  ;", "ServiceBuilder < JMSServerManager >    builder    =    target . addService ( JMSServices . getJmsManagerBaseServiceName ( serverServiceName )  ,    service )  . addDependency ( serverServiceName ,    ActiveMQServer . class ,    service . activeMQServer )  . addDependency ( MessagingServices . ACTIVEMQ _ CLIENT _ THREAD _ POOL )  . setInitialMode ( ACTIVE )  ;", "addServerExecutorDependency ( builder ,    service . serverExecutor )  ;", "return   builder . install (  )  ;", "}", "METHOD_END"], "methodName": ["addService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSService"}, {"methodBody": ["METHOD_START", "{", "final   ServiceContainer   serviceContainer    =    context . getController (  )  . getServiceContainer (  )  ;", "ClassLoader   oldTccl    =    WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( getClass (  )  )  ;", "try    {", "jmsServer    =    new   JMSServerManagerImpl ( activeMQServer . getValue (  )  ,    new   WildFlyBindingRegistry ( context . getController (  )  . getServiceContainer (  )  )  )  ;", "activeMQServer . getValue (  )  . registerActivationFailureListener (  (    e )     -  >     {", "StartException   se    =    new   StartException ( e )  ;", "context . failed ( se )  ;", "}  )  ;", "activeMQServer . getValue (  )  . registerActivateCallback ( new   ActivateCallback (  )     {", "private   volatile   ServiceController < Void >    activeMQActivationController ;", "public   void   preActivate (  )     {", "}", "public   void   activated (  )     {", "if    ( overrideInVMSecurity )     {", "activeMQServer . getValue (  )  . getRemotingService (  )  . allowInvmSecurityOverride ( new   ActiveMQPrincipal ( DefaultCredentials . getUsername (  )  ,    DefaultCredentials . getPassword (  )  )  )  ;", "}", "if    ( serviceContainer . isShutdown (  )  )     {", "return ;", "}", "if    (  ( activeMQActivationController )     =  =    null )     {", "activeMQActivationController    =    serviceContainer . addService ( ActiveMQActivationService . getServiceName ( serverServiceName )  ,    new   ActiveMQActivationService (  )  )  . setInitialMode ( ACTIVE )  . install (  )  ;", "} else    {", "activeMQActivationController . setMode ( Mode . ACTIVE )  ;", "}", "}", "@ Override", "public   void   activationComplete (  )     {", "}", "public   void   deActivate (  )     {", "if    (  ( activeMQActivationController )     !  =    null )     {", "if    (  !  ( activeMQActivationController . getState (  )  . in ( State . STOPPING ,    State . REMOVED )  )  )     {", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "activeMQActivationController . compareAndSetMode ( Mode . ACTIVE ,    Mode . REMOVE )  ;", "activeMQActivationController . addListener ( new   AbstractServiceListener < Void >  (  )     {", "@ Override", "public   void   transition ( ServiceController <  ?    extends   Void >    controller ,    ServiceController . Transition   transition )     {", "if    ( transition . enters ( State . REMOVED )  )     {", "latch . countDown (  )  ;", "}", "}", "}  )  ;", "try    {", "latch . await (  5  ,    TimeUnit . SECONDS )  ;", "}    catch    ( InterruptedException   e )     {", "}", "activeMQActivationController    =    null ;", "}", "}", "}", "}  )  ;", "jmsServer . start (  )  ;", "}    catch    ( StartException   e )     {", "throw   e ;", "}    catch    ( Throwable   t )     {", "throw   new   StartException ( t )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "}", "}", "METHOD_END"], "methodName": ["doStart"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSService"}, {"methodBody": ["METHOD_START", "{", "try    {", "jmsServer . stop (  )  ;", "jmsServer    =    null ;", "}    catch    ( Exception   e )     {", "MLogger . ROOT _ LOGGER . errorStoppingJmsServer ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["doStop"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( jmsServer )     =  =    null )     {", "throw   new   IllegalStateException (  )  ;", "}", "return   jmsServer ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSService"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServiceName . append ( JMSServices . JMS )  . append ( JMSServices . JMS _ CF _ BASE )  ;", "}", "METHOD_END"], "methodName": ["getConnectionFactoryBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServices"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServiceName . append ( JMSServices . JMS )  . append ( JMSServices . JMS _ MANAGER )  ;", "}", "METHOD_END"], "methodName": ["getJmsManagerBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServices"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServiceName . append ( JMSServices . JMS )  . append ( JMSServices . JMS _ QUEUE _ BASE )  ;", "}", "METHOD_END"], "methodName": ["getJmsQueueBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServices"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServiceName . append ( JMSServices . JMS )  . append ( JMSServices . JMS _ TOPIC _ BASE )  ;", "}", "METHOD_END"], "methodName": ["getJmsTopicBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServices"}, {"methodBody": ["METHOD_START", "{", "if    ( node . isDefined (  )  )     {", "final   Set < String >    bindings    =    new   HashSet < String >  (  )  ;", "for    ( final   ModelNode   entry    :    node . asList (  )  )     {", "bindings . add ( entry . asString (  )  )  ;", "}", "return   bindings . toArray ( new   String [ bindings . size (  )  ]  )  ;", "}", "return    . NO _ BINDINGS ;", "}", "METHOD_END"], "methodName": ["getJndiBindings"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServices"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServiceName . append ( JMSServices . JMS )  . append ( JMSServices . JMS _ POOLED _ CF _ BASE )  ;", "}", "METHOD_END"], "methodName": ["getPooledConnectionFactoryBaseServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSServices"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ ALL _ SUBSCRIPTIONS ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( JMSTopicControlHandler . SUBSCRIPTION _ REPLY _ PARAMETER _ DEFINITIONS )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ ALL _ SUBSCRIPTIONS _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ DURABLE _ SUBSCRIPTIONS ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( JMSTopicControlHandler . SUBSCRIPTION _ REPLY _ PARAMETER _ DEFINITIONS )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ DURABLE _ SUBSCRIPTIONS _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ NON _ DURABLE _ SUBSCRIPTIONS ,    resolver )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( JMSTopicControlHandler . SUBSCRIPTION _ REPLY _ PARAMETER _ DEFINITIONS )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ NON _ DURABLE _ SUBSCRIPTIONS _ AS _ JSON ,    resolver )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ MESSAGES _ FOR _ SUBSCRIPTION ,    resolver )  . setParameters ( JMSTopicControlHandler . QUEUE _ NAME )  . setReplyType ( ModelType . LIST )  . setReplyParameters ( JMSManagementHelper . JMS _ MESSAGE _ PARAMETERS )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . LIST _ MESSAGES _ FOR _ SUBSCRIPTION _ AS _ JSON ,    resolver )  . setParameters ( JMSTopicControlHandler . QUEUE _ NAME )  . setReplyType ( ModelType . STRING )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeReadOnlyOperation ( JMSTopicControlHandler . COUNT _ MESSAGES _ FOR _ SUBSCRIPTION ,    resolver )  . setParameters ( JMSTopicControlHandler . CLIENT _ ID ,    JMSTopicControlHandler . SUBSCRIPTION _ NAME ,    CommonAttributes . FILTER )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( JMSTopicControlHandler . DROP _ DURABLE _ SUBSCRIPTION ,    resolver )  . setParameters ( JMSTopicControlHandler . CLIENT _ ID ,    JMSTopicControlHandler . SUBSCRIPTION _ NAME )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( JMSTopicControlHandler . DROP _ ALL _ SUBSCRIPTIONS ,    resolver )  . build (  )  ,    this )  ;", "registry . registerOperationHandler ( OperationDefinitionHelper . runtimeOnlyOperation ( JMSTopicControlHandler . REMOVE _ MESSAGES ,    resolver )  . setParameters ( CommonAttributes . FILTER )  . setReplyType ( ModelType . INT )  . build (  )  ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSTopicControlHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "final   String   name    =    context . getCurrentAddress (  )  . getLastElement (  )  . getValue (  )  ;", "ServiceController <  ?  >    service    =    context . getServiceRegistry ( false )  . getService ( serviceName )  ;", "ActiveMQServer   server    =    ActiveMQServer . class . cast ( service . getValue (  )  )  ;", "JMSServerControl   control    =    JMSServerControl . class . cast ( server . getManagementService (  )  . getResource ( JMS _ SERVER )  )  ;", "if    ( control    !  =    null )     {", "try    {", "control . destroyTopic ( name ,    true )  ;", "}    catch    ( Exception   e )     {", "throw   new   OperationFailedException ( e )  ;", "}", "}", "context . removeService ( JMSServices . getJmsTopicBaseServiceName ( serviceName )  . append ( name )  )  ;", "for    ( String   entry    :    CommonAttributes . DESTINATION _ ENTRIES . unwrap ( context ,    model )  )     {", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( entry )  ;", "ServiceName   binderServiceName    =    bindInfo . getBinderServiceName (  )  ;", "context . removeService ( binderServiceName )  ;", "}", "for    ( String   legacyEntry    :    CommonAttributes . LEGACY _ ENTRIES . unwrap ( context ,    model )  )     {", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( legacyEntry )  ;", "ServiceName   binderServiceName    =    bindInfo . getBinderServiceName (  )  ;", "context . removeService ( binderServiceName )  ;", "}", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSTopicRemove"}, {"methodBody": ["METHOD_START", "{", "JMSTopicAdd . INSTANCE . performRuntime ( context ,    operation ,    model )  ;", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSTopicRemove"}, {"methodBody": ["METHOD_START", "{", "final   JMSTopicService   service    =    new   JMSTopicService ( name ,    jndiBindings )  ;", "final   ServiceName   serviceName    =    JMSServices . getJmsTopicBaseServiceName ( serverServiceName )  . append ( name )  ;", "final   ServiceBuilder < Topic >    serviceBuilder    =    serviceTarget . addService ( serviceName ,    service )  . addDependency ( ActiveMQActivationService . getServiceName ( serverServiceName )  )  . addDependency ( JMSServices . getJmsManagerBaseServiceName ( serverServiceName )  ,    JMSServerManager . class ,    service . jmsServer )  . setInitialMode ( PASSIVE )  ;", "Services . addServerExecutorDependency ( serviceBuilder ,    service . executorInjector )  ;", "serviceBuilder . install (  )  ;", "return   service ;", "}", "METHOD_END"], "methodName": ["installService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSTopicService"}, {"methodBody": ["METHOD_START", "{", "JMSTopicUpdateJndiHandler   add    =    new   JMSTopicUpdateJndiHandler ( true )  ;", "add . registerOperation ( registry ,    resolver )  ;", "JMSTopicUpdateJndiHandler   remove    =    new   JMSTopicUpdateJndiHandler ( false )  ;", "remove . registerOperation ( registry ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.wildfly.extension.messaging.activemq.jms.JMSTopicUpdateJndiHandler"}, {"methodBody": ["METHOD_START", "{", "List < PooledConnectionFactoryConfigProperties >    configs    =    new   ArrayList < PooledConnectionFactoryConfigProperties >  (  )  ;", "for    ( ConnectionFactoryAttribute   nodeAttribute    :    PooledConnectionFactoryDefinition . ATTRIBUTES )     {", "if    (  !  ( nodeAttribute . isResourceAdapterProperty (  )  )  )", "continue ;", "AttributeDefinition   definition    =    nodeAttribute . getDefinition (  )  ;", "ModelNode   node    =    definition . resolveModelAttribute ( context ,    model )  ;", "if    ( node . isDefined (  )  )     {", "String   attributeName    =    definition . getName (  )  ;", "final   String   value ;", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST . getName (  )  )  )     {", "value    =    String . join (  \"  ,  \"  ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ BLACKLIST . unwrap ( context ,    model )  )  ;", "} else", "if    ( attributeName . equals ( ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST . getName (  )  )  )     {", "value    =    String . join (  \"  ,  \"  ,    ConnectionFactoryAttributes . Common . DESERIALIZATION _ WHITELIST . unwrap ( context ,    model )  )  ;", "} else    {", "value    =    node . asString (  )  ;", "}", "configs . add ( new   PooledConnectionFactoryConfigProperties ( nodeAttribute . getPropertyName (  )  ,    value ,    nodeAttribute . getClassType (  )  ,    nodeAttribute . getConfigType (  )  )  )  ;", "}", "}", "return   configs ;", "}", "METHOD_END"], "methodName": ["getAdapterParams"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryAdd"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP . getName (  )  )  )     {", "return   model . get ( ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP . getName (  )  )  . asString (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDiscoveryGroup"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryAdd"}, {"methodBody": ["METHOD_START", "{", "ServiceName   raActivatorsServiceName    =    PooledConnectionFactoryService . getResourceAdapterActivatorsServiceName ( name )  ;", "PooledConnectionFactoryStatisticsService   statsService    =    new   PooledConnectionFactoryStatisticsService ( context . getResourceRegistrationForUpdate (  )  ,    true )  ;", "context . getServiceTarget (  )  . addService ( raActivatorsServiceName . append (  \" statistics \"  )  ,    statsService )  . addDependency ( raActivatorsServiceName ,    ResourceAdapterDeployment . class ,    statsService . getRADeploymentInjector (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["installStatistics"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryAdd"}, {"methodBody": ["METHOD_START", "{", "SortedSet < String >    pooledConnectionFactoryAttributes    =    PooledConnectionFactoryAttributesTestCase . findAllResourceAdapterProperties ( PooledConnectionFactoryDefinition . ATTRIBUTES )  ;", "pooledConnectionFactoryAttributes . removeAll ( PooledConnectionFactoryAttributesTestCase . KNOWN _ ATTRIBUTES )  ;", "SortedSet < String >    activemqRAProperties    =    findAllPropertyNames ( ActiveMQResourceAdapter . class )  ;", "activemqRAProperties . removeAll ( PooledConnectionFactoryAttributesTestCase . UNSUPPORTED _ ACTIVEMQ _ RA _ PROPERTIES )  ;", "AttributesTestBase . compare (  \" AS 7    PooledConnectionFactoryAttributes \"  ,    pooledConnectionFactoryAttributes ,     \" ActiveMQ   Resource   Adapter \"  ,    activemqRAProperties )  ;", "}", "METHOD_END"], "methodName": ["compareWildFlyPooledConnectionFactoryAndActiveMQConnectionFactoryProperties"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryAttributesTestCase"}, {"methodBody": ["METHOD_START", "{", "SortedSet < String >    names    =    new   TreeSet < String >  (  )  ;", "for    (    attr    :    attrs )     {", "if    ( attr . isResourceAdapterProperty (  )  )     {", "names . add ( attr . getPropertyName (  )  )  ;", "}", "}", "return   names ;", "}", "METHOD_END"], "methodName": ["findAllResourceAdapterProperties"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryAttributesTestCase"}, {"methodBody": ["METHOD_START", "{", "return   configType ;", "}", "METHOD_END"], "methodName": ["getConfigType"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryConfigProperties"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryConfigProperties"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryConfigProperties"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryConfigProperties"}, {"methodBody": ["METHOD_START", "{", "AbstractAttributeDefinitionBuilder   builder ;", "if    ( attribute   instanceof   SimpleListAttributeDefinition )     {", "builder    =    new   SimpleListAttributeDefinition . Builder (  (  ( SimpleListAttributeDefinition )     ( attribute )  )  )  ;", "(  ( SimpleListAttributeDefinition . Builder )     ( builder )  )  . setListValidator ( attribute . getValidator (  )  )  ;", "} else", "if    ( attribute   instanceof   SimpleMapAttributeDefinition )     {", "builder    =    new   Builder (  (  ( SimpleMapAttributeDefinition )     ( attribute )  )  )  ;", "} else", "if    ( attribute   instanceof   PrimitiveListAttributeDefinition )     {", "builder    =    new   Builder (  (  ( PrimitiveListAttributeDefinition )     ( attribute )  )  )  ;", "(  ( Builder )     ( builder )  )  . setListValidator ( attribute . getValidator (  )  )  ;", "} else    {", "builder    =    new   SimpleAttributeDefinitionBuilder (  (  ( SimpleAttributeDefinition )     ( attribute )  )  )  ;", "}", "builder . setFlags ( flag )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryDefinition"}, {"methodBody": ["METHOD_START", "{", "int   size    =     ( common . length )     +     ( specific . length )  ;", "ConnectionFactoryAttribute [  ]    result    =    new   ConnectionFactoryAttribute [ size ]  ;", "System . arraycopy ( specific ,     0  ,    result ,     0  ,    specific . length )  ;", "for    ( int   i    =     0  ;    i    <     ( common . length )  ;    i +  +  )     {", "ConnectionFactoryAttribute   attr    =    common [ i ]  ;", "AttributeDefinition   definition    =    attr . getDefinition (  )  ;", "ConnectionFactoryAttribute   newAttr ;", "if    ( definition    =  =     ( ConnectionFactoryAttributes . Common . RECONNECT _ ATTEMPTS )  )     {", "AttributeDefinition   copy    =     . copy ( ConnectionFactoryAttributes . Pooled . RECONNECT _ ATTEMPTS ,    RESTART _ ALL _ SERVICES )  ;", "newAttr    =    ConnectionFactoryAttribute . create ( copy ,    ConnectionFactoryAttributes . Pooled . RECONNECT _ ATTEMPTS _ PROP _ NAME ,    true )  ;", "} else    {", "AttributeDefinition   copy    =     . copy ( definition ,    RESTART _ ALL _ SERVICES )  ;", "newAttr    =    ConnectionFactoryAttribute . create ( copy ,    attr . getPropertyName (  )  ,    attr . isResourceAdapterProperty (  )  ,    attr . getConfigType (  )  )  ;", "}", "result [  (  ( specific . length )     +    i )  ]     =    newAttr ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["define"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryDefinition"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ConnectionFactoryAttribute >    attrs    =    new   HashMap < String ,    ConnectionFactoryAttribute >  ( PooledConnectionFactoryDefinition . ATTRIBUTES . length )  ;", "for    ( ConnectionFactoryAttribute   attribute    :    PooledConnectionFactoryDefinition . ATTRIBUTES )     {", "attrs . put ( attribute . getDefinition (  )  . getName (  )  ,    attribute )  ;", "}", "return   attrs ;", "}", "METHOD_END"], "methodName": ["getAttributesMap"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryDefinition"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   operationAddress    =    operation . require ( ModelDescriptionConstants . OP _ ADDR )  ;", "final   PathAddress   address    =    PathAddress . pathAddress ( operationAddress )  ;", "final   String   name    =    address . getLastElement (  )  . getValue (  )  ;", "final   ServiceName   serviceName    =    MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( OP _ ADDR )  )  )  ;", "context . removeService ( JMSServices . getBaseServiceName ( serviceName )  . append ( name )  )  ;", "removeJNDIAliases ( context ,    model . require ( ConnectionFactoryAttributes . Common . ENTRIES . getName (  )  )  . asList (  )  )  ;", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryRemove"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries . size (  )  )     >     1  )     {", "for    ( int   i    =     1  ;    i    <     ( entries . size (  )  )  ;    i +  +  )     {", "ContextNames . BindInfo   aliasBindInfo    =    ContextNames . bindInfoFor ( entries . get ( i )  . asString (  )  )  ;", "context . rService ( aliasBindInfo . getBinderServiceName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeJNDIAliases"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryRemove"}, {"methodBody": ["METHOD_START", "{", "if    (  ( credentialSourceSupplier . getOptionalValue (  )  )     !  =    null )     {", "try    {", "CredentialSource   credentialSource    =    credentialSourceSupplier . getValue (  )  . get (  )  ;", "if    ( credentialSource    !  =    null )     {", "char [  ]    password    =    credentialSource . getCredential ( PasswordCredential . class )  . getPassword ( ClearPassword . class )  . getPassword (  )  ;", "if    ( password    !  =    null )     {", "properties . add (  . simpleProperty 1  5  (  \" password \"  ,    String . class . getName (  )  ,    new   String ( password )  )  )  ;", "}", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["configureCredential"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "List < ConnectionDefinition >    definitions    =    Collections . singletonList ( common )  ;", "return   new   ActivationImpl ( null ,    null ,    transactionSupport ,    definitions ,    Collections .  < AdminObject > emptyList (  )  ,    Collections .  < String ,    String > emptyMap (  )  ,    Collections .  < String > emptyList (  )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["createActivation"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "Integer   minSize    =     ( minPoolSize    =  =     (  -  1  )  )     ?    null    :    minPoolSize ;", "Integer   maxSize    =     ( maxPoolSize    =  =     (  -  1  )  )     ?    null    :    maxPoolSize ;", "boolean   prefill    =    false ;", "boolean   useStrictMin    =    false ;", "FlushStrategy   flushStrategy    =    FlushStrategy . FAILING _ CONNECTION _ ONLY ;", "Boolean   isXA    =    Boolean . FALSE ;", "final   Pool   pool ;", "if    ( transactionSupport    =  =     ( TransactionSupportEnum . XATransaction )  )     {", "pool    =    new   XaPoolImpl ( minSize ,    Defaults . INITIAL _ POOL _ SIZE ,    maxSize ,    prefill ,    useStrictMin ,    flushStrategy ,    null ,    Defaults . FAIR ,    Defaults . IS _ SAME _ RM _ OVERRIDE ,    Defaults . INTERLEAVING ,    Defaults . PAD _ XID ,    Defaults . WRAP _ XA _ RESOURCE ,    Defaults . NO _ TX _ SEPARATE _ POOL )  ;", "isXA    =    Boolean . TRUE ;", "} else    {", "pool    =    new   PoolImpl ( minSize ,    Defaults . INITIAL _ POOL _ SIZE ,    maxSize ,    prefill ,    useStrictMin ,    flushStrategy ,    null ,    Defaults . FAIR )  ;", "}", "TimeOut   timeOut    =    new   TimeOutImpl ( null ,    null ,    null ,    null ,    null )     {  }  ;", "Security   security    =    new   SecurityImpl ( null ,    null ,    true ,    false )  ;", "Recovery   recovery    =    new   Recovery ( new   CredentialImpl ( null ,    null ,    null ,    false ,    null )  ,    null ,    Boolean . TRUE )  ;", "Validation   validation    =    new   ValidationImpl ( Defaults . VALIDATE _ ON _ MATCH ,    null ,    null ,    false )  ;", "return   new   ConnectionDefinitionImpl ( Collections .  < String ,    String > emptyMap (  )  ,     . RAMANAGED _ CONN _ FACTORY ,    jndiName ,     . ACTIVEMQ _ CONN _ DEF ,    true ,    true ,    true ,    Defaults . SHARABLE ,    Defaults . ENLISTMENT ,    Defaults . CONNECTABLE ,    false ,    managedConnectionPoolClassName ,    enlistmentTrace ,    pool ,    timeOut ,    validation ,    security ,    recovery ,    isXA )  ;", "}", "METHOD_END"], "methodName": ["createConnDef"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   new   ConnectorImpl ( Version . V _  1  5  ,    null ,    PooledConnectionFactoryService . str (  \" Red   Hat \"  )  ,    PooledConnectionFactoryService . str (  \" JMS    1  .  1    Server \"  )  ,    PooledConnectionFactoryService . str (  \"  1  .  0  \"  )  ,    null ,    ra ,    null ,    false ,    PooledConnectionFactoryService . EMPTY _ LOCL ,    PooledConnectionFactoryService . EMPTY _ LOCL ,    Collections .  < Icon > emptyList (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["createConnector15"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "List < RequiredConfigProperty >    destination    =    Collections .  < RequiredConfigProperty > singletonList ( new   RequiredConfigPropertyImpl ( PooledConnectionFactoryService . EMPTY _ LOCL ,    PooledConnectionFactoryService . str (  \" destination \"  )  ,    null )  )  ;", "Activationspec   activation 1  5     =    new   ActivationSpecImpl ( PooledConnectionFactoryService . str ( PooledConnectionFactoryService . ACTIVEMQ _ ACTIVATION )  ,    destination ,    inboundProps ,    null )  ;", "List < MessageListener >    messageListeners    =    Collections .  < MessageListener > singletonList ( new   MessageListenerImpl ( PooledConnectionFactoryService . str ( PooledConnectionFactoryService . JMS _ MESSAGE _ LISTENER )  ,    activation 1  5  ,    null )  )  ;", "Messageadapter   message    =    new   MessageAdapterImpl ( messageListeners ,    null )  ;", "return   new   InboundResourceAdapterImpl ( message ,    null )  ;", "}", "METHOD_END"], "methodName": ["createInbound"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "for    ( final   String   alias    :    aliases )     {", "if    (  ( controller . getContainer (  )  . get ( ContextNames . bindInfoFor ( alias )  . getBinderName (  )  )  )     =  =    null )     {", "BinderUtil . installAliasBinder ( controller . getContainer (  )  ,    bindInfo ,    alias )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createJNDIAliases"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "List < ConnectionDefinition >    definitions    =    new   ArrayList (  )  ;", "List < ConfigProperty >    props    =    new   ArrayList ( outboundProperties )  ;", "props . add (  . simpleProperty 1  5  (  . SESSION _ DEFAULT _ TYPE ,     . STRING _ TYPE ,     . JMS _ QUEUE )  )  ;", "props . add (  . simpleProperty 1  5  (  . TRY _ LOCK ,     . INTEGER _ TYPE ,     \"  0  \"  )  )  ;", "definitions . add ( new   ConnectionDefinitionImpl (  . str (  . RAMANAGED _ CONN _ FACTORY )  ,    props ,     . str (  . RA _ CONN _ FACTORY )  ,     . str (  . RA _ CONN _ FACTORY _ IMPL )  ,     . str (  . JMS _ SESSION )  ,     . str (  . ACTIVEMQ _ RA _ SESSION )  ,    null )  )  ;", "AuthenticationMechanism   basicPassword    =    new   AuthenticationMechanismImpl ( Collections .  < LocalizedXsdString > emptyList (  )  ,     . str (  . BASIC _ PASS )  ,    CredentialInterfaceEnum . PasswordCredential ,    null ,    null )  ;", "return   new   OutboundResourceAdapterImpl ( definitions ,    TransactionSupportEnum . XATransaction ,    Collections . singletonList ( basicPassword )  ,    false ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["createOutbound"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   new   ResourceAdapterImpl ( PooledConnectionFactoryService . str ( PooledConnectionFactoryService . ACTIVEMQ _ RESOURCE _ ADAPTER )  ,    properties ,    outbound ,    inbound ,    Collections .  < AdminObject > emptyList (  )  ,    Collections .  < SecurityPermission > emptyList (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["createResourceAdapter15"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    null ;", "InputStream   isIj    =    null ;", "List < ConfigProperty >    properties    =    new   ArrayList < ConfigProperty >  (  )  ;", "try    {", "StringBuilder   connectorClassname    =    new   StringBuilder (  )  ;", "StringBuilder   connectorParams    =    new   StringBuilder (  )  ;", "if    (  (  (  ( discoveryGroupName )     =  =    null )     &  &     ( connectors . isEmpty (  )  )  )     &  &     ( pickAnyConnectors )  )     {", "Set < String >    connectorNames    =    activeMQServer . getValue (  )  . getConfiguration (  )  . getConnectorConfigurations (  )  . keySet (  )  ;", "if    (  ( connectorNames . size (  )  )     >     0  )     {", "String   connectorName    =    connectorNames . iterator (  )  . next (  )  ;", "MessagingLogger . ROOT _ LOGGER . connectorForPooledConnectionFactory ( name ,    connectorName )  ;", "connectors . add ( connectorName )  ;", "}", "}", "for    ( String   connector    :    connectors )     {", "TransportConfiguration   tc    =    activeMQServer . getValue (  )  . getConfiguration (  )  . getConnectorConfigurations (  )  . get ( connector )  ;", "if    ( tc    =  =    null )     {", "throw   MessagingLogger . ROOT _ LOGGER . connectorNotDefined ( connector )  ;", "}", "if    (  ( connectorClassname . length (  )  )     >     0  )     {", "connectorClassname . append (  \"  ,  \"  )  ;", "connectorParams . append (  \"  ,  \"  )  ;", "}", "connectorClassname . append ( tc . getFactoryClassName (  )  )  ;", "Map < String ,    Object >    params    =    tc . getParams (  )  ;", "boolean   multiple    =    false ;", "for    ( Map . Entry < String ,    Object >    entry    :    params . entrySet (  )  )     {", "if    ( multiple )     {", "connectorParams . append (  \"  ;  \"  )  ;", "}", "connectorParams . append ( entry . getKey (  )  )  . append (  \"  =  \"  )  . append ( entry . getValue (  )  )  ;", "multiple    =    true ;", "}", "}", "if    (  ( connectorClassname . length (  )  )     >     0  )     {", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . CONNECTOR _ CLASSNAME ,    PooledConnectionFactoryService . STRING _ TYPE ,    connectorClassname . toString (  )  )  )  ;", "}", "if    (  ( connectorParams . length (  )  )     >     0  )     {", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . CONNECTION _ PARAMETERS ,    PooledConnectionFactoryService . STRING _ TYPE ,    connectorParams . toString (  )  )  )  ;", "}", "if    (  ( discoveryGroupName )     !  =    null )     {", "DiscoveryGroupConfiguration   discoveryGroupConfiguration    =    activeMQServer . getValue (  )  . getConfiguration (  )  . getDiscoveryGroupConfigurations (  )  . get ( discoveryGroupName )  ;", "BroadcastEndpointFactory   bgCfg    =    discoveryGroupConfiguration . getBroadcastEndpointFactory (  )  ;", "if    ( bgCfg   instanceof   UDPBroadcastEndpointFactory )     {", "UDPBroadcastEndpointFactory   udpCfg    =     (  ( UDPBroadcastEndpointFactory )     ( bgCfg )  )  ;", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . GROUP _ ADDRESS ,    PooledConnectionFactoryService . STRING _ TYPE ,    udpCfg . getGroupAddress (  )  )  )  ;", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . GROUP _ PORT ,    PooledConnectionFactoryService . INTEGER _ TYPE ,     (  \"  \"     +     ( udpCfg . getGroupPort (  )  )  )  )  )  ;", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . DISCOVERY _ LOCAL _ BIND _ ADDRESS ,    PooledConnectionFactoryService . STRING _ TYPE ,     (  \"  \"     +     ( udpCfg . getLocalBindAddress (  )  )  )  )  )  ;", "} else", "if    ( bgCfg   instanceof   broadcast . CommandDispatcherBroadcastEndpointFactory )     {", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . JGROUPS _ CHANNEL _ NAME ,    PooledConnectionFactoryService . STRING _ TYPE ,    jgroupsChannelName )  )  ;", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . JGROUPS _ CHANNEL _ REF _ NAME ,    PooledConnectionFactoryService . STRING _ TYPE ,     (  (  ( serverName )     +     \"  / discovery \"  )     +     ( discoveryGroupConfiguration . getName (  )  )  )  )  )  ;", "}", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . DISCOVERY _ INITIAL _ WAIT _ TIMEOUT ,    PooledConnectionFactoryService . LONG _ TYPE ,     (  \"  \"     +     ( discoveryGroupConfiguration . getDiscoveryInitialWaitTimeout (  )  )  )  )  )  ;", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( PooledConnectionFactoryService . REFRESH _ TIMEOUT ,    PooledConnectionFactoryService . LONG _ TYPE ,     (  \"  \"     +     ( discoveryGroupConfiguration . getRefreshTimeout (  )  )  )  )  )  ;", "}", "boolean   hasReconnect    =    false ;", "final   List < ConfigProperty >    inboundProperties    =    new   ArrayList <  >  (  )  ;", "final   List < ConfigProperty >    outboundProperties    =    new   ArrayList <  >  (  )  ;", "final   String   reconnectName    =    ConnectionFactoryAttributes . Pooled . RECONNECT _ ATTEMPTS _ PROP _ NAME ;", "for    ( PooledConnectionFactoryConfigProperties   adapterParam    :    adapterParams )     {", "hasReconnect    |  =    reconnectName . equals ( adapterParam . getName (  )  )  ;", "ConfigProperty   p    =    PooledConnectionFactoryService . simpleProperty 1  5  ( adapterParam . getName (  )  ,    adapterParam . getType (  )  ,    adapterParam . getValue (  )  )  ;", "if    ( adapterParam . getName (  )  . equals ( ConnectionFactoryAttributes . Pooled . REBALANCE _ CONNECTIONS _ PROP _ NAME )  )     {", "boolean   rebalanceConnections    =    Boolean . parseBoolean ( adapterParam . getValue (  )  )  ;", "if    ( rebalanceConnections )     {", "inboundProperties . add ( p )  ;", "}", "} else    {", "if    (  ( adapterParam . getConfigType (  )  )     =  =     ( ConnectionFactoryAttribute . ConfigType . INBOUND )  )     {", "inboundProperties . add ( p )  ;", "} else", "if    (  ( adapterParam . getConfigType (  )  )     =  =     ( ConnectionFactoryAttribute . ConfigType . OUTBOUND )  )     {", "outboundProperties . add ( p )  ;", "} else    {", "properties . add ( p )  ;", "}", "}", "}", "if    (  ! hasReconnect )     {", "properties . add ( PooledConnectionFactoryService . simpleProperty 1  5  ( reconnectName ,    Integer . class . getName (  )  ,    PooledConnectionFactoryService . DEFAULT _ MAX _ RECONNECTS )  )  ;", "}", "configureCredential ( properties )  ;", "WildFlyRecoveryRegistry . container    =    container ;", "OutboundResourceAdapter   outbound    =    PooledConnectionFactoryService . createOutbound ( outboundProperties )  ;", "InboundResourceAdapter   inbound    =    createInbound ( inboundProperties )  ;", "ResourceAdapter   ra    =    createResourceAdapter 1  5  ( properties ,    outbound ,    inbound )  ;", "Connector   cmd    =    PooledConnectionFactoryService . createConnector 1  5  ( ra )  ;", "TransactionSupportEnum   transactionSupport    =    PooledConnectionFactoryService . getTransactionSupport ( txSupport )  ;", "ConnectionDefinition   common    =    PooledConnectionFactoryService . createConnDef ( transactionSupport ,    bindInfo . getBindName (  )  ,    minPoolSize ,    maxPoolSize ,    managedConnectionPoolClassName ,    enlistmentTrace )  ;", "Activation   activation    =    PooledConnectionFactoryService . createActivation ( common ,    transactionSupport )  ;", "ResourceAdapterActivatorService   activator    =    new   ResourceAdapterActivatorService ( cmd ,    activation ,    PooledConnectionFactoryService . class . getClassLoader (  )  ,    name )  ;", "activator . setBindInfo ( bindInfo )  ;", "activator . setCreateBinderService ( createBinderService )  ;", "ServiceController < ResourceAdapterDeployment >    controller    =    Services . addServerExecutorDependency ( serviceTarget . addService ( PooledConnectionFactoryService . getResourceAdapterActivatorsServiceName ( name )  ,    activator )  ,    activator . getExecutorServiceInjector (  )  )  . addDependency ( ActiveMQActivationService . getServiceName ( MessagingServices . getActiveMQServiceName ( serverName )  )  )  . addDependency ( IRONJACAMAR _ MDR ,    AS 7 MetadataRepository . class ,    activator . getMdrInjector (  )  )  . addDependency ( RA _ REPOSITORY _ SERVICE ,    ResourceAdapterRepository . class ,    activator . getRaRepositoryInjector (  )  )  . addDependency ( MANAGEMENT _ REPOSITORY _ SERVICE ,    ManagementRepository . class ,    activator . getManagementRepositoryInjector (  )  )  . addDependency ( RESOURCE _ ADAPTER _ REGISTRY _ SERVICE ,    ResourceAdapterDeploymentRegistry . class ,    activator . getRegistryInjector (  )  )  . addDependency ( TRANSACTION _ INTEGRATION _ SERVICE ,    TransactionIntegration . class ,    activator . getTxIntegrationInjector (  )  )  . addDependency ( CONNECTOR _ CONFIG _ SERVICE ,    JcaSubsystemConfiguration . class ,    activator . getConfigInjector (  )  )  . addDependency ( CCM _ SERVICE ,    CachedConnectionManager . class ,    activator . getCcmInjector (  )  )  . addDependency ( SERVICE _ NAME )  . addDependency ( JBOSS _ TXN _ TRANSACTION _ MANAGER )  . addDependency ( BOOTSTRAP _ CONTEXT _ SERVICE . append (  \" default \"  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "createJNDIAliases ( bindInfo ,    jndiAliases ,    controller )  ;", "serviceTarget . addService ( RESOURCE _ ADAPTER _ DEPLOYER _ SERVICE _ PREFIX . append ( name )  ,    NULL )  . install (  )  ;", "}    finally    {", "if    ( is    !  =    null )", "is . close (  )  ;", "if    ( isIj    !  =    null )", "isIj . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "ServiceBuilder   serviceBuilder    =    serviceTarget . addService ( serviceName ,    service )  . addDependency ( JBOSS _ TXN _ TRANSACTION _ MANAGER ,    service . transactionManager )  . addDependency ( serverServiceName ,    ActiveMQServer . class ,    service . activeMQServer )  . addDependency ( ActiveMQActivationService . getServiceName ( serverServiceName )  )  . addDependency ( JMSServices . getJmsManagerBaseServiceName ( serverServiceName )  )  . addDependency ( MessagingServices . ACTIVEMQ _ CLIENT _ THREAD _ POOL )  . addDependency ( SERVICE _ NAME )  . setInitialMode ( PASSIVE )  ;", "return   serviceBuilder ;", "}", "METHOD_END"], "methodName": ["createServiceBuilder"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   activeMQServer ;", "}", "METHOD_END"], "methodName": ["getActiveMQServer"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   credentialSourceSupplier ;", "}", "METHOD_END"], "methodName": ["getCredentialSourceSupplierInjector"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   RESOURCE _ ADAPTER _ ACTIVATOR _ SERVICE . append ( name )  ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterActivatorsServiceName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   new   MapInjector < String ,    SocketBinding >  ( socketBindings ,    name )  ;", "}", "METHOD_END"], "methodName": ["getSocketBindingInjector"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   TransaSupportEnum . valueOf ( txSupport )  ;", "}    catch    ( RuntimeException   e )     {", "return   TransaSupportEnum . LocalTransa ;", "}", "}", "METHOD_END"], "methodName": ["getTransactionSupport"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "String   jndiName    =    jndiNames . get (  0  )  ;", "this . bindInfo    =    ContextNames . bindInfoFor ( jndiName )  ;", "this . jndiAliases    =    new   ArrayList < String >  (  )  ;", "if    (  ( jndiNames . size (  )  )     >     1  )     {", "jndiAliases    =    jndiNames . subList (  1  ,    jndiNames . size (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initJNDIBindings"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "ServiceName   serverServiceName    =    MessagingServices . getActiveMQServiceName ( serverName )  ;", "ServiceName   serviceName    =    JMSServices . getPooledConnectionFactoryBaseServiceName ( serverServiceName )  . append ( name )  ;", "service    =    new    ( name ,    connectors ,    discoveryGroupName ,    serverName ,    jgroupsChannelName ,    adapterParams ,    jndiNames ,    txSupport ,    minPoolSize ,    maxPoolSize ,    managedConnectionPoolClassName ,    enlistmentTrace )  ;", ". installService 0  ( context ,    serverServiceName ,    serviceName ,    service ,    model )  ;", "}", "METHOD_END"], "methodName": ["installService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "ServiceName   serverServiceName    =    MessagingServices . getActiveMQServiceName ( serverName )  ;", "ServiceName   serviceName    =    JMSServices . getPooledConnectionFactoryBaseServiceName ( serverServiceName )  . append ( name )  ;", "service    =    new    ( name ,    connectors ,    discoveryGroupName ,    serverName ,    jgroupsChannelName ,    adapterParams ,    bindInfo ,    txSupport ,    minPoolSize ,    maxPoolSize ,    managedConnectionPoolClassName ,    enlistmentTrace ,    pickAnyConnectors )  ;", ". installService 0  ( serviceTarget ,    serverServiceName ,    serviceName ,    service )  ;", "}", "METHOD_END"], "methodName": ["installService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "ServiceBuilder   serviceBuilder    =    PooledConnectionFactoryService . createServiceBuilder ( context . getServiceTarget (  )  ,    serverServiceName ,    serviceName ,    service )  ;", "ModelNode   credentialReference    =    ConnectionFactoryAttributes . Pooled . CREDENTIAL _ REFERENCE . resolveModelAttribute ( context ,    model )  ;", "if    ( credentialReference . isDefined (  )  )     {", "service . getCredentialSourceSupplierInjector (  )  . inject ( CredentialReference . getCredentialSourceSupplier ( context ,    ConnectionFactoryAttributes . Pooled . CREDENTIAL _ REFERENCE ,    model ,    serviceBuilder )  )  ;", "}", "serviceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["installService0"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "ServiceBuilder   serviceBuilder    =    PooledConnectionFactoryService . createServiceBuilder ( serviceTarget ,    serverServiceName ,    serviceName ,    service )  ;", "serviceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["installService0"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   new   ConfigPropertyImpl ( PooledConnectionFactoryService . EMPTY _ LOCL ,    PooledConnectionFactoryService . str ( name )  ,    PooledConnectionFactoryService . str ( type )  ,    PooledConnectionFactoryService . str ( value )  ,    null ,    null ,    null ,    null ,    false ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["simpleProperty15"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "ServiceTarget   serviceTarget    =    context . getChildTarget (  )  ;", "try    {", "createService ( serviceTarget ,    context . getController (  )  . getServiceContainer (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   MLogger . ROOT _ LOGGER . failedToCreate ( e ,     \" resource   adapter \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   new   XsdString ( str ,    null )  ;", "}", "METHOD_END"], "methodName": ["str"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   injectedRADeployment ;", "}", "METHOD_END"], "methodName": ["getRADeploymentInjector"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryStatisticsService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( PooledConnectionFactoryStatisticsService . POOL _ STATISTICS )     {", "if    (  !  ( resource . hasChild ( PooledConnectionFactoryStatisticsService . POOL _ STATISTICS )  )  )     {", "resource . registerChild ( PooledConnectionFactoryStatisticsService . POOL _ STATISTICS ,    new   PlaceholderResourceEntry ( PooledConnectionFactoryStatisticsService . POOL _ STATISTICS )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerStatisticsResources"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryStatisticsService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( PooledConnectionFactoryStatisticsService . POOL _ STATISTICS )     {", "if    ( resource . hasChild ( PooledConnectionFactoryStatisticsService . POOL _ STATISTICS )  )     {", "resource . removeChild ( PooledConnectionFactoryStatisticsService . POOL _ STATISTICS )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeStatisticsResources"], "fileName": "org.wildfly.extension.messaging.activemq.jms.PooledConnectionFactoryStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   new   ListValidator ( elementValidator ,    false ,     1  ,    Integer . MAX _ VALUE )     {", "@ Override", "public   void   validateParameter ( String   parameterName ,    ModelNode   value )    throws   OperationFailedException    {", "super . validateParameter ( parameterName ,    value )  ;", "int   elementsSize    =    value . asList (  )  . size (  )  ;", "Set < ModelNode >    set    =    new   HashSet ( value . asList (  )  )  ;", "if    (  ( set . size (  )  )     !  =    elementsSize )     {", "throw   MessagingLogger . ROOT _ LOGGER . duplicateElements ( parameterName ,    value )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["noDuplicateElements"], "fileName": "org.wildfly.extension.messaging.activemq.jms.Validators"}, {"methodBody": ["METHOD_START", "{", "return   registry ;", "}", "METHOD_END"], "methodName": ["getTMRegistry"], "fileName": "org.wildfly.extension.messaging.activemq.jms.WildFlyRecoveryRegistry"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "ServiceController < XAResourceRecoveryRegistry >    service    =     (  ( ServiceController < XAResourceRecoveryRegistry >  )     (  . container . getService ( JBOSS _ TXN _ ARJUNA _ RECOVERY _ MANAGER )  )  )  ;", "return   service    =  =    null    ?    null    :    service . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getXAResourceRecoveryRegistry"], "fileName": "org.wildfly.extension.messaging.activemq.jms.WildFlyRecoveryRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( model . hasDefined ( credentialReferenceAttributeDefinition . getName (  )  )  )     {", "ModelNode   filteredModelNode    =    model ;", "if    (  ( modelFilter    !  =    null )     &  &     (  ( modelFilter . length )     >     0  )  )     {", "for    ( String   path    :    modelFilter )     {", "if    ( filteredModelNode . get ( path )  . isDefined (  )  )", "filteredModelNode    =    filteredModelNode . get ( path )  ;", "else", "break ;", "}", "}", "ModelNode   value    =    credentialReferenceAttributeDefinition . resolveModelAttribute ( context ,    filteredModelNode )  ;", "if    ( value . isDefined (  )  )     {", "credentialSourceSupplierInjector . inject ( CredentialReference . getCredentialSourceSupplier ( context ,    credentialReferenceAttributeDefinition ,    filteredModelNode ,    serviceBuilder )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addCredentialStoreReference"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeAdd"}, {"methodBody": ["METHOD_START", "{", "String   jndiName    =    attribute . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "builder . addDependency ( ContextNames . bindInfoFor ( jndiName )  . getBinderServiceName (  )  )  ;", "}", "METHOD_END"], "methodName": ["addDependencyForJNDIResource"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeAdd"}, {"methodBody": ["METHOD_START", "{", "final   Properties   sourceContextProperties    =    resolveContextProperties ( JMSBridgeDefinition . SOURCE _ CONTEXT ,    context ,    model )  ;", "final   String   sourceConnectionFactoryName    =    JMSBridgeDefinition . SOURCE _ CONNECTION _ FACTORY . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ConnectionFactoryFactory   sourceCff    =    new   JNDIConnectionFactoryFactory ( sourceContextProperties ,    sourceConnectionFactoryName )  ;", "final   String   sourceDestinationName    =    JMSBridgeDefinition . SOURCE _ DESTINATION . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   DestinationFactory   sourceDestinationFactory    =    new   JNDIDestinationFactory ( sourceContextProperties ,    sourceDestinationName )  ;", "final   Properties   targetContextProperties    =    resolveContextProperties ( JMSBridgeDefinition . TARGET _ CONTEXT ,    context ,    model )  ;", "final   String   targetConnectionFactoryName    =    JMSBridgeDefinition . TARGET _ CONNECTION _ FACTORY . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ConnectionFactoryFactory   targetCff    =    new   JNDIConnectionFactoryFactory ( targetContextProperties ,    targetConnectionFactoryName )  ;", "final   String   targetDestinationName    =    JMSBridgeDefinition . TARGET _ DESTINATION . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   DestinationFactory   targetDestinationFactory    =    new   JNDIDestinationFactory ( targetContextProperties ,    targetDestinationName )  ;", "final   String   sourceUsername    =    resolveAttribute ( JMSBridgeDefinition . SOURCE _ USER ,    context ,    model )  ;", "final   String   sourcePassword    =    resolveAttribute ( JMSBridgeDefinition . SOURCE _ PASSWORD ,    context ,    model )  ;", "final   String   targetUsername    =    resolveAttribute ( JMSBridgeDefinition . TARGET _ USER ,    context ,    model )  ;", "final   String   targetPassword    =    resolveAttribute ( JMSBridgeDefinition . TARGET _ PASSWORD ,    context ,    model )  ;", "final   String   selector    =    resolveAttribute ( CommonAttributes . SELECTOR ,    context ,    model )  ;", "final   long   failureRetryInterval    =    JMSBridgeDefinition . FAILURE _ RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   int   maxRetries    =    JMSBridgeDefinition . MAX _ RETRIES . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   QualityOfServiceMode   qosMode    =    QualityOfServiceMode . valueOf ( JMSBridgeDefinition . QUALITY _ OF _ SERVICE . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "final   int   maxBatchSize    =    JMSBridgeDefinition . MAX _ BATCH _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  ;", "final   long   maxBatchTime    =    JMSBridgeDefinition . MAX _ BATCH _ TIME . resolveModelAttribute ( context ,    model )  . asLong (  )  ;", "final   String   subName    =    resolveAttribute ( JMSBridgeDefinition . SUBSCRIPTION _ NAME ,    context ,    model )  ;", "final   String   clientID    =    resolveAttribute ( JMSBridgeDefinition . CLIENT _ ID ,    context ,    model )  ;", "final   boolean   addMessageIDInHeader    =    JMSBridgeDefinition . ADD _ MESSAGE _ ID _ IN _ HEADER . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   String   moduleName    =    resolveAttribute ( JMSBridgeDefinition . MODULE ,    context ,    model )  ;", "final   ClassLoader   oldTccl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "if    ( moduleName    !  =    null )     {", "ModuleIdentifier   moduleID    =    ModuleIdentifier . fromString ( moduleName )  ;", "Module   module    =    Module . getCallerModuleLoader (  )  . loadModule ( moduleID )  ;", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( module . getClassLoader (  )  )  ;", "}", "return   new   JMSBridgeImpl ( sourceCff ,    targetCff ,    sourceDestinationFactory ,    targetDestinationFactory ,    sourceUsername ,    sourcePassword ,    targetUsername ,    targetPassword ,    selector ,    failureRetryInterval ,    maxRetries ,    qosMode ,    maxBatchSize ,    maxBatchTime ,    subName ,    clientID ,    addMessageIDInHeader )  ;", "}    catch    ( ModuleLoadException   e )     {", "throw   MessagingLogger . ROOT _ LOGGER . unableToLoadModule ( moduleName ,    e )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "}", "}", "METHOD_END"], "methodName": ["createJMSBridge"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeAdd"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    resolveContextProperties ( attr ,    context ,    model )  ;", "return    ( properties    =  =    null )     |  |     (  ( properties . size (  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["dependsOnLocalResources"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   node    =    attr . resolveModelAttribute ( context ,    model )  ;", "return   node . isDefined (  )     ?    node . asString (  )     :    null ;", "}", "METHOD_END"], "methodName": ["resolveAttribute"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   contextModel    =    attribute . resolveModelAttribute ( context ,    model )  ;", "if    (  !  ( contextModel . isDefined (  )  )  )     {", "return   null ;", "}", "final   Properties   contextProperties    =    new   Properties (  )  ;", "for    ( Property   property    :    contextModel . asPropertyList (  )  )     {", "contextProperties . put ( property . getName (  )  ,    property . getValue (  )  . asString (  )  )  ;", "}", "return   contextProperties ;", "}", "METHOD_END"], "methodName": ["resolveContextProperties"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeAdd"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   String   bridgeName    =    address . getLastElement (  )  . getValue (  )  ;", "context . removeService ( MessagingServices . getServiceName ( bridgeName )  )  ;", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeRemove"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   String   bridgeName    =    address . getLastElement (  )  . getValue (  )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   ServiceName   jmsBridgeServiceName    =    MessagingServices . getServiceName ( bridgeName )  ;", "final   ServiceController <  ?  >    jmsBridgeServiceController    =    registry . getService ( jmsBridgeServiceName )  ;", "if    (  ( jmsBridgeServiceController    !  =    null )     &  &     (  ( jmsBridgeServiceController . getState (  )  )     =  =     ( State . UP )  )  )     {", "Service   jmsBridgeService    =     (  ( Service )     ( jmsBridgeServiceController . getService (  )  )  )  ;", "try    {", "jmsBridgeService . startBridge (  )  ;", "}    catch    ( Exception   e )     {", "throw   MessagingLogger . ROOT _ LOGGER . failedToRecover ( e ,    bridgeName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeRemove"}, {"methodBody": ["METHOD_START", "{", "return   executorInjector ;", "}", "METHOD_END"], "methodName": ["getExecutorInjector"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeService"}, {"methodBody": ["METHOD_START", "{", "return   sourceCredentialSourceSupplierInjector ;", "}", "METHOD_END"], "methodName": ["getSourceCredentialSourceSupplierInjector"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeService"}, {"methodBody": ["METHOD_START", "{", "return   targetCredentialSourceSupplierInjector ;", "}", "METHOD_END"], "methodName": ["getTargetCredentialSourceSupplierInjector"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeService"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "Controller < TransactionManager >    service    =     (  ( Controller < TransactionManager >  )     ( context . getController (  )  . getContainer (  )  . get ( JBOSS _ TXN _ TRANSACTION _ MANAGER )  )  )  ;", "return   service    =  =    null    ?    null    :    service . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeService"}, {"methodBody": ["METHOD_START", "{", "setNewJMSBridgePassword ( sourceCredentialSourceSupplierInjector . getOptionalValue (  )  ,    bridge :  : setSourcePassword )  ;", "setNewJMSBridgePassword ( targetCredentialSourceSupplierInjector . getOptionalValue (  )  ,    bridge :  : setTargetPassword )  ;", "}", "METHOD_END"], "methodName": ["setJMSBridgePasswordsFromCredentialSource"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeService"}, {"methodBody": ["METHOD_START", "{", "if    ( credentialSourceSupplier    !  =    null )     {", "try    {", "CredentialSource   credentialSource    =    credentialSourceSupplier . get (  )  ;", "if    ( credentialSource    !  =    null )     {", "char [  ]    password    =    credentialSource . getCredential ( PasswordCredential . class )  . getPassword ( ClearPassword . class )  . getPassword (  )  ;", "if    ( password    !  =    null )     {", "passwordConsumercept ( new   String ( password )  )  ;", "}", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setNewJMSBridgePassword"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeService"}, {"methodBody": ["METHOD_START", "{", "final   Module   module ;", "if    (  ( moduleName )     !  =    null )     {", "ModuleIdentifier   moduleID    =    ModuleIdentifier . fromString ( moduleName )  ;", "module    =    Module . getContextModuleLoader (  )  . loadModule ( moduleID )  ;", "} else    {", "module    =    Module . forClass (  . class )  ;", "}", "ClassLoader   oldTccl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( module . getClassLoader (  )  )  ;", "setJMSBridgePasswordsFromCredentialSource (  )  ;", "bridge . start (  )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "}", "MessagingLogger . ROOT _ LOGGER . startedService (  \" JMS   Bridge \"  ,    bridgeName )  ;", "}", "METHOD_END"], "methodName": ["startBridge"], "fileName": "org.wildfly.extension.messaging.activemq.jms.bridge.JMSBridgeService"}, {"methodBody": ["METHOD_START", "{", "boolean   ha    =    LegacyConnectionFactoryDefinition . HA . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "String   factoryTypeStr    =    LegacyConnectionFactoryDefinition . FACTORY _ TYPE . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "JMSFactoryType   factoryType    =    LegacyConnectionFactoryDefinition . HornetQConnectionFactoryType . valueOf ( factoryTypeStr )  . getType (  )  ;", "final   HornetQConnectionFactory   incompleteCF ;", "if    ( ha )     {", "incompleteCF    =    HornetQJMSClient . createConnectionFactoryWithHA ( factoryType )  ;", "} else    {", "incompleteCF    =    HornetQJMSClient . createConnectionFactoryWithoutHA ( factoryType )  ;", "}", "incompleteCF . setAutoGroup ( LegacyConnectionFactoryDefinition . AUTO _ GROUP . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "incompleteCF . setBlockOnAcknowledge ( LegacyConnectionFactoryDefinition . BLOCK _ ON _ ACKNOWLEDGE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "incompleteCF . setBlockOnDurableSend ( LegacyConnectionFactoryDefinition . BLOCK _ ON _ DURABLE _ SEND . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "incompleteCF . setBlockOnNonDurableSend ( LegacyConnectionFactoryDefinition . BLOCK _ ON _ NON _ DURABLE _ SEND . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "incompleteCF . setCacheLargeMessagesClient ( LegacyConnectionFactoryDefinition . CACHE _ LARGE _ MESSAGE _ CLIENT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "incompleteCF . setCallFailoverTimeout ( CommonAttributes . CALL _ FAILOVER _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "incompleteCF . setCallTimeout ( CommonAttributes . CALL _ TIMEOUT . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "incompleteCF . setClientFailureCheckPeriod ( LegacyConnectionFactoryDefinition . CLIENT _ FAILURE _ CHECK _ PERIOD . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "final   ModelNode   clientID    =    CommonAttributes . CLIENT _ ID . resolveModelAttribute ( context ,    model )  ;", "if    ( clientID . isDefined (  )  )     {", "incompleteCF . setClientID ( clientID . asString (  )  )  ;", "}", "incompleteCF . setCompressLargeMessage ( LegacyConnectionFactoryDefinition . COMPRESS _ LARGE _ MESSAGES . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "incompleteCF . setConfirmationWindowSize ( LegacyConnectionFactoryDefinition . CONFIRMATION _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "final   ModelNode   connectionLoadBalancingClassName    =    LegacyConnectionFactoryDefinition . CONNECTION _ LOAD _ BALANCING _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  ;", "if    ( connectionLoadBalancingClassName . isDefined (  )  )     {", "incompleteCF . setConnectionLoadBalancingPolicyClassName ( connectionLoadBalancingClassName . asString (  )  )  ;", "}", "incompleteCF . setConnectionTTL ( LegacyConnectionFactoryDefinition . CONNECTION _ TTL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "incompleteCF . setConsumerMaxRate ( LegacyConnectionFactoryDefinition . CONSUMER _ MAX _ RATE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setConsumerWindowSize ( LegacyConnectionFactoryDefinition . CONSUMER _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setConfirmationWindowSize ( LegacyConnectionFactoryDefinition . CONFIRMATION _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setDupsOKBatchSize ( LegacyConnectionFactoryDefinition . DUPS _ OK _ BATCH _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setFailoverOnInitialConnection ( LegacyConnectionFactoryDefinition . FAILOVER _ ON _ INITIAL _ CONNECTION . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "final   ModelNode   groupID    =    LegacyConnectionFactoryDefinition . GROUP _ ID . resolveModelAttribute ( context ,    model )  ;", "if    ( groupID . isDefined (  )  )     {", "incompleteCF . setGroupID ( groupID . asString (  )  )  ;", "}", "incompleteCF . setInitialConnectAttempts ( LegacyConnectionFactoryDefinition . INITIAL _ CONNECT _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setInitialMessagePacketSize ( LegacyConnectionFactoryDefinition . INITIAL _ MESSAGE _ PACKET _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setMaxRetryInterval ( LegacyConnectionFactoryDefinition . MAX _ RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "incompleteCF . setMinLargeMessageSize ( LegacyConnectionFactoryDefinition . MIN _ LARGE _ MESSAGE _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setPreAcknowledge ( LegacyConnectionFactoryDefinition . PRE _ ACKNOWLEDGE . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "incompleteCF . setProducerMaxRate ( LegacyConnectionFactoryDefinition . PRODUCER _ MAX _ RATE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setProducerWindowSize ( LegacyConnectionFactoryDefinition . PRODUCER _ WINDOW _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setReconnectAttempts ( LegacyConnectionFactoryDefinition . RECONNECT _ ATTEMPTS . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setRetryInterval ( LegacyConnectionFactoryDefinition . RETRY _ INTERVAL . resolveModelAttribute ( context ,    model )  . asLong (  )  )  ;", "incompleteCF . setRetryIntervalMultiplier ( LegacyConnectionFactoryDefinition . RETRY _ INTERVAL _ MULTIPLIER . resolveModelAttribute ( context ,    model )  . asDouble (  )  )  ;", "incompleteCF . setScheduledThreadPoolMaxSize ( LegacyConnectionFactoryDefinition . SCHEDULED _ THREAD _ POOL _ MAX _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setThreadPoolMaxSize ( LegacyConnectionFactoryDefinition . THREAD _ POOL _ MAX _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setTransactionBatchSize ( LegacyConnectionFactoryDefinition . TRANSACTION _ BATCH _ SIZE . resolveModelAttribute ( context ,    model )  . asInt (  )  )  ;", "incompleteCF . setUseGlobalPools ( LegacyConnectionFactoryDefinition . USE _ GLOBAL _ POOLS . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "return   incompleteCF ;", "}", "METHOD_END"], "methodName": ["createLegacyConnectionFactory"], "fileName": "org.wildfly.extension.messaging.activemq.jms.legacy.LegacyConnectionFactoryAdd"}, {"methodBody": ["METHOD_START", "{", "final   LegacyConnectionFactoryService   service    =    new   LegacyConnectionFactoryService ( uncompletedConnectionFactory ,    discoveryGroupName ,    connectors )  ;", "final   ServiceName   serviceName    =    JMSServices . getConnectionFactoryBaseServiceName ( activeMQServerServiceName )  . append ( CommonAttributes . LEGACY ,    name )  ;", "serviceTarget . addService ( serviceName ,    service )  . addDependency ( ActiveMQActivationService . getServiceName ( activeMQServerServiceName )  )  . addDependency ( activeMQServerServiceName ,    ActiveMQServer . class ,    service . injectedActiveMQServer )  . setInitialMode ( PASSIVE )  . install (  )  ;", "return   service ;", "}", "METHOD_END"], "methodName": ["installService"], "fileName": "org.wildfly.extension.messaging.activemq.jms.legacy.LegacyConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "BroadcastEndpointFactory   newBroadcastEndpointFactory    =    newDiscoveryGroupConfiguration . getBroadcastEndpointFactory (  )  ;", "BroadcastEndpointFactoryConfiguration   legacyBroadcastEndpointFactory ;", "if    ( newBroadcastEndpointFactory   instanceof   UDPBroadcastEndpointFactory )     {", "UDPBroadcastEndpointFactory   factory    =     (  ( UDPBroadcastEndpointFactory )     ( newBroadcastEndpointFactory )  )  ;", "legacyBroadcastEndpointFactory    =    new   UDPBroadcastGroupConfiguration ( factory . getGroupAddress (  )  ,    factory . getGroupPort (  )  ,    factory . getLocalBindAddress (  )  ,    factory . getLocalBindPort (  )  )  ;", "} else", "if    ( newBroadcastEndpointFactory   instanceof   ChannelBroadcastEndpointFactory )     {", "ChannelBroadcastEndpointFactory   factory    =     (  ( ChannelBroadcastEndpointFactory )     ( newBroadcastEndpointFactory )  )  ;", "legacyBroadcastEndpointFactory    =    new   JGroupsBroadcastGroupConfiguration ( factory . getChannel (  )  ,    factory . getChannelName (  )  )  ;", "} else    {", "throw   logging . MessagingLogger . ROOT _ LOGGER . unsupportedBroadcastGroupConfigurationForLegacy ( newBroadcastEndpointFactory . getClass (  )  . getName (  )  )  ;", "}", "return   new   DiscoveryGroupConfiguration ( newDiscoveryGroupConfiguration . getName (  )  ,    newDiscoveryGroupConfiguration . getRefreshTimeout (  )  ,    newDiscoveryGroupConfiguration . getDiscoveryInitialWaitTimeout (  )  ,    legacyBroadcastEndpointFactory )  ;", "}", "METHOD_END"], "methodName": ["translateDiscoveryGroupConfiguration"], "fileName": "org.wildfly.extension.messaging.activemq.jms.legacy.LegacyConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "if    ( newFactoryClassName . equals ( NettyConnectorFactory . class . getName (  )  )  )     {", "return   getName (  )  ;", "} else    {", "throw   MessagingLogger . ROOT _ LOGGER . unsupportedConnectorFactoryForLegacy ( newFactoryClassName . getClass (  )  . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["translateFactoryClassName"], "fileName": "org.wildfly.extension.messaging.activemq.jms.legacy.LegacyConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    legacyParams    =    new   HashMap <  >  (  )  ;", "for    ( Map . Entry < String ,    Object >    newEntry    :    newParams . entrySet (  )  )     {", "String   newKey    =    newEntry . getKey (  )  ;", "Object   value    =    newEntry . getValue (  )  ;", "String   legacyKey    =     . PARAM _ KEY _ MAPPING . getOrDefault ( newKey ,    newKey )  ;", "if    ( ACTIVEMQ _ SERVER _ NAME . equals ( legacyKey )  )     {", "continue ;", "}", "legacyParams . put ( legacyKey ,    value )  ;", "}", "return   legacyParams ;", "}", "METHOD_END"], "methodName": ["translateParams"], "fileName": "org.wildfly.extension.messaging.activemq.jms.legacy.LegacyConnectionFactoryService"}, {"methodBody": ["METHOD_START", "{", "List < TransportConfiguration >    legacyConnectorConfigurations    =    new   ArrayList <  >  (  )  ;", "for    ( String   connectorName    :    connectors )     {", "TransportConfiguration   newTransportConfiguration    =    connectorConfigurations . get ( connectorName )  ;", "String   legacyFactoryClassName    =    translateFactoryClassName ( newTransportConfiguration . getFactoryClassName (  )  )  ;", "Map   legacyParams    =    translateParams ( newTransportConfiguration . getParams (  )  )  ;", "TransportConfiguration   legacyTransportConfiguration    =    new   TransportConfiguration ( legacyFactoryClassName ,    legacyParams ,    newTransportConfiguration . getName (  )  )  ;", "legacyConnectorConfigurations . add ( legacyTransportConfiguration )  ;", "}", "return   legacyConnectorConfigurations . toArray ( new   TransportConfiguration [ legacyConnectorConfigurations . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["translateTransportGroupConfigurations"], "fileName": "org.wildfly.extension.messaging.activemq.jms.legacy.LegacyConnectionFactoryService"}]