[{"methodBody": ["METHOD_START", "{", "return    ( Modifier . isPrivate ( method . getModifiers (  )  )  )     |  |     (  ( ClassReflectionIndexUtil . findRequiredMethod ( deploymentReflectionIndex ,    actualClass ,    method )  . getDeclaringClass (  )  )     =  =    clazz )  ;", "}", "METHOD_END"], "methodName": ["isNotOverriden"], "fileName": "org.jboss.as.ee.component.AbstractComponentConfigurator"}, {"methodBody": ["METHOD_START", "{", "final   Map < InjectionTarget ,    ResourceInjectionConfiguration >    mergedInjections    =    new   HashMap < InjectionTarget ,    ResourceInjectionConfiguration >  (  )  ;", "if    (  ( classDescription    !  =    null )     &  &     (  ! metadataComplete )  )     {", "mergedInjections . putAll ( classDescription . getInjectionConfigurations (  )  )  ;", "}", "mergedInjections . putAll ( moduleDescription . getResourceInjections ( clazz . getName (  )  )  )  ;", "mergedInjections . putAll ( description . getResourceInjections ( clazz . getName (  )  )  )  ;", "for    ( final   ResourceInjectionConfiguration   injectionConfiguration    :    mergedInjections . values (  )  )     {", "if    (  (  !  ( moduleDescription . isAppClient (  )  )  )     &  &     ( injectionConfiguration . getTarget (  )  . isStatic ( context . getDeploymentUnit (  )  )  )  )     {", "EeLogger . ROOT _ LOGGER . debugf (  \" Injection   for   a   member   with   static   modifier   is   only   acceptable   on   application   clients ,    ignoring   injection   for   target    % s \"  ,    injectionConfiguration . getTarget (  )  )  ;", "continue ;", "}", "if    (  ( injectionConfiguration . getTarget (  )  )    instanceof   MethodInjectionTarget )     {", "final   MethodInjectionTarget   mt    =     (  ( MethodInjectionTarget )     ( injectionConfiguration . getTarget (  )  )  )  ;", "Method   method    =    mt . getMethod ( deploymentReflectionIndex ,    clazz )  ;", "if    (  !  ( isNotOverriden ( clazz ,    method ,    actualClass ,    deploymentReflectionIndex )  )  )     {", "continue ;", "}", "}", "final   Object   valueContextKey    =    new   Object (  )  ;", "final   InjectedValue < ManagedReferenceFactory >    managedReferenceFactoryValue    =    new   InjectedValue < ManagedReferenceFactory >  (  )  ;", "configuration . getStartDependencies (  )  . add ( new   ComponentDescription . Injected ( injectionConfiguration ,    configuration ,    context ,    managedReferenceFactoryValue )  )  ;", "injectors . addFirst ( injectionConfiguration . getTarget (  )  . createInjectionInterceptorFactory ( instanceKey ,    valueContextKey ,    managedReferenceFactoryValue ,    context . getDeploymentUnit (  )  ,    injectionConfiguration . isOptional (  )  )  )  ;", "uninjectors . addLast ( new   ImmediateInterceptorFactory ( new   ManagedReferenceReleaseInterceptor ( valueContextKey )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeInjectionsForClass"], "fileName": "org.jboss.as.ee.component.AbstractComponentConfigurator"}, {"methodBody": ["METHOD_START", "{", "if    ( interceptorFactories    =  =    null )     {", "return   null ;", "}", "return   new   InterceptorFactory (  )     {", "@ Override", "public   Interceptor   create ( InterceptorFactoryContext   context )     {", "final   Interceptor [  ]    interceptors    =    new   Interceptor [ interceptorFactories . size (  )  ]  ;", "final   Ite < InterceptorFactory >    factories    =    interceptorFactories . ite (  )  ;", "for    ( int   i    =     0  ;    i    <     ( interceptors . length )  ;    i +  +  )     {", "interceptors [ i ]     =    factories . next (  )  . create ( context )  ;", "}", "return   Interceptors . getWeavedInterceptor ( interceptors )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["weaved"], "fileName": "org.jboss.as.ee.component.AbstractComponentConfigurator"}, {"methodBody": ["METHOD_START", "{", "return   constructComponentInstance ( instance ,    invokePostConstruct ,    Collections . emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["constructComponentInstance"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "waitForComponentStart (  )  ;", "final   Instance   basicComponentInstance    =    this . instantiateComponentInstance ( preDestroyInterceptor ,    interceptorInstanceMap ,    context )  ;", "if    ( instance    !  =    null )     {", "basicComponentInstance . setInstanceData ( Instance . INSTANCE _ KEY ,    instance )  ;", "}", "if    ( invokePostConstruct )     {", "final   InterceptorContext   interceptorContext    =    new   InterceptorContext (  )  ;", "interceptorContext . putPrivateData ( Component . class ,    this )  ;", "interceptorContext . putPrivateData ( ComponentInstance . class ,    basicComponentInstance )  ;", "interceptorContext . putPrivateData ( InvocationType . class ,    InvocationType . POST _ CONSTRUCT )  ;", "interceptorContext . setContextData ( new   HashMap < String ,    Object >  (  )  )  ;", "try    {", "postConstructInterceptor . processInvocation ( interceptorContext )  ;", "}    catch    ( Exception   e )     {", "throw   EeLogger . ROOT _ LOGGER . componentConstructionFailure ( e )  ;", "}", "}", "componentInstanceCreated ( basicComponentInstance )  ;", "return   basicComponentInstance ;", "}", "METHOD_END"], "methodName": ["constructComponentInstance"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "BasicComponentInstance   instance    =    constructComponentInstance ( null ,    true )  ;", "return   instance ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "BasicComponentInstance   obj    =    constructComponentInstance ( new   ImmediateManagedReference ( instance )  ,    true )  ;", "obj . constructionFinished (  )  ;", "return   obj ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "postConstructInterceptor    =    this . postConstruct . create ( context )  ;", "preDestroyInterceptor    =    this . getPreDestroy (  )  . create ( context )  ;", "final   Map < Method ,    InterceptorFactory >    interceptorFactoryMap    =    this . getInterceptorFactoryMap (  )  ;", "final   IdityHashMap < Method ,    Interceptor >    interceptorMap    =    new   IdityHashMap < Method ,    Interceptor >  (  )  ;", "for    ( Method   method    :    interceptorFactoryMap . keySet (  )  )     {", "interceptorMap . put ( method ,    interceptorFactoryMap . get ( method )  . create ( context )  )  ;", "}", "this . interceptorInstanceMap    =    interceptorMap ;", "}", "METHOD_END"], "methodName": ["createInterceptors"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   componentClass ;", "}", "METHOD_END"], "methodName": ["getComponentClass"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   componentName ;", "}", "METHOD_END"], "methodName": ["getComponentName"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   createServiceName ;", "}", "METHOD_END"], "methodName": ["getCreateServiceName"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   interceptorFactoryMap ;", "}", "METHOD_END"], "methodName": ["getInterceptorFactoryMap"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   preDestroy ;", "}", "METHOD_END"], "methodName": ["getPreDestroy"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorFactoryContext   context    =    new   SimpleInterceptorFactoryContext (  )  ;", "context . getContextData (  )  . put ( Cclass ,    this )  ;", "createInterceptors ( context )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   BasicComponentInstance ( this ,    preDestroyInterceptor ,    methodInterceptors )  ;", "}", "METHOD_END"], "methodName": ["instantiateComponentInstance"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnitServiceName . append (  \" component \"  )  . append ( componentName )  ;", "}", "METHOD_END"], "methodName": ["serviceNameOf"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "init (  )  ;", "thiopping . t ( fal )  ;", "gate    =    true ;", "notifyAll (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( stopping . compareAndSet ( false ,    true )  )     {", "synchronized ( this )     {", "gate    =    false ;", "this . interceptorInstanceMap    =    null ;", "this . preDestroyInterceptor    =    null ;", "this . postConstructInterceptor    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( gate )  )     {", "EeLogger . ROOT _ LOGGER . tracef (  \" Waiting   for    % s    (  % s )  \"  , Name , Class )  ;", "synchronized ( this )     {", "if    ( stopping . get (  )  )     {", "throw   EeLogger . ROOT _ LOGGERIsStopped (  )  ;", "}", "while    (  !  ( gate )  )     {", "try    {", "wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "throw   EeLogger . ROOT _ LOGGERNotAvailable (  )  ;", "}", "}", "}", "EeLogger . ROOT _ LOGGER . tracef (  \" Finished   waiting   for    % s    (  % s )  \"  , Name , Class )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForComponentStart"], "fileName": "org.jboss.as.ee.component.BasicComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   BasicComponent ( this )  ;", "}", "METHOD_END"], "methodName": ["createComponent"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   componentClass ;", "}", "METHOD_END"], "methodName": ["getComponentClass"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   componentInterceptors ;", "}", "METHOD_END"], "methodName": ["getComponentInterceptors"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   componentName ;", "}", "METHOD_END"], "methodName": ["getComponentName"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit ;", "}", "METHOD_END"], "methodName": ["getDeploymentUnitInjector"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   namespaceContextSelector ;", "}", "METHOD_END"], "methodName": ["getNamespaceContextSelector"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   postConstruct ;", "}", "METHOD_END"], "methodName": ["getPostConstruct"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   preDestroy ;", "}", "METHOD_END"], "methodName": ["getPreDestroy"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceName ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    this . component ;", "if    ( component    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . serviceNotStarted (  )  ;", "}", "return   component ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Modifier . isPublic ( method . getModifiers (  )  )  )     &  &     (  !  ( Modifier . isFinal ( method . getModifiers (  )  )  )  )  )     &  &     ( componentConfiguration . getComponentDescription (  )  . isIntercepted (  )  )  ;", "}", "METHOD_END"], "methodName": ["requiresInterceptors"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "component    =    createComponent (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "component    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ee.component.BasicComponentCreateService"}, {"methodBody": ["METHOD_START", "{", "return   methodMap . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["allowedMethods"], "fileName": "org.jboss.as.ee.component.BasicComponentInstance"}, {"methodBody": ["METHOD_START", "{", "this . constructionFinished    =    true ;", "}", "METHOD_END"], "methodName": ["constructionFinished"], "fileName": "org.jboss.as.ee.component.BasicComponentInstance"}, {"methodBody": ["METHOD_START", "{", "if    ( BasicComponentInstance . doneUpdater . compareAndSet ( this ,     0  ,     1  )  )", "try    {", "preDestroy (  )  ;", "final   Object   instance    =    getInstance (  )  ;", "if    ( instance    !  =    null )     {", "final   InterceptorContext   interceptorContext    =    prepareInterceptorContext (  )  ;", "interceptorContext . setTarget ( instance )  ;", "interceptorContext . putPrivateData ( interceptors . InvocationType . class ,    interceptors . InvocationType . PRE _ DESTROY )  ;", "preDestroy . processInvocation ( interceptorContext )  ;", "}", "}    catch    ( Exception   e )     {", "componentDestroyFailure ( e ,    this )  ;", "}    finally    {", "component . finishDestroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.jboss.as.ee.component.BasicComponentInstance"}, {"methodBody": ["METHOD_START", "{", "return   component ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.jboss.as.ee.component.BasicComponentInstance"}, {"methodBody": ["METHOD_START", "{", "ManagedReference   managedReference    =     (  ( ManagedReference )     ( getInstanceData ( BasicComponentInstance . INSTANCE _ KEY )  )  )  ;", "if    ( managedReference    =  =    null )     {", "return   null ;", "}", "return   managedReference . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.jboss.as.ee.component.BasicComponentInstance"}, {"methodBody": ["METHOD_START", "{", "Interceptor   interceptor    =    methodMap . get ( method )  ;", "if    ( interceptor    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . methodNotFound ( method )  ;", "}", "return   interceptor ;", "}", "METHOD_END"], "methodName": ["getInterceptor"], "fileName": "org.jboss.as.ee.component.BasicComponentInstance"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorContext   interceptorContext    =    new   InterceptorContext (  )  ;", "interceptorContext . putPrivateData ( Component . class ,    component )  ;", "interceptorContext . putPrivateData (  . class ,    this )  ;", "interceptorContext . setContextData ( new   HashMap < String ,    Object >  (  )  )  ;", "return   interceptorContext ;", "}", "METHOD_END"], "methodName": ["prepareInterceptorContext"], "fileName": "org.jboss.as.ee.component.BasicComponentInstance"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   BindingConfiguration )  )", "return   false ;", "BindingConfiguration   config    =     (  ( BindingConfiguration )     ( other )  )  ;", "return    ( name . equals ( config . name )  )     &  &     ( source . equals ( config . source )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.BindingConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.ee.component.BindingConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.jboss.as.ee.component.BindingConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    (  ( name . hashCode (  )  )     *     3  1  )     +     ( source . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.BindingConfiguration"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    this . clazz ;", "final   List < EEModule >    queue    =    new   ArrayList < EEModule >  (  )  ;", "final   List < Class <  ?  >  >    classQueue    =    new   ArrayList < Class <  ?  >  >  (  )  ;", "while    (  ( clazz    !  =    null )     &  &     ( clazz    !  =     ( Object . class )  )  )     {", "final   EEModule   configuration    =    applicationClasses . getClassByName ( clazz . getName (  )  )  ;", "queue . add ( configuration )  ;", "classQueue . add ( clazz )  ;", "clazz    =    clazz . getSuperclass (  )  ;", "}", "for    ( int   i    =     ( queue . size (  )  )     -     1  ;    i    >  =     0  ;     -  - i )     {", "final   EEModule   config    =    queue . get ( i )  ;", "if    ( config    !  =    null )     {", "handle ( classQueue . get ( i )  ,    config )  ;", "} else    {", "handle ( classQueue . get ( i )  ,    null )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.jboss.as.ee.component.ClassDescriptionTraversal"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isRemotable"], "fileName": "org.jboss.as.ee.component.Component"}, {"methodBody": ["METHOD_START", "{", "constructionComplete    =    true ;", "}", "METHOD_END"], "methodName": ["constructionComplete"], "fileName": "org.jboss.as.ee.component.ComponentClientInstance"}, {"methodBody": ["METHOD_START", "{", "return   contextInformation . get ( key )  ;", "}", "METHOD_END"], "methodName": ["getViewInstanceData"], "fileName": "org.jboss.as.ee.component.ComponentClientInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < Object ,    Object >    entry    :    contextInformation . entrySet (  )  )     {", "interceptorContext . putPrivateData ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareInterceptorContext"], "fileName": "org.jboss.as.ee.component.ComponentClientInstance"}, {"methodBody": ["METHOD_START", "{", "if    ( constructionComplete )     {", "throw   EeLogger . ROOT _ LOGGER . iDataCanOnlyBeSetDuringConstruction (  )  ;", "}", "contextInformation . put ( key ,    data )  ;", "}", "METHOD_END"], "methodName": ["setViewInstanceData"], "fileName": "org.jboss.as.ee.component.ComponentClientInstance"}, {"methodBody": ["METHOD_START", "{", "aroundConstructInterceptors . add ( Collections . singletonList ( interceptorFactory )  ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addAroundConstructInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "aroundConstructInterceptors . add ( factories ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addAroundConstructInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "addComponentInterceptors ( method ,    Collections . singletonList ( factory )  ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addComponentInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "addComponentInterceptors ( Collections . singletonList ( factory )  ,    priority ,    publicOnly )  ;", "}", "METHOD_END"], "methodName": ["addComponentInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "OrderedItemContainer < List < InterceptorFactory >  >    interceptors    =    componentInterceptors . get ( method )  ;", "if    ( interceptors    =  =    null )     {", "componentInterceptors . put ( method ,     ( interceptors    =    new   OrderedItemContainer < List < InterceptorFactory >  >  (  )  )  )  ;", "}", "interceptors . add ( factory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addComponentInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :     (  ( Iterable < Method >  )     ( classIndex . getClassMethods (  )  )  )  )     {", "if    ( publicOnly    &  &     (  !  ( Modifier . isPublic ( method . getModifiers (  )  )  )  )  )     {", "continue ;", "}", "OrderedItemContainer < List < InterceptorFactory >  >    interceptors    =    Interceptors . get ( method )  ;", "if    ( interceptors    =  =    null )     {", "Interceptors . put ( method ,     ( interceptors    =    new   OrderedItemContainer < List < InterceptorFactory >  >  (  )  )  )  ;", "}", "interceptors . add ( factory ,    priority )  ;", "}", "}", "METHOD_END"], "methodName": ["addComponentInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "lifecycleMethods . add ( method )  ;", "}", "METHOD_END"], "methodName": ["addLifecycleMethod"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "postActivateInterceptors . add ( Collections . singletonList ( interceptorFactory )  ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPostActivateInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "postActivateInterceptors . add ( interceptorFactory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPostActivateInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "postConstructInterceptors . add ( Collections . singletonList ( interceptorFactory )  ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPostConstructInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "postConstructInterceptors . add ( interceptorFactory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPostConstructInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "preDestroyInterceptors . add ( Collections . singletonList ( interceptorFactory )  ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPreDestroyInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "preDestroyInterceptors . add ( factories ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPreDestroyInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "prePassivateInterceptors . add ( Collections . singletonList ( interceptorFactory )  ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPrePassivateInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "prePassivateInterceptors . add ( factories ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addPrePassivateInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "OrderedItemContainer < InterceptorFactory >    interceptors    =    timeoutInterceptors . get ( method )  ;", "if    ( interceptors    =  =    null )     {", "timeoutInterceptors . put ( method ,     ( interceptors    =    new   OrderedItemContainer < InterceptorFactory >  (  )  )  )  ;", "}", "interceptors . add ( factory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addTimeoutViewInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :     (  ( Iterable < Method >  )     ( classIndex . getClassMethods (  )  )  )  )     {", "OrderedItemtainer < InterceptorFactory >    interceptors    =    timeoutInterceptors . get ( method )  ;", "if    ( interceptors    =  =    null )     {", "timeoutInterceptors . put ( method ,     ( interceptors    =    new   OrderedItemtainer < InterceptorFactory >  (  )  )  )  ;", "}", "interceptors . add ( factory ,    priority )  ;", "}", "}", "METHOD_END"], "methodName": ["addTimeoutViewInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   componentDescription . getApplicationName (  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "List < List < InterceptorFactory >  >    sortedItems    =    aroundConstructInterceptors . getSortedItems (  )  ;", "List < InterceptorFactory >    interceptorFactories    =    new   ArrayList <  >  (  )  ;", "for    ( List < InterceptorFactory >    i    :    sortedItems )     {", "interceptorFactories . addAll ( i )  ;", "}", "return   interceptorFactories ;", "}", "METHOD_END"], "methodName": ["getAroundConstructInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "Map < Method ,    OrderedItemContainer < InterceptorFactory >  >    map    =    timeoutInterceptors ;", "OrderedItemContainer < InterceptorFactory >    interceptors    =    map . get ( method )  ;", "if    ( interceptors    =  =    null )     {", "return   Collecs . emptyList (  )  ;", "}", "return   interceptors . getSortedItems (  )  ;", "}", "METHOD_END"], "methodName": ["getAroundTimeoutInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   classIndex ;", "}", "METHOD_END"], "methodName": ["getClassIndex"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   classIndex . getIndexedClass (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentClass"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   componentCreateServiceFactory ;", "}", "METHOD_END"], "methodName": ["getComponentCreateServiceFactory"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   componentDescription ;", "}", "METHOD_END"], "methodName": ["getComponentDescription"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "Map < Method ,    OrderedItemContainer < List < InterceptorFactory >  >  >    map    =    componentInterceptors ;", "OrderedItemContainer < List < InterceptorFactory >  >    interceptors    =    map . get ( method )  ;", "if    ( interceptors    =  =    null )     {", "return   Collections . emptyList (  )  ;", "}", "List < List < InterceptorFactory >  >    sortedItems    =    interceptors . getSortedItems (  )  ;", "List < InterceptorFactory >    ret    =    new   ArrayList <  >  (  )  ;", "for    ( List < InterceptorFactory >    item    :    sortedItems )     {", "ret . addAll ( item )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["getComponentInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   componentDescription . getComponentName (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentName"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   concurrentContext ;", "}", "METHOD_END"], "methodName": ["getConcurrentContext"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   createDependencies ;", "}", "METHOD_END"], "methodName": ["getCreateDependencies"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   classIndex . getClassMethods (  )  ;", "}", "METHOD_END"], "methodName": ["getDefinedComponentMethods"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   instanceFactory ;", "}", "METHOD_END"], "methodName": ["getInstanceFactory"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   interceptorContextKeys ;", "}", "METHOD_END"], "methodName": ["getInterceptorContextKeys"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( lifecycleMethods )  ;", "}", "METHOD_END"], "methodName": ["getLifecycleMethods"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   moduleClassLoader ;", "}", "METHOD_END"], "methodName": ["getModuleClassLoader"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   moduleLoader ;", "}", "METHOD_END"], "methodName": ["getModuleLoader"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   componentDescription . getModuleName (  )  ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   namespaceContextInterceptorFactory ;", "}", "METHOD_END"], "methodName": ["getNamespaceContextInterceptorFactory"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   namespaceContextSelector ;", "}", "METHOD_END"], "methodName": ["getNamespaceContextSelector"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "List < List < InterceptorFactory >  >    sortedItems    =    postActivateInterceptors . getSortedItems (  )  ;", "List < InterceptorFactory >    interceptorFactories    =    new   ArrayList <  >  (  )  ;", "for    ( List < InterceptorFactory >    i    :    sortedItems )     {", "interceptorFactorieddAll ( i )  ;", "}", "return   interceptorFactories ;", "}", "METHOD_END"], "methodName": ["getPostActivateInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "List < List < InterceptorFactory >  >    sortedItems    =    postConstructInterceptors . getSortedItems (  )  ;", "List < InterceptorFactory >    interceptorFactories    =    new   ArrayList <  >  (  )  ;", "for    ( List < InterceptorFactory >    i    :    sortedItems )     {", "interceptorFactories . addAll ( i )  ;", "}", "return   interceptorFactories ;", "}", "METHOD_END"], "methodName": ["getPostConstructInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "List < List < InterceptorFactory >  >    sortedItems    =    preDestroyInterceptors . getSortedItems (  )  ;", "List < InterceptorFactory >    interceptorFactories    =    new   ArrayList <  >  (  )  ;", "for    ( List < InterceptorFactory >    i    :    sortedItems )     {", "interceptorFactorieddAll ( i )  ;", "}", "return   interceptorFactories ;", "}", "METHOD_END"], "methodName": ["getPreDestroyInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "List < List < InterceptorFactory >  >    sortedItems    =    prePassivateInterceptors . getSortedItems (  )  ;", "List < InterceptorFactory >    interceptorFactories    =    new   ArrayList <  >  (  )  ;", "for    ( List < InterceptorFactory >    i    :    sortedItems )     {", "interceptorFactorieddAll ( i )  ;", "}", "return   interceptorFactories ;", "}", "METHOD_END"], "methodName": ["getPrePassivateInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   startDependencies ;", "}", "METHOD_END"], "methodName": ["getStartDependencies"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   views ;", "}", "METHOD_END"], "methodName": ["getViews"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "if   CreateServiceFactory    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar ( CreateServiceFactory \"  ,     \"  ,    getComponentName (  )  )  ;", "}", "thisCreateServiceFactory    = CreateServiceFactory ;", "}", "METHOD_END"], "methodName": ["setComponentCreateServiceFactory"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . instanceFactory    =    instanceFactory ;", "}", "METHOD_END"], "methodName": ["setInstanceFactory"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . namespaceContextInterceptorFactory    =    interceptorFactory ;", "}", "METHOD_END"], "methodName": ["setNamespaceContextInterceptorFactory"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . namespaceContextSelector    =    namespaceContextSelector ;", "}", "METHOD_END"], "methodName": ["setNamespaceContextSelector"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( getClass (  )  . getName (  )  )     +     \"  [ name =  \"  )     +     ( componentDescription . getComponentName (  )  )  )     +     \"    class =  \"  )     +     ( componentDescription . getComponentClassName (  )  )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.ee.component.ComponentConfiguration"}, {"methodBody": ["METHOD_START", "{", "classInterceptors . add ( description )  ;", "this . allInterceptors    =    null ;", "}", "METHOD_END"], "methodName": ["addClassInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( serviceName    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" serviceName \"  ,     \"  \"  ,    Name )  ;", "}", "if    ( type    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" type \"  ,     \"  \"  ,    Name )  ;", "}", "final   Map < ServiceName ,    ServiceBuilder . DependencyType >    dependencies    =    this . dependencies ;", "final   ServiceBuilder . DependencyType   dependencyType    =    dependencies . get ( serviceName )  ;", "if    ( dependencyType    =  =     ( DependencyType . REQUIRED )  )     {", "dependencies . put ( serviceName ,    REQUIRED )  ;", "} else    {", "dependencies . put ( serviceName ,    type )  ;", "}", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "interceptorClassOverrides . put ( className ,    InterceptorClassDescription . merge ( interceptorClassOverrides . get ( className )  ,    override )  )  ;", "}", "METHOD_END"], "methodName": ["addInterceptorMethodOverride"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "List < InterceptorDescription >    interceptors    =    methodInterceptors . get ( method )  ;", "if    ( interceptors    =  =    null )     {", "methodInterceptors . put ( method ,     ( interceptors    =    new   ArrayList < InterceptorDescription >  (  )  )  )  ;", "}", "final   String   name    =    description . getInterceptorClassName (  )  ;", "interceptors . add ( description )  ;", "this . allInterceptors    =    null ;", "}", "METHOD_END"], "methodName": ["addMethodInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "String   className    =    injection . getTarget (  )  . getClassName (  )  ;", "Map < InjectionTarget ,    ResourceInjectionConfiguration >    map    =    resourceInjections . get ( className )  ;", "if    ( map    =  =    null )     {", "resourceInjections . put ( className ,     ( map    =    new   HashMap < InjectionTarget ,    ResourceInjectionConfiguration >  (  )  )  )  ;", "}", "map . put ( injection . getTarget (  )  ,    injection )  ;", "}", "METHOD_END"], "methodName": ["addResourceInjection"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   new   ComponentConfiguration ( this ,    classIndex ,    moduleClassLoader ,    moduleLoader )  ;", "}", "METHOD_END"], "methodName": ["createConfiguration"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "methodExcludeClassInterceptors . add ( method )  ;", "}", "METHOD_END"], "methodName": ["excludeClassInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "methodExcludeDefaultInterceptors . add ( method )  ;", "}", "METHOD_END"], "methodName": ["excludeDefaultInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allInterceptors )     =  =    null )     {", "allInterceptors    =    new   HashSet < Interceptor >  (  )  ;", "allInterceptors . addAll ( classInterceptors )  ;", "if    (  !  ( excludeDefaultInterceptors )  )     {", "allInterceptors . addAll ( defaultInterceptors )  ;", "}", "for    ( List < Interceptor >    interceptors    :    methodInterceptors . values (  )  )     {", "allInterceptors . addAll ( interceptors )  ;", "}", "}", "return   allInterceptors ;", "}", "METHOD_END"], "methodName": ["getAllInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   moduleDescription . getApplicationName (  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   beanDeploymentArchiveId ;", "}", "METHOD_END"], "methodName": ["getBeanDeploymentArchiveId"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   bindingConfigurations ;", "}", "METHOD_END"], "methodName": ["getBindingConfigurations"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "for    ( InterceptorDescription   interceptor    :    classInterceptors )     {", "if    ( interceptor . getInterceptorClassName (  )  . equals ( interceptorClassName )  )     {", "return   interceptor ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getClassInterceptor"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   classInterceptors ;", "}", "METHOD_END"], "methodName": ["getClassInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   componentClassName ;", "}", "METHOD_END"], "methodName": ["getComponentClassName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   componentName ;", "}", "METHOD_END"], "methodName": ["getComponentName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   configurators ;", "}", "METHOD_END"], "methodName": ["getConfigurators"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contextServiceName )     !  =    null )", "return   contextServiceName ;", "if    (  ( getNamingMode (  )  )     =  =     ( NamingMode . CREATE )  )     {", "return   ContextNames . contextServiceNameOf ( getApplicationName (  )  ,    getModuleName (  )  ,    getName (  )  )  ;", "} else", "if    (  ( getNamingMode (  )  )     =  =     ( NamingMode . USE _ MODULE )  )     {", "return   ContextNames . contextServiceNameOfModule ( getApplicationName (  )  ,    getModuleName (  )  )  ;", "} else    {", "throw   new   IllegalStateException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getContextServiceName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   serviceName . append (  \" CREATE \"  )  ;", "}", "METHOD_END"], "methodName": ["getCreateServiceName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   defaultInterceptors ;", "}", "METHOD_END"], "methodName": ["getDefaultInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   deploymentDescriptorEnvironment ;", "}", "METHOD_END"], "methodName": ["getDeploymentDescriptorEnvironment"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   methodInterceptors ;", "}", "METHOD_END"], "methodName": ["getMethodInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   moduleDescription ;", "}", "METHOD_END"], "methodName": ["getModuleDescription"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   moduleDescription . getModuleName (  )  ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   namingMode ;", "}", "METHOD_END"], "methodName": ["getNamingMode"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "Map < InjectionTarget ,    ResourceInjectionConfiguration >    injections    =    resourceInjections . get ( className )  ;", "if    ( injections    =  =    null )     {", "return   Collections . emptyMap (  )  ;", "} else    {", "return   Collections . unmodifiableMap ( injections )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceInjections"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   serviceName . append (  \" START \"  )  ;", "}", "METHOD_END"], "methodName": ["getStartServiceName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getTimerMethods"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   views ;", "}", "METHOD_END"], "methodName": ["getViews"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCDIInterceptorEnabled"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   methodExcludeClassInterceptors . contains ( method )  ;", "}", "METHOD_END"], "methodName": ["isExcludeClassInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   excludeDefaultInterceptors ;", "}", "METHOD_END"], "methodName": ["isExcludeDefaultInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   methodExcludeDefaultInterceptors . contains ( method )  ;", "}", "METHOD_END"], "methodName": ["isExcludeDefaultInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   ignoreLifecycleInterceptors ;", "}", "METHOD_END"], "methodName": ["isIgnoreLifecycleInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isIntercepted"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isPassivationApplicable"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isTimerServiceApplicable"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "return    ( isTimerServiceApplicable (  )  )     &  &     (  !  ( getTimerMethods (  )  . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTimerServiceRequired"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   InterceptorClassDescription   interceptorConfig ;", "if    (  ( classDescription    !  =    null )     &  &     (  ! metadataComplete )  )     {", "interceptorConfig    =    InterceptorClassDescription . merge ( classDescription . getInterceptorClassDescription (  )  ,    description . interceptorClassOverrides . get ( clazz . getName (  )  )  )  ;", "} else    {", "interceptorConfig    =    InterceptorClassDescription . merge ( null ,    description . interceptorClassOverrides . get ( clazz . getName (  )  )  )  ;", "}", "return   interceptorConfig ;", "}", "METHOD_END"], "methodName": ["mergeInterceptorConfig"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . beanDeploymentArchiveId    =    beanDeploymentArchiveId ;", "}", "METHOD_END"], "methodName": ["setBeanDeploymentArchiveId"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . classInterceptors    =    classInterceptors ;", "thillInterceptors    =    null ;", "}", "METHOD_END"], "methodName": ["setClassInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . contextServiceName    =    contextServiceName ;", "}", "METHOD_END"], "methodName": ["setContextServiceName"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "allInterceptors    =    null ;", "this . defaultInterceptors    =    defaultInterceptors ;", "}", "METHOD_END"], "methodName": ["setDefaultInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . deploymentDescriptorEnvironment    =    deploymentDescriptorEnvironment ;", "}", "METHOD_END"], "methodName": ["setDeploymentDescriptorEnvironment"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "allInterceptors    =    null ;", "thixcludeDefaultInterceptors    =    excludeDefaultInterceptors ;", "}", "METHOD_END"], "methodName": ["setExcludeDefaultInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "this . ignoreLifecycleInterceptors    =    ignoreLifecycleInterceptors ;", "}", "METHOD_END"], "methodName": ["setIgnoreLifecycleInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "methodInterceptors . put ( identifier ,    interceptorDescriptions )  ;", "methodExcludeClassInterceptors . add ( identifier )  ;", "methodExcludeDefaultInterceptors . add ( identifier )  ;", "}", "METHOD_END"], "methodName": ["setMethodInterceptors"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( namingMode    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" namingMode \"  ,     \"  \"  ,    Name )  ;", "}", "this . namingMode    =    namingMode ;", "}", "METHOD_END"], "methodName": ["setNamingMode"], "fileName": "org.jboss.as.ee.component.ComponentDescription"}, {"methodBody": ["METHOD_START", "{", "final   ComponentInstance   componentInstance    =    context . getPrivateData ( ComponentInstance . class )  ;", "final   ManagedReference   existing    =     (  ( ManagedReference )     ( componentInstance . getInstanceData ( contextKey )  )  )  ;", "if    ( existing    =  =    null )     {", "final   ManagedReference   reference    =    componentFactory . create ( context )  ;", "boolean   ok    =    false ;", "try    {", "componentInstance . setInstanceData ( contextKey ,    reference )  ;", "if    ( setTarget )     {", "context . setTarget ( reference . getInstance (  )  )  ;", "}", "Object   result    =    context . proceed (  )  ;", "ok    =    true ;", "return   result ;", "}    finally    {", "if    (  ! ok )     {", "reference . release (  )  ;", "componentInstance . setInstanceData ( contextKey ,    reference )  ;", "}", "}", "} else    {", "return   context . proceed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ee.component.ComponentInstantiatorInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( componentConfiguration . getViews (  )  . size (  )  )     <     2  )     {", "if    (  ( componentConfiguration . getViews (  )  . size (  )  )     =  =     0  )     {", "componentsByClass . put ( componentConfiguration . getComponentClass (  )  ,    new    . ComponentManagedReferenceFactory ( componentConfiguration . getComponentDescription (  )  . getStartServiceName (  )  ,    null )  )  ;", "} else    {", "componentsByClass . put ( componentConfiguration . getComponentClass (  )  ,    new    . ComponentManagedReferenceFactory ( componentConfiguration . getComponentDescription (  )  . getStartServiceName (  )  ,    componentConfiguration . getViews (  )  . get (  0  )  . getViewServiceName (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addComponent"], "fileName": "org.jboss.as.ee.component.ComponentRegistry"}, {"methodBody": ["METHOD_START", "{", "final   ComponentRegistry . ComponentManagedReferenceFactory   factory    =    componentsByClass . get ( instance . getClass (  )  )  ;", "if    ( factory    =  =    null )     {", "return   classIntrospectorInjectedValue . getValue (  )  . createInstance ( instance )  ;", "}", "return   factory . getReference ( instance )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.ee.component.ComponentRegistry"}, {"methodBody": ["METHOD_START", "{", "final   ManagedReferenceFactory   factory    =    componentsByClass . get ( componentClass )  ;", "if    ( factory    =  =    null )     {", "return   classIntrospectorInjectedValue . getValue (  )  . createFactory ( componentClass )  ;", "}", "return   factory ;", "}", "METHOD_END"], "methodName": ["createInstanceFactory"], "fileName": "org.jboss.as.ee.component.ComponentRegistry"}, {"methodBody": ["METHOD_START", "{", "return   classIntrospectorInjectedValue ;", "}", "METHOD_END"], "methodName": ["getClassIntrospectorInjectedValue"], "fileName": "org.jboss.as.ee.component.ComponentRegistry"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append ( ComponentRegistry . SERVICE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["serviceName"], "fileName": "org.jboss.as.ee.component.ComponentRegistry"}, {"methodBody": ["METHOD_START", "{", "return   component ;", "}", "METHOD_END"], "methodName": ["getComponentInjector"], "fileName": "org.jboss.as.ee.component.ComponentStartService"}, {"methodBody": ["METHOD_START", "{", "return   executor ;", "}", "METHOD_END"], "methodName": ["getExecutorInjector"], "fileName": "org.jboss.as.ee.component.ComponentStartService"}, {"methodBody": ["METHOD_START", "{", "return   component . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.component.ComponentStartService"}, {"methodBody": ["METHOD_START", "{", "final   Runnable   task    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "getValue (  )  . start (  )  ;", "contextlete (  )  ;", "}    catch    ( Throwable   e )     {", "context . failed ( new   StartException ( e )  )  ;", "}", "}", "}  ;", "try    {", "executor . getValue (  )  . submit ( task )  ;", "}    catch    ( RejectedExecutionException   e )     {", "task . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ee.component.ComponentStartService"}, {"methodBody": ["METHOD_START", "{", "final   Runnable   task    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "getValue (  )  . stop (  )  ;", "}    finally    {", "contextlete (  )  ;", "}", "}", "}  ;", "try    {", "executor . getValue (  )  . submit ( task )  ;", "}    catch    ( RejectedExecutionException   e )     {", "task . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ee.component.ComponentStartService"}, {"methodBody": ["METHOD_START", "{", "if    ( other   instanceof   ComponentTypeInjectionSource )     {", "return    (  ( ComponentTypeInjectionSource )     ( other )  )  . typeName . equals ( typeName )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.ComponentTypeInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEApplicationDescription   applicationDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ DESCRIPTION )  ;", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   Set < ViewDescription > sForViewName    =    applicationDescription . getComponentsForViewName ( typeName ,    deploymentRoot . getRoot (  )  )  ;", "final   Iterator < ViewDescription >    iterator    = sForViewName . iterator (  )  ;", "if    (  !  ( iterator . hasNext (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGERNotFound ( typeName )  ;", "}", "final   ViewDescription   description    =    iterator . next (  )  ;", "if    ( iterator . hasNext (  )  )     {", "throw   EeLogger . ROOT _ LOGGER . multipleComponentsFound ( typeName )  ;", "}", "serviceBuilder . addDependency ( description . getServiceName (  )  ,    ComponentView . class ,    new   ViewManagedReferenceFactory . Injector ( injector )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ee.component.ComponentTypeInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   typeName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.ComponentTypeInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    context . getDeploymentUnit (  )  ;", "final   DeploymentReflectionIndex   deploymentReflectionIndex    =    deploymentUnit . getAttachment ( Attachments . REFLECTION _ INDEX )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   boolean   metadataComplete    =    MetadataCompleteMarker . isMetadataComplete ( deploymentUnit )  ;", "final   Deque < InterceptorFactory >    injectors    =    new   ArrayDeque <  >  (  )  ;", "final   Deque < InterceptorFactory >    uninjectors    =    new   ArrayDeque <  >  (  )  ;", "final   Deque < InterceptorFactory >    destructors    =    new   ArrayDeque <  >  (  )  ;", "final   List < InterceptorFactory >    componentUserAroundInvoke    =    new   ArrayList <  >  (  )  ;", "final   List < InterceptorFactory >    componentUserAroundTimeout ;", "final   List < InterceptorFactory >    userPostConstruct    =    new   ArrayList <  >  (  )  ;", "final   List < InterceptorFactory >    userPreDestroy    =    new   ArrayList <  >  (  )  ;", "final   List < InterceptorFactory >    componentUserPrePassivate ;", "final   List < InterceptorFactory >    componentUserPostActivate ;", "final   Set < MethodIdentifier >    timeoutMethods    =    description . getTimerMethods (  )  ;", "if    ( description . isTimerServiceRequired (  )  )     {", "componentUserAroundTimeout    =    new   ArrayList (  )  ;", "} else    {", "componentUserAroundTimeout    =    null ;", "}", "if    ( description . isPassivationApplicable (  )  )     {", "componentUserPrePassivate    =    new   ArrayList (  )  ;", "componentUserPostActivate    =    new   ArrayList (  )  ;", "} else    {", "componentUserPrePassivate    =    null ;", "componentUserPostActivate    =    null ;", "}", "destructors . add ( new   ImmediateInterceptorFactory ( new   ManagedReferenceReleaseInterceptor ( BasicComponentInstance . INSTANCE _ KEY )  )  )  ;", "new   ClassDescriptionTraversal ( configuration . getComponentClass (  )  ,    applicationClasses )     {", "@ Override", "public   void   handle ( Class <  ?  >    clazz ,    EEModuleClassDescription   classDescription )    throws   DeploymentUnitProcessingException    {", "mergeInjectionsForClass ( clazz ,    configuration . getComponentClass (  )  ,    classDescription ,    moduleDescription ,    deploymentReflectionIndex ,    description ,    configuration ,    context ,    injectors ,    BasicComponentInstance . INSTANCE _ KEY ,    uninjectors ,    metadataComplete )  ;", "}", "}  . run (  )  ;", "new   ClassDescriptionTraversal ( configuration . getComponentClass (  )  ,    applicationClasses )     {", "@ Override", "public   void   handle ( final   Class <  ?  >    clazz ,    EEModuleClassDescription   classDescription )    throws   DeploymentUnitProcessingException    {", "final   InterceptorClassDescription   interceptorConfig    =    InterceptorClassDescription . merge ( ComponentDescription . mergeInterceptorConfig ( clazz ,    classDescription ,    description ,    metadataComplete )  ,    moduleDescription . getInterceptorClassOverride ( clazz . getName (  )  )  )  ;", "handleClassMethod ( clazz ,    interceptorConfig . getAroundInvoke (  )  ,    componentUserAroundInvoke ,    false ,    false ,    configuration )  ;", "if    ( description . isTimerServiceRequired (  )  )     {", "handleClassMethod ( clazz ,    interceptorConfig . getAroundTimeout (  )  ,    componentUserAroundTimeout ,    false ,    false ,    configuration )  ;", "}", "if    (  !  ( description . isIgnoreLifecycleInterceptors (  )  )  )     {", "handleClassMethod ( clazz ,    interceptorConfig . getPostConstruct (  )  ,    userPostConstruct ,    true ,    true ,    configuration )  ;", "handleClassMethod ( clazz ,    interceptorConfig . getPreDestroy (  )  ,    userPreDestroy ,    true ,    true ,    configuration )  ;", "if    ( description . isPassivationApplicable (  )  )     {", "handleClassMethod ( clazz ,    interceptorConfig . getPrePassivate (  )  ,    componentUserPrePassivate ,    false ,    true ,    configuration )  ;", "handleClassMethod ( clazz ,    interceptorConfig . getPostActivate (  )  ,    componentUserPostActivate ,    false ,    true ,    configuration )  ;", "}", "}", "}", "private   void   handleClassMethod ( final   Class <  ?  >    clazz ,    final   MethodIdentifier   methodIdentifier ,    final   List < InterceptorFactory >    interceptors ,    boolean   changeMethod ,    boolean   lifecycleMethod ,    ComponentConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "if    ( methodIdentifier    !  =    null )     {", "final   Method   method    =    ClassReflectionIndexUtil . findRequiredMethod ( deploymentReflectionIndex ,    clazz ,    methodIdentifier )  ;", "if    ( isNotOverriden ( clazz ,    method ,    configuration . getComponentClass (  )  ,    deploymentReflectionIndex )  )     {", "InterceptorFactory   interceptorFactory    =    new   ImmediateInterceptorFactory ( new   ManagedReferenceLifecycleMethodInterceptor ( BasicComponentInstance . INSTANCE _ KEY ,    method ,    changeMethod ,    lifecycleMethod )  )  ;", "interceptors . add ( interceptorFactory )  ;", "if    ( lifecycleMethod )     {", "configuration . addLifecycleMethod ( method )  ;", "}", "}", "}", "}", "}  . run (  )  ;", "final   ClassLoader   classLoader    =    module . getClassLoader (  )  ;", "final   InterceptorFactory   tcclInterceptor    =    new   ImmediateInterceptorFactory ( new   ContextClassLoaderInterceptor ( classLoader )  )  ;", "if    (  !  ( injectors . isEmpty (  )  )  )     {", "configuration . addPostConstructInterceptors ( new   ArrayList ( injectors )  ,    InterceptorOrder . ComponentPostConstruct . COMPONENT _ RESOURCE _ INJECTION _ INTERCEPTORS )  ;", "}", "if    (  !  ( userPostConstruct . isEmpty (  )  )  )     {", "configuration . addPostConstructInterceptors ( userPostConstruct ,    InterceptorOrder . ComponentPostConstruct . COMPONENT _ USER _ INTERCEPTORS )  ;", "}", "configuration . addPostConstructInterceptor ( Interceptors . getTerminalInterceptorFactory (  )  ,    InterceptorOrder . ComponentPostConstruct . TERMINAL _ INTERCEPTOR )  ;", "configuration . addPostConstructInterceptor ( tcclInterceptor ,    InterceptorOrder . ComponentPostConstruct . TCCL _ INTERCEPTOR )  ;", "if    (  !  ( uninjectors . isEmpty (  )  )  )     {", "configuration . addPreDestroyInterceptors ( new   ArrayList ( uninjectors )  ,    InterceptorOrder . ComponentPreDestroy . COMPONENT _ UNINJECTION _ INTERCEPTORS )  ;", "}", "if    (  !  ( destructors . isEmpty (  )  )  )     {", "configuration . addPreDestroyInterceptors ( new   ArrayList ( destructors )  ,    InterceptorOrder . ComponentPreDestroy . COMPONENT _ DESTRUCTION _ INTERCEPTORS )  ;", "}", "if    (  !  ( userPreDestroy . isEmpty (  )  )  )     {", "configuration . addPreDestroyInterceptors ( userPreDestroy ,    InterceptorOrder . ComponentPreDestroy . COMPONENT _ USER _ INTERCEPTORS )  ;", "}", "configuration . addPreDestroyInterceptor ( Interceptors . getTerminalInterceptorFactory (  )  ,    InterceptorOrder . ComponentPreDestroy . TERMINAL _ INTERCEPTOR )  ;", "configuration . addPreDestroyInterceptor ( tcclInterceptor ,    InterceptorOrder . ComponentPreDestroy . TCCL _ INTERCEPTOR )  ;", "if    ( description . isPassivationApplicable (  )  )     {", "if    (  !  ( componentUserPrePassivate . isEmpty (  )  )  )     {", "configuration . addPrePassivateInterceptors ( componentUserPrePassivate ,    InterceptorOrder . ComponentPassivation . COMPONENT _ USER _ INTERCEPTORS )  ;", "}", "configuration . addPrePassivateInterceptor ( Interceptors . getTerminalInterceptorFactory (  )  ,    InterceptorOrder . ComponentPassivation . TERMINAL _ INTERCEPTOR )  ;", "configuration . addPrePassivateInterceptor ( tcclInterceptor ,    InterceptorOrder . ComponentPassivation . TCCL _ INTERCEPTOR )  ;", "if    (  !  ( componentUserPostActivate . isEmpty (  )  )  )     {", "configuration . addPostActivateInterceptors ( componentUserPostActivate ,    InterceptorOrder . ComponentPassivation . COMPONENT _ USER _ INTERCEPTORS )  ;", "}", "configuration . addPostActivateInterceptor ( Interceptors . getTerminalInterceptorFactory (  )  ,    InterceptorOrder . ComponentPassivation . TERMINAL _ INTERCEPTOR )  ;", "configuration . addPostActivateInterceptor ( tcclInterceptor ,    InterceptorOrder . ComponentPassivation . TCCL _ INTERCEPTOR )  ;", "}", "if    ( description . isIntercepted (  )  )     {", "for    ( final   Method   method    :    configuration . getDefinedComponentMethods (  )  )     {", "configuration . addComponentInterceptor ( method ,    Interceptors . getInitialInterceptorFactory (  )  ,    InterceptorOrder . Component . INITIAL _ INTERCEPTOR )  ;", "configuration . addComponentInterceptor ( method ,    new   ImmediateInterceptorFactory ( new   ManagedReferenceMethodInterceptor ( BasicComponentInstance . INSTANCE _ KEY ,    method )  )  ,    InterceptorOrder . Component . TERMINAL _ INTERCEPTOR )  ;", "final   MethodIdentifier   identifier    =    MethodIdentifier . getIdentifier ( method . getReturnType (  )  ,    method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "final   boolean   requiresTimerChain    =     ( description . isTimerServiceRequired (  )  )     &  &     ( timeoutMethods . contains ( identifier )  )  ;", "if    ( requiresTimerChain )     {", "configuration . addComponentInterceptor ( method ,    new   UserInterceptorFactory ( Abstrac . weaved ( componentUserAroundInvoke )  ,    Abstrac . weaved ( componentUserAroundTimeout )  )  ,    InterceptorOrder . Component . COMPONENT _ USER _ INTERCEPTORS )  ;", "} else    {", "configuration . addComponentInterceptors ( method ,    componentUserAroundInvoke ,    InterceptorOrder . Component . COMPONENT _ USER _ INTERCEPTORS )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.ee.component.DefaultComponentConfigurator"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    context . getDeploymentUnit (  )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   ProxyMetadataSource   proxyReflectionIndex    =    deploymentUnit . getAttachment ( PROXY _ REFLECTION _ INDEX )  ;", "for    ( ViewDescription   view    :    description . getViews (  )  )     {", "Class <  ?  >    viewClass ;", "try    {", "viewClass    =    module . getClassLoader (  )  . loadClass ( view . getViewClassName (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoadViewClass ( e ,    view . getViewClassName (  )  ,    configuration )  ;", "}", "final   ViewConfiguration   viewConfiguration ;", "final   ProxyConfiguration   proxyConfiguration    =    new   ProxyConfiguration (  )  ;", "if    ( viewClass . getName (  )  . startsWith (  \" \"  )  )     {", "proxyConfiguration . setProxyName (  (  (  (  \" \"     +     ( viewClass . getSimpleName (  )  )  )     +     \"  $  $  $ view \"  )     +     (  . PROXY _ ID . incrementAndGet (  )  )  )  )  ;", "} else    {", "proxyConfiguration . setProxyName (  (  (  ( viewClass . getName (  )  )     +     \"  $  $  $ view \"  )     +     (  . PROXY _ ID . incrementAndGet (  )  )  )  )  ;", "}", "proxyConfiguration . setClassLoader ( module . getClassLoader (  )  )  ;", "proxyConfiguration . setProtectionDomain ( viewClass . getProtectionDomain (  )  )  ;", "proxyConfiguration . setMetadataSource ( proxyReflectionIndex )  ;", "if    ( view . isSerializable (  )  )     {", "proxyConfiguration . addAdditionalInterface ( Serializable . class )  ;", "if    ( view . isUseWriteReplace (  )  )     {", "proxyConfiguration . addAdditionalInterface ( WriteReplaceInterface . class )  ;", "}", "}", "if    ( viewClass . isInterface (  )  )     {", "proxyConfiguration . setSuperClass ( Object . class )  ;", "proxyConfiguration . addAdditionalInterface ( viewClass )  ;", "viewConfiguration    =    view . createViewConfiguration ( viewClass ,    configuration ,    new   ProxyFactory ( proxyConfiguration )  )  ;", "} else    {", "proxyConfiguration . setSuperClass ( viewClass )  ;", "viewConfiguration    =    view . createViewConfiguration ( viewClass ,    configuration ,    new   ProxyFactory ( proxyConfiguration )  )  ;", "}", "for    ( final   ViewConfigurator   configurator    :    view . getConfigurators (  )  )     {", "configurator . configure ( context ,    configuration ,    view ,    viewConfiguration )  ;", "}", "configuration . getViews (  )  . add ( viewConfiguration )  ;", "}", "configuration . getStartDependencies (  )  . add ( new   DependencyConfigurator < ComponentStartService >  (  )     {", "@ Override", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    ComponentStartService   service )    throws   DeploymentUnitProcessingException    {", "for    ( final   Map . Entry < ServiceName ,    ServiceBuilder . DependencyType >    entry    :    description . getDependencies (  )  . entrySet (  )  )     {", "serviceBuilder . addDependency ( entry . getValue (  )  ,    entry . getKey (  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.ee.component.DefaultComponentViewConfigurator"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    context . getDeploymentUnit (  )  ;", "final   DeploymentReflectionIndex   deploymentReflectionIndex    =    deploymentUnit . getAttachment ( Attachments . REFLECTION _ INDEX )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   boolean   metadataComplete    =    MetadataCompleteMarker . isMetadataComplete ( deploymentUnit )  ;", "final   Deque < InterceptorFactory >    instantiators    =    new   ArrayDeque <  >  (  )  ;", "final   Deque < InterceptorFactory >    injectors    =    new   ArrayDeque <  >  (  )  ;", "final   Deque < InterceptorFactory >    uninjectors    =    new   ArrayDeque <  >  (  )  ;", "final   Deque < InterceptorFactory >    destructors    =    new   ArrayDeque <  >  (  )  ;", "final   Map < String ,    List < InterceptorFactory >  >    userAroundInvokesByInterceptorClass    =    new   HashMap <  >  (  )  ;", "final   Map < String ,    List < InterceptorFactory >  >    userAroundConstructsByInterceptorClass    =    new   HashMap < String ,    List < InterceptorFactory >  >  (  )  ;", "final   Map < String ,    List < InterceptorFactory >  >    userAroundTimeoutsByInterceptorClass ;", "final   Map < String ,    List < InterceptorFactory >  >    userPrePassivatesByInterceptorClass ;", "final   Map < String ,    List < InterceptorFactory >  >    userPostActivatesByInterceptorClass ;", "final   Map < String ,    List < InterceptorFactory >  >    userPostConstructByInterceptorClass    =    new   HashMap < String ,    List < InterceptorFactory >  >  (  )  ;", "final   Map < String ,    List < InterceptorFactory >  >    userPreDestroyByInterceptorClass    =    new   HashMap < String ,    List < InterceptorFactory >  >  (  )  ;", "final   Set < MethodIdentifier >    timeoutMethods    =    description . getTimerMethods (  )  ;", "if    ( description . isTimerServiceRequired (  )  )     {", "userAroundTimeoutsByInterceptorClass    =    new   HashMap (  )  ;", "} else    {", "userAroundTimeoutsByInterceptorClass    =    null ;", "}", "if    ( description . isPassivationApplicable (  )  )     {", "userPrePassivatesByInterceptorClass    =    new   HashMap (  )  ;", "userPostActivatesByInterceptorClass    =    new   HashMap (  )  ;", "} else    {", "userPrePassivatesByInterceptorClass    =    null ;", "userPostActivatesByInterceptorClass    =    null ;", "}", "final   InterceptorFactory   instantiator ;", "final   ComponentFactory   instanceFactory    =    configuration . getInstanceFactory (  )  ;", "if    ( instanceFactory    !  =    null )     {", "instantiator    =    new   ImmediateInterceptorFactory ( new   ComponentInstantiatorInterceptor ( instanceFactory ,    BasicComponentInstance . INSTANCE _ KEY ,    true )  )  ;", "} else    {", "final   ClassReflectionIndex   componentClassIndex    =    deploymentReflectionIndex . getClassIndex ( configuration . getComponentClass (  )  )  ;", "final   Constructor <  ?  >    constructor    =    componentClassIndex . getConstructor (  . EMPTY _ CLASS _ ARRAY )  ;", "if    ( constructor    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . defaultConstructorNotFound ( configuration . getComponentClass (  )  )  ;", "}", "instantiator    =    new   ImmediateInterceptorFactory ( new   ComponentInstantiatorInterceptor ( new   ConstructorComponentFactory ( constructor )  ,    BasicComponentInstance . INSTANCE _ KEY ,    true )  )  ;", "}", "final   List < InterceptorDescription >    interceptorWithLifecycleCallbacks    =    new   ArrayList < InterceptorDescription >  (  )  ;", "if    (  !  ( description . isExcludeDefaultInterceptors (  )  )  )     {", "interceptorWithLifecycleCallbacks . addAll ( description . getDefaultInterceptors (  )  )  ;", "}", "interceptorWithLifecycleCallbacks . addAll ( description . getClassInterceptors (  )  )  ;", "for    ( final   InterceptorDescription   interceptorDescription    :    description . getAllInterceptors (  )  )     {", "final   String   interceptorClassName    =    interceptorDescription . getInterceptorClassName (  )  ;", "final   Class <  ?  >    interceptorClass ;", "try    {", "interceptorClass    =    ClassLoadingUtils . loadClass ( interceptorClassName ,    module )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoadInterceptor ( e ,    interceptorClassName )  ;", "}", "final   InterceptorEnvironment   interceptorEnvironment    =    moduleDescription . getInterceptorEnvironment (  )  . get ( interceptorClassName )  ;", "if    ( interceptorEnvironment    !  =    null )     {", "description . getBindingConfigurations (  )  . addAll ( interceptorEnvironment . getBindingConfigurations (  )  )  ;", "for    ( final   ResourceInjectionConfiguration   injection    :    interceptorEnvironment . getResourceInjections (  )  )     {", "description . addResourceInjection ( injection )  ;", "}", "}", "final   Object   contextKey    =    interceptorClass ;", "configuration . getInterceptorContextKeys (  )  . add ( contextKey )  ;", "final   ClassReflectionIndex   interceptorIndex    =    deploymentReflectionIndex . getClassIndex ( interceptorClass )  ;", "final   Constructor <  ?  >    constructor    =    interceptorIndex . getConstructor (  . EMPTY _ CLASS _ ARRAY )  ;", "if    ( constructor    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . defaultConstructorNotFoundOnComponent ( interceptorClassName ,    configuration . getComponentClass (  )  )  ;", "}", "instantiators . addFirst ( new   ImmediateInterceptorFactory ( new   ComponentInstantiatorInterceptor ( new   ConstructorComponentFactory ( constructor )  ,    contextKey ,    false )  )  )  ;", "destructors . addLast ( new   ImmediateInterceptorFactory ( new   ManagedReferenceReleaseInterceptor ( contextKey )  )  )  ;", "final   boolean   interceptorHasLifecycleCallbacks    =    interceptorWithLifecycleCallbacks . contains ( interceptorDescription )  ;", "new   ClassDescriptionTraversal ( interceptorClass ,    applicationClasses )     {", "@ Override", "public   void   handle ( final   Class <  ?  >    clazz ,    EEModuleClassDescription   classDescription )    throws   DeploymentUnitProcessingException    {", "mergeInjectionsForClass ( clazz ,    interceptorClass ,    classDescription ,    moduleDescription ,    deploymentReflectionIndex ,    description ,    configuration ,    context ,    injectors ,    contextKey ,    uninjectors ,    metadataComplete )  ;", "final   InterceptorClassDescription   interceptorConfig ;", "if    (  ( classDescription    !  =    null )     &  &     (  ! metadataComplete )  )     {", "interceptorConfig    =    InterceptorClassDescription . merge ( classDescription . getInterceptorClassDescription (  )  ,    moduleDescription . getInterceptorClassOverride ( clazz . getName (  )  )  )  ;", "} else    {", "interceptorConfig    =    InterceptorClassDescription . merge ( null ,    moduleDescription . getInterceptorClassOverride ( clazz . getName (  )  )  )  ;", "}", "if    ( interceptorHasLifecycleCallbacks    &  &     (  !  ( description . isIgnoreLifecycleInterceptors (  )  )  )  )     {", "final   MethodIdentifier   postConstructMethodIdentifier    =    interceptorConfig . getPostConstruct (  )  ;", "handleInterceptorClass ( clazz ,    postConstructMethodIdentifier ,    userPostConstructByInterceptorClass ,    true ,    true )  ;", "final   MethodIdentifier   preDestroyMethodIdentifier    =    interceptorConfig . getPreDestroy (  )  ;", "handleInterceptorClass ( clazz ,    preDestroyMethodIdentifier ,    userPreDestroyByInterceptorClass ,    true ,    true )  ;", "final   MethodIdentifier   aroundConstructMethodIdentifier    =    interceptorConfig . getAroundConstruct (  )  ;", "handleInterceptorClass ( clazz ,    aroundConstructMethodIdentifier ,    userAroundConstructsByInterceptorClass ,    true ,    true )  ;", "}", "final   MethodIdentifier   aroundInvokeMethodIdentifier    =    interceptorConfig . getAroundInvoke (  )  ;", "handleInterceptorClass ( clazz ,    aroundInvokeMethodIdentifier ,    userAroundInvokesByInterceptorClass ,    false ,    false )  ;", "if    ( description . isTimerServiceRequired (  )  )     {", "final   MethodIdentifier   aroundTimeoutMethodIdentifier    =    interceptorConfig . getAroundTimeout (  )  ;", "handleInterceptorClass ( clazz ,    aroundTimeoutMethodIdentifier ,    userAroundTimeoutsByInterceptorClass ,    false ,    false )  ;", "}", "if    ( description . isPassivationApplicable (  )  )     {", "handleInterceptorClass ( clazz ,    interceptorConfig . getPrePassivate (  )  ,    userPrePassivatesByInterceptorClass ,    false ,    false )  ;", "handleInterceptorClass ( clazz ,    interceptorConfig . getPostActivate (  )  ,    userPostActivatesByInterceptorClass ,    false ,    false )  ;", "}", "}", "private   void   handleInterceptorClass ( final   Class <  ?  >    clazz ,    final   MethodIdentifier   methodIdentifier ,    final   Map < String ,    List < InterceptorFactory >  >    classMap ,    final   boolean   changeMethod ,    final   boolean   lifecycleMethod )    throws   DeploymentUnitProcessingException    {", "if    ( methodIdentifier    !  =    null )     {", "final   Method   method    =    ClassReflectionIndexUtil . findRequiredMethod ( deploymentReflectionIndex ,    clazz ,    methodIdentifier )  ;", "if    ( isNotOverriden ( clazz ,    method ,    interceptorClass ,    deploymentReflectionIndex )  )     {", "final   InterceptorFactory   interceptorFactory    =    new   ImmediateInterceptorFactory ( new   ManagedReferenceLifecycleMethodInterceptor ( contextKey ,    method ,    changeMethod ,    lifecycleMethod )  )  ;", "List < InterceptorFactory >    factories    =    classMap . get ( interceptorClassName )  ;", "if    ( factories    =  =    null )     {", "classMap . put ( interceptorClassName ,     ( factories    =    new   ArrayList < InterceptorFactory >  (  )  )  )  ;", "}", "factories . add ( interceptorFactory )  ;", "}", "}", "}", "}  . run (  )  ;", "}", "final   List < InterceptorFactory >    userAroundConstruct    =    new   ArrayList < InterceptorFactory >  (  )  ;", "final   List < InterceptorFactory >    userPostConstruct    =    new   ArrayList < InterceptorFactory >  (  )  ;", "final   List < InterceptorFactory >    userPreDestroy    =    new   ArrayList < InterceptorFactory >  (  )  ;", "final   List < InterceptorFactory >    userPrePassivate    =    new   ArrayList < InterceptorFactory >  (  )  ;", "final   List < InterceptorFactory >    userPostActivate    =    new   ArrayList < InterceptorFactory >  (  )  ;", "for    ( final   InterceptorDescription   interceptorClass    :    interceptorWithLifecycleCallbacks )     {", "if    ( userPostConstructByInterceptorClass . containsKey ( interceptorClass . getInterceptorClassName (  )  )  )     {", "userPostConstruct . addAll ( userPostConstructByInterceptorClass . get ( interceptorClass . getInterceptorClassName (  )  )  )  ;", "}", "if    ( userAroundConstructsByInterceptorClass . containsKey ( interceptorClass . getInterceptorClassName (  )  )  )     {", "userAroundConstruct . addAll ( userAroundConstructsByInterceptorClass . get ( interceptorClass . getInterceptorClassName (  )  )  )  ;", "}", "if    ( userPreDestroyByInterceptorClass . containsKey ( interceptorClass . getInterceptorClassName (  )  )  )     {", "userPreDestroy . addAll ( userPreDestroyByInterceptorClass . get ( interceptorClass . getInterceptorClassName (  )  )  )  ;", "}", "if    ( description . isPassivationApplicable (  )  )     {", "if    ( userPrePassivatesByInterceptorClass . containsKey ( interceptorClass . getInterceptorClassName (  )  )  )     {", "userPrePassivate . addAll ( userPrePassivatesByInterceptorClass . get ( interceptorClass . getInterceptorClassName (  )  )  )  ;", "}", "if    ( userPostActivatesByInterceptorClass . containsKey ( interceptorClass . getInterceptorClassName (  )  )  )     {", "userPostActivate . addAll ( userPostActivatesByInterceptorClass . get ( interceptorClass . getInterceptorClassName (  )  )  )  ;", "}", "}", "}", "if    (  !  ( injectors . isEmpty (  )  )  )     {", "configuration . addPostConstructInterceptors ( new   ArrayList ( injectors )  ,    InterceptorOrder . ComponentPostConstruct . INTERCEPTOR _ RESOURCE _ INJECTION _ INTERCEPTORS )  ;", "}", "if    (  !  ( instantiators . isEmpty (  )  )  )     {", "configuration . addPostConstructInterceptors ( new   ArrayList ( instantiators )  ,    InterceptorOrder . ComponentPostConstruct . INTERCEPTOR _ INSTANTIATION _ INTERCEPTORS )  ;", "}", "if    (  !  ( userAroundConstruct . isEmpty (  )  )  )     {", "configuration . addAroundConstructInterceptors ( userAroundConstruct ,    InterceptorOrder . AroundConstruct . INTERCEPTOR _ AROUND _ CONSTRUCT )  ;", "}", "configuration . addAroundConstructInterceptor ( instantiator ,    InterceptorOrder . AroundConstruct . CONSTRUCT _ COMPONENT )  ;", "configuration . addAroundConstructInterceptor ( new   ImmediateInterceptorFactory ( Interceptors . getTerminalInterceptor (  )  )  ,    InterceptorOrder . AroundConstruct . TERMINAL _ INTERCEPTOR )  ;", "if    (  !  ( configuration . getAroundConstructInterceptors (  )  . isEmpty (  )  )  )     {", "configuration . addPostConstructInterceptor ( new   AroundConstructInterceptorFactory ( Interceptors . getChainedInterceptorFactory ( configuration . getAroundConstructInterceptors (  )  )  )  ,    InterceptorOrder . ComponentPostConstruct . AROUND _ CONSTRUCT _ CHAIN )  ;", "}", "if    (  !  ( userPostConstruct . isEmpty (  )  )  )     {", "configuration . addPostConstructInterceptors ( userPostConstruct ,    InterceptorOrder . ComponentPostConstruct . INTERCEPTOR _ USER _ INTERCEPTORS )  ;", "}", "if    (  !  ( uninjectors . isEmpty (  )  )  )     {", "configuration . addPreDestroyInterceptors ( new   ArrayList ( uninjectors )  ,    InterceptorOrder . ComponentPreDestroy . INTERCEPTOR _ UNINJECTION _ INTERCEPTORS )  ;", "}", "if    (  !  ( destructors . isEmpty (  )  )  )     {", "configuration . addPreDestroyInterceptors ( new   ArrayList ( destructors )  ,    InterceptorOrder . ComponentPreDestroy . INTERCEPTOR _ DESTRUCTION _ INTERCEPTORS )  ;", "}", "if    (  !  ( userPreDestroy . isEmpty (  )  )  )     {", "configuration . addPreDestroyInterceptors ( userPreDestroy ,    InterceptorOrder . ComponentPreDestroy . INTERCEPTOR _ USER _ INTERCEPTORS )  ;", "}", "if    ( description . isPassivationApplicable (  )  )     {", "if    (  !  ( userPrePassivate . isEmpty (  )  )  )     {", "configuration . addPrePassivateInterceptors ( userPrePassivate ,    InterceptorOrder . ComponentPassivation . INTERCEPTOR _ USER _ INTERCEPTORS )  ;", "}", "if    (  !  ( userPostActivate . isEmpty (  )  )  )     {", "configuration . addPostActivateInterceptors ( userPostActivate ,    InterceptorOrder . ComponentPassivation . INTERCEPTOR _ USER _ INTERCEPTORS )  ;", "}", "}", "final   List < InterceptorDescription >    classInterceptors    =    description . getClassInterceptors (  )  ;", "final   Map < MethodIdentifier ,    List < InterceptorDescription >  >    methodInterceptors    =    description . getMethodInterceptors (  )  ;", "if    ( description . isIntercepted (  )  )     {", "for    ( final   Method   method    :    configuration . getDefinedComponentMethods (  )  )     {", "final   MethodIdentifier   identifier    =    MethodIdentifier . getIdentifier ( method . getReturnType (  )  ,    method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "final   List < InterceptorFactory >    userAroundInvokes    =    new   ArrayList < InterceptorFactory >  (  )  ;", "final   List < InterceptorFactory >    userAroundTimeouts    =    new   ArrayList < InterceptorFactory >  (  )  ;", "final   boolean   requiresTimerChain    =     ( description . isTimerServiceRequired (  )  )     &  &     ( timeoutMethods . contains ( identifier )  )  ;", "if    (  (  !  ( description . isExcludeDefaultInterceptors (  )  )  )     &  &     (  !  ( description . isExcludeDefaultInterceptors ( identifier )  )  )  )     {", "for    ( InterceptorDescription   interceptorDescription    :    description . getDefaultInterceptors (  )  )     {", "String   interceptorClassName    =    interceptorDescription . getInterceptorClassName (  )  ;", "List < InterceptorFactory >    aroundInvokes    =    userAroundInvokesByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundInvokes    !  =    null )     {", "userAroundInvokes . addAll ( aroundInvokes )  ;", "}", "if    ( requiresTimerChain )     {", "List < InterceptorFactory >    aroundTimeouts    =    userAroundTimeoutsByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundTimeouts    !  =    null )     {", "userAroundTimeouts . addAll ( aroundTimeouts )  ;", "}", "}", "}", "}", "if    (  !  ( description . isExcludeClassInterceptors ( identifier )  )  )     {", "for    ( InterceptorDescription   interceptorDescription    :    classInterceptors )     {", "String   interceptorClassName    =    interceptorDescription . getInterceptorClassName (  )  ;", "List < InterceptorFactory >    aroundInvokes    =    userAroundInvokesByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundInvokes    !  =    null )     {", "userAroundInvokes . addAll ( aroundInvokes )  ;", "}", "if    ( requiresTimerChain )     {", "List < InterceptorFactory >    aroundTimeouts    =    userAroundTimeoutsByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundTimeouts    !  =    null )     {", "userAroundTimeouts . addAll ( aroundTimeouts )  ;", "}", "}", "}", "}", "List < InterceptorDescription >    methodLevelInterceptors    =    methodInterceptors . get ( identifier )  ;", "if    ( methodLevelInterceptors    !  =    null )     {", "for    ( InterceptorDescription   methodLevelInterceptor    :    methodLevelInterceptors )     {", "String   interceptorClassName    =    methodLevelInterceptor . getInterceptorClassName (  )  ;", "List < InterceptorFactory >    aroundInvokes    =    userAroundInvokesByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundInvokes    !  =    null )     {", "userAroundInvokes . addAll ( aroundInvokes )  ;", "}", "if    ( requiresTimerChain )     {", "List < InterceptorFactory >    aroundTimeouts    =    userAroundTimeoutsByInterceptorClass . get ( interceptorClassName )  ;", "if    ( aroundTimeouts    !  =    null )     {", "userAroundTimeouts . addAll ( aroundTimeouts )  ;", "}", "}", "}", "}", "if    ( requiresTimerChain )     {", "configuration . addComponentInterceptor ( method ,    new   UserInterceptorFactory ( AbstractComponentConfigurator . weaved ( userAroundInvokes )  ,    AbstractComponentConfigurator . weaved ( userAroundTimeouts )  )  ,    InterceptorOrder . Component . INTERCEPTOR _ USER _ INTERCEPTORS )  ;", "} else    {", "configuration . addComponentInterceptors ( method ,    userAroundInvokes ,    InterceptorOrder . Component . INTERCEPTOR _ USER _ INTERCEPTORS )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.ee.component.DefaultInterceptorConfigurator"}, {"methodBody": ["METHOD_START", "{", "return   defaultContext ;", "}", "METHOD_END"], "methodName": ["getDefaultContext"], "fileName": "org.jboss.as.ee.component.DeploymentDescriptorEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   environment ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.jboss.as.ee.component.DeploymentDescriptorEnvironment"}, {"methodBody": ["METHOD_START", "{", "for    ( EEModuleDescription   module    :    availableModules )     {", "final   EEModuleDescription   desc    =    module . getDescription ( name )  ;", "if    ( desc    !  =    null )     {", "return   desc ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getClassByName"], "fileName": "org.jboss.as.ee.component.EEApplicationClasses"}, {"methodBody": ["METHOD_START", "{", "for    ( final   ViewDescription   viewDescription    :    description . getViews (  )  )     {", "List <  . ViewInformation >    viewComponents    =    componentsByViewName . get ( viewDescription . getViewClassName (  )  )  ;", "if    ( viewComponents    =  =    null )     {", "viewComponents    =    new   ArrayList <  . ViewInformation >  (  1  )  ;", "componentsByViewName . put ( viewDescription . getViewClassName (  )  ,    viewComponents )  ;", "}", "viewComponents . add ( new    . ViewInformation ( viewDescription ,    deploymentRoot ,    description . getComponentName (  )  )  )  ;", "}", "List <  . Description >    components    =    componentsByName . get ( description . getComponentName (  )  )  ;", "if    ( components    =  =    null )     {", "componentsByName . put ( description . getComponentName (  )  ,     ( components    =    new   ArrayList <  . Description >  (  1  )  )  )  ;", "}", "components . add ( new    . Description ( description ,    deploymentRoot )  )  ;", "}", "METHOD_END"], "methodName": ["addComponent"], "fileName": "org.jboss.as.ee.component.EEApplicationDescription"}, {"methodBody": ["METHOD_START", "{", "List < EEApplicationDescription . MessageDestinationMapping >    components    =    messageDestinationJndiMapping . get ( name )  ;", "if    ( components    =  =    null )     {", "messageDestinationJndiMapping . put ( name ,     ( components    =    new   ArrayList < EEApplicationDescription . MessageDestinationMapping >  (  1  )  )  )  ;", "}", "components . add ( new   EEApplicationDescription . MessageDestinationMapping ( resolvedName ,    deploymentRoot )  )  ;", "}", "METHOD_END"], "methodName": ["addMessageDestination"], "fileName": "org.jboss.as.ee.component.EEApplicationDescription"}, {"methodBody": ["METHOD_START", "{", "final   List < EEApplicationDescription . ViewInformation >    info    =    componentsByViewName . get ( viewName )  ;", "if    ( info    =  =    null )     {", "return   Collections .  < ViewDescription > emptySet (  )  ;", "}", "if    ( componentName . contains (  \"  #  \"  )  )     {", "final   String [  ]    parts    =    componentName . split (  \"  #  \"  )  ;", "String   path    =    parts [  0  ]  ;", "if    (  !  ( path . startsWith (  \"  .  .  /  \"  )  )  )     {", "path    =     \"  .  .  /  \"     +    path ;", "}", "final   VirtualFile   virtualPath    =    deploymentRoot . getChild ( path )  ;", "final   String   name    =    parts [  1  ]  ;", "final   Set < ViewDescription >    ret    =    new   HashSet < ViewDescription >  (  )  ;", "for    ( EEApplicationDescription . ViewInformation   i    :    info )     {", "if    ( i . beanName . equals ( name )  )     {", "if    ( virtualPath . equals ( i . deploymentRoot )  )     {", "ret . add ( i . viewDescription )  ;", "}", "}", "}", "return   ret ;", "} else    {", "final   Set < ViewDescription >    all    =    new   HashSet < ViewDescription >  (  )  ;", "final   Set < ViewDescription >    thisDeployment    =    new   HashSet < ViewDescription >  (  )  ;", "for    ( EEApplicationDescription . ViewInformation   i    :    info )     {", "if    ( i . beanName . equals ( componentName )  )     {", "all . add ( i . viewDescription )  ;", "if    ( i . deploymentRoot . equals ( deploymentRoot )  )     {", "thisDeployment . add ( i . viewDescription )  ;", "}", "}", "}", "if    (  ( all . size (  )  )     >     1  )     {", "return   thisDeployment ;", "}", "return   all ;", "}", "}", "METHOD_END"], "methodName": ["getComponents"], "fileName": "org.jboss.as.ee.component.EEApplicationDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( componentName . contains (  \"  #  \"  )  )     {", "final   String [  ]    parts    =    componentName . split (  \"  #  \"  )  ;", "String   path    =    parts [  0  ]  ;", "if    (  !  ( path . startsWith (  \"  .  .  /  \"  )  )  )     {", "path    =     \"  .  .  /  \"     +    path ;", "}", "final   VirtualFile   virtualPath    =    deploymentRoot . getChild ( path )  ;", "final   String   name    =    parts [  1  ]  ;", "final   List <  . Description >    info    =    componentsByName . get ( name )  ;", "if    ( info    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "final   Set < ComponentDescription >    ret    =    new   HashSet < ComponentDescription >  (  )  ;", "for    (  . Description   i    :    info )     {", "if    ( virtualPath . equals ( i . deploymentRoot )  )     {", "ret . add ( i . componentDescription )  ;", "}", "}", "return   ret ;", "} else    {", "final   List <  . Description >    info    =    componentsByName . get ( componentName )  ;", "if    ( info    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "final   Set < ComponentDescription >    all    =    new   HashSet < ComponentDescription >  (  )  ;", "final   Set < ComponentDescription >    thisDeployment    =    new   HashSet < ComponentDescription >  (  )  ;", "for    (  . Description   i    :    info )     {", "all . add ( i . componentDescription )  ;", "if    ( i . deploymentRoot . equals ( deploymentRoot )  )     {", "thisDeployment . add ( i . componentDescription )  ;", "}", "}", "if    (  ( all . size (  )  )     >     1  )     {", "return   thisDeployment ;", "}", "return   all ;", "}", "}", "METHOD_END"], "methodName": ["getComponents"], "fileName": "org.jboss.as.ee.component.EEApplicationDescription"}, {"methodBody": ["METHOD_START", "{", "final   List < EEApplicationDescription . ViewInformation >    info    =    componentsByViewName . get ( viewType )  ;", "if    ( info    =  =    null )     {", "return   Collections .  < ViewDescription > emptySet (  )  ;", "}", "final   Set < ViewDescription >    ret    =    new   HashSet < ViewDescription >  (  )  ;", "final   Set < ViewDescription >    currentDep    =    new   HashSet < ViewDescription >  (  )  ;", "for    ( EEApplicationDescription . ViewInformation   i    :    info )     {", "if    ( deploymentRoot . equals ( i . deploymentRoot )  )     {", "currentDep . add ( i . viewDescription )  ;", "}", "ret . add ( i . viewDescription )  ;", "}", "if    (  !  ( currentDep . isEmpty (  )  )  )     {", "return   currentDep ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["getComponentsForViewName"], "fileName": "org.jboss.as.ee.component.EEApplicationDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( messageDestName . contains (  \"  #  \"  )  )     {", "final   String [  ]    parts    =    messageDestName . split (  \"  #  \"  )  ;", "String   path    =    parts [  0  ]  ;", "if    (  !  ( path . startsWith (  \"  .  .  /  \"  )  )  )     {", "path    =     \"  .  .  /  \"     +    path ;", "}", "final   VirtualFile   virtualPath    =    deploymentRoot . getChild ( path )  ;", "final   String   name    =    parts [  1  ]  ;", "final   Set < String >    ret    =    new   HashSet < String >  (  )  ;", "final   List <  . MessageDestinationMapping >    data    =    messageDestinationJndiMapping . get ( name )  ;", "if    ( data    !  =    null )     {", "for    ( final    . MessageDestinationMapping   i    :    data )     {", "if    ( virtualPath . equals ( i . deploymentRoot )  )     {", "ret . add ( i . jndiName )  ;", "}", "}", "}", "return   ret ;", "} else    {", "final   Set < String >    all    =    new   HashSet < String >  (  )  ;", "final   Set < String >    thisDeployment    =    new   HashSet < String >  (  )  ;", "final   List <  . MessageDestinationMapping >    data    =    messageDestinationJndiMapping . get ( messageDestName )  ;", "if    ( data    !  =    null )     {", "for    ( final    . MessageDestinationMapping   i    :    data )     {", "all . add ( i . jndiName )  ;", "if    ( i . deploymentRoot . equals ( deploymentRoot )  )     {", "thisDeployment . add ( i . jndiName )  ;", "}", "}", "}", "if    (  ( all . size (  )  )     >     1  )     {", "return   thisDeployment ;", "}", "return   all ;", "}", "}", "METHOD_END"], "methodName": ["resolveMessageDestination"], "fileName": "org.jboss.as.ee.component.EEApplicationDescription"}, {"methodBody": ["METHOD_START", "{", "return   contextService ;", "}", "METHOD_END"], "methodName": ["getContextService"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "return   dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "return   jmsConnectionFactory ;", "}", "METHOD_END"], "methodName": ["getJmsConnectionFactory"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "return   managedExecutorService ;", "}", "METHOD_END"], "methodName": ["getManagedExecutorService"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "return   managedScheduledExecutorService ;", "}", "METHOD_END"], "methodName": ["getManagedScheduledExecutorService"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "return   managedThreadFactory ;", "}", "METHOD_END"], "methodName": ["getManagedThreadFactory"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "this . contextService    =    contextService ;", "}", "METHOD_END"], "methodName": ["setContextService"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "this . dataSource    =    dataSource ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "this . jmsConnectionFactory    =    jmsConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setJmsConnectionFactory"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "this . managedExecutorService    =    managedExecutorService ;", "}", "METHOD_END"], "methodName": ["setManagedExecutorService"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "this . managedScheduledExecutorService    =    managedScheduledExecutorService ;", "}", "METHOD_END"], "methodName": ["setManagedScheduledExecutorService"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "this . managedThreadFactory    =    managedThreadFactory ;", "}", "METHOD_END"], "methodName": ["setManagedThreadFactory"], "fileName": "org.jboss.as.ee.component.EEDefaultResourceJndiNames"}, {"methodBody": ["METHOD_START", "{", "this . annotationInformation . put ( annotationInformation . getAnnotationType (  )  ,    annotationInformation )  ;", "}", "METHOD_END"], "methodName": ["addAnnotationInformation"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "injectionConfigurations . put ( injection . getTarget (  )  ,    injection )  ;", "}", "METHOD_END"], "methodName": ["addResourceInjection"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ClassAnnotationInformation < A ,    T >  )     ( this . annotationInformation . get ( annotationType )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationInformation"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   bindingConfigurations ;", "}", "METHOD_END"], "methodName": ["getBindingConfigurations"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   injectionConfigurations ;", "}", "METHOD_END"], "methodName": ["getInjectionConfigurations"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   interceptorClassDescription ;", "}", "METHOD_END"], "methodName": ["getInterceptorClassDescription"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( invalidMessageBuilder )     =  =    null )     {", "return    \"  \"  ;", "}", "return   invalidMessageBuilder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getInvalidMessage"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   invalid ;", "}", "METHOD_END"], "methodName": ["isInvalid"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( interceptorClassDescription    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" interceptorClassDescription \"  ,     \" module   class \"  ,    className )  ;", "}", "this . interceptorClassDescription    =    interceptorClassDescription ;", "}", "METHOD_END"], "methodName": ["setInterceptorClassDescription"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( invalid )  )     {", "invalid    =    true ;", "invalidMeageBuilder    =    new   StringBuilder (  )  ;", "} else    {", "invalidMeageBuilder . append (  '  \\ n '  )  ;", "}", "invalidMeageBuilder . append ( meage )  ;", "}", "METHOD_END"], "methodName": ["setInvalid"], "fileName": "org.jboss.as.ee.component.EEModuleClassDescription"}, {"methodBody": ["METHOD_START", "{", "componentConfigurations . add ( configuration )  ;", "}", "METHOD_END"], "methodName": ["addComponentConfiguration"], "fileName": "org.jboss.as.ee.component.EEModuleConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ee.component.EEModuleConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( componentConfigurations )  ;", "}", "METHOD_END"], "methodName": ["getComponentConfigurations"], "fileName": "org.jboss.as.ee.component.EEModuleConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.ee.component.EEModuleConfiguration"}, {"methodBody": ["METHOD_START", "{", "final   String   componentName    =    description . getComponentName (  )  ;", "final   String   componentClassName    =    description . getComponentClassName (  )  ;", "if    ( componentName    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" componentName \"  ,     \" module \"  ,    moduleName )  ;", "}", "if    ( componentClassName    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" componentClassName \"  ,     \" module \"  ,    moduleName )  ;", "}", "if    ( componentsByName . containsKey ( componentName )  )     {", "throw   EeLogger . ROOT _ LOGGER . componentAlreadyDefined ( componentName )  ;", "}", "componentsByName . put ( componentName ,    description )  ;", "List < Component >    list    =    componentsByClassName . get ( componentClassName )  ;", "if    ( list    =  =    null )     {", "componentsByClassName . put ( componentClassName ,     ( list    =    new   ArrayList < Component >  (  1  )  )  )  ;", "}", "list . add ( description )  ;", "}", "METHOD_END"], "methodName": ["addComponent"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "interceptorEnvironment . put ( interceptorClassName ,    env )  ;", "}", "METHOD_END"], "methodName": ["addInterceptorEnvironment"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "interceptorClassOverrides . put ( className ,    InterceptorClassDescription . merge ( interceptorClassOverrides . get ( className )  ,    override )  )  ;", "}", "METHOD_END"], "methodName": ["addInterceptorMethodOverride"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "messageDestinations . put ( name ,    jndiName )  ;", "}", "METHOD_END"], "methodName": ["addMessageDestination"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( className    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" className \"  ,     \" module \"  ,    moduleName )  ;", "}", "EEModuleClass   ret    =    classs . get ( className )  ;", "if    ( ret    =  =    null )     {", "classs . put ( className ,     ( ret    =    new   EEModuleClass ( className )  )  )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["addOrGetLocalClassDescription"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "String   className    =    injection . getTarget (  )  . getClassName (  )  ;", "Map < InjectionTarget ,    ResourceInjectionConfiguration >    map    =    resourceInjections . get ( className )  ;", "if    ( map    =  =    null )     {", "resourceInjections . put ( className ,     ( map    =    new   HashMap < InjectionTarget ,    ResourceInjectionConfiguration >  (  )  )  )  ;", "}", "map . put ( injection . getTarget (  )  ,    injection )  ;", "}", "METHOD_END"], "methodName": ["addResourceInjection"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( applicationName )     =  =    null )     {", "return   mName ;", "}", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   bindingConfigurations ;", "}", "METHOD_END"], "methodName": ["getBindingConfigurations"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   classDescriptions . get ( className )  ;", "}", "METHOD_END"], "methodName": ["getClassDescription"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   classDescriptions . values (  )  ;", "}", "METHOD_END"], "methodName": ["getClassDescriptions"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   componentsByName . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getComponentByName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   componentsByName . values (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentDescriptions"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "final   List < ComponentDescription >    ret    =    componentsByClassName . get ( className )  ;", "return   ret    =  =    null    ?    Collections .  < ComponentDescription > emptyList (  )     :    ret ;", "}", "METHOD_END"], "methodName": ["getComponentsByClassName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   concurrentContext ;", "}", "METHOD_END"], "methodName": ["getConcurrentContext"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   defaultClassIntrospectorServiceName ;", "}", "METHOD_END"], "methodName": ["getDefaultClassIntrospectorServiceName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   defaultResourceJndiNames ;", "}", "METHOD_END"], "methodName": ["getDefaultResourceJndiNames"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   defaultSecurityDomain ;", "}", "METHOD_END"], "methodName": ["getDefaultSecurityDomain"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   distinctName ;", "}", "METHOD_END"], "methodName": ["getDistinctName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . earApplicationName ;", "}", "METHOD_END"], "methodName": ["getEarApplicationName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   interceptorClassOverrides . get ( className )  ;", "}", "METHOD_END"], "methodName": ["getInterceptorClassOverride"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   interceptorEnvironment ;", "}", "METHOD_END"], "methodName": ["getInterceptorEnvironment"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( messageDestinations )  ;", "}", "METHOD_END"], "methodName": ["getMessageDestinations"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   namespaceContextSelector ;", "}", "METHOD_END"], "methodName": ["getNamespaceContextSelector"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "Map < InjectionTarget ,    ResourceInjectionConfiguration >    injections    =    resourceInjections . get ( className )  ;", "if    ( injections    =  =    null )     {", "return   Collections . emptyMap (  )  ;", "} else    {", "return   Collections . unmodifiableMap ( injections )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceInjections"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   this . startupBeansCount ;", "}", "METHOD_END"], "methodName": ["getStartupBeansCount"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   componentsByName . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["hasComponent"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return   appClient ;", "}", "METHOD_END"], "methodName": ["isAppClient"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return    +  +  ( this . startupBeansCount )  ;", "}", "METHOD_END"], "methodName": ["registerStartupBean"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "componentsByName . remove ( componentName )  ;", "componentsByClassName . remove ( componentClassName )  ;", "}", "METHOD_END"], "methodName": ["removeComponent"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "this . defaultClassIntrospectorServiceName    =    defaultClassIntrospectorServiceName ;", "}", "METHOD_END"], "methodName": ["setDefaultClassIntrospectorServiceName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "this . defaultSecurityDomain    =    defaultSecurityDomain ;", "}", "METHOD_END"], "methodName": ["setDefaultSecurityDomain"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( distinctName    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" distinctName \"  ,     \" m \"  ,    mName )  ;", "}", "this . distinctName    =    distinctName ;", "}", "METHOD_END"], "methodName": ["setDistinctName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "this . moduleName    =    moduleName ;", "}", "METHOD_END"], "methodName": ["setModuleName"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "this . namespaceContextSelector    =    namespaceContextSelector ;", "}", "METHOD_END"], "methodName": ["setNamespaceContextSelector"], "fileName": "org.jboss.as.ee.component.EEModuleDescription"}, {"methodBody": ["METHOD_START", "{", "return    ( injectionSource    !  =    null )     &  &     ( value . equals ( injectionSource . value )  )  ;", "}", "METHOD_END"], "methodName": ["equalTo"], "fileName": "org.jboss.as.ee.component.EnvEntryInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return    ( injectionSource   instanceof   EnvEntryInjectionSource )     &  &     ( equalTo (  (  ( EnvEntryInjectionSource )     ( injectionSource )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.EnvEntryInjectionSource"}, {"methodBody": ["METHOD_START", "{", "injector . inject ( new   ValueManagedReferenceFactory ( Values . immediateValue ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ee.component.EnvEntryInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   value . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.EnvEntryInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   new   ManagedReferenceFieldInjectionInterceptorFactory ( targetContextKey ,    valueContextKey ,    factoryValue ,    getField ( deploymentUnit )  ,    optional )  ;", "}", "METHOD_END"], "methodName": ["createInjectionInterceptorFactory"], "fileName": "org.jboss.as.ee.component.FieldInjectionTarget"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    getName (  )  ;", "final   String   className    =    getClassName (  )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( Attachments . MODULE )  ;", "final   ModuleClassLoader   classLoader    =    module . getClassLoader (  )  ;", "final   DeploymentReflIndex   reflIndex    =    deploymentUnit . getAttachment ( Attachments . REFLECTION _ INDEX )  ;", "final   ClassReflIndex   classIndex ;", "try    {", "classIndex    =    reflIndex . getClassIndex ( Class . forName ( className ,    false ,    classLoader )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   DeploymentUnitProcessingException ( e )  ;", "}", "final   Field   field    =    classIndex . getField ( name )  ;", "if    ( field    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . fieldNotFound ( name )  ;", "}", "return   field ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.jboss.as.ee.component.FieldInjectionTarget"}, {"methodBody": ["METHOD_START", "{", "return    ( configuration    !  =    null )     &  &     ( value . equals ( configuration . value )  )  ;", "}", "METHOD_END"], "methodName": ["equalTo"], "fileName": "org.jboss.as.ee.component.FixedInjectionSource"}, {"methodBody": ["METHOD_START", "{", "injector . inject ( managedReferenceFactory )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ee.component.FixedInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   value . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.FixedInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.jboss.as.ee.component.InjectionTarget"}, {"methodBody": ["METHOD_START", "{", "return   declaredValueClassName ;", "}", "METHOD_END"], "methodName": ["getDeclaredValueClassName"], "fileName": "org.jboss.as.ee.component.InjectionTarget"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.ee.component.InjectionTarget"}, {"methodBody": ["METHOD_START", "{", "return   interceptorClassName ;", "}", "METHOD_END"], "methodName": ["getInterceptorClassName"], "fileName": "org.jboss.as.ee.component.InterceptorDescription"}, {"methodBody": ["METHOD_START", "{", "resourceInjections . add ( injection )  ;", "}", "METHOD_END"], "methodName": ["addResourceInjection"], "fileName": "org.jboss.as.ee.component.InterceptorEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   bindingConfigurations ;", "}", "METHOD_END"], "methodName": ["getBindingConfigurations"], "fileName": "org.jboss.as.ee.component.InterceptorEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   deploymentDescriptorEnvironment ;", "}", "METHOD_END"], "methodName": ["getDeploymentDescriptorEnvironment"], "fileName": "org.jboss.as.ee.component.InterceptorEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   resourceInjections ;", "}", "METHOD_END"], "methodName": ["getResourceInjections"], "fileName": "org.jboss.as.ee.component.InterceptorEnvironment"}, {"methodBody": ["METHOD_START", "{", "if    ( configuration   instanceof   LookupInjectionSource )     {", "LookupInjectionSource   lookup    =     (  ( LookupInjectionSource )     ( configuration )  )  ;", "return   lookupName . equals ( lookup . lookupName )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.LookupInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   String   applicationName    =    resolutionContext . getApplicationName (  )  ;", "final   String   moduleName    =    resolutionContext . getModuleName (  )  ;", "final   String   componentName    =    resolutionContext . getComponentName (  )  ;", "final   boolean   compUsesModule    =    resolutionContext . isCompUsesModule (  )  ;", "final   String   scheme    =    InitialContext . getURLScheme ( lookupName )  ;", "if    ( scheme    =  =    null )     {", "if    (  ( componentName    !  =    null )     &  &     (  ! compUsesModule )  )     {", "ContextNames . bindInfoFor ( applicationName ,    moduleName ,    componentName ,     (  \" java : comp / env /  \"     +     ( lookupName )  )  )  . setupLookupInjection ( serviceBuilder ,    injector ,    phaseContext . getDeploymentUnit (  )  ,    optional )  ;", "} else", "if    ( compUsesModule )     {", "ContextNames . bindInfoFor ( applicationName ,    moduleName ,    componentName ,     (  \" java : module / env /  \"     +     ( lookupName )  )  )  . setupLookupInjection ( serviceBuilder ,    injector ,    phaseContext . getDeploymentUnit (  )  ,    optional )  ;", "} else    {", "ContextNames . bindInfoFor ( applicationName ,    moduleName ,    componentName ,     (  \" java : jboss / env /  \"     +     ( lookupName )  )  )  . setupLookupInjection ( serviceBuilder ,    injector ,    phaseContext . getDeploymentUnit (  )  ,    optional )  ;", "}", "} else    {", "if    ( scheme . equals (  \" java \"  )  )     {", "if    ( compUsesModule    &  &     ( lookupName . startsWith (  \" java : comp /  \"  )  )  )     {", "ContextNames . bindInfoFor ( applicationName ,    moduleName ,    componentName ,     (  \" java : module /  \"     +     ( lookupName . substring (  1  0  )  )  )  )  . setupLookupInjection ( serviceBuilder ,    injector ,    phaseContext . getDeploymentUnit (  )  ,    optional )  ;", "} else    {", "ContextNames . bindInfoFor ( applicationName ,    moduleName ,    componentName ,    lookupName )  . setupLookupInjection ( serviceBuilder ,    injector ,    phaseContext . getDeploymentUnit (  )  ,    optional )  ;", "}", "} else    {", "final   ManagedReferenceFactory   managedReferenceFactory ;", "if    (  . URL _ SCHEMES . contains ( scheme )  )     {", "managedReferenceFactory    =    new   ManagedReferenceFactory (  )     {", "@ Override", "public   ManagedReference   getReference (  )     {", "try    {", "return   new   ImmediateManagedReference ( new   URL ( lookupName )  )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  ;", "} else    {", "managedReferenceFactory    =    new   ManagedReferenceFactory (  )     {", "@ Override", "public   ManagedReference   getReference (  )     {", "try    {", "return   new   ImmediateManagedReference ( new   InitialContext (  )  . lookup ( lookupName )  )  ;", "}    catch    ( NamingException   e )     {", "EeLogger . ROOT _ LOGGER . tracef ( e ,     \" failed   to   lookup    % s \"  ,    lookupName )  ;", "return   null ;", "}", "}", "}  ;", "}", "injector . inject ( managedReferenceFactory )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ee.component.LookupInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   lookupName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.LookupInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return    (  \" lookup    (  \"     +     ( lookupName )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.ee.component.LookupInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   new   ManagedReferenceFieldInjectionInterceptorFactory . ManagedReferenceFieldInjectionInterceptor ( targetContextKey ,    valueContextKey ,    factoryValue . getValue (  )  ,    field ,    optional )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.ee.component.ManagedReferenceFieldInjectionInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "final   ManagedReference   reference    =     (  ( ManagedReference )     ( context . getPrivateData ( ComponentInstance . class )  . getInstanceData ( contextKey )  )  )  ;", "final   Object   instance    =    reference . getInstance (  )  ;", "try    {", "final   Method   method    =    this . method ;", "if    ( withContext )     {", "final   Method   oldMethod    =    context . getMethod (  )  ;", "try    {", "if    ( this . lifecycleMethod )     {", "context . setMethod ( null )  ;", "return   method . invoke ( instance ,    context . getInvocationContext (  )  )  ;", "} else", "if    ( this . changeMethod )     {", "context . setMethod ( method )  ;", "return   method . invoke ( instance ,    context . getInvocationContext (  )  )  ;", "} else    {", "return   method . invoke ( instance ,    context . getInvocationContext (  )  )  ;", "}", "}    finally    {", "context . setMethod ( oldMethod )  ;", "}", "} else    {", "method . invoke ( instance )  ;", "return   context . proceed (  )  ;", "}", "}    catch    ( IllegalAccessException   e )     {", "final   IllegalAccessError   n    =    new   IllegalAccessError ( e . getMessage (  )  )  ;", "n . setStackTrace ( e . getStackTrace (  )  )  ;", "throw   n ;", "}    catch    ( InvocationTargetException   e )     {", "throw   Interceptors . rethrow ( e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ee.component.ManagedReferenceLifecycleMethodInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   ManagedReferenceMethodInjectionInterceptorFactory . ManagedReferenceMethodInjectionInterceptor ( targetContextKey ,    valueContextKey ,    factoryValue . getValue (  )  ,    method ,    optional )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.ee.component.ManagedReferenceMethodInjectionInterceptorFactory"}, {"methodBody": ["METHOD_START", "{", "final   ManagedReference   reference    =     (  ( ManagedReference )     ( context . getPrivateData ( ComponentInstance . class )  . getInstanceData ( contextKey )  )  )  ;", "final   Object   instance    =    reference . getInstance (  )  ;", "try    {", "return   method . invoke ( instance ,    context . getParameters (  )  )  ;", "}    catch    ( IllegalAccessException   e )     {", "final   IllegalAccessError   n    =    new   IllegalAccessError ( e . getMessage (  )  )  ;", "n . setStackTrace ( e . getStackTrace (  )  )  ;", "throw   n ;", "}    catch    ( InvocationTargetException   e )     {", "throw   Interceptors . rethrow ( e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ee.component.ManagedReferenceMethodInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   context . proceed (  )  ;", "}    finally    {", "final      managedReference    =     (  (  )     ( context . getPrivateData ( ComponentInstance . class )  . getInstanceData ( contextKey )  )  )  ;", "if    ( managedReference    !  =    null )     {", "managedReference . release (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ee.component.ManagedReferenceReleaseInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   ManagedReferenceMethodInjectionInterceptorFactory ( targetContextKey ,    valueContextKey ,    factoryValue ,    getMethod ( deploymentUnit )  ,    optional )  ;", "}", "METHOD_END"], "methodName": ["createInjectionInterceptorFactory"], "fileName": "org.jboss.as.ee.component.MethodInjectionTarget"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    getName (  )  ;", "final   String   className    =    getClassName (  )  ;", "final   String   paramType    =    getDeclaredValueClassName (  )  ;", "final   DeploymentReflIndex   reflIndex    =    deploymentUnit . getAttachment ( REFLECTION _ INDEX )  ;", "final   Class <  ?  >    clazz ;", "try    {", "clazz    =    ClassLoadingUtils . loadClass ( className ,    deploymentUnit )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   DeploymentUnitProcessingException ( e )  ;", "}", "Method   method    =    getMethod ( reflIndex ,    clazz )  ;", "return   method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.jboss.as.ee.component.MethodInjectionTarget"}, {"methodBody": ["METHOD_START", "{", "final   ClassReflectionIndex   classIndex    =    reflectionIndex . getClassIndex ( clazz )  ;", "Collection < Method >    methods    =    null ;", "final   String   paramType    =    getDeclaredValueClassName (  )  ;", "final   String   name    =    getName (  )  ;", "final   String   className    =    getClassName (  )  ;", "if    ( paramType    !  =    null )     {", "methods    =    ClassReflectionIndexUtil . findMethods ( reflectionIndex ,    classIndex ,    name ,    paramType )  ;", "}", "if    (  ( methods    =  =    null )     |  |     ( methods . isEmpty (  )  )  )     {", "methods    =    ClassReflectionIndexUtil . findAllMethods ( reflectionIndex ,    classIndex ,    name ,     1  )  ;", "}", "Iterator < Method >    iterator    =    methods . iterator (  )  ;", "if    (  !  ( iterator . hasNext (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . methodNotFound ( name ,    paramType ,    className )  ;", "}", "Method   method    =    iterator . next (  )  ;", "if    ( iterator . hasNext (  )  )     {", "throw   EeLogger . ROOT _ LOGGER . multipleMethodsFound ( name ,    paramType ,    className )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.jboss.as.ee.component.MethodInjectionTarget"}, {"methodBody": ["METHOD_START", "{", "final   ComponentNamingMode   namingMode    =    description . getNamingMode (  )  ;", "final   InjectedEEtextSelector   selector    =    new   InjectedEEtextSelector (  )  ;", "final   String   applicationName    =    configuration . getApplicationName (  )  ;", "final   String   moduleName    =    configuration . getModuleName (  )  ;", "final   String   compName    =    configuration . getComponentName (  )  ;", "final   ServiceName   appContextServiceName    =    ContextNames . contextServiceNameOfApplication ( applicationName )  ;", "final   ServiceName   moduleContextServiceName    =    ContextNames . contextServiceNameOfModule ( applicationName ,    moduleName )  ;", "final   ServiceName   compContextServiceName    =    ContextNames . contextServiceNameOfComponent ( applicationName ,    moduleName ,    compName )  ;", "final   Injector < NamingStore >    appInjector    =    selector . getAppContextInjector (  )  ;", "final   Injector < NamingStore >    moduleInjector    =    selector . getModuleContextInjector (  )  ;", "final   Injector < NamingStore >    compInjector    =    selector . getCompContextInjector (  )  ;", "final   Injector < NamingStore >    jbossInjector    =    selector . getJbossContextInjector (  )  ;", "final   Injector < NamingStore >    globalInjector    =    selector . getGlobalContextInjector (  )  ;", "final   Injector < NamingStore >    exportedInjector    =    selector . getExportedContextInjector (  )  ;", "configuration . getStartDependencies (  )  . add ( new   DependencyConfigurator < ComponentStartService >  (  )     {", "public   void   configureDependency ( final   ServiceBuilder <  ?  >    serviceBuilder ,    ComponentStartService   service )     {", "serviceBuilder . addDependency ( appContextServiceName ,    NamingStore . class ,    appInjector )  ;", "serviceBuilder . addDependency ( moduleContextServiceName ,    NamingStore . class ,    moduleInjector )  ;", "if    ( namingMode    =  =     ( ComponentNamingMode . CREATE )  )     {", "serviceBuilder . addDependency ( compContextServiceName ,    NamingStore . class ,    compInjector )  ;", "} else", "if    ( namingMode    =  =     ( ComponentNamingMode . USE _ MODULE )  )     {", "serviceBuilder . addDependency ( moduleContextServiceName ,    NamingStore . class ,    compInjector )  ;", "}", "serviceBuilder . addDependency ( GLOBAL _ CONTEXT _ SERVICE _ NAME ,    NamingStore . class ,    globalInjector )  ;", "serviceBuilder . addDependency ( JBOSS _ CONTEXT _ SERVICE _ NAME ,    NamingStore . class ,    jbossInjector )  ;", "serviceBuilder . addDependency ( EXPORTED _ CONTEXT _ SERVICE _ NAME ,    NamingStore . class ,    exportedInjector )  ;", "}", "}  )  ;", "final   InterceptorFactory   interceptorFactory    =    new   ImmediateInterceptorFactory ( new   textInterceptor ( selector ,    context . getDeploymentUnit (  )  . getServiceName (  )  )  )  ;", "configuration . addPostConstructInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPostConstruct . JNDI _ NAMESPACE _ INTERCEPTOR )  ;", "configuration . addPreDestroyInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPreDestroy . JNDI _ NAMESPACE _ INTERCEPTOR )  ;", "if    ( description . isPassivationApplicable (  )  )     {", "configuration . addPrePassivateInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPassivation . JNDI _ NAMESPACE _ INTERCEPTOR )  ;", "configuration . addPostActivateInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPassivation . JNDI _ NAMESPACE _ INTERCEPTOR )  ;", "}", "configuration . settextInterceptorFactory ( interceptorFactory )  ;", "configuration . settextSelector ( selector )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.ee.component.NamespaceConfigurator"}, {"methodBody": ["METHOD_START", "{", "NamespaceContextSelector . pushCurrentSelector ( selector )  ;", "try    {", "WritableServiceBasedNamingStore . pushOwner ( deploymentUnitServiceName )  ;", "try    {", "return   context . proceed (  )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "}    finally    {", "NamespaceContextSelector . popCurrentSelector (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ee.component.NamespaceContextInterceptor"}, {"methodBody": ["METHOD_START", "{", "configuration . addViewInterceptor ( componentConfiguration . getNamespaceContextInterceptorFactory (  )  ,    InterceptorOrder . View . JNDI _ NAMESPACE _ INTERCEPTOR )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.jboss.as.ee.component.NamespaceViewConfigurator"}, {"methodBody": ["METHOD_START", "{", "final   Interceptor   interceptor    =    interceptors . get ( method )  ;", "if    ( interceptor    =  =    null )     {", "throw   new   NoSuchMethodError ( method . toString (  )  )  ;", "}", "final   InterceptorContext   context    =    new   InterceptorContext (  )  ;", "context . putPrivateData ( Object . class ,    proxy )  ;", "context . putPrivateData ( Component . class ,    componentView . getComponent (  )  )  ;", "context . putPrivateData ( ComponentView . class ,    componentView )  ;", "context . putPrivateData ( SecurityDomain . class ,     ( WildFlySecurityManager . isChecking (  )     ?    AccessController . doPrivileged (  (  ( PrivilegedAction < SecurityDomain >  )     ( SecurityDomain :  : getCurrent )  )  )     :    SecurityDomain . getCurrent (  )  )  )  ;", "instance . prepareInterceptorContext ( context )  ;", "context . setParameters ( args )  ;", "context . setMethod ( method )  ;", "context . setContextData ( new   HashMap < String ,    Object >  (  )  )  ;", "context . setBlockingCaller ( true )  ;", "return   interceptor . process ( context )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.jboss.as.ee.component.ProxyInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.jboss.as.ee.component.ResourceInjectionConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.jboss.as.ee.component.ResourceInjectionConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   optional ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "org.jboss.as.ee.component.ResourceInjectionConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    ( configuration    !  =    null )     &  &     ( serviceName . equals ( configuration . serviceName )  )  ;", "}", "METHOD_END"], "methodName": ["equalTo"], "fileName": "org.jboss.as.ee.component.ServiceInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    other )     {", "return   true ;", "}", "if    (  ( other   instanceof    )     =  =    false )     {", "return   false ;", "}", "obj    =     (  (  )     ( other )  )  ;", "return   this . equalTo ( obj )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.ServiceInjectionSource"}, {"methodBody": ["METHOD_START", "{", "Injector   inject    =     ( ManagedReferenceFactory . class . isAssignableFrom ( serviceValueType )  )     ?    injector    :    new   ManagedReferenceInjector ( injector )  ;", "serviceBuilder . addDependency ( serviceName ,    serviceValueType ,    inject )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ee.component.ServiceInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   serviceName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.ServiceInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return    ( configuration    !  =    null )     &  &     ( serviceName . equals ( configuration . serviceName )  )  ;", "}", "METHOD_END"], "methodName": ["equalTo"], "fileName": "org.jboss.as.ee.component.ViewBindingInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return    ( injectionSource   instanceof   ViewBindingInjectionSource )     &  &     ( equalTo (  (  ( ViewBindingInjectionSource )     ( injectionSource )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.ViewBindingInjectionSource"}, {"methodBody": ["METHOD_START", "{", "serviceBuilder . addDependency ( serviceName ,    ComponentView . class ,    new   ViewManagedReferenceFactory . Injector ( injector )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ee.component.ViewBindingInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   serviceName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.ViewBindingInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . asyncMethods . add ( method )  ;", "}", "METHOD_END"], "methodName": ["addAsyncMethod"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "OrderedItemContainer < InterceptorFactory >    container    =    clientInterceptors . get ( method )  ;", "if    ( container    =  =    null )     {", "clientInterceptors . put ( method ,     ( container    =    new   OrderedItemContainer < InterceptorFactory >  (  )  )  )  ;", "}", "container . add ( interceptorFactory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addClientInterceptor"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    proxyFactory . getCachedMethods (  )  )     {", "addCliInterceptor ( method ,    interceptorFactory ,    priority )  ;", "}", "}", "METHOD_END"], "methodName": ["addClientInterceptor"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "clientPostConstructInterceptors . add ( interceptorFactory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addClientPostConstructInterceptor"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "clientPreDestroyInterceptors . add ( interceptorFactory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addClientPreDestroyInterceptor"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "OrderedItemContainer < InterceptorFactory >    container    =    viewInterceptors . get ( method )  ;", "if    ( container    =  =    null )     {", "viewInterceptors . put ( method ,     ( container    =    new   OrderedItemContainer < InterceptorFactory >  (  )  )  )  ;", "}", "container . add ( interceptorFactory ,    priority )  ;", "}", "METHOD_END"], "methodName": ["addViewInterceptor"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    proxyFactory . getCachedMethods (  )  )     {", "addInterceptor ( method ,    interceptorFactory ,    priority )  ;", "}", "}", "METHOD_END"], "methodName": ["addViewInterceptor"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( asyncMethods )  ;", "}", "METHOD_END"], "methodName": ["getAsyncMethods"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   bindingConfigurations ;", "}", "METHOD_END"], "methodName": ["getBindingConfigurations"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "OrderedItemContainer < InterceptorFactory >    container    =    clientInterceptors . get ( method )  ;", "if    ( container    =  =    null )     {", "return   Collecs . emptyList (  )  ;", "}", "return   container . getSortedItems (  )  ;", "}", "METHOD_END"], "methodName": ["getClientInterceptors"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   clientPostConstructInterceptors . getSortedItems (  )  ;", "}", "METHOD_END"], "methodName": ["getClientPostConstructInterceptors"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   clientPreDestroyInterceptors . getSortedItems (  )  ;", "}", "METHOD_END"], "methodName": ["getClientPreDestroyInterceptors"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   componentConfiguration ;", "}", "METHOD_END"], "methodName": ["getComponentConfiguration"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   privateData ;", "}", "METHOD_END"], "methodName": ["getPrivateData"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   proxyFactory ;", "}", "METHOD_END"], "methodName": ["getProxyFactory"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   viewClass ;", "}", "METHOD_END"], "methodName": ["getViewClass"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   viewInstanceFactory ;", "}", "METHOD_END"], "methodName": ["getViewInstanceFactory"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "OrderedItemContainer < InterceptorFactory >    container    =    viewInterceptors . get ( method )  ;", "if    ( container    =  =    null )     {", "return   Collecs . emptyList (  )  ;", "}", "return   container . getSortedItems (  )  ;", "}", "METHOD_END"], "methodName": ["getViewInterceptors"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   viewServiceName ;", "}", "METHOD_END"], "methodName": ["getViewServiceName"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   viewToComponentMethodMap ;", "}", "METHOD_END"], "methodName": ["getViewToComponentMethodMap"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "privateData . put ( type ,    data )  ;", "}", "METHOD_END"], "methodName": ["putPrivateData"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . viewInstanceFactory    =    viewInstanceFactory ;", "}", "METHOD_END"], "methodName": ["setViewInstanceFactory"], "fileName": "org.jboss.as.ee.component.ViewConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   ViewBindingInjectionSource ( serviceName )  ;", "}", "METHOD_END"], "methodName": ["createInjectionSource"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   new   ViewConfiguration ( viewClass ,    componentConfiguration ,    getServiceName (  )  ,    proxyFactory )  ;", "}", "METHOD_END"], "methodName": ["createViewConfiguration"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   bindingNames ;", "}", "METHOD_END"], "methodName": ["getBindingNames"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   componentDescription ;", "}", "METHOD_END"], "methodName": ["getComponentDescription"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   configurators ;", "}", "METHOD_END"], "methodName": ["getConfigurators"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( viewNameParts . isEmpty (  )  )  )     {", "return   component . getServiceName (  )  . append (  \" VIEW \"  )  . append ( viewNameParts . toArray ( new   String [ viewNameParts . size (  )  ]  )  )  ;", "} else    {", "return   component . getServiceName (  )  . append (  \" VIEW \"  )  . append ( viewClassName )  ;", "}", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   viewClassName ;", "}", "METHOD_END"], "methodName": ["getViewClassName"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   viewNameParts ;", "}", "METHOD_END"], "methodName": ["getViewNameParts"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   serializable ;", "}", "METHOD_END"], "methodName": ["isSerializable"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "return   useWriteReplace ;", "}", "METHOD_END"], "methodName": ["isUseWriteReplace"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "this . serializable    =    serializable ;", "}", "METHOD_END"], "methodName": ["setSerializable"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "this . useWriteReplace    =    useWriteReplace ;", "}", "METHOD_END"], "methodName": ["setUseWriteReplace"], "fileName": "org.jboss.as.ee.component.ViewDescription"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   view . createInstance (  )  ;", "}    catch    ( Exception   e )     {", "throw   EeLogger . ROOT _ LOGGERViewConstructionFailure ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.jboss.as.ee.component.ViewManagedReferenceFactory"}, {"methodBody": ["METHOD_START", "{", "return   componentInjector ;", "}", "METHOD_END"], "methodName": ["getComponentInjector"], "fileName": "org.jboss.as.ee.component.ViewService"}, {"methodBody": ["METHOD_START", "{", "return   view ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.component.ViewService"}, {"methodBody": ["METHOD_START", "{", "ViewService . View   view    =    new   ViewService . View ( privateData )  ;", "view . initializeInterceptors (  )  ;", "this . view    =    view ;", "final   SimpleInterceptorFactoryContext   factoryContext    =    new   SimpleInterceptorFactoryContext (  )  ;", "final   Component   component    =    view . getComponent (  )  ;", "factoryContext . getContextData (  )  . put ( Component . class ,    component )  ;", "factoryContext . getContextData (  )  . put ( ComponentView . class ,    view )  ;", "clientPostConstructInterceptor    =    clientPostConstruct . create ( factoryContext )  ;", "clientPreDestroyInterceptor    =    clientPreDestroy . create ( factoryContext )  ;", "final   Map < Method ,    InterceptorFactory >    clientInterceptorFactories    =    this . clientInterceptorFactories ;", "clientInterceptors    =    new   IdentityHashMap < Method ,    Interceptor >  ( clientInterceptorFactories . size (  )  )  ;", "for    ( Method   method    :    clientInterceptorFactories . keySet (  )  )     {", "clientInterceptors . put ( method ,    clientInterceptorFactories . get ( method )  . create ( factoryContext )  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ee.component.ViewService"}, {"methodBody": ["METHOD_START", "{", "view    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ee.component.ViewService"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   Collection < ComponentDescription >    componentConfigurations    =    eeModuleDescription . getComponentDescriptions (  )  ;", "if    (  ( componentConfigurations    =  =    null )     |  |     ( componentConfigurations . isEmpty (  )  )  )     {", "return ;", "}", "for    ( ComponentDescription   componentConfiguration    :    componentConfigurations )     {", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "if    ( index    !  =    null )     {", "process ( deploymentUnit ,    phaseContext ,    index ,    componentConfiguration )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.AbstractComponentConfigProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entry . getInjectionTargets (  )  )     !  =    null )     {", "for    ( ResourceInjectionTargetMetaData   injectionTarget    :    entry . getInjectionTargets (  )  )     {", "final   String   injectionTargetClassName    =    injectionTarget . getInjectionTargetClass (  )  ;", "final   String   injectionTargetName    =    injectionTarget . getInjectionTargetName (  )  ;", "final   AccessibleObject   fieldOrMethod    =    InjectionUtils . getInjectionTarget ( injectionTargetClassName ,    injectionTargetName ,    classLoader ,    deploymentReflectionIndex )  ;", "final   Class <  ?  >    injectionTargetType    =     ( fieldOrMethod   instanceof   Field )     ?     (  ( Field )     ( fieldOrMethod )  )  . getType (  )     :     (  ( Method )     ( fieldOrMethod )  )  . getParameterTypes (  )  [  0  ]  ;", "final   String   memberName    =     ( fieldOrMethod   instanceof   Field )     ?     (  ( Field )     ( fieldOrMethod )  )  . getName (  )     :     (  ( Method )     ( fieldOrMethod )  )  . getName (  )  ;", "if    ( classType    !  =    null )     {", "if    (  !  ( injectionTargetType . isAssignableFrom ( classType )  )  )     {", "boolean   ok    =    false ;", "if    ( classType . isPrimitive (  )  )     {", "if    (  . BOXED _ TYPES . get ( classType )  . equals ( injectionTargetType )  )     {", "ok    =    true ;", "}", "} else", "if    ( injectionTargetType . isPrimitive (  )  )     {", "if    (  . BOXED _ TYPES . get ( injectionTargetType )  . equals ( classType )  )     {", "ok    =    true ;", "}", "}", "if    (  ! ok )     {", "throw   EeLogger . ROOT _ LOGGER . invalidInjectionTarget ( injectionTarget . getInjectionTargetName (  )  ,    injectionTarget . getInjectionTargetClass (  )  ,    classType )  ;", "}", "classType    =    injectionTargetType ;", "}", "} else    {", "classType    =    injectionTargetType ;", "}", "final   InjectionTarget   injectionTargetDescription    =     ( fieldOrMethod   instanceof   Field )     ?    new   FieldInjectionTarget ( injectionTargetClassName ,    memberName ,    classType . getName (  )  )     :    new   MethodInjectionTarget ( injectionTargetClassName ,    memberName ,    classType . getName (  )  )  ;", "final   ResourceInjectionConfiguration   injectionConfiguration    =    new   ResourceInjectionConfiguration ( injectionTargetDescription ,    injectionSource )  ;", "resourceInjectionTarget . addResourceInjection ( injectionConfiguration )  ;", "}", "}", "return   classType ;", "}", "METHOD_END"], "methodName": ["processInjectionTargets"], "fileName": "org.jboss.as.ee.component.deployers.AbstractDeploymentDescriptorBindingsProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( target   instanceof   MethodInfo )  )     {", "throw   EeLogger . ROOT _ LOGGER . methodOnlyAnnotation (  . AROUND _ INVOKE _ ANNOTATION _ NAME )  ;", "}", "final   MethodInfo   methodInfo    =    MethodInfo . class . cast ( target )  ;", "final   ClassInfo   classInfo    =    methodInfo . declaringClass (  )  ;", "final   EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "final   List < AnnotationInstance >    classAroundInvokes    =    classInfo . annotations (  )  . get (  . AROUND _ INVOKE _ ANNOTATION _ NAME )  ;", "if    (  ( classAroundInvokes . size (  )  )     >     1  )     {", "throw   EeLogger . ROOT _ LOGGER . aroundInvokeAnnotationUsedTooManyTimes ( classInfo . name (  )  ,    classAroundInvokes . size (  )  )  ;", "}", "validateArgumentType ( classInfo ,    methodInfo )  ;", "InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder ( classDescription . getInterceptorClassDescription (  )  )  ;", "builder . setAroundInvoke ( MethodIdentifier . getIdentifier ( Object . class ,    methodInfo . name (  )  ,    InvocationContext . class )  )  ;", "classDescription . setInterceptorClassDescription ( builder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["processAroundInvoke"], "fileName": "org.jboss.as.ee.component.deployers.AroundInvokeAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Type [  ]    args    =    methodInfo . args (  )  ;", "switch    ( args . length )     {", "case    0     :", "throw   new   IllegalArgumentException ( EeLogger . ROOT _ LOGGER . invalidSignature ( methodInfo . name (  )  ,     . AROUND _ INVOKE _ ANNOTATION _ NAME ,    classInfo . name (  )  ,     \" Object   methodName ( InvocationContext   ctx )  \"  )  )  ;", "case    1     :", "if    (  !  ( InvocationContext . class . getName (  )  . equals ( args [  0  ]  . name (  )  . toString (  )  )  )  )     {", "throw   new   IllegalArgumentException ( EeLogger . ROOT _ LOGGER . invalidSignature ( methodInfo . name (  )  ,     . AROUND _ INVOKE _ ANNOTATION _ NAME ,    classInfo . name (  )  ,     \" Object   methodName ( InvocationContext   ctx )  \"  )  )  ;", "}", "break ;", "default    :", "throw   new   IllegalArgumentException ( EeLogger . ROOT _ LOGGER . invalidNumberOfArguments ( methodInfo . name (  )  ,     . AROUND _ INVOKE _ ANNOTATION _ NAME ,    classInfo . name (  )  )  )  ;", "}", "if    (  !  ( methodInfo . returnType (  )  . name (  )  . toString (  )  . equals ( Object . class . getName (  )  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidReturnType ( Object . class . getName (  )  ,    methodInfo . name (  )  ,     . AROUND _ INVOKE _ ANNOTATION _ NAME ,    classInfo . name (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateArgumentType"], "fileName": "org.jboss.as.ee.component.deployers.AroundInvokeAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( Attachments . MODULE )  ;", "final   EEModuleConfiguration   moduleConfiguration    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ CONFIGURATION )  ;", "if    (  ( module    =  =    null )     |  |     ( moduleConfiguration    =  =    null )  )     {", "return ;", "}", "ComponentRegistry   componentRegistry    =    deploymentUnit . getAttachment ( Attachments . COMPONENT _ REGISTRY )  ;", "final   List < ServiceName >    dependencies    =    deploymentUnit . getAttachmentList ( JNDI _ DEPENDENCIES )  ;", "final   ServiceName   bindingDependencyService    =    JndiNamingDependencyProcessor . serviceName ( deploymentUnit . getServiceName (  )  )  ;", "for    ( final   ComponentConfiguration   configuration    :    moduleConfiguration . getComponentConfigurations (  )  )     {", "try    {", "EeLogger . ROOT _ LOGGER . tracef (  \" Installing   component    % s \"  ,    configuration . getComponentClass (  )  . getName (  )  )  ;", "deployComponent ( phaseContext ,    configuration ,    dependencies ,    bindingDependencyService )  ;", "componentRegistry . addComponent ( configuration )  ;", "deploymentUnit . addToAttachmentList ( WEB _ DEPENDENCIES ,    configuration . getComponentDescription (  )  . getStartServiceName (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   EeLogger . ROOT _ LOGGER . failedToInstallComponent ( e ,    configuration . getComponentName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.ComponentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ServiceTarget   serviceTarget    =    phaseContext . getServiceTarget (  )  ;", "final   String   applicationName    =    configuration . getApplicationName (  )  ;", "final   String   moduleName    =    configuration . getModuleName (  )  ;", "final   String   componentName    =    configuration . getComponentName (  )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   ServiceName   createServiceName    =    configuration . getComponentDescription (  )  . getCreateServiceName (  )  ;", "final   ServiceName   startServiceName    =    configuration . getComponentDescription (  )  . getStartServiceName (  )  ;", "final   BasicComponentCreateService   createService    =    configuration . getComponentCreateServiceFactory (  )  . constructService ( configuration )  ;", "final   ServiceBuilder < Component >    createBuilder    =    serviceTarget . addService ( createServiceName ,    createService )  ;", "createBuilder . addDependency ( deploymentUnit . getServiceName (  )  ,    DeploymentUnit . class ,    createService . getDeploymentUnitInjector (  )  )  ;", "final   ComponentStartService   startService    =    new   ComponentStartService (  )  ;", "final   ServiceBuilder < Component >    startBuilder    =    serviceTarget . addService ( startServiceName ,    startService )  ;", "deploymentUnit . addToAttachmentList ( DEPLOYMENT _ COMPLETE _ SERVICES ,    startServiceName )  ;", "ServiceName   jndiDepServiceName    =    configuration . getComponentDescription (  )  . getServiceName (  )  . append (  . JNDI _ BINDINGS _ SERVICE )  ;", "final   ServiceBuilder < Void >    jndiDepServiceBuilder    =    serviceTarget . addService ( jndiDepServiceName ,    NULL )  ;", "jndiDependencies . add ( jndiDepServiceName )  ;", "for    ( DependencyConfigurator   configurator    :    configuration . getCreateDependencies (  )  )     {", "configurator . configureDependency ( createBuilder ,    createService )  ;", "}", "for    ( DependencyConfigurator   configurator    :    configuration . getStartDependencies (  )  )     {", "configurator . configureDependency ( startBuilder ,    startService )  ;", "}", "startBuilder . addDependency ( createServiceName ,    BasicComponent . class ,    startService . getComponentInjector (  )  )  ;", "Services . addServerExecutorDependency ( startBuilder ,    startService . getExecutorInjector (  )  )  ;", "startBuilder . addDependency ( bindingDependencyService )  ;", "final   ServiceName   contextServiceName ;", "if    (  ( configuration . getComponentDescription (  )  . getNamingMode (  )  )     =  =     ( ComponentNamingMode . CREATE )  )     {", "final   NamingStoreService   contextService    =    new   NamingStoreService ( true )  ;", "serviceTarget . addService ( configuration . getComponentDescription (  )  . getContextServiceName (  )  ,    contextService )  . install (  )  ;", "}", "final   InjectionSource . ResolutionContext   resolutionContext    =    new   InjectionSource . ResolutionContext (  (  ( configuration . getComponentDescription (  )  . getNamingMode (  )  )     =  =     ( ComponentNamingMode . USE _ MODULE )  )  ,    configuration . getComponentName (  )  ,    configuration . getModuleName (  )  ,    configuration . getApplicationName (  )  )  ;", "for    ( ViewConfiguration   viewConfiguration    :    configuration . getViews (  )  )     {", "final   ServiceName   serviceName    =    viewConfiguration . getViewServiceName (  )  ;", "final   ViewService   viewService    =    new   ViewService ( viewConfiguration )  ;", "final   ServiceBuilder < ComponentView >    componentViewServiceBuilder    =    serviceTarget . addService ( serviceName ,    viewService )  ;", "componentViewServiceBuilder . addDependency ( createServiceName ,    Component . class ,    viewService . getComponentInjector (  )  )  ;", "for    ( final   DependencyConfigurator < ViewService >    depConfig    :    viewConfiguration . getDependencies (  )  )     {", "depConfig . configureDependency ( componentViewServiceBuilder ,    viewService )  ;", "}", "componentViewServiceBuilder . install (  )  ;", "startBuilder . addDependency ( serviceName )  ;", "for    ( BindingConfiguration   bindingConfiguration    :    viewConfiguration . getBindingConfigurations (  )  )     {", "final   String   bindingName    =    bindingConfiguration . getName (  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( applicationName ,    moduleName ,    componentName ,    bindingName )  ;", "final   BinderService   service    =    new   BinderService ( bindInfo . getBindName (  )  ,    bindingConfiguration . getSource (  )  )  ;", "jndiDepServiceBuilder . addDependency ( bindInfo . getBinderServiceName (  )  )  ;", "ServiceBuilder < ManagedReferenceFactory >    serviceBuilder    =    serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    service )  ;", "bindingConfiguration . getSource (  )  . getResourceValue ( resolutionContext ,    serviceBuilder ,    phaseContext ,    service . getManagedObjectInjector (  )  )  ;", "serviceBuilder . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    service . getNamingStoreInjector (  )  )  ;", "serviceBuilder . install (  )  ;", "}", "}", "if    (  ( configuration . getComponentDescription (  )  . getNamingMode (  )  )     =  =     ( ComponentNamingMode . CREATE )  )     {", "final   Set < ServiceName >    bound    =    new   HashSet < ServiceName >  (  )  ;", "processBindings ( phaseContext ,    configuration ,    serviceTarget ,    resolutionContext ,    configuration . getComponentDescription (  )  . getBindingConfigurations (  )  ,    jndiDepServiceBuilder ,    bound )  ;", "if    (  !  ( MetadataCompleteMarker . isMetadataComplete ( phaseContext . getDeploymentUnit (  )  )  )  )     {", "new   ClassDescriptionTraversal ( configuration . getComponentClass (  )  ,    applicationClasses )     {", "@ Override", "protected   void   handle ( final   Class <  ?  >    clazz ,    final   EEModuleClassDescription   classDescription )    throws   DeploymentUnitProcessingException    {", "if    ( classDescription    !  =    null )     {", "processBindings ( phaseContext ,    configuration ,    serviceTarget ,    resolutionContext ,    classDescription . getBindingConfigurations (  )  ,    jndiDepServiceBuilder ,    bound )  ;", "}", "}", "}  . run (  )  ;", "for    ( InterceptorDescription   interceptor    :    configuration . getComponentDescription (  )  . getAllInterceptors (  )  )     {", "final   Class <  ?  >    interceptorClass ;", "try    {", "interceptorClass    =    module . getClassLoader (  )  . loadClass ( interceptor . getInterceptorClassName (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoadInterceptor ( e ,    interceptor . getInterceptorClassName (  )  ,    configuration . getComponentClass (  )  )  ;", "}", "if    ( interceptorClass    !  =    null )     {", "new   ClassDescriptionTraversal ( interceptorClass ,    applicationClasses )     {", "@ Override", "protected   void   handle ( final   Class <  ?  >    clazz ,    final   EEModuleClassDescription   classDescription )    throws   DeploymentUnitProcessingException    {", "if    ( classDescription    !  =    null )     {", "processBindings ( phaseContext ,    configuration ,    serviceTarget ,    resolutionContext ,    classDescription . getBindingConfigurations (  )  ,    jndiDepServiceBuilder ,    bound )  ;", "}", "}", "}  . run (  )  ;", "}", "}", "}", "}", "createBuilder . install (  )  ;", "startBuilder . install (  )  ;", "jndiDepServiceBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["deployComponent"], "fileName": "org.jboss.as.ee.component.deployers.ComponentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( BindingConfiguration   bindingConfiguration    :    bindings )     {", "if    (  ( bindingConfiguration . getName (  )  . startsWith (  \" java : comp \"  )  )     |  |     (  !  ( bindingConfiguration . getName (  )  . startsWith (  \" java :  \"  )  )  )  )     {", "final   String   bindingName    =     ( bindingConfiguration . getName (  )  . startsWith (  \" java : comp \"  )  )     ?    bindingConfiguration . getName (  )     :     \" java : comp / env /  \"     +     ( bindingConfiguration . getName (  )  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( configuration . getApplicationName (  )  ,    configuration . getModuleName (  )  ,    configuration . getName (  )  ,     (  ( configuration . getDescription (  )  . getNamingMode (  )  )     =  =     ( NamingMode . CREATE )  )  ,    bindingName )  ;", "if    ( bound . contains ( bindInfo . getBinderServiceName (  )  )  )     {", "continue ;", "}", "bound . add ( bindInfo . getBinderServiceName (  )  )  ;", "try    {", "final   BinderService   service    =    new   BinderService ( bindInfo . getBindName (  )  ,    bindingConfiguration . getSource (  )  )  ;", "jndiDepServiceBuilder . addDependency ( bindInfo . getBinderServiceName (  )  )  ;", "ServiceBuilder < ManagedReferenceFactory >    serviceBuilder    =    serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    service )  ;", "bindingConfiguration . getSource (  )  . getResourceValue ( resolutionContext ,    serviceBuilder ,    phaseContext ,    service . getManagedObjectInjector (  )  )  ;", "serviceBuilder . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    service . getNamingStoreInjector (  )  )  ;", "serviceBuilder . install (  )  ;", "}    catch    ( DuplicateServiceException   e )     {", "ServiceController < ManagedReferenceFactory >    registered    =     (  ( ServiceController < ManagedReferenceFactory >  )     ( CurrentServiceContainer . getServiceContainer (  )  . getService ( bindInfo . getBinderServiceName (  )  )  )  )  ;", "if    ( registered    =  =    null )", "throw   e ;", "BinderService   service    =     (  ( BinderService )     ( registered . getService (  )  )  )  ;", "if    (  !  ( service . getSource (  )  . equals ( bindingConfiguration . getSource (  )  )  )  )", "throw   EeLogger . ROOT _ LOGGER . conflictingBinding ( bindingName ,    bindingConfiguration . getSource (  )  )  ;", "}    catch    ( CircularDependencyException   e )     {", "throw   EeLogger . ROOT _ LOGGER . circularDependency ( bindingName )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processBindings"], "fileName": "org.jboss.as.ee.component.deployers.ComponentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "this . contextService    =    contextService ;", "}", "METHOD_END"], "methodName": ["setContextService"], "fileName": "org.jboss.as.ee.component.deployers.DefaultBindingsConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "this . dataSource    =    dataSource ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.jboss.as.ee.component.deployers.DefaultBindingsConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "this . jmsConnectionFactory    =    jmsConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setJmsConnectionFactory"], "fileName": "org.jboss.as.ee.component.deployers.DefaultBindingsConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "this . managedExecutorService    =    managedExecutorService ;", "}", "METHOD_END"], "methodName": ["setManagedExecutorService"], "fileName": "org.jboss.as.ee.component.deployers.DefaultBindingsConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "this . managedScheduledExecutorService    =    managedScheduledExecutorService ;", "}", "METHOD_END"], "methodName": ["setManagedScheduledExecutorService"], "fileName": "org.jboss.as.ee.component.deployers.DefaultBindingsConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "this . managedThreadFactory    =    managedThreadFactory ;", "}", "METHOD_END"], "methodName": ["setManagedThreadFactory"], "fileName": "org.jboss.as.ee.component.deployers.DefaultBindingsConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "this . earSubDeploymentsIsolated    =    earSubDeploymentsIsolated ;", "}", "METHOD_END"], "methodName": ["setEarSubDeploymentsIsolated"], "fileName": "org.jboss.as.ee.component.deployers.DefaultEarSubDeploymentsIsolationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   RemoteEnvironment   environment    =    env . getEnvironment (  )  ;", "LifecycleCallbacksMetaData   postConstructs    =    environment . getPostConstructs (  )  ;", "if    ( postConstructs    !  =    null )     {", "for    ( LifecycleCallbackMetaData   postConstruct    :    postConstructs )     {", "String   className    =    postConstruct . getClassName (  )  ;", "if    (  ( className    =  =    null )     |  |     ( className . isEmpty (  )  )  )     {", "if    ( defaultClassName    =  =    null )     {", "continue ;", "} else    {", "className    =    defaultClassName ;", "}", "}", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "String   methodName    =    postConstruct . getMethodName (  )  ;", "MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName )  ;", "builder . setPostConstruct ( methodIdentifier )  ;", "eeModuleDescription . addInterceptorMethodOverride ( className ,    builder . build (  )  )  ;", "}", "}", "LifecycleCallbacksMetaData   preDestroys    =    environment . getPreDestroys (  )  ;", "if    ( preDestroys    !  =    null )     {", "for    ( LifecycleCallbackMetaData   preDestroy    :    preDestroys )     {", "String   className    =    preDestroy . getClassName (  )  ;", "if    (  ( className    =  =    null )     |  |     ( className . isEmpty (  )  )  )     {", "if    ( defaultClassName    =  =    null )     {", "continue ;", "} else    {", "className    =    defaultClassName ;", "}", "}", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder (  )  ;", "String   methodName    =    preDestroy . getMethodName (  )  ;", "MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName )  ;", "builder . setPreDestroy ( methodIdentifier )  ;", "eeModuleDescription . addInterceptorMethodOverride ( className ,    builder . build (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleMethods"], "fileName": "org.jboss.as.ee.component.deployers.DescriptorEnvironmentLifecycleMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ModuleSpecification   attachment    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "if    ( attachment    =  =    null )     {", "return ;", "}", "final   List < PermissionFactory >    permissions    =    attachment . getPermissionFactories (  )  ;", "final   Enumeration < Permission >    e    =     . DEFAULT _ PERMISSIONS . elements (  )  ;", "while    ( e . hasMoreElements (  )  )     {", "permissions . add ( new   ImmediatePermissionFactory ( e . nextElement (  )  )  )  ;", "}", "ResourceRoot   root    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "try    {", "File   file    =    root . getRoot (  )  . getPhysicalFile (  )  ;", "if    (  ( file    !  =    null )     &  &     ( file . isDirectory (  )  )  )     {", "FilePermission   permission    =    new   FilePermission (  (  (  ( file . getAbsolutePath (  )  )     +     ( File . separatorChar )  )     +     \"  -  \"  )  ,     \" read \"  )  ;", "permissions . add ( new   ImmediatePermissionFactory ( permission )  )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   DeploymentUnitProcessingException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.EEDefaultPermissionsProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   DeploymentReflectionIndex   reflectionIndex    =    deploymentUnit . getAttachment ( REFLECTION _ INDEX )  ;", "if    (  ( module    =  =    null )     |  |     ( moduleDescription    =  =    null )  )     {", "return ;", "}", "final   int   startupBeansCount    =    moduleDescription . getStartupBeansCount (  )  ;", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "deploymentUnit . putAttachment ( Attachments . STARTUP _ COUNTDOWN ,    new   StartupCountdown ( startupBeansCount )  )  ;", "} else    {", "final   StartupCountdown   countdown    =    deploymentUnit . getParent (  )  . getAttachment ( Attachments . STARTUP _ COUNTDOWN )  ;", "deploymentUnit . putAttachment ( Attachments . STARTUP _ COUNTDOWN ,    countdown )  ;", "countdown . countUp ( startupBeansCount )  ;", "}", "final   Set < ServiceName >    failed    =    new   HashSet < ServiceName >  (  )  ;", "final      moduleConfiguration    =    new    ( moduleDescription )  ;", "deploymentUnit . putAttachment ( Attachments . EE _ MODULE _ CONFIGURATION ,    moduleConfiguration )  ;", "final   ClassLoader   oldCl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( module . getClassLoader (  )  )  ;", "final   Iterator < ComponentDescription >    iterator    =    moduleDescription . getComponentDescriptions (  )  . iterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", "final   ComponentDescription   componentDescription    =    iterator . next (  )  ;", "EeLogger . ROOT _ LOGGER . debugf (  \" Configuring   component   class :     % s   named    % s \"  ,    componentDescription . getComponentClassName (  )  ,    componentDescription . getComponentName (  )  )  ;", "final   ComponentConfiguration   componentConfiguration ;", "try    {", "componentConfiguration    =    componentDescription . createConfiguration ( reflectionIndex . getClassIndex ( ClassLoadingUtils . loadClass ( componentDescription . getComponentClassName (  )  ,    module )  )  ,    module . getClassLoader (  )  ,    module . getModuleLoader (  )  )  ;", "for    ( final   ComponentConfigurator   componentConfigurator    :    componentDescription . getConfigurators (  )  )     {", "componentConfigurator . configure ( phaseContext ,    componentDescription ,    componentConfiguration )  ;", "}", "moduleConfiguration . addComponentConfiguration ( componentConfiguration )  ;", "}    catch    ( Throwable   e )     {", "if    ( componentDescription . isOptional (  )  )     {", "EeLogger . ROOT _ LOGGER . componentInstallationFailure ( componentDescription . getComponentName (  )  )  ;", "EeLogger . ROOT _ LOGGER . debugf ( e ,     \" Not   installing   optional   component    % s   due   to   an   exception \"  ,    componentDescription . getComponentName (  )  )  ;", "failed . add ( componentDescription . getStartServiceName (  )  )  ;", "failed . add ( componentDescription . getCreateServiceName (  )  )  ;", "failed . add ( componentDescription . getServiceName (  )  )  ;", "iterator . remove (  )  ;", "} else    {", "throw   EeLogger . ROOT _ LOGGER . cannotConfigureComponent ( e ,    componentDescription . getComponentName (  )  )  ;", "}", "}", "}", "deploymentUnit . putAttachment ( Attachments . FAILED _ COMPONENTS ,    Collections . synchronizedSet ( failed )  )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldCl )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.EEModuleConfigurationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   String   deploymentUnitName    =    deploymentUnit . getName (  )  ;", "final   String   moduleName ;", "if    (  (  (  ( deploymentUnitName . endsWith (  \"  . war \"  )  )     |  |     ( deploymentUnitName . endsWith (  \"  . jar \"  )  )  )     |  |     ( deploymentUnitName . endsWith (  \"  . ear \"  )  )  )     |  |     ( deploymentUnitName . endsWith (  \"  . rar \"  )  )  )     {", "moduleName    =    deploymentUnitName . substring (  0  ,     (  ( deploymentUnitName . length (  )  )     -     4  )  )  ;", "} else    {", "moduleName    =    deploymentUnitName ;", "}", "final   String   appName ;", "final   String   earApplicationName    =    deploymentUnit . getAttachment ( Attachments . EAR _ APPLICATION _ NAME )  ;", "if    ( earApplicationName    !  =    null )     {", "appName    =    earApplicationName ;", "} else    {", "appName    =    null ;", "}", "deploymentUnit . putAttachment ( Attachments . EE _ MODULE _ DESCRIPTION ,    new   Description ( appName ,    moduleName ,    earApplicationName ,    appClient )  )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.EEModuleInitialProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   List < DeploymentUnit >    subDeployments    =    deploymentUnit . getAttachmentList ( SUB _ DEPLOYMENTS )  ;", "final   Set < String >    moduleNames    =    new   HashSet < String >  (  )  ;", "final   Set < String >    moduleConflicts    =    new   HashSet < String >  (  )  ;", "for    ( DeploymentUnit   deployment    :    subDeployments )     {", "final   EEModuleDescription   module    =    deployment . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "if    ( module    !  =    null )     {", "if    ( moduleNames . contains ( module . get (  )  )  )     {", "moduleConflicts . add ( module . get (  )  )  ;", "}", "moduleNames . add ( module . get (  )  )  ;", "}", "}", "for    ( DeploymentUnit   deployment    :    subDeployments )     {", "final   EEModuleDescription   module    =    deployment . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "if    ( module    !  =    null )     {", "if    ( moduleConflicts . contains ( module . get (  )  )  )     {", "module . set ( deployment . getName (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.EEModuleNameProcessor"}, {"methodBody": ["METHOD_START", "{", "return   resourceReferenceProcessors . get ( resourceReferenceType )  ;", "}", "METHOD_END"], "methodName": ["getResourceReferenceProcessor"], "fileName": "org.jboss.as.ee.component.deployers.EEResourceReferenceProcessorRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( resourceReferenceProcessor    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullResourceReference (  )  ;", "}", "final   String   resourceReferenceType    =    resourceReferenceProcessor . getResourceReferenceType (  )  ;", "if    (  ( resourceReferenceType    =  =    null )     |  |     ( resourceReferenceType . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . nullOrEmptyResourceReferenceType (  )  ;", "}", "resourceReferenceProcessors . put ( resourceReferenceType ,    resourceReferenceProcessor )  ;", "}", "METHOD_END"], "methodName": ["registerResourceReferenceProcessor"], "fileName": "org.jboss.as.ee.component.deployers.EEResourceReferenceProcessorRegistry"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   parentDU    =    deploymentUnit . getParent (  )  ;", "if    ( parentDU    =  =    null )     {", "final   EarMetaData   earMetaData    =    deploymentUnit . getAttachment ( Attachments . EAR _ METADATA )  ;", "if    ( earMetaData    !  =    null )     {", "final   String   overriddenAppName    =    earMetaData . get (  )  ;", "if    ( overriddenAppName    =  =    null )     {", "return   this . getEarName ( deploymentUnit )  ;", "}", "return   overriddenAppName ;", "} else    {", "return   this . getEarName ( deploymentUnit )  ;", "}", "}", "return   this . get ( parentDU )  ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.jboss.as.ee.component.deployers.EarApplicationNameProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   duName    =    deploymentUnit . getName (  )  ;", "if    ( duName . endsWith (  \"  . ear \"  )  )     {", "return   duName . substring (  0  ,     (  ( duName . length (  )  )     -     (  \"  . ear \"  . length (  )  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getEarName"], "fileName": "org.jboss.as.ee.component.deployers.EarApplicationNameProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < Class >    heirachy    =    new   ArrayList < Class >  (  )  ;", "Class   c    =    componentClass ;", "while    (  ( c    !  =     ( Object . class )  )     &  &     ( c    !  =    null )  )     {", "heirachy . add ( c )  ;", "c    =    c . getSuperclass (  )  ;", "}", "Collections . reverse ( heirachy )  ;", "final   RuntimeAnnotationInformation < Boolean >    excludeDefaults    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    ExcludeDefaults . class )  ;", "if    ( excludeDefaults . getClassAnnotations (  )  . containsKey ( componentClass . getName (  )  )  )     {", "description . setExcludeDefaults ( true )  ;", "}", "for    ( final   Map . Entry < Method ,    List < Boolean >  >    entry    :    excludeDefaults . getMethodAnnotations (  )  . entrySet (  )  )     {", "description . excludeDefaults ( MethodIdentifier . getIdentifierForMethod ( entry . getKey (  )  )  )  ;", "}", "final   RuntimeAnnotationInformation < Boolean >    excludeClasss    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    ExcludeClasss . class )  ;", "for    ( final   Map . Entry < Method ,    List < Boolean >  >    entry    :    excludeClasss . getMethodAnnotations (  )  . entrySet (  )  )     {", "description . excludeClasss ( MethodIdentifier . getIdentifierForMethod ( entry . getKey (  )  )  )  ;", "}", "final   RuntimeAnnotationInformation < String [  ]  >    interceptors    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    deploymentReflectionIndex ,    s . class )  ;", "for    ( final   Class <  ?  >    clazz    :    heirachy )     {", "final   List < String [  ]  >    classs    =    interceptors . getClassAnnotations (  )  . get ( clazz . getName (  )  )  ;", "if    ( classs    !  =    null )     {", "for    ( final   String   interceptor    :    classs . get (  0  )  )     {", "description . addClass ( new   Description ( interceptor )  )  ;", "}", "}", "}", "for    ( final   Map . Entry < Method ,    List < String [  ]  >  >    entry    :    interceptors . getMethodAnnotations (  )  . entrySet (  )  )     {", "final   MethodIdentifier   method    =    MethodIdentifier . getIdentifierForMethod ( entry . getKey (  )  )  ;", "for    ( final   String   interceptor    :    entry . getValue (  )  . get (  0  )  )     {", "description . addMethod ( method ,    new   Description ( interceptor )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleAnnotations"], "fileName": "org.jboss.as.ee.component.deployers.InterceptorAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    componentClass ;", "try    {", "componentClass    =    ClassLoadingUtils . loadClass ( description . getComponentClassName (  )  ,    deploymentUnit )  ;", "}    catch    ( Throwable   e )     {", "return ;", "}", "handles ( applicationClasses ,    deploymentReflectionIndex ,    componentClass ,    description )  ;", "}", "METHOD_END"], "methodName": ["processComponentConfig"], "fileName": "org.jboss.as.ee.component.deployers.InterceptorAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "for    ( DotName   annotationName    :     . LIFE _ CYCLE _ ANNOTATIONS )     {", "final   List < AnnotationInstance >    lifecycles    =    index . getAnnotations ( annotationName )  ;", "for    ( AnnotationInstance   annotation    :    lifecycles )     {", "processLifeCycle ( eeModuleDescription ,    annotation . target (  )  ,    annotationName ,    applicationClasses )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.LifecycleAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     =  =     0  )     {", "return   MethodIdentifier . getIdentifier ( Void . TYPE ,    methodInfo . name (  )  )  ;", "} else    {", "return   MethodIdentifier . getIdentifier ( methodInfo . returnType (  )  . name (  )  . toString (  )  ,    methodInfo . name (  )  ,    InvocContext . class . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMethodIdentifier"], "fileName": "org.jboss.as.ee.component.deployers.LifecycleAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( target   instanceof   MethodInfo )  )     {", "throw   EeLogger . ROOT _ LOGGER . methodOnlyAnnotation ( annotationType )  ;", "}", "final   MethodInfo   methodInfo    =    MethodInfo . class . cast ( target )  ;", "final   ClassInfo   classInfo    =    methodInfo . declaringClass (  )  ;", "final   EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "final   Type [  ]    args    =    methodInfo . args (  )  ;", "if    (  ( args . length )     >     1  )     {", "EeLogger . ROOT _ LOGGER . warn ( EeLogger . ROOT _ LOGGER . invalidNumberOfArguments ( methodInfo . name (  )  ,    annotationType ,    classInfo . name (  )  )  )  ;", "return ;", "} else", "if    (  (  ( args . length )     =  =     1  )     &  &     (  !  ( args [  0  ]  . name (  )  . toString (  )  . equals ( getName (  )  )  )  )  )     {", "EeLogger . ROOT _ LOGGER . warn ( EeLogger . ROOT _ LOGGER . invalidSignature ( methodInfo . name (  )  ,    annotationType ,    classInfo . name (  )  ,     \" void   methodName ( InvocationContext   ctx )  \"  )  )  ;", "return ;", "}", "final   InterceptorClassDescription . Builder   builder    =    InterceptorClassDescription . builder ( classDescription . getInterceptorClassDescription (  )  )  ;", "if    ( annotationType    =  =     (  . POST _ CONSTRUCT _ ANNOTATION )  )     {", "builder . setPostConstruct ( getMethodIdentifier ( args ,    methodInfo )  )  ;", "} else", "if    ( annotationType    =  =     (  . PRE _ DESTROY _ ANNOTATION )  )     {", "builder . setPreDestroy ( getMethodIdentifier ( args ,    methodInfo )  )  ;", "} else", "if    ( annotationType    =  =     (  . AROUND _ CONSTRUCT _ ANNOTATION )  )     {", "builder . setAroundConstruct ( getMethodIdentifier ( args ,    methodInfo )  )  ;", "}", "classDescription . setInterceptorClassDescription ( builder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["processLifeCycle"], "fileName": "org.jboss.as.ee.component.deployers.LifecycleAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( a    =  =    b )     |  |     (  ( a    !  =    null )     &  &     ( a . equals ( b )  )  )  ;", "}", "METHOD_END"], "methodName": ["eq"], "fileName": "org.jboss.as.ee.component.deployers.MessageDestinationInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  !  ( o   instanceof    )  )", "return   false ;", "if    (  ( error )     !  =    null )     {", "throw   new   RuntimeException ( error )  ;", "}", "if    (  ( resolvedLookupName )     =  =    null )     {", "throw   new   RuntimeException (  \" Error   equals (  )    cannot   be   called   before   resolve (  )  \"  )  ;", "}", "final      other    =     (  (  )     ( o )  )  ;", "return    . eq ( resolvedLookupName ,    other . resolvedLookupName )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.deployers.MessageDestinationInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( error )     !  =    null )     {", "throw   new   DeploymentUnitProcessingException ( error )  ;", "}", "final   String   applicationName    =    resolutionContext . getApplicationName (  )  ;", "final   String   moduleName    =    resolutionContext . getModuleName (  )  ;", "final   String   Name    =    resolutionContext . getComponentName (  )  ;", "final   boolean   compUsesModule    =    resolutionContext . isCompUsesModule (  )  ;", "final   String   lookupName ;", "if    (  !  ( this . resolvedLookupName . contains (  \"  :  \"  )  )  )     {", "if    (  ( Name    !  =    null )     &  &     (  ! compUsesModule )  )     {", "lookupName    =     \" java : comp / env /  \"     +     ( this . resolvedLookupName )  ;", "} else", "if    ( compUsesModule )     {", "lookupName    =     \" java : module / env /  \"     +     ( this . resolvedLookupName )  ;", "} else    {", "lookupName    =     \" java : jboss / env \"     +     ( this . resolvedLookupName )  ;", "}", "} else", "if    (  ( this . resolvedLookupName . startsWith (  \" java : comp /  \"  )  )     &  &    compUsesModule )     {", "lookupName    =     \" java : module /  \"     +     ( this . resolvedLookupName . substring (  1  0  )  )  ;", "} else    {", "lookupName    =    this . resolvedLookupName ;", "}", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( applicationName ,    moduleName ,    Name ,    lookupName )  ;", "if    ( lookupName . startsWith (  \" java :  \"  )  )     {", "serviceBuilder . addDependency ( bindInfo . getBinderServiceName (  )  ,    ManagedReferenceFactory . class ,    injector )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.ee.component.deployers.MessageDestinationInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   messageDestinationName . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.jboss.as.ee.component.deployers.MessageDestinationInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEApplicationDescription   applicationDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ DESCRIPTION )  ;", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   Set < String >    names    =    applicationDescription . resolve ( messageDestinationName ,    deploymentRoot . getRoot (  )  )  ;", "if    ( names . isEmpty (  )  )     {", "error    =    EeLogger . ROOT _ LOGGER . no ( messageDestinationName ,    bindingName )  ;", "return ;", "}", "if    (  ( names . size (  )  )     >     1  )     {", "error    =    EeLogger . ROOT _ LOGGER . moreThanOne ( messageDestinationName ,    bindingName ,    names )  ;", "return ;", "}", "resolvedLookupName    =    names . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.jboss.as.ee.component.deployers.MessageDestinationInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   String   bindingName    =     ( bindingConfiguration . getName (  )  . startsWith (  \" java :  \"  )  )     ?    bindingConfiguration . getName (  )     :     \" java : module / env /  \"     +     ( bindingConfiguration . getName (  )  )  ;", "InjectionSource . ResolutionContext   resolutionContext    =    new   InjectionSource . ResolutionContext ( true ,    module . getModuleName (  )  ,    module . getModuleName (  )  ,    module . getApplicationName (  )  )  ;", "if    ( bindingName    !  =    null )     {", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( module . getApplicationName (  )  ,    module . getModuleName (  )  ,    module . getModuleName (  )  ,    false ,    bindingName )  ;", "dependencies . add ( bindInfo . getBinderServiceName (  )  )  ;", "if    (  (  ( bindingName . startsWith (  \" java : comp \"  )  )     |  |     ( bindingName . startsWith (  \" java : module \"  )  )  )     |  |     ( bindingName . startsWith (  \" java : app \"  )  )  )     {", "try    {", "final   BinderService   service    =    new   BinderService ( bindInfo . getBindName (  )  ,    bindingConfiguration . getSource (  )  )  ;", "ServiceBuilder < ManagedReferenceFactory >    serviceBuilder    =    phaseContext . getServiceTarget (  )  . addService ( bindInfo . getBinderServiceName (  )  ,    service )  ;", "bindingConfiguration . getSource (  )  . getResourceValue ( resolutionContext ,    serviceBuilder ,    phaseContext ,    service . getManagedObjectInjector (  )  )  ;", "serviceBuilder . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    service . getNamingStoreInjector (  )  )  ;", "serviceBuilder . install (  )  ;", "}    catch    ( DuplicateServiceException   e )     {", "ServiceController < ManagedReferenceFactory >    registered    =     (  ( ServiceController < ManagedReferenceFactory >  )     ( CurrentServiceContainer . getServiceContainer (  )  . getService ( bindInfo . getBinderServiceName (  )  )  )  )  ;", "if    ( registered    =  =    null )", "throw   e ;", "BinderService   service    =     (  ( BinderService )     ( registered . getService (  )  )  )  ;", "if    (  !  ( service . getSource (  )  . equals ( bindingConfiguration . getSource (  )  )  )  )", "throw   EeLogger . ROOT _ LOGGER . conflictingBinding ( bindingName ,    bindingConfiguration . getSource (  )  )  ;", "}    catch    ( CircularDependencyException   e )     {", "throw   EeLogger . ROOT _ LOGGER . circularDependency ( bindingName )  ;", "}", "} else    {", "BinderService   service ;", "ServiceController < ManagedReferenceFactory >    controller ;", "try    {", "service    =    new   BinderService ( bindInfo . getBindName (  )  ,    bindingConfiguration . getSource (  )  ,    true )  ;", "ServiceTarget   externalServiceTarget    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( EXTERNAL _ SERVICE _ TARGET )  ;", "ServiceBuilder < ManagedReferenceFactory >    serviceBuilder    =    externalServiceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    service )  ;", "bindingConfiguration . getSource (  )  . getResourceValue ( resolutionContext ,    serviceBuilder ,    phaseContext ,    service . getManagedObjectInjector (  )  )  ;", "serviceBuilder . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    service . getNamingStoreInjector (  )  )  ;", "controller    =    serviceBuilder . install (  )  ;", "}    catch    ( DuplicateServiceException   e )     {", "controller    =     (  ( ServiceController < ManagedReferenceFactory >  )     ( CurrentServiceContainer . getServiceContainer (  )  . getService ( bindInfo . getBinderServiceName (  )  )  )  )  ;", "if    ( controller    =  =    null )", "throw   e ;", "service    =     (  ( BinderService )     ( controller . getService (  )  )  )  ;", "if    (  !  (  . equals ( service . getSource (  )  ,    bindingConfiguration . getSource (  )  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . conflictingBinding ( bindingName ,    bindingConfiguration . getSource (  )  )  ;", "}", "}", "try    {", "phaseContext . getServiceTarget (  )  . addService ( phaseContext . getDeploymentUnit (  )  . getServiceName (  )  . append (  \" sharedBindingReleaseService \"  )  . append ( bindInfo . getBinderServiceName (  )  )  ,    new    . BinderReleaseService ( controller ,    service )  )  . install (  )  ;", "service . acquire (  )  ;", "}    catch    ( DuplicateServiceException   ignore )     {", "}", "}", "} else    {", "throw   EeLogger . ROOT _ LOGGER . nullBindingName ( bindingConfiguration )  ;", "}", "}", "METHOD_END"], "methodName": ["addJndiBinding"], "fileName": "org.jboss.as.ee.component.deployers.ModuleJndiBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   EEModuleConfiguration   moduleConfiguration    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ CONFIGURATION )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "if    ( moduleConfiguration    =  =    null )     {", "return ;", "}", "final   List < ServiceName >    dependencies    =    deploymentUnit . getAttachmentList ( JNDI _ DEPENDENCIES )  ;", "final   Map < ServiceName ,    BindingConfiguration >    deploymentDescriptorBindings    =    new   HashMap < ServiceName ,    BindingConfiguration >  (  )  ;", "final   List < BindingConfiguration >    bindingConfigurations    =    eeModuleDescription . getBindingConfigurations (  )  ;", "if    (  !  ( DeploymentTypeMarker . isType ( DeploymentType . EAR ,    deploymentUnit )  )  )     {", "bindingConfigurations . add ( new   BindingConfiguration (  \" java : module / env \"  ,    new   ContextInjectionSource (  \" env \"  ,     \" java : module / env \"  )  )  )  ;", "}", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "bindingConfigurations . add ( new   BindingConfiguration (  \" java : app / env \"  ,    new   ContextInjectionSource (  \" env \"  ,     \" java : app / env \"  )  )  )  ;", "}", "for    ( BindingConfiguration   binding    :    bindingConfigurations )     {", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( moduleConfiguration . getApplicationName (  )  ,    moduleConfiguration . getModuleName (  )  ,    null ,    false ,    binding . getName (  )  )  ;", "deploymentDescriptorBindings . put ( bindInfo . getBinderServiceName (  )  ,    binding )  ;", "add ( moduleConfiguration ,    binding ,    phaseContext ,    dependencies )  ;", "}", "for    ( final   ComponentConfiguration   componentConfiguration    :    moduleConfiguration . getComponentConfigurations (  )  )     {", "for    ( BindingConfiguration   binding    :    componentConfiguration . getComponentDescription (  )  . getBindingConfigurations (  )  )     {", "final   String   bindingName    =    binding . getName (  )  ;", "final   boolean   compBinding    =     ( bindingName . startsWith (  \" java : comp \"  )  )     |  |     (  !  ( bindingName . startsWith (  \" java :  \"  )  )  )  ;", "if    (  (  ( componentConfiguration . getComponentDescription (  )  . getNamingMode (  )  )     =  =     ( ComponentNamingMode . CREATE )  )     &  &    compBinding )     {", "continue ;", "}", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( moduleConfiguration . getApplicationName (  )  ,    moduleConfiguration . getModuleName (  )  ,    null ,    false ,    binding . getName (  )  )  ;", "deploymentDescriptorBindings . put ( bindInfo . getBinderServiceName (  )  ,    binding )  ;", "add ( moduleConfiguration ,    binding ,    phaseContext ,    dependencies )  ;", "}", "}", "final   Set < String >    handledClasses    =    new   HashSet < String >  (  )  ;", "for    ( final   ComponentConfiguration   componentConfiguration    :    moduleConfiguration . getComponentConfigurations (  )  )     {", "final   Set < Class <  ?  >  >    classConfigurations    =    new   HashSet < Class <  ?  >  >  (  )  ;", "classConfigurations . add ( componentConfiguration . getComponentClass (  )  )  ;", "for    ( final   InterceptorDescription   interceptor    :    componentConfiguration . getComponentDescription (  )  . getAllInterceptors (  )  )     {", "try    {", "classConfigurations . add ( ClassLoadingUtils . loadClass ( interceptor . getInterceptorClassName (  )  ,    module )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoadInterceptor ( e ,    interceptor . getInterceptorClassName (  )  ,    componentConfiguration . getComponentClass (  )  )  ;", "}", "}", "processClassConfigurations ( phaseContext ,    applicationClasses ,    moduleConfiguration ,    deploymentDescriptorBindings ,    handledClasses ,    componentConfiguration . getComponentDescription (  )  . getNamingMode (  )  ,    classConfigurations ,    componentConfiguration . getComponentName (  )  ,    dependencies )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.ModuleJndiBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( one    =  =    two )     |  |     (  ( one    !  =    null )     &  &     ( one . equals ( two )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.jboss.as.ee.component.deployers.ModuleJndiBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Class <  ?  >    clazz    :    classes )     {", "new   ClassDescriptionTraversal ( clazz ,    applicationClasses )     {", "@ Override", "protected   void   handle ( final   Class <  ?  >    currentClass ,    final   EEModuleClassDescription   classDescription )    throws   DeploymentUnitProcessingException    {", "if    ( classDescription    =  =    null )     {", "return ;", "}", "if    ( classDescription . isInvalid (  )  )     {", "throw   EeLogger . ROOT _ LOGGER . componentClassHasErrors ( classDescription . getClassName (  )  ,    componentName ,    classDescription . getInvalidMessage (  )  )  ;", "}", "if    ( handledClasses . contains ( classDescription . getClassName (  )  )  )     {", "return ;", "}", "handledClasses . add ( classDescription . getClassName (  )  )  ;", "if    (  !  ( MetadataCompleteMarker . isMetadataComplete ( phaseContext . getDeploymentUnit (  )  )  )  )     {", "final   Set < BindingConfiguration >    classLevelBindings    =    new   HashSet < BindingConfiguration >  ( classDescription . getBindingConfigurations (  )  )  ;", "for    ( BindingConfiguration   binding    :    classLevelBindings )     {", "final   String   bindingName    =    binding . getName (  )  ;", "final   boolean   compBinding    =     ( bindingName . startsWith (  \" java : comp \"  )  )     |  |     (  !  ( bindingName . startsWith (  \" java :  \"  )  )  )  ;", "if    (  ( namingMode    =  =     ( ComponentNamingMode . CREATE )  )     &  &    compBinding )     {", "continue ;", "}", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( moduleConfiguration . getApplicationName (  )  ,    moduleConfiguration . getModuleName (  )  ,    null ,    false ,    binding . getName (  )  )  ;", "EeLogger . ROOT _ LOGGER . tracef (  \" Binding    % s   using   service    % s \"  ,    binding . getName (  )  ,    bindInfo . getBinderServiceName (  )  )  ;", "if    ( deploymentDescriptorBindings . containsKey ( bindInfo . getBinderServiceName (  )  )  )     {", "continue ;", "}", "add ( moduleConfiguration ,    binding ,    phaseContext ,    dependencies )  ;", "}", "}", "}", "}  . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processClassConfigurations"], "fileName": "org.jboss.as.ee.component.deployers.ModuleJndiBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "final   EEApplicationClasses   applicationClasses    =    deploymentUnit . getAttachment ( Attachments . EE _ APPLICATION _ CLASSES _ DESCRIPTION )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   PropertyReplacer   replacer    =    EJBAnnotationPropertyReplacement . propertyReplacer ( deploymentUnit )  ;", "if    ( module    =  =    null )     {", "return ;", "}", "final   List < AnnotationInstance >    resourceAnnotations    =    index . getAnnotations (  . RESOURCE _ ANNOTATION _ NAME )  ;", "for    ( AnnotationInstance   annotation    :    resourceAnnotations )     {", "final   AnnotationTarget   annotationTarget    =    annotation . target (  )  ;", "final   AnnotationValue   nameValue    =    annotation . value (  \" name \"  )  ;", "final   String   name    =     ( nameValue    !  =    null )     ?    replacer . replaceProperties ( nameValue . asString (  )  )     :    null ;", "final   AnnotationValue   typeValue    =    annotation . value (  \" type \"  )  ;", "final   String   type    =     ( typeValue    !  =    null )     ?    typeValue . asClass (  )  . name (  )  . toString (  )     :    null ;", "if    ( annotationTarget   instanceof   FieldInfo )     {", "final   FieldInfo   fieldInfo    =     (  ( FieldInfo )     ( annotationTarget )  )  ;", "final   ClassInfo   classInfo    =    fieldInfo . declaringClass (  )  ;", "EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "processFieldResource ( phaseContext ,    fieldInfo ,    name ,    type ,    classDescription ,    annotation ,    eeModuleDescription ,    module ,    applicationClasses ,    replacer )  ;", "} else", "if    ( annotationTarget   instanceof   MethodInfo )     {", "final   MethodInfo   methodInfo    =     (  ( MethodInfo )     ( annotationTarget )  )  ;", "ClassInfo   classInfo    =    methodInfo . declaringClass (  )  ;", "EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "processMethodResource ( phaseContext ,    methodInfo ,    name ,    type ,    classDescription ,    annotation ,    eeModuleDescription ,    module ,    applicationClasses ,    replacer )  ;", "} else", "if    ( annotationTarget   instanceof   ClassInfo )     {", "final   ClassInfo   classInfo    =     (  ( ClassInfo )     ( annotationTarget )  )  ;", "EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "processClassResource ( phaseContext ,    name ,    type ,    classDescription ,    annotation ,    eeModuleDescription ,    module ,    applicationClasses ,    replacer )  ;", "}", "}", "final   List < AnnotationInstance >    resourcesAnnotations    =    index . getAnnotations (  . RESOURCES _ ANNOTATION _ NAME )  ;", "for    ( AnnotationInstance   outerAnnotation    :    resourcesAnnotations )     {", "final   AnnotationTarget   annotationTarget    =    outerAnnotation . target (  )  ;", "if    ( annotationTarget   instanceof   ClassInfo )     {", "final   ClassInfo   classInfo    =     (  ( ClassInfo )     ( annotationTarget )  )  ;", "final   AnnotationInstance [  ]    values    =    outerAnnotation . value (  \" value \"  )  . asNestedArray (  )  ;", "for    ( AnnotationInstance   annotation    :    values )     {", "final   AnnotationValue   nameValue    =    annotation . value (  \" name \"  )  ;", "final   String   name    =     ( nameValue    !  =    null )     ?    replacer . replaceProperties ( nameValue . asString (  )  )     :    null ;", "final   AnnotationValue   typeValue    =    annotation . value (  \" type \"  )  ;", "final   String   type    =     ( typeValue    !  =    null )     ?    typeValue . asClass (  )  . name (  )  . toString (  )     :    null ;", "EEModuleClassDescription   classDescription    =    eeModuleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  ;", "processClassResource ( phaseContext ,    name ,    type ,    classDescription ,    annotation ,    eeModuleDescription ,    module ,    applicationClasses ,    replacer )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.component.deployers.ResourceInjectionAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( string    =  =    null )     |  |     ( string . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.ee.component.deployers.ResourceInjectionAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( ResourceInjectionAnnotationParsingProcessor . SIMPLE _ ENTRIES . contains ( type )  )     {", "return   true ;", "}", "try    {", "return   module . getClassLoader (  )  . loadClass ( type )  . isEnum (  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isEnvEntryType"], "fileName": "org.jboss.as.ee.component.deployers.ResourceInjectionAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   EEResourceReferenceProcessorRegistry   registry    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( Attachments . RESOURCE _ REFERENCE _ PROCESSOR _ REGISTRY )  ;", "final   AnnotationValue   lookupAnnotation    =    annotation . value (  \" lookup \"  )  ;", "String   lookup    =     ( lookupAnnotation    =  =    null )     ?    null    :    replacer . replaceProperties ( lookupAnnotation . asString (  )  )  ;", "if    ( isEmpty ( lookup )  )     {", "final   AnnotationValue   mappedNameAnnotationValue    =    annotation . value (  \" mappedName \"  )  ;", "lookup    =     ( mappedNameAnnotationValue    =  =    null )     ?    null    :    replacer . replaceProperties ( mappedNameAnnotationValue . asString (  )  )  ;", "}", "if    (  ( isEmpty ( lookup )  )     &  &     (  . FIXED _ LOCATIONS . containsKey ( injectionType )  )  )     {", "lookup    =     . FIXED _ LOCATIONS . get ( injectionType )  ;", "}", "InjectionSource   valueSource    =    null ;", "final   boolean   isEnvEntryType    =    this . isEnvEntryType ( injectionType ,    module )  ;", "if    (  !  ( isEmpty ( lookup )  )  )     {", "valueSource    =    new   LookupInjectionSource ( lookup ,     . JAVAX _ NAMING _ CONTEXT . equals ( injectionType )  )  ;", "} else", "if    ( isEnvEntryType )     {", "} else    {", "final   EEResourceReferenceProcessor   resourceReferenceProcessor    =    registry . getResourceReferenceProcessor ( injectionType )  ;", "if    ( resourceReferenceProcessor    !  =    null )     {", "valueSource    =    resourceReferenceProcessor . getResourceReferenceBindingSource (  )  ;", "}", "}", "if    ( valueSource    =  =    null )     {", "if    ( targetDescription    !  =    null )     {", "final   LookupInjectionSource   optionalInjection    =    new   LookupInjectionSource ( localContextName ,    true )  ;", "final   ResourceInjectionConfiguration   injectionConfiguration    =    new   ResourceInjectionConfiguration ( targetDescription ,    optionalInjection ,    true )  ;", "classDescription . addResourceInjection ( injectionConfiguration )  ;", "}", "} else    {", "final   InjectionSource   injectionSource    =    new   LookupInjectionSource ( localContextName )  ;", "final   ResourceInjectionConfiguration   injectionConfiguration    =     ( targetDescription    !  =    null )     ?    new   ResourceInjectionConfiguration ( targetDescription ,    injectionSource )     :    null ;", "final   BindingConfiguration   bindingConfiguration    =    new   BindingConfiguration ( localContextName ,    valueSource )  ;", "classDescription . getBindingConfigurations (  )  . add ( bindingConfiguration )  ;", "if    ( injectionConfiguration    !  =    null )     {", "classDescription . addResourceInjection ( injectionConfiguration )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.jboss.as.ee.component.deployers.ResourceInjectionAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( isEmpty ( name )  )     {", "throw   EeLogger . ROOT _ LOGGER . aAttributeMissing (  \"  @ Resource \"  ,     \" name \"  )  ;", "}", "final   String   realType ;", "if    ( isEmpty ( type )  )     {", "realType    =    Object . class . getName (  )  ;", "} else    {", "realType    =    type ;", "}", "process ( phaseContext ,    classDescription ,    a ,    realType ,    name ,    null ,    eeModuleDescription ,    module ,    applicationClasses ,    replacer )  ;", "}", "METHOD_END"], "methodName": ["processClassResource"], "fileName": "org.jboss.as.ee.component.deployers.ResourceInjectionAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   fieldName    =    fieldInfo . name (  )  ;", "final   String   injectionType    =     (  ( isEmpty ( type )  )     |  |     ( type . equals ( Object . class . getName (  )  )  )  )     ?    fieldInfo . type (  )  . name (  )  . toString (  )     :    type ;", "final   String   localContextName    =     ( isEmpty ( name )  )     ?     (  ( fieldInfo . declaringClass (  )  . name (  )  . toString (  )  )     +     \"  /  \"  )     +    fieldName    :    name ;", "final   Target   targetDescription    =    new   FieldTarget ( fieldInfo . declaringClass (  )  . name (  )  . toString (  )  ,    fieldName ,    fieldInfo . type (  )  . name (  )  . toString (  )  )  ;", "process ( phaseContext ,    classDescription ,    annotation ,    injectionType ,    localContextName ,    targetDescription ,    eeModuleDescription ,    module ,    applicationClasses ,    replacer )  ;", "}", "METHOD_END"], "methodName": ["processFieldResource"], "fileName": "org.jboss.as.ee.component.deployers.ResourceInjectionAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   methodName    =    methodInfo . name (  )  ;", "if    (  (  !  ( methodName . startsWith (  \" set \"  )  )  )     |  |     (  ( methodInfo . args (  )  . length )     !  =     1  )  )     {", "throw   EeLogger . ROOT _ LOGGER . setterMethodOnly (  \"  @ Resource \"  ,    methodInfo )  ;", "}", "final   String   contextNameSuffix    =     ( methodName . substring (  3  ,     4  )  . toLowerCase ( Locale . ENGLISH )  )     +     ( methodName . substring (  4  )  )  ;", "final   String   localContextName    =     ( isEmpty ( name )  )     ?     (  ( methodInfo . declaringClass (  )  . name (  )  . toString (  )  )     +     \"  /  \"  )     +    contextNameSuffix    :    name ;", "final   String   injectionType    =     (  ( isEmpty ( type )  )     |  |     ( type . equals ( Object . class . getName (  )  )  )  )     ?    methodInfo . args (  )  [  0  ]  . name (  )  . toString (  )     :    type ;", "final   Target   targetDescription    =    new   MethodTarget ( methodInfo . declaringClass (  )  . name (  )  . toString (  )  ,    methodName ,    methodInfo . args (  )  [  0  ]  . name (  )  . toString (  )  )  ;", "process ( phaseContext ,    classDescription ,    annotation ,    injectionType ,    localContextName ,    targetDescription ,    eeModuleDescription ,    module ,    applicationClasses ,    replacer )  ;", "}", "METHOD_END"], "methodName": ["processMethodResource"], "fileName": "org.jboss.as.ee.component.deployers.ResourceInjectionAnnotationParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < BindingConfiguration >    bindings    =    new   ArrayList < BindingConfiguration >  (  )  ;", "final   EnvironmentEntriesMetaData   envEntries    =    environment . getEnvironment (  )  . getEnvironmentEntries (  )  ;", "if    ( envEntries    =  =    null )     {", "return   bindings ;", "}", "for    ( final   EnvironmentEntryMetaData   envEntry    :    envEntries )     {", "final   String   name ;", "if    ( envEntry . getName (  )  . startsWith (  \" java :  \"  )  )     {", "name    =    envEntry . getName (  )  ;", "} else    {", "name    =     ( environment . getDefaultContext (  )  )     +     ( envEntry . getEnvEntryName (  )  )  ;", "}", "Class <  ?  >    classType    =    null ;", "if    (  ( envEntry . getType (  )  )     !  =    null )     {", "try    {", "classType    =    this . loadClass ( envEntry . getType (  )  ,    classLoader )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoad ( e ,    envEntry . getType (  )  )  ;", "}", "}", "final   String   value    =    envEntry . getValue (  )  ;", "final   String   lookup    =    envEntry . getLookupName (  )  ;", "if    (  (  !  ( isEmpty ( value )  )  )     &  &     (  !  ( isEmpty ( lookup )  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . cannotSpecifyBoth (  \"  < env - entry - value >  \"  ,     \"  < lookup - name >  \"  )  ;", "} else", "if    (  ( isEmpty ( lookup )  )     &  &     ( isEmpty ( value )  )  )     {", "continue ;", "}", "LookupInjectionSource   injectionSource    =    new   LookupInjectionSource ( name )  ;", "classType    =    processInjectionTargets ( resourceInjectionTarget ,    injectionSource ,    classLoader ,    deploymentReflectionIndex ,    envEntry ,    classType )  ;", "if    ( classType    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . cannotDetermineType (  \"  < env - entry >  \"  ,    name ,     \"  < env - entry - type >  \"  )  ;", "}", "final   String   type    =    classType . getName (  )  ;", "final   BindingConfiguration   bindingConfiguration ;", "if    (  !  ( isEmpty ( lookup )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   LookupInjectionSource ( lookup )  )  ;", "} else", "if    ( type . equals ( String . class . getName (  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( value )  )  ;", "} else", "if    (  ( type . equals ( Integer . class . getName (  )  )  )     |  |     ( type . equals (  \" int \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Integer . valueOf ( value )  )  )  ;", "} else", "if    (  ( type . equals ( Short . class . getName (  )  )  )     |  |     ( type . equals (  \" short \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Short . valueOf ( value )  )  )  ;", "} else", "if    (  ( type . equals ( Long . class . getName (  )  )  )     |  |     ( type . equals (  \" long \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Long . valueOf ( value )  )  )  ;", "} else", "if    (  ( type . equals ( Byte . class . getName (  )  )  )     |  |     ( type . equals (  \" byte \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Byte . valueOf ( value )  )  )  ;", "} else", "if    (  ( type . equals ( Double . class . getName (  )  )  )     |  |     ( type . equals (  \" double \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Double . valueOf ( value )  )  )  ;", "} else", "if    (  ( type . equals ( Float . class . getName (  )  )  )     |  |     ( type . equals (  \" float \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Float . valueOf ( value )  )  )  ;", "} else", "if    (  ( type . equals ( Boolean . class . getName (  )  )  )     |  |     ( type . equals (  \" boolean \"  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Boolean . valueOf ( value )  )  )  ;", "} else", "if    (  ( type . equals ( Character . class . getName (  )  )  )     |  |     ( type . equals (  \" char \"  )  )  )     {", "if    (  ( value . length (  )  )     !  =     1  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidCharacterLength (  \" env - entry \"  ,    value )  ;", "}", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( value . charAt (  0  )  )  )  ;", "} else", "if    ( type . equals ( Class . class . getName (  )  )  )     {", "try    {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( classLoader . loadClass ( value )  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoad ( value )  ;", "}", "} else", "if    (  ( classType . isEnum (  )  )     |  |     (  (  ( classType . getEnclosingClass (  )  )     !  =    null )     &  &     ( classType . getEnclosingClass (  )  . isEnum (  )  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   EnvEntryInjectionSource ( Enum . valueOf (  (  ( Class )     ( classType )  )  ,    value )  )  )  ;", "} else    {", "throw   EeLogger . ROOT _ LOGGER . unknownElementType (  \" env - entry \"  ,    type )  ;", "}", "bindings . add ( bindingConfiguration )  ;", "}", "return   bindings ;", "}", "METHOD_END"], "methodName": ["getEnvironmentEntries"], "fileName": "org.jboss.as.ee.component.deployers.ResourceReferenceProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < BindingConfiguration >    bindings    =    new   ArrayList < BindingConfiguration >  (  )  ;", "final   MessageDestinationReferencesMetaData   messageDestinationReferences    =    environment . getEnvironment (  )  . getMessageDestinationReferences (  )  ;", "if    ( messageDestinationReferences    =  =    null )     {", "return   bindings ;", "}", "for    ( final   MessageDestinationReferenceMetaData   messageRef    :    messageDestinationReferences )     {", "final   String   name ;", "if    ( messageRef . getName (  )  . startsWith (  \" java :  \"  )  )     {", "name    =    messageRef . getName (  )  ;", "} else    {", "name    =     ( environment . getDefaultContext (  )  )     +     ( messageRef . getName (  )  )  ;", "}", "Class <  ?  >    classType    =    null ;", "if    (  ( messageRef . getType (  )  )     !  =    null )     {", "try    {", "classType    =    classLoader . loadClass ( messageRef . getType (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoad ( e ,    messageRef . getType (  )  )  ;", "}", "}", "final   LookupInjectionSource   injectionSource    =    new   LookupInjectionSource ( name )  ;", "classType    =    processInjectionTargets ( resourceInjectionTarget ,    injectionSource ,    classLoader ,    deploymentReflectionIndex ,    messageRef ,    classType )  ;", "final   BindingConfiguration   bindingConfiguration ;", "if    (  !  ( isEmpty ( messageRef . getLookupName (  )  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   LookupInjectionSource ( messageRef . getLookupName (  )  )  )  ;", "bindings . add ( bindingConfiguration )  ;", "} else", "if    (  !  ( isEmpty ( messageRef . getMappedName (  )  )  )  )     {", "bindingConfiguration    =    new   BindingConfiguration ( name ,    new   LookupInjectionSource ( messageRef . getMappedName (  )  )  )  ;", "bindings . add ( bindingConfiguration )  ;", "} else", "if    (  !  ( isEmpty ( messageRef . getLink (  )  )  )  )     {", "final   MessageDestinationInjectionSource   messageDestinationInjectionSource    =    new   MessageDestinationInjectionSource ( messageRef . getLink (  )  ,    name )  ;", "bindingConfiguration    =    new   BindingConfiguration ( name ,    messageDestinationInjectionSource )  ;", "deploymentUnit . addToAttachmentList ( Attachments . MESSAGE _ DESTINATIONS ,    messageDestinationInjectionSource )  ;", "bindings . add ( bindingConfiguration )  ;", "} else    {", "EeLogger . ROOT _ LOGGER . cannotResolve (  \" message - destination - ref \"  ,    name )  ;", "}", "}", "return   bindings ;", "}", "METHOD_END"], "methodName": ["getMessageDestinationRefs"], "fileName": "org.jboss.as.ee.component.deployers.ResourceReferenceProcessor"}, {"methodBody": ["METHOD_START", "{", "List < BindingConfiguration >    bindings    =    new   ArrayList < BindingConfiguration >  (  )  ;", "final   ResourceEnvironmentReferencesMetaData   resourceEnvRefs    =    environment . getEnvironment (  )  . getResourceEnvironmentReferences (  )  ;", "final   EERegistry   registry    =    deploymentUnit . getAttachment ( Attachments . RESOURCE _ REFERENCE _ PROCESSOR _ REGISTRY )  ;", "if    ( resourceEnvRefs    =  =    null )     {", "return   bindings ;", "}", "for    ( ResourceEnvironmentReferenceMetaData   resourceEnvRef    :    resourceEnvRefs )     {", "final   String   name ;", "if    ( resourceEnvRef . getName (  )  . startsWith (  \" java :  \"  )  )     {", "name    =    resourceEnvRef . getName (  )  ;", "} else    {", "name    =     ( environment . getDefaultContext (  )  )     +     ( resourceEnvRef . getName (  )  )  ;", "}", "Class <  ?  >    classType    =    null ;", "if    (  ( resourceEnvRef . getType (  )  )     !  =    null )     {", "try    {", "classType    =    classLoader . loadClass ( resourceEnvRef . getType (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoad ( e ,    resourceEnvRef . getType (  )  )  ;", "}", "}", "InjectionSource   injectionSource    =    new   LookupInjectionSource ( name )  ;", "classType    =    processInjectionTargets ( resourceInjectionTarget ,    injectionSource ,    classLoader ,    deploymentReflectionIndex ,    resourceEnvRef ,    classType )  ;", "if    (  !  ( isEmpty ( resourceEnvRef . getLookupName (  )  )  )  )     {", "injectionSource    =    new   LookupInjectionSource ( resourceEnvRef . getLookupName (  )  ,     (  ( classType    !  =    null )     &  &     (  . JAVAX _ NAMING _ CONTEXT . equals ( classType . getName (  )  )  )  )  )  ;", "} else    {", "if    ( classType    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . cannotDetermineType ( name )  ;", "}", "final   String   lookup    =    ResourceInjectionAnnotationParsingProcessor . FIXED _ LOCATIONS . get ( classType . getName (  )  )  ;", "if    ( lookup    !  =    null )     {", "injectionSource    =    new   LookupInjectionSource ( lookup )  ;", "} else    {", "final   EE   resourceReferenceProcessor    =    registry . get ( classType . getName (  )  )  ;", "if    ( resourceReferenceProcessor    !  =    null )     {", "injectionSource    =    resourceReferenceProcessor . getResourceReferenceBindingSource (  )  ;", "} else    {", "if    ( resourceEnvRef . getResourceEnvRefName (  )  . startsWith (  \" java :  \"  )  )     {", "EeLogger . ROOT _ LOGGER . cannotResolve (  \" resource - env - ref \"  ,    name )  ;", "continue ;", "} else    {", "injectionSource    =    new   LookupInjectionSource (  (  \" java : jboss / resources /  \"     +     ( resourceEnvRef . getResourceEnvRefName (  )  )  )  )  ;", "}", "}", "}", "}", "bindings . add ( new   BindingConfiguration ( name ,    injectionSource )  )  ;", "}", "return   bindings ;", "}", "METHOD_END"], "methodName": ["getResourceEnvRefEntries"], "fileName": "org.jboss.as.ee.component.deployers.ResourceReferenceProcessor"}, {"methodBody": ["METHOD_START", "{", "List < BindingConfiguration >    bindings    =    new   ArrayList < BindingConfiguration >  (  )  ;", "final   EERegistry   registry    =    deploymentUnit . getAttachment ( Attachments . RESOURCE _ REFERENCE _ PROCESSOR _ REGISTRY )  ;", "final   ResourceReferencesMetaData   resourceRefs    =    environment . getEnvironment (  )  . getResourceReferences (  )  ;", "if    ( resourceRefs    =  =    null )     {", "return   bindings ;", "}", "for    ( final   ResourceReferenceMetaData   resourceRef    :    resourceRefs )     {", "final   String   name ;", "if    ( resourceRef . getName (  )  . startsWith (  \" java :  \"  )  )     {", "name    =    resourceRef . getName (  )  ;", "} else    {", "name    =     ( environment . getDefaultContext (  )  )     +     ( resourceRef . getName (  )  )  ;", "}", "Class <  ?  >    classType    =    null ;", "if    (  ( resourceRef . getType (  )  )     !  =    null )     {", "try    {", "classType    =    classLoader . loadClass ( resourceRef . getType (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoad ( e ,    resourceRef . getType (  )  )  ;", "}", "}", "InjectionSource   injectionSource    =    new   LookupInjectionSource ( name )  ;", "classType    =    processInjectionTargets ( resourceInjectionTarget ,    injectionSource ,    classLoader ,    deploymentReflectionIndex ,    resourceRef ,    classType )  ;", "if    (  !  ( isEmpty ( resourceRef . getLookupName (  )  )  )  )     {", "injectionSource    =    new   LookupInjectionSource ( resourceRef . getLookupName (  )  ,     (  ( classType    !  =    null )     &  &     (  . JAVAX _ NAMING _ CONTEXT . equals ( classType . getName (  )  )  )  )  )  ;", "} else", "if    (  !  ( isEmpty ( resourceRef . getResUrl (  )  )  )  )     {", "final   String   url    =    resourceRef . getResUrl (  )  ;", "if    (  ( classType    !  =    null )     &  &     ( classType . equals ( class )  )  )     {", "try    {", "injectionSource    =    new   FixedInjectionSource ( new   ManagedReferenceFactory (  )     {", "@ Override", "public   ManagedReference   getReference (  )     {", "try    {", "return   new   ImmediateManagedReference ( new   URI ( url )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  ,    new   URI ( url )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotParseResourceRefUri ( e ,    resourceRef . getResUrl (  )  )  ;", "}", "} else    {", "try    {", "injectionSource    =    new   FixedInjectionSource ( new   ManagedReferenceFactory (  )     {", "@ Override", "public   ManagedReference   getReference (  )     {", "try    {", "return   new   ImmediateManagedReference ( new   URL ( url )  )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  ,    new   URL ( url )  )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotParseResourceRefUri ( e ,    resourceRef . getResUrl (  )  )  ;", "}", "}", "} else    {", "if    ( classType    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . cannotDetermineType ( name )  ;", "}", "final   String   lookup    =    ResourceInjectionAnnotationParsingProcessor . FIXED _ LOCATIONS . get ( classType . getName (  )  )  ;", "if    ( lookup    !  =    null )     {", "injectionSource    =    new   LookupInjectionSource ( lookup )  ;", "} else    {", "final   EE   resourceReferenceProcessor    =    registry . get ( classType . getName (  )  )  ;", "if    ( resourceReferenceProcessor    !  =    null )     {", "injectionSource    =    resourceReferenceProcessor . getResourceReferenceBindingSource (  )  ;", "} else", "if    (  !  ( resourceRef . getResourceRefName (  )  . startsWith (  \" java :  \"  )  )  )     {", "injectionSource    =    new   LookupInjectionSource (  (  \" java : jboss / resources /  \"     +     ( resourceRef . getResourceRefName (  )  )  )  )  ;", "} else    {", "EeLogger . ROOT _ LOGGER . cannotResolve (  \" resource - env - ref \"  ,    name )  ;", "continue ;", "}", "}", "}", "bindings . add ( new   BindingConfiguration ( name ,    injectionSource )  )  ;", "}", "return   bindings ;", "}", "METHOD_END"], "methodName": ["getResourceRefEntries"], "fileName": "org.jboss.as.ee.component.deployers.ResourceReferenceProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( string    =  =    null )     |  |     ( string . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.jboss.as.ee.component.deployers.ResourceReferenceProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( claame    =  =    null )     |  |     ( claame . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . cannotBeNullOrEmpty (  \" Claame \"  ,    claame )  ;", "}", "if    ( claame . equals ( void . clagetName (  )  )  )     {", "return   void . cla", "}", "if    ( claame . equals ( byte . clagetName (  )  )  )     {", "return   byte . cla", "}", "if    ( claame . equals ( short . clagetName (  )  )  )     {", "return   short . cla", "}", "if    ( claame . equals ( int . clagetName (  )  )  )     {", "return   int . cla", "}", "if    ( claame . equals ( long . clagetName (  )  )  )     {", "return   long . cla", "}", "if    ( claame . equals ( char . clagetName (  )  )  )     {", "return   char . cla", "}", "if    ( claame . equals ( boolean . clagetName (  )  )  )     {", "return   boolean . cla", "}", "if    ( claame . equals ( float . clagetName (  )  )  )     {", "return   float . cla", "}", "if    ( claame . equals ( double . clagetName (  )  )  )     {", "return   double . cla", "}", "return   ClaforName ( claame ,    false ,    cl )  ;", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.ee.component.deployers.ResourceReferenceProcessor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  ( c )     !  =     0  )", "callbacks . add ( callback )  ;", "else", "callback . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addCallback"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "if    ( isPrivileged (  )  )", "return ;", "if    (  ( c )     !  =     0  )     {", "synchronized ( this )     {", "while    (  ( c )     !  =     0  )", "wait (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  (  -  -  ( c )  )     =  =     0  )     {", "try    {", "while    (  !  ( callbacks . isEmpty (  )  )  )", "callbacks . poll (  )  . run (  )  ;", "}    finally    {", "notifyAll (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["countDown"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "this . c    +  =    c ;", "}", "}", "METHOD_END"], "methodName": ["countUp"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "return   StartupCountdown . frames . get (  )  ;", "}", "METHOD_END"], "methodName": ["current"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "final   StartupCountdown . Frame   frame    =    StartupCountdown . frames . get (  )  ;", "StartupCountdown . frames . set ( new   StartupCountdown . Frame ( frame ,    this )  )  ;", "return   frame ;", "}", "METHOD_END"], "methodName": ["enter"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "final   StartupCountdown . Frame   frame    =    StartupCountdown . frames . get (  )  ;", "return    ( frame    !  =    null )     &  &     ( frame . contains ( this )  )  ;", "}", "METHOD_END"], "methodName": ["isPrivileged"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "StartupCountdown . frames . set ( frame )  ;", "}", "METHOD_END"], "methodName": ["restore"], "fileName": "org.jboss.as.ee.component.deployers.StartupCountdown"}, {"methodBody": ["METHOD_START", "{", "ComponentInstance   componentInstance    =    context . getPrivateData ( ComponentInstance . class )  ;", "if    ( componentInstance    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . noComponentInstance (  )  ;", "}", "Method   oldMethod    =    context . getMethod (  )  ;", "try    {", "context . setMethod ( componentMethod )  ;", "context . setTarget ( componentInstance . getInstance (  )  )  ;", "return   componentInstance . get ( componentMethod )  . processInvocation ( context )  ;", "}    finally    {", "context . setMethod ( oldMethod )  ;", "context . setTarget ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ee.component.interceptors.ComponentDispatcherInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   InterceptorClassDescription . Builder (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "if    ( base    =  =    null )     {", "return   new    . Builder (  )  ;", "}", "return   new    . Builder ( base )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   aroundConstruct ;", "}", "METHOD_END"], "methodName": ["getAroundConstruct"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   aroundInvoke ;", "}", "METHOD_END"], "methodName": ["getAroundInvoke"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   aroundTimeout ;", "}", "METHOD_END"], "methodName": ["getAroundTimeout"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   postActivate ;", "}", "METHOD_END"], "methodName": ["getPostActivate"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   postConstruct ;", "}", "METHOD_END"], "methodName": ["getPostConstruct"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   preDestroy ;", "}", "METHOD_END"], "methodName": ["getPreDestroy"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   prePassivate ;", "}", "METHOD_END"], "methodName": ["getPrePassivate"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "if    (  ( existing    =  =    null )     &  &     ( override    =  =    null )  )     {", "return    . EMPTY _ INSTANCE ;", "}", "if    ( override    =  =    null )     {", "return   existing ;", "}", "if    ( existing    =  =    null )     {", "return   override ;", "}", "final    . Builder   builder    =     . builder ( existing )  ;", "if    (  ( override . getAroundInvoke (  )  )     !  =    null )     {", "builder . setAroundInvoke ( override . getAroundInvoke (  )  )  ;", "}", "if    (  ( override . getAroundTimeout (  )  )     !  =    null )     {", "builder . setAroundTimeout ( override . getAroundTimeout (  )  )  ;", "}", "if    (  ( override . getAroundConstruct (  )  )     !  =    null )     {", "builder . setAroundConstruct ( override . getAroundConstruct (  )  )  ;", "}", "if    (  ( override . getPostConstruct (  )  )     !  =    null )     {", "builder . setPostConstruct ( override . getPostConstruct (  )  )  ;", "}", "if    (  ( override . getPreDestroy (  )  )     !  =    null )     {", "builder . setPreDestroy ( override . getPreDestroy (  )  )  ;", "}", "if    (  ( override . getPrePassivate (  )  )     !  =    null )     {", "builder . setPrePassivate ( override . getPrePassivate (  )  )  ;", "}", "if    (  ( override . getPostActivate (  )  )     !  =    null )     {", "builder . setPostActivate ( override . getPostActivate (  )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "org.jboss.as.ee.component.interceptors.InterceptorClassDescription"}, {"methodBody": ["METHOD_START", "{", "return   label ;", "}", "METHOD_END"], "methodName": ["getLabel"], "fileName": "org.jboss.as.ee.component.interceptors.InvocationType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sortedItems )     !  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . cannotAddMoreItems (  )  ;", "}", "if    ( item    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . nullVar (  \" item \"  )  ;", "}", "final   T   current    =    items . get ( priority )  ;", "if    ( current    !  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . priorityAlreadyExists ( item ,    Integer . toHexString ( priority )  ,    current )  ;", "}", "items . put ( priority ,    item )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jboss.as.ee.component.interceptors.OrderedItemContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sortedItems )     =  =    null )     {", "final   SortedMap < Integer ,    T >    sortedMap    =    new   TreeMap < Integer ,    T >  ( items )  ;", "sortedItems    =    new   ArrayList < T >  ( sortedMap . values (  )  )  ;", "}", "return   sortedItems ;", "}", "METHOD_END"], "methodName": ["getSortedItems"], "fileName": "org.jboss.as.ee.component.interceptors.OrderedItemContainer"}, {"methodBody": ["METHOD_START", "{", "final   String   factoryName    =    factory . getName (  )  ;", "if    ( factoryMap . containsKey ( factoryName )  )     {", "throw   EeLogger . ROOT _ LOGGER . factoryAlreadyExists ( this ,    factoryName )  ;", "}", "factoryMap . put ( factoryName ,    factory )  ;", "final   Comparator < HandleFactory >    comparator    =    new   Comparator < HandleFactory >  (  )     {", "@ Override", "public   int   compare ( HandleFactory   o 1  ,    HandleFactory   o 2  )     {", "return   Integer . compare ( o 1  . getChainPriority (  )  ,    o 2  . getChainPriority (  )  )  ;", "}", "}  ;", "SortedSet < HandleFactory >    sortedSet    =    new   TreeSet <  >  ( comparator )  ;", "sortedSet . addAll ( factoryMap . values (  )  )  ;", "factoryOrderedList    =    new   ArrayList <  >  ( sortedSet )  ;", "}", "METHOD_END"], "methodName": ["addFactory"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContext"}, {"methodBody": ["METHOD_START", "{", "return   ConcurrentContext . current . peek (  )  ;", "}", "METHOD_END"], "methodName": ["current"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )     {", "return   CServiceContainer . getServiceContainer (  )  ;", "}", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContext"}, {"methodBody": ["METHOD_START", "{", "return   ConcurrentContext . current . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popCurrent"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContext"}, {"methodBody": ["METHOD_START", "{", "ConcurrentContext . current . push ( context )  ;", "}", "METHOD_END"], "methodName": ["pushCurrent"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContext"}, {"methodBody": ["METHOD_START", "{", "final   List < SetupContextHandle >    handles    =    new   ArrayList <  >  ( factoryOrderedList . size (  )  )  ;", "for    ( ContextHandleFactory   factory    :    factoryOrderedList )     {", "handles . add ( factory . saveContext ( contextService ,    contextObjectProperties )  )  ;", "}", "return   new    . ChainedSetupContextHandle ( this ,    handles )  ;", "}", "METHOD_END"], "methodName": ["saveContext"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContext"}, {"methodBody": ["METHOD_START", "{", "this . serviceName    =    serviceName ;", "}", "METHOD_END"], "methodName": ["setServiceName"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContext"}, {"methodBody": ["METHOD_START", "{", "return   concurrentContext ;", "}", "METHOD_END"], "methodName": ["getConcurrentContext"], "fileName": "org.jboss.as.ee.concurrent.ConcurrentContextSetupAction"}, {"methodBody": ["METHOD_START", "{", "checkNotNullParam (  \" instance \"  ,    instance )  ;", "checkNotNullParam (  \" intf \"  ,    intf )  ;", "IdityAwareProxyInvocationHandler   handler    =    new   IdityAwareProxyInvocationHandler ( this ,    instance ,    executionProperties )  ;", "Object   proxy    =    Proxy . newProxyInstance ( instance . getClass (  )  . getClassLoader (  )  ,    new   Class [  ]  {    intf    }  ,    handler )  ;", "return   intf . cast ( proxy )  ;", "}", "METHOD_END"], "methodName": ["internalCreateContextualProxy"], "fileName": "org.jboss.as.ee.concurrent.ContextServiceImpl"}, {"methodBody": ["METHOD_START", "{", "checkNotNullParam (  \" instance \"  ,    instance )  ;", "checkArrayBounds ( checkNotNullParam (  \" interfaces \"  ,    interfaces )  ,     0  ,     1  )  ;", "Class <  ?    extends   Object >    instanceClass    =    instance . getClass (  )  ;", "for    ( Class <  ?    extends   Object >    thisInterface    :    interfaces )     {", "if    (  !  ( thisInterface . isAssignableFrom ( instanceClass )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . classDoesNotementAllInterfaces (  )  ;", "}", "}", "IdentityAwareProxyInvocationHandler   handler    =    new   IdentityAwareProxyInvocationHandler ( this ,    instance ,    executionProperties )  ;", "Object   proxy    =    Proxy . newProxyInstance ( instance . getClass (  )  . getClassLoader (  )  ,    interfaces ,    handler )  ;", "return   proxy ;", "}", "METHOD_END"], "methodName": ["internalCreateContextualProxy"], "fileName": "org.jboss.as.ee.concurrent.ContextServiceImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( controlPoint    =  =    null )     |  |     ( runnable    =  =    null )  )     {", "return   runnable ;", "} else    {", "final    . ControlledScheduledRunnable   controlledScheduledRunnable    =    new    . ControlledScheduledRunnable ( runnable ,    controlPoint )  ;", "return   runnable   instanceof   ManagedTask    ?    new    . ControlledManagedRunnable ( controlledScheduledRunnable ,     (  ( ManagedTask )     ( runnable )  )  )     :    controlledScheduledRunnable ;", "}", "}", "METHOD_END"], "methodName": ["doScheduledWrap"], "fileName": "org.jboss.as.ee.concurrent.ControlPointUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( controlPoint    =  =    null )     |  |     ( callable    =  =    null )  )     {", "return   callable ;", "} else    {", "final    . ControlledScheduledCallable   controlledScheduledCallable    =    new    . ControlledScheduledCallable ( callable ,    controlPoint )  ;", "return   callable   instanceof   ManagedTask    ?    new    . ControlledManagedCallable ( controlledScheduledCallable ,     (  ( ManagedTask )     ( callable )  )  )     :    controlledScheduledCallable ;", "}", "}", "METHOD_END"], "methodName": ["doScheduledWrap"], "fileName": "org.jboss.as.ee.concurrent.ControlPointUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( controlPoint    =  =    null )     |  |     ( runnable    =  =    null )  )     {", "return   runnable ;", "}", "try    {", "controlPoint . forceBeginRequest (  )  ;", "final    . ControlledRunnable   controlledRunnable    =    new    . ControlledRunnable ( runnable ,    controlPoint )  ;", "return   runnable   instanceof   ManagedTask    ?    new    . ControlledManagedRunnable ( controlledRunnable ,     (  ( ManagedTask )     ( runnable )  )  )     :    controlledRunnable ;", "}    catch    ( Exception   e )     {", "throw   new   RejectedExecutionException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["doWrap"], "fileName": "org.jboss.as.ee.concurrent.ControlPointUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( controlPoint    =  =    null )     |  |     ( callable    =  =    null )  )     {", "return   callable ;", "}", "try    {", "controlPoint . forceBeginRequest (  )  ;", "final    . ControlledCallable   controlledCallable    =    new    . ControlledCallable ( callable ,    controlPoint )  ;", "return   callable   instanceof   ManagedTask    ?    new    . ControlledManagedCallable ( controlledCallable ,     (  ( ManagedTask )     ( callable )  )  )     :    controlledCallable ;", "}    catch    ( Exception   e )     {", "throw   new   RejectedExecutionException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["doWrap"], "fileName": "org.jboss.as.ee.concurrent.ControlPointUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( runnable    =  =    null )     {", "return   null ;", "}", "final   SecurityIdentity   securityIdentity    =     . getSecurityIdentity (  )  ;", "if    ( securityIdentity    =  =    null )     {", "return   runnable ;", "}", "Runnable   securedRunnable    =     (  )     -  >    securityIdentity . runAs ( runnable )  ;", "return   runnable   instanceof   ManagedTask    ?    new    . SecuredManagedRunnable ( securedRunnable ,     (  ( ManagedTask )     ( runnable )  )  )     :    securedRunnable ;", "}", "METHOD_END"], "methodName": ["doIdentityWrap"], "fileName": "org.jboss.as.ee.concurrent.SecurityIdentityUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( callable    =  =    null )     {", "return   null ;", "}", "final   SecurityIdentity   securityIdentity    =     . getSecurityIdentity (  )  ;", "if    ( securityIdentity    =  =    null )     {", "return   callable ;", "}", "Callable < T >    securedCallable    =     (  )     -  >    securityIdentity . runAs ( callable )  ;", "return   callable   instanceof   ManagedTask    ?    new    . SecuredManagedCallable < T >  ( securedCallable ,     (  ( ManagedTask )     ( callable )  )  )     :    securedCallable ;", "}", "METHOD_END"], "methodName": ["doIdentityWrap"], "fileName": "org.jboss.as.ee.concurrent.SecurityIdentityUtils"}, {"methodBody": ["METHOD_START", "{", "final   SecurityManager   sm    =    System . getSecurityManager (  )  ;", "final   SecurityDomain   securityDomain ;", "if    ( sm    !  =    null )     {", "securityDomain    =    AccessController . doPrivileged (  (  ( PrivilegedAction < SecurityDomain >  )     (  (  )     -  >    SecurityDomain . getCurrent (  )  )  )  )  ;", "} else    {", "securityDomain    =    SecurityDomain . getCurrent (  )  ;", "}", "return   securityDomain    !  =    null    ?    securityDomain . getCurrent (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getSecurityIdentity"], "fileName": "org.jboss.as.ee.concurrent.SecurityIdentityUtils"}, {"methodBody": ["METHOD_START", "{", "in . defaultReadObject (  )  ;", "final   ServiceContainer   currentServiceContainer    =     (  ( System . getSecurityManager (  )  )     =  =    null )     ?    CurrentServiceContainer . getServiceContainer (  )     :    AccessController . doPrivileged ( GET _ ACTION )  ;", "final   ServiceController <  ?  >    serviceController    =    currentServiceContainer . getService ( serviceName )  ;", "if    ( serviceController    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . transactionSetupProviderServiceNotInstalled (  )  ;", "}", "transactionSetupProvider    =     (  (  )     ( serviceController . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.jboss.as.ee.concurrent.ServiceTransactionSetupProvider"}, {"methodBody": ["METHOD_START", "{", "out . defaultWriteObject (  )  ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.jboss.as.ee.concurrent.ServiceTransactionSetupProvider"}, {"methodBody": ["METHOD_START", "{", "final   ComponentConfigurator   componentConfigurator    =    new   ComponentConfigurator (  )     {", "@ Override", "public   void   configure ( DeploymentPhaseContext   context ,    ComponentDescription   description ,    final   ComponentConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "final      concurrentContext    =    configuration . get (  )  ;", "setup ( concurrentContext ,    description . getApplicationName (  )  ,    description . getModuleName (  )  ,    description . getComponentName (  )  ,    configuration . getModuleClassLoader (  )  ,    configuration . getNamespaceContextSelector (  )  ,    context . getDeploymentUnit (  )  ,    context . getServiceTarget (  )  )  ;", "final   Interceptor   interceptor    =    new   Interceptor ( concurrentContext )  ;", "final   InterceptorFactory   interceptorFactory    =    new   ImmediateInterceptorFactory ( interceptor )  ;", "configuration . addPostConstructInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPostConstruct . CONCURRENT _ CONTEXT )  ;", "configuration . addPreDestroyInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPreDestroy . CONCURRENT _ CONTEXT )  ;", "if    ( description . isPassivationApplicable (  )  )     {", "configuration . addPrePassivateInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPassivation . CONCURRENT _ CONTEXT )  ;", "configuration . addPostActivateInterceptor ( interceptorFactory ,    InterceptorOrder . ComponentPassivation . CONCURRENT _ CONTEXT )  ;", "}", "configuration . addComponentInterceptor ( interceptorFactory ,    InterceptorOrder . Component . CONCURRENT _ CONTEXT ,    false )  ;", "}", "}  ;", "componentDescription . getConfigurators (  )  . add ( componentConfigurator )  ;", "}", "METHOD_END"], "methodName": ["processComponentDescription"], "fileName": "org.jboss.as.ee.concurrent.deployers.EEConcurrentContextProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ConcurrentContext   concurrentContext    =    moduleDescription . getConcurrentContext (  )  ;", "setupConcurrentContext ( concurrentContext ,    moduleDescription . getApplicationName (  )  ,    moduleDescription . getModuleName (  )  ,    null ,    deploymentUnit . getAttachment ( Attachments . MODULE )  . getClassLoader (  )  ,    moduleDescription . getNamespaceContextSelector (  )  ,    deploymentUnit ,    phaseContext . getServiceTarget (  )  )  ;", "final   ConcurrentContextSetupAction   setupAction    =    new   ConcurrentContextSetupAction ( concurrentContext )  ;", "deploymentUnit . getAttachmentList ( mponent . Attachments . WEB _ SETUP _ ACTIONS )  . add ( setupAction )  ;", "}", "METHOD_END"], "methodName": ["processModuleDescription"], "fileName": "org.jboss.as.ee.concurrent.deployers.EEConcurrentContextProcessor"}, {"methodBody": ["METHOD_START", "{", "concurrentContext . addFactory ( new   NamingContextHandleFactory ( namespaceContextSelector ,    deploymentUnit . getServiceName (  )  )  )  ;", "concurrentContext . addFactory ( new   ClassLoaderContextHandleFactory ( moduleClassLoader )  )  ;", "for    ( ContextHandleFactory   factory    :    deploymentUnit . getAttachmentList ( Attachments . ADDITIONAL _ FACTORIES )  )     {", "concurrentContext . addFactory ( factory )  ;", "}", "concurrentContext . addFactory ( new   OtherEESetupActionsContextHandleFactory ( deploymentUnit . getAttachmentList ( Attachments . OTHER _ EE _ SETUP _ ACTIONS )  )  )  ;", "final   Service   service    =    new   Service ( concurrentContext )  ;", "final   ServiceName   serviceName    =    ConcurrentServiceNames . getServiceName ( applicationName ,    moduleName ,    componentName )  ;", "serviceTarget . addService ( serviceName ,    service )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["setupConcurrentContext"], "fileName": "org.jboss.as.ee.concurrent.deployers.EEConcurrentContextProcessor"}, {"methodBody": ["METHOD_START", "{", "final   LookupInjectionSource   injectionSource    =    new   LookupInjectionSource ( source )  ;", "if    ( DeploymentTypeMarker . isType ( DeploymentType . WAR ,    deploymentUnit )  )     {", "moduleDescription . geConfigurations (  )  . add ( new   BindingConfiguration ( moduleTarget ,    injectionSource )  )  ;", "} else    {", "if    ( DeploymentTypeMarker . isType ( DeploymentType . APPLICATION _ CLIENT ,    deploymentUnit )  )     {", "moduleDescription . geConfigurations (  )  . add ( new   BindingConfiguration ( compTarget ,    injectionSource )  )  ;", "}", "for    ( ComponentDescription   componentDescription    :    moduleDescription . getComponentDescriptions (  )  )     {", "if    (  ( componentDescription . getNamingMode (  )  )     =  =     ( ComponentNamingMode . CREATE )  )     {", "componentDescription . geConfigurations (  )  . add ( new   BindingConfiguration ( compTarget ,    injectionSource )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addBinding"], "fileName": "org.jboss.as.ee.concurrent.deployers.EEConcurrentDefaultBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "return   NullContextHandle . INSTANCE ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.jboss.as.ee.concurrent.handle.NullContextHandle"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   moduleServiceName    =    ConcurrentServiceNames . CONCURRENT _ CONTEXT _ BASE _ SERVICE _ NAME . append ( app )  . append ( module )  ;", "if    ( component    =  =    null )     {", "return   moduleServiceName ;", "} else    {", "return   moduleServiceName . append ( component )  ;", "}", "}", "METHOD_END"], "methodName": ["getConcurrentContextServiceName"], "fileName": "org.jboss.as.ee.concurrent.service.ConcurrentServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   ConcurrentServiceNames . CONTEXT _ SERVICE _ BASE _ SERVICE _ NAME . append ( name )  ;", "}", "METHOD_END"], "methodName": ["getContextServiceServiceName"], "fileName": "org.jboss.as.ee.concurrent.service.ConcurrentServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   ConcurrentServiceNames . MANAGED _ EXECUTOR _ SERVICE _ BASE _ SERVICE _ NAME . append ( name )  ;", "}", "METHOD_END"], "methodName": ["getManagedExecutorServiceServiceName"], "fileName": "org.jboss.as.ee.concurrent.service.ConcurrentServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   ConcurrentServiceNames . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE _ BASE _ SERVICE _ NAME . append ( name )  ;", "}", "METHOD_END"], "methodName": ["getManagedScheduledExecutorServiceServiceName"], "fileName": "org.jboss.as.ee.concurrent.service.ConcurrentServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   ConcurrentServiceNames . MANAGED _ THREAD _ FACTORY _ BASE _ SERVICE _ NAME . append ( name )  ;", "}", "METHOD_END"], "methodName": ["getManagedThreadFactoryServiceName"], "fileName": "org.jboss.as.ee.concurrent.service.ConcurrentServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   contextSetupProvider ;", "}", "METHOD_END"], "methodName": ["getContextSetupProvider"], "fileName": "org.jboss.as.ee.concurrent.service.ContextServiceService"}, {"methodBody": ["METHOD_START", "{", "return   transactionSetupProvider ;", "}", "METHOD_END"], "methodName": ["getTransactionSetupProvider"], "fileName": "org.jboss.as.ee.concurrent.service.ContextServiceService"}, {"methodBody": ["METHOD_START", "{", "final   ContextServiceImpl   value    =    this . contextService ;", "if    ( value    =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . concurrentServiceValueUninitialized (  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.concurrent.service.ContextServiceService"}, {"methodBody": ["METHOD_START", "{", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( jndiName )  ;", "final   BinderService   binderService    =    new   BinderService ( bindInfo . getBindName (  )  )  ;", "final   ImmediateManagedReferenceFactory   managedReferenceFactory    =    new   ImmediateManagedReferenceFactory (  . getValue (  )  )  ;", "context . getChildTarget (  )  . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addInjectionValue ( binderService . getManagedObjectInjector (  )  ,    new   ImmediateValue < ManagedReferenceFactory >  ( managedReferenceFactory )  )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["bindValueToJndi"], "fileName": "org.jboss.as.ee.concurrent.service.EEConcurrentAbstractService"}, {"methodBody": ["METHOD_START", "{", "startValue ( context )  ;", "bindValueToJndi ( context )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ee.concurrent.service.EEConcurrentAbstractService"}, {"methodBody": ["METHOD_START", "{", "stopValue ( context )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ee.concurrent.service.EEConcurrentAbstractService"}, {"methodBody": ["METHOD_START", "{", "boolean   checking    =    WildFlySecurityManager . isChecking (  )  ;", "SecurityDomain   domain    =     ( checking )     ?    AccessController . doPrivileged (  (  ( PrivilegedAction < SecurityDomain >  )     ( SecurityDomain :  : getCurrent )  )  )     :    SecurityDomain . getCurrent (  )  ;", "SecurityIdentity   identity    =     ( domain    =  =    null )     ?    null    :    domain . getCurrentSecurityIdentity (  )  ;", "if    ( checking )     {", "return   AccessController . doPrivileged (  (  ( PrivilegedAction <  . ElytronManagedThread >  )     (  (  )     -  >    new    . ElytronManagedThread ( r ,    contextHandleForSetup ,    identity )  )  )  )  ;", "} else    {", "return   new    . ElytronManagedThread ( r ,    contextHandleForSetup ,    identity )  ;", "}", "}", "METHOD_END"], "methodName": ["createThread"], "fileName": "org.jboss.as.ee.concurrent.service.ElytronManagedThreadFactory"}, {"methodBody": ["METHOD_START", "{", "return   contextService ;", "}", "METHOD_END"], "methodName": ["getContextServiceInjector"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "return   managedThreadFactoryInjectedValue ;", "}", "METHOD_END"], "methodName": ["getManagedThreadFactoryInjector"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "return   requestController ;", "}", "METHOD_END"], "methodName": ["getRequestController"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executorService )     =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . concurrentServiceValueUninitialized (  )  ;", "}", "return   executorService . getAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "return   contextService ;", "}", "METHOD_END"], "methodName": ["getContextServiceInjector"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedScheduledExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "return   managedThreadFactoryInjectedValue ;", "}", "METHOD_END"], "methodName": ["getManagedThreadFactoryInjector"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedScheduledExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "return   requestController ;", "}", "METHOD_END"], "methodName": ["getRequestController"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedScheduledExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executorService )     =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . concurrentServiceValueUninitialized (  )  ;", "}", "return   executorService . getAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedScheduledExecutorServiceService"}, {"methodBody": ["METHOD_START", "{", "return   contextService ;", "}", "METHOD_END"], "methodName": ["getContextServiceInjector"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedThreadFactoryService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . managedThreadFactory )     =  =    null )     {", "throw   EeLogger . ROOT _ LOGGER . concurrentServiceValueUninitialized (  )  ;", "}", "return   managedThreadFactory ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.concurrent.service.ManagedThreadFactoryService"}, {"methodBody": ["METHOD_START", "{", "final   ComponentClientInstance   instance    =    context . getPrivateData ( ComponentClientInstance . class )  ;", "final   Component    =    context . getPrivateData ( Component . class )  ;", "final   ComponentInstance   nstance    =    createInstance (  )  ;", "boolean   ok    =    false ;", "try    {", "context . putPrivateData ( ComponentInstance . class ,    nstance )  ;", "instance . setViewInstanceData ( ComponentInstance . class ,    nstance )  ;", "final   Object   result    =    context . proceed (  )  ;", "ok    =    true ;", "return   result ;", "}    finally    {", "context . putPrivateData ( ComponentInstance . class ,    null )  ;", "if    (  ! ok )     {", "nstance . destroy (  )  ;", "instance . setViewInstanceData ( ComponentInstance . class ,    null )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processInvocation"], "fileName": "org.jboss.as.ee.managedbean.component.ManagedBeanCreateInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "final   ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "ModuleDependency   invocation    =    new   ModuleDependency ( moduleLoader ,     . JBOSS _ INVOCATION _ ID ,    false ,    false ,    false ,    false )  ;", "invocation . addImportFilter ( PathFilters . is (  \" org / jboss / invocation / proxy / classloading \"  )  ,    true )  ;", "invocation . addImportFilter ( PathFilters . acceptAll (  )  ,    false )  ;", "moduleSpecification . addSystemDependency ( invocation )  ;", "ModuleDependency   ee    =    new   ModuleDependency ( moduleLoader ,     . JBOSS _ AS _ EE ,    false ,    false ,    false ,    false )  ;", "ee . addImportFilter ( PathFilters . is (  \" org / jboss / as / ee / component / serialization \"  )  ,    true )  ;", "ee . addImportFilter ( PathFilters . is (  \" org / jboss / as / ee / concurrent \"  )  ,    true )  ;", "ee . addImportFilter ( PathFilters . is (  \" org / jboss / as / ee / concurrent / handle \"  )  ,    true )  ;", "ee . addImportFilter ( PathFilters . acceptAll (  )  ,    false )  ;", "moduleSpecification . addSystemDependency ( ee )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    ModuleIdentifier . create (  \" naming \"  )  ,    false ,    false ,    false ,    false )  )  ;", "for    ( final   ModuleIdentifier   moduleIdentifier    :     . JAVA _ EE _ API _ MODULES )     {", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    moduleIdentifier ,    true ,    false ,    true ,    false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.managedbean.processors.JavaEEDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "final   short   flags    =    managedBeanClass . flags (  )  ;", "final   String   className    =    managedBeanClass . name (  )  . toString (  )  ;", "if    ( Modifier . isInterface ( flags )  )     {", "EeLogger . ROOT _ LOGGER . invalidManagedBeanInterface (  \" MB .  2  .  1  .  1  \"  ,    className )  ;", "return   false ;", "}", "if    (  ( Modifier . isAbstract ( flags )  )     |  |     ( Modifier . isFinal ( flags )  )  )     {", "EeLogger . ROOT _ LOGGER . invalidbstractOrFinal (  \" MB .  2  .  1  .  1  \"  ,    className )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["assertManagedBeanClassValidity"], "fileName": "org.jboss.as.ee.managedbean.processors.ManagedBeanAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEResourceReferenceProcessorRegistry   registry    =    deploymentUnit . getAttachment ( Attachments . RESOURCE _ REFERENCE _ PROCESSOR _ REGISTRY )  ;", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   CompositeIndex   compositeIndex    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "final   PropertyReplacer   replacer    =    EJBAnnotationPropertyReplacement . propertyReplacer ( deploymentUnit )  ;", "if    ( compositeIndex    =  =    null )     {", "return ;", "}", "final   List < AnnotationInstance >    instances    =    compositeIndex . getAnnotations (  . MANAGED _ BEAN _ ANNOTATION _ NAME )  ;", "if    (  ( instances    =  =    null )     |  |     ( instances . isEmpty (  )  )  )     {", "return ;", "}", "for    ( AnnotationInstance   instance    :    instances )     {", "AnnotationTarget   target    =    instance . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "throw   EeLogger . ROOT _ LOGGER . classOnlyAnnotation (  \"  @ ManagedBean \"  ,    target )  ;", "}", "final   ClassInfo   classInfo    =     (  ( ClassInfo )     ( target )  )  ;", "if    (  !  (  . assertManagedBeanClassValidity ( classInfo )  )  )     {", "continue ;", "}", "final   String   beanClassName    =    classInfo . name (  )  . toString (  )  ;", "final   AnnotationValue   nameValue    =    instance . value (  )  ;", "final   String   beanName    =     (  ( nameValue    =  =    null )     |  |     ( nameValue . asString (  )  . isEmpty (  )  )  )     ?    beanClassName    :    replacer . replaceProperties ( nameValue . asString (  )  )  ;", "final   ManagedBeanComponentDescription   componentDescription    =    new   ManagedBeanComponentDescription ( beanName ,    beanClassName ,    moduleDescription ,    deploymentUnit . getServiceName (  )  )  ;", "ViewDescription   viewDescription    =    new   ViewDescription ( componentDescription ,    beanClassName )  ;", "viewDescription . getConfigurators (  )  . addFirst ( new   ViewConfigurator (  )     {", "public   void   configure ( final   DeploymentPhaseContext   context ,    final   ComponentConfiguration   componentConfiguration ,    final   ViewDescription   description ,    final   ViewConfiguration   configuration )    throws   DeploymentUnitProcessingException    {", "configuration . addClientPostConstructInterceptor ( ManagedBeanCreateInterceptor . FACTORY ,    InterceptorOrder . ClientPostConstruct . INSTANCE _ CREATE )  ;", "final   ClassLoader   classLoader    =    componentConfiguration . getModuleClassLoader (  )  ;", "configuration . addViewInterceptor ( AccessCheckingInterceptor . getFactory (  )  ,    InterceptorOrder . View . CHECKING _ INTERCEPTOR )  ;", "configuration . addViewInterceptor ( new   ImmediateInterceptorFactory ( new   ContextClassLoaderInterceptor ( classLoader )  )  ,    InterceptorOrder . View . TCCL _ INTERCEPTOR )  ;", "}", "}  )  ;", "viewDescription . getBindingNames (  )  . addAll ( Arrays . asList (  (  \" java : module /  \"     +    beanName )  ,     (  (  (  \" java : app /  \"     +     ( moduleDescription . getModuleName (  )  )  )     +     \"  /  \"  )     +    beanName )  )  )  ;", "componentDescription . getViews (  )  . add ( viewDescription )  ;", "moduleDescription . addComponent ( componentDescription )  ;", "registry . registerResourceReferenceProcessor ( new   ManagedBeanResourceReferenceProcessor ( beanClassName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.managedbean.processors.ManagedBeanAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   CompositeIndex   index    =    deploymentUnit . getAttachment ( COMPOSITE _ ANNOTATION _ INDEX )  ;", "PropertyReplacer   propertyReplacer    =    EJBpertyReplacement . propertyReplacer ( deploymentUnit )  ;", "if    (  ( index    =  =    null )     |  |     ( eeModuleDescription    =  =    null )  )     {", "return ;", "}", "final   List < ClassAnnotationInformationFactory >    factories    =    annotationInformationFactories (  )  ;", "for    ( final   ClassAnnotationInformationFactory   factory    :    factories )     {", "final   Map < String ,    ClassAnnotationInformation <  ?  ,     ?  >  >    data    =    factory . createAnnotationInformation ( index ,    propertyReplacer )  ;", "for    ( Map . Entry < String ,    ClassAnnotationInformation <  ?  ,     ?  >  >    entry    :    data . entrySet (  )  )     {", "EEModuleClassDescription   clazz    =    eeModuleDescription . addOrGetLocalClassDescription ( entry . getKey (  )  )  ;", "clazz . addAnnotationInformation ( entry . getValue (  )  )  ;", "}", "}", "afterAnnotationsProcessed ( phaseContext ,    deploymentUnit )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.metadata.AbstractEEAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "return   componentDefault ;", "}", "METHOD_END"], "methodName": ["getComponentDefault"], "fileName": "org.jboss.as.ee.metadata.AnnotationMetadata"}, {"methodBody": ["METHOD_START", "{", "return   methodOverrides ;", "}", "METHOD_END"], "methodName": ["getMethodOverrides"], "fileName": "org.jboss.as.ee.metadata.AnnotationMetadata"}, {"methodBody": ["METHOD_START", "{", "return   annotationType ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformation"}, {"methodBody": ["METHOD_START", "{", "return   classLevelAnnotations ;", "}", "METHOD_END"], "methodName": ["getClassLevelAnnotations"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformation"}, {"methodBody": ["METHOD_START", "{", "return   fieldLevelAnnotations ;", "}", "METHOD_END"], "methodName": ["getFieldLevelAnnotations"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformation"}, {"methodBody": ["METHOD_START", "{", "return   methodLevelAnnotations ;", "}", "METHOD_END"], "methodName": ["getMethodLevelAnnotations"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformation"}, {"methodBody": ["METHOD_START", "{", "final   List < ClassAnnotationInformationFactory . TargetAnnotation >    annotations    =    new   ArrayList < ClassAnnotationInformationFactory . TargetAnnotation >  (  )  ;", "if    (  ( multiAnnotationDotName )     !  =    null )     {", "for    ( AnnotationInstance   multiInstance    :    index . getAnnotations ( multiAnnotationDotName )  )     {", "annotations . addAll ( fromMultiAnnotation ( multiInstance )  )  ;", "}", "}", "final   List < AnnotationInstance >    simpleAnnotations    =    index . getAnnotations ( annotationDotName )  ;", "if    ( simpleAnnotations    !  =    null )     {", "for    ( AnnotationInstance   annotation    :    simpleAnnotations )     {", "annotations . add ( new   ClassAnnotationInformationFactory . TargetAnnotation ( annotation ,    annotation . target (  )  )  )  ;", "}", "}", "final   Map < DotName ,    List < ClassAnnotationInformationFactory . TargetAnnotation >  >    classLevel    =    new   HashMap < DotName ,    List < ClassAnnotationInformationFactory . TargetAnnotation >  >  (  )  ;", "final   Map < DotName ,    List < ClassAnnotationInformationFactory . TargetAnnotation >  >    methodLevel    =    new   HashMap < DotName ,    List < ClassAnnotationInformationFactory . TargetAnnotation >  >  (  )  ;", "final   Map < DotName ,    List < ClassAnnotationInformationFactory . TargetAnnotation >  >    fieldLevel    =    new   HashMap < DotName ,    List < ClassAnnotationInformationFactory . TargetAnnotation >  >  (  )  ;", "for    ( ClassAnnotationInformationFactory . TargetAnnotation   instance    :    annotations )     {", "final   DotName   targetClass    =    getAnnotationClass ( instance . target (  )  )  . name (  )  ;", "if    (  ( instance . target (  )  )    instanceof   ClassInfo )     {", "List < ClassAnnotationInformationFactory . TargetAnnotation >    data    =    classLevel . get ( targetClass )  ;", "if    ( data    =  =    null )", "classLevel . put ( targetClass ,     ( data    =    new   ArrayList < ClassAnnotationInformationFactory . TargetAnnotation >  (  1  )  )  )  ;", "data . add ( instance )  ;", "} else", "if    (  ( instance . target (  )  )    instanceof   MethodInfo )     {", "List < ClassAnnotationInformationFactory . TargetAnnotation >    data    =    methodLevel . get ( targetClass )  ;", "if    ( data    =  =    null )", "methodLevel . put ( targetClass ,     ( data    =    new   ArrayList < ClassAnnotationInformationFactory . TargetAnnotation >  (  1  )  )  )  ;", "data . add ( instance )  ;", "} else", "if    (  ( instance . target (  )  )    instanceof   FieldInfo )     {", "List < ClassAnnotationInformationFactory . TargetAnnotation >    data    =    fieldLevel . get ( targetClass )  ;", "if    ( data    =  =    null )", "fieldLevel . put ( targetClass ,     ( data    =    new   ArrayList < ClassAnnotationInformationFactory . TargetAnnotation >  (  1  )  )  )  ;", "data . add ( instance )  ;", "} else", "if    (  ( instance . target (  )  )    instanceof   MethodParameterInfo )     {", "} else    {", "throw   unknownAnnotationTargetType ( instance . target (  )  )  ;", "}", "}", "final   Map < String ,    ClassAnnotationInformation < A ,    T >  >    ret    =    new   HashMap < String ,    ClassAnnotationInformation < A ,    T >  >  (  )  ;", "final   Set < DotName >    allClasses    =    new   HashSet < DotName >  ( classLevel . keySet (  )  )  ;", "allClasses . addAll ( methodLevel . keySet (  )  )  ;", "allClasses . addAll ( fieldLevel . keySet (  )  )  ;", "for    ( DotName   clazz    :    allClasses )     {", "final   List < ClassAnnotationInformationFactory . TargetAnnotation >    classAnnotations    =    classLevel . get ( clazz )  ;", "final   List < T >    classData ;", "if    ( classAnnotations    =  =    null )     {", "classData    =    Collections . emptyList (  )  ;", "} else    {", "classData    =    new   ArrayList < T >  ( classAnnotations . size (  )  )  ;", "for    ( ClassAnnotationInformationFactory . TargetAnnotation   instance    :    classAnnotations )     {", "classData . add ( fromAnnotation ( instance . instance (  )  ,    propertyReplacer )  )  ;", "}", "}", "final   List < ClassAnnotationInformationFactory . TargetAnnotation >    fieldAnnotations    =    fieldLevel . get ( clazz )  ;", "final   Map < String ,    List < T >  >    fieldData ;", "if    ( fieldAnnotations    =  =    null )     {", "fieldData    =    Collections . emptyMap (  )  ;", "} else    {", "fieldData    =    new   HashMap < String ,    List < T >  >  (  )  ;", "for    ( ClassAnnotationInformationFactory . TargetAnnotation   instance    :    fieldAnnotations )     {", "final   String   name    =     (  ( FieldInfo )     ( instance . target (  )  )  )  . name (  )  ;", "List < T >    data    =    fieldData . get ( name )  ;", "if    ( data    =  =    null )     {", "fieldData . put ( name ,     ( data    =    new   ArrayList < T >  (  1  )  )  )  ;", "}", "data . add ( fromAnnotation ( instance . instance (  )  ,    propertyReplacer )  )  ;", "}", "}", "final   List < ClassAnnotationInformationFactory . TargetAnnotation >    methodAnnotations    =    methodLevel . get ( clazz )  ;", "final   Map < MethodIdentifier ,    List < T >  >    methodData ;", "if    ( methodAnnotations    =  =    null )     {", "methodData    =    Collections . emptyMap (  )  ;", "} else    {", "methodData    =    new   HashMap < MethodIdentifier ,    List < T >  >  (  )  ;", "for    ( ClassAnnotationInformationFactory . TargetAnnotation   instance    :    methodAnnotations )     {", "final   MethodIdentifier   identifier    =    getMethodIdentifier ( instance . target (  )  )  ;", "List < T >    data    =    methodData . get ( identifier )  ;", "if    ( data    =  =    null )     {", "methodData . put ( identifier ,     ( data    =    new   ArrayList < T >  (  1  )  )  )  ;", "}", "data . add ( fromAnnotation ( instance . instance (  )  ,    propertyReplacer )  )  ;", "}", "}", "ClassAnnotationInformation < A ,    T >    information    =    new   ClassAnnotationInformation < A ,    T >  ( annotationType ,    classData ,    methodData ,    fieldData )  ;", "ret . put ( clazz . toString (  )  ,    information )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["createAnnotationInformation"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformationFactory"}, {"methodBody": ["METHOD_START", "{", "List < ClassAnnotationInformationFactory . TargetAnnotation >    instances    =    new   ArrayList < ClassAnnotationInformationFactory . TargetAnnotation >  (  )  ;", "final   AnnotationInstance [  ]    values    =    multiAnnotationInstance . value (  )  . asNestedArray (  )  ;", "for    ( AnnotationInstance   value    :    values )     {", "instances . add ( new   ClassAnnotationInformationFactory . TargetAnnotation ( value ,    multiAnnotationInstance . target (  )  )  )  ;", "}", "return   instances ;", "}", "METHOD_END"], "methodName": ["fromMultiAnnotation"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformationFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( annotationTarget   instanceof   ClassInfo )     {", "return    (  ( ClassInfo )     ( annotationTarget )  )  ;", "} else", "if    ( annotationTarget   instanceof   MethodInfo )     {", "return    (  ( MethodInfo )     ( annotationTarget )  )  . declaringClass (  )  ;", "} else", "if    ( annotationTarget   instanceof   FieldInfo )     {", "return    (  ( FieldInfo )     ( annotationTarget )  )  . declaringClass (  )  ;", "} else", "if    ( annotationTarget   instanceof   MethodParameterInfo )     {", "return    (  ( MethodParameterInfo )     ( annotationTarget )  )  . method (  )  . declaringClass (  )  ;", "} else    {", "throw   logging . EeLogger . ROOT _ LOGGER . unknownAnnotationTargetType ( annotationTarget )  ;", "}", "}", "METHOD_END"], "methodName": ["getAnnotationClass"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformationFactory"}, {"methodBody": ["METHOD_START", "{", "return   annotationType ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformationFactory"}, {"methodBody": ["METHOD_START", "{", "final   MethodInfo   methodInfo    =    MethodInfo . class . cast ( target )  ;", "final   String [  ]    args    =    new   String [ methodInfo . args (  )  . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( methodInfo . args (  )  . length )  ;    i +  +  )     {", "args [ i ]     =    methodInfo . args (  )  [ i ]  . name (  )  . toString (  )  ;", "}", "return   MethodIdentifier . getIdentifier ( methodInfo . returnType (  )  . name (  )  . toString (  )  ,    methodInfo . name (  )  ,    args )  ;", "}", "METHOD_END"], "methodName": ["getMethodIdentifier"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformationFactory"}, {"methodBody": ["METHOD_START", "{", "return   multiAnnotationType ;", "}", "METHOD_END"], "methodName": ["getMultiAnnotationType"], "fileName": "org.jboss.as.ee.metadata.ClassAnnotationInformationFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( outboundConnectionRef    =  =    null )     |  |     ( outboundConnectionRef . trim (  )  . isEmpty (  )  )  )     {", "throw   new   IllegalArgumentException (  \" Cannot   add   a   remoting   receiver   which   references   a   null / empty   outbound   connection \"  )  ;", "}", "final    . RemotingReceiverConfiguration   remotingReceiverConfiguration    =    new    . RemotingReceiverConfiguration ( outboundConnectionRef )  ;", "this . remotingReceiverConfigurations . put ( outboundConnectionRef ,    remotingReceiverConfiguration )  ;", "return   remotingReceiverConfiguration ;", "}", "METHOD_END"], "methodName": ["addRemotingReceiverConnectionRef"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . clusterConfigs )  ;", "}", "METHOD_END"], "methodName": ["getClusterConfigs"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . deploymentNodeSelector ;", "}", "METHOD_END"], "methodName": ["getDeploymentNodeSelector"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . invocationTimeout ;", "}", "METHOD_END"], "methodName": ["getInvocationTimeout"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . profile ;", "}", "METHOD_END"], "methodName": ["getProfile"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . remotingReceiverConfigurations . values (  )  ;", "}", "METHOD_END"], "methodName": ["getRemotingReceiverConfigurations"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . excludeLocalReceiver ;", "}", "METHOD_END"], "methodName": ["isLocalReceiverExcluded"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . localReceiverPassByValue ;", "}", "METHOD_END"], "methodName": ["isLocalReceiverPassByValue"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "final   EJBClientDescriptorMetaData . ClusterConfig   clusterConfig    =    new   EJBClientDescriptorMetaData . ClusterConfig ( clusterName )  ;", "this . clusterConfigs . add ( clusterConfig )  ;", "return   clusterConfig ;", "}", "METHOD_END"], "methodName": ["newClusterConfig"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "this . deploymentNodeSelector    =    selector ;", "}", "METHOD_END"], "methodName": ["setDeploymentNodeSelector"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "this . excludeLocalReceiver    =    excludeLocalReceiver ;", "}", "METHOD_END"], "methodName": ["setExcludeLocalReceiver"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "this . invocationTimeout    =    invocationTimeout ;", "}", "METHOD_END"], "methodName": ["setInvocationTimeout"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "this . localReceiverPassByValue    =    passByValue ;", "}", "METHOD_END"], "methodName": ["setLocalReceiverPassByValue"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "this . profile    =    profile ;", "}", "METHOD_END"], "methodName": ["setProfile"], "fileName": "org.jboss.as.ee.metadata.EJBClientDescriptorMetaData"}, {"methodBody": ["METHOD_START", "{", "final   Boolean   marker    =    deploymentUnit . getAttachment ( MetadataCompleteMarker . KEY )  ;", "return    ( marker    !  =    null )     &  &    marker ;", "}", "METHOD_END"], "methodName": ["isMetadataComplete"], "fileName": "org.jboss.as.ee.metadata.MetadataCompleteMarker"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . putAttachment ( MetadataCompleteMarker . KEY ,    value )  ;", "}", "METHOD_END"], "methodName": ["setMetadataComplete"], "fileName": "org.jboss.as.ee.metadata.MetadataCompleteMarker"}, {"methodBody": ["METHOD_START", "{", "final   HashSet < MethodIdentifier >    methodIdentifiers    =    new   HashSet < MethodIdentifier >  (  )  ;", "final   Map < Method ,    List < T >  >    methods    =    new   HashMap < Method ,    List < T >  >  (  )  ;", "final   Map < String ,    List < T >  >    classs    =    new   HashMap < String ,    List < T >  >  (  )  ;", "Class <  ?  >    c    =    componentClass ;", "while    (  ( c    !  =    null )     &  &     ( c    !  =     ( Object . class )  )  )     {", "final   ClassReflectionIndex   classIndex    =    index . getClassIndex ( c )  ;", "final   EEModuleClassDescription   description    =    applicationClasses . getClassByName ( c . getName (  )  )  ;", "if    ( description    !  =    null )     {", "ClassInformation < A ,    T >    annotationData    =    description . getInformation ( annotationType )  ;", "if    ( annotationData    !  =    null )     {", "if    (  !  ( annotationData . getClassLevels (  )  . isEmpty (  )  )  )     {", "classs . put ( c . getName (  )  ,    annotationData . getClassLevels (  )  )  ;", "}", "for    ( Map . Entry < MethodIdentifier ,    List < T >  >    entry    :    annotationData . getMethodLevels (  )  . entrySet (  )  )     {", "final   Method   method    =    classIndex . getMethod ( entry . getKey (  )  )  ;", "if    ( method    !  =    null )     {", "if    (  ( Modifier . isPrivate ( method . getModifiers (  )  )  )     |  |     (  !  ( methodIdentifiers . contains ( entry . getKey (  )  )  )  )  )     {", "methods . put ( method ,    entry . getValue (  )  )  ;", "}", "} else    {", "throw   EeLogger . ROOT _ LOGGER . cannotResolveMethod ( entry . getKey (  )  ,    c ,    entry . getValue (  )  )  ;", "}", "}", "}", "}", "for    ( Method   method    :     (  ( Iterable < Method >  )     ( classIndex . getMethods (  )  )  )  )     {", "if    (  !  ( Modifier . isPrivate ( method . getModifiers (  )  )  )  )     {", "methodIdentifiers . add ( MethodIdentifier . getIdentifierForMethod ( method )  )  ;", "}", "}", "c    =    c . getSuperclass (  )  ;", "}", "return   new   RuntimeInformation < T >  ( classs ,    methods )  ;", "}", "METHOD_END"], "methodName": ["runtimeAnnotationInformation"], "fileName": "org.jboss.as.ee.metadata.MethodAnnotationAggregator"}, {"methodBody": ["METHOD_START", "{", "RuntimeAnnotationInformation < Object >    result    =    MethodAnnotationAggregator . runtimeAnnotationInformation ( componentClass ,    applicationClasses ,    index ,    annotationType )  ;", "return   result . getMethodAnnotations (  )  . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["runtimeAnnotationPresent"], "fileName": "org.jboss.as.ee.metadata.MethodAnnotationAggregator"}, {"methodBody": ["METHOD_START", "{", "return   classAnnotations ;", "}", "METHOD_END"], "methodName": ["getClassAnnotations"], "fileName": "org.jboss.as.ee.metadata.RuntimeAnnotationInformation"}, {"methodBody": ["METHOD_START", "{", "return   methodAnnotations ;", "}", "METHOD_END"], "methodName": ["getMethodAnnotations"], "fileName": "org.jboss.as.ee.metadata.RuntimeAnnotationInformation"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    ( deploymentUnit . hasAttachment ( Attachments . DEPLOYMENT _ PROPERTIES )  )     {", "return ;", "}", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   VirtualFile   deploymentFile    =    deploymentRoot . getRoot (  )  ;", "final   VirtualFile   propertiesFile    =    deploymentFile . getChild (  . DEPLOYMENT _ PROPERTIES )  ;", "if    (  !  ( propertiesFile . exists (  )  )  )     {", "return ;", "}", "Properties   properties    =    new   Properties (  )  ;", "InputStream   propertyFileStream    =    null ;", "try    {", "propertyFileStream    =    propertiesFile . openStream (  )  ;", "properties . load ( propertyFileStream )  ;", "}    catch    ( IOException   e )     {", "throw   EeLogger . ROOT _ LOGGER . failedToLoadJbossProperties ( e )  ;", "}    finally    {", "VFSUtils . safeClose ( propertyFileStream )  ;", "}", "deploymentUnit . putAttachment ( Attachments . DEPLOYMENT _ PROPERTIES ,    properties )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.metadata.property.DeploymentPropertiesProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "DeploymentUnit   current    =    deploymentUnit ;", "final   List < PropertyResolver >    propertyResolvers    =    new   ArrayList < PropertyResolver >  (  )  ;", "do    {", "final   Properties   deploymentProperties    =    current . getAttachment ( Attachments . DEPLOYMENT _ PROPERTIES )  ;", "if    ( deploymentProperties    !  =    null )     {", "propertyResolvers . add ( new   PropertiesPropertyResolver ( deploymentProperties )  )  ;", "}", "current    =    current . getParent (  )  ;", "}    while    ( current    !  =    null    )  ;", "if    (  !  ( propertyResolvers . isEmpty (  )  )  )     {", "deploymentUnit . addToAttachmentList ( Attachments . DEPLOYMENT _ PROPERTY _ RESOLVERS ,    new   jbossCompositePropertyResolver ( propertyResolvers )  )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.metadata.property.DeploymentPropertyResolverProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "Composite   propertyResolver    =    new   Composite ( deploymentUnit . getAttachment ( Attachments . DEPLOYMENT _ PROPERTY _ RESOLVERS )  )  ;", "deploymentUnit . putAttachment ( Attachments . FINAL _ PROPERTY _ RESOLVER ,    propertyResolver )  ;", "deploymentUnit . putAttachment ( Attachments . FINAL _ PROPERTY _ REPLACER ,    PropertyReplacers . resolvingReplacer ( propertyResolver )  )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.metadata.property.PropertyResolverProcessor"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . removeAttachment ( Attachments . FINAL _ PROPERTY _ REPLACER )  ;", "deploymentUnit . removeAttachment ( Attachments . FINAL _ PROPERTY _ RESOLVER )  ;", "deploymentUnit . removeAttachment ( Attachments . DEPLOYMENT _ PROPERTY _ RESOLVERS )  ;", "}", "METHOD_END"], "methodName": ["undeploy"], "fileName": "org.jboss.as.ee.metadata.property.PropertyResolverProcessor"}, {"methodBody": ["METHOD_START", "{", "phaseContext . getDeploymentUnit (  )  . addToAttachmentList ( Attachments . DEPLOYMENT _ PROPERTY _ RESOLVERS ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.metadata.property.SystemPropertyResolverProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( vaultReader . isVaultFormat ( propertyName )  )     {", "return   vaultReader . retrieveFromVault ( propertyName )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.jboss.as.ee.metadata.property.VaultPropertyResolver"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   AbstractVaultReader   vaultReader    =    deploymentUnit . getAttachment ( VAULT _ READER _ ATTACHMENT _ KEY )  ;", "if    ( vaultReader    !  =    null )     {", "deploymentUnit . addToAttachmentList ( Attachments . DEPLOYMENT _ PROPERTY _ RESOLVERS ,    new    ( vaultReader )  )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.metadata.property.VaultPropertyResolverProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "return ;", "}", "EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   ServiceTarget   serviceTarget    =    phaseContext . getServiceTarget (  )  ;", "final   ServiceName   aServiceName    =    ContextNames . contextServiceNameOfApplication ( moduleDescription . getApplicationName (  )  )  ;", "final   NamingStoreService   contextService    =    new   NamingStoreService ( true )  ;", "serviceTarget . addService ( aServiceName ,    contextService )  . install (  )  ;", "final   BinderService   applicationNameBinder    =    new   BinderService (  \" AppName \"  )  ;", "final   ServiceName   appNameServiceName    =    aServiceName . append (  \" AppName \"  )  ;", "serviceTarget . addService ( appNameServiceName ,    applicationNameBinder )  . addDependency ( aServiceName ,    ServiceBasedNamingStore . class ,    applicationNameBinder . getNamingStoreInjector (  )  )  . addInjection ( applicationNameBinder . getManagedObjectInjector (  )  ,    new   ValueManagedReferenceFactory ( Values . immediateValue ( moduleDescription . getApplicationName (  )  )  )  )  . install (  )  ;", "deploymentUnit . addToAttachmentList ( JNDI _ DEPENDENCIES ,    appNameServiceName )  ;", "deploymentUnit . putAttachment ( Attachments . APPLICATION _ CONTEXT _ CONFIG ,    aServiceName )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.naming.ApplicationContextProcessor"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . removeAttachment ( Attachments . APPLICATION _ CONTEXT _ CONFIG )  ;", "}", "METHOD_END"], "methodName": ["undeploy"], "fileName": "org.jboss.as.ee.naming.ApplicationContextProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   inAppClientServiceName    =    contextServiceName . append (  \" InAppClientContainer \"  )  ;", "BinderService   inAppClientContainerService    =    new   BinderService (  \" InAppClientContainer \"  )  ;", "serviceTarget . addService ( inAppClientServiceName ,    inAppClientContainerService )  . addInjection ( inAppClientContainerService . getManagedObjectInjector (  )  ,    new   naming . ValueManagedReferenceFactory ( Values . immediateValue ( appclient )  )  )  . addDependency ( contextServiceName ,    ServiceBasedNamingStore . class ,    inAppClientContainerService . getNamingStoreInjector (  )  )  . install (  )  ;", "deploymentUnit . addToAttachmentList ( JNDI _ DEPENDENCIES ,    inAppClientServiceName )  ;", "}", "METHOD_END"], "methodName": ["bindServices"], "fileName": "org.jboss.as.ee.naming.InApplicationClientBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "return   appContext ;", "}", "METHOD_END"], "methodName": ["getAppContextInjector"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "return   compContext ;", "}", "METHOD_END"], "methodName": ["getCompContextInjector"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "NamingStore   namingStore    =    getNamingStore ( identifier )  ;", "if    ( namingStore    !  =    null )     {", "try    {", "return    (  ( Context )     ( namingStore . lookup (  . EMPTY _ NAME )  )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "return   exportedContext ;", "}", "METHOD_END"], "methodName": ["getExportedContextInjector"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "return   globalContext ;", "}", "METHOD_END"], "methodName": ["getGlobalContextInjector"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "return   jbossContext ;", "}", "METHOD_END"], "methodName": ["getJbossContextInjector"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "return   moduleContext ;", "}", "METHOD_END"], "methodName": ["getModuleContextInjector"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "if    ( identifier . equals (  \" jboss \"  )  )     {", "return   jbossContext . getOptionalValue (  )  ;", "} else", "if    ( identifier . equals (  \" global \"  )  )     {", "return   globalContext . getOptionalValue (  )  ;", "} else", "if    ( identifier . equals (  \" app \"  )  )     {", "return   appContext . getOptionalValue (  )  ;", "} else", "if    ( identifier . equals (  \" module \"  )  )     {", "return   modul . getOptionalValue (  )  ;", "} else", "if    ( identifier . equals (  \" comp \"  )  )     {", "return   compContext . getOptionalValue (  )  ;", "} else", "if    ( identifier . equals (  \" jboss / exported \"  )  )     {", "return   exportedContext . getOptionalValue (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getNamingStore"], "fileName": "org.jboss.as.ee.naming.InjectedEENamespaceContextSelector"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   instanceNameServiceName    =    contextServiceName . append (  \" InstanceName \"  )  ;", "final   BinderService   instanceNameService    =    new   BinderService (  \" InstanceName \"  )  ;", "serviceTarget . addService ( instanceNameServiceName ,    instanceNameService )  . addDependency ( contextServiceName ,    ServiceBasedNamingStore . class ,    instanceNameService . getNamingStoreInjector (  )  )  . addDependency ( SERVICE _ NAME ,    ServerEnvironment . class ,    new   Injector < ServerEnvironment >  (  )     {", "@ Override", "public   void   inject ( final   ServerEnvironment   serverEnvironment )    throws   InjectionException    {", "instanceNameService . getManagedObjectInjector (  )  . inject ( new   naming . ManagedReferenceFactory (  )     {", "@ Override", "public   naming . ManagedReference   getReference (  )     {", "return   new   naming . ManagedReference (  )     {", "@ Override", "public   void   release (  )     {", "}", "@ Override", "public   Object   getInstance (  )     {", "final   String   nodeName    =    serverEnvironment . getNodeName (  )  ;", "return   nodeName    =  =    null    ?     \"  \"     :    nodeName ;", "}", "}  ;", "}", "}  )  ;", "}", "@ Override", "public   void   uninject (  )     {", "instanceNameService . getManagedObjectInjector (  )  . uninject (  )  ;", "}", "}  )  . install (  )  ;", "deploymentUnit . addToAttachmentList ( JNDI _ DEPENDENCIES ,    instanceNameServiceName )  ;", "}", "METHOD_END"], "methodName": ["bindServices"], "fileName": "org.jboss.as.ee.naming.InstanceNameBindingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    ( DeploymentTypeMarker . isType ( DeploymentType . EAR ,    deploymentUnit )  )     {", "return ;", "}", "EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   ServiceTarget   serviceTarget    =    phaseContext . getServiceTarget (  )  ;", "final   ServiceName   appContextServiceName    =    ContextNames . contextServiceNameOfApplication ( moduleDescription . getApplicationName (  )  )  ;", "final   ServiceName   moduleContextServiceName    =    ContextNames . contextServiceNameOfModule ( moduleDescription . getApplicationName (  )  ,    moduleDescription . getModuleName (  )  )  ;", "final   NamingStoreService   contextService    =    new   NamingStoreService ( true )  ;", "serviceTarget . addService ( moduleContextServiceName ,    contextService )  . install (  )  ;", "final   BinderService   moduleNameBinder    =    new   BinderService (  \" ModuleName \"  )  ;", "final   ServiceName   moduleNameServiceName    =    moduleContextServiceName . append (  \" ModuleName \"  )  ;", "serviceTarget . addService ( moduleNameServiceName ,    moduleNameBinder )  . addInjection ( moduleNameBinder . getManagedObjectInjector (  )  ,    new   naming . ValueManagedReferenceFactory ( Values . immediateValue ( moduleDescription . getModuleName (  )  )  )  )  . addDependency ( moduleContextServiceName ,    ServiceBasedNamingStore . class ,    moduleNameBinder . getNamingStoreInjector (  )  )  . install (  )  ;", "deploymentUnit . addToAttachmentList ( JNDI _ DEPENDENCIES ,    moduleNameServiceName )  ;", "deploymentUnit . putAttachment ( Attachments . MODULE _ CONTEXT _ CONFIG ,    moduleContextServiceName )  ;", "final   InjectedEENamespaceContextSelector   selector    =    new   InjectedEENamespaceContextSelector (  )  ;", "phaseContext . addDependency ( appContextServiceName ,    NamingStore . class ,    selector . getAppContextInjector (  )  )  ;", "phaseContext . addDependency ( moduleContextServiceName ,    NamingStore . class ,    selector . getModuleContextInjector (  )  )  ;", "phaseContext . addDependency ( moduleContextServiceName ,    NamingStore . class ,    selector . getCompContextInjector (  )  )  ;", "phaseContext . addDependency ( JBOSS _ CONTEXT _ SERVICE _ NAME ,    NamingStore . class ,    selector . getJbossContextInjector (  )  )  ;", "phaseContext . addDependency ( EXPORTED _ CONTEXT _ SERVICE _ NAME ,    NamingStore . class ,    selector . getExportedContextInjector (  )  )  ;", "phaseContext . addDependency ( GLOBAL _ CONTEXT _ SERVICE _ NAME ,    NamingStore . class ,    selector . getGlobalContextInjector (  )  )  ;", "moduleDescription . setNamespaceContextSelector ( selector )  ;", "final   Set < ServiceName >    serviceNames    =    new   HashSet < ServiceName >  (  )  ;", "serviceNames . add ( appContextServiceName )  ;", "serviceNames . add ( moduleContextServiceName )  ;", "serviceNames . add ( JBOSS _ CONTEXT _ SERVICE _ NAME )  ;", "serviceNames . add ( GLOBAL _ CONTEXT _ SERVICE _ NAME )  ;", "final   JavaNamespaceSetup   setupAction    =    new   JavaNamespaceSetup ( selector ,    deploymentUnit . getServiceName (  )  )  ;", "deploymentUnit . addToAttachmentList ( server . deployment . Attachments . SETUP _ ACTIONS ,    setupAction )  ;", "deploymentUnit . addToAttachmentList ( Attachments . WEB _ SETUP _ ACTIONS ,    setupAction )  ;", "deploymentUnit . putAttachment ( Attachments . JAVA _ NAMESPACE _ SETUP _ ACTION ,    setupAction )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.naming.ModuleContextProcessor"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . removeAttachment ( Attachments . JAVA _ NAMESPACE _ SETUP _ ACTION )  ;", "deploymentUnit . getAttachmentList ( component . Attachments . WEB _ SETUP _ ACTIONS )  . removeIf (  (    setupAction )     -  >    setupAction   instanceof   JavaNamespaceSetup )  ;", "deploymentUnit . getAttachmentList ( SETUP _ ACTIONS )  . removeIf (  (    setupAction )     -  >    setupAction   instanceof   JavaNamespaceSetup )  ;", "deploymentUnit . removeAttachment ( Attachments . MODULE _ CONTEXT _ CONFIG )  ;", "}", "METHOD_END"], "methodName": ["undeploy"], "fileName": "org.jboss.as.ee.naming.ModuleContextProcessor"}, {"methodBody": ["METHOD_START", "{", "final   AnnotationTarget   target    =    annotationInstance . target (  )  ;", "if    (  !  ( target   instanceof   ClassInfo )  )     {", "throw   EeLogger . ROOT _ LOGGER . classOnlyAnnotation ( annotationInstance . toString (  )  ,    target )  ;", "}", "final   ClassInfo   classInfo    =     (  ( ClassInfo )     ( target )  )  ;", "return   moduleDescription . addOrGetLocalClassDescription ( classInfo . name (  )  . toString (  )  )  . getBindingConfigurations (  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotatedClassBindingConfigurations"], "fileName": "org.jboss.as.ee.resource.definition.ResourceDefinitionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "addProperties ( annotationProperties ,    null )  ;", "}", "METHOD_END"], "methodName": ["addProperties"], "fileName": "org.jboss.as.ee.resource.definition.ResourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    ( annotationProperties    !  =    null )     {", "for    ( String   annotationProperty    :    annotationProperties )     {", "if    ( propertyReplacer    !  =    null )     {", "annotationProperty    =    propertyReplacer . replaceProperties ( annotationProperty )  ;", "}", "final   int   index    =    annotationProperty . indexOf (  '  =  '  )  ;", "String   propertyName ;", "String   propertyValue ;", "if    ( index    !  =     (  -  1  )  )     {", "propertyName    =    annotationProperty . substring (  0  ,    index )  ;", "propertyValue    =     (  ( annotationProperty . length (  )  )     >    index )     ?    annotationProperty . substring (  ( index    +     1  )  ,    annotationProperty . length (  )  )     :     \"  \"  ;", "} else    {", "propertyName    =    annotationProperty ;", "propertyValue    =     \"  \"  ;", "}", "this . properties . put ( propertyName ,    propertyValue )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addProperties"], "fileName": "org.jboss.as.ee.resource.definition.ResourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    ( descriptorProperties    !  =    null )     {", "for    ( PropertyMetaData   descriptorProperty    :    descriptorProperties )     {", "this . properties . put ( descriptorProperty . getName (  )  ,    descriptorProperty . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addProperties"], "fileName": "org.jboss.as.ee.resource.definition.ResourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   jndiName ;", "}", "METHOD_END"], "methodName": ["getJndiName"], "fileName": "org.jboss.as.ee.resource.definition.ResourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . annotationPropertyReplacement    =    annotationPropertyReplacement ;", "}", "METHOD_END"], "methodName": ["setDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.structure.AnnotationPropertyReplacementProcessor"}, {"methodBody": ["METHOD_START", "{", "DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ComponentRegistry   componentRegistry    =    new   ComponentRegistry ( phaseContext . getServiceRegistry (  )  )  ;", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "if    ( moduleDescription    =  =    null )     {", "return ;", "}", "phaseContext . getServiceTarget (  )  . addService ( ComponentRegistry . serviceName ( deploymentUnit )  ,    new   ValueService ( new   ImmediateValue < Object >  ( componentRegistry )  )  )  . addDependency ( moduleDescription . getDefaultClassIntrospectorServiceName (  )  ,    EEClassIntrospector . class ,    componentRegistry . getClassIntrospectorInjectedValue (  )  )  . install (  )  ;", "deploymentUnit . putAttachment ( Attachments . COMPONENT _ REGISTRY ,    componentRegistry )  ;", "if    (  ( deploymentUnit . getAttachment ( Attachments . DEPLOYMENT _ TYPE )  )     =  =     ( DeploymentType . EAR )  )     {", "final   EEApplicationDescription   applicationDescription    =    new   EEApplicationDescription (  )  ;", "deploymentUnit . putAttachment ( Attachments . EE _ APPLICATION _ DESCRIPTION ,    applicationDescription )  ;", "for    ( final   Map . Entry < String ,    String >    messageDestination    :    moduleDescription . getMessageDestinations (  )  . entrySet (  )  )     {", "applicationDescription . addMessageDestination ( messageDestination . getKey (  )  ,    messageDestination . getValue (  )  ,    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  . getRoot (  )  )  ;", "}", "final   List < DeploymentUnit >    subdeployments    =    deploymentUnit . getAttachmentList ( server . deployment . Attachments . SUB _ DEPLOYMENTS )  ;", "for    ( final   DeploymentUnit   subdeployment    :    subdeployments )     {", "final   EEModuleDescription   subDeploymentModuleDescription    =    subdeployment . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "final   ResourceRoot   deploymentRoot    =    subdeployment . getAttachment ( DEPLOYMENT _ ROOT )  ;", "if    ( subDeploymentModuleDescription    =  =    null )     {", "continue ;", "}", "for    ( final   ComponentDescription   componentDescription    :    subDeploymentModuleDescription . getComponentDescriptions (  )  )     {", "applicationDescription . addComponent ( componentDescription ,    deploymentRoot . getRoot (  )  )  ;", "}", "for    ( final   Map . Entry < String ,    String >    messageDestination    :    subDeploymentModuleDescription . getMessageDestinations (  )  . entrySet (  )  )     {", "applicationDescription . addMessageDestination ( messageDestination . getKey (  )  ,    messageDestination . getValue (  )  ,    deploymentRoot . getRoot (  )  )  ;", "}", "for    ( final   ComponentDescription   componentDescription    :    subdeployment . getAttachmentList ( Attachments . ADDITIONAL _ RESOLVABLE _ COMPONENTS )  )     {", "applicationDescription . addComponent ( componentDescription ,    deploymentRoot . getRoot (  )  )  ;", "}", "subdeployment . putAttachment ( Attachments . EE _ APPLICATION _ DESCRIPTION ,    applicationDescription )  ;", "}", "} else", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "final   EEApplicationDescription   applicationDescription    =    new   EEApplicationDescription (  )  ;", "deploymentUnit . putAttachment ( Attachments . EE _ APPLICATION _ DESCRIPTION ,    applicationDescription )  ;", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "for    ( final   ComponentDescription   componentDescription    :    moduleDescription . getComponentDescriptions (  )  )     {", "applicationDescription . addComponent ( componentDescription ,    deploymentRoot . getRoot (  )  )  ;", "}", "for    ( final   Map . Entry < String ,    String >    messageDestination    :    moduleDescription . getMessageDestinations (  )  . entrySet (  )  )     {", "applicationDescription . addMessageDestination ( messageDestination . getKey (  )  ,    messageDestination . getValue (  )  ,    deploymentRoot . getRoot (  )  )  ;", "}", "for    ( final   ComponentDescription   componentDescription    :    deploymentUnit . getAttachmentList ( Attachments . ADDITIONAL _ RESOLVABLE _ COMPONENTS )  )     {", "applicationDescription . addComponent ( componentDescription ,    deploymentRoot . getRoot (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.structure.ComponentAggregationProcessor"}, {"methodBody": ["METHOD_START", "{", "return   deploymentType    =  =     ( deploymentUnit . getAttachment ( Attachments . DEPLOYMENT _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["isType"], "fileName": "org.jboss.as.ee.structure.DeploymentTypeMarker"}, {"methodBody": ["METHOD_START", "{", "return   deploymentType    =  =     ( resourceRoot . getAttachment ( Attachments . DEPLOYMENT _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["isType"], "fileName": "org.jboss.as.ee.structure.DeploymentTypeMarker"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . putAttachment ( Attachments . DEPLOYMENT _ TYPE ,    deploymentType )  ;", "final   ResourceRoot   resourceRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "if    ( resourceRoot    !  =    null )     {", "resourceRoot . putAttachment ( Attachments . DEPLOYMENT _ TYPE ,    deploymentType )  ;", "}", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.jboss.as.ee.structure.DeploymentTypeMarker"}, {"methodBody": ["METHOD_START", "{", "this . descriptorPropertyReplacement    =    descriptorPropertyReplacement ;", "}", "METHOD_END"], "methodName": ["setDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.structure.DescriptorPropertyReplacementProcessor"}, {"methodBody": ["METHOD_START", "{", "Boolean   replacement    =    deploymentUnit . getAttachment ( Attachments . ANNOTATION _ PROPERTY _ REPLACEMENT )  ;", "if    (  ( replacement    =  =    null )     |  |    replacement )     {", "PropertyReplacer   replacer    =    deploymentUnit . getAttachment ( metadata . property . Attachments . FINAL _ PROPERTY _ REPLACER )  ;", "return   replacer    !  =    null    ?    replacer    :    PropertyReplacers . noop (  )  ;", "} else    {", "return   PropertyReplacers . noop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyReplacer"], "fileName": "org.jboss.as.ee.structure.EJBAnnotationPropertyReplacement"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   b    =    new   StringBuilder (  \" Missing   one   or   more   required   attributes :  \"  )  ;", "for    ( XMLAttribute   attribute    :    required )     {", "b . append (  '     '  )  . append ( attribute )  ;", "}", "throw   EeLogger . ROOT _ LOGGER . errorParsing ( b . toString (  )  ,    location )  ;", "}", "METHOD_END"], "methodName": ["missingAttributes"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "final   Set < EJBClientDescriptorXMLElement >    visited    =    EnumSet . noneOf ( EJBClientDescriptorXMLElement . class )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "if    ( visited . contains ( element )  )     {", ". unexpectedElement ( reader )  ;", "}", "visited . add ( element )  ;", "switch    ( element )     {", "case   EJB _ RECEIVERS    :", "this . parseEJBReceivers ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "default    :", ". unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", ". unexpectedContent ( reader )  ;", "}", "}", "}", ". unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseClientContext"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "Boolean   localReceiverPassByValue    =    null ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "final   String   value    =    readResolveValue ( reader ,    i )  ;", "switch    ( attribute )     {", "case   EXCLUDE _ LOCAL _ RECEIVER    :", "final   boolean   excludeLocalReceiver    =    Boolean . parseBoolean ( value )  ;", "ejbClientDescriptorMetaData . setExcludeLocalReceiver ( excludeLocalReceiver )  ;", "break ;", "case   LOCAL _ RECEIVER _ PASS _ BY _ VALUE    :", "localReceiverPassByValue    =    Boolean . parseBoolean ( value )  ;", "break ;", "default    :", ". unexpectedContent ( reader )  ;", "}", "}", "ejbClientDescriptorMetaData . setLocalReceiverPassByValue ( localReceiverPassByValue )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   REMOTING _ EJB _ RECEIVER    :", "this . parseRemotingReceiver ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "default    :", ". unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", ". unexpectedContent ( reader )  ;", "}", "}", "}", ". unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseEJBReceivers"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "String   outboundConnectionRef    =    null ;", "final   Set < EJBClientDescriptorXMLAttribute >    required    =    EnumSet . of ( EJBClientDescriptorXMLAttribute . OUTBOUND _ CONNECTION _ REF )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   OUTBOUND _ CONNECTION _ REF    :", "outboundConnectionRef    =    readResolveValue ( reader ,    i )  ;", "ejbClientDescriptorMetaData . addRemotingReceiverConnectionRef ( outboundConnectionRef )  ;", "break ;", "default    :", ". unexpectedContent ( reader )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", ". missingAttributes ( reader . getLocation (  )  ,    required )  ;", "}", "if    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", ". unexpectedContent ( reader )  ;", "}", "}", "METHOD_END"], "methodName": ["parseRemotingReceiver"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "return   propertyReplacer . replaceProperties ( reader . getAttributeValue ( index )  . trim (  )  )  ;", "}", "METHOD_END"], "methodName": ["readResolveValue"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "final   String   kind ;", "switch    ( reader . getEventType (  )  )     {", "case   XMLStreamConstants . ATTRIBUTE    :", "kind    =     \" attribute \"  ;", "break ;", "case   XMLStreamConstants . CDATA    :", "kind    =     \" cdata \"  ;", "break ;", "case   XMLStreamConstants . CHARACTERS    :", "kind    =     \" characters \"  ;", "break ;", "case   XMLStreamConstants . COMMENT    :", "kind    =     \" comment \"  ;", "break ;", "case   XMLStreamConstants . DTD    :", "kind    =     \" dtd \"  ;", "break ;", "case   XMLStreamConstants . END _ DOCUMENT    :", "kind    =     \" document   end \"  ;", "break ;", "case   XMLStreamConstants . END _ ELEMENT    :", "kind    =     \" element   end \"  ;", "break ;", "case   XMLStreamConstants . ENTITY _ DECLARATION    :", "kind    =     \" entity   declaration \"  ;", "break ;", "case   XMLStreamConstants . ENTITY _ REFERENCE    :", "kind    =     \" entity   ref \"  ;", "break ;", "case   XMLStreamConstants . NAMESPACE    :", "kind    =     \" namespace \"  ;", "break ;", "case   XMLStreamConstants . NOTATION _ DECLARATION    :", "kind    =     \" notation   declaration \"  ;", "break ;", "case   XMLStreamConstants . PROCESSING _ INSTRUCTION    :", "kind    =     \" processing   instruction \"  ;", "break ;", "case   XMLStreamConstants . SPACE    :", "kind    =     \" whitespace \"  ;", "break ;", "case   XMLStreamConstants . START _ DOCUMENT    :", "kind    =     \" document   start \"  ;", "break ;", "case   XMLStreamConstants . START _ ELEMENT    :", "kind    =     \" element   start \"  ;", "break ;", "default    :", "kind    =     \" unknown \"  ;", "break ;", "}", "final   StringBuilder   b    =    new   StringBuilder (  \" Unexpected   content   of   type    '  \"  )  . append ( kind )  . append (  '  \\  '  '  )  ;", "if    ( reader . hasName (  )  )     {", "b . append (  \"    named    '  \"  )  . append ( reader . getName (  )  )  . append (  '  \\  '  '  )  ;", "}", "if    ( reader . hasText (  )  )     {", "b . append (  \"  ,    text   is :     '  \"  )  . append ( reader . getText (  )  )  . append (  '  \\  '  '  )  ;", "}", "throw   EeLogger . ROOT _ LOGGER . errorParsing ( b . toString (  )  ,    reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["unexpectedContent"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "throw   EeLogger . ROOT _ LOGGER . unexpectedElement ( reader . getName (  )  ,    reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["unexpectedElement"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "throw   EeLogger . ROOT _ LOGGER . errorParsingEJBClientDescriptor (  \" Unexpected   end   of   document \"  ,    location )  ;", "}", "METHOD_END"], "methodName": ["unexpectedEndOfDocument"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor10Parser"}, {"methodBody": ["METHOD_START", "{", "final   Properties   channelCreationOptions    =    new   Properties (  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return   channelCreationOptions ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "channelCreationOptions . putAll ( this . parseProperty ( reader )  )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "return   channelCreationOptions ;", "}", "METHOD_END"], "methodName": ["parseChannelCreationOptions"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "final   Set < EJBClientDescriptorXMLElement >    visited    =    EnumSet . noneOf ( EJBClientDescriptorXMLElement . class )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "if    ( visited . contains ( element )  )     {", "0 Parser . unexpectedElement ( reader )  ;", "}", "visited . add ( element )  ;", "switch    ( element )     {", "case   EJB _ RECEIVERS    :", "this . parseEJBReceivers ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "case   CLUSTERS    :", "this . parseClusters ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseClientContext"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "final   Set < EJBClientDescriptorXMLAttribute >    required    =    EnumSet . of ( EJBClientDescriptorXMLAttribute . NAME )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   clusterName    =    null ;", "String   clusterNodeSelector    =    null ;", "long   connectTimeout    =     5  0  0  0  ;", "long   maxAllowedConnectedNodes    =     1  0  ;", "String   userName    =    null ;", "String   securityRealm    =    null ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "final   String   value    =    readResolveValue ( reader ,    i )  ;", "switch    ( attribute )     {", "case   NAME    :", "clusterName    =    value ;", "break ;", "case   CONNECT _ TIMEOUT    :", "connectTimeout    =    Long . parseLong ( value )  ;", "break ;", "case   CLUSTER _ NODE _ SELECTOR    :", "clusterNodeSelector    =    value ;", "break ;", "case   MAX _ ALLOWED _ CONNECTED _ NODES    :", "maxAllowedConnectedNodes    =    Long . parseLong ( value )  ;", "break ;", "case   USERNAME    :", "userName    =    value ;", "break ;", "case   SECURITY _ REALM    :", "securityRealm    =    value ;", "break ;", "default    :", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "0 Parser . missingAttributes ( reader . getLocation (  )  ,    required )  ;", "}", "final   EJBClientDescriptorMetaData . ClusterConfig   clusterConfig    =    ejbClientDescriptorMetaData . newClusterConfig ( clusterName )  ;", "clusterConfig . setConnectTimeout ( connectTimeout )  ;", "clusterConfig . setNodeSelector ( clusterNodeSelector )  ;", "clusterConfig . setMaxAllowedConnectedNodes ( maxAllowedConnectedNodes )  ;", "clusterConfig . setSecurityRealm ( securityRealm )  ;", "clusterConfig . setUserName ( userName )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONNECTION _ CREATION _ OPTIONS    :", "final   Properties   connectionCreationOptions    =    this . parseConnectionCreationOptions ( reader )  ;", "clusterConfig . setConnectionOptions ( connectionCreationOptions )  ;", "break ;", "case   CHANNEL _ CREATION _ OPTIONS    :", "final   Properties   channelCreationOptions    =    this . parseChannelCreationOptions ( reader )  ;", "clusterConfig . setChannelCreationOptions ( channelCreationOptions )  ;", "break ;", "case   NODE    :", "this . parseClusterNode ( reader ,    clusterConfig )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseCluster"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "final   Set < EJBClientDescriptorXMLAttribute >    required    =    EnumSet . of ( EJBClientDescriptorXMLAttribute . NAME )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   nodeName    =    null ;", "long   connectTimeout    =     5  0  0  0  ;", "String   userName    =    null ;", "String   securityRealm    =    null ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "final   String   value    =    readResolveValue ( reader ,    i )  ;", "switch    ( attribute )     {", "case   NAME    :", "nodeName    =    value ;", "break ;", "case   CONNECT _ TIMEOUT    :", "connectTimeout    =    Long . parseLong ( value )  ;", "break ;", "case   USERNAME    :", "userName    =    value ;", "break ;", "case   SECURITY _ REALM    :", "securityRealm    =    value ;", "break ;", "default    :", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "0 Parser . missingAttributes ( reader . getLocation (  )  ,    required )  ;", "}", "final   EJBClientDescriptorMetaData . ClusterNodeConfig   clusterNodeConfig    =    clusterConfig . newClusterNode ( nodeName )  ;", "clusterNodeConfig . setConnectTimeout ( connectTimeout )  ;", "clusterNodeConfig . setSecurityRealm ( securityRealm )  ;", "clusterNodeConfig . setUserName ( userName )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONNECTION _ CREATION _ OPTIONS    :", "final   Properties   connectionCreationOptions    =    this . parseConnectionCreationOptions ( reader )  ;", "clusterNodeConfig . setConnectionOptions ( connectionCreationOptions )  ;", "break ;", "case   CHANNEL _ CREATION _ OPTIONS    :", "final   Properties   channelCreationOptions    =    this . parseChannelCreationOptions ( reader )  ;", "clusterNodeConfig . setChannelCreationOptions ( channelCreationOptions )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseClusterNode"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CLUSTER    :", "this . parseCluster ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseClusters"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "final   Properties   connectionCreationOptions    =    new   Properties (  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return   connectionCreationOptions ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "connectionCreationOptions . putAll ( this . parseProperty ( reader )  )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "return   connectionCreationOptions ;", "}", "METHOD_END"], "methodName": ["parseConnectionCreationOptions"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "final   Set < EJBClientDescriptorXMLAttribute >    required    =    EnumSet . of ( EJBClientDescriptorXMLAttribute . NAME ,    EJBClientDescriptorXMLAttribute . VALUE )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   name    =    null ;", "String   value    =    null ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "final   String   val    =    readResolveValue ( reader ,    i )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    val ;", "break ;", "case   VALUE    :", "value    =    val ;", "break ;", "default    :", "EJBClientDescriptor 1  0 Parser . unexpectedContent ( reader )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "EJBClientDescriptor 1  0 Parser . missingAttributes ( reader . getLocation (  )  ,    required )  ;", "}", ". requireNoContent ( reader )  ;", "final   Properties   property    =    new   Properties (  )  ;", "property . put ( name ,    value )  ;", "return   property ;", "}", "METHOD_END"], "methodName": ["parseProperty"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "0 Parser . unexpectedElement ( reader )  ;", "}", "}", "METHOD_END"], "methodName": ["requireNoContent"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor11Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "final   String   val    =    reader . getAttributeValue ( i )  ;", "switch    ( attribute )     {", "case   INVOCATION _ TIMEOUT    :", "final   Long   invocationTimeout    =    Long . parseLong ( val . trim (  )  )  ;", "ejbClientDescriptorMetaData . setInvocationTimeout ( invocationTimeout )  ;", "break ;", "case   DEPLOYMENT _ NODE _ SELECTOR    :", "ejbClientDescriptorMetaData . setDeploymentNodeSelector ( val . trim (  )  )  ;", "break ;", "default    :", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "final   Set < EJBClientDescriptorXMLElement >    visited    =    EnumSet . noneOf ( EJBClientDescriptorXMLElement . class )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "if    ( visited . contains ( element )  )     {", "0 Parser . unexpectedElement ( reader )  ;", "}", "visited . add ( element )  ;", "switch    ( element )     {", "case   EJB _ RECEIVERS    :", "this . parseEJBReceivers ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "case   CLUSTERS    :", "this . parseClusters ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseClientContext"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor12Parser"}, {"methodBody": ["METHOD_START", "{", "String   outboundConnectionRef    =    null ;", "final   Set < EJBClientDescriptorXMLAttribute >    required    =    EnumSet . of ( EJBClientDescriptorXMLAttribute . OUTBOUND _ CONNECTION _ REF )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "EJBClientDescriptorMetaData . RemotingReceiverConfiguration   remotingReceiverConfiguration    =    null ;", "long   connectTimeout    =     5  0  0  0  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "final   String   value    =    readResolveValue ( reader ,    i )  ;", "switch    ( attribute )     {", "case   OUTBOUND _ CONNECTION _ REF    :", "outboundConnectionRef    =    value ;", "remotingReceiverConfiguration    =    ejbClientDescriptorMetaData . addRemotingReceiverConnectionRef ( outboundConnectionRef )  ;", "break ;", "case   CONNECT _ TIMEOUT    :", "connectTimeout    =    Long . parseLong ( value )  ;", "break ;", "default    :", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "0 Parser . missingAttributes ( reader . getLocation (  )  ,    required )  ;", "}", "remotingReceiverConfiguration . setConnectionTimeout ( connectTimeout )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CHANNEL _ CREATION _ OPTIONS    :", "final   Properties   channelCreationOptions    =    this . parseChannelCreationOptions ( reader )  ;", "remotingReceiverConfiguration . setChannelCreationOptions ( channelCreationOptions )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseRemotingReceiver"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor12Parser"}, {"methodBody": ["METHOD_START", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "final   String   value    =    readResolveValue ( reader ,    i )  ;", "switch    ( attribute )     {", "case   INVOCATION _ TIMEOUT    :", "final   Long   invocationTimeout    =    Long . parseLong ( value )  ;", "ejbClientDescriptorMetaData . setInvocationTimeout ( invocationTimeout )  ;", "break ;", "case   DEPLOYMENT _ NODE _ SELECTOR    :", "final   String   deploymentNodeSelector    =    readResolveValue ( reader ,    i )  ;", "ejbClientDescriptorMetaData . setDeploymentNodeSelector ( deploymentNodeSelector )  ;", "break ;", "default    :", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "final   Set < EJBClientDescriptorXMLElement >    visited    =    EnumSet . noneOf ( EJBClientDescriptorXMLElement . class )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . forName ( reader . getLocalName (  )  )  ;", "if    ( visited . contains ( element )  )     {", "0 Parser . unexpectedElement ( reader )  ;", "}", "visited . add ( element )  ;", "switch    ( element )     {", "case   EJB _ RECEIVERS    :", "this . parseEJBReceivers ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "case   CLUSTERS    :", "this . parseClusters ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "case   PROFILE    :", "this . parseProfile ( reader ,    ejbClientDescriptorMetaData )  ;", "break ;", "default    :", "0 Parser . unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "{", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "}", "0 Parser . unexpectedEndOfDocument ( reader . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseClientContext"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor13Parser"}, {"methodBody": ["METHOD_START", "{", "final   Set < EJBClientDescriptorXMLAttribute >    required    =    EnumSet . of ( EJBClientDescriptorXMLAttribute . NAME )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   profileName    =    null ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   EJBClientDescriptorXMLAttribute   attribute    =    EJBClientDescriptorXMLAttribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "final   String   value    =    readResolveValue ( reader ,    i )  ;", "switch    ( attribute )     {", "case   NAME    :", "profileName    =    value ;", "break ;", "default    :", "0 Parser . unexpectedContent ( reader )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "0 Parser . missingAttributes ( reader . getLocation (  )  ,    required )  ;", "}", "ejbClientDescriptorMetaData . setProfile ( profileName )  ;", "}", "METHOD_END"], "methodName": ["parseProfile"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptor13Parser"}, {"methodBody": ["METHOD_START", "{", "final   XMLMapper   mapper    =    Factory . create (  )  ;", "final   PropertyReplacer   propertyReplacer    =    EjbClientDescriptorPropertyReplacement . propertyReplacer ( deploymentUnit )  ;", "final   EJBClientDescriptor 1  0 Parser   ejbClientDescriptor 1  0 Parser    =    new   EJBClientDescriptor 1  0 Parser ( propertyReplacer )  ;", "mapper . registerRootElement (  . ROOT _  1  _  0  ,    ejbClientDescriptor 1  0 Parser )  ;", "final   EJBClientDescriptor 1  1 Parser   ejbClientDescriptor 1  1 Parser    =    new   EJBClientDescriptor 1  1 Parser ( propertyReplacer )  ;", "mapper . registerRootElement (  . ROOT _  1  _  1  ,    ejbClientDescriptor 1  1 Parser )  ;", "final   EJBClientDescriptor 1  1 Parser   ejbClientDescriptor 1  2 Parser    =    new   EJBClientDescriptor 1  2 Parser ( propertyReplacer )  ;", "mapper . registerRootElement (  . ROOT _  1  _  2  ,    ejbClientDescriptor 1  2 Parser )  ;", "final   EJBClientDescriptor 1  3 Parser   ejbClientDescriptor 1  3 Parser    =    new   EJBClientDescriptor 1  3 Parser ( propertyReplacer )  ;", "mapper . registerRootElement (  . ROOT _  1  _  3  ,    ejbClientDescriptor 1  3 Parser )  ;", "mapper . registerRootElement (  . ROOT _ NO _ NAMESPACE ,    ejbClientDescriptor 1  3 Parser )  ;", "return   mapper ;", "}", "METHOD_END"], "methodName": ["createMapper"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   FileInputStream   fis ;", "try    {", "fis    =    new   FileInputStream ( file )  ;", "}    catch    ( FileNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . failedToProcessEJBClientDescriptor ( e )  ;", "}", "try    {", "return   parse ( fis ,    file ,    mapper )  ;", "}    finally    {", ". safeClose ( fis )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   XMLInputFactory   inputFactory    =     . INPUT _ FACTORY ;", "setIfSupported ( inputFactory ,    XMLInputFactory . IS _ VALIDATING ,    Boolean . FALSE )  ;", "setIfSupported ( inputFactory ,    XMLInputFactory . SUPPORT _ DTD ,    Boolean . FALSE )  ;", "final   XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( source )  ;", "try    {", "final   EJBClientDescriptorMetaData   result    =    new   EJBClientDescriptorMetaData (  )  ;", "mapper . parseDocument ( result ,    streamReader )  ;", "return   result ;", "}    finally    {", ". safeClose ( streamReader )  ;", "}", "}    catch    ( XMLStreamException   e )     {", "throw   EeLogger . ROOT _ LOGGER . xmlErrorParsingEJBClientDescriptor ( e ,    file . getAbsolutePath (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( closeable    !  =    null )", "try    {", "closeable . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if   eamReader    !  =    null )", "try    {", "eamReader . close (  )  ;", "}    catch    ( XMLStreamException   e )     {", "}", "}", "METHOD_END"], "methodName": ["safeClose"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( inputFactory . isPropertySupported ( property )  )     {", "inputFactory . setProperty ( property ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setIfSupported"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   EJBClientDescriptorXMLAttribute   element    =    EJBClientDescriptorXMLAttribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    EJBClientDescriptorXMLAttribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorXMLAttribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorXMLAttribute"}, {"methodBody": ["METHOD_START", "{", "final   EJBClientDescriptorXMLElement   element    =    EJBClientDescriptorXMLElement . MAP . get ( localName )  ;", "return   element    =  =    null    ?    EJBClientDescriptorXMLElement . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorXMLElement"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.ee.structure.EJBClientDescriptorXMLElement"}, {"methodBody": ["METHOD_START", "{", "if    (  ( phaseContext . getAttachment ( Attachments . DEPLOYMENT _ TYPE )  )     =  =     ( DeploymentType . EAR )  )     {", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "for    ( DeploymentUnit   subdeployment    :    deploymentUnit . getAttachmentList ( server . deployment . Attachments . SUB _ DEPLOYMENTS )  )     {", "phaseContext . addToAttachmentList ( server . deployment . Attachments . NEXT _ PHASE _ DEPS ,    Services . deploymentUnitName ( deploymentUnit . getName (  )  ,    subdeployment . getName (  )  ,    phaseContext . getPhase (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.structure.EarDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "String   deploymentName    =    deploymentUnit . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    ( deploymentName . endsWith (  . EAR _ EXTENSION )  )     {", "DeploymentTypeMarker . setType ( DeploymentType . EAR ,    deploymentUnit )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.structure.EarInitializationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    (  !  ( DeploymentTypeMarker . isType ( DeploymentType . EAR ,    deploymentUnit )  )  )     {", "return ;", "}", "final   ResourceRoot   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   VirtualFile   deploymentFile    =    deploymentRoot . getRoot (  )  ;", "EarMetaData   earMetaData    =    handleSpecMetadata ( deploymentFile ,    SpecDescriptorPropertyReplacement . propertyReplacer ( deploymentUnit )  )  ;", "JBossAppMetaData   jbossMetaData    =    handleJbossMetadata ( deploymentFile ,    JBossDescriptorPropertyReplacement . propertyReplacer ( deploymentUnit )  ,    deploymentUnit )  ;", "if    (  ( earMetaData    =  =    null )     &  &     ( jbossMetaData    =  =    null )  )     {", "return ;", "}", "if    (  ( jbossMetaData    !  =    null )     &  &     (  ( jbossMetaData . getDistinctName (  )  )     !  =    null )  )     {", "deploymentUnit . putAttachment ( Attachments . DISTINCT _ NAME ,    jbossMetaData . getDistinctName (  )  )  ;", "}", "JBossAppMetaData   merged ;", "if    ( earMetaData    !  =    null )     {", "merged    =    new   JBossAppMetaData ( earMetaData . getEarVersion (  )  )  ;", "} else    {", "merged    =    new   JBossAppMetaData (  )  ;", "}", "JBossAppMetaDataMerger . merge ( merged ,    jbossMetaData ,    earMetaData )  ;", "deploymentUnit . putAttachment ( Attachments . EAR _ METADATA ,    merged )  ;", "if    (  ( merged . getEarEnvironmentRefsGroup (  )  )     !  =    null )     {", "final   DeploymentDescriptorEnvironment   bindings    =    new   DeploymentDescriptorEnvironment (  \" java : app / env /  \"  ,    merged . getEarEnvironmentRefsGroup (  )  )  ;", "deploymentUnit . putAttachment ( component . Attachments . MODULE _ DEPLOYMENT _ DESCRIPTOR _ ENVIRONMENT ,    bindings )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.structure.EarMetaDataParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   applicationXmlFile    =    deploymentFile . getChild ( EarMetaDataParsingProcessor . JBOSS _ APP _ XML )  ;", "if    (  !  ( applicationXmlFile . exists (  )  )  )     {", "return   deploymentUnit . getAttachment ( AppJBossAllParser . ATTACHMENT _ KEY )  ;", "}", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    applicationXmlFile . openStream (  )  ;", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( NoopXMLResolver . create (  )  )  ;", "XMLStreamReader   xmlReader    =    inputFactory . createXMLStreamReader ( inputStream )  ;", "return   INSTANCE . parse ( xmlReader ,    propertyReplacer )  ;", "}    catch    ( Exception   e )     {", "throw   EeLogger . ROOT _ LOGGER . failedToParse ( e ,    applicationXmlFile )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "METHOD_END"], "methodName": ["handleJbossMetadata"], "fileName": "org.jboss.as.ee.structure.EarMetaDataParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   applicationXmlFile    =    deploymentFile . getChild ( EarMetaDataParsingProcessor . APPLICATION _ XML )  ;", "if    (  !  ( applicationXmlFile . exists (  )  )  )     {", "return   null ;", "}", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    applicationXmlFile . openStream (  )  ;", "final   XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setXMLResolver ( NoopXMLResolver . create (  )  )  ;", "XMLStreamReader   xmlReader    =    inputFactory . createXMLStreamReader ( inputStream )  ;", "return   INSTANCE . parse ( xmlReader ,    propertyReplacer )  ;", "}    catch    ( Exception   e )     {", "throw   EeLogger . ROOT _ LOGGER . failedToParse ( e ,    applicationXmlFile )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "METHOD_END"], "methodName": ["handleSpecMetadata"], "fileName": "org.jboss.as.ee.structure.EarMetaDataParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "deploymentUnit . removeAttachment ( Attachments . EAR _ METADATA )  ;", "}", "METHOD_END"], "methodName": ["undeploy"], "fileName": "org.jboss.as.ee.structure.EarMetaDataParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   boolean   war    =    file . getName (  )  . toLowerCase ( Locale . ENGLISH )  . endsWith ( EarStructureProcessor . WAR _ EXTENSION )  ;", "final   Closeable   closable    =     ( file . isFile (  )  )     ?    EarStructureProcessor . mount ( file ,    explodeDuringMount )     :    exportExplodedWar ( war ,    file ,    deploymentUnit )  ;", "final   MountHandle   mountHandle    =    new   MountHandle ( closable )  ;", "final   ResourceRoot   resourceRoot    =    new   ResourceRoot ( file ,    mountHandle )  ;", "deploymentUnit . addToAttachmentList ( RESOURCE _ ROOTS ,    resourceRoot )  ;", "if    ( markAsSubDeployment )     {", "SubDeploymentMarker . mark ( resourceRoot )  ;", "}", "if    ( war )     {", "resourceRoot . putAttachment ( INDEX _ RESOURCE _ ROOT ,    false )  ;", "SubExplodedDeploymentMarker . mark ( resourceRoot )  ;", "}", "return   resourceRoot ;", "}", "METHOD_END"], "methodName": ["createResourceRoot"], "fileName": "org.jboss.as.ee.structure.EarStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    (  !  ( DeploymentTypeMarker . isType ( DeploymentType . EAR ,    deploymentUnit )  )  )     {", "return ;", "}", "final   ResourceRoot   deploymentRoot    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( DEPLOYMENT _ ROOT )  ;", "final   VirtualFile   virtualFile    =    deploymentRoot . getRoot (  )  ;", "deploymentRoot . putAttachment ( INDEX _ RESOURCE _ ROOT ,    false )  ;", "ModuleRootMarker . mark ( deploymentRoot ,    false )  ;", "String   libDirName    =     . DEFAULT _ LIB _ DIR ;", "final   boolean   appXmlPresent    =    deploymentRoot . getRoot (  )  . getChild (  \" META - INF / application . xml \"  )  . exists (  )  ;", "final   EarMetaData   earMetaData    =    deploymentUnit . getAttachment ( Attachments . EAR _ METADATA )  ;", "if    ( earMetaData    !  =    null )     {", "final   String   xmlLibDirName    =    earMetaData . getLibraryDirectory (  )  ;", "if    ( xmlLibDirName    !  =    null )     {", "if    (  (  ( xmlLibDirName . length (  )  )     =  =     1  )     &  &     (  ( xmlLibDirName . charAt (  0  )  )     =  =     '  /  '  )  )     {", "throw   EeLogger . ROOT _ LOGGER . rootAsLibraryDirectory (  )  ;", "}", "libDirName    =    xmlLibDirName ;", "}", "}", "Map < String ,    MountedDeploymentOverlay >    overlays    =    deploymentUnit . getAttachment ( DEPLOYMENT _ OVERLAY _ LOCATIONS )  ;", "try    {", "final   VirtualFile   libDir ;", "if    (  !  ( libDirName . isEmpty (  )  )  )     {", "libDir    =    virtualFile . getChild ( libDirName )  ;", "if    ( libDir . exists (  )  )     {", "List < VirtualFile >    libArchives    =    libDir . getChildren (  . CHILD _ ARCHIVE _ FILTER )  ;", "for    ( final   VirtualFile   child    :    libArchives )     {", "String   relativeName    =    child . getPathNameRelativeTo ( deploymentRoot . getRoot (  )  )  ;", "MountedDeploymentOverlay   overlay    =    overlays . get ( relativeName )  ;", "final   MountHandle   mountHandle ;", "if    ( overlay    !  =    null )     {", "overlay . remountAsZip ( false )  ;", "mountHandle    =    new   MountHandle ( null )  ;", "} else    {", "final   Closeable   closable    =     ( child . isFile (  )  )     ?     . mount ( child ,    false )     :    null ;", "mountHandle    =    new   MountHandle ( closable )  ;", "}", "final   ResourceRoot   childResource    =    new   ResourceRoot ( child ,    mountHandle )  ;", "if    ( child . getName (  )  . toLowerCase ( Locale . ENGLISH )  . endsWith (  . JAR _ EXTENSION )  )     {", "ModuleRootMarker . mark ( childResource )  ;", "deploymentUnit . addToAttachmentList ( RESOURCE _ ROOTS ,    childResource )  ;", "}", "}", "}", "} else    {", "libDir    =    null ;", "}", "final   List < VirtualFile >    childArchives    =    new   ArrayList < VirtualFile >  ( virtualFile . getChildren ( new   SuffixMatchFilter (  . CHILD _ ARCHIVE _ EXTENSIONS ,    new   VisitorAttributes (  )     {", "@ Override", "public   boolean   isLeavesOnly (  )     {", "return   false ;", "}", "@ Override", "public   boolean   isRecurse ( VirtualFile   file )     {", "if    ( file . equals ( libDir )  )     {", "return   false ;", "}", "for    ( String   suffix    :     . CHILD _ ARCHIVE _ EXTENSIONS )     {", "if    ( file . getName (  )  . endsWith ( suffix )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "}  )  )  )  ;", "if    (  ! appXmlPresent )     {", "for    ( final   VirtualFile   child    :    childArchives )     {", "final   boolean   isWarFile    =    child . getName (  )  . toLowerCase ( Locale . ENGLISH )  . endsWith (  . WAR _ EXTENSION )  ;", "final   boolean   isRarFile    =    child . getName (  )  . toLowerCase ( Locale . ENGLISH )  . endsWith (  . RAR _ EXTENSION )  ;", "this . createResourceRoot ( deploymentUnit ,    child ,     ( isWarFile    |  |    isRarFile )  ,    isWarFile )  ;", "}", "} else    {", "final   Set < VirtualFile >    subDeploymentFiles    =    new   HashSet < VirtualFile >  (  )  ;", "for    ( final   ModuleMetaData   module    :    earMetaData . getModules (  )  )     {", "if    ( module . getFileName (  )  . endsWith (  \"  . xml \"  )  )     {", "throw   EeLogger . ROOT _ LOGGER . unsupportedModuleType ( module . getFileName (  )  )  ;", "}", "final   VirtualFile   moduleFile    =    virtualFile . getChild ( module . getFileName (  )  )  ;", "if    (  !  ( moduleFile . exists (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . cannotProcessEarModule ( virtualFile ,    module . getFileName (  )  )  ;", "}", "if    ( libDir    !  =    null )     {", "VirtualFile   moduleParentFile    =    moduleFile . getParent (  )  ;", "if    ( moduleParentFile    !  =    null )     {", "if    ( libDir . equals ( moduleParentFile )  )     {", "throw   EeLogger . ROOT _ LOGGER . earModuleChildOfLibraryDirectory ( libDirName ,    module . getFileName (  )  )  ;", "}", "}", "}", "subDeploymentFiles . add ( moduleFile )  ;", "final   boolean   webArchive    =     ( module . getType (  )  )     =  =     ( ModuleType . Web )  ;", "final   ResourceRoot   childResource    =    this . createResourceRoot ( deploymentUnit ,    moduleFile ,    true ,    webArchive )  ;", "childResource . putAttachment ( Attachments . MODULE _ META _ DATA ,    module )  ;", "if    (  ! webArchive )     {", "ModuleRootMarker . mark ( childResource )  ;", "}", "final   String   alternativeDD    =    module . getAlternativeDD (  )  ;", "if    (  ( alternativeDD    !  =    null )     &  &     (  ( alternativeDD . trim (  )  . length (  )  )     >     0  )  )     {", "final   VirtualFile   alternateDeploymentDescriptor    =    deploymentRoot . getRoot (  )  . getChild ( alternativeDD )  ;", "if    (  !  ( alternateDeploymentDescriptor . exists (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . alternateDeploymentDescriptor ( alternateDeploymentDescriptor ,    moduleFile )  ;", "}", "switch    ( module . getType (  )  )     {", "case   Client    :", "childResource . putAttachment ( Attachments . ALTERNATE _ CLIENT _ DEPLOYMENT _ DESCRIPTOR ,    alternateDeploymentDescriptor )  ;", "break ;", "case   Connector    :", "childResource . putAttachment ( Attachments . ALTERNATE _ CONNECTOR _ DEPLOYMENT _ DESCRIPTOR ,    alternateDeploymentDescriptor )  ;", "break ;", "case   Ejb    :", "childResource . putAttachment ( Attachments . ALTERNATE _ EJB _ DEPLOYMENT _ DESCRIPTOR ,    alternateDeploymentDescriptor )  ;", "break ;", "case   Web    :", "childResource . putAttachment ( Attachments . ALTERNATE _ WEB _ DEPLOYMENT _ DESCRIPTOR ,    alternateDeploymentDescriptor )  ;", "break ;", "case   Service    :", "throw   EeLogger . ROOT _ LOGGER . unsupportedModuleType ( module . getFileName (  )  )  ;", "}", "}", "}", "for    ( final   VirtualFile   child    :    childArchives )     {", "if    ( subDeploymentFiles . contains ( child )  )     {", "continue ;", "}", "final   String   fileName    =    child . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    (  ( fileName . endsWith (  . SAR _ EXTENSION )  )     |  |     ( fileName . endsWith (  . JAR _ EXTENSION )  )  )     {", "this . createResourceRoot ( deploymentUnit ,    child ,    false ,    false )  ;", "}", "}", "}", "}    catch    ( IOException   e )     {", "throw   EeLogger . ROOT _ LOGGER . failedToProcessChild ( e ,    virtualFile )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.ee.structure.EarStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( isExplodedWarInArchiveEar ( war ,    file ,    deploymentUnit )  )     {", "File   warContent    =    file . getPhysicalFile (  )  ;", "VFSUtils . recursiveCopy ( file ,    warContent . getParentFile (  )  )  ;", "return   VFS . mountReal ( warContent ,    file )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["exportExplodedWar"], "fileName": "org.jboss.as.ee.structure.EarStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( war    &  &     (  !  ( file . isFile (  )  )  )  )     &  &     ( deploymentUnit . hasAttachment ( DEPLOYMENT _ CONTENTS )  )  )     &  &     ( deploymentUnit . getAttachment ( DEPLOYMENT _ CONTENTS )  . isFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["isExplodedWarInArchiveEar"], "fileName": "org.jboss.as.ee.structure.EarStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "return   explode    ?    VFS . mountZipExpanded ( moduleFile ,    moduleFile ,    TempFileProviderService . provider (  )  )     :    VFS . mountZip ( moduleFile ,    moduleFile ,    TempFileProviderService . provider (  )  )  ;", "}", "METHOD_END"], "methodName": ["mount"], "fileName": "org.jboss.as.ee.structure.EarStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < ResourceRoot >    children    =    context . removeAttachment ( RESOURCE _ ROOTS )  ;", "if    ( children    !  =    null )     {", "for    ( ResourceRoot   childRoot    :    children )     {", "VFSUtils . safeClose ( childRoot . getMountHandle (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["undeploy"], "fileName": "org.jboss.as.ee.structure.EarStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "Boolean   replacement    =    deploymentUnit . getAttachment ( Attachments . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT )  ;", "if    (  ( replacement    =  =    null )     |  |    replacement )     {", "PropertyReplacer   replacer    =    deploymentUnit . getAttachment ( metadata . property . Attachments . FINAL _ PROPERTY _ REPLACER )  ;", "return   replacer    !  =    null    ?    replacer    :    PropertyReplacers . noop (  )  ;", "} else    {", "return   PropertyReplacers . noop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyReplacer"], "fileName": "org.jboss.as.ee.structure.EjbClientDescriptorPropertyReplacement"}, {"methodBody": ["METHOD_START", "{", "this . globalModules    =    globalModules ;", "}", "METHOD_END"], "methodName": ["setGlobalModules"], "fileName": "org.jboss.as.ee.structure.GlobalModuleDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "Boolean   replacement    =    deploymentUnit . getAttachment ( Attachments . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT )  ;", "if    (  ( replacement    =  =    null )     |  |    replacement )     {", "PropertyReplacer   replacer    =    deploymentUnit . getAttachment ( metadata . property . Attachments . FINAL _ PROPERTY _ REPLACER )  ;", "return   replacer    !  =    null    ?    replacer    :    PropertyReplacers . noop (  )  ;", "} else    {", "return   PropertyReplacers . noop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyReplacer"], "fileName": "org.jboss.as.ee.structure.JBossDescriptorPropertyReplacement"}, {"methodBody": ["METHOD_START", "{", "Boolean   replacement    =    deploymentUnit . getAttachment ( Attachments . SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT )  ;", "if    (  ( replacement    =  =    null )     |  |    replacement )     {", "PropertyReplacer   replacer    =    deploymentUnit . getAttachment ( metadata . property . Attachments . FINAL _ PROPERTY _ REPLACER )  ;", "return   replacer    !  =    null    ?    replacer    :    PropertyReplacers . noop (  )  ;", "} else    {", "return   PropertyReplacers . noop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyReplacer"], "fileName": "org.jboss.as.ee.structure.SpecDescriptorPropertyReplacement"}, {"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.ee.subsystem.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.ee.subsystem.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   getLocalName (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.ee.subsystem.Attribute"}, {"methodBody": ["METHOD_START", "{", "final   String   cleaned ;", "if    (  (  (  ( name . endsWith (  \"  . war \"  )  )     |  |     ( name . endsWith (  \"  . jar \"  )  )  )     |  |     ( name . endsWith (  \"  . ear \"  )  )  )     |  |     ( name . endsWith (  \"  . rar \"  )  )  )     {", "cleaned    =    namtring (  0  ,     (  ( name . length (  )  )     -     4  )  )  ;", "} else    {", "cleaned    =    name ;", "}", "return   cleaned ;", "}", "METHOD_END"], "methodName": ["cleanName"], "fileName": "org.jboss.as.ee.subsystem.EEJndiViewExtension"}, {"methodBody": ["METHOD_START", "{", "return   registry ;", "}", "METHOD_END"], "methodName": ["getRegistryInjector"], "fileName": "org.jboss.as.ee.subsystem.EEJndiViewExtension"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.ee.subsystem.EEJndiViewExtension"}, {"methodBody": ["METHOD_START", "{", "final   EEModuleDescription   moduleDescription    =    deploymentUnit . getAttachment ( Attachments . EE _ MODULE _ DESCRIPTION )  ;", "if    ( moduleDescription    =  =    null )     {", "return ;", "}", "final   String   appName    =    moduleDescription . getApplicationName (  )  ;", "final   String   moduleName    =    moduleDescription . getModuleName (  )  ;", "final   ModelNode   moduleNode    =    modulesNode . get ( moduleDescription . getModuleName (  )  )  ;", "final   ServiceName   moduleContextName    =    ContextNames . contextServiceNameOfModule ( appName ,    moduleName )  ;", "final   ServiceController <  ?  >    moduleContextController    =    serviceRegistry . getService ( moduleContextName )  ;", "if    ( moduleContextController    !  =    null )     {", "final   NamingStore   moduleStore    =    NamingStore . class . cast ( moduleContextController . getValue (  )  )  ;", "try    {", "context . addEntries ( moduleNode . get (  \" java : module \"  )  ,    new   naming . NamingContext ( moduleStore ,    null )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   controller . OperationFailedException ( e ,    new   ModelNode (  )  . set ( EeLogger . ROOT _ LOGGER . failedToRead (  \" java : module \"  ,    appName ,    moduleName )  )  )  ;", "}", "final   Collection < ComponentDescription >    componentDescriptions    =    moduleDescription . getComponentDescriptions (  )  ;", "for    ( ComponentDescription   componentDescription    :    componentDescriptions )     {", "final   String   componentName    =    componentDescription . getComponentName (  )  ;", "final   ServiceName   compContextServiceName    =    ContextNames . contextServiceNameOfComponent ( appName ,    moduleName ,    componentName )  ;", "final   ServiceController <  ?  >    compContextController    =    serviceRegistry . getService ( compContextServiceName )  ;", "if    ( compContextController    !  =    null )     {", "final   ModelNode   componentNode    =    moduleNode . get (  \" components \"  )  . get ( componentName )  ;", "final   NamingStore   compStore    =    NamingStore . class . cast ( compContextController . getValue (  )  )  ;", "try    {", "context . addEntries ( componentNode . get (  \" java : comp \"  )  ,    new   naming . NamingContext ( compStore ,    null )  )  ;", "}    catch    ( NamingException   e )     {", "throw   new   controller . OperationFailedException ( e ,    new   ModelNode (  )  . set ( EeLogger . ROOT _ LOGGER . failedToRead (  \" java : comp \"  ,    appName ,    moduleName ,    componentName )  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleModule"], "fileName": "org.jboss.as.ee.subsystem.EEJndiViewExtension"}, {"methodBody": ["METHOD_START", "{", "registry . getValue (  )  . addExtension ( this )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.ee.subsystem.EEJndiViewExtension"}, {"methodBody": ["METHOD_START", "{", "registry . getValue (  )  . removeExtension ( this )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.ee.subsystem.EEJndiViewExtension"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . EAR _ SUBDEPLOYMENTS _ ISOLATED . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEarSubDeploymentsIsolatedElement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser10"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . EAR _ SUBDEPLOYMENTS _ ISOLATED . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEarSubDeploymentsIsolatedElement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser11"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseJBossDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser11"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseSpecDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser11"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEJBAnnotationPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser12"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . EAR _ SUBDEPLOYMENTS _ ISOLATED . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEarSubDeploymentsIsolatedElement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser12"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseJBossDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser12"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseSpecDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser12"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONTEXT _ SERVICES    :", "{", ". parseContextServices ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "case   MANAGED _ THREAD _ FACTORIES    :", "{", ". parseManagedThreadFactories ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "case   MANAGED _ EXECUTOR _ SERVICES    :", "{", ". parseManagedExecutorServices ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "case   MANAGED _ SCHEDULED _ EXECUTOR _ SERVICES    :", "{", ". parseManagedScheduledExecutorServices ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseConcurrent"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   CONTEXT _ SERVICE    :", "{", "empty    =    false ;", ". parseContextService ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   missingRequired ( reader ,    EnumSet . of ( Element . CONTEXT _ SERVICE )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseContextServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEJBAnnotationPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . EAR _ SUBDEPLOYMENTS _ ISOLATED . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEarSubDeploymentsIsolatedElement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseJBossDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   MANAGED _ EXECUTOR _ SERVICE    :", "{", "empty    =    false ;", ". parseManagedExecutorService ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   missingRequired ( reader ,    EnumSet . of ( Element . MANAGED _ EXECUTOR _ SERVICE )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseManagedExecutorServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE    :", "{", "empty    =    false ;", ". parseManagedScheduledExecutorService ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   missingRequired ( reader ,    EnumSet . of ( Element . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseManagedScheduledExecutorServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   MANAGED _ THREAD _ FACTORY    :", "{", "empty    =    false ;", ". parseManagedThreadFactory ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   missingRequired ( reader ,    EnumSet . of ( Element . MANAGED _ THREAD _ FACTORY )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseManagedThreadFactories"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseSpecDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser20"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONTEXT _ SERVICES    :", "{", ". parseContextServices ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "case   MANAGED _ THREAD _ FACTORIES    :", "{", ". parseManagedThreadFactories ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "case   MANAGED _ EXECUTOR _ SERVICES    :", "{", ". parseManagedExecutorServices ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "case   MANAGED _ SCHEDULED _ EXECUTOR _ SERVICES    :", "{", ". parseManagedScheduledExecutorServices ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseConcurrent"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   CONTEXT _ SERVICE    :", "{", "empty    =    false ;", ". parseContextService ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( Element . CONTEXT _ SERVICE )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseContextServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEJBAnnotationPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . EAR _ SUBDEPLOYMENTS _ ISOLATED . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseEarSubDeploymentsIsolatedElement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseJBossDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   MANAGED _ EXECUTOR _ SERVICE    :", "{", "empty    =    false ;", ". parseManagedExecutorService ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( Element . MANAGED _ EXECUTOR _ SERVICE )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseManagedExecutorServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE    :", "{", "empty    =    false ;", ". parseManagedScheduledExecutorService ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( Element . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseManagedScheduledExecutorServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "boolean   empty    =    true ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   MANAGED _ THREAD _ FACTORY    :", "{", "empty    =    false ;", ". parseManagedThreadFactory ( reader ,    operations ,    subsystemPathAddress )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    ( empty )     {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( Element . MANAGED _ THREAD _ FACTORY )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseManagedThreadFactories"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "ParseUtils . requireNoAttributes ( reader )  ;", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    =  =    null )     |  |     ( value . trim (  )  . isEmpty (  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalidValue ( value ,    Element . SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getLocalName (  )  ,    reader . getLocation (  )  )  ;", "}", "return   value . trim (  )  ;", "}", "METHOD_END"], "methodName": ["parseSpecDescriptorPropertyReplacement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemParser40"}, {"methodBody": ["METHOD_START", "{", "boolean   started    =    false ;", "if    ( eeSubSystem . hasDefined ( Model . CONTEXT _ SERVICE )  )     {", "writer . writeStartElement ( Element . CONCURRENT . getLocalName (  )  )  ;", "started    =    true ;", "writeContextServices ( writer ,    eeSubSystem . get ( Model . CONTEXT _ SERVICE )  )  ;", "}", "if    ( eeSubSystem . hasDefined ( Model . MANAGED _ THREAD _ FACTORY )  )     {", "if    (  ! started )     {", "writer . writeStartElement ( Element . CONCURRENT . getLocalName (  )  )  ;", "started    =    true ;", "}", "writeManagedThreadFactories ( writer ,    eeSubSystem . get ( Model . MANAGED _ THREAD _ FACTORY )  )  ;", "}", "if    ( eeSubSystem . hasDefined ( Model . MANAGED _ EXECUTOR _ SERVICE )  )     {", "if    (  ! started )     {", "writer . writeStartElement ( Element . CONCURRENT . getLocalName (  )  )  ;", "started    =    true ;", "}", "writeManagedExecutorServices ( writer ,    eeSubSystem . get ( Model . MANAGED _ EXECUTOR _ SERVICE )  )  ;", "}", "if    ( eeSubSystem . hasDefined ( Model . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE )  )     {", "if    (  ! started )     {", "writer . writeStartElement ( Element . CONCURRENT . getLocalName (  )  )  ;", "started    =    true ;", "}", "writeManagedScheduledExecutorServices ( writer ,    eeSubSystem . get ( Model . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE )  )  ;", "}", "if    ( started )     {", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeConcurrentElement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemXmlPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . CONTEXT _ SERVICES . getLocalName (  )  )  ;", "for    ( Property   property    :    subModel . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . CONTEXT _ SERVICE . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( SimpleAttributeDefinition   ad    :    ContextServiceResourceDefinition . ATTRIBUTES )     {", "ad . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeContextServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemXmlPersister"}, {"methodBody": ["METHOD_START", "{", "if    (  ( eeSubSystem . hasDefined ( EESubsystemModel . SERVICE )  )     &  &     ( eeSubSystem . get ( EESubsystemModel . SERVICE )  . hasDefined ( EESubsystemModel . DEFAULT _ BINDINGS )  )  )     {", "ModelNode   defaultBindingsNode    =    eeSubSystem . get ( EESubsystemModel . SERVICE ,    EESubsystemModel . DEFAULT _ BINDINGS )  ;", "writer . writeStartElement ( Element . DEFAULT _ BINDINGS . getLocalName (  )  )  ;", "for    ( SimpleAttributeDefinition   ad    :    DefaultBindingsResourceDefinition . ATTRIBUTES )     {", "ad . marshallAsAttribute ( defaultBindingsNode ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDefaultBindingsElement"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemXmlPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . MANAGED _ EXECUTOR _ SERVICES . getLocalName (  )  )  ;", "for    ( Property   property    :    subModel . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . MANAGED _ EXECUTOR _ SERVICE . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( SimpleAttributeDefinition   ad    :    ManagedExecutorServiceResourceDefinition . ATTRIBUTES )     {", "ad . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeManagedExecutorServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemXmlPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICES . getLocalName (  )  )  ;", "for    ( Property   property    :    subModel . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( SimpleAttributeDefinition   ad    :    ManagedScheduledExecutorServiceResourceDefinition . ATTRIBUTES )     {", "ad . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeManagedScheduledExecutorServices"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemXmlPersister"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . MANAGED _ THREAD _ FACTORIES . getLocalName (  )  )  ;", "for    ( Property   property    :    subModel . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . MANAGED _ THREAD _ FACTORY . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( SimpleAttributeDefinition   ad    :    ManagedThreadFactoryResourceDefinition . ATTRIBUTES )     {", "ad . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeManagedThreadFactories"], "fileName": "org.jboss.as.ee.subsystem.EESubsystemXmlPersister"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardResourceDescriptionResolver ( keyPrefix ,    EeExtension . RESOURCE _ NAME ,    EeExtension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.ee.subsystem.EeExtension"}, {"methodBody": ["METHOD_START", "{", "final   Pattern   pattern    =    Pattern . compile (  \"  ( subsystem )  _  \\  \\ d +  _  \\  \\ d +  \\  \\  . xml \"  )  ;", "final   String   cp    =    WildFlySecurityManager . getPropertyPrivileged (  \" path \"  ,     \"  .  \"  )  ;", "final   String [  ]    entries    =    cp . split ( Pattern . quote ( File . pathSeparator )  )  ;", "final   List < String >    configs    =    new   ArrayList <  >  (  )  ;", "for    ( String   entry    :    entries )     {", "final   Path   path    =    Paths . get ( entry )  ;", "if    ( Files . isDirectory ( path )  )     {", "Files . walkFileTree ( path ,    new   SimpleFileVisitor < Path >  (  )     {", "@ Override", "public   FileVisitResult   visitFile ( final   Path   file ,    final   BasicFileAttributes   attrs )    throws   IOException    {", "final   String   name    =    file . getFileName (  )  . toString (  )  ;", "if    ( pattern . matcher ( name )  . matches (  )  )     {", "configs . add ( name )  ;", "}", "return   FileVisitResult . CONTINUE ;", "}", "}  )  ;", "}", "}", "Assert . assertFalse (  \" No   configs   were   found \"  ,    configs . isEmpty (  )  )  ;", "for    ( String   configId    :    configs )     {", "standard ( configId ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["testLegacyConfigurations"], "fileName": "org.jboss.as.ee.subsystem.EeLegacySubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   result    =    kernelServices . executeOperation ( op )  ;", "if    (  !  ( Operations . isSuccessfulOutcome ( result )  )  )     {", "Assert . fail ( Operations . getFailureDescription ( result )  . asString (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["executeForSuccess"], "fileName": "org.jboss.as.ee.subsystem.EeOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   kernelServices    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXml ( getSubsystemXml (  )  )  . build (  )  ;", "final   ModelNode   address    =     . createAddress ( SUBSYSTEM ,    EeExtension . SUBSYSTEM _ NAME ,     \" managed - executor - service \"  ,     \" default \"  )  ;", "ModelNode   op    =     . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     0  )  ;", "ModelNode   result    =    kernelServices . executeOperation ( op )  ;", "Assert . assertFalse (  . isSuccessfulOutcome ( result )  )  ;", "op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" queue - length \"  ,    Integer . MAX _ VALUE )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     0  )  )  . build (  )  . getOperation (  )  ;", "result    =    kernelServices . executeOperation ( op )  ;", "Assert . assertFalse (  . isSuccessfulOutcome ( result )  )  ;", "op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" queue - length \"  ,     0  )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     0  )  )  . build (  )  . getOperation (  )  ;", "result    =    kernelServices . executeOperation ( op )  ;", "Assert . assertFalse (  . isSuccessfulOutcome ( result )  )  ;", "op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     4  )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" max - threads \"  ,     1  )  )  . build (  )  . getOperation (  )  ;", "result    =    kernelServices . executeOperation ( op )  ;", "Assert . assertFalse (  . isSuccessfulOutcome ( result )  )  ;", "op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" queue - length \"  ,     \"  $  { test . queue - length :  1  0  }  \"  )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     \"  $  { test . core - threads :  5  0  0  }  \"  )  )  . build (  )  . getOperation (  )  ;", "result    =    kernelServices . executeOperation ( op )  ;", "Assert . assertFalse (  . isSuccessfulOutcome ( result )  )  ;", "final   int   calculatedMaxThreads    =     ( ProcessorInfo . availableProcessors (  )  )     *     2  ;", "op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,    calculatedMaxThreads )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" max - threads \"  ,     ( calculatedMaxThreads    -     1  )  )  )  . build (  )  . getOperation (  )  ;", "result    =    kernelServices . executeOperation ( op )  ;", "Assert . assertFalse (  . isSuccessfulOutcome ( result )  )  ;", "}", "METHOD_END"], "methodName": ["testManagedExecutorFailureOperations"], "fileName": "org.jboss.as.ee.subsystem.EeOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   kernelServices    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXml ( getSubsystemXml (  )  )  . build (  )  ;", "final   ModelNode   address    =     . createAddress ( SUBSYSTEM ,    EeExtension . SUBSYSTEM _ NAME ,     \" managed - executor - service \"  ,     \" default \"  )  ;", "ModelNode   op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" queue - length \"  ,    Integer . MAX _ VALUE )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     5  )  )  . build (  )  . getOperation (  )  ;", "executeForSuccess ( kernelServices ,    op )  ;", "op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" max - threads \"  ,     5  )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" queue - length \"  ,     1  0  )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     0  )  )  . build (  )  . getOperation (  )  ;", "executeForSuccess ( kernelServices ,    op )  ;", "op    =    CompositeOperationBuilder . create (  )  . addStep (  . createWriteAttributeOperation ( address ,     \" core - threads \"  ,     4  )  )  . addStep (  . createWriteAttributeOperation ( address ,     \" max - threads \"  ,     4  )  )  . build (  )  . getOperation (  )  ;", "executeForSuccess ( kernelServices ,    op )  ;", "}", "METHOD_END"], "methodName": ["testManagedExecutorOperations"], "fileName": "org.jboss.as.ee.subsystem.EeOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    resource . getModel (  )  ;", "final   EEJndiViewExtension   extension    =    new   EEJndiViewExtension (  )  ;", "context . getServiceTarget (  )  . addService ( EEJndiViewExtension . SERVICE _ NAME ,    extension )  . addDependency ( SERVICE _ NAME ,    JndiViewExtensionRegistry . class ,    extension . getRegistryInjector (  )  )  . install (  )  ;", "final   boolean   appclient    =     ( context . getProcessType (  )  )     =  =     ( ProcessType . APPLICATION _ CLIENT )  ;", "final   ModelNode   globalModules    =    GlobalModulesDefinition . INSTANCE . resolveModelAttribute ( context ,    model )  ;", "final   boolean   earSubDeploymentsIsolated    =    EeSubsystemRootResource . EAR _ SUBDEPLOYMENTS _ ISOLATED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   specDescriptorPropertyReplacement    =    EeSubsystemRootResource . SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   jbossDescriptorPropertyReplacement    =    EeSubsystemRootResource . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   boolean   ejbAnnotationPropertyReplacement    =    EeSubsystemRootResource . ANNOTATION _ PROPERTY _ REPLACEMENT . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "moduleDependencyProcessor . setGlobalModules ( GlobalModulesDefinition . createModuleList ( context ,    globalModules )  )  ;", "isolationProcessor . setEarSubDeploymentsIsolated ( earSubDeploymentsIsolated )  ;", "specDescriptorPropertyReplacementProcessor . setDescriptorPropertyReplacement ( specDescriptorPropertyReplacement )  ;", "jbossDescriptorPropertyReplacementProcessor . setDescriptorPropertyReplacement ( jbossDescriptorPropertyReplacement )  ;", "ejbAnnotationPropertyReplacementProcessor . setDescriptorPropertyReplacement ( ejbAnnotationPropertyReplacement )  ;", "context . addStep ( new   AbstractDeploymentChainStep (  )     {", "protected   void   execute ( DeploymentProcessorTarget   processorTarget )     {", "EeLogger . ROOT _ LOGGER . debug (  \" Activating   EE   subsystem \"  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ DEPLOYMENT _ PROPERTIES ,    new   DeploymentPropertiesProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ DEPLOYMENT _ PROPERTY _ RESOLVER ,    new   DeploymentPropertyResolverProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ VAULT _ PROPERTY _ RESOLVER ,    new   VaultPropertyResolverProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ SYSTEM _ PROPERTY _ RESOLVER ,    new   SystemPropertyResolverProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ PROPERTY _ RESOLVER ,    new   PropertyResolverProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ REGISTER _ JBOSS _ ALL _ EE _ APP ,    new   server . deployment . jbossallxml . JBossAllXmlParserRegisteringProcessor < JBossAppMetaData >  ( AppJBossAllParser . ROOT _ ELEMENT ,    AppJBossAllParser . ATTACHMENT _ KEY ,    new   AppJBossAllParser (  )  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ SPEC _ DESC _ PROPERTY _ REPLACEMENT ,    specDescriptorPropertyReplacementProcessor )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ JBOSS _ DESC _ PROPERTY _ REPLACEMENT ,    jbossDescriptorPropertyReplacementProcessor )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ EJB _ ANNOTATION _ PROPERTY _ REPLACEMENT ,    ejbAnnotationPropertyReplacementProcessor )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EAR _ DEPLOYMENT _ INIT ,    new   EarInitializationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EAR _ APP _ XML _ PARSE ,    new   EarMetaDataParsingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ JBOSS _ EJB _ CLIENT _ XML _ PARSE ,    new   EJBClientDescriptorParsingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EJB _ EAR _ APPLICATION _ NAME ,    new   EarApplicationNameProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EAR ,    new   EarStructureProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EJB _ JAR _ IN _ EAR ,    new   EjbJarDeploymentProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ APPLICATION _ CLIENT _ IN _ EAR ,    new   ApplicationClientDeploymentProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ MANAGED _ BEAN _ JAR _ IN _ EAR ,    new   ManagedBeanSubDeploymentMarkingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EAR _ SUB _ DEPLYOMENTS _ ISOLATED ,    isolationProcessor )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ MODULE _ INIT ,    new   EEModuleInitialProcessor (  (  ( context . getProcessType (  )  )     =  =     ( ProcessType . APPLICATION _ CLIENT )  )  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ EE _ RESOURCE _ INJECTION _ REGISTRY ,    new   ResourceReferenceRegistrySetupProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ GLOBAL _ MODULES ,    moduleDependencyProcessor )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ EE _ MODULE _ NAME ,    new   EEModuleNameProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ EE _ ANNOTATIONS ,    new   EEAnnotationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ LIFECYCLE _ ANNOTATION ,    new   LifecycleAnnotationParsingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ AROUNDINVOKE _ ANNOTATION ,    new   AroundInvokeAnnotationParsingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ DISTINCT _ NAME ,    new   EEDistinctNameProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ EAR _ MESSAGE _ DESTINATIONS ,    new   EarMessageDestinationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ MANAGED _ BEAN _ ANNOTATION ,    new   ManagedBeanAnnotationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ DESCRIPTOR _ LIFECYCLE _ METHOD _ RESOLUTION ,    new   DescriptorEnvironmentLifecycleMethodProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    DEPENDENCIES ,    DEPENDENCIES _ EE _ PERMISSIONS ,    new   EEDefaultPermissionsProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    DEPENDENCIES ,    DEPENDENCIES _ MANAGED _ BEAN ,    new   JavaEEDependencyProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    DEPENDENCIES ,    DEPENDENCIES _ EE _ CLASS _ DESCRIPTIONS ,    new   ApplicationClassesAggregationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ EAR _ DEPENDENCY ,    new   EarDependencyProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ INITIALIZE _ IN _ ORDER ,    new   InitializeInOrderProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ INJECTION _ ANNOTATION ,    new   ResourceInjectionAnnotationParsingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ ENV _ ENTRY ,    new   ResourceReferenceProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ INTERCEPTOR _ ANNOTATIONS ,    new   InterceptorAnnotationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ NAMING _ CONTEXT ,    new   ModuleContextProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ IN _ APP _ CLIENT ,    new   InApplicationClientBindingProcessor ( appclient )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ EE _ INSTANCE _ NAME ,    new   InstanceNameBindingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ APP _ NAMING _ CONTEXT ,    new   ApplicationContextProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ EE _ CONCURRENT _ CONTEXT ,    new   EEConcurrentContextProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ RESOLVE _ MESSAGE _ DESTINATIONS ,    new   MessageDestinationResolutionProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ COMPONENT _ AGGREGATION ,    new   ComponentAggregationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ DEFAULT _ BINDINGS _ EE _ CONCURRENCY ,    new   EEConcurrentDefaultBindingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ MODULE _ JNDI _ BINDINGS ,    new   ModuleJndiBindingProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ EE _ MODULE _ CONFIG ,    new   EEModuleConfigurationProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ EE _ COMPONENT ,    new   ComponentInstallProcessor (  )  )  ;", "processorTarget . addDeploymentProcessor ( EeExtension . SUBSYSTEM _ NAME ,    CLEANUP ,    CLEANUP _ EE ,    new   EECleanUpProcessor (  )  )  ;", "}", "}  ,    RUNTIME )  ;", "context . getServiceTarget (  )  . addService ( ReflectiveClassIntrospector . SERVICE _ NAME ,    new   ReflectiveClassIntrospector (  )  )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["performBoottime"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   ad    :    EeSubsystemRootResource . ATTRIBUTES )     {", "ad . validateAndSet ( operation ,    model )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "return   new   EeSubsystemRootResource (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemRootResource"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem . xml \"  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "List < ModelNode >    xmlOps    =    builder . parseXml ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - ee :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "FailedOperationTransformationConfig . ChainedConfig   chained    =    ChainedConfig . createBuilder ( GlobalModulesDefinition . INSTANCE . getName (  )  ,    EESubsystemModel . ANNOTATION _ PROPERTY _ REPLACEMENT )  . addConfig ( new    . GlobalModulesConfig (  )  )  . addConfig ( new   FailedOperationTransformationConfig . RejectExpressionsConfig ( EESubsystemModel . ANNOTATION _ PROPERTY _ REPLACEMENT )     {", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "ModelNode   resolved    =    super . correctValue ( toResolve ,    isWriteAttribute )  ;", "return   new   ModelNode ( resolved . asBoolean (  )  )  ;", "}", "}  )  . build (  )  ;", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM )  ,    chained )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . CONTEXT _ SERVICE )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . MANAGED _ THREAD _ FACTORY )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . MANAGED _ EXECUTOR _ SERVICE )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE )  )  ,    REJECTED _ RESOURCE )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    xmlOps ,    config )  ;", "}", "METHOD_END"], "methodName": ["testTransformers1_0_x_reject"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem - transformers . xml \"  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - ee :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformers1_1"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem . xml \"  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "List < ModelNode >    xmlOps    =    builder . parseXml ( subsystemXml )  ;", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     1  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - ee :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . CONTEXT _ SERVICE )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . MANAGED _ THREAD _ FACTORY )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . MANAGED _ EXECUTOR _ SERVICE )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( EeExtension . PATH _ SUBSYSTEM ,    PathElement . pathElement ( EESubsystemModel . MANAGED _ SCHEDULED _ EXECUTOR _ SERVICE )  )  ,    REJECTED _ RESOURCE )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    xmlOps ,    config )  ;", "}", "METHOD_END"], "methodName": ["testTransformers1_1_x_reject"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem - transformers - discard . xml \"  )  ;", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - ee :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . configureReverseControllerCheck ( MANAGEMENT ,     (    modelNode )     -  >     {", "for    ( ModelNode   node    :    modelNode . get ( GLOBAL _ MODULES )  . asList (  )  )     {", "if    (  \" log 4 j \"  . equals ( node . get ( NAME )  . asString (  )  )  )     {", "if    (  !  ( node . has ( ANNOTATIONS )  )  )     {", "node . get ( ANNOTATIONS )  . set ( false )  ;", "}", "if    (  !  ( node . has ( META _ INF )  )  )     {", "node . get ( META _ INF )  . set ( false )  ;", "}", "if    (  !  ( node . has ( SERVICES )  )  )     {", "node . get ( SERVICES )  . set ( true )  ;", "}", "}", "}", "return   modelNode ;", "}  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "ModelNode   globalModules    =    mainServices . readTransformedModel ( modelVersion )  . get ( SUBSYSTEM ,     \" ee \"  )  . get ( GlobalModulesDefinition . GLOBAL _ MODULES )  ;", "for    ( ModelNode   node    :    globalModules . asList (  )  )     {", "if    (  (  ( node . hasDefined ( GlobalModulesDefinition . ANNOTATIONS )  )     |  |     ( node . hasDefined ( GlobalModulesDefinition . SERVICES )  )  )     |  |     ( node . hasDefined ( GlobalModulesDefinition . META _ INF )  )  )     {", "Assert . fail (  ( node    +     \"     -  -    attributes   not   discarded \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testTransformersDiscardsImpliedValues1_0_0"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem - transformers - discard . xml \"  )  ;", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     1  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXml ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - ee :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . configureReverseControllerCheck ( MANAGEMENT ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersDiscardsImpliedValues1_1_0"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersDiscardsImpliedValues 1  _  0  _  0  ( EAP _  6  _  2  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersDiscardsImpliedValuesEAP620"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersDiscardsImpliedValues 1  _  1  _  0  ( EAP _  6  _  3  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersDiscardsImpliedValuesEAP630"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersDiscardsImpliedValues 1  _  1  _  0  ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersDiscardsImpliedValuesEAP640"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  _  1  ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP620"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  _  0  _ x _ reject ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP620Reject"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  _  1  ( EAP _  6  _  3  _  0  ,    ModelVersion . create (  1  ,     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP630"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  _  1  _ x _ reject ( EAP _  6  _  3  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP630Reject"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  _  1  ( EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP640"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers 1  _  1  _ x _ reject ( EAP _  6  _  4  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP640Reject"], "fileName": "org.jboss.as.ee.subsystem.EeSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( GlobalModulesDefinition . INSTANCE . getName (  )  . equals ( attributeName )  )     {", "moduleDependencyProcessor . setGlobalModules ( GlobalModulesDefinition . createModuleList ( context ,    newValue )  )  ;", "} else", "if    ( EeSubsystemRootResource . EAR _ SUBDEPLOYMENTS _ ISOLATED . getName (  )  . equals ( attributeName )  )     {", "boolean   isolate    =    newValue . asBoolean (  )  ;", "isolationProcessor . setEarSubDeploymentsIsolated ( isolate )  ;", "} else", "if    ( EeSubsystemRootResource . SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getName (  )  . equals ( attributeName )  )     {", "boolean   enabled    =    newValue . asBoolean (  )  ;", "specDescriptorPropertyReplacementProcessor . setDescriptorPropertyReplacement ( enabled )  ;", "} else", "if    ( EeSubsystemRootResource . JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT . getName (  )  . equals ( attributeName )  )     {", "boolean   enabled    =    newValue . asBoolean (  )  ;", "jbossDescriptorPropertyReplacementProcessor . setDescriptorPropertyReplacement ( enabled )  ;", "} else", "if    ( EeSubsystemRootResource . ANNOTATION _ PROPERTY _ REPLACEMENT . getName (  )  . equals ( attributeName )  )     {", "boolean   enabled    =    newValue . asBoolean (  )  ;", "annotationPropertyReplacementProcessor . setDescriptorPropertyReplacement ( enabled )  ;", "}", "}", "METHOD_END"], "methodName": ["applyUpdateToDeploymentUnitProcessor"], "fileName": "org.jboss.as.ee.subsystem.EeWriteAttributeHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   ad    :    EeSubsystemRootResource . ATTRIBUTES )     {", "registry . registerRead ( ad ,    null ,    this )  ;", "}", "}", "METHOD_END"], "methodName": ["registerAttributes"], "fileName": "org.jboss.as.ee.subsystem.EeWriteAttributeHandler"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.ee.subsystem.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.ee.subsystem.Element"}, {"methodBody": ["METHOD_START", "{", "final   List < GlobalModulesDefinition . GlobalModule >    ret    =    new   ArrayList <  >  (  )  ;", "if    ( globalMods . isDefined (  )  )     {", "for    ( final   ModelNode   module    :    globalMods . asList (  )  )     {", "String   name    =    GlobalModulesDefinition . NAME _ AD . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "String   slot    =    GlobalModulesDefinition . SLOT _ AD . resolveModelAttribute ( context ,    module )  . asString (  )  ;", "boolean   annotations    =    GlobalModulesDefinition . ANNOTATIONS _ AD . resolveModelAttribute ( context ,    module )  . asBoolean (  )  ;", "boolean   services    =    GlobalModulesDefinition . SERVICES _ AD . resolveModelAttribute ( context ,    module )  . asBoolean (  )  ;", "boolean   metaInf    =    GlobalModulesDefinition . META _ INF _ AD . resolveModelAttribute ( context ,    module )  . asBoolean (  )  ;", "ret . add ( new   GlobalModulesDefinition . GlobalModule ( ModuleIdentifier . create ( name ,    slot )  ,    annotations ,    services ,    metaInf )  )  ;", "}", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["createModuleList"], "fileName": "org.jboss.as.ee.subsystem.GlobalModulesDefinition"}, {"methodBody": ["METHOD_START", "{", "final   PathElement   pathElement    =    getPathElement (  )  ;", "final   ResourceTransformationDescriptionBuilder   resourceBuilder    =    builder . addChildResource ( pathElement )  ;", "resourceBuilder . getAttributeBuilder (  )  . addRejectCheck ( UNDEFINED ,     . CORE _ THREADS _ AD )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_4_0"], "fileName": "org.jboss.as.ee.subsystem.ManagedExecutorServiceResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   PathElement   pathElement    =    getPathElement (  )  ;", "final   ResourceTransformationDescriptionBuilder   resourceBuilder    =    builder . addChildResource ( pathElement )  ;", "resourceBuilder . getAttributeBuilder (  )  . addRejectCheck ( UNDEFINED ,     . CORE _ THREADS _ AD )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_4_0"], "fileName": "org.jboss.as.ee.subsystem.ManagedScheduledExecutorServiceResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.ee.subsystem.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.ee.subsystem.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   beanValidationIncluded ;", "}", "METHOD_END"], "methodName": ["isBeanValidationIncluded"], "fileName": "org.jboss.as.ee.subsystem.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   ClassLoadingUtils . loadClass ( className ,    du . getAttachment ( MODULE )  )  ;", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.ee.utils.ClassLoadingUtils"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   oldTccl    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( module . getClassLoader (  )  )  ;", "return   Class . forName ( className ,    false ,    module . getClassLoader (  )  )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl )  ;", "}", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.jboss.as.ee.utils.ClassLoadingUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( descriptor . length (  )  )     =  =     1  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isPrimitive"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "String   primitive    =    DescriptorUtils . primitives . get ( c )  ;", "if    ( primitive    !  =    null )     {", "return   primitive ;", "} else", "if    ( c . isArray (  )  )     {", "return   c . getName (  )  . replace (  \"  .  \"  ,     \"  /  \"  )  ;", "} else    {", "return   DescriptorUtils . makeDescriptor ( c . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["makeDescriptor"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "String   repl    =    className . replace (  \"  .  \"  ,     \"  /  \"  )  ;", "return    (  ' L '     +    repl )     +     '  ;  '  ;", "}", "METHOD_END"], "methodName": ["makeDescriptor"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   desc    =    new   StringBuilder (  \"  (  \"  )  ;", "for    ( Class <  ?  >    p    :    c . getParameterTypes (  )  )     {", "desc . append (  . makeDescriptor ( p )  )  ;", "}", "desc . append (  \"  )  \"  )  ;", "desc . append (  \" V \"  )  ;", "return   desc . toString (  )  ;", "}", "METHOD_END"], "methodName": ["makeDescriptor"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   desc    =    new   StringBuilder (  \"  (  \"  )  ;", "for    ( String   p    :    parameters )     {", "desc . append ( p )  ;", "}", "desc . append (  \"  )  \"  )  ;", "desc . append ( returnType )  ;", "return   desc . toString (  )  ;", "}", "METHOD_END"], "methodName": ["methodDescriptor"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   desc    =    new   StringBuilder (  \"  (  \"  )  ;", "for    ( Class <  ?  >    p    :    m . getParameterTypes (  )  )     {", "desc . append (  . makeDescriptor ( p )  )  ;", "}", "desc . append (  \"  )  \"  )  ;", "desc . append (  . makeDescriptor ( m . getReturnType (  )  )  )  ;", "return   desc . toString (  )  ;", "}", "METHOD_END"], "methodName": ["methodDescriptor"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "String [  ]    ret    =    new   String [ parameters . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( ret . length )  ;     +  + i )     {", "ret [ i ]     =     . makeDescriptor ( parameters [ i ]  )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["parameterDescriptors"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "int   i    =     1  ;", "List < String >    ret    =    new   ArrayList < String >  (  )  ;", "int   arrayStart    =     -  1  ;", "while    (  ( method . charAt ( i )  )     !  =     '  )  '  )     {", "String   type    =    null ;", "if    (  ( method . charAt ( i )  )     =  =     '  [  '  )     {", "if    ( arrayStart    =  =     (  -  1  )  )     {", "arrayStart    =    i ;", "}", "} else    {", "if    (  ( method . charAt ( i )  )     =  =     ' L '  )     {", "int   start    =    i ;", "i +  +  ;", "while    (  ( method . charAt ( i )  )     !  =     '  ;  '  )     {", "+  + i ;", "}", "if    ( arrayStart    =  =     (  -  1  )  )     {", "type    =    method . substring ( start ,    i )  ;", "} else    {", "type    =    method . substring ( arrayStart ,    i )  ;", "}", "} else    {", "if    ( arrayStart    =  =     (  -  1  )  )     {", "type    =     ( method . charAt ( i )  )     +     \"  \"  ;", "} else    {", "type    =    method . substring ( arrayStart ,     ( i    +     1  )  )  ;", "}", "}", "arrayStart    =     -  1  ;", "ret . add ( type )  ;", "}", "+  + i ;", "}", "String [  ]    r    =    new   String [ ret . size (  )  ]  ;", "for    ( int   j    =     0  ;    j    <     ( ret . size (  )  )  ;     +  + j )     {", "r [ j ]     =    ret . get ( j )  ;", "}", "return   r ;", "}", "METHOD_END"], "methodName": ["parameterDescriptors"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "return   DescriptorUtils . parameterDescriptors ( m . getParameterTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterDescriptors"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "return   methodDescriptor . substring (  (  ( methodDescriptor . lastIndexOf (  '  )  '  )  )     +     1  )  ,    methodDescriptor . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["returnType"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( descriptor . length (  )  )     =  =     0  )     {", "throw   EeLogger . ROOT _ LOGGER . cannotBeEmpty (  \" descriptors \"  )  ;", "}", "if    (  ( descriptor . length (  )  )     >     1  )     {", "if    ( descriptor . startsWith (  \" L \"  )  )     {", "if    (  !  ( descriptor . endsWith (  \"  ;  \"  )  )  )     {", "throw   EeLogger . ROOT _ LOGGER . invalid ( descriptor )  ;", "}", "} else", "if    ( descriptor . startsWith (  \"  [  \"  )  )     {", "} else    {", "throw   EeLogger . ROOT _ LOGGER . invalid ( descriptor )  ;", "}", "} else    {", "char   type    =    descriptor . charAt (  0  )  ;", "switch    ( type )     {", "case    ' I '     :", "case    ' Z '     :", "case    ' S '     :", "case    ' B '     :", "case    ' F '     :", "case    ' D '     :", "case    ' V '     :", "case    ' J '     :", "case    ' C '     :", "break ;", "default    :", "throw   EeLogger . ROOT _ LOGGER . invalid ( descriptor )  ;", "}", "}", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["validateDescriptor"], "fileName": "org.jboss.as.ee.utils.DescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    injectionTargetClass ;", "try    {", "injectionTargetClass    =    classLoader . loadClass ( injectionTargetClassName )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   EeLogger . ROOT _ LOGGER . cannotLoad ( e ,    injectionTargetClassName )  ;", "}", "final   ClassReflectionIndex   index    =    deploymentReflectionIndex . getClassIndex ( injectionTargetClass )  ;", "String   methodName    =     (  \" set \"     +     ( injectionTargetName . substring (  0  ,     1  )  . toUpperCase ( Locale . ENGLISH )  )  )     +     ( injectionTargetName . substring (  1  )  )  ;", "boolean   methodFound    =    false ;", "Method   method    =    null ;", "Field   field    =    null ;", "Class <  ?  >    current    =    injectionTargetClass ;", "while    (  (  ( current    !  =     ( Object . class )  )     &  &     ( current    !  =    null )  )     &  &     (  ! methodFound )  )     {", "final   Collection < Method >    methods    =    index . getAllMethods ( methodName )  ;", "for    ( Method   m    :    methods )     {", "if    (  ( m . getParameterTypes (  )  . length )     =  =     1  )     {", "if    (  ( m . isBridge (  )  )     |  |     ( m . isSynthetic (  )  )  )     {", "continue ;", "}", "if    ( methodFound )     {", "throw   EeLogger . ROOT _ LOGGER . multipleSetterMethodsFound ( injectionTargetName ,    injectionTargetClassName )  ;", "}", "methodFound    =    true ;", "method    =    m ;", "}", "}", "current    =    current . getSuperclass (  )  ;", "}", "if    ( method    =  =    null )     {", "current    =    injectionTargetClass ;", "while    (  (  ( current    !  =     ( Object . class )  )     &  &     ( current    !  =    null )  )     &  &     ( field    =  =    null )  )     {", "field    =    index . getField ( injectionTargetName )  ;", "if    ( field    !  =    null )     {", "break ;", "}", "current    =    current . getSuperclass (  )  ;", "}", "}", "if    (  ( field    =  =    null )     &  &     ( method    =  =    null )  )     {", "throw   EeLogger . ROOT _ LOGGER . cannotResolvePoint ( injectionTargetName ,    injectionTargetClassName )  ;", "}", "return   field    !  =    null    ?    field    :    method ;", "}", "METHOD_END"], "methodName": ["getInjectionTarget"], "fileName": "org.jboss.as.ee.utils.InjectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( unit . getParent (  )  )     =  =    null )     {", "return    ( unit . getAttachment (  . MARKER )  )     !  =    null ;", "} else    {", "return    ( unit . getParent (  )  . getAttachment (  . MARKER )  )     !  =    null ;", "}", "}", "METHOD_END"], "methodName": ["isPartOfWeldDeployment"], "fileName": "org.jboss.as.ee.weld.WeldDeploymentMarker"}, {"methodBody": ["METHOD_START", "{", "return    ( unit . getAttachment ( WeldDeploymentMarker . MARKER )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isWeldDeployment"], "fileName": "org.jboss.as.ee.weld.WeldDeploymentMarker"}, {"methodBody": ["METHOD_START", "{", "unit . putAttachment ( WeldDeploymentMarker . MARKER ,    Boolean . TRUE )  ;", "if    (  ( unit . getParent (  )  )     !  =    null )     {", "WeldDeploymentMarker . mark ( unit . getParent (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["mark"], "fileName": "org.jboss.as.ee.weld.WeldDeploymentMarker"}]