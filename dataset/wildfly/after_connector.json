[{"methodBody": ["METHOD_START", "{", "return   this . getClass (  )  . getResource ( archive )  . toURI (  )  ;", "}", "METHOD_END"], "methodName": ["getURI"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "annotations    =    new   Annotations (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "annotations    =    null ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / ra 1  6 annoactiv . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "}    catch    ( Throwable   t )     {", "fail ( t . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProcessActivation"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / ra 1  6 annoadminobj . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "}    catch    ( Throwable   t )     {", "fail ( t . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProcessAdministeredObject"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / ra 1  6 annoauthmech . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "}    catch    ( Throwable   t )     {", "fail ( t . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProcessAuthenticationMechanism"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / ra 1  6 annoconfprop . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "}    catch    ( Throwable   t )     {", "fail ( t . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProcessConfigProperty"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / ra 1  6 annoconndef . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "}    catch    ( Throwable   t )     {", "fail ( t . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProcessConnectionDefinition"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / ra 1  6 annoconndefs . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "}    catch    ( Throwable   t )     {", "t . printStackTrace (  )  ;", "fail ( t . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProcessConnectionDefinitions"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / ra 1  6 inoutanno . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "}    catch    ( Throwable   t )     {", "t . printStackTrace (  )  ;", "fail ( t . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProcessConnector"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "URI   uri    =    getURI (  \"  / rafail 2 connector . rar \"  )  ;", "final   VirtualFile   virtualFile    =    VFS . getChild ( uri )  ;", "final   Indexer   indexer    =    new   Indexer (  )  ;", "final   List < VirtualFile >    classChildren    =    virtualFile . getChildren ( new   SuffixMatchFilter (  \"  . class \"  ,    VisitorAttributes . RECURSE _ LEAVES _ ONLY )  )  ;", "for    ( VirtualFile   classFile    :    classChildren )     {", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    classFile . openStream (  )  ;", "indexer . index ( inputStream )  ;", "}    finally    {", "VFSUtils . safeClose ( inputStream )  ;", "}", "}", "final   Index   index    =    indexer . complete (  )  ;", "AnnotationRepository   ar    =    new   JandexAnnotationRepositoryImpl ( index ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "process ( ar ,    null ,    Thread . currentThread (  )  . getContextClassLoader (  )  )  ;", "fail (  \" Success \"  )  ;", "}    catch    ( Throwable   t )     {", "}", "}", "METHOD_END"], "methodName": ["testProcessConnectorFail"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "annotations . process ( null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testProcessNullAnnotationRepository"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "annotations . process ( null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testProcessNullArguments"], "fileName": "org.jboss.as.connector.annotations.repository.jandex.AnnotationsTestCase"}, {"methodBody": ["METHOD_START", "{", "Boolean   attachment    =    deploymentUnit . getAttachment ( JBOSS _ DESCRIPTOR _ PROPERTY _ REPLACEMENT )  ;", "return    ( attachment    !  =    null )     &  &     ( attachment . booleanValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResolveJBoss"], "fileName": "org.jboss.as.connector.deployers.Util"}, {"methodBody": ["METHOD_START", "{", "Boolean   attachment    =    deploymentUnit . getAttachment ( SPEC _ DESCRIPTOR _ PROPERTY _ REPLACEMENT )  ;", "return    ( attachment    !  =    null )     &  &     ( attachment . booleanValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResolveSpec"], "fileName": "org.jboss.as.connector.deployers.Util"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    metaData . getName (  )  ;", "if    (  ( name    =  =    null )     |  |     ( name . isEmpty (  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < data - source >  \"  ,     \" name \"  )  ;", "}", "final   InjectionSource   resourceDefinitionInjectionSource    =    new   InjectionSource ( name )  ;", "final   String   className    =    metaData . getClassName (  )  ;", "if    (  ( className    =  =    null )     |  |     ( className . equals ( Object . class . getName (  )  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < data - source >  \"  ,     \" className \"  )  ;", "}", "resourceDefinitionInjectionSource . setClassName ( className )  ;", "resourceDefinitionInjectionSource . setDatabaseName ( metaData . getDatabaseName (  )  )  ;", "if    (  ( metaData . getDescriptions (  )  )     !  =    null )     {", "resourceDefinitionInjectionSource . setDescription ( metaData . getDescriptions (  )  . toString (  )  )  ;", "}", "resourceDefinitionInjectionSource . setInitialPoolSize ( metaData . getInitialPoolSize (  )  )  ;", "if    (  ( metaData . getIsolationLevel (  )  )     !  =    null )     {", "resourceDefinitionInjectionSource . setIsolationLevel ( metaData . getIsolationLevel (  )  . ordinal (  )  )  ;", "}", "resourceDefinitionInjectionSource . setLoginTimeout ( metaData . getLoginTimeout (  )  )  ;", "resourceDefinitionInjectionSource . setMaxIdleTime ( metaData . getMaxIdleTime (  )  )  ;", "resourceDefinitionInjectionSource . setMaxStatements ( metaData . getMaxStatements (  )  )  ;", "resourceDefinitionInjectionSource . setMaxPoolSize ( metaData . getMaxPoolSize (  )  )  ;", "resourceDefinitionInjectionSource . setMinPoolSize ( metaData . getMinPoolSize (  )  )  ;", "resourceDefinitionInjectionSource . setInitialPoolSize ( metaData . getInitialPoolSize (  )  )  ;", "resourceDefinitionInjectionSource . setPassword ( metaData . getPassword (  )  )  ;", "resourceDefinitionInjectionSource . setPortNumber ( metaData . getPortNumber (  )  )  ;", "resourceDefinitionInjectionSource . addProperties ( metaData . getProperties (  )  )  ;", "resourceDefinitionInjectionSource . setServerName ( metaData . getServerName (  )  )  ;", "resourceDefinitionInjectionSource . setTransactional ( metaData . getTransactional (  )  )  ;", "resourceDefinitionInjectionSource . setUrl ( metaData . getUrl (  )  )  ;", "resourceDefinitionInjectionSource . setUser ( metaData . getUser (  )  )  ;", "return   resourceDefinitionInjectionSource ;", "}", "METHOD_END"], "methodName": ["getResourceDefinitionInjectionSource"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Iterator < Map . Entry < String ,    String >  >    it    =    props . entrySet (  )  . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "final   Map . Entry < String ,    String >    entry    =    it . next (  )  ;", "String   value    =    entry . getKey (  )  ;", "if    (  ( value    =  =    null )     |  |     (  \"  \"  . equals ( value )  )  )     {", "it . remove (  )  ;", "} else    {", "StringBuilder   builder    =    new   StringBuilder (  \" set \"  )  . append ( entry . getKey (  )  )  ;", "builder . setCharAt (  3  ,    Character . toUpperCase ( entry . getKey (  )  . charAt (  0  )  )  )  ;", "final   String   methodName    =    builder . toString (  )  ;", "final   Class <  ?  >    paramType    =    value . getClass (  )  ;", "final   MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName ,    paramType )  ;", "final   Method   setterMethod    =    ClassReflectionIndexUtil . findMethod ( reflectionIndex ,    dataSourceClass ,    methodIdentifier )  ;", "if    ( setterMethod    =  =    null )     {", "it . remove (  )  ;", "ConnectorLogger . DS _ DEPLOYER _ LOGGER . methodNotFoundOn ( methodName ,    dataSourceClass )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["clearUnknownProperties"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   databaseName ;", "}", "METHOD_END"], "methodName": ["getDatabaseName"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   initialPoolSize ;", "}", "METHOD_END"], "methodName": ["getInitialPoolSize"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   isolationLevel ;", "}", "METHOD_END"], "methodName": ["getIsolationLevel"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   loginTimeout ;", "}", "METHOD_END"], "methodName": ["getLoginTimeout"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   maxIdleTime ;", "}", "METHOD_END"], "methodName": ["getMaxIdleTime"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   maxPoolSize ;", "}", "METHOD_END"], "methodName": ["getMaxPoolSize"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   maxStatements ;", "}", "METHOD_END"], "methodName": ["getMaxStatements"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   minPoolSize ;", "}", "METHOD_END"], "methodName": ["getMinPoolSize"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   portNumber ;", "}", "METHOD_END"], "methodName": ["getPortNumber"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   EEModuleDescription   eeModuleDescription    =    deploymentUnit . getAttachment ( EE _ MODULE _ DESCRIPTION )  ;", "final   String   poolName    =    uniqueName ( context ,    jndiName )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( context . getApplicationName (  )  ,    context . getModuleName (  )  ,    context . getComponentName (  )  ,     (  !  ( context . isCompUsesModule (  )  )  )  ,    jndiName )  ;", "final   DeploymentReflectionIndex   reflectionIndex    =    deploymentUnit . getAttachment ( REFLECTION _ INDEX )  ;", "try    {", "final   Class <  ?  >    clazz    =    module . getClassLoader (  )  . loadClass ( className )  ;", "clearUnknownProperties ( reflectionIndex ,    clazz ,    properties )  ;", "populateProperties ( reflectionIndex ,    clazz ,    properties )  ;", "DsSecurityImpl   dsSecurity    =    new   DsSecurityImpl ( user ,    password ,    null ,    false ,    null ,    null )  ;", "if    (  ( XA . class . isAssignableFrom ( clazz )  )     &  &     ( transactional )  )     {", "final   DsXaPoolImpl   xaPool    =    new   DsXaPoolImpl (  (  ( minPoolSize )     <     0     ?    Defaults . MIN _ POOL _ SIZE    :    Integer . valueOf ( minPoolSize )  )  ,     (  ( initialPoolSize )     <     0     ?    Defaults . INITIAL _ POOL _ SIZE    :    Integer . valueOf ( initialPoolSize )  )  ,     (  ( maxPoolSize )     <     1     ?    Defaults . MAX _ POOL _ SIZE    :    Integer . valueOf ( maxPoolSize )  )  ,    Defaults . PREFILL ,    Defaults . USE _ STRICT _ MIN ,    Defaults . FLUSH _ STRATEGY ,    Defaults . IS _ SAME _ RM _ OVERRIDE ,    Defaults . INTERLEAVING ,    Defaults . PAD _ XID ,    Defaults . WRAP _ XA _ RESOURCE ,    Defaults . NO _ TX _ SEPARATE _ POOL ,    Boolean . FALSE ,    null ,    Defaults . FAIR ,    null )  ;", "final   ModifiableXa   dataSource    =    new   ModifiableXa ( transactionIsolation (  )  ,    null ,    dsSecurity ,    null ,    null ,    null ,    null ,    null ,    null ,    poolName ,    true ,    jndiName ,    false ,    false ,    Defaults . CONNECTABLE ,    Defaults . TRACKING ,    Defaults . MCP ,    Defaults . ENLISTMENT _ TRACE ,    properties ,    className ,    null ,    null ,    xaPool ,    null )  ;", "final   XaService   xds    =    new   XaService ( bindInfo . getBinderServiceName (  )  . getCanonicalName (  )  ,    bindInfo ,    module . getClassLoader (  )  )  ;", "xds . getConfigInjector (  )  . inject ( dataSource )  ;", "start ( xds ,    bindInfo ,    eeModuleDescription ,    context ,    phaseContext . getServiceTarget (  )  ,    serviceBuilder ,    injector )  ;", "} else    {", "final   DsPoolImpl   commonPool    =    new   DsPoolImpl (  (  ( minPoolSize )     <     0     ?    Defaults . MIN _ POOL _ SIZE    :    Integer . valueOf ( minPoolSize )  )  ,     (  ( initialPoolSize )     <     0     ?    Defaults . INITIAL _ POOL _ SIZE    :    Integer . valueOf ( initialPoolSize )  )  ,     (  ( maxPoolSize )     <     1     ?    Defaults . MAX _ POOL _ SIZE    :    Integer . valueOf ( maxPoolSize )  )  ,    Defaults . PREFILL ,    Defaults . USE _ STRICT _ MIN ,    Defaults . FLUSH _ STRATEGY ,    Boolean . FALSE ,    null ,    Defaults . FAIR ,    null )  ;", "final   Modifiable   dataSource    =    new   Modifiable ( url ,    null ,    className ,    null ,    transactionIsolation (  )  ,    properties ,    null ,    dsSecurity ,    null ,    null ,    null ,    null ,    null ,    false ,    poolName ,    true ,    jndiName ,    Defaults . SPY ,    Defaults . USE _ CCM ,    transactional ,    Defaults . CONNECTABLE ,    Defaults . TRACKING ,    Defaults . MCP ,    Defaults . ENLISTMENT _ TRACE ,    commonPool )  ;", "final   LocalService   ds    =    new   LocalService ( bindInfo . getBinderServiceName (  )  . getCanonicalName (  )  ,    bindInfo ,    module . getClassLoader (  )  )  ;", "ds . getConfigInjector (  )  . inject ( dataSource )  ;", "start ( ds ,    bindInfo ,    eeModuleDescription ,    context ,    phaseContext . getServiceTarget (  )  ,    serviceBuilder ,    injector )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   DeploymentUnitProcessingException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   serverName ;", "}", "METHOD_END"], "methodName": ["getServerName"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   user ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   transactional ;", "}", "METHOD_END"], "methodName": ["isTransactional"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . DESCRIPTION _ PROP ,    description )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . URL _ PROP ,    url )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . UPPERCASE _ URL _ PROP ,    url )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . DATABASE _ NAME _ PROP ,    databaseName )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . SERVER _ NAME _ PROP ,    serverName )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . PORT _ NUMBER _ PROP ,    Integer . valueOf ( portNumber )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . LOGIN _ TIMEOUT _ PROP ,    Integer . valueOf ( loginTimeout )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . ISOLATION _ LEVEL _ PROP ,    Integer . valueOf ( isolationLevel )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . TRANSACTIONAL _ PROP ,    Boolean . valueOf ( transactional )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . INITIAL _ POOL _ SIZE _ PROP ,    Integer . valueOf ( initialPoolSize )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . MAX _ IDLE _ TIME _ PROP ,    Integer . valueOf ( maxIdleTime )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . MAX _ POOL _ SIZE _ PROP ,    Integer . valueOf ( maxPoolSize )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . MAX _ STATEMENTS _ PROP ,    Integer . valueOf ( maxStatements )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . MIN _ POOL _ SIZE _ PROP ,    Integer . valueOf ( minPoolSize )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . INITIAL _ POOL _ SIZE _ PROP ,    Integer . valueOf ( minPoolSize )  )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . USER _ PROP ,    user )  ;", "setProperty ( deploymentReflectionIndex ,    dataSourceClass ,    properties ,    DataSourceDefinitionInjectionSource . PASSWORD _ PROP ,    password )  ;", "}", "METHOD_END"], "methodName": ["populateProperties"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . className    =    className ;", "}", "METHOD_END"], "methodName": ["setClassName"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . databaseName    =    databaseName ;", "}", "METHOD_END"], "methodName": ["setDatabaseName"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . initialPoolSize    =    initialPoolSize ;", "}", "METHOD_END"], "methodName": ["setInitialPoolSize"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . isolationLevel    =    isolationLevel ;", "}", "METHOD_END"], "methodName": ["setIsolationLevel"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . loginTimeout    =    loginTimeout ;", "}", "METHOD_END"], "methodName": ["setLoginTimeout"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . maxIdleTime    =    maxIdleTime ;", "}", "METHOD_END"], "methodName": ["setMaxIdleTime"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . maxPoolSize    =    maxPoolSize ;", "}", "METHOD_END"], "methodName": ["setMaxPoolSize"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . maxStatements    =    maxStatements ;", "}", "METHOD_END"], "methodName": ["setMaxStatements"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . minPoolSize    =    minPoolSize ;", "}", "METHOD_END"], "methodName": ["setMinPoolSize"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . portNumber    =    portNumber ;", "}", "METHOD_END"], "methodName": ["setPortNumber"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( value    =  =    null )     |  |     (  \"  \"  . equals ( value )  )  )", "return ;", "if    (  ( value   instanceof   Integer )     &  &     (  (  (  ( Integer )     ( value )  )  . intValue (  )  )     =  =     (  -  1  )  )  )", "return ;", "StringBuilder   builder    =    new   StringBuilder (  \" set \"  )  . append ( name )  ;", "builder . setCharAt (  3  ,    Character . toUpperCase ( name . charAt (  0  )  )  )  ;", "final   String   methodName    =    builder . toString (  )  ;", "final   Class <  ?  >    paramType    =    value . getClass (  )  ;", "MethodIdentifier   methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName ,    paramType )  ;", "Method   setterMethod    =    ClassReflectionIndexUtil . findMethod ( deploymentReflectionIndex ,    dClass ,    methodIdentifier )  ;", "if    ( setterMethod    !  =    null )     {", "properties . put ( name ,    value . toString (  )  )  ;", "} else", "if    ( paramType    =  =     ( Integer . class )  )     {", "methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName ,    int . class )  ;", "setterMethod    =    ClassReflectionIndexUtil . findMethod ( deploymentReflectionIndex ,    dClass ,    methodIdentifier )  ;", "if    ( setterMethod    !  =    null )     {", "properties . put ( name ,    value . toString (  )  )  ;", "}", "} else", "if    ( paramType    =  =     ( Boolean . class )  )     {", "methodIdentifier    =    MethodIdentifier . getIdentifier ( void . class ,    methodName ,    boolean . class )  ;", "setterMethod    =    ClassReflectionIndexUtil . findMethod ( deploymentReflectionIndex ,    dClass ,    methodIdentifier )  ;", "if    ( setterMethod    !  =    null )     {", "properties . put ( name ,    value . toString (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . serverName    =    serverName ;", "}", "METHOD_END"], "methodName": ["setServerName"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . transactional    =    transactional ;", "}", "METHOD_END"], "methodName": ["setTransactional"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . url    =    url ;", "}", "METHOD_END"], "methodName": ["setUrl"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . user    =    user ;", "}", "METHOD_END"], "methodName": ["setUser"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   dataSourceServiceName    =    AbstractDataSourceService . getServiceName ( bindInfo )  ;", "final   ServiceBuilder <  ?  >    dataSourceServiceBuilder    =    Services . addServerExecutorDependency ( serviceTarget . addService ( dataSourceServiceName ,    dataSourceService )  ,    dataSourceService . getExecutorServiceInjector (  )  )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    MetadataRepository . class ,    dataSourceService . getMdrInjector (  )  )  . addDependency ( ConnectorServices . RA _ REPOSITORY _ SERVICE ,    ResourceAdapterRepository . class ,    dataSourceService . getRaRepositoryInjector (  )  )  . addDependency ( ConnectorServices . BOOTSTRAP _ CONTEXT _ SERVICE . append ( Constants . DEFAULT _ NAME )  )  . addDependency ( ConnectorServices . TRANSACTION _ INTEGRATION _ SERVICE ,    TransactionIntegration . class ,    dataSourceService . getTransactionIntegrationInjector (  )  )  . addDependency ( ConnectorServices . MANAGEMENT _ REPOSITORY _ SERVICE ,    ManagementRepository . class ,    dataSourceService . getManagementRepositoryInjector (  )  )  . addDependency ( ConnectorServices . CCM _ SERVICE ,    CachedConnectionManager . class ,    dataSourceService . getCcmInjector (  )  )  . addDependency ( ConnectorServices . JDBC _ DRIVER _ REGISTRY _ SERVICE ,    DriverRegistry . class ,    dataSourceService . getDriverRegistryInjector (  )  )  . addDependency ( SERVICE _ NAME )  ;", "final   DataSourceReferenceFactoryService   referenceFactoryService    =    new   DataSourceReferenceFactoryService (  )  ;", "final   ServiceName   referenceFactoryServiceName    =    DataSourceReferenceFactoryService . SERVICE _ NAME _ BASE . append ( bindInfo . getBinderServiceName (  )  )  ;", "final   ServiceBuilder <  ?  >    referenceBuilder    =    serviceTarget . addService ( referenceFactoryServiceName ,    referenceFactoryService )  . addDependency ( dataSourceServiceName ,    DataSource . class ,    referenceFactoryService . getDataSourceInjector (  )  )  ;", "final   BinderService   binderService    =    new   BinderService ( bindInfo . getBindName (  )  ,    this )  ;", "final   ServiceBuilder <  ?  >    binderBuilder    =    serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addDependency ( referenceFactoryServiceName ,    ManagedReferenceFactory . class ,    binderService . getManagedObjectInjector (  )  )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . addListener ( new   AbstractServiceListener < Object >  (  )     {", "public   void   transition ( final   ServiceController <  ?    extends   Object >    controller ,    final   ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "if    ( isTransactional (  )  )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . boundDataSource ( jndiName )  ;", "} else    {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . boundNonJTADataSource ( jndiName )  ;", "}", "break ;", "}", "case   START _ REQUESTED _ to _ DOWN    :", "{", "if    ( isTransactional (  )  )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . unboundDataSource ( jndiName )  ;", "} else    {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . unBoundNonJTADataSource ( jndiName )  ;", "}", "break ;", "}", "case   REMOVING _ to _ REMOVED    :", "{", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . debugf (  \" Removed   JDBC   Data - source    [  % s ]  \"  ,    jndiName )  ;", "break ;", "}", "}", "}", "}  )  ;", "dataSourceServiceBuilder . setInitialMode ( ACTIVE )  . install (  )  ;", "referenceBuilder . setInitialMode ( ACTIVE )  . install (  )  ;", "binderBuilder . setInitialMode ( ACTIVE )  . install (  )  ;", "valueSourceServiceBuilder . addDependency ( bindInfo . getBinderServiceName (  )  ,    ManagedReferenceFactory . class ,    injector )  ;", "}", "METHOD_END"], "methodName": ["startDataSource"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "switch    ( isolationLevel )     {", "case   Cion . TRANSACTION _ NONE    :", "return   TransactionIsolation . TRANSACTION _ NONE ;", "case   Cion . TRANSACTION _ READ _ COMMITTED    :", "return   TransactionIsolation . TRANSACTION _ READ _ COMMITTED ;", "case   Cion . TRANSACTION _ READ _ UNCOMMITTED    :", "return   TransactionIsolation . TRANSACTION _ READ _ UNCOMMITTED ;", "case   Cion . TRANSACTION _ REPEATABLE _ READ    :", "return   TransactionIsolation . TRANSACTION _ REPEATABLE _ READ ;", "case   Cion . TRANSACTION _ SERIALIZABLE    :", "return   TransactionIsolation . TRANSACTION _ SERIALIZABLE ;", "default    :", "return   TransactionIsolation . TRANSACTION _ READ _ COMMITTED ;", "}", "}", "METHOD_END"], "methodName": ["transactionIsolation"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   name    =    new   StringBuilder (  )  ;", "name . append (  (  ( context . getApplicaName (  )  )     +     \"  _  \"  )  )  ;", "name . append (  (  ( context . getModuleName (  )  )     +     \"  _  \"  )  )  ;", "if    (  ( context . getComponentName (  )  )     !  =    null )     {", "name . append (  (  ( context . getComponentName (  )  )     +     \"  _  \"  )  )  ;", "}", "name . append ( jndiName )  ;", "return   name . toString (  )  ;", "}", "METHOD_END"], "methodName": ["uniqueName"], "fileName": "org.jboss.as.connector.deployers.datasource.DataSourceDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "updateContext . addDeploymentProcessor ( DataSourcesExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ DSXML _ DEPLOYMENT ,    new   DsXmlDeploymentParsingProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( DataSourcesExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ RESOURCE _ DEF _ ANNOTATION _ DATA _ SOURCE ,    new   DataSourceDefinitionAnnotationProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( DataSourcesExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ RESOURCE _ DEF _ XML _ DATA _ SOURCE ,    new   DataSourceDefinitionDescriptorProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( DataSourcesExtension . SUBSYSTEM _ NAME ,    FIRST _ MODULE _ USE ,    FIRST _ MODULE _ USE _ DSXML _ DEPLOYMENT ,    new   DsXmlDeploymentInstallProcessor (  )  )  ;", "}", "METHOD_END"], "methodName": ["activateProcessors"], "fileName": "org.jboss.as.connector.deployers.ds.DsDeploymentActivator"}, {"methodBody": ["METHOD_START", "{", "assert    (  ( ds . getSecurity (  )  )     =  =    null )     |  |     (  ( ds . getSecurity (  )  )    instanceof   DsSecurity )  ;", "return   new   ModifiableDataSource ( ds . getCionUrl (  )  ,    ds . getDriverClass (  )  ,    ds . getDataSourceClass (  )  ,    ds . getDriver (  )  ,    ds . getTransactionIsolation (  )  ,    ds . getCionProperties (  )  ,    ds . getTimeOut (  )  ,     (  ( DsSecurity )     ( ds . getSecurity (  )  )  )  ,    ds . getStatement (  )  ,    ds . getValidation (  )  ,    ds . getUrlDelimiter (  )  ,    ds . getUrlSelectorStrategyClassName (  )  ,    ds . getNewCionSql (  )  ,    ds . isUseJavaContext (  )  ,    ds . getPoolName (  )  ,    ds . isEnabled (  )  ,    ds . getJndiName (  )  ,    ds . isSpy (  )  ,    ds . isUseCcm (  )  ,    ds . isJTA (  )  ,    ds . isCable (  )  ,    ds . isTracking (  )  ,    ds . getMcp (  )  ,    ds . isEnlistmentTrace (  )  ,    ds . getPool (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildDataSource"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DsXaPool   xaPool ;", "if    (  ( xads . getXaPool (  )  )     =  =    null )     {", "xaPool    =    new   jca . common . metadata . ds . DsXaPoolImpl ( Defaults . MIN _ POOL _ SIZE ,    Defaults . INITIAL _ POOL _ SIZE ,    Defaults . MAX _ POOL _ SIZE ,    Defaults . PREFILL ,    Defaults . USE _ STRICT _ MIN ,    Defaults . FLUSH _ STRATEGY ,    Defaults . IS _ SAME _ RM _ OVERRIDE ,    Defaults . INTERLEAVING ,    Defaults . PAD _ XID ,    Defaults . WRAP _ XA _ RESOURCE ,    Defaults . NO _ TX _ SEPARATE _ POOL ,    Defaults . ALLOW _ MULTIPLE _ USERS ,    null ,    Defaults . FAIR ,    null )  ;", "} else    {", "final   DsXaPool   p    =    xads . getXaPool (  )  ;", "xaPool    =    new   jca . common . metadata . ds . DsXaPoolImpl ( getDef ( p . getMinPoolSize (  )  ,    MIN _ POOL _ SIZE )  ,    getDef ( p . getInitialPoolSize (  )  ,    INITIAL _ POOL _ SIZE )  ,    getDef ( p . getMaxPoolSize (  )  ,    MAX _ POOL _ SIZE )  ,    getDef ( p . isPrefill (  )  ,    PREFILL )  ,    getDef ( p . isUseStrictMin (  )  ,    USE _ STRICT _ MIN )  ,    getDef ( p . getFlushStrategy (  )  ,    FLUSH _ STRATEGY )  ,    getDef ( p . isSameRmOverride (  )  ,    IS _ SAME _ RM _ OVERRIDE )  ,    getDef ( p . isInterleaving (  )  ,    INTERLEAVING )  ,    getDef ( p . isPadXid (  )  ,    PAD _ XID )  ,    getDef ( p . isWrapXaResource (  )  ,    WRAP _ XA _ RESOURCE )  ,    getDef ( p . isNoTxSeparatePool (  )  ,    NO _ TX _ SEPARATE _ POOL )  ,    getDef ( p . isAllowMultipleUsers (  )  ,    ALLOW _ MULTIPLE _ USERS )  ,    p . getCapacity (  )  ,    getDef ( p . isFair (  )  ,    FAIR )  ,    p . getConnectionListener (  )  )  ;", "}", "return   new   ModifiableXaDataSource ( xads . getTransactionIsolation (  )  ,    xads . getTimeOut (  )  ,    xads . getSecurity (  )  ,    xads . getStatement (  )  ,    xads . getValidation (  )  ,    xads . getUrlDelimiter (  )  ,    xads . getUrlProperty (  )  ,    xads . getUrlSelectorStrategyClassName (  )  ,    xads . isUseJavaContext (  )  ,    xads . getPoolName (  )  ,    xads . isEnabled (  )  ,    xads . getJndiName (  )  ,    xads . isSpy (  )  ,    xads . isUseCcm (  )  ,    xads . isConnectable (  )  ,    xads . isTracking (  )  ,    xads . getMcp (  )  ,    xads . isEnlistmentTrace (  )  ,    xads . getXaDataSourceProperty (  )  ,    xads . getXaDataSourceClass (  )  ,    xads . getDriver (  )  ,    xads . getNewConnectionSql (  )  ,    xaPool ,    xads . getRecovery (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildXaDataSource"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "List < PathElement >    elements    =    new   ArrayList < PathElement >  (  )  ;", "if    (  ( deploymentUnit . getParent (  )  )     =  =    null )     {", "elements . add ( PathElement . pathElement ( DEPLOYMENT ,    deploymentUnit . getName (  )  )  )  ;", "} else    {", "elements . add ( PathElement . pathElement ( DEPLOYMENT ,    deploymentUnit . getParent (  )  . getName (  )  )  )  ;", "elements . add ( PathElement . pathElement ( SUBDEPLOYMENT ,    deploymentUnit . getName (  )  )  )  ;", "}", "elements . add ( PathElement . pathElement ( SUBSYSTEM ,    DataSourcesExtension . SUBSYSTEM _ NAME )  )  ;", "if    ( xa )     {", "elements . add ( PathElement . pathElement (  . XA _ DATA _ SOURCE ,    jndiName )  )  ;", "} else    {", "elements . add ( PathElement . pathElement (  . DATA _ SOURCE ,    jndiName )  )  ;", "}", "return   PathAddress . pathAddress ( elements )  ;", "}", "METHOD_END"], "methodName": ["getDataSourceAddress"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "return   value    !  =    null    ?    value    :    def ;", "}", "METHOD_END"], "methodName": ["getDef"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "Resource   current    =    parent ;", "for    ( final   PathEle   ele    :    address )     {", "synchronized ( current )     {", "if    ( current . hasChild ( ele )  )     {", "current    =    current . requireChild ( ele )  ;", "} else    {", "final   Resource   resource    =    Factory . create (  )  ;", "current . registerChild ( ele ,    resource )  ;", "current    =    resource ;", "}", "}", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["getOrCreate"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Resource   root    =    unit . getAttachment ( DEPLOYMENT _ RESOURCE )  ;", "synchronized ( root )     {", "ManagementResourceRegistration   registration    =    unit . getAttachment ( MUTABLE _ REGISTRATION _ ATTACHMENT )  ;", "final   PathAddress   address    =     ( xa )     ?     . XA _ DATASOURCE _ ADDRESS    :     . DATASOURCE _ ADDRESS ;", "ManagementResourceRegistration   subModel    =    registration . getSubModel ( address )  ;", "if    ( subModel    =  =    null )     {", "throw   new   IllegalStateException ( address . toString (  )  )  ;", "}", "return   subModel ;", "}", "}", "METHOD_END"], "methodName": ["getRegistration"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   Resource   root    =    unit . getAttachment ( DEPLOYMENT _ RESOURCE )  ;", "final   String   key    =     ( xa )     ?     . XA _ DATA _ SOURCE    :     . DATA _ SOURCE ;", "final   PathAddress   address    =    PathAddress . pathAddress ( PathElement . pathElement ( key ,    dsName )  )  ;", "synchronized ( root )     {", "final   Resource   subsystem    =     . getOrCreate ( root ,     . SUBSYSTEM _ ADDRESS )  ;", "return    . getOrCreate ( subsystem ,    address )  ;", "}", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "XMLDataSourceRuntimeHandler . INSTANCE . registerDataSource ( addr ,    ds )  ;", "final   DeploymentResourceSupport   deploymentResourceSupport    =    deploymentUnit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "deploymentResourceSupport . getDeploymentSubModel ( DataSourcesExtension . SUBSYSTEM _ NAME ,    addr . getLastElement (  )  )  ;", "if    (  ( ds . getConnectionProperties (  )  )     !  =    null )     {", "for    ( final   Map . Entry < String ,    String >    prop    :    ds . getConnectionProperties (  )  . entrySet (  )  )     {", "PathAddress   registration    =    PathAddress . pathAddress ( addr . getLastElement (  )  ,    PathElement . pathElement (  . CONNECTION _ PROPERTIES ,    prop . getKey (  )  )  )  ;", "deploymentResourceSupport . getDeploymentSubModel ( DataSourcesExtension . SUBSYSTEM _ NAME ,    registration )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["installManagementModel"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "XMLXaDataSourceRuntimeHandler . INSTANCE . registerDataSource ( addr ,    ds )  ;", "final   DeploymentResourceSupport   deploymentResourceSupport    =    deploymentUnit . getAttachment ( DEPLOYMENT _ RESOURCE _ SUPPORT )  ;", "deploymentResourceSupport . getDeploymentSubModel ( DataSourcesExtension . SUBSYSTEM _ NAME ,    addr . getLastElement (  )  )  ;", "if    (  ( ds . getXaDataSourceProperty (  )  )     !  =    null )     {", "for    ( final   Map . Entry < String ,    String >    prop    :    ds . getXaDataSourceProperty (  )  . entrySet (  )  )     {", "PathAddress   registration    =    PathAddress . pathAddress ( addr . getLastElement (  )  ,    PathElement . pathElement (  . XA _ CONNECTION _ PROPERTIES ,    prop . getKey (  )  )  )  ;", "deploymentResourceSupport . getDeploymentSubModel ( DataSourcesExtension . SUBSYSTEM _ NAME ,    registration )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["installManagementModel"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =     (  ( config    !  =    null )     &  &     ( config   instanceof   SecurityMetadata )  )     &  &     (  !  (  (  ( SecurityMetadata )     ( config )  )  . isElytronEnabled (  )  )  )  ;", "if    ( result )     {", "String   domain    =    config . resolveSecurityDomain (  )  ;", "result    =     ( domain    !  =    null )     &  &     (  ( domain . trim (  )  . length (  )  )     >     0  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["isLegacySecurityRequired"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( jndiName )  ;", "final   ServiceName   dataSourceServiceName    =    AbstractDataSourceService . getServiceName ( bindInfo )  ;", "final   ServiceBuilder <  ?  >    dataSourceServiceBuilder    =    Services . addServerExecutorDependency ( serviceTarget . addService ( dataSourceServiceName ,    dataSourceService )  ,    dataSourceService . getExecutorServiceInjector (  )  )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    MetadataRepository . class ,    dataSourceService . getMdrInjector (  )  )  . addDependency ( ConnectorServices . RA _ REPOSITORY _ SERVICE ,    ResourceAdapterRepository . class ,    dataSourceService . getRaRepositoryInjector (  )  )  . addDependency ( ConnectorServices . BOOTSTRAP _ CONTEXT _ SERVICE . append ( Constants . DEFAULT _ NAME )  )  . addDependency ( ConnectorServices . TRANSACTION _ INTEGRATION _ SERVICE ,    TransactionIntegration . class ,    dataSourceService . getTransactionIntegrationInjector (  )  )  . addDependency ( ConnectorServices . MANAGEMENT _ REPOSITORY _ SERVICE ,    ManagementRepository . class ,    dataSourceService . getManagementRepositoryInjector (  )  )  . addDependency ( ConnectorServices . CCM _ SERVICE ,    CachedConnectionManager . class ,    dataSourceService . getCcmInjector (  )  )  . addDependency ( ConnectorServices . JDBC _ DRIVER _ REGISTRY _ SERVICE ,    DriverRegistry . class ,    dataSourceService . getDriverRegistryInjector (  )  )  . addDependency ( SERVICE _ NAME )  ;", "if    ( requireLegacySecurity )     {", "dataSourceServiceBuilder . addDependency ( SimpleSecurityManagerService . SERVICE _ NAME ,    ServerSecurityManager . class ,    dataSourceService . getServerSecurityManager (  )  )  ;", "dataSourceServiceBuilder . addDependency ( SubjectFactoryService . SERVICE _ NAME ,    SubjectFactory . class ,    dataSourceService . getSubjectFactoryInjector (  )  )  ;", "}", "if    ( registration . isAllowsOverride (  )  )     {", "ManagementResourceRegistration   overrideRegistration    =    registration . getOverrideModel ( managementName )  ;", "if    (  ( overrideRegistration    =  =    null )     |  |     ( overrideRegistration . isAllowsOverride (  )  )  )     {", "overrideRegistration    =    registration . registerOverrideModel ( managementName ,    DataSourcesSubsystemProviders . OVERRIDE _ DS _ DESC )  ;", "}", "DataSourceStatisticsService   statsService    =    new   DataSourceStatisticsService ( registration ,    false )  ;", "serviceTarget . addService ( dataSourceServiceName . append ( subsystems . datasources . Constants . STATISTICS )  ,    statsService )  . addDependency ( dataSourceServiceName )  . addDependency ( CommonDeploymentService . getServiceName ( bindInfo )  ,    CommonDeployment . class ,    statsService . getCommonDeploymentInjector (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "DataSourceStatisticsService . registerStatisticsResources ( resource )  ;", "}", "final   ServiceName   driverServiceName    =    JBOSS . append (  \" jdbc - driver \"  ,    driverName . replaceAll (  \"  \\  \\  .  \"  ,     \"  _  \"  )  )  ;", "if    ( driverServiceName    !  =    null )     {", "dataSourceServiceBuilder . addDependency ( driverServiceName ,    Driver . class ,    dataSourceService . getDriverInjector (  )  )  ;", "}", "final   DataSourceReferenceFactoryService   referenceFactoryService    =    new   DataSourceReferenceFactoryService (  )  ;", "final   ServiceName   referenceFactoryServiceName    =    DataSourceReferenceFactoryService . SERVICE _ NAME _ BASE . append ( jndiName )  ;", "final   ServiceBuilder <  ?  >    referenceBuilder    =    serviceTarget . addService ( referenceFactoryServiceName ,    referenceFactoryService )  . addDependency ( dataSourceServiceName ,    DataSource . class ,    referenceFactoryService . getDataSourceInjector (  )  )  ;", "final   BinderService   binderService    =    new   BinderService ( bindInfo . getBindName (  )  )  ;", "final   ServiceBuilder <  ?  >    binderBuilder    =    serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addDependency ( referenceFactoryServiceName ,    ManagedReferenceFactory . class ,    binderService . getManagedObjectInjector (  )  )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . addListener ( new   AbstractServiceListener < Object >  (  )     {", "public   void   transition ( final   ServiceController <  ?  >    controller ,    final   ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "if    ( isTransactional )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . boundDataSource ( jndiName )  ;", "} else    {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . boundNonJTADataSource ( jndiName )  ;", "}", "break ;", "}", "case   START _ REQUESTED _ to _ DOWN    :", "{", "if    ( isTransactional )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . unboundDataSource ( jndiName )  ;", "} else    {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . unBoundNonJTADataSource ( jndiName )  ;", "}", "break ;", "}", "case   REMOVING _ to _ REMOVED    :", "{", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . debugf (  \" Removed   JDBC   Data - source    [  % s ]  \"  ,    jndiName )  ;", "break ;", "}", "}", "}", "}  )  ;", "dataSourceServiceBuilder . setInitialMode ( ACTIVE )  . install (  )  ;", "referenceBuilder . setInitialMode ( ACTIVE )  . install (  )  ;", "binderBuilder . setInitialMode ( ACTIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["startDataSource"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   addr    =    DsXmlDeploymentInstallProcessor . getDataSourceAddress ( ds . getJndiName (  )  ,    deploymentUnit ,    false )  ;", "XMLDataSourceRuntimeHandler . INSTANCE . unregisterDataSource ( addr )  ;", "}", "METHOD_END"], "methodName": ["undeployDataSource"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   addr    =    DsXmlDeploymentInstallProcessor . getDataSourceAddress ( ds . getJndiName (  )  ,    deploymentUnit ,    true )  ;", "XMLXaDataSourceRuntimeHandler . INSTANCE . unregisterDataSource ( addr )  ;", "}", "METHOD_END"], "methodName": ["undeployXaDataSource"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentInstallProcessor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   deploymentRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  . getRoot (  )  ;", "if    (  ( deploymentRoot    =  =    null )     |  |     (  !  ( deploymentRoot . exists (  )  )  )  )     {", "return   Collections . emptySet (  )  ;", "}", "final   String   deploymentRootName    =    deploymentRoot . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    ( deploymentRootName . endsWith (  \"  - ds . xml \"  )  )     {", "return   Collections . singleton ( deploymentRoot )  ;", "}", "final   Set < VirtualFile >    ret    =    new   HashSet < VirtualFile >  (  )  ;", "for    ( String   location    :     . LOCATIONS )     {", "final   VirtualFile   loc    =    deploymentRoot . getChild ( location )  ;", "if    ( loc . exists (  )  )     {", "for    ( final   VirtualFile   file    :    loc . getChildren (  )  )     {", "if    ( file . getName (  )  . endsWith (  \"  - ds . xml \"  )  )     {", "ret . add ( file )  ;", "}", "}", "}", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["dataSources"], "fileName": "org.jboss.as.connector.deployers.ds.processors.DsXmlDeploymentParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    metaData . getName (  )  ;", "if    (  ( name    =  =    null )     |  |     ( name . isEmpty (  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < administered - object >  \"  ,     \" name \"  )  ;", "}", "final   String   className    =    metaData . getClassName (  )  ;", "if    (  ( className    =  =    null )     |  |     ( className . isEmpty (  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < administered - object >  \"  ,     \" className \"  )  ;", "}", "final   String   resourceAdapter    =    metaData . getResourceAdapter (  )  ;", "if    (  ( resourceAdapter    =  =    null )     |  |     ( resourceAdapter . isEmpty (  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < administered - object >  \"  ,     \" resourceAdapter \"  )  ;", "}", "final   InjectionSource   resourceDefinitionInjectionSource    =    new   InjectionSource ( name ,    className ,    resourceAdapter )  ;", "resourceDefinitionInjectionSource . setInterface ( metaData . getInterfaceName (  )  )  ;", "if    (  ( metaData . getDescriptions (  )  )     !  =    null )     {", "resourceDefinitionInjectionSource . setDescription ( metaData . getDescriptions (  )  . toString (  )  )  ;", "}", "resourceDefinitionInjectionSource . addProperties ( metaData . getProperties (  )  )  ;", "return   resourceDefinitionInjectionSource ;", "}", "METHOD_END"], "methodName": ["getResourceDefinitionInjectionSource"], "fileName": "org.jboss.as.connector.deployers.ra.AdministeredObjectDefinitionDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "properties . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["addProperty"], "fileName": "org.jboss.as.connector.deployers.ra.AdministeredObjectDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.jboss.as.connector.deployers.ra.AdministeredObjectDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   interfaceName ;", "}", "METHOD_END"], "methodName": ["getInterface"], "fileName": "org.jboss.as.connector.deployers.ra.AdministeredObjectDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "String   raId    =    resourceAdapter ;", "if    ( resourceAdapter . startsWith (  \"  #  \"  )  )     {", "raId    =     ( deploymentUnit . getParent (  )  . getName (  )  )     +    raId ;", "}", "String   deployerServiceName    =    raId ;", "if    (  !  ( raId . endsWith (  \"  . rar \"  )  )  )     {", "deployerServiceName    =    deployerServiceName    +     \"  . rar \"  ;", "raId    =    deployerServiceName ;", "}", "ConnectorLogger . SUBSYSTEM _ RA _ LOGGER . debugf (  \"  @  :     % s   for    % s   binding   to    % s    \"  ,    className ,    resourceAdapter ,    jndiName )  ;", "ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( context . getApplicationName (  )  ,    context . getModuleName (  )  ,    context . getComponentName (  )  ,     (  !  ( context . isCompUsesModule (  )  )  )  ,    jndiName )  ;", "DirectAdminObjectActivatorService   service    =    new   DirectAdminObjectActivatorService ( jndiName ,    className ,    resourceAdapter ,    raId ,    properties ,    module ,    bindInfo )  ;", "ServiceName   serviceName    =    DirectAdminObjectActivatorService . SERVICE _ NAME _ BASE . append ( jndiName )  ;", "phaseContext . getServiceTarget (  )  . addService ( serviceName ,    service )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    AS 7 MetadataRepository . class ,    service . getMdrInjector (  )  )  . addDependency ( ConnectorServices . RESOURCE _ ADAPTER _ DEPLOYER _ SERVICE _ PREFIX . append ( deployerServiceName )  )  . setInitialMode ( ACTIVE )  . install (  )  ;", "serviceBuilder . addDependency ( AdminObjectReferenceFactoryService . SERVICE _ NAME _ BASE . append ( bindInfo . getBinderServiceName (  )  )  ,    ManagedReferenceFactory . class ,    injector )  ;", "serviceBuilder . addListener ( new   AbstractServiceListener < Object >  (  )     {", "public   void   transition ( final   ServiceController <  ?    extends   Object >    controller ,    final   ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . adminObjectAnnotation ( jndiName )  ;", "break ;", "}", "case   STOPPING _ to _ DOWN    :", "{", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . unboundJca (  \" AdminObject \"  ,    jndiName )  ;", "break ;", "}", "case   REMOVING _ to _ REMOVED    :", "{", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \" Removed   JCA   AdminObject    [  % s ]  \"  ,    jndiName )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.connector.deployers.ra.AdministeredObjectDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.jboss.as.connector.deployers.ra.AdministeredObjectDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . interfaceName    =    interfaceName ;", "}", "METHOD_END"], "methodName": ["setInterface"], "fileName": "org.jboss.as.connector.deployers.ra.AdministeredObjectDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "AnnotationValue   value    =    annotation . value ( property )  ;", "return   value    =  =    null    ?    null    :    TransactionSupportLevel . valueOf (  (  ( String )     ( value . value (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asTransactionSupportLocal"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionAnnotationProcessor"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    metaData . getName (  )  ;", "if    (  ( name    =  =    null )     |  |     ( name . isEmpty (  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < connection - factory >  \"  ,     \" name \"  )  ;", "}", "final   String   interfaceName    =    metaData . getInterfaceName (  )  ;", "if    (  ( interfaceName    =  =    null )     |  |     ( interfaceName . isEmpty (  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < connection - factory >  \"  ,     \" interfaceName \"  )  ;", "}", "final   String   resourceAdapter    =    metaData . getResourceAdapter (  )  ;", "if    (  ( resourceAdapter    =  =    null )     |  |     ( resourceAdapter . isEmpty (  )  )  )     {", "throw   ROOT _ LOGGER . elementAttributeMissing (  \"  < connection - factory >  \"  ,     \" resourceAdapter \"  )  ;", "}", "final   InjectionSource   resourceDefinitionInjectionSource    =    new   InjectionSource ( name ,    interfaceName ,    resourceAdapter )  ;", "if    (  ( metaData . getDescriptions (  )  )     !  =    null )     {", "resourceDefinitionInjectionSource . setDescription ( metaData . getDescriptions (  )  . toString (  )  )  ;", "}", "resourceDefinitionInjectionSource . setMaxPoolSize ( metaData . getMaxPoolSize (  )  )  ;", "resourceDefinitionInjectionSource . setMinPoolSize ( metaData . getMinPoolSize (  )  )  ;", "if    (  ( metaData . getTransactionSupport (  )  )     !  =    null )     {", "switch    ( metaData . getTransactionSupport (  )  )     {", "case   NoTransaction    :", "resourceDefinitionInjectionSource . setTransactionSupportLevel ( NoTransaction )  ;", "break ;", "case   LocalTransaction    :", "resourceDefinitionInjectionSource . setTransactionSupportLevel ( LocalTransaction )  ;", "break ;", "case   XATransaction    :", "resourceDefinitionInjectionSource . setTransactionSupportLevel ( XATransaction )  ;", "break ;", "}", "}", "resourceDefinitionInjectionSource . addProperties ( metaData . getProperties (  )  )  ;", "return   resourceDefinitionInjectionSource ;", "}", "METHOD_END"], "methodName": ["getResourceDefinitionInjectionSource"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionDescriptorProcessor"}, {"methodBody": ["METHOD_START", "{", "properties . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["addProperty"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   maxPoolSize ;", "}", "METHOD_END"], "methodName": ["getMaxPoolSize"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   minPoolSize ;", "}", "METHOD_END"], "methodName": ["getMinPoolSize"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "String   raId    =    resourceAdapter ;", "if    ( resourceAdapter . startsWith (  \"  #  \"  )  )     {", "raId    =     ( deploymentUnit . getParent (  )  . getName (  )  )     +    raId ;", "}", "String   deployerServiceName    =    raId ;", "if    (  !  ( raId . endsWith (  \"  . rar \"  )  )  )     {", "deployerServiceName    =    deployerServiceName    +     \"  . rar \"  ;", "raId    =    deployerServiceName ;", "}", "ConnectorLogger . SUBSYSTEM _ RA _ LOGGER . debugf (  \"  @  :     % s   for    % s   binding   to    % s    \"  ,    interfaceName ,    resourceAdapter ,    jndiName )  ;", "ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoForEnvEntry ( context . getApplicationName (  )  ,    context . getModuleName (  )  ,    context . getComponentName (  )  ,     (  !  ( context . isCompUsesModule (  )  )  )  ,    jndiName )  ;", "DirectConnectionFactoryActivatorService   service    =    new   DirectConnectionFactoryActivatorService ( jndiName ,    interfaceName ,    resourceAdapter ,    raId ,    maxPoolSize ,    minPoolSize ,    properties ,    transactionSupport ,    module ,    bindInfo )  ;", "ServiceName   serviceName    =    DirectConnectionFactoryActivatorService . SERVICE _ NAME _ BASE . append ( jndiName )  ;", "phaseContext . getServiceTarget (  )  . addService ( serviceName ,    service )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    AS 7 MetadataRepository . class ,    service . getMdrInjector (  )  )  . addDependency ( ConnectorServices . RESOURCE _ ADAPTER _ DEPLOYER _ SERVICE _ PREFIX . append ( deployerServiceName )  )  . setInitialMode ( ACTIVE )  . install (  )  ;", "serviceBuilder . addDependency ( ConnectionFactoryReferenceFactoryService . SERVICE _ NAME _ BASE . append ( bindInfo . getBinderServiceName (  )  )  ,    ManagedReferenceFactory . class ,    injector )  ;", "serviceBuilder . addListener ( new   AbstractServiceListener < Object >  (  )     {", "public   void   transition ( final   ServiceController <  ?    extends   Object >    controller ,    final   ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . connectionFactoryAnnotation ( jndiName )  ;", "break ;", "}", "case   STOPPING _ to _ DOWN    :", "{", "break ;", "}", "case   REMOVING _ to _ REMOVED    :", "{", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \" Removed   JCA   ConnectionFactory    [  % s ]  \"  ,    jndiName )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getResourceValue"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "return   transactionSupport ;", "}", "METHOD_END"], "methodName": ["getTransactionSupportLevel"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . maxPoolSize    =    maxPoolSize ;", "}", "METHOD_END"], "methodName": ["setMaxPoolSize"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . minPoolSize    =    minPoolSize ;", "}", "METHOD_END"], "methodName": ["setMinPoolSize"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "this . transactionSupport    =    transactionSupport ;", "}", "METHOD_END"], "methodName": ["setTransactionSupportLevel"], "fileName": "org.jboss.as.connector.deployers.ra.ConnectionFactoryDefinitionInjectionSource"}, {"methodBody": ["METHOD_START", "{", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ RAR ,    new   RaStructureProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    STRUCTURE ,    STRUCTURE _ JDBC _ DRIVER ,    new   StructureDriverProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ RA _ DEPLOYMENT ,    new   RaDeploymentParsingProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ IRON _ JACAMAR _ DEPLOYMENT ,    new   IronJacamarDeploymentParsingProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ RESOURCE _ DEF _ ANNOTATION _ CONNECTION _ FACTORY ,    new   ConnectionFactoryDefinitionAnnotationProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    PARSE ,    PARSE _ RESOURCE _ DEF _ ANNOTATION _ ADMINISTERED _ OBJECT ,    new   AdministeredObjectDefinitionAnnotationProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    DEPENDENCIES ,    DEPENDENCIES _ RAR _ CONFIG ,    new   RarDependencyProcessor ( appclient )  )  ;", "if    (  !  ( appclient )  )", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    Phase . POST _ MODULE _ RAR _ SERVICES _ DEPS ,    new   processors . RaXmlDependencyProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ RESOURCE _ DEF _ XML _ CONNECTION _ FACTORY ,    new   ConnectionFactoryDefinitionDescriptorProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    POST _ MODULE ,    POST _ MODULE _ RESOURCE _ DEF _ XML _ ADMINISTERED _ OBJECT ,    new   AdministeredObjectDefinitionDescriptorProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ RA _ NATIVE ,    new   RaNativeProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ RA _ DEPLOYMENT ,    new   ParsedRaDeploymentProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ RA _ XML _ DEPLOYMENT ,    new   RaXmlDeploymentProcessor (  )  )  ;", "updateContext . addDeploymentProcessor ( ResourceAdaptersExtension . SUBSYSTEM _ NAME ,    INSTALL ,    INSTALL _ JDBC _ DRIVER ,    new   DriverProcessor (  )  )  ;", "}", "METHOD_END"], "methodName": ["activateProcessors"], "fileName": "org.jboss.as.connector.deployers.ra.RaDeploymentActivator"}, {"methodBody": ["METHOD_START", "{", "serviceTarget . addService ( ConnectorServices . IRONJACAMAR _ MDR ,    mdrService )  . install (  )  ;", "RaRepositoryService   raRepositoryService    =    new   RaRepositoryService (  )  ;", "serviceTarget . addService ( ConnectorServices . RA _ REPOSITORY _ SERVICE ,    raRepositoryService )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    MetadataRepository . class ,    raRepositoryService . getMdrInjector (  )  )  . addDependency ( ConnectorServices . TRANSACTION _ INTEGRATION _ SERVICE ,    TransactionIntegration . class ,    raRepositoryService . getTransactionIntegrationInjector (  )  )  . install (  )  ;", "NonJTADataSourceRaRepositoryService   nonJTADataSourceRaRepositoryService    =    new   NonJTADataSourceRaRepositoryService (  )  ;", "serviceTarget . addService ( ConnectorServices . NON _ JTA _ DS _ RA _ REPOSITORY _ SERVICE ,    nonJTADataSourceRaRepositoryService )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    MetadataRepository . class ,    nonJTADataSourceRaRepositoryService . getMdrInjector (  )  )  . install (  )  ;", "ManagementRepositoryService   managementRepositoryService    =    new   ManagementRepositoryService (  )  ;", "serviceTarget . addService ( ConnectorServices . MANAGEMENT _ REPOSITORY _ SERVICE ,    managementRepositoryService )  . install (  )  ;", "ResourceAdapterRegistryService   registryService    =    new   ResourceAdapterRegistryService (  )  ;", "serviceTarget . addService ( ConnectorServices . RESOURCE _ ADAPTER _ REGISTRY _ SERVICE ,    registryService )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["activateServices"], "fileName": "org.jboss.as.connector.deployers.ra.RaDeploymentActivator"}, {"methodBody": ["METHOD_START", "{", "IronJacamarXmlDescriptor   xmlDescriptor    =    null ;", "if    (  ( deploymentRoot    =  =    null )     |  |     (  !  ( deploymentRoot . exists (  )  )  )  )", "return   null ;", "final   String   deploymentRootName    =    deploymentRoot . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "VirtualFile   serviceXmlFile    =    null ;", "if    ( deploymentRootName . endsWith (  \"  . rar \"  )  )     {", "serviceXmlFile    =    deploymentRoot . getChild (  \"  / META - INF / ironjacamar . xml \"  )  ;", "}", "if    (  ( serviceXmlFile    =  =    null )     |  |     (  !  ( serviceXmlFile . exists (  )  )  )  )", "return   null ;", "InputStream   xmlStream    =    null ;", "Activation   result    =    null ;", "try    {", "xmlStream    =    serviceXmlFile . openStream (  )  ;", "IronJacamarParser   ironJacamarParser    =    new   IronJacamarParser (  )  ;", "ironJacamarParser . setSystemPropertiesResolved ( resolveProperties )  ;", "result    =    ironJacamarParser . parse ( xmlStream )  ;", "if    ( result    !  =    null )     {", "xmlDescriptor    =    new   IronJacamarXmlDescriptor ( result )  ;", "} else", "throw   ConnectorLogger . ROOT _ LOGGER . failedToParseServiceXml ( serviceXmlFile )  ;", "}    catch    ( Exception   e )     {", "throw   ConnectorLogger . ROOT _ LOGGER . failedToParseServiceXml ( e ,    serviceXmlFile )  ;", "}    finally    {", "VFSUtils . safeClose ( xmlStream )  ;", "}", "return   xmlDescriptor ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.jboss.as.connector.deployers.ra.processors.IronJacamarDeploymentParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "final   ConnectorXmlDescriptor   connectorXmlDescriptor    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( ConnectorXmlDescriptor . ATTACHMENT _ KEY )  ;", "final   ManagementResourceRegistration   registration ;", "final   ManagementResourceRegistration   baseRegistration    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( MUTABLE _ REGISTRATION _ ATTACHMENT )  ;", "final   Resource   deploymentResource    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( DEPLOYMENT _ RESOURCE )  ;", "if    ( connectorXmlDescriptor    =  =    null )     {", "return ;", "}", "final   ServiceTarget   serviceTarget    =    phaseContext . getServiceTarget (  )  ;", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "registration    =    baseRegistration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement (  \" subdeployment \"  )  )  )  ;", "} else    {", "registration    =    baseRegistration ;", "}", "final   IronJacamarXmlDescriptor   ironJacamarXmlDescriptor    =    deploymentUnit . getAttachment ( IronJacamarXmlDescriptor . ATTACHMENT _ KEY )  ;", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \"  :    Processing =  % s \"  ,    deploymentUnit )  ;", "final   ClassLoader   classLoader    =    module . getClassLoader (  )  ;", "Map < ResourceRoot ,    Index >    annotationIndexes    =    AnnotationIndexUtils . getAnnotationIndexes ( deploymentUnit )  ;", "ServiceBuilder   builder    =     . process ( connectorXmlDescriptor ,    ironJacamarXmlDescriptor ,    classLoader ,    serviceTarget ,    annotationIndexes ,    deploymentUnit . getServiceName (  )  ,    registration ,    deploymentResource )  ;", "if    ( builder    !  =    null )     {", "String   bootstrapCtx    =    null ;", "if    (  (  ( ironJacamarXmlDescriptor    !  =    null )     &  &     (  ( ironJacamarXmlDescriptor . getIronJacamar (  )  )     !  =    null )  )     &  &     (  ( ironJacamarXmlDescriptor . getIronJacamar (  )  . getBootstrapContext (  )  )     !  =    null )  )", "bootstrapCtx    =    ironJacamarXmlDescriptor . getIronJacamar (  )  . getBootstrapContext (  )  ;", "if    ( bootstrapCtx    =  =    null )", "bootstrapCtx    =     \" default \"  ;", "builder . addDependency ( ConnectorServices . BOOTSTRAP _ CONTEXT _ SERVICE . append ( bootstrapCtx )  )  ;", "if    (  ( registration . isAllowsOverride (  )  )     &  &     (  ( registration . getOverrideModel ( deploymentUnit . getName (  )  )  )     =  =    null )  )     {", "registration . registerOverrideModel ( deploymentUnit . getName (  )  ,    new   OverrideDescriptionProvider (  )     {", "@ Override", "public   Map < String ,    ModelNode >    getAttributeOverrideDescriptions ( Locale   locale )     {", "return   Collections . emptyMap (  )  ;", "}", "@ Override", "public   Map < String ,    ModelNode >    getChildTypeOverrideDescriptions ( Locale   locale )     {", "return   Collections . emptyMap (  )  ;", "}", "}  )  ;", "}", "builder . setInitialMode ( ACTIVE )  . install (  )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.connector.deployers.ra.processors.ParsedRaDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "Connector   cmd    =     ( connectorXmlDescriptor    !  =    null )     ?    connectorXmlDescriptor . getConnector (  )     :    null ;", "final   Activation   activation    =     ( ironJacamarXmlDescriptor    !  =    null )     ?    ironJacamarXmlDescriptor . getIronJacamar (  )     :    null ;", "try    {", "Annotations   annotator    =    new   Annotations (  )  ;", "if    (  ( annotationIndexes    !  =    null )     &  &     (  ( annotationIndexes . size (  )  )     >     0  )  )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \"  :    Found    % d   annotationIndexes \"  ,    annotationIndexes . size (  )  )  ;", "for    ( Index   index    :    annotationIndexes . values (  )  )     {", "if    (  (  ( index . getKnownClasses (  )  )     !  =    null )     &  &     (  ( index . getKnownClasses (  )  . size (  )  )     >     0  )  )     {", "AnnotationRepository   repository    =    new   JandexAnnotationRepositoryImpl ( index ,    classLoader )  ;", "cmd    =    annotator . merge ( cmd ,    repository ,    classLoader )  ;", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \"  :    CMD =  % s \"  ,    cmd )  ;", "}", "}", "}", "if    (  ( annotationIndexes    =  =    null )     |  |     (  ( annotationIndexes . size (  )  )     =  =     0  )  )", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \"  :    Found    0    annotationIndexes \"  )  ;", "if    ( cmd    !  =    null )     {", "cmd . validate (  )  ;", "cmd    =    new   Merger (  )  . mergeConnectorWithCommonIronJacamar ( activation ,    cmd )  ;", "}", "TransactionSupportEnum   transactionSupport    =    TransactionSupportEnum . NoTransaction ;", "if    (  (  ( cmd    !  =    null )     &  &     (  ( cmd . getResourceadapter (  )  )     !  =    null )  )     &  &     (  ( cmd . getResourceadapter (  )  . getOutboundResourceadapter (  )  )     !  =    null )  )     {", "transactionSupport    =    cmd . getResourceadapter (  )  . getOutboundResourceadapter (  )  . getTransactionSupport (  )  ;", "}", "if    (  ( activation    !  =    null )     &  &     (  ( activation . getTransactionSupport (  )  )     !  =    null )  )     {", "transactionSupport    =    activation . getTransactionSupport (  )  ;", "}", "final   ServiceName   deployerServiceName    =    ConnectorServices . RESOURCE _ ADAPTER _ DEPLOYER _ SERVICE _ PREFIX . append ( connectorXmlDescriptor . getDeploymentName (  )  )  ;", "final   ResourceAdapterDeploymentService   raDeploymentService    =    new   ResourceAdapterDeploymentService ( connectorXmlDescriptor ,    cmd ,    activation ,    classLoader ,    deployerServiceName ,    duServiceName ,    registration ,    deploymentResource )  ;", "ServiceBuilder < ResourceAdapterDeployment >    builder    =    Services . addServerExecutorDependency ( serviceTarget . addService ( deployerServiceName ,    raDeploymentService )  ,    raDeploymentService . getExecutorServiceInjector (  )  )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    AS 7 MetadataRepository . class ,    raDeploymentService . getMdrInjector (  )  )  . addDependency ( ConnectorServices . RA _ REPOSITORY _ SERVICE ,    ResourceAdapterRepository . class ,    raDeploymentService . getRaRepositoryInjector (  )  )  . addDependency ( ConnectorServices . MANAGEMENT _ REPOSITORY _ SERVICE ,    ManagementRepository . class ,    raDeploymentService . getManagementRepositoryInjector (  )  )  . addDependency ( ConnectorServices . RESOURCE _ ADAPTER _ REGISTRY _ SERVICE ,    ResourceAdapterDeploymentRegistry . class ,    raDeploymentService . getRegistryInjector (  )  )  . addDependency ( ConnectorServices . TRANSACTION _ INTEGRATION _ SERVICE ,    TransactionIntegration . class ,    raDeploymentService . getTxIntegrationInjector (  )  )  . addDependency ( ConnectorServices . CONNECTOR _ CONFIG _ SERVICE ,    JcaSubsystemConfiguration . class ,    raDeploymentService . getConfigInjector (  )  )  . addDependency ( ConnectorServices . IDLE _ REMOVER _ SERVICE )  . addDependency ( ConnectorServices . CONNECTION _ VALIDATOR _ SERVICE )  . addDependency ( SERVICE _ NAME )  ;", "if    (  ( transactionSupport    =  =    null )     |  |     ( transactionSupport . equals ( NoTransaction )  )  )     {", "builder . addDependency ( ConnectorServices . NON _ TX _ CCM _ SERVICE ,    CachedConnectionManager . class ,    raDeploymentService . getCcmInjector (  )  )  ;", "} else    {", "builder . addDependency ( ConnectorServices . CCM _ SERVICE ,    CachedConnectionManager . class ,    raDeploymentService . getCcmInjector (  )  )  ;", "}", "if    (  ( activation    !  =    null )     &  &     ( ActivationSecurityUtil . isLegacySecurityRequired ( activation )  )  )     {", "builder . addDependency ( SubjectFactoryService . SERVICE _ NAME ,    SubjectFactory . class ,    raDeploymentService . getSubjectFactoryInjector (  )  )  . addDependency ( SimpleSecurityManagerService . SERVICE _ NAME ,    ServerSecurityManager . class ,    raDeploymentService . getServerSecurityManager (  )  )  ;", "}", "return   builder ;", "}    catch    ( Throwable   t )     {", "throw   new   DeploymentUnitProcessingException ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.jboss.as.connector.deployers.ra.processors.ParsedRaDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   VirtualFile   serviceXmlFile ;", "if    ( alternateDescriptor    !  =    null )     {", "serviceXmlFile    =    alternateDescriptor ;", "} else    {", "serviceXmlFile    =    file . getChild (  \"  / META - INF / ra . xml \"  )  ;", "}", "InputStream   xmlStream    =    null ;", "Connector   result    =    null ;", "try    {", "if    (  ( serviceXmlFile    !  =    null )     &  &     ( serviceXmlFile . exists (  )  )  )     {", "xmlStream    =    serviceXmlFile . openStream (  )  ;", "RaParser   raParser    =    new   RaParser (  )  ;", "raParser . setSystemPropertiesResolved ( resolveProperties )  ;", "result    =    raParser . parse ( xmlStream )  ;", "if    ( result    =  =    null )", "throw   ConnectorLogger . ROOT _ LOGGER . failedToParseServiceXml ( serviceXmlFile )  ;", "}", "File   root    =    file . getPhysicalFile (  )  ;", "URL   url    =    root . toURI (  )  . toURL (  )  ;", "return   new   ConnectorXmlDescriptor ( result ,    root ,    url ,    dName )  ;", "}    catch    ( Exception   e )     {", "throw   ConnectorLogger . ROOT _ LOGGER . failedToParseServiceXml ( e ,    serviceXmlFile )  ;", "}    finally    {", "VFSUtils . safeClose ( xmlStream )  ;", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.jboss.as.connector.deployers.ra.processors.RaDeploymentParsingProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( deploymentRoot    =  =    null )     |  |     (  !  ( deploymentRoot . exists (  )  )  )  )", "return ;", "final   String   deploymentRootName    =    deploymentRoot . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    (  !  ( deploymentRootName . endsWith (  \"  . rar \"  )  )  )     {", "return ;", "}", "try    {", "List < VirtualFile >    libs    =    deploymentRoot . getChildrenRecursively ( new    . LibraryFilter (  )  )  ;", "if    (  ( libs    !  =    null )     &  &     (  ( libs . size (  )  )     >     0  )  )     {", "for    ( VirtualFile   vf    :    libs )     {", "String   fileName    =    vf . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "ConnectorLogger . ROOT _ LOGGER . tracef (  \" Processing   library :     % s \"  ,    fileName )  ;", "try    {", "File   f    =    vf . getPhysicalFile (  )  ;", "System . load ( f . getAbsolutePath (  )  )  ;", "ConnectorLogger . ROOT _ LOGGER . debugf (  \" Loaded   library :     % s \"  ,    f . getAbsolutePath (  )  )  ;", "}    catch    ( Throwable   t )     {", "ConnectorLogger . ROOT _ LOGGER . debugf (  \" Unable   to   load   library :     % s \"  ,    fileName )  ;", "}", "}", "}", "}    catch    ( Exception   e )     {", "throw   ConnectorLogger . ROOT _ LOGGER . failedToLoadNativeLibraries ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.jboss.as.connector.deployers.ra.processors.RaNativeProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ResourceRoot   resourceRoot    =    deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  ;", "if    ( resourceRoot    =  =    null )     {", "return ;", "}", "final   VirtualFile   deploymentRoot    =    resourceRoot . getRoot (  )  ;", "if    (  ( deploymentRoot    =  =    null )     |  |     (  !  ( deploymentRoot . exists (  )  )  )  )     {", "return ;", "}", "final   String   deploymentRootName    =    deploymentRoot . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    (  !  ( deploymentRootName . endsWith (  . RAR _ EXTENSION )  )  )     {", "return ;", "}", "final   ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "moduleSpecification . setPublicModule ( true )  ;", "ModuleRootMarker . mark ( resourceRoot ,    true )  ;", "Map < String ,    MountedDeploymentOverlay >    overlays    =    deploymentUnit . getAttachment ( DEPLOYMENT _ OVERLAY _ LOCATIONS )  ;", "try    {", "final   List < VirtualFile >    childArchives    =    deploymentRoot . getChildren (  . CHILD _ ARCHIVE _ FILTER )  ;", "for    ( final   VirtualFile   child    :    childArchives )     {", "String   relativeName    =    child . getPathNameRelativeTo ( deploymentRoot )  ;", "MountedDeploymentOverlay   overlay    =    overlays . get ( relativeName )  ;", "Closeable   closable    =     . NO _ OP _ CLOSEABLE ;", "if    ( overlay    !  =    null )     {", "overlay . remountAsZip ( false )  ;", "} else", "if    ( child . isFile (  )  )     {", "closable    =    mountZip ( child ,    child ,    provider (  )  )  ;", "}", "final   MountHandle   mountHandle    =    new   MountHandle ( closable )  ;", "final   ResourceRoot   childResource    =    new   ResourceRoot ( child ,    mountHandle )  ;", "ModuleRootMarker . mark ( childResource )  ;", "deploymentUnit . addToAttachmentList ( RESOURCE _ ROOTS ,    childResource )  ;", "resourceRoot . addToAttachmentList ( INDEX _ IGNORE _ PATHS ,    child . getPathNameRelativeTo ( deploymentRoot )  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   ConnectorLogger . ROOT _ LOGGER . failedToProcessRaChild ( e ,    deploymentRoot )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.connector.deployers.ra.processors.RaStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "final   List < ResourceRoot >    childRoots    =    context . removeAttachment ( RESOURCE _ ROOTS )  ;", "if    ( childRoots    !  =    null )     {", "for    ( ResourceRoot   childRoot    :    childRoots )     {", "VFSUtils . safeClose ( childRoot . getMountHandle (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["undeploy"], "fileName": "org.jboss.as.connector.deployers.ra.processors.RaStructureProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "if    (  ( phaseContext . getDeploymentUnit (  )  . getAttachment ( ConnectorXmlDescriptor . ATTACHMENT _ KEY )  )     =  =    null )     {", "return ;", "}", "CopyOnWriteArrayListMultiMap < String ,    ServiceName >    resourceAdaptersMap    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( ResourceAdaptersSubsystemService . ATTACHMENT _ KEY )  ;", "String   deploymentUnitPrefix    =     \"  \"  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "deploymentUnitPrefix    =     ( deploymentUnit . getParent (  )  . getName (  )  )     +     \"  #  \"  ;", "}", "final   String   deploymentUnitName    =    deploymentUnitPrefix    +     ( deploymentUnit . getName (  )  )  ;", "if    (  ( resourceAdaptersMap    !  =    null )     &  &     (  ( resourceAdaptersMap . get ( deploymentUnitName )  )     !  =    null )  )     {", "for    ( ServiceName   serviceName    :    resourceAdaptersMap . get ( deploymentUnitName )  )     {", "phaseContext . addDeployment ( serviceName ,    AttachmentKey . create ( ModifiableResourceAdapter . class )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.connector.deployers.ra.processors.RaXmlDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ManagementResourceRegistration   baseRegistration    =    deploymentUnit . getAttachment ( MUTABLE _ REGISTRATION _ ATTACHMENT )  ;", "final   ManagementResourceRegistration   registration ;", "final   Resource   deploymentResource    =    phaseContext . getDeploymentUnit (  )  . getAttachment ( DEPLOYMENT _ RESOURCE )  ;", "final   ConnectorXmlDescriptor   connectorXmlDescriptor    =    deploymentUnit . getAttachment ( ConnectorXmlDescriptor . ATTACHMENT _ KEY )  ;", "if    ( connectorXmlDescriptor    =  =    null )     {", "return ;", "}", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "registration    =    baseRegistration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement (  \" subdeployment \"  )  )  )  ;", "} else    {", "registration    =    baseRegistration ;", "}", "ResourceAdaptersService . ModifiableResourceAdaptors   raxmls    =    null ;", "final   ServiceController <  ?  >    raService    =    phaseContext . getServiceRegistry (  )  . getService ( ConnectorServices . RESOURCEADAPTERS _ SERVICE )  ;", "if    ( raService    !  =    null )", "raxmls    =     (  ( ResourceAdaptersService . ModifiableResourceAdaptors )     ( raService . getValue (  )  )  )  ;", "ConnectorLogger . ROOT _ LOGGER . tracef (  \" processing   Raxml \"  )  ;", "Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "try    {", "final   ServiceTarget   serviceTarget    =    phaseContext . getServiceTarget (  )  ;", "String   deploymentUnitPrefix    =     \"  \"  ;", "if    (  ( deploymentUnit . getParent (  )  )     !  =    null )     {", "deploymentUnitPrefix    =     ( deploymentUnit . getParent (  )  . getName (  )  )     +     \"  #  \"  ;", "}", "final   String   deploymentUnitName    =    deploymentUnitPrefix    +     ( deploymentUnit . getName (  )  )  ;", "if    ( raxmls    !  =    null )     {", "for    ( Activation   raxml    :    raxmls . getActivations (  )  )     {", "String   rarName    =    raxml . getArchive (  )  ;", "if    ( deploymentUnitName . equals ( rarName )  )     {", "RaServicesFactory . createDeploymentService ( registration ,    connectorXmlDescriptor ,    module ,    serviceTarget ,    deploymentUnitName ,    deploymentUnit . getServiceName (  )  ,    deploymentUnitName ,    raxml ,    deploymentResource ,    phaseContext . getServiceRegistry (  )  )  ;", "}", "}", "}", "ServiceName   serviceName    =    ConnectorServices . INACTIVE _ RESOURCE _ ADAPTER _ SERVICE . append ( deploymentUnitName )  ;", "InactiveResourceAdapterDeploymentService   service    =    new   InactiveResourceAdapterDeploymentService ( connectorXmlDescriptor ,    module ,    deploymentUnitName ,    deploymentUnitName ,    deploymentUnit . getServiceName (  )  ,    registration ,    serviceTarget ,    deploymentResource )  ;", "ServiceBuilder   builder    =    serviceTarget . addService ( serviceName ,    service )  ;", "builder . setInitialMode ( ACTIVE )  . install (  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   DeploymentUnitProcessingException ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.connector.deployers.ra.processors.RaXmlDeploymentProcessor"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentUnit   deploymentUnit    =    phaseContext . getDeploymentUnit (  )  ;", "final   ModuleLoader   moduleLoader    =    Module . getBootModuleLoader (  )  ;", "final   ModuleSpecification   moduleSpecification    =    deploymentUnit . getAttachment ( MODULE _ SPECIFICATION )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    RarDependencyProcessor . RESOURCE _ API _ ID ,    false ,    false ,    false ,    false )  )  ;", "if    (  ( phaseContext . getDeploymentUnit (  )  . getAttachment ( ConnectorXmlDescriptor . ATTACHMENT _ KEY )  )     =  =    null )     {", "return ;", "}", "moduleSpecification . setLocalDependenciesTransitive ( true )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    RarDependencyProcessor . JMS _ ID ,    false ,    false ,    false ,    false )  )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    RarDependencyProcessor . VALIDATION _ ID ,    false ,    false ,    false ,    false )  )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    RarDependencyProcessor . IRON _ JACAMAR _ ID ,    false ,    false ,    false ,    false )  )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    RarDependencyProcessor . IRON _ JACAMAR _ IMPL _ ID ,    false ,    true ,    false ,    false )  )  ;", "moduleSpecification . addSystemDependency ( new   ModuleDependency ( moduleLoader ,    RarDependencyProcessor . HIBERNATE _ VALIDATOR _ ID ,    false ,    false ,    true ,    false )  )  ;", "if    (  !  ( appclient )  )", "phaseContext . addDeploymentDependency ( util . ConnectorServices . RESOURCEADAPTERS _ SUBSYSTEM _ SERVICE ,    subsystems . resourceadapters . ResourceAdaptersSubsystemService . ATTACHMENT _ KEY )  ;", "}", "METHOD_END"], "methodName": ["deploy"], "fileName": "org.jboss.as.connector.deployers.ra.processors.RarDependencyProcessor"}, {"methodBody": ["METHOD_START", "{", "LinkedList < AttributeDefinition >    result    =    new   LinkedList <  >  (  )  ;", "for    ( String   name    :    plugin . getNames (  )  )     {", "ModelType   modelType    =    ModelType . STRING ;", "if    (  ( plugin . getType ( name )  )     =  =     ( int . class )  )     {", "modelType    =    ModelType . INT ;", "}", "if    (  ( plugin . getType ( name )  )     =  =     ( long . class )  )     {", "modelType    =    ModelType . LONG ;", "}", "SimpleAttributeDefinition   attribute    =    new   troller . SimpleAttributeDefinitionBuilder ( name ,    modelType )  . setRequired ( false )  . setStorageRuntime (  )  . build (  )  ;", "result . add ( attribute )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAttributesFromPlugin"], "fileName": "org.jboss.as.connector.dynamicresource.StatisticsResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardResourceDescriptionResolver ( keyPrefix ,    bundleName ,    ResourceAdaptersExtension . class . getClassLoader (  )  ,    true ,    false )     {", "@ Override", "public   String   getResourceAttributeDescription ( String   attributeName ,    Locale   locale ,    ResourceBundle   bundle )     {", "if    ( bundle . containsKey (  (  ( keyPrefix    +     \"  .  \"  )     +    attributeName )  )  )     {", "return   super . getResourceAttributeDescription ( attributeName ,    locale ,    bundle )  ;", "}", "return   plugin . getDescription ( attributeName )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getResolver"], "fileName": "org.jboss.as.connector.dynamicresource.StatisticsResourceDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( security    =  =    null )", "return   false ;", "if    (  ( security   instanceof   common . SecurityMetadata )     &  &     (  (  ( common . SecurityMetadata )     ( security )  )  . isElytronEnabled (  )  )  )", "return   false ;", "final   String   domain    =    security . resolveSecurityDomain (  )  ;", "return    ( domain    !  =    null )     &  &     (  ( domain . trim (  )  . length (  )  )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["isLegacySecurityRequired"], "fileName": "org.jboss.as.connector.metadata.api.resourceadapter.ActivationSecurityUtil"}, {"methodBody": ["METHOD_START", "{", "boolean   required    =    false ;", "WorkManagerSecurity   wmsecurity    =     (  ( raxml . getWorkManager (  )  )     !  =    null )     ?    raxml . getWorkManager (  )  . getSecurity (  )     :    null ;", "required    =     . isLegacySecurityRequired ( wmsecurity )  ;", "if    (  ! required )     {", "List < ConnectionDefinition >    connDefs    =    raxml . getConnectionDefinitions (  )  ;", "if    ( connDefs    !  =    null )     {", "for    ( ConnectionDefinition   cd    :    connDefs )     {", "Security   cdSecurity    =    cd . getSecurity (  )  ;", "Credential   cdRecoveryCredential    =     (  ( cd . getRecovery (  )  )     =  =    null )     ?    null    :    cd . getRecovery (  )  . getCredential (  )  ;", "if    (  (  . isLegacySecurityRequired ( cdSecurity )  )     |  |     (  . isLegacySecurityRequired ( cdRecoveryCredential )  )  )     {", "required    =    true ;", "break ;", "}", "}", "}", "}", "return   required ;", "}", "METHOD_END"], "methodName": ["isLegacySecurityRequired"], "fileName": "org.jboss.as.connector.metadata.api.resourceadapter.ActivationSecurityUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( config    =  =    null )", "return   false ;", "if    (  ( config   instanceof   WorkManager )     &  &     (  (  ( WorkManager )     ( config )  )  . isElytronEnabled (  )  )  )", "return   false ;", "final   String   domain    =    config . getDomain (  )  ;", "return    ( domain    !  =    null )     &  &     (  ( domain . trim (  )  . length (  )  )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["isLegacySecurityRequired"], "fileName": "org.jboss.as.connector.metadata.api.resourceadapter.ActivationSecurityUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( credentialSourceSupplier )     !  =    null )     {", "try    {", "return   new   String ( credentialSourceSupplier . get (  )  . get ( Password . class )  . getPassword ( ClearPassword . class )  . getPassword (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . invalidSourceSupplier ( e )  ;", "}", "}", "return   this . password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.jboss.as.connector.metadata.common.CredentialImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . securityDomain ;", "}", "METHOD_END"], "methodName": ["getSecurityDomain"], "fileName": "org.jboss.as.connector.metadata.common.CredentialImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . userName ;", "}", "METHOD_END"], "methodName": ["getUserName"], "fileName": "org.jboss.as.connector.metadata.common.CredentialImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . getSecurityDomain (  )  ;", "}", "METHOD_END"], "methodName": ["resolveSecurityDomain"], "fileName": "org.jboss.as.connector.metadata.common.CredentialImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . userName )     !  =    null )     &  &     (  ( this . securityDomain )     !  =    null )  )     {", "throw   new   ValidateException (  . bundle . invalidSecurityConfiguration (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.jboss.as.connector.metadata.common.CredentialImpl"}, {"methodBody": ["METHOD_START", "{", "return   deployment ;", "}", "METHOD_END"], "methodName": ["getDeployment"], "fileName": "org.jboss.as.connector.metadata.deployment.ResourceAdapterDeployment"}, {"methodBody": ["METHOD_START", "{", "return   raName ;", "}", "METHOD_END"], "methodName": ["getRaName"], "fileName": "org.jboss.as.connector.metadata.deployment.ResourceAdapterDeployment"}, {"methodBody": ["METHOD_START", "{", "return   raServiceName ;", "}", "METHOD_END"], "methodName": ["getRaServiceName"], "fileName": "org.jboss.as.connector.metadata.deployment.ResourceAdapterDeployment"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  1  0  0  )  ;", "sb . append (  \"  @  \"  )  . append ( Integer . toHexString ( System . identityHashCode ( this )  )  )  ;", "sb . append (  \"  [ deployment =  \"  )  . append ( deployment )  ;", "sb . append (  \"  ]  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.connector.metadata.deployment.ResourceAdapterDeployment"}, {"methodBody": ["METHOD_START", "{", "return   this . reauthPlugin ;", "}", "METHOD_END"], "methodName": ["getReauthPlugin"], "fileName": "org.jboss.as.connector.metadata.ds.DsSecurityImpl"}, {"methodBody": ["METHOD_START", "{", "return   elytronEnabled ;", "}", "METHOD_END"], "methodName": ["isElytronEnabled"], "fileName": "org.jboss.as.connector.metadata.resourceadapter.WorkManagerSecurityImpl"}, {"methodBody": ["METHOD_START", "{", "return   connector ;", "}", "METHOD_END"], "methodName": ["getConnector"], "fileName": "org.jboss.as.connector.metadata.xmldescriptors.ConnectorXmlDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   deploymentName ;", "}", "METHOD_END"], "methodName": ["getDeploymentName"], "fileName": "org.jboss.as.connector.metadata.xmldescriptors.ConnectorXmlDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.jboss.as.connector.metadata.xmldescriptors.ConnectorXmlDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.jboss.as.connector.metadata.xmldescriptors.ConnectorXmlDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   ironJacamar ;", "}", "METHOD_END"], "methodName": ["getIronJacamar"], "fileName": "org.jboss.as.connector.metadata.xmldescriptors.IronJacamarXmlDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   elytronEnabled ;", "}", "METHOD_END"], "methodName": ["isElytronEnabled"], "fileName": "org.jboss.as.connector.security.CallbackImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "subject . getPrivateCredentials (  )  . add ( credential )  ;", "} else    {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", "subject . getPrivateCredentials (  )  . add ( credential )  ;", "return   null ;", "}  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addPrivateCredential"], "fileName": "org.jboss.as.connector.security.ElytronCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServerAuthenticationContext   context    =    this . securityDomain . createNewAuthenticationContext (  )  ;", "final   PasswordGuessEvidence   evidence    =    new   PasswordGuessEvidence (  ( credential    !  =    null    ?    credential    :    null )  )  ;", "try    {", "context . setAuthenticationName ( username )  ;", "if    ( context . verifyEvidence ( evidence )  )     {", "if    ( context . authorize (  )  )     {", "context . succeed (  )  ;", "return   context . getAuthorizedIdentity (  )  ;", "} else    {", "context . fail (  )  ;", "throw   new   SecurityException (  \" Authorization   failed \"  )  ;", "}", "} else    {", "context . fail (  )  ;", "throw   new   SecurityException (  \" Authentication   failed \"  )  ;", "}", "}    catch    ( IllegalArgumentException    |    IllegalStateException    |    RealmUnavailableException   e )     {", "context . fail (  )  ;", "throw   e ;", "}    finally    {", "if    (  !  ( context . isDone (  )  )  )     {", "context . fail (  )  ;", "}", "evidence . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["authenticate"], "fileName": "org.jboss.as.connector.security.ElytronCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "T   credential    =    null ;", "if    ( subject    !  =    null )     {", "Set < T >    credentialSet ;", "if    (  !  ( WildFlySManager . isChecking (  )  )  )     {", "credentialSet    =    subject . getPrivateCredentials ( credentialClass )  ;", "} else    {", "credentialSet    =    AccessController . doPrivileged (  (  ( PrivilegedAction < Set < T >  >  )     (  (  )     -  >    subject . getPrivateCredentials ( credentialClass )  )  )  )  ;", "}", "if    (  !  ( credentialSet . isEmpty (  )  )  )     {", "credential    =    credentialSet . iterator (  )  . next (  )  ;", "}", "}", "return   credential ;", "}", "METHOD_END"], "methodName": ["getPrivateCredential"], "fileName": "org.jboss.as.connector.security.ElytronCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( ConnectorLogger . SUBSYSTEM _ RA _ LOGGER . isTraceEnabled (  )  )", "ConnectorLogger . SUBSYSTEM _ RA _ LOGGER . elytronHandlerHandle ( toString ( callbacks )  )  ;", "if    (  ( this . executionSubject )     !  =    null )     {", "final   SecurityIdentity   subjectIdentity    =    this . getPrivateCredential ( this . executionSubject ,    SecurityIdentity . class )  ;", "if    (  ( subjectIdentity    !  =    null )     &  &     (  !  ( subjectIdentity . isAnonymous (  )  )  )  )     {", "return ;", "}", "}", "if    (  ( callbacks    !  =    null )     &  &     (  ( callbacks . length )     >     0  )  )     {", "if    (  (  ( this . mappings )     !  =    null )     &  &     ( this . mappings . isMappingRequired (  )  )  )     {", "callbacks    =    this . mappings . mapCallbacks ( callbacks )  ;", "}", "GroupPrincipalCallback   groupPrincipalCallback    =    null ;", "CallerPrincipalCallback   callerPrincipalCallback    =    null ;", "PasswordValidati   passwordValidati    =    null ;", "for    ( Callback   callback    :    callbacks )     {", "if    ( callback   instanceof   GroupPrincipalCallback )     {", "groupPrincipalCallback    =     (  ( GroupPrincipalCallback )     ( callback )  )  ;", "if    (  ( this . executionSubject )     =  =    null )     {", "this . executionSubject    =    groupPrincipalCallback . getSubject (  )  ;", "} else", "if    (  !  ( this . executionSubject . equals ( groupPrincipalCallback . getSubject (  )  )  )  )     {", "}", "} else", "if    ( callback   instanceof   CallerPrincipalCallback )     {", "callerPrincipalCallback    =     (  ( CallerPrincipalCallback )     ( callback )  )  ;", "if    (  ( this . executionSubject )     =  =    null )     {", "this . executionSubject    =    callerPrincipalCallback . getSubject (  )  ;", "} else", "if    (  !  ( this . executionSubject . equals ( callerPrincipalCallback . getSubject (  )  )  )  )     {", "}", "} else", "if    ( callback   instanceof   PasswordValidati )     {", "passwordValidati    =     (  ( PasswordValidati )     ( callback )  )  ;", "if    (  ( this . executionSubject )     =  =    null )     {", "this . executionSubject    =    passwordValidati . getSubject (  )  ;", "} else", "if    (  !  ( this . executionSubject . equals ( passwordValidati . getSubject (  )  )  )  )     {", "}", "} else    {", "throw   new   UnsupportedCallbackException ( callback )  ;", "}", "}", "this . handleInternal ( callerPrincipalCallback ,    groupPrincipalCallback ,    passwordValidati )  ;", "}", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.jboss.as.connector.security.ElytronCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . executionSubject )     =  =    null )     {", "throw   ConnectorLogger . SUBSYSTEM _ RA _ LOGGER . executionSubjectNotSetInHandler (  )  ;", "}", "SecurityIdentity   identity    =    this . securityDomain . getAnonymousSecurityIdentity (  )  ;", "Principal   callerPrincipal    =    null ;", "if    ( callerPrincipalCallback    !  =    null )     {", "Principal   callbackPrincipal    =    callerPrincipalCallback . getPrincipal (  )  ;", "callerPrincipal    =     ( callbackPrincipal    !  =    null )     ?    new   NamePrincipal ( callbackPrincipal . getName (  )  )     :     ( callerPrincipalCallback . getName (  )  )     !  =    null    ?    new   NamePrincipal ( callerPrincipalCallback . getName (  )  )     :    null ;", "}", "if    ( callerPrincipal    !  =    null )     {", "if    ( passwordValidati    !  =    null )     {", "final   String   username    =    passwordValidati . getUsername (  )  ;", "final   char [  ]    password    =    passwordValidati . getPassword (  )  ;", "try    {", "identity    =    this . authenticate ( username ,    password )  ;", "this . addPrivateCredential ( this . executionSubject ,    new   PasswordCredential ( username ,    password )  )  ;", "passwordValidati . setResult ( true )  ;", "}    catch    ( SecurityException   e )     {", "passwordValidati . setResult ( false )  ;", "return ;", "}", "} else    {", "PasswordCredential   passwordCredential    =    this . getPrivateCredential ( this . executionSubject ,    PasswordCredential . class )  ;", "if    ( passwordCredential    !  =    null )     {", "try    {", "identity    =    this . authenticate ( passwordCredential . getUserName (  )  ,    passwordCredential . getPassword (  )  )  ;", "}    catch    ( SecurityException   e )     {", "return ;", "}", "} else    {", "identity    =    securityDomain . createAdHocIdentity ( callerPrincipal )  ;", "}", "}", "if    (  !  ( callerPrincipal . equals ( identity . getPrincipal (  )  )  )  )     {", "identity    =    identity . createRunAsIdentity ( callerPrincipal . getName (  )  )  ;", "}", "if    ( groupPrincipalCallback    !  =    null )     {", "String [  ]    groups    =    groupPrincipalCallback . getGroups (  )  ;", "if    ( groups    !  =    null )     {", "Set < String >    roles    =    new   HashSet <  >  ( Arrays . asList ( groups )  )  ;", "identity    =    identity . withRoleMapper ( ElytronSecurityIntegration . SECURITY _ IDENTITY _ ROLE ,    RoleMapper . constant ( Roles . fromSet ( roles )  )  )  ;", "}", "}", "}", "this . executionSubject . getPrincipals (  )  . add ( identity . getPrincipal (  )  )  ;", "this . addPrivateCredential ( executionSubject ,    identity )  ;", "}", "METHOD_END"], "methodName": ["handleInternal"], "fileName": "org.jboss.as.connector.security.ElytronCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "return   this . authenticatedSubject . getPrivateCredentials ( credentialClass )  ;", "} else    {", "return   AccessController . doPrivileged (  (  ( PrivilegedAction < Set < T >  >  )     (  (  )     -  >    this . authenticatedSubject . getPrivateCredentials ( credentialClass )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPrivateCredentials"], "fileName": "org.jboss.as.connector.security.ElytronSecurityContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . authenticatedSubject )     !  =    null )     {", "Set < Identity >    authenticatedIdentities    =    this . getPrivateCredentials ( Identity . class )  ;", "if    (  !  ( authenticatedIdentities . isEmpty (  )  )  )     {", "Identity   identity    =    authenticatedIdentities . iterator (  )  . next (  )  ;", "identity . runAs ( work )  ;", "return ;", "}", "}", "work . run (  )  ;", "}", "METHOD_END"], "methodName": ["runWork"], "fileName": "org.jboss.as.connector.security.ElytronSecurityContext"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "return   CurrentServiceContainer . getServiceContainer (  )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.connector.security.ElytronSecurityIntegration"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "subject . getPrivateCredentials (  )  . add ( credential )  ;", "} else    {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Void >  )     (  (  )     -  >     {", "subject . getPrivateCredentials (  )  . add ( credential )  ;", "return   null ;", "}  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addPrivateCredential"], "fileName": "org.jboss.as.connector.security.ElytronSubjectFactory"}, {"methodBody": ["METHOD_START", "{", "final   Subject   subject    =    this . createSubject ( getAuthenticationContext (  )  )  ;", "if    ( CLogger . ROOT _ LOGGER . isTraceEnabled (  )  )     {", "CLogger . ROOT _ LOGGER . subject ( subject ,    Integer . toHexString ( System . identityHashCode ( subject )  )  )  ;", "}", "return   subject ;", "}", "METHOD_END"], "methodName": ["createSubject"], "fileName": "org.jboss.as.connector.security.ElytronSubjectFactory"}, {"methodBody": ["METHOD_START", "{", "AuthenticationContext   context ;", "if    (  ( authenticationContextName    !  =    null )     &  &     (  !  ( authenticationContextName . isEmpty (  )  )  )  )     {", "final   ServiceContainer   container    =    this . currentServiceContainer (  )  ;", "final   ServiceName   authContextServiceName    =     . AUTHENTICATION _ CONTEXT _ RUNTIME _ CAPABILITY . getCapabilityServiceName ( authenticationContextName )  ;", "context    =     (  ( AuthenticationContext )     ( container . getRequiredService ( authContextServiceName )  . getValue (  )  )  )  ;", "} else    {", "context    =    getAuthenticationContext (  )  ;", "}", "final   Subject   subject    =    this . createSubject ( context )  ;", "if    ( ConnectorLogger . ROOT _ LOGGER . isTraceEnabled (  )  )     {", "ConnectorLogger . ROOT _ LOGGER . subject ( subject ,    Integer . toHexString ( System . identityHashCode ( subject )  )  )  ;", "}", "return   subject ;", "}", "METHOD_END"], "methodName": ["createSubject"], "fileName": "org.jboss.as.connector.security.ElytronSubjectFactory"}, {"methodBody": ["METHOD_START", "{", "final   AuthenticationConfiguration   configuration    =    ElytronSubjectFactory . AUTH _ CONFIG _ CLIENT . getAuthenticationConfiguration ( this . targetURI ,    authenticationContext )  ;", "final   CallbackHandler   handler    =    ElytronSubjectFactory . AUTH _ CONFIG _ CLIENT . getCallbackHandler ( configuration )  ;", "final   NameCallback   nameCallback    =    new   NameCallback (  \" Username :     \"  )  ;", "final   PasswordCallback   passwordCallback    =    new   PasswordCallback (  \" Password :     \"  ,    false )  ;", "final   CredentialCallback   credentialCallback    =    new   CredentialCallback ( GSSKerberosCredential . class )  ;", "try    {", "handler . handle ( new   Callback [  ]  {    nameCallback ,    passwordCallback ,    credentialCallback    }  )  ;", "Subject   subject    =    new   Subject (  )  ;", "if    (  ( credentialCallback . getCredential (  )  )     !  =    null )     {", "GSSKerberosCredential   kerberosCredential    =    GSSKerberosCredential . class . cast ( credentialCallback . getCredential (  )  )  ;", "this . addPrivateCredential ( subject ,    kerberosCredential . getKerberosTicket (  )  )  ;", "this . addPrivateCredential ( subject ,    kerberosCredential . getGssCredential (  )  )  ;", "GSSName   gssName    =    kerberosCredential . getGssCredential (  )  . getName (  )  ;", "subject . getPrincipals (  )  . add ( new   KerberosPrincipal ( gssName . toString (  )  )  )  ;", "}", "if    (  ( nameCallback . getName (  )  )     !  =    null )     {", "subject . getPrincipals (  )  . add ( new   NamePrincipal ( nameCallback . getName (  )  )  )  ;", "}", "if    (  ( passwordCallback . getPassword (  )  )     !  =    null )     {", "this . addPrivateCredential ( subject ,    new   PasswordCredential ( nameCallback . getName (  )  ,    passwordCallback . getPassword (  )  )  )  ;", "}", "return   subject ;", "}    catch    ( Exception   e )     {", "throw   new   SecurityException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createSubject"], "fileName": "org.jboss.as.connector.security.ElytronSubjectFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( GET _ ACTION )  ;", "}", "return   CurrentServiceContainer . getServiceContainer (  )  ;", "}", "METHOD_END"], "methodName": ["currentServiceContainer"], "fileName": "org.jboss.as.connector.security.ElytronSubjectFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( authenticationContext )     =  =    null    ?    AuthenticationContext . captureCurrent (  )     :    authenticationContext ;", "}", "METHOD_END"], "methodName": ["getAuthenticationContext"], "fileName": "org.jboss.as.connector.security.ElytronSubjectFactory"}, {"methodBody": ["METHOD_START", "{", "return   jcaConfig ;", "}", "METHOD_END"], "methodName": ["getJcaConfigInjector"], "fileName": "org.jboss.as.connector.services.bootstrap.BootStrapContextService"}, {"methodBody": ["METHOD_START", "{", "return   txManager ;", "}", "METHOD_END"], "methodName": ["getTxManagerInjector"], "fileName": "org.jboss.as.connector.services.bootstrap.BootStrapContextService"}, {"methodBody": ["METHOD_START", "{", "return   workManagerValue ;", "}", "METHOD_END"], "methodName": ["getWorkManagerValue"], "fileName": "org.jboss.as.connector.services.bootstrap.BootStrapContextService"}, {"methodBody": ["METHOD_START", "{", "return   workManagerValue ;", "}", "METHOD_END"], "methodName": ["getWorkManagerValueInjector"], "fileName": "org.jboss.as.connector.services.bootstrap.BootStrapContextService"}, {"methodBody": ["METHOD_START", "{", "return   xaTerminator ;", "}", "METHOD_END"], "methodName": ["getXaTerminatorInjector"], "fileName": "org.jboss.as.connector.services.bootstrap.BootStrapContextService"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.connector.services.bootstrap.NamedBootstrapContext"}, {"methodBody": ["METHOD_START", "{", "name    =    v ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.jboss.as.connector.services.bootstrap.NamedBootstrapContext"}, {"methodBody": ["METHOD_START", "{", "return   injectedDeploymentMD ;", "}", "METHOD_END"], "methodName": ["getCommonDeploymentInjector"], "fileName": "org.jboss.as.connector.services.datasources.statistics.DataSourceStatisticsService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( DataSourceStatisticsService . JDBC _ STATISTICS )     {", "if    (  !  ( datasourceResource . hasChild ( DataSourceStatisticsService . JDBC _ STATISTICS )  )  )     {", "datasourceResource . registerChild ( DataSourceStatisticsService . JDBC _ STATISTICS ,    new   PlaceholderResourceEntry ( DataSourceStatisticsService . JDBC _ STATISTICS )  )  ;", "}", "if    (  !  ( datasourceResource . hasChild ( DataSourceStatisticsService . POOL _ STATISTICS )  )  )     {", "datasourceResource . registerChild ( DataSourceStatisticsService . POOL _ STATISTICS ,    new   PlaceholderResourceEntry ( DataSourceStatisticsService . POOL _ STATISTICS )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerStatisticsResources"], "fileName": "org.jboss.as.connector.services.datasources.statistics.DataSourceStatisticsService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( DataSourceStatisticsService . JDBC _ STATISTICS )     {", "if    ( datasourceResource . hasChild ( DataSourceStatisticsService . JDBC _ STATISTICS )  )     {", "datasourceResource . removeChild ( DataSourceStatisticsService . JDBC _ STATISTICS )  ;", "}", "if    ( datasourceResource . hasChild ( DataSourceStatisticsService . POOL _ STATISTICS )  )     {", "datasourceResource . removeChild ( DataSourceStatisticsService . POOL _ STATISTICS )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeStatisticsResources"], "fileName": "org.jboss.as.connector.services.datasources.statistics.DataSourceStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   injectedDriverRegistry ;", "}", "METHOD_END"], "methodName": ["getDriverRegistryServiceInjector"], "fileName": "org.jboss.as.connector.services.driver.DriverService"}, {"methodBody": ["METHOD_START", "{", "return   dataSourceClassName ;", "}", "METHOD_END"], "methodName": ["getDataSourceClassName"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnitName ;", "}", "METHOD_END"], "methodName": ["getDeploymentUnitName"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   driverClassName ;", "}", "METHOD_END"], "methodName": ["getDriverClassName"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   driverName ;", "}", "METHOD_END"], "methodName": ["getDriverName"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   majorVersion ;", "}", "METHOD_END"], "methodName": ["getMajorVersion"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   minorVersion ;", "}", "METHOD_END"], "methodName": ["getMinorVersion"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   xaDataSourceClassName ;", "}", "METHOD_END"], "methodName": ["getXaDataSourceClassName"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return    ( deploymentUnitName )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isFromDeployment"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   jdbcCompliant ;", "}", "METHOD_END"], "methodName": ["isJdbcCompliant"], "fileName": "org.jboss.as.connector.services.driver.InstalledDriver"}, {"methodBody": ["METHOD_START", "{", "return   transactionIntegration ;", "}", "METHOD_END"], "methodName": ["getTransactionIntegrationInjector"], "fileName": "org.jboss.as.connector.services.jca.CachedConnectionManagerService"}, {"methodBody": ["METHOD_START", "{", "return   mdrValue ;", "}", "METHOD_END"], "methodName": ["getMdrInjector"], "fileName": "org.jboss.as.connector.services.rarepository.NonJTADataSourceRaRepositoryService"}, {"methodBody": ["METHOD_START", "{", "return   mdrValue ;", "}", "METHOD_END"], "methodName": ["getMdrInjector"], "fileName": "org.jboss.as.connector.services.rarepository.RaRepositoryService"}, {"methodBody": ["METHOD_START", "{", "return   tiValue ;", "}", "METHOD_END"], "methodName": ["getTransactionIntegrationInjector"], "fileName": "org.jboss.as.connector.services.rarepository.RaRepositoryService"}, {"methodBody": ["METHOD_START", "{", "return   adminObjectValue ;", "}", "METHOD_END"], "methodName": ["getAdminObjectInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.AdminObjectReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   reference ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.jboss.as.connector.services.resourceadapters.AdminObjectReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.connector.services.resourceadapters.AdminObjectReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "reference    =    new   ValueManagedReference ( new   ImmediateValue < Object >  ( adminObjectValue . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.connector.services.resourceadapters.AdminObjectReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "reference    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.connector.services.resourceadapters.AdminObjectReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   connectionFactoryValue ;", "}", "METHOD_END"], "methodName": ["getConnectionFactoryInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.ConnectionFactoryReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   reference ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.jboss.as.connector.services.resourceadapters.ConnectionFactoryReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.connector.services.resourceadapters.ConnectionFactoryReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "reference    =    new   ValueManagedReference ( new   ImmediateValue < Object >  ( connectionFactoryValue . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.connector.services.resourceadapters.ConnectionFactoryReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "reference    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.connector.services.resourceadapters.ConnectionFactoryReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   mdr ;", "}", "METHOD_END"], "methodName": ["getMdrInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.DirectAdminObjectActivatorService"}, {"methodBody": ["METHOD_START", "{", "if    ( aoInterface    !  =    null )     {", "if    (  ( aoInterface . indexOf (  \"  .  \"  )  )     !  =     (  -  1  )  )     {", "return   aoInterface . substring (  (  ( aoInterface . lastIndexOf (  \"  .  \"  )  )     +     1  )  )  ;", "} else    {", "return   aoInterface ;", "}", "}", "if    (  ( aoClass . indexOf (  \"  .  \"  )  )     !  =     (  -  1  )  )     {", "return   aoClass . substring (  (  ( aoClass . lastIndexOf (  \"  .  \"  )  )     +     1  )  )  ;", "} else    {", "return   aoClass ;", "}", "}", "METHOD_END"], "methodName": ["poolName"], "fileName": "org.jboss.as.connector.services.resourceadapters.DirectAdminObjectActivatorService"}, {"methodBody": ["METHOD_START", "{", "return   mdr ;", "}", "METHOD_END"], "methodName": ["getMdrInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.DirectConnectionFactoryActivatorService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cfInterface . indexOf (  \"  .  \"  )  )     !  =     (  -  1  )  )     {", "return   cfInterface . substring (  (  ( cfInterface . lastIndexOf (  \"  .  \"  )  )     +     1  )  )  ;", "} else    {", "return   cfInterface ;", "}", "}", "METHOD_END"], "methodName": ["poolName"], "fileName": "org.jboss.as.connector.services.resourceadapters.DirectConnectionFactoryActivatorService"}, {"methodBody": ["METHOD_START", "{", "return   mdr ;", "}", "METHOD_END"], "methodName": ["getMdrInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.IronJacamarActivationResourceService"}, {"methodBody": ["METHOD_START", "{", "return   deployment ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterDeploymentInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.IronJacamarActivationResourceService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bindInfo )     !  =    null )", "return   bindInfo ;", "return   ContextNambindInfoFor ( jndi )  ;", "}", "METHOD_END"], "methodName": ["getBindInfo"], "fileName": "org.jboss.as.connector.services.resourceadapters.ResourceAdapterActivatorService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentMD ;", "}", "METHOD_END"], "methodName": ["getDeploymentMD"], "fileName": "org.jboss.as.connector.services.resourceadapters.ResourceAdapterActivatorService"}, {"methodBody": ["METHOD_START", "{", "return   createBinderService ;", "}", "METHOD_END"], "methodName": ["isCreateBinderService"], "fileName": "org.jboss.as.connector.services.resourceadapters.ResourceAdapterActivatorService"}, {"methodBody": ["METHOD_START", "{", "this . bindInfo    =    bindInfo ;", "}", "METHOD_END"], "methodName": ["setBindInfo"], "fileName": "org.jboss.as.connector.services.resourceadapters.ResourceAdapterActivatorService"}, {"methodBody": ["METHOD_START", "{", "this . createBinderService    =    createBinderService ;", "}", "METHOD_END"], "methodName": ["setCreateBinderService"], "fileName": "org.jboss.as.connector.services.resourceadapters.ResourceAdapterActivatorService"}, {"methodBody": ["METHOD_START", "{", "ExecutorService   executorService    =    getLifecycleExecutorService (  )  ;", "Runnable   r    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "WritableServiceBasedNamingStore . pushOwner ( serviceName )  ;", "unregisterAll ( Name )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "context . failed ( ConnectorLogger . ROOT _ LOGGER . failedToStartRaDeployment ( cause ,    Name )  )  ;", "}", "}", "}  ;", "try    {", "executorService . execute ( r )  ;", "}    catch    ( RejectedExecutionException   e )     {", "r . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupStartAsync"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   ContextNames . bindInfoFor ( jndi )  ;", "}", "METHOD_END"], "methodName": ["getBindInfo"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   ccmValue ;", "}", "METHOD_END"], "methodName": ["getCcmInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   config ;", "}", "METHOD_END"], "methodName": ["getConfig"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   config ;", "}", "METHOD_END"], "methodName": ["getConfigInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   executorServiceInjector ;", "}", "METHOD_END"], "methodName": ["getExecutorServiceInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "ExecutorService   result    =    executorServiceInjector . getOptionalValue (  )  ;", "if    ( result    =  =    null )     {", "final   ThreadGroup   threadGroup    =    new   ThreadGroup (  \"    ThreadGroup \"  )  ;", "final   String   namePattern    =     \"    Thread   Pool    -  -     % t \"  ;", "final   ThreadFactory   threadFactory    =    AccessController . doPrivileged ( new   PrivilegedAction < JBossThreadFactory >  (  )     {", "public   JBossThreadFactory   run (  )     {", "return   new   JBossThreadFactory ( threadGroup ,    Boolean . FALSE ,    null ,    namePattern ,    null ,    null )  ;", "}", "}  )  ;", "result    =    Executors . newSingleThreadExecutor ( threadFactory )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getLifecycleExecutorService"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   managementRepository ;", "}", "METHOD_END"], "methodName": ["getManagementRepositoryInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   mdr ;", "}", "METHOD_END"], "methodName": ["getMdrInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   raRepository ;", "}", "METHOD_END"], "methodName": ["getRaRepositoryInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   registry ;", "}", "METHOD_END"], "methodName": ["getRegistryInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   secManager ;", "}", "METHOD_END"], "methodName": ["getServerSecurityManager"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   subjectFactory ;", "}", "METHOD_END"], "methodName": ["getSubjectFactoryInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   txInt ;", "}", "METHOD_END"], "methodName": ["getTxIntegration"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   txInt ;", "}", "METHOD_END"], "methodName": ["getTxIntegrationInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   ConnectorServices . notNull ( value )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isCreateBinderService"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "ExecutorService   executorService    =    getLifecycleExecutorService (  )  ;", "Runnable   r    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \" Stopping   service    % s \"  ,    serviceName )  ;", "WritableServiceBasedNamingStore . pushOwner ( serviceName )  ;", "unregisterAll ( Name )  ;", "}    finally    {", "WritableServiceBasedNamingStore . popOwner (  )  ;", "context . complete (  )  ;", "}", "}", "}  ;", "try    {", "executorService . execute ( r )  ;", "}    catch    ( RejectedExecutionException   e )     {", "r . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopAsync"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( value )     !  =    null )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debugf (  \" Unregistering :     % s \"  ,    deploymentName )  ;", "if    (  (  ( registry )     !  =    null )     &  &     (  ( registry . getValue (  )  )     !  =    null )  )     {", "registry . getValue (  )  . unregister ( value )  ;", "}", "if    (  (  (  (  ( managementRepository )     !  =    null )     &  &     (  ( managementRepository . getValue (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  . getConnector (  )  )     !  =    null )  )     {", "managementRepository . getValue (  )  . getConnectors (  )  . remove ( value . getDeployment (  )  . getConnector (  )  )  ;", "}", "if    (  (  (  (  (  ( mdr )     !  =    null )     &  &     (  ( mdr . getValue (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  . getCfs (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  . getCfJndiNames (  )  )     !  =    null )  )     {", "for    ( int   i    =     0  ;    i    <     ( value . getDeployment (  )  . getCfs (  )  . length )  ;    i +  +  )     {", "try    {", "String   cf    =    value . getDeployment (  )  . getCfs (  )  [ i ]  . getClass (  )  . getName (  )  ;", "String   jndi    =    value . getDeployment (  )  . getCfJndiNames (  )  [ i ]  ;", "mdr . getValue (  )  . unregisterJndiMapping ( value . getDeployment (  )  . getURL (  )  . toExternalForm (  )  ,    cf ,    jndi )  ;", "}    catch    ( Throwable   nfe )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debug (  \" Exception   during   JNDI   unbinding \"  ,    nfe )  ;", "}", "}", "}", "if    (  (  (  (  ( mdr )     !  =    null )     &  &     (  ( mdr . getValue (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  . getAos (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  . getAoJndiNames (  )  )     !  =    null )  )     {", "for    ( int   i    =     0  ;    i    <     ( value . getDeployment (  )  . getAos (  )  . length )  ;    i +  +  )     {", "try    {", "String   ao    =    value . getDeployment (  )  . getAos (  )  [ i ]  . getClass (  )  . getName (  )  ;", "String   jndi    =    value . getDeployment (  )  . getAoJndiNames (  )  [ i ]  ;", "mdr . getValue (  )  . unregisterJndiMapping ( value . getDeployment (  )  . getURL (  )  . toExternalForm (  )  ,    ao ,    jndi )  ;", "}    catch    ( Throwable   nfe )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debug (  \" Exception   during   JNDI   unbinding \"  ,    nfe )  ;", "}", "}", "}", "if    (  (  (  (  (  ( value )     !  =    null )     &  &     (  ( value . getDeployment (  )  )     !  =    null )  )     &  &     (  ( value . getDeployment (  )  . getRecovery (  )  )     !  =    null )  )     &  &     (  ( txInt )     !  =    null )  )     &  &     (  ( txInt . getValue (  )  )     !  =    null )  )     {", "XAResourceRecoveryRegistry   rr    =    txInt . getValue (  )  . getRecoveryRegistry (  )  ;", "if    ( rr    !  =    null )     {", "for    ( XAResourceRecovery   recovery    :    value . getDeployment (  )  . getRecovery (  )  )     {", "if    ( recovery    !  =    null )     {", "try    {", "recovery . shutdown (  )  ;", "}    catch    ( Exception   e )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . errorDuringRecoveryShutdown ( e )  ;", "}    finally    {", "rr . removeXAResourceRecovery ( recovery )  ;", "}", "}", "}", "}", "}", "if    (  (  ( value . getDeployment (  )  )     !  =    null )     &  &     (  ( value . getDeployment (  )  . getConnectionManagers (  )  )     !  =    null )  )     {", "for    ( ConnectionManager   cm    :    value . getDeployment (  )  . getConnectionManagers (  )  )     {", "cm . shutdown (  )  ;", "}", "}", "if    (  (  ( value . getDeployment (  )  )     !  =    null )     &  &     (  ( value . getDeployment (  )  . getResourceAdapter (  )  )     !  =    null )  )     {", "ClassLoader   old    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( value . getDeployment (  )  . getResourceAdapter (  )  . getClass (  )  . getClassLoader (  )  )  ;", "value . getDeployment (  )  . getResourceAdapter (  )  . stop (  )  ;", "}    catch    ( Throwable   nfe )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . errorStoppingRA ( nfe )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( old )  ;", "}", "}", "if    (  (  ( value . getDeployment (  )  )     !  =    null )     &  &     (  ( value . getDeployment (  )  . getBootstrapContextIdentifier (  )  )     !  =    null )  )     {", "BootstrapContextCoordinator . getInstance (  )  . removeBootstrapContext ( value . getDeployment (  )  . getBootstrapContextIdentifier (  )  )  ;", "}", "}", "if    (  (  (  ( raRepositoryRegistrationId )     !  =    null )     &  &     (  ( raRepository )     !  =    null )  )     &  &     (  ( raRepository . getValue (  )  )     !  =    null )  )     {", "try    {", "raRepository . getValue (  )  . unregisterResourceAdapter ( raRepositoryRegistrationId )  ;", "}    catch    ( Throwable   e )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debug (  \" Failed   to   unregister   RA   from   RA   Repository \"  ,    e )  ;", "}", "}", "if    (  ( connectorServicesRegistrationName )     !  =    null )     {", "try    {", "ConnectorServices . unregisterResourceAdapterIdentifier ( connectorServicesRegistrationName )  ;", "}    catch    ( Throwable   e )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debug (  \" Failed   to   unregister   RA   from   ConnectorServices \"  ,    e )  ;", "}", "}", "if    (  (  (  ( mdrRegistrationName )     !  =    null )     &  &     (  ( mdr )     !  =    null )  )     &  &     (  ( mdr . getValue (  )  )     !  =    null )  )     {", "try    {", "mdr . getValue (  )  . unregisterResourceAdapter ( mdrRegistrationName )  ;", "}    catch    ( Throwable   e )     {", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ LOGGER . debug (  \" Failed   to   unregister   RA   from   MDR \"  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["unregisterAll"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.AbstractResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.InactiveResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "if    (  (  ( format )     =  =    null )     |  |     (  ( format . locale (  )  )     !  =     ( Locale . getDefault (  )  )  )  )", "format    =    new   Format ( this )  ;", "format . format ( Locale . getDefault (  )  ,    format ,    args )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.JBossLogPrintWriter"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "if    (  (  ( format )     =  =    null )     |  |     (  ( format . locale (  )  )     !  =    l )  )", "format    =    new   Format ( this ,    l )  ;", "format . format ( l ,    format ,    args )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.JBossLogPrintWriter"}, {"methodBody": ["METHOD_START", "{", "outputLogger (  )  ;", "}", "METHOD_END"], "methodName": ["newLine"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.JBossLogPrintWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffer . length (  )  )     >     0  )     {", "logger . log ( level ,     (  (  ( Name )     +     \"  :     \"  )     +     ( buffer . toString (  )  )  )  )  ;", "buffer . setLength (  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["outputLogger"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.JBossLogPrintWriter"}, {"methodBody": ["METHOD_START", "{", "ExecutorService   executorService    =    getLifecycleExecutorService (  )  ;", "Runnable   r    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "ClassLoader   old    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WritableServiceBasedNamingStore . pushOwner ( duServiceName )  ;", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( toUse )  ;", "unregisterAll ( Name )  ;", "}    finally    {", "try    {", "context . failed ( ConnectorLogger . ROOT _ LOGGER . failedToStartRaDeployment ( cause ,    Name )  )  ;", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( old )  ;", "WritableServiceBasedNamingStore . popOwner (  )  ;", "}", "}", "}", "}  ;", "try    {", "executorService . execute ( r )  ;", "}    catch    ( RejectedExecutionException   e )     {", "r . run (  )  ;", "}    finally    {", "context . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupStartAsync"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.ResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   mdr . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getMdr"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.ResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   raDeployment ;", "}", "METHOD_END"], "methodName": ["getRaDeployment"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.ResourceAdapterDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   raxml ;", "}", "METHOD_END"], "methodName": ["getRaxml"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.ResourceAdapterXmlDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   raxmlDeployment ;", "}", "METHOD_END"], "methodName": ["getRaxmlDeployment"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.ResourceAdapterXmlDeploymentService"}, {"methodBody": ["METHOD_START", "{", "this . raxml    =    raxml ;", "}", "METHOD_END"], "methodName": ["setRaxml"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.ResourceAdapterXmlDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( deployments )  ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterDeployments"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.registry.ResourceAdapterDeploymentRegistryImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( deployment    =  =    null )", "throw   new   IllegalArgumentException ( ConnectorLogger . ROOT _ LOGGER . nullVar (  \" Deployment \"  )  )  ;", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ REGISTRY _ LOGGER . tracef (  \" Adding   deployment :     % s \"  ,    deployment )  ;", "deployments . add ( deployment )  ;", "}", "METHOD_END"], "methodName": ["registerResourceAdapterDeployment"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.registry.ResourceAdapterDeploymentRegistryImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( deployment    =  =    null )", "throw   new   IllegalArgumentException ( ConnectorLogger . ROOT _ LOGGER . nullVar (  \" Deployment \"  )  )  ;", "ConnectorLogger . DEPLOYMENT _ CONNECTOR _ REGISTRY _ LOGGER . tracef (  \" Removing   deployment :     % s \"  ,    deployment )  ;", "deployments . remove ( deployment )  ;", "}", "METHOD_END"], "methodName": ["unregisterResourceAdapterDeployment"], "fileName": "org.jboss.as.connector.services.resourceadapters.deployment.registry.ResourceAdapterDeploymentRegistryImpl"}, {"methodBody": ["METHOD_START", "{", "return   bootstrapContext ;", "}", "METHOD_END"], "methodName": ["getBootstrapContextInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.statistics.AdminObjectStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   deployment ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterDeploymentInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.statistics.AdminObjectStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   bootstrapContext ;", "}", "METHOD_END"], "methodName": ["getBootstrapContextInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.statistics.ConnectionDefinitionStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   deployment ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterDeploymentInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.statistics.ConnectionDefinitionStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   bootstrapContext ;", "}", "METHOD_END"], "methodName": ["getBootstrapContextInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.statistics.ResourceAdapterStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   deployment ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterDeploymentInjector"], "fileName": "org.jboss.as.connector.services.resourceadapters.statistics.ResourceAdapterStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   rr ;", "}", "METHOD_END"], "methodName": ["getRrInjector"], "fileName": "org.jboss.as.connector.services.transactionintegration.TransactionIntegrationService"}, {"methodBody": ["METHOD_START", "{", "return   terminator ;", "}", "METHOD_END"], "methodName": ["getTerminatorInjector"], "fileName": "org.jboss.as.connector.services.transactionintegration.TransactionIntegrationService"}, {"methodBody": ["METHOD_START", "{", "return   tm ;", "}", "METHOD_END"], "methodName": ["getTmInjector"], "fileName": "org.jboss.as.connector.services.transactionintegration.TransactionIntegrationService"}, {"methodBody": ["METHOD_START", "{", "return   tsr ;", "}", "METHOD_END"], "methodName": ["getTsrInjector"], "fileName": "org.jboss.as.connector.services.transactionintegration.TransactionIntegrationService"}, {"methodBody": ["METHOD_START", "{", "return   utr ;", "}", "METHOD_END"], "methodName": ["getUtrInjector"], "fileName": "org.jboss.as.connector.services.transactionintegration.TransactionIntegrationService"}, {"methodBody": ["METHOD_START", "{", "return   this . dispatcherFactory ;", "}", "METHOD_END"], "methodName": ["getCommandDispatcherFactoryInjector"], "fileName": "org.jboss.as.connector.services.workmanager.DistributedWorkManagerService"}, {"methodBody": ["METHOD_START", "{", "return   executorLong ;", "}", "METHOD_END"], "methodName": ["getExecutorLongInjector"], "fileName": "org.jboss.as.connector.services.workmanager.DistributedWorkManagerService"}, {"methodBody": ["METHOD_START", "{", "return   executorShort ;", "}", "METHOD_END"], "methodName": ["getExecutorShortInjector"], "fileName": "org.jboss.as.connector.services.workmanager.DistributedWorkManagerService"}, {"methodBody": ["METHOD_START", "{", "return   xaTerminator ;", "}", "METHOD_END"], "methodName": ["getXaTerminatorInjector"], "fileName": "org.jboss.as.connector.services.workmanager.DistributedWorkManagerService"}, {"methodBody": ["METHOD_START", "{", "return   new   WildflyWorkWrapper ( this ,    securityIntegration ,    work ,    executionContext ,    workListener ,    startedLatch ,    completedLatch ,    System . currentTimeMillis (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWorKWrapper"], "fileName": "org.jboss.as.connector.services.workmanager.NamedDistributedWorkManager"}, {"methodBody": ["METHOD_START", "{", "return   elytronEnabled ;", "}", "METHOD_END"], "methodName": ["isElytronEnabled"], "fileName": "org.jboss.as.connector.services.workmanager.NamedDistributedWorkManager"}, {"methodBody": ["METHOD_START", "{", "return   elytronEnabled ;", "}", "METHOD_END"], "methodName": ["isElytronEnabled"], "fileName": "org.jboss.as.connector.services.workmanager.NamedWorkManager"}, {"methodBody": ["METHOD_START", "{", "return   executorLong ;", "}", "METHOD_END"], "methodName": ["getExecutorLongInjector"], "fileName": "org.jboss.as.connector.services.workmanager.WorkManagerService"}, {"methodBody": ["METHOD_START", "{", "return   executorShort ;", "}", "METHOD_END"], "methodName": ["getExecutorShortInjector"], "fileName": "org.jboss.as.connector.services.workmanager.WorkManagerService"}, {"methodBody": ["METHOD_START", "{", "return   xaTerminator ;", "}", "METHOD_END"], "methodName": ["getXaTerminatorInjector"], "fileName": "org.jboss.as.connector.services.workmanager.WorkManagerService"}, {"methodBody": ["METHOD_START", "{", "return   distributedWorkManager ;", "}", "METHOD_END"], "methodName": ["getDistributedWorkManagerInjector"], "fileName": "org.jboss.as.connector.services.workmanager.statistics.DistributedWorkManagerStatisticsService"}, {"methodBody": ["METHOD_START", "{", "return   workManager ;", "}", "METHOD_END"], "methodName": ["getWorkManagerInjector"], "fileName": "org.jboss.as.connector.services.workmanager.statistics.WorkManagerStatisticsService"}, {"methodBody": ["METHOD_START", "{", "ExceptionSupplier < Map < Node ,    CommandResponse < Void >  >  ,    CommandDispatcherException >    task    =     (  )     -  >    this . dispatcher . executeOnCluster ( command )  ;", "try    {", "Map < Node ,    CommandResponse < Void >  >    responses    =    this . executor . execute ( task )  . orElse ( Collections . emptyMap (  )  )  ;", "for    ( Map . Entry < Node ,    CommandResponse < Void >  >    entry    :    responses . entrySet (  )  )     {", "entry . getValue (  )  . get (  )  ;", "}", "}    catch    ( CommandDispatcherException    |    ExecutionException   e )     {", "throw   new   WorkException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["broadcast"], "fileName": "org.jboss.as.connector.services.workmanager.transport.CommandDispatcherTransport"}, {"methodBody": ["METHOD_START", "{", "Address   address    =     (  ( parameters . length )     >     0  )     ?     (  ( Address )     ( parameters [  0  ]  )  )     :    null ;", "switch    ( request )     {", "case   CLEAR _ DISTRIBUTED _ STATISTICS    :", "{", "return   new   ClearDistributedStatistics ( address )  ;", "}", "case   DELTA _ DOWORK _ ACCEPTED    :", "{", "return   new   DeltaDoWorkAccepted ( address )  ;", "}", "case   DELTA _ DOWORK _ REJECTED    :", "{", "return   new   DeltaDoWorkRejected ( address )  ;", "}", "case   DELTA _ SCHEDULEWORK _ ACCEPTED    :", "{", "return   new   DeltaScheduleWorkAccepted ( address )  ;", "}", "case   DELTA _ SCHEDULEWORK _ REJECTED    :", "{", "return   new   DeltaScheduleWorkRejected ( address )  ;", "}", "case   DELTA _ STARTWORK _ ACCEPTED    :", "{", "return   new   DeltaStartWorkAccepted ( address )  ;", "}", "case   DELTA _ STARTWORK _ REJECTED    :", "{", "return   new   DeltaStartWorkRejected ( address )  ;", "}", "case   DELTA _ WORK _ FAILED    :", "{", "return   new   DeltaWorkFailed ( address )  ;", "}", "case   DELTA _ WORK _ SUCCESSFUL    :", "{", "return   new   DeltaWorkSuccessful ( address )  ;", "}", "case   DO _ WORK    :", "{", "return   new   DoWork ( address ,     (  ( DistributableWork )     ( parameters [  2  ]  )  )  )  ;", "}", "case   GET _ DISTRIBUTED _ STATISTICS    :", "{", "return   new   DistributedStatistics ( address )  ;", "}", "case   GET _ LONGRUNNING _ FREE    :", "{", "return   new   LongRunningFree ( address )  ;", "}", "case   GET _ SHORTRUNNING _ FREE    :", "{", "return   new   ShortRunningFree ( address )  ;", "}", "case   PING    :", "{", "return   new   Ping (  )  ;", "}", "case   SCHEDULE _ WORK    :", "{", "return   new   ScheduleWork ( address ,     (  ( DistributableWork )     ( parameters [  2  ]  )  )  )  ;", "}", "case   START _ WORK    :", "{", "return   new   StartWork ( address ,     (  ( DistributableWork )     ( parameters [  2  ]  )  )  )  ;", "}", "case   UPDATE _ LONGRUNNING _ FREE    :", "{", "return   new   UpdateLongRunningFree ( address ,     (  ( Long )     ( parameters [  1  ]  )  )  )  ;", "}", "case   UPDATE _ SHORTRUNNING _ FREE    :", "{", "return   new   UpdateShortRunningFree ( address ,     (  ( Long )     ( parameters [  1  ]  )  )  )  ;", "}", "case   WORKMANAGER _ ADD    :", "{", "return   new   AddWorkManager ( address ,     (  ( Node )     ( parameters [  1  ]  )  )  )  ;", "}", "case   WORKMANAGER _ REMOVE    :", "{", "return   new   RemoveWorkManager ( address )  ;", "}", "default    :", "{", "throw   new   IllegalStateException ( request . name (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createCommand"], "fileName": "org.jboss.as.connector.services.workmanager.transport.CommandDispatcherTransport"}, {"methodBody": ["METHOD_START", "{", "this . join ( this . dispatcherFactory . getGroup (  )  . getMembership (  )  )  ;", "}", "METHOD_END"], "methodName": ["join"], "fileName": "org.jboss.as.connector.services.workmanager.transport.CommandDispatcherTransport"}, {"methodBody": ["METHOD_START", "{", "Map < Node ,    Future < Set < Address >  >  >    futures    =    new   HashMap <  >  (  )  ;", "for    ( Node   member    :    membership . getMembers (  )  )     {", "if    (  (  !  ( this . getOwnAddress (  )  . equals ( member )  )  )     &  &     (  !  ( this . nodes . containsValue ( member )  )  )  )     {", "try    {", "futures . put ( member ,    this . dispatcher . submitOnNode ( new   GetWorkManagersCommand (  )  ,    member )  )  ;", "}    catch    ( Exception   e )     {", "ConnectorLogger . ROOT _ LOGGER . warn ( e . getLocalizedMessage (  )  ,    e )  ;", "}", "}", "}", "try    {", "for    ( Map . Entry < Node ,    Future < Set < Address >  >  >    entry    :    futures . entrySet (  )  )     {", "Node   member    =    entry . getKey (  )  ;", "try    {", "Set < Address >    addresses    =    entry . getValue (  )  . get (  )  ;", "for    ( Address   address    :    addresses )     {", "this . join ( address ,    member )  ;", "this . localUpdateLongRunningFree ( address ,    this . getShortRunningFree ( address )  )  ;", "this . localUpdateShortRunningFree ( address ,    this . getShortRunningFree ( address )  )  ;", "}", "}    catch    ( ExecutionException   e )     {", "ConnectorLogger . ROOT _ LOGGER . warn ( e . getLocalizedMessage (  )  ,    e )  ;", "}", "}", "}    catch    ( InterruptedException   e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "METHOD_END"], "methodName": ["join"], "fileName": "org.jboss.as.connector.services.workmanager.transport.CommandDispatcherTransport"}, {"methodBody": ["METHOD_START", "{", "if    ( context . isNormalServer (  )  )     {", "context . addStep ( new   OperationStepHandler (  )     {", "public   void   execute ( OperationContext   context ,    ModelNode   operation )    throws   OperationFailedException    {", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   String   jndiName    =    address . getLastElement (  )  . getValue (  )  ;", "final   String   attributeName    =    operation . require ( ModelDescriptionConstants . NAME )  . asString (  )  ;", "final   ServiceController <  ?  >    managementRepoService    =    context . getServiceRegistry ( false )  . getService ( CServices . MANAGEMENT _ REPOSITORY _ SERVICE )  ;", "if    ( managementRepoService    !  =    null )     {", "try    {", "final   ManagementRepository   repository    =     (  ( ManagementRepository )     ( managementRepoService . getValue (  )  )  )  ;", "final   ModelNode   result    =    context . getResult (  )  ;", "List < StatisticsPlugin >    stats    =    getMatchingStats ( jndiName ,    repository )  ;", "for    ( StatisticsPlugin   stat    :    stats )     {", "result . set (  (  \"  \"     +     ( stat . getValue ( attributeName )  )  )  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   OperationFailedException ( CLogger . ROOT _ LOGGER . failedToGetMetrics ( e . getLocalizedMessage (  )  )  )  ;", "}", "}", "}", "}  ,    RUNTIME )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.connector.subsystems.common.pool.PoolMetrics"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   String   jndiName ;", "ModelNode   model ;", "if    (  (  !  ( address . getElement (  0  )  . getKey (  )  . equals ( DEPLOYMENT )  )  )     &  &     (  ( model    =    context . readResource ( EMPTY _ ADDRESS ,    false )  . getModel (  )  )  . isDefined (  )  )  )     {", "jndiName    =    Util . getJndiName ( context ,    model )  ;", "if    ( isDisabledDatasource ( context ,    address ,    model )  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . datasourceIsDisabled ( jndiName )  ;", "}", "} else    {", "jndiName    =    address . getLastElement (  )  . getValue (  )  ;", "}", "final   Object [  ]    parameters    =    getParameters ( context ,    operation )  ;", "if    ( context . isNormalServer (  )  )     {", "context . addStep ( new   StepHandler (  )     {", "public   void   execute ( Context   context ,    ModelNode   operation )    throws   FailedException    {", "final   ServiceController <  ?  >    managementRepoService    =    context . getServiceRegistry ( disallowMonitor )  . getService ( ConnectorServices . MANAGEMENT _ REPOSITORY _ SERVICE )  ;", "if    ( managementRepoService    !  =    null )     {", "ModelNode   operationResult    =    null ;", "try    {", "final   ManagementRepository   repository    =     (  ( ManagementRepository )     ( managementRepoService . getValue (  )  )  )  ;", "final   List < Pool >    pools    =    matcher . match ( jndiName ,    repository )  ;", "if    ( pools . isEmpty (  )  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . failedToMatchPool ( jndiName )  ;", "}", "for    ( Pool   pool    :    pools )     {", "operationResult    =    invokeCommandOn ( pool ,    parameters )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   FailedException ( ConnectorLogger . ROOT _ LOGGER . failedToInvoke ( e . getLocalizedMessage (  )  )  )  ;", "}", "if    ( operationResult    !  =    null )     {", "context . getResult (  )  . set ( operationResult )  ;", "}", "}", "context . completeStep ( NOOP _ ROLLBACK _ HANDLER )  ;", "}", "}  ,    RUNTIME )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.connector.subsystems.common.pool.PoolOperations"}, {"methodBody": ["METHOD_START", "{", "return    ( address . getElement (  0  )  . getValue (  )  . equals ( Constants . DATASOURCES )  )     &  &     (  !  ( ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    datasourceNode ,    Constants . ENABLED )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDisabledDatasource"], "fileName": "org.jboss.as.connector.subsystems.common.pool.PoolOperations"}, {"methodBody": ["METHOD_START", "{", "return   getModel ( resourceFileName ,    true ,    null )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.AbstractComplexSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   xml    =    readResource ( resourceFileName )  ;", "KernelServices   services    =    createKernelServicesBuilder ( MANAGEMENT )  . setXml ( xml )  . build (  )  ;", "ModelNode   model    =    services . readWholeModel (  )  ;", "String   marshalled    =    services . getPersistedXml (  )  ;", "if    ( checkMarshalledXML )", "assertEquals ( normalizeXML ( xml )  ,    normalizeXML ( marshalled )  )  ;", "services    =    createKernelServicesBuilder ( MANAGEMENT )  . setXml ( marshalled )  . build (  )  ;", "ModelNode   modelReloaded    =    services . readWholeModel (  )  ;", "compare ( model ,    modelReloaded )  ;", "assertRemoveResources ( services )  ;", "return   model ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.AbstractComplexSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "return   getModel ( resourceFileName ,    true ,    archiveName )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.AbstractComplexSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    getModel (  \" datasource . xml \"  ,    false ,    null )  ;", "final   String   complexDs    =     \" complexDs \"  ;", "final   String   complexDsJndi    =     \" java : jboss / datasources /  \"     +    complexDs ;", "Properties   params    =    ParseUtils . nonXaDsProperties ( complexDsJndi )  ;", "ModelNode   modelDs    =    model . get (  \" subsystem \"  ,     \" datasources \"  ,     \" data - source \"  ,     ( complexDs    +     \"  _ Pool \"  )  )  ;", "ParseUtils . checkModelParams ( modelDs ,    params )  ;", "Assert . assertEquals ( modelDs . asString (  )  ,     \" UTF -  8  \"  ,    modelDs . get (  \" connection - properties \"  ,     \" char . encoding \"  ,     \" value \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelDs . asString (  )  ,     \" Property 2  \"  ,    modelDs . get (  \" valid - connection - checker - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelDs . asString (  )  ,     \" Property 4  \"  ,    modelDs . get (  \" exception - sorter - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelDs . asString (  )  ,     \" Property 3  \"  ,    modelDs . get (  \" stale - connection - checker - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelDs . asString (  )  ,     \" Property 1  \"  ,    modelDs . get (  \" reauth - plugin - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "final   String   complexXaDs    =     \" complexXaDs \"  ;", "final   String   complexXaDsJndi    =     \" java : jboss / xa - datasources /  \"     +    complexXaDs ;", "params    =    ParseUtils . xaDsProperties ( complexXaDsJndi )  ;", "ModelNode   modelXaDs    =    model . get (  \" subsystem \"  ,     \" datasources \"  ,     \" xa - data - source \"  ,     ( complexXaDs    +     \"  _ Pool \"  )  )  ;", "ParseUtils . checkModelParams ( modelXaDs ,    params )  ;", "Assert . assertEquals ( modelXaDs . asString (  )  ,     \" jdbc : h 2  : mem : test \"  ,    modelXaDs . get (  \" xa - datasource - properties \"  ,     \" URL \"  ,     \" value \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelXaDs . asString (  )  ,     \" Property 2  \"  ,    modelXaDs . get (  \" valid - connection - checker - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelXaDs . asString (  )  ,     \" Property 4  \"  ,    modelXaDs . get (  \" exception - sorter - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelXaDs . asString (  )  ,     \" Property 3  \"  ,    modelXaDs . get (  \" stale - connection - checker - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelXaDs . asString (  )  ,     \" Property 1  \"  ,    modelXaDs . get (  \" reauth - plugin - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelXaDs . asString (  )  ,     \" Property 5  \"  ,    modelXaDs . get (  \" recovery - plugin - properties \"  ,     \" name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( modelXaDs . asString (  )  ,     \" Property 6  \"  ,    modelXaDs . get (  \" recovery - plugin - properties \"  ,     \" name 1  \"  )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDatasource"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ComplexDatasourceSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    getModel (  \" datasource . xml \"  ,    false ,    null )  ;", "ModelNode   h 2 MainModuleDriver    =    model . get (  \" subsystem \"  ,     \" datasources \"  ,     \" jdbc - driver \"  ,     \" h 2  \"  )  ;", "ModelNode   h 2 TestModuleDriver    =    model . get (  \" subsystem \"  ,     \" datasources \"  ,     \" jdbc - driver \"  ,     \" h 2 test \"  )  ;", "Assert . assertEquals ( h 2 MainModuleDriver . asString (  )  ,     \" com . h 2 database . h 2  \"  ,    h 2 MainModuleDriver . get (  \" driver - module - name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( h 2 MainModuleDriver . asString (  )  ,     \" JdbcDataSource \"  ,    h 2 MainModuleDriver . get (  \" driver - xa - datasource - class - name \"  )  . asString (  )  )  ;", "Assert . assertFalse ( h 2 MainModuleDriver . get (  \" module - slot \"  )  . isDefined (  )  )  ;", "Assert . assertEquals ( h 2 TestModuleDriver . asString (  )  ,     \" com . h 2 database . h 2  \"  ,    h 2 TestModuleDriver . get (  \" driver - module - name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( h 2 TestModuleDriver . asString (  )  ,     \" JdbcDataSource \"  ,    h 2 TestModuleDriver . get (  \" driver - xa - datasource - class - name \"  )  . asString (  )  )  ;", "Assert . assertEquals ( h 2 TestModuleDriver . asString (  )  ,     \" test \"  ,    h 2 TestModuleDriver . get (  \" module - slot \"  )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJDBCDriver"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ComplexDatasourceSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "getModel (  \" minimal - jca . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMinModel"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ComplexJcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "getModel (  \" jca . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testModel"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ComplexJcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "getModel (  \" ra 2  . xml \"  ,    false ,     \" multiple . rar \"  )  ;", "}", "METHOD_END"], "methodName": ["testResourceAdapterWith2ConDefAnd2AdmObj"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ComplexResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    getModel (  \" ra . xml \"  ,     \" some . rar \"  )  ;", "if    ( model    =  =    null )", "return ;", "Properties   params    =    ParseUtils . raCommonProperties (  )  ;", "ModelNode   raCommonModel    =    model . get (  \"  \"  ,     \" resource - adapters \"  ,     \" resource - adapter \"  ,     \" myRA \"  )  ;", "ParseUtils . checkModelParams ( raCommonModel ,    params )  ;", "Assert . assertEquals ( raCommonModel . asString (  )  ,     \" A \"  ,    raCommonModel . get (  \" config - properties \"  ,     \" Property \"  ,     \" value \"  )  . asString (  )  )  ;", "Assert . assertEquals ( raCommonModel . get (  \" beanvalidationgroups \"  )  . asString (  )  ,    raCommonModel . get (  \" beanvalidationgroups \"  )  . asString (  )  ,     \"  [  \\  \" Class 0  \\  \"  ,  \\  \" Class 0  0  \\  \"  ]  \"  )  ;", "params    =    ParseUtils . raAdminProperties (  )  ;", "ModelNode   raAdminModel    =    raCommonModel . get (  \" admin - objects \"  ,     \" Pool 2  \"  )  ;", "ParseUtils . checkModelParams ( raAdminModel ,    params )  ;", "Assert . assertEquals ( raAdminModel . asString (  )  ,     \" D \"  ,    raAdminModel . get (  \" config - properties \"  ,     \" Property \"  ,     \" value \"  )  . asString (  )  )  ;", "params    =    ParseUtils . raConnectionProperties (  )  ;", "ModelNode   raConnModel    =    raCommonModel . get (  \" connection - definitions \"  ,     \" Pool 1  \"  )  ;", "ParseUtils . checkModelParams ( raConnModel ,    params )  ;", "Assert . assertEquals ( raConnModel . asString (  )  ,     \" B \"  ,    raConnModel . get (  \" config - properties \"  ,     \" Property \"  ,     \" value \"  )  . asString (  )  )  ;", "Assert . assertEquals ( raConnModel . asString (  )  ,     \" C \"  ,    raConnModel . get (  \" recovery - plugin - properties \"  ,     \" Property \"  )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceAdapters"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ComplexResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   str ;", "StringBuffer   sb    =    new   StringBuffer (  )  ;", "String   par ;", "String   child ;", "Enumeration <  ?  >    e    =    params . propertyNames (  )  ;", "while    ( e . hasMoreElements (  )  )     {", "str    =     (  ( String )     ( e . nextElement (  )  )  )  ;", "par    =    params . getProperty ( str )  ;", "if    (  ( node . get ( str )  )     =  =    null )     {", "sb . append (  (  (  (  (  \" Parameter    <  \"     +    str )     +     \"  >    is   not   set ,    but   must   be   set   to    '  \"  )     +    par )     +     \"  \\  '     \\ n \"  )  )  ;", "} else    {", "child    =    node . get ( str )  . asString (  )  ;", "if    (  !  ( child . equals ( par )  )  )     {", "sb . append (  (  (  (  (  (  (  \" Parameter    <  \"     +    str )     +     \"  >    is   set   to    '  \"  )     +    child )     +     \"  '  ,    but   must   be   set   to    '  \"  )     +    par )     +     \"  \\  '     \\ n \"  )  )  ;", "}", "}", "}", "if    (  ( sb . length (  )  )     >     0  )", "unit . Assert . fail (  (  (  (  \" There   are   parsing   errors :  \\ n \"     +     ( sb . toString (  )  )  )     +     \" Parsed   configuration :  \\ n \"  )     +    node )  )  ;", "}", "METHOD_END"], "methodName": ["checkModelParams"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   params    =    new   Properties (  )  ;", "params . put (  \" use - java - context \"  ,     \" true \"  )  ;", "params . put (  \" spy \"  ,     \" false \"  )  ;", "params . put (  \" use - ccm \"  ,     \" true \"  )  ;", "params . put (  \" jndi - name \"  ,    jndiName )  ;", "params . put (  \" driver - name \"  ,     \" h 2  \"  )  ;", "params . put (  \" new - ion - sql \"  ,     \" select    1  \"  )  ;", "params . put (  \" transaction - isolation \"  ,     \" TRANSACTION _ READ _ COMMITTED \"  )  ;", "params . put (  \" url - delimiter \"  ,     \"  :  \"  )  ;", "params . put (  \" url - selector - strategy - class - name \"  ,     \" someClass \"  )  ;", "params . put (  \" min - pool - size \"  ,     \"  1  \"  )  ;", "params . put (  \" max - pool - size \"  ,     \"  5  \"  )  ;", "params . put (  \" pool - prefill \"  ,     \" true \"  )  ;", "params . put (  \" pool - use - strict - min \"  ,     \" true \"  )  ;", "params . put (  \" flush - strategy \"  ,     \" EntirePool \"  )  ;", "params . put (  \" user - name \"  ,     \" sa \"  )  ;", "params . put (  \" password \"  ,     \" sa \"  )  ;", "params . put (  \" reauth - plugin - class - name \"  ,     \" someClass 1  \"  )  ;", "params . put (  \" valid - ion - checker - class - name \"  ,     \" someClass 2  \"  )  ;", "params . put (  \" check - valid - ion - sql \"  ,     \" select    1  \"  )  ;", "params . put (  \" validate - on - match \"  ,     \" true \"  )  ;", "params . put (  \" background - validation \"  ,     \" true \"  )  ;", "params . put (  \" background - validation - millis \"  ,     \"  2  0  0  0  \"  )  ;", "params . put (  \" use - fast - fail \"  ,     \" true \"  )  ;", "params . put (  \" stale - ion - checker - class - name \"  ,     \" someClass 3  \"  )  ;", "params . put (  \" exception - sorter - class - name \"  ,     \" someClass 4  \"  )  ;", "params . put (  \" blocking - timeout - wait - millis \"  ,     \"  2  0  0  0  0  \"  )  ;", "params . put (  \" idle - timeout - minutes \"  ,     \"  4  \"  )  ;", "params . put (  \" set - tx - query - timeout \"  ,     \" true \"  )  ;", "params . put (  \" query - timeout \"  ,     \"  1  2  0  \"  )  ;", "params . put (  \" use - try - lock \"  ,     \"  1  0  0  \"  )  ;", "params . put (  \" allocation - retry \"  ,     \"  2  \"  )  ;", "params . put (  \" allocation - retry - wait - millis \"  ,     \"  3  0  0  0  \"  )  ;", "params . put (  \" track - statements \"  ,     \" nowarn \"  )  ;", "params . put (  \" prepared - statements - cache - size \"  ,     \"  3  0  \"  )  ;", "params . put (  \" share - prepared - statements \"  ,     \" true \"  )  ;", "return   params ;", "}", "METHOD_END"], "methodName": ["commonDsProperties"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   params    =    ParseUtils . commonDsProperties ( jndiName )  ;", "params . put (  \" jta \"  ,     \" false \"  )  ;", "params . put (  \" driver - class \"  ,     \" jdbcDriver \"  )  ;", "params . put (  \" datasource - class \"  ,     \" datasources . ModifiableDataSource \"  )  ;", "params . put (  \" connection - url \"  ,     \" jdbc : h 2  : mem : test ; DB _ CLOSE _ DELAY =  -  1  \"  )  ;", "return   params ;", "}", "METHOD_END"], "methodName": ["nonXaDsProperties"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   params    =    new   Properties (  )  ;", "params . put (  \" use - java - context \"  ,     \" false \"  )  ;", "params . put (  \" class - name \"  ,     \" Class 3  \"  )  ;", "params . put (  \" jndi - name \"  ,     \" java :  / Name 3  \"  )  ;", "params . put (  \" enabled \"  ,     \" true \"  )  ;", "return   params ;", "}", "METHOD_END"], "methodName": ["raAdminProperties"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   para =    new   Properties (  )  ;", "paraput (  \" archive \"  ,     \" some . rar \"  )  ;", "paraput (  \" transaction - support \"  ,     \" XATransaction \"  )  ;", "paraput (  \" bootstrap - context \"  ,     \" someContext \"  )  ;", "return   para", "}", "METHOD_END"], "methodName": ["raCommonProperties"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   params    =    new   Properties (  )  ;", "params . put (  \" use - java - context \"  ,     \" false \"  )  ;", "params . put (  \" class - name \"  ,     \" Class 1  \"  )  ;", "params . put (  \" use - ccm \"  ,     \" true \"  )  ;", "params . put (  \" jndi - name \"  ,     \" java : jboss / name 1  \"  )  ;", "params . put (  \" enabled \"  ,     \" false \"  )  ;", "params . put (  \" min - pool - size \"  ,     \"  1  \"  )  ;", "params . put (  \" max - pool - size \"  ,     \"  5  \"  )  ;", "params . put (  \" pool - prefill \"  ,     \" true \"  )  ;", "params . put (  \" pool - use - strict - min \"  ,     \" true \"  )  ;", "params . put (  \" flush - strategy \"  ,     \" IdleCions \"  )  ;", "params . put (  \" same - rm - override \"  ,     \" true \"  )  ;", "params . put (  \" interleaving \"  ,     \" true \"  )  ;", "params . put (  \" no - tx - separate - pool \"  ,     \" true \"  )  ;", "params . put (  \" pad - xid \"  ,     \" true \"  )  ;", "params . put (  \" wrap - xa - resource \"  ,     \" true \"  )  ;", "params . put (  \" security - application \"  ,     \" true \"  )  ;", "params . put (  \" background - validation \"  ,     \" true \"  )  ;", "params . put (  \" background - validation - millis \"  ,     \"  5  0  0  0  \"  )  ;", "params . put (  \" use - fast - fail \"  ,     \" true \"  )  ;", "params . put (  \" blocking - timeout - wait - millis \"  ,     \"  5  0  0  0  \"  )  ;", "params . put (  \" idle - timeout - minutes \"  ,     \"  4  \"  )  ;", "params . put (  \" allocation - retry \"  ,     \"  2  \"  )  ;", "params . put (  \" allocation - retry - wait - millis \"  ,     \"  3  0  0  0  \"  )  ;", "params . put (  \" xa - resource - timeout \"  ,     \"  3  0  0  \"  )  ;", "params . put (  \" no - recovery \"  ,     \" false \"  )  ;", "params . put (  \" recovery - plugin - class - name \"  ,     \" someClass 2  \"  )  ;", "params . put (  \" recovery - username \"  ,     \" sa \"  )  ;", "params . put (  \" recovery - password \"  ,     \" sa - pass \"  )  ;", "return   params ;", "}", "METHOD_END"], "methodName": ["raConnectionProperties"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "String   str ;", "Enumeration <  ?  >    e    =    parapropertyNames (  )  ;", "while    ( e . hasMoreElements (  )  )     {", "str    =     (  ( String )     ( e . nextElement (  )  )  )  ;", "operation . get ( str )  . set ( paragetProperty ( str )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setOperationParams"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   params    =    ParseUtils . commonDsProperties ( jndiName )  ;", "params . put (  \" xa - datasource - class \"  ,     \" datasources . ModifiableXaDataSource \"  )  ;", "params . put (  \" same - rm - override \"  ,     \" true \"  )  ;", "params . put (  \" interleaving \"  ,     \" true \"  )  ;", "params . put (  \" no - tx - separate - pool \"  ,     \" true \"  )  ;", "params . put (  \" pad - xid \"  ,     \" true \"  )  ;", "params . put (  \" wrap - xa - resource \"  ,     \" true \"  )  ;", "params . put (  \" xa - resource - timeout \"  ,     \"  1  2  0  \"  )  ;", "params . put (  \" no - recovery \"  ,     \" false \"  )  ;", "params . put (  \" recovery - plugin - class - name \"  ,     \" someClass 5  \"  )  ;", "params . put (  \" recovery - username \"  ,     \" sa \"  )  ;", "params . put (  \" recovery - password \"  ,     \" sa \"  )  ;", "return   params ;", "}", "METHOD_END"], "methodName": ["xaDsProperties"], "fileName": "org.jboss.as.connector.subsystems.complextestcases.ParseUtils"}, {"methodBody": ["METHOD_START", "{", "final   String   jndiName    =    Constants . JNDI _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( jndiName )  ;", "final   boolean   jta    =    Constants . JTA . resolveModelAttribute ( context ,    operation )  . asBoolean (  )  ;", "final   String   dsName    =    context . getCurrentAddressValue (  )  ;", "@ SuppressWarnings (  \" unused \"  )", "final   boolean   statsEnabled    =    Constants . STATISTICS _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "ModelNode   node    =    Constants . DATASOURCE _ DRIVER . resolveModelAttribute ( context ,    model )  ;", "final   String   driverName    =    node . asString (  )  ;", "final   ServiceName   driverServiceName    =    JBOSS . append (  \" jdbc - driver \"  ,    driverName . replaceAll (  \"  \\  \\  .  \"  ,     \"  _  \"  )  )  ;", "ValueInjectionService < Driver >    driverDemanderService    =    new   ValueInjectionService < Driver >  (  )  ;", "final   ServiceName   driverDemanderServiceName    =    JBOSS . append (  \" driver - demander \"  )  . append ( jndiName )  ;", "final   ServiceBuilder <  ?  >    driverDemanderBuilder    =    serviceTarget . addService ( driverDemanderServiceName ,    driverDemanderService )  . addDependency ( driverServiceName ,    Driver . class ,    driverDemanderService . getInjector (  )  )  ;", "driverDemanderBuilder . setInitialMode ( ACTIVE )  ;", "AbstractDataSourceService   dataSourceService    =    createDataSourceService ( dsName ,    jndiName )  ;", "final   ManagementResourceRegistration   registration    =    context . getResourceRegistrationForUpdate (  )  ;", "final   ServiceName   dataSourceServiceNameAlias    =    AbstractDataSourceService . getServiceName ( bindInfo )  ;", "final   ServiceName   dataSourceServiceName    =    context . getCapabilityServiceName ( Capabilities . DATA _ SOURCE _ CAPABILITY _ NAME ,    dsName ,    DataSource . class )  ;", "final   ServiceBuilder <  ?  >    dataSourceServiceBuilder    =    Services . addServerExecutorDependency ( serviceTarget . addService ( dataSourceServiceName ,    dataSourceService )  ,    dataSourceService . getExecutorServiceInjector (  )  )  . addAliases ( dataSourceServiceNameAlias )  . addDependency ( ConnectorServices . MANAGEMENT _ REPOSITORY _ SERVICE ,    ManagementRepository . class ,    dataSourceService . getManagementRepositoryInjector (  )  )  . addDependency ( ConnectorServices . JDBC _ DRIVER _ REGISTRY _ SERVICE ,    DriverRegistry . class ,    dataSourceService . getDriverRegistryInjector (  )  )  . addDependency ( ConnectorServices . IDLE _ REMOVER _ SERVICE )  . addDependency ( ConnectorServices . CONNECTION _ VALIDATOR _ SERVICE )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    MetadataRepository . class ,    dataSourceService . getMdrInjector (  )  )  . addDependency ( SERVICE _ NAME )  ;", "if    ( jta )     {", "dataSourceServiceBuilder . addDependency ( ConnectorServices . TRANSACTION _ INTEGRATION _ SERVICE ,    TransactionIntegration . class ,    dataSourceService . getTransactionIntegrationInjector (  )  )  . addDependency ( ConnectorServices . CCM _ SERVICE ,    CachedConnectionManager . class ,    dataSourceService . getCcmInjector (  )  )  . addDependency ( ConnectorServices . BOOTSTRAP _ CONTEXT _ SERVICE . append ( jca . Constants . DEFAULT _ NAME )  )  . addDependency ( ConnectorServices . RA _ REPOSITORY _ SERVICE ,    ResourceAdapterRepository . class ,    dataSourceService . getRaRepositoryInjector (  )  )  ;", "} else    {", "dataSourceServiceBuilder . addDependency ( ConnectorServices . NON _ JTA _ DS _ RA _ REPOSITORY _ SERVICE ,    ResourceAdapterRepository . class ,    dataSourceService . getRaRepositoryInjector (  )  )  . addDependency ( ConnectorServices . NON _ TX _ CCM _ SERVICE ,    CachedConnectionManager . class ,    dataSourceService . getCcmInjector (  )  )  ;", "}", "if    ( registration . isAllowsOverride (  )  )     {", "registration . registerOverrideModel ( dsName ,    DataSourcesSubsystemProviders . OVERRIDE _ DS _ DESC )  ;", "}", "startConfigAndAddDependency ( dataSourceServiceBuilder ,    dataSourceService ,    dsName ,    serviceTarget ,    operation )  ;", "dataSourceServiceBuilder . addDependency ( driverServiceName ,    Driver . class ,    dataSourceService . getDriverInjector (  )  )  ;", "boolean   requireLegacySecurity    =    false ;", "if    ( Constants . ELYTRON _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )     {", "if    ( model . hasDefined ( Constants . AUTHENTICATION _ CONTEXT . getName (  )  )  )     {", "dataSourceServiceBuilder . addDependency ( context . getCapabilityServiceName ( Capabilities . AUTHENTICATION _ CONTEXT _ CAPABILITY ,    Constants . AUTHENTICATION _ CONTEXT . resolveModelAttribute ( context ,    model )  . asString (  )  ,    AuthenticationContext . class )  ,    AuthenticationContext . class ,    dataSourceService . getAuthenticationContext (  )  )  ;", "}", "} else    {", "String   secDomain    =    Constants . SECURITY _ DOMAIN . resolveModelAttribute ( context ,    model )  . asStringOrNull (  )  ;", "requireLegacySecurity    =     ( secDomain    !  =    null )     &  &     (  ( secDomain . length (  )  )     >     0  )  ;", "}", "if    ( isXa (  )  )     {", "if    ( Constants . RECOVERY _ ELYTRON _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )     {", "if    ( model . hasDefined ( Constants . RECOVERY _ AUTHENTICATION _ CONTEXT . getName (  )  )  )     {", "dataSourceServiceBuilder . addDependency ( context . getCapabilityServiceName ( Capabilities . AUTHENTICATION _ CONTEXT _ CAPABILITY ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT . resolveModelAttribute ( context ,    model )  . asString (  )  ,    AuthenticationContext . class )  ,    AuthenticationContext . class ,    dataSourceService . getRecoveryAuthenticationContext (  )  )  ;", "}", "} else", "if    (  ! requireLegacySecurity )     {", "String   secDomain    =    Constants . RECOVERY _ SECURITY _ DOMAIN . resolveModelAttribute ( context ,    model )  . asStringOrNull (  )  ;", "requireLegacySecurity    =     ( secDomain    !  =    null )     &  &     (  ( secDomain . length (  )  )     >     0  )  ;", "}", "}", "if    ( requireLegacySecurity )     {", "dataSourceServiceBuilder . addDependency ( SubjectFactoryService . SERVICE _ NAME ,    SubjectFactory . class ,    dataSourceService . getSubjectFactoryInjector (  )  )  . addDependency ( SimpleSecurityManagerService . SERVICE _ NAME ,    ServerSecurityManager . class ,    dataSourceService . getServerSecurityManager (  )  )  ;", "}", "ModelNode   credentialReference    =    Constants . CREDENTIAL _ REFERENCE . resolveModelAttribute ( context ,    model )  ;", "if    ( credentialReference . isDefined (  )  )     {", "dataSourceService . getCredentialSourceSupplierInjector (  )  . inject ( CredentialReference . getCredentialSourceSupplier ( context ,    Constants . CREDENTIAL _ REFERENCE ,    model ,    dataSourceServiceBuilder )  )  ;", "}", "ModelNode   recoveryCredentialReference    =    Constants . RECOVERY _ CREDENTIAL _ REFERENCE . resolveModelAttribute ( context ,    model )  ;", "if    ( recoveryCredentialReference . isDefined (  )  )     {", "dataSourceService . getRecoveryCredentialSourceSupplierInjector (  )  . inject ( CredentialReference . getCredentialSourceSupplier ( context ,    Constants . RECOVERY _ CREDENTIAL _ REFERENCE ,    model ,    dataSourceServiceBuilder )  )  ;", "}", "dataSourceServiceBuilder . setInitialMode ( NEVER )  ;", "dataSourceServiceBuilder . install (  )  ;", "driverDemanderBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["firstRuntimeStep"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceAdd"}, {"methodBody": ["METHOD_START", "{", "final   List < AttributeDefinition >    result    =    new   ArrayList <  >  (  )  ;", "result . addAll ( ArrayList ( a )  )  ;", "result . addAll ( ArrayList ( b )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["join"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceAdd"}, {"methodBody": ["METHOD_START", "{", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   ModelNode   address    =    operation . require ( ModelDescriptionConstants . OP _ ADDR )  ;", "final   String   dsName    =    PathAddress . pathAddress ( address )  . getLastElement (  )  . getValue (  )  ;", "final   String   jndiName    =    Constants . JNDI _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "final   List < ServiceName >    serviceNames    =    registry . getServiceNames (  )  ;", "final   boolean   elytronEnabled    =    Constants . ELYTRON _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "final   ServiceName   dataSourceServiceName    =    context . getCapabilityServiceName ( Capabilities . DATA _ SOURCE _ CAPABILITY _ NAME ,    dsName ,    DataSource . class )  ;", "final   ServiceController <  ?  >    dataSourceController    =    registry . getService ( dataSourceServiceName )  ;", "final   ExceptionSupplier < CredentialSource ,    Exception >    credentialSourceExceptionExceptionSupplier    =     (  ( dataSourceController . getService (  )  )    instanceof   Service )     ?     (  ( Service )     ( dataSourceController . getService (  )  )  )  . getCredentialSourceSupplierInjector (  )  . getOptionalValue (  )     :    null ;", "final   ExceptionSupplier < CredentialSource ,    Exception >    recoveryCredentialSourceExceptionExceptionSupplier    =     (  ( dataSourceController . getService (  )  )    instanceof   Service )     ?     (  ( Service )     ( dataSourceController . getService (  )  )  )  . getRecoveryCredentialSourceSupplierInjector (  )  . getOptionalValue (  )     :    null ;", "final   boolean   jta ;", "if    ( isXa )     {", "jta    =    true ;", "final   ModifiableXaDataSource   dataSourceConfig ;", "try    {", "dataSourceConfig    =    DataSourceModelNodeUtil . xaFrom ( context ,    model ,    dsName ,    credentialSourceExceptionExceptionSupplier ,    recoveryCredentialSourceExceptionExceptionSupplier )  ;", "}    catch    ( ValidateException   e )     {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . failedToCreate (  \" XaDataSource \"  ,    operation ,    e . getLocalizedMessage (  )  )  )  ;", "}", "final   ServiceName   xaDataSourceConfigServiceName    =    XADataSourceConfigService . SERVICE _ NAME _ BASE . append ( dsName )  ;", "final   XADataSourceConfigService   xaDataSourceConfigService    =    new   XADataSourceConfigService ( dataSourceConfig )  ;", "final   ServiceBuilder <  ?  >    builder    =    serviceTarget . addService ( xaDataSourceConfigServiceName ,    xaDataSourceConfigService )  ;", "final   DsSecurity   dsSecurityConfig    =    dataSourceConfig . getSecurity (  )  ;", "if    ( dsSecurityConfig    !  =    null )     {", "final   String   securityDomainName    =    dsSecurityConfig . getSecurityDomain (  )  ;", "if    (  (  ! elytronEnabled )     &  &     ( securityDomainName    !  =    null )  )     {", "builder . addDependency ( SERVICE _ NAME . append ( securityDomainName )  )  ;", "}", "}", "if    (  ( dataSourceConfig . getRecovery (  )  )     !  =    null )     {", "final   Credential   credential    =    dataSourceConfig . getRecovery (  )  . getCredential (  )  ;", "if    ( credential    !  =    null )     {", "final   String   securityDomainName    =    credential . getSecurityDomain (  )  ;", "if    (  (  !  ( Constants . RECOVERY _ ELYTRON _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  )     &  &     ( securityDomainName    !  =    null )  )     {", "builder . addDependency ( SERVICE _ NAME . append ( securityDomainName )  )  ;", "}", "}", "}", "int   propertiesCount    =     0  ;", "for    ( ServiceName   name    :    serviceNames )     {", "if    ( xaDataSourceConfigServiceName . append (  \" xa - datasource - properties \"  )  . isParentOf ( name )  )     {", "final   ServiceController <  ?  >    xaConfigPropertyController    =    registry . getService ( name )  ;", "XaDataSourcePropertiesService   xaPropService    =     (  ( XaDataSourcePropertiesService )     ( xaConfigPropertyController . getService (  )  )  )  ;", "if    (  !  ( UP . equals ( xaConfigPropertyController . getState (  )  )  )  )     {", "propertiesCount +  +  ;", "xaConfigPropertyController . setMode ( ACTIVE )  ;", "builder . addDependency ( name ,    String . class ,    xaDataSourceConfigService . getXaDataSourcePropertyInjector ( xaPropService . getName (  )  )  )  ;", "} else    {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . serviceAlreadyStarted (  \" Data - source . xa - config - property \"  ,    name )  )  ;", "}", "}", "}", "if    ( propertiesCount    =  =     0  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . xaDataSourcePropertiesNotPresent (  )  ;", "}", "builder . install (  )  ;", "} else    {", "final   ModifiableDataSource   dataSourceConfig ;", "try    {", "dataSourceConfig    =    DataSourceModelNodeUtil . from ( context ,    model ,    dsName ,    credentialSourceExceptionExceptionSupplier )  ;", "}    catch    ( ValidateException   e )     {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . failedToCreate (  \" DataSource \"  ,    operation ,    e . getLocalizedMessage (  )  )  )  ;", "}", "jta    =    dataSourceConfig . isJTA (  )  ;", "final   ServiceName   dataSourceCongServiceName    =    DataSourceConfigService . SERVICE _ NAME _ BASE . append ( dsName )  ;", "final   DataSourceConfigService   configService    =    new   DataSourceConfigService ( dataSourceConfig )  ;", "final   ServiceBuilder <  ?  >    builder    =    serviceTarget . addService ( dataSourceCongServiceName ,    configService )  ;", "final   DsSecurity   dsSecurityConfig    =    dataSourceConfig . getSecurity (  )  ;", "if    ( dsSecurityConfig    !  =    null )     {", "final   String   securityDomainName    =    dsSecurityConfig . getSecurityDomain (  )  ;", "if    (  (  ! elytronEnabled )     &  &     ( securityDomainName    !  =    null )  )     {", "builder . addDependency ( SERVICE _ NAME . append ( securityDomainName )  )  ;", "}", "}", "for    ( ServiceName   name    :    serviceNames )     {", "if    ( dataSourceCongServiceName . append (  \" connection - properties \"  )  . isParentOf ( name )  )     {", "final   ServiceController <  ?  >    connPropServiceController    =    registry . getService ( name )  ;", "ConnectionPropertiesService   connPropService    =     (  ( ConnectionPropertiesService )     ( connPropServiceController . getService (  )  )  )  ;", "if    (  !  ( UP . equals ( connPropServiceController . getState (  )  )  )  )     {", "connPropServiceController . setMode ( ACTIVE )  ;", "builder . addDependency ( name ,    String . class ,    configService . getConnectionPropertyInjector ( connPropService . getName (  )  )  )  ;", "} else    {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . serviceAlreadyStarted (  \" Data - source . connectionProperty \"  ,    name )  )  ;", "}", "}", "}", "builder . install (  )  ;", "}", "final   ServiceName   dataSourceServiceNameAlias    =    Service . SERVICE _ NAME _ BASE . append ( jndiName )  . append ( Constants . STATISTICS )  ;", "if    ( dataSourceController    !  =    null )     {", "if    (  !  ( UP . equals ( dataSourceController . getState (  )  )  )  )     {", "final   boolean   statsEnabled    =    Constants . STATISTICS _ ENABLED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  ;", "DataSourceStatisticsService   statsService    =    new   DataSourceStatisticsService ( datasourceRegistration ,    statsEnabled )  ;", "serviceTarget . addService ( dataSourceServiceName . append ( Constants . STATISTICS )  ,    statsService )  . addAliases ( dataSourceServiceNameAlias )  . addDependency ( dataSourceServiceName )  . addDependency ( CommonDeploymentService . getServiceName ( ContextNames . bindInfoFor ( jndiName )  )  ,    CommonDeployment . class ,    statsService . getCommonDeploymentInjector (  )  )  . setInitialMode ( PASSIVE )  . install (  )  ;", "dataSourceController . setMode ( ACTIVE )  ;", "} else    {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . serviceAlreadyStarted (  \" Data - source \"  ,    dsName )  )  ;", "}", "} else    {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . serviceNotAvailable (  \" Data - source \"  ,    dsName )  )  ;", "}", "final   DataSourceReferenceFactoryService   referenceFactoryService    =    new   DataSourceReferenceFactoryService (  )  ;", "final   ServiceName   referenceFactoryServiceName    =    DataSourceReferenceFactoryService . SERVICE _ NAME _ BASE . append ( dsName )  ;", "final   ServiceBuilder <  ?  >    referenceBuilder    =    serviceTarget . addService ( referenceFactoryServiceName ,    referenceFactoryService )  . addDependency ( dataSourceServiceName ,    DataSource . class ,    referenceFactoryService . getDataSourceInjector (  )  )  ;", "referenceBuilder . install (  )  ;", "final   ContextNames . BindInfo   bindInfo    =    ContextNames . bindInfoFor ( jndiName )  ;", "final   BinderService   binderService    =    new   BinderService ( bindInfo . getBindName (  )  )  ;", "final   ServiceBuilder <  ?  >    binderBuilder    =    serviceTarget . addService ( bindInfo . getBinderServiceName (  )  ,    binderService )  . addDependency ( referenceFactoryServiceName ,    ManagedReferenceFactory . class ,    binderService . getManagedObjectInjector (  )  )  . addDependency ( bindInfo . getParentContextServiceName (  )  ,    ServiceBasedNamingStore . class ,    binderService . getNamingStoreInjector (  )  )  . addListener ( new   AbstractServiceListener < Object >  (  )     {", "public   void   transition ( final   ServiceController <  ?    extends   Object >    controller ,    final   ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STARTING _ to _ UP    :", "{", "if    ( jta )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . boundDataSource ( jndiName )  ;", "} else    {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . boundNonJTADataSource ( jndiName )  ;", "}", "break ;", "}", "case   STOPPING _ to _ DOWN    :", "{", "if    ( jta )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . unboundDataSource ( jndiName )  ;", "} else    {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . unBoundNonJTADataSource ( jndiName )  ;", "}", "break ;", "}", "case   REMOVING _ to _ REMOVED    :", "{", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . debugf (  \" Removed   JDBC   Data - source    [  % s ]  \"  ,    jndiName )  ;", "break ;", "}", "}", "}", "}  )  ;", "binderBuilder . setInitialMode ( ACTIVE )  ;", "binderBuilder . install (  )  ;", "}", "METHOD_END"], "methodName": ["secondRuntimeStep"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceAdd"}, {"methodBody": ["METHOD_START", "{", "final   StringBuffer   valueBuf    =    new   StringBuffer (  )  ;", "for    ( Map . Entry < String ,    String >    Property    :    configProps . entrySet (  )  )     {", "valueBuf . append ( Property . getKey (  )  )  ;", "valueBuf . append (  \"  =  \"  )  ;", "valueBuf . append ( Property . getValue (  )  )  ;", "valueBuf . append (  \"  ;  \"  )  ;", "}", "return   valueBuf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildConfigPropsString"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( classLoader )     !  =    null )     {", "return   classLoader ;", "}", "final   Class <  ?    extends   Driver >    clazz    =    driverValue . getValue (  )  . getClass (  )  ;", "return    !  ( WildFlySecurityManager . isChecking (  )  )     ?    clazz . getClassLoader (  )     :    AcsController . doPrivileged ( new   GetClassLoaderAction ( clazz )  )  ;", "}", "METHOD_END"], "methodName": ["driverClassLoader"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   authenticationContext ;", "}", "METHOD_END"], "methodName": ["getAuthenticationContext"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   ccmValue ;", "}", "METHOD_END"], "methodName": ["getCcmInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   credentialSourceSupplier ;", "}", "METHOD_END"], "methodName": ["getCredentialSourceSupplierInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   deploymentMD ;", "}", "METHOD_END"], "methodName": ["getDeploymentMD"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   driverValue ;", "}", "METHOD_END"], "methodName": ["getDriverInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   driverRegistry ;", "}", "METHOD_END"], "methodName": ["getDriverRegistryInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   executor ;", "}", "METHOD_END"], "methodName": ["getExecutorServiceInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   managementRepositoryValue ;", "}", "METHOD_END"], "methodName": ["getManagementRepositoryInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   mdr ;", "}", "METHOD_END"], "methodName": ["getMdrInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   raRepository ;", "}", "METHOD_END"], "methodName": ["getRaRepositoryInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   recoveryAuthenticationContext ;", "}", "METHOD_END"], "methodName": ["getRecoveryAuthenticationContext"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   recoveryCredentialSourceSupplier ;", "}", "METHOD_END"], "methodName": ["getRecoveryCredentialSourceSupplierInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   secManager ;", "}", "METHOD_END"], "methodName": ["getServerSecurityManager"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   AbstractDataSourceService . SERVICE _ NAME _ BASE . append ( bindInfo . getBinderServiceName (  )  . getCanonicalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   subjectFactory ;", "}", "METHOD_END"], "methodName": ["getSubjectFactoryInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( WildFlySecurityManager . isChecking (  )  )  )     {", "Thread . currentThread (  )  . setContextClaoader ( TransactionIntegration . clagetClaoader (  )  )  ;", "} else    {", "Acceontroller . doPrivileged ( new   SetContextClaoaderFromClaction ( TransactionIntegration . cla )  ;", "}", "try    {", "return   transactionIntegrationValue . getValue (  )  ;", "}    finally    {", "Acceontroller . doPrivileged ( ClearContextClaoaderAction . getInstance (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getTransactionIntegration"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   transactionIntegrationValue ;", "}", "METHOD_END"], "methodName": ["getTransactionIntegrationInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   sqlDataSource ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   ServiceContainer   container    =    startContext . getController (  )  . getServiceContainer (  )  ;", "deploymentMD    =    getDeployer (  )  . deploy ( container )  ;", "if    (  ( deploymentMD . getCfs (  )  . length )     !  =     1  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . cannotStartDs (  )  ;", "}", "sqlDataSource    =    new   WildFlyDataSource (  (  ( DataSource )     ( deploymentMD . getCfs (  )  [  0  ]  )  )  ,    jndiName . getAbsoluteJndiName (  )  )  ;", "ConnectorLogger . DS _ DEPLOYER _ LOGGER . debugf (  \" Adding   datasource :     % s \"  ,    deploymentMD . getCfJndiNames (  )  [  0  ]  )  ;", "CommonDeploymentService   cdService    =    new   CommonDeploymentService ( deploymentMD )  ;", "final   ServiceName   cdServiceName    =    CommonDeploymentService . getServiceName ( jndiName )  ;", "startContext . getController (  )  . getServiceContainer (  )  . addService ( cdServiceName ,    cdService )  . addDependency (  . getServiceName ( jndiName )  )  . setInitialMode ( ACTIVE )  . install (  )  ;", "}    catch    ( Throwable   t )     {", "throw   ConnectorLogger . ROOT _ LOGGER . deploymentError ( t ,    dsName )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "final   ServiceController <  ?  >    serviceController    =    stopContext . getController (  )  . getServiceContainer (  )  . getService ( CommonDeploymentService . getServiceName ( jndiName )  )  ;", "if    ( serviceController    !  =    null )     {", "serviceController . setMode ( REMOVE )  ;", "}", "ExecutorService   executorService    =    executor . getValue (  )  ;", "Runnable   r    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "stopService (  )  ;", "}    finally    {", "stopContext . complete (  )  ;", "}", "}", "}  ;", "try    {", "executorService . execute ( r )  ;", "}    catch    ( RejectedExecutionException   e )     {", "r . run (  )  ;", "}    finally    {", "stopContext . asynchronous (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( deploymentMD )     !  =    null )     {", "if    (  ( deploymentMD . getResourceAdapterKey (  )  )     !  =    null )     {", "try    {", "raRepository . getValue (  )  . unregisterResourceAdapter ( deploymentMD . getResourceAdapterKey (  )  )  ;", "}    catch    ( jca   nfe )     {", "ConnectorLogger . ROOT _ LOGGER . exceptionDuringUnregistering ( nfe )  ;", "}", "}", "if    (  ( deploymentMD . getResourceAdapter (  )  )     !  =    null )     {", "deploymentMD . getResourceAdapter (  )  . stop (  )  ;", "if    (  (  ( BootstrapContextCoordinator . getInstance (  )  )     !  =    null )     &  &     (  ( deploymentMD . getBootstrapContextIdentifier (  )  )     !  =    null )  )     {", "BootstrapContextCoordinator . getInstance (  )  . removeBootstrapContext ( deploymentMD . getBootstrapContextIdentifier (  )  )  ;", "}", "}", "if    (  (  ( deploymentMD . ges (  )  )     !  =    null )     &  &     (  ( managementRepositoryValue . getValue (  )  )     !  =    null )  )     {", "for    ( DataSource   mgtDs    :    deploymentMD . ges (  )  )     {", "managementRepositoryValue . getValue (  )  . ges (  )  . remove ( mgtDs )  ;", "}", "}", "if    (  ( deploymentMD . getConnectionManagers (  )  )     !  =    null )     {", "for    ( ConnectionManager   cm    :    deploymentMD . getConnectionManagers (  )  )     {", "cm . shutdown (  )  ;", "}", "}", "}", "sqlDataSource    =    null ;", "}", "METHOD_END"], "methodName": ["stopService"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractDataSourceService"}, {"methodBody": ["METHOD_START", "{", "final   List < PathElement >    relativeAddress    =    new   ArrayList < PathElement >  (  )  ;", "for    ( int   i    =     ( operationAddress . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "PathElement   pe    =    operationAddress . getElement ( i )  ;", "relativeAddress . add (  0  ,    pe )  ;", "if    ( DEPLOYMENT . equals ( pe . getKey (  )  )  )     {", "break ;", "}", "}", "final   PathAddress   pa    =    PathAddress . pathAddress ( relativeAddress )  ;", "final   T   config ;", "if    (  ( operationAddress . getLastElement (  )  . getKey (  )  . equals (  . CONNECTION _ PROPERTIES )  )     |  |     ( operationAddress . getLastElement (  )  . getKey (  )  . equals (  . XA _ DATASOURCE _ PROPERTIES )  )  )     {", "config    =    dataSourceConfigs . get ( pa . subAddress (  0  ,     (  ( pa . size (  )  )     -     1  )  )  )  ;", "} else    {", "config    =    dataSourceConfigs . get ( pa )  ;", "}", "if    ( config    =  =    null )     {", "String   exceptionMessage    =    ConnectorLogger . ROOT _ LOGGER . noDataSourceRegisteredForAddress ( operationAddress )  ;", "throw   new   OperationFailedException ( exceptionMessage )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["getDataSourceConfig"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "dataSourceConfigs . put ( address ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["registerDataSource"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "text . getResult (  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setBooleanIfNotNull"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "text . getResult (  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setIntIfNotNull"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "text . getResult (  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setLongIfNotNull"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "text . getResult (  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setStringIfNotNull"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "throw   ConnectorLogger . ROOT _ LOGGER . unknownOperation ( opName )  ;", "}", "METHOD_END"], "methodName": ["unknownOperation"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "dataSourceConfigs . remove ( address )  ;", "}", "METHOD_END"], "methodName": ["unregisterDataSource"], "fileName": "org.jboss.as.connector.subsystems.datasources.AbstractXMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.connector.subsystems.datasources.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.connector.subsystems.datasources.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   CommonDeploymentService . SERVICE _ NAME _ BASE . append ( bindInfo . getBinderServiceName (  )  . getCanonicalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.jboss.as.connector.subsystems.datasources.CommonDeploymentService"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.connector.subsystems.datasources.ConnectionPropertiesService"}, {"methodBody": ["METHOD_START", "{", "parentBuilder . addChildResource ( ConnectionPropertyDefinition . PATH _ CONNECTION _ PROPERTY )  . getAttributeBuilder (  )  . addRejectCheck ( UNDEFINED ,    Constants . CONNECTION _ PROPERTY _ VALUE )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers11x"], "fileName": "org.jboss.as.connector.subsystems.datasources.ConnectionPropertyDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   LocalDataSourceService ( dsName ,    ContextNames . bindInfoFor ( jndiName )  )  ;", "}", "METHOD_END"], "methodName": ["createDataSourceService"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceAdd"}, {"methodBody": ["METHOD_START", "{", "return   new   ConcurrentMapInjector ( connectionProperties ,    key )  ;", "}", "METHOD_END"], "methodName": ["getConnectionPropertyInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceConfigService"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    String >    connectionProperty    :    connectionProperties . entrySet (  )  )     {", "d . addConnectionProperty ( connectionProperty . getKey (  )  ,    connectionProperty . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceConfigService"}, {"methodBody": ["METHOD_START", "{", "return   new   RejectAttributeChecker . DefaultRejectAttributeChecker (  )     {", "@ Override", "public   String   getRejectionLogMessage ( Map < String ,    ModelNode >    attributes )     {", "return   UNDEFINED . getRejectionLogMessage ( attributes )  ;", "}", "@ Override", "public   boolean   rejectOperationParameter ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    ModelNode   operation ,    TransformationContext   context )     {", "return    ( operation . get ( OP )  . asString (  )  . equals ( ADD )  )     &  &     (  !  ( attributeValue . ised (  )  )  )  ;", "}", "@ Override", "protected   boolean   rejectAttribute ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    TransformationContext   context )     {", "return    !  ( attributeValue . ised (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createConnURLRejectChecker"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSourceDefinition ( registerRuntimeOnly ,    deployed )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceDefinition"}, {"methodBody": ["METHOD_START", "{", "ConnectorLogger . ROOT _ LOGGER . legacyDisableEnableOperation ( operation . get ( ModelDescriptionConstants . OP )  . asString (  )  )  ;", "ModelNode   writeAttributeOp    =    getWriteAttributeOperation ( context . getCurrentAddress (  )  ,    Constants . ENABLED . getName (  )  ,    enabled )  ;", "OperationStepHandler   writeHandler    =    context . getResourceRegistration (  )  . getOperationHandler ( EMPTY _ ADDRESS ,    ModelDescriptionConstants . WRITE _ ATTRIBUTE _ OPERATION )  ;", "context . addStep ( writeAttributeOp ,    writeHandler ,    MODEL ,    true )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceEnableDisable"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    String >    connectionProperties    =    Collections . emptyMap (  )  ;", "final   String   connectionUrl    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . CONNECTION _ URL )  ;", "final   String   driverClass    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . DRIVER _ CLASS )  ;", "final   String   dataSourceClass    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . DATASOURCE _ CLASS )  ;", "final   String   jndiName    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . JNDI _ NAME )  ;", "final   String   driver    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . DATASOURCE _ DRIVER )  ;", "final   String   newConnectionSql    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . NEW _ CONNECTION _ SQL )  ;", "final   String   poolName    =    dsName ;", "final   String   urlDelimiter    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . URL _ DELIMITER )  ;", "final   String   urlSelectorStrategyClassName    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME )  ;", "final   boolean   useJavaContext    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USE _ JAVA _ CONTEXT )  ;", "final   boolean   enabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ENABLED )  ;", "final   boolean   connectable    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . CONNECTABLE )  ;", "final   Boolean   tracking    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . TRACKING )  ;", "final   Boolean   enlistmentTrace    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ENLISTMENT _ TRACE )  ;", "final   String   mcp    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . MCP )  ;", "final   boolean   jta    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . JTA )  ;", "final   Integer   maxPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . MAX _ POOL _ SIZE )  ;", "final   Integer   minPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . MIN _ POOL _ SIZE )  ;", "final   Integer   initialPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . INITIAL _ POOL _ SIZE )  ;", "final   boolean   prefill    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ PREFILL )  ;", "final   boolean   fair    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ FAIR )  ;", "final   boolean   useStrictMin    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ USE _ STRICT _ MIN )  ;", "final   String   flushStrategyString    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ FLUSH _ STRATEGY )  ;", "final   FlushStrategy   flushStrategy    =    FlushStrategy . forName ( flushStrategyString )  ;", "final   Boolean   allowMultipleUsers    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ALLOW _ MULTIPLE _ USERS )  ;", "Extension   incrementer    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS ,    common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES )  ;", "Extension   decrementer    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS ,    common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES )  ;", "final   Capacity   capacity    =    new   Capacity ( incrementer ,    decrementer )  ;", "final   Extension   connectionListener    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . CONNECTION _ LISTENER _ CLASS ,    Constants . CONNECTION _ LISTENER _ PROPERTIES )  ;", "final   DsPool   pool    =    new   DsPoolImpl ( minPoolSize ,    initialPoolSize ,    maxPoolSize ,    prefill ,    useStrictMin ,    flushStrategy ,    allowMultipleUsers ,    capacity ,    fair ,    connectionListener )  ;", "final   String   username    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USERNAME )  ;", "final   String   password    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . PASSWORD )  ;", "final   String   securityDomain    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SECURITY _ DOMAIN )  ;", "final   boolean   elytronEnabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ELYTRON _ ENABLED )  ;", "final   String   authenticationContext    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . AUTHENTICATION _ CONTEXT )  ;", "final   Extension   reauthPlugin    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . REAUTH _ PLUGIN _ CLASSNAME ,    Constants . REAUTHPLUGIN _ PROPERTIES )  ;", "final   DsSecurity   security    =    new   DsSecurityImpl ( username ,    password ,     ( elytronEnabled    ?    authenticationContext    :    securityDomain )  ,    elytronEnabled ,    credentialSourceSupplier ,    reauthPlugin )  ;", "final   boolean   sharePreparedStatements    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SHARE _ PREPARED _ STATEMENTS )  ;", "final   Long   preparedStatementsCacheSize    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . PREPARED _ STATEMENTS _ CACHE _ SIZE )  ;", "final   String   trackStatementsString    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . TRACK _ STATEMENTS )  ;", "final   Statement . TrackStatementsEnum   trackStatements    =    TrackStatementsEnum . valueOf ( trackStatementsString . toUpperCase ( Locale . ENGLISH )  )  ;", "final   Statement   statement    =    new   StatementImpl ( sharePreparedStatements ,    preparedStatementsCacheSize ,    trackStatements )  ;", "final   Integer   allocationRetry    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ALLOCATION _ RETRY )  ;", "final   Long   allocationRetryWaitMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS )  ;", "final   Long   blockingTimeoutMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS )  ;", "final   Long   idleTimeoutMinutes    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . IDLETIMEOUTMINUTES )  ;", "final   Long   queryTimeout    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . QUERY _ TIMEOUT )  ;", "final   Integer   xaResourceTimeout    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . XA _ RESOURCE _ TIMEOUT )  ;", "final   Long   useTryLock    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USE _ TRY _ LOCK )  ;", "final   boolean   setTxQueryTimeout    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SET _ TX _ QUERY _ TIMEOUT )  ;", "final   TimeOut   timeOut    =    new   TimeOutImpl ( blockingTimeoutMillis ,    idleTimeoutMinutes ,    allocationRetry ,    allocationRetryWaitMillis ,    xaResourceTimeout ,    setTxQueryTimeout ,    queryTimeout ,    useTryLock )  ;", "final   String   transactionIsolationString    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . TRANSACTION _ ISOLATION )  ;", "TransactionIsolation   transactionIsolation    =    null ;", "if    ( transactionIsolationString    !  =    null )     {", "transactionIsolation    =    TransactionIsolation . forName ( transactionIsolationString )  ;", "if    ( transactionIsolation    =  =    null )     {", "transactionIsolation    =    TransactionIsolation . customLevel ( transactionIsolationString )  ;", "}", "}", "final   String   checkValidConnectionSql    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . CHECK _ VALID _ CONNECTION _ SQL )  ;", "final   Extension   exceptionSorter    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . EXCEPTION _ SORTER _ CLASSNAME ,    Constants . EXCEPTION _ SORTER _ PROPERTIES )  ;", "final   Extension   staleConnectionChecker    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . STALE _ CONNECTION _ CHECKER _ CLASSNAME ,    Constants . STALE _ CONNECTION _ CHECKER _ PROPERTIES )  ;", "final   Extension   validConnectionChecker    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . VALID _ CONNECTION _ CHECKER _ CLASSNAME ,    Constants . VALID _ CONNECTION _ CHECKER _ PROPERTIES )  ;", "Long   backgroundValidationMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . BACKGROUNDVALIDATIONMILLIS )  ;", "final   Boolean   backgroundValidation    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . BACKGROUNDVALIDATION )  ;", "boolean   useFastFail    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . USE _ FAST _ FAIL )  ;", "final   Boolean   validateOnMatch    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . VALIDATE _ ON _ MATCH )  ;", "final   boolean   spy    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SPY )  ;", "final   boolean   useCcm    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USE _ CCM )  ;", "final   Validation   validation    =    new   ValidationImpl ( backgroundValidation ,    backgroundValidationMillis ,    useFastFail ,    validConnectionChecker ,    checkValidConnectionSql ,    validateOnMatch ,    staleConnectionChecker ,    exceptionSorter )  ;", "return   new   ModifiableDataSource ( connectionUrl ,    driverClass ,    dataSourceClass ,    driver ,    transactionIsolation ,    connectionProperties ,    timeOut ,    security ,    statement ,    validation ,    urlDelimiter ,    urlSelectorStrategyClassName ,    newConnectionSql ,    useJavaContext ,    poolName ,    enabled ,    jndiName ,    spy ,    useCcm ,    jta ,    connectable ,    tracking ,    mcp ,    enlistmentTrace ,    pool )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    String >    xaDataSourceProperty ;", "xaDataSourceProperty    =    Collections . emptyMap (  )  ;", "final   String   xaDataSourceClass    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . XA _ DATASOURCE _ CLASS )  ;", "final   String   jndiName    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . JNDI _ NAME )  ;", "final   String   module    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . DATASOURCE _ DRIVER )  ;", "final   String   newConnectionSql    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . NEW _ CONNECTION _ SQL )  ;", "final   String   poolName    =    dsName ;", "final   String   urlDelimiter    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . URL _ DELIMITER )  ;", "final   String   urlSelectorStrategyClassName    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME )  ;", "final   Boolean   useJavaContext    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USE _ JAVA _ CONTEXT )  ;", "final   Boolean   enabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ENABLED )  ;", "final   boolean   connectable    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . CONNECTABLE )  ;", "final   Boolean   tracking    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . TRACKING )  ;", "final   Boolean   enlistmentTrace    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ENLISTMENT _ TRACE )  ;", "final   String   mcp    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . MCP )  ;", "final   Integer   maxPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . MAX _ POOL _ SIZE )  ;", "final   Integer   minPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . MIN _ POOL _ SIZE )  ;", "final   Integer   initialPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . INITIAL _ POOL _ SIZE )  ;", "final   Boolean   prefill    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ PREFILL )  ;", "final   Boolean   fair    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ FAIR )  ;", "final   Boolean   useStrictMin    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ USE _ STRICT _ MIN )  ;", "final   Boolean   interleaving    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . INTERLEAVING )  ;", "final   Boolean   noTxSeparatePool    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . NO _ TX _ SEPARATE _ POOL )  ;", "final   Boolean   padXid    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . PAD _ XID )  ;", "final   Boolean   isSameRmOverride    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SAME _ RM _ OVERRIDE )  ;", "final   Boolean   wrapXaDataSource    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . WRAP _ XA _ RESOURCE )  ;", "final   String   flushStrategyString    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . POOL _ FLUSH _ STRATEGY )  ;", "final   FlushStrategy   flushStrategy    =    FlushStrategy . forName ( flushStrategyString )  ;", "final   Boolean   allowMultipleUsers    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ALLOW _ MULTIPLE _ USERS )  ;", "Extension   incrementer    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS ,    common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES )  ;", "Extension   decrementer    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS ,    common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES )  ;", "final   Capacity   capacity    =    new   Capacity ( incrementer ,    decrementer )  ;", "final   Extension   connectionListener    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . CONNECTION _ LISTENER _ CLASS ,    Constants . CONNECTION _ LISTENER _ PROPERTIES )  ;", "final   DsXaPool   xaPool    =    new   DsXaPoolImpl ( minPoolSize ,    initialPoolSize ,    maxPoolSize ,    prefill ,    useStrictMin ,    flushStrategy ,    isSameRmOverride ,    interleaving ,    padXid ,    wrapXaDataSource ,    noTxSeparatePool ,    allowMultipleUsers ,    capacity ,    fair ,    connectionListener )  ;", "final   String   username    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USERNAME )  ;", "final   String   password    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . PASSWORD )  ;", "final   String   securityDomain    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SECURITY _ DOMAIN )  ;", "final   boolean   elytronEnabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ELYTRON _ ENABLED )  ;", "final   String   authenticationContext    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . AUTHENTICATION _ CONTEXT )  ;", "final   Extension   reauthPlugin    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . REAUTH _ PLUGIN _ CLASSNAME ,    Constants . REAUTHPLUGIN _ PROPERTIES )  ;", "final   DsSecurity   security    =    new   DsSecurityImpl ( username ,    password ,     ( elytronEnabled    ?    authenticationContext    :    securityDomain )  ,    elytronEnabled ,    credentialSourceSupplier ,    reauthPlugin )  ;", "final   Boolean   sharePreparedStatements    =     ( dataSourceNode . hasDefined ( Constants . SHARE _ PREPARED _ STATEMENTS . getName (  )  )  )     ?    dataSourceNode . get ( Constants . SHARE _ PREPARED _ STATEMENTS . getName (  )  )  . asBoolean (  )     :    Defaults . SHARE _ PREPARED _ STATEMENTS ;", "final   Long   preparedStatementsCacheSize    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . PREPARED _ STATEMENTS _ CACHE _ SIZE )  ;", "final   String   trackStatementsString    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . TRACK _ STATEMENTS )  ;", "final   Statement . TrackStatementsEnum   trackStatements    =    TrackStatementsEnum . valueOf ( trackStatementsString . toUpperCase ( Locale . ENGLISH )  )  ;", "final   Statement   statement    =    new   StatementImpl ( sharePreparedStatements ,    preparedStatementsCacheSize ,    trackStatements )  ;", "final   Integer   allocationRetry    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ALLOCATION _ RETRY )  ;", "final   Long   allocationRetryWaitMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS )  ;", "final   Long   blockingTimeoutMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS )  ;", "final   Long   idleTimeoutMinutes    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . IDLETIMEOUTMINUTES )  ;", "final   Long   queryTimeout    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . QUERY _ TIMEOUT )  ;", "final   Integer   xaResourceTimeout    =    ModelNodeUtil . getIntIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . XA _ RESOURCE _ TIMEOUT )  ;", "final   Long   useTryLock    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USE _ TRY _ LOCK )  ;", "final   Boolean   setTxQueryTimeout    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SET _ TX _ QUERY _ TIMEOUT )  ;", "final   TimeOut   timeOut    =    new   TimeOutImpl ( blockingTimeoutMillis ,    idleTimeoutMinutes ,    allocationRetry ,    allocationRetryWaitMillis ,    xaResourceTimeout ,    setTxQueryTimeout ,    queryTimeout ,    useTryLock )  ;", "final   String   transactionIsolationString    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . TRANSACTION _ ISOLATION )  ;", "TransactionIsolation   transactionIsolation    =    null ;", "if    ( transactionIsolationString    !  =    null )     {", "transactionIsolation    =    TransactionIsolation . forName ( transactionIsolationString )  ;", "if    ( transactionIsolation    =  =    null )     {", "transactionIsolation    =    TransactionIsolation . customLevel ( transactionIsolationString )  ;", "}", "}", "final   String   checkValidConnectionSql    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . CHECK _ VALID _ CONNECTION _ SQL )  ;", "final   Extension   exceptionSorter    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . EXCEPTION _ SORTER _ CLASSNAME ,    Constants . EXCEPTION _ SORTER _ PROPERTIES )  ;", "final   Extension   staleConnectionChecker    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . STALE _ CONNECTION _ CHECKER _ CLASSNAME ,    Constants . STALE _ CONNECTION _ CHECKER _ PROPERTIES )  ;", "final   Extension   validConnectionChecker    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . VALID _ CONNECTION _ CHECKER _ CLASSNAME ,    Constants . VALID _ CONNECTION _ CHECKER _ PROPERTIES )  ;", "Long   backgroundValidationMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . BACKGROUNDVALIDATIONMILLIS )  ;", "final   Boolean   backgroundValidation    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . BACKGROUNDVALIDATION )  ;", "boolean   useFastFail    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    common . pool . Constants . USE _ FAST _ FAIL )  ;", "final   Boolean   validateOnMatch    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . VALIDATE _ ON _ MATCH )  ;", "final   Boolean   spy    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . SPY )  ;", "final   Boolean   useCcm    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . USE _ CCM )  ;", "final   Validation   validation    =    new   ValidationImpl ( backgroundValidation ,    backgroundValidationMillis ,    useFastFail ,    validConnectionChecker ,    checkValidConnectionSql ,    validateOnMatch ,    staleConnectionChecker ,    exceptionSorter )  ;", "final   String   recoveryUsername    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . RECOVERY _ USERNAME )  ;", "final   String   recoveryPassword    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . RECOVERY _ PASSWORD )  ;", "final   String   recoverySecurityDomain    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . RECOVERY _ SECURITY _ DOMAIN )  ;", "final   boolean   recoveryElytronEnabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . RECOVERY _ ELYTRON _ ENABLED )  ;", "final   String   recoveryAuthenticationContext    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT )  ;", "Boolean   noRecovery    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . NO _ RECOVERY )  ;", "final   String   urlProperty    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    Constants . URL _ PROPERTY )  ;", "Recovery   recovery    =    null ;", "if    (  (  (  ( recoveryUsername    !  =    null )     &  &     (  ( recoveryPassword    !  =    null )     |  |     ( recoveryCredentialSourceSupplier    !  =    null )  )  )     |  |     ( recoverySecurityDomain    !  =    null )  )     |  |     ( noRecovery    !  =    null )  )     {", "Credential   credential    =    null ;", "if    (  (  ( recoveryUsername    !  =    null )     &  &     (  ( recoveryPassword    !  =    null )     |  |     ( recoveryCredentialSourceSupplier    !  =    null )  )  )     |  |     ( recoverySecurityDomain    !  =    null )  )", "credential    =    new   CredentialImpl ( recoveryUsername ,    recoveryPassword ,     ( recoveryElytronEnabled    ?    recoveryAuthenticationContext    :    recoverySecurityDomain )  ,    elytronEnabled ,    recoveryCredentialSourceSupplier )  ;", "Extension   recoverPlugin    =    ModelNodeUtil . extractExtension ( operationContext ,    dataSourceNode ,    Constants . RECOVER _ PLUGIN _ CLASSNAME ,    Constants . RECOVER _ PLUGIN _ PROPERTIES )  ;", "if    ( noRecovery    =  =    null )", "noRecovery    =    Boolean . FALSE ;", "recovery    =    new   Recovery ( credential ,    recoverPlugin ,    noRecovery )  ;", "}", "return   new   ModifiableXaDataSource ( transactionIsolation ,    timeOut ,    security ,    statement ,    validation ,    urlDelimiter ,    urlProperty ,    urlSelectorStrategyClassName ,    useJavaContext ,    poolName ,    enabled ,    jndiName ,    spy ,    useCcm ,    connectable ,    tracking ,    mcp ,    enlistmentTrace ,    xaDataSourceProperty ,    xaDataSourceClass ,    module ,    newConnectionSql ,    xaPool ,    recovery )  ;", "}", "METHOD_END"], "methodName": ["xaFrom"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "return   dataSourceValue ;", "}", "METHOD_END"], "methodName": ["getDataSourceInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   reference ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "reference    =    new   ValueManagedReference ( new   ImmediateValue < Object >  ( dataSourceValue . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "reference    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourceReferenceFactoryService"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder ( DataSourcesExtension . SUBSYSTEM _ NAME )  ;", "for    ( String   kp    :    keyPrefix )     {", "prefix . append (  '  .  '  )  . append ( kp )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,    DataSourcesExtension . RESOURCE _ NAME ,    DataSourcesExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesExtension"}, {"methodBody": ["METHOD_START", "{", "model . setEmptyObject (  )  ;", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesSubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "if    ( locale    =  =    null )     {", "locale    =    Locale . getDefault (  )  ;", "}", "return   ResourceBundle . getBundle (  . RESOURCE _ NAME ,    locale )  ;", "}", "METHOD_END"], "methodName": ["getResourceBundle"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesSubsystemProviders"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSourcesSubsystemRootDefinition ( registerRuntimeOnly ,    true )  ;", "}", "METHOD_END"], "methodName": ["createDeployedInstance"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesSubsystemRootDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSourcesSubsystemRootDefinition ( registerRuntimeOnly ,    false )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesSubsystemRootDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   RejectAttributeChecker . DefaultRejectAttributeChecker (  )     {", "@ Override", "public   String   getRejectionLogMessage ( Map < String ,    ModelNode >    attributes )     {", "return   UNDEFINED . getRejectionLogMessage ( attributes )  ;", "}", "@ Override", "public   boolean   rejectOperationParameter ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    ModelNode   operation ,    ationContext   context )     {", "return    ( operation . get ( OP )  . asString (  )  . equals ( ADD )  )     &  &     (  !  ( attributeValue . isDefined (  )  )  )  ;", "}", "@ Override", "protected   boolean   rejectAttribute ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    ationContext   context )     {", "return    !  ( attributeValue . isDefined (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createConnURLRejectChecker"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parentBuilder . addChildResource ( DataSourceDefinition . PATH _ DATASOURCE )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( true )  )  ,    Constants . POOL _ FAIR )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    Constants . CONNECTABLE )  . setDiscard ( new   DiscardAttributeValueChecker ( false ,    false ,    new   ModelNode ( true )  )  ,    ModelDescriptionConstants . STATISTICS _ ENABLED )  . setDiscard ( new   DiscardAttributeValueChecker ( Constants . ENLISTMENT _ TRACE . getDefaultValue (  )  )  ,    Constants . ENLISTMENT _ TRACE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  . LEGACY _ MCP )  )  ,    Constants . MCP )  . addRejectCheck ( DEFINED ,    Constants . POOL _ FAIR )  . addRejectCheck ( new   RejectAttributeChecker . SimpleRejectAttributeChecker ( new   ModelNode ( false )  )  ,    Constants . ENLISTMENT _ TRACE )  . addRejectCheck ( DEFINED ,    Constants . MCP )  . addRejectCheck ( new   RejectAttributeChecker . DefaultRejectAttributeChecker (  )     {", "@ Override", "public   String   getRejectionLogMessage ( Map < String ,    ModelNode >    attributes )     {", "return   ConnectorLogger . ROOT _ LOGGER . rejectAttributesMustBeTrue ( attributes . keySet (  )  )  ;", "}", "@ Override", "protected   boolean   rejectAttribute ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    TransformationContext   context )     {", "return    (  !  ( attributeValue . isDefined (  )  )  )     |  |     (  !  ( attributeValue . asString (  )  . equals (  \" true \"  )  )  )  ;", "}", "}  ,    ModelDescriptionConstants . STATISTICS _ ENABLED )  . end (  )  . addOperationTransformationOverride ( Constants . DATASOURCE _ ENABLE . getName (  )  )  . end (  )  . addOperationTransformationOverride ( Constants . DATASOURCE _ DISABLE . getName (  )  )  . end (  )  ;", "builder    =    parentBuilder . addChildResource ( XaDataSourceDefinition . PATH _ XA _ DATASOURCE )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode ( false )  )  ,    Constants . CONNECTABLE )  . setDiscard ( new   DiscardAttributeValueChecker ( false ,    false ,    new   ModelNode ( true )  )  ,    ModelDescriptionConstants . STATISTICS _ ENABLED )  . setDiscard ( new   DiscardAttributeValueChecker ( Constants . ENLISTMENT _ TRACE . getDefaultValue (  )  )  ,    Constants . ENLISTMENT _ TRACE )  . setDiscard ( new   DiscardAttributeValueChecker ( new   ModelNode (  . LEGACY _ MCP )  )  ,    Constants . MCP )  . addRejectCheck ( DEFINED ,    Constants . ENLISTMENT _ TRACE )  . addRejectCheck ( DEFINED ,    Constants . MCP )  . addRejectCheck ( new   RejectAttributeChecker . DefaultRejectAttributeChecker (  )     {", "@ Override", "public   String   getRejectionLogMessage ( Map < String ,    ModelNode >    attributes )     {", "return   ConnectorLogger . ROOT _ LOGGER . rejectAttributesMustBeTrue ( attributes . keySet (  )  )  ;", "}", "@ Override", "protected   boolean   rejectAttribute ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    TransformationContext   context )     {", "return    (  !  ( attributeValue . isDefined (  )  )  )     |  |     (  !  ( attributeValue . asString (  )  . equals (  \" true \"  )  )  )  ;", "}", "}  ,    ModelDescriptionConstants . STATISTICS _ ENABLED )  . setDiscard ( UNDEFINED ,    Constants . TRACKING )  . end (  )  . addOperationTransformationOverride ( Constants . DATASOURCE _ ENABLE . getName (  )  )  . end (  )  . addOperationTransformationOverride ( Constants . DATASOURCE _ DISABLE . getName (  )  )  . end (  )  ;", "return   parentBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["get120TransformationDescription"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parentBuilder . addChildResource ( DataSourceDefinition . PATH _ DATASOURCE )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeChecker . DefaultDiscardAttributeChecker (  )     {", "@ Override", "protected   boolean   isValueDiscardable ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    TransformationContext   context )     {", "return   attributeValue . equals ( new   ModelNode ( false )  )  ;", "}", "}  ,    Constants . TRACKING )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,    ModelDescriptionConstants . ENABLED )  . addRejectCheck ( DEFINED ,    Constants . TRACKING )  . end (  )  ;", "builder    =    parentBuilder . addChildResource ( XaDataSourceDefinition . PATH _ XA _ DATASOURCE )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeChecker . DefaultDiscardAttributeChecker (  )     {", "@ Override", "protected   boolean   isValueDiscardable ( PathAddress   address ,    String   attributeName ,    ModelNode   attributeValue ,    TransformationContext   context )     {", "return   attributeValue . equals ( new   ModelNode ( false )  )  ;", "}", "}  ,    Constants . TRACKING )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,    ModelDescriptionConstants . ENABLED )  . addRejectCheck ( DEFINED ,    Constants . TRACKING )  . end (  )  ;", "return   parentBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["get130TransformationDescription"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parentBuilder . addChildResource ( DataSourceDefinition . PATH _ DATASOURCE )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( Constants . ELYTRON _ ENABLED . getDefaultValue (  )  )  ,    Constants . ELYTRON _ ENABLED )  . setDiscard ( UNDEFINED ,    Constants . AUTHENTICATION _ CONTEXT ,    Constants . CREDENTIAL _ REFERENCE )  . addRejectCheck ( DEFINED ,    Constants . ELYTRON _ ENABLED ,    Constants . AUTHENTICATION _ CONTEXT ,    Constants . CREDENTIAL _ REFERENCE )  . addRejectCheck (  . createConnURLRejectChecker (  )  ,    Constants . CONNECTION _ URL )  . setValueConverter ( new   DefaultValueAttributeConverter ( Constants . ENLISTMENT _ TRACE )  ,    Constants . ENLISTMENT _ TRACE )  . end (  )  ;", "builder    =    parentBuilder . addChildResource ( XaDataSourceDefinition . PATH _ XA _ DATASOURCE )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( new   DiscardAttributeValueChecker ( Constants . ELYTRON _ ENABLED . getDefaultValue (  )  )  ,    Constants . ELYTRON _ ENABLED ,    Constants . RECOVERY _ ELYTRON _ ENABLED )  . setDiscard ( UNDEFINED ,    Constants . RECOVERY _ CREDENTIAL _ REFERENCE ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT ,    Constants . CREDENTIAL _ REFERENCE ,    Constants . AUTHENTICATION _ CONTEXT )  . addRejectCheck ( DEFINED ,    Constants . RECOVERY _ CREDENTIAL _ REFERENCE ,    Constants . RECOVERY _ ELYTRON _ ENABLED ,    Constants . ELYTRON _ ENABLED ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT ,    Constants . CREDENTIAL _ REFERENCE ,    Constants . AUTHENTICATION _ CONTEXT )  . setValueConverter ( new   DefaultValueAttributeConverter ( Constants . ENLISTMENT _ TRACE )  ,    Constants . ENLISTMENT _ TRACE )  . end (  )  ;", "parentBuilder . addChildResource ( JdbcDriverDefinition . PATH _ DRIVER )  . getAttributeBuilder (  )  . addRejectCheck ( SIMPLE _ EXPRESSIONS ,    Constants . MODULE _ SLOT ,    Constants . JDBC _ COMPLIANT ,    Constants . PROFILE ,    Constants . DRIVER _ MODULE _ NAME ,    Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME ,    Constants . DRIVER _ CLASS _ NAME )  . end (  )  ;", "return   parentBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["get400TransformationDescription"], "fileName": "org.jboss.as.connector.subsystems.datasources.DataSourcesTransformers"}, {"methodBody": ["METHOD_START", "{", "return   AdditionalInitialization . withCapabilities (  (  ( Capabilities . AUTHENTICATION _ CONTEXT _ CAPABILITY )     +     \"  . DsAuthCtxt \"  )  ,     (  ( Capabilities . AUTHENTICATION _ CONTEXT _ CAPABILITY )     +     \"  . CredentialAuthCtxt \"  )  ,     (  ( CredentialReference . CREDENTIAL _ STORE _ CAPABILITY )     +     \"  . test - store \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createAdditionalInitialization"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "LegacyKernelServicesInitializer   initializer    =    builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  ;", "String   mavenGroupId    =    controllerVersion . getMavenGroupId (  )  ;", "String   artifactId    =     \" wildfly - connector \"  ;", "if    (  ( controllerVersion . isEap (  )  )     &  &     ( controllerVersion . getMavenGavVersion (  )  . equals ( controllerVersion . getCoreVersion (  )  )  )  )     {", "artifactId    =     \" jboss - as - connector \"  ;", "}", "initializer . addMavenResourceURL (  (  (  (  ( mavenGroupId    +     \"  :  \"  )     +    artifactId )     +     \"  :  \"  )     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  ;", "initializer . addMavenResourceURL (  \" ironjacamar : ironjacamar - spec - api :  1  .  0  .  2  8  . Final \"  )  . addMavenResourceURL (  \" ironjacamar : ironjacamar - common - api :  1  .  0  .  2  8  . Final \"  )  . setExtensionClassName (  \" SourcesExtension \"  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "return   mainServices ;", "}", "METHOD_END"], "methodName": ["initialKernelServices"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" datasources - elytron - enabled _  5  _  0  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testElytronConfig"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" datasources - full - expression . xml \"  ,     \" datasources - full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressionConfig"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" datasources - full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFullConfig"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformerEAP 7 Rejection (  \" datasources - no - connection - url . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testRejectionsEAP7"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "KernelServices   mainServices    =    initialKernelServices ( builder ,    controllerVersion ,    modelVersion )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( subsystemXml )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( DataSRootDefinition . PATH _ SUBSYSTEM )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress . append ( DataSourceDefinition . PATH _ DATASOURCE )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . TRACKING )  )  . addFailedAttribute ( subsystemAddress . append ( XaDataSourceDefinition . PATH _ XA _ DATASOURCE )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . TRACKING )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformer"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" datasources - full . xml \"  ,    EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     2  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP62"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" datasources - full . xml \"  ,    EAP _  6  _  3  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP63"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" datasources - full . xml \"  ,    EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP64"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformerEAP 7 FullConfiguration (  \" datasources - full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP7"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   eap 7 ControllerVersion    =    ModelTestControllerVersion . EAP _  7  _  0  _  0  ;", "ModelVersion   eap 7 ModelVersion    =    ModelVersion . create (  4  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "KernelServices   mainServices    =    initialKernelServices ( builder ,    eap 7 ControllerVersion ,    eap 7 ModelVersion )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( Xml )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    eap 7 ModelVersion ,    ops ,    NO _ FAILURES )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP7FullConfiguration"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelTestControllerVersion   eap 7 ControllerVersion    =    ModelTestControllerVersion . EAP _  7  _  0  _  0  ;", "ModelVersion   eap 7 ModelVersion    =    ModelVersion . create (  4  ,     0  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "KernelServices   mainServices    =    initialKernelServices ( builder ,    eap 7 ControllerVersion ,    eap 7 ModelVersion )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( subsystemXml )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( DataSourcesSubsystemRootDefinition . PATH _ SUBSYSTEM )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    eap 7 ModelVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress . append ( DataSourceDefinition . PATH _ DATASOURCE )  ,    new    . RejectUndefinedAttribute ( Constants . CONNECTION _ URL . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP7Rejection"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "KernelServices   mainServices    =    initialKernelServices ( builder ,    controllerVersion ,    modelVersion )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( subsystemXml )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( DataSRootDefinition . PATH _ SUBSYSTEM )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress . append ( DataSourceDefinition . PATH _ DATASOURCE )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . TRACKING ,    Constants . ELYTRON _ ENABLED ,    Constants . AUTHENTICATION _ CONTEXT ,    Constants . CREDENTIAL _ REFERENCE )  )  . addFailedAttribute ( subsystemAddress . append ( XaDataSourceDefinition . PATH _ XA _ DATASOURCE )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . TRACKING ,    Constants . ELYTRON _ ENABLED ,    Constants . AUTHENTICATION _ CONTEXT ,    Constants . RECOVERY _ ELYTRON _ ENABLED ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT ,    Constants . CREDENTIAL _ REFERENCE ,    Constants . RECOVERY _ CREDENTIAL _ REFERENCE )     {", "@ Override", "protected   boolean   isAttributeWritable ( String   attributeName )     {", "return   false ;", "}", "@ Override", "protected   boolean   checkValue ( String   attrName ,    ModelNode   attribute ,    boolean   isWriteAttribute )     {", "return   attribute . isDefined (  )  ;", "}", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "return   new   ModelNode (  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerElytronEnabled"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformerElytronEnabled (  \" datasources - elytron - enabled _  5  _  0  . xml \"  ,    EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerElytronEnabledEAP64"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" datasources - full - expression 1  1  1  . xml \"  ,    EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     2  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerExpressionEAP62"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" datasources - full - expression 1  1  1  . xml \"  ,    EAP _  6  _  3  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerExpressionEAP63"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" datasources - full - expression 1  1  1  . xml \"  ,    EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerExpressionEAP64"], "fileName": "org.jboss.as.connector.subsystems.datasources.DatasourcesSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "int   iterate ;", "try    {", "iterate    =    reader . nextTag (  )  ;", "}    catch    ( XMLStreamException   e )     {", "iterate    =    reader . nextTag (  )  ;", "}", "switch    ( iterate )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    (  . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   DATASOURCES    :", "{", "parseDataSources ( reader ,    list ,    parentAddress )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "default    :", "throw   new   IllegalStateException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . CAPACITY )  )     {", "return ;", "} else    {", "if    (  ( Capacity . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Capacity . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Capacity . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   INCREMENTER    :", "{", "parseExtension ( reader ,    reader . getLocalName (  )  ,    operation ,    Constants . CAPACITY _ INCREMENTER _ CLASS ,    Constants . CAPACITY _ INCREMENTER _ PROPERTIES )  ;", "break ;", "}", "case   DECREMENTER    :", "{", "parseExtension ( reader ,    reader . getLocalName (  )  ,    operation ,    Constants . CAPACITY _ DECREMENTER _ CLASS ,    Constants . CAPACITY _ DECREMENTER _ PROPERTIES )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseCapacity"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     |  |     (  ( Recovery . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Recovery . Tag . RECOVER _ CREDENTIAL )  )  )     {", "return ;", "} else    {", "if    (  ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Credential . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . PASSWORD    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ PASSWORD . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   USER _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ USERNAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . SECURITY _ DOMAIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseCredential"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     |  |     (  ( Recovery . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Recovery . Tag . RECOVER _ CREDENTIAL )  )  )     {", "return ;", "} else    {", "if    (  ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Credential . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . PASSWORD    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ PASSWORD . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   USER _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ USERNAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . SECURITY _ DOMAIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . ELYTRON _ ENABLED    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . RECOVERY _ ELYTRON _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . AUTHENTICATION _ CONTEXT    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ AUTHENTICATION _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . CREDENTIAL _ REFERENCE    :", "Constants . RECOVERY _ CREDENTIAL _ REFERENCE . getParser (  )  . parseElement ( Constants . RECOVERY _ CREDENTIAL _ REFERENCE ,    reader ,    operation )  ;", "break ;", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseCredential_5_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   DataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JTA    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . JTA . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . JTA . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . DATA _ SOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    configPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( configPropertiesOperations )  ;", "return ;", "} else    {", "if    (  ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONNECTION _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . CONNECTION _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . CONNECTION _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "configPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . CONNECTION _ URL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . CONNECTION _ URL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DRIVER _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DRIVER _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   POOL    :", "{", "parsePool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDataSource_1_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "boolean   enabled    =    ENABLED . booleanValue (  )  ;", "boolean   persistEnabled    =    true ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   DataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "enabled    =    Boolean . parseBoolean ( value )  ;", "persistEnabled    =    true ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JTA    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . JTA . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . JTA . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . CONNECTABLE . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "if    ( Constants . STATISTICS _ ENABLED . getName (  )  . equals ( reader . getAttributeLocalName ( i )  )  )     {", "final   String   value    =    rawAttributeText ( reader ,    Constants . STATISTICS _ ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . DATA _ SOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    configPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( configPropertiesOperations )  ;", "if    ( enabled )     {", "final   ModelNode   enableOperation    =    new   ModelNode (  )  ;", "enableOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ENABLE )  ;", "enableOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "enableOperation . get ( ModelDescriptionConstants . PERSISTENT )  . set ( persistEnabled )  ;", "list . add ( enableOperation )  ;", "}", "return ;", "} else    {", "if    (  ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONNECTION _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . CONNECTION _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . CONNECTION _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "configPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . CONNECTION _ URL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . CONNECTION _ URL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DRIVER _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DRIVER _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   POOL    :", "{", "parsePool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDataSource_1_2"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   DataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JTA    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . JTA . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . JTA . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . CONNECTABLE . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . TRACKING    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . TRACKING . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . TRACKING . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "if    ( Constants . STATISTICS _ ENABLED . getName (  )  . equals ( reader . getAttributeLocalName ( i )  )  )     {", "final   String   value    =    rawAttributeText ( reader ,    Constants . STATISTICS _ ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . DATA _ SOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    configPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( configPropertiesOperations )  ;", "return ;", "} else    {", "if    (  ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONNECTION _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . CONNECTION _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . CONNECTION _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "configPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . CONNECTION _ URL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . CONNECTION _ URL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DRIVER _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DRIVER _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   POOL    :", "{", "parsePool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDataSource_3_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   DataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JTA    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . JTA . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . JTA . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . CONNECTABLE . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . MCP    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . MCP . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . MCP . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . ENLISTMENT _ TRACE    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENLISTMENT _ TRACE . getXmlName (  )  )  ;", "Constants . ENLISTMENT _ TRACE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRACKING    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . TRACKING . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . TRACKING . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "if    ( Constants . STATISTICS _ ENABLED . getName (  )  . equals ( reader . getAttributeLocalName ( i )  )  )     {", "final   String   value    =    rawAttributeText ( reader ,    Constants . STATISTICS _ ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . DATA _ SOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    configPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( configPropertiesOperations )  ;", "return ;", "} else    {", "if    (  ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( DataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONNECTION _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . CONNECTION _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . CONNECTION _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "configPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . CONNECTION _ URL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . CONNECTION _ URL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DRIVER _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DRIVER _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   POOL    :", "{", "parsePool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   DATASOURCES _  4  _  0     :", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "default    :", "parseDsSecurity _  5  _  0  ( reader ,    operation )  ;", "break ;", "}", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDataSource_4_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  (  . Tag . forName ( reader . getLocalName (  )  )  )     =  =     (  . Tag . DATASOURCES )  )", "return ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( DataSources . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   DATASOURCE    :", "{", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   DATASOURCES _  1  _  1     :", "case   DATASOURCES _  2  _  0     :", "parseDataSource _  1  _  0  ( reader ,    list ,    parentAddress )  ;", "break ;", "case   DATASOURCES _  1  _  2     :", "parseDataSource _  1  _  2  ( reader ,    list ,    parentAddress )  ;", "break ;", "case   DATASOURCES _  3  _  0     :", "parseDataSource _  3  _  0  ( reader ,    list ,    parentAddress )  ;", "break ;", "default    :", "parseDataSource _  4  _  0  ( reader ,    list ,    parentAddress )  ;", "break ;", "}", "break ;", "}", "case   Constants . XA _ DATASOURCE    :", "{", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   DATASOURCES _  1  _  1     :", "case   DATASOURCES _  2  _  0     :", "parseXADataSource _  1  _  0  ( reader ,    list ,    parentAddress )  ;", "break ;", "case   DATASOURCES _  1  _  2     :", "parseXADataSource _  1  _  2  ( reader ,    list ,    parentAddress )  ;", "break ;", "case   DATASOURCES _  3  _  0     :", "parseXADataSource _  3  _  0  ( reader ,    list ,    parentAddress )  ;", "break ;", "default    :", "parseXADataSource _  4  _  0  ( reader ,    list ,    parentAddress )  ;", "break ;", "}", "break ;", "}", "case   DRIVERS    :", "{", "break ;", "}", "case   DRIVER    :", "{", "parseDriver ( reader ,    list ,    parentAddress )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDataSources"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   driverAddress    =    parentAddress . clone (  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "String   driverName    =    null ;", "for    ( Driver . Attribute   attribute    :    Attribute . values (  )  )     {", "switch    ( attribute )     {", "case   NAME    :", "{", "driverName    =    rawAttributeText ( reader ,    Constants . DRIVER _ NAME . getXmlName (  )  )  ;", "Constants . DRIVER _ NAME . parseAndSetParameter ( driverName ,    operation ,    reader )  ;", "break ;", "}", "case   MAJOR _ VERSION    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . DRIVER _ MAJOR _ VERSION . getXmlName (  )  )  ;", "Constants . DRIVER _ MAJOR _ VERSION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   MINOR _ VERSION    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . DRIVER _ MINOR _ VERSION . getXmlName (  )  )  ;", "Constants . DRIVER _ MINOR _ VERSION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   MODULE    :", "{", "String   moduleName    =    rawAttributeText ( reader ,    Constants . DRIVER _ MODULE _ NAME . getXmlName (  )  )  ;", "String   slot    =    null ;", "if    ( moduleName . contains (  \"  :  \"  )  )     {", "slot    =    moduleName . substring (  (  ( moduleName . indexOf (  \"  :  \"  )  )     +     1  )  )  ;", "moduleName    =    moduleName . substring (  0  ,    moduleName . indexOf (  \"  :  \"  )  )  ;", "}", "Constants . DRIVER _ MODULE _ NAME . parseAndSetParameter ( moduleName ,    operation ,    reader )  ;", "if    ( slot    !  =    null )     {", "Constants . MODULE _ SLOT . parseAndSetParameter ( slot ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "break ;", "}", "}", "driverAddress . add ( Constants . JDBC _ DRIVER _ NAME ,    driverName )  ;", "driverAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( driverAddress )  ;", "boolean   driverClassMatched    =    false ;", "boolean   xaDatasourceClassMatched    =    false ;", "boolean   ClassMatched    =    false ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . DRIVER )  )     {", "list . add ( operation )  ;", "return ;", "} else    {", "if    (  ( Driver . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Driver . Tag . UNKNOWN )  )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Driver . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . DATASOURCE _ CLASS    :", "{", "if    ( ClassMatched )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . getXmlName (  )  )  )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "ClassMatched    =    true ;", "break ;", "}", "case   Constants . XA _ DATASOURCE _ CLASS    :", "{", "if    ( xaDatasourceClassMatched )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . getXmlName (  )  )  )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "xaDatasourceClassMatched    =    true ;", "break ;", "}", "case   Constants . DRIVER _ CLASS    :", "{", "if    ( driverClassMatched )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( Constants . DRIVER _ CLASS _ NAME . getXmlName (  )  )  )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . DRIVER _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "driverClassMatched    =    true ;", "break ;", "}", "default    :", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException ( DsParser . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDriver"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "boolean   securityDomainMatched    =    false ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     {", "return ;", "} else    {", "if    (  ( DsSecurity . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DsSecurity . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "final   String   localName    =    reader . getLocalName (  )  ;", "DsSecurity . Tag   tag    =    DsSecurity . Tag . forName ( localName )  ;", "if    ( localName    =  =    null )", "break ;", "if    ( localName . equals ( DsSecurity . Tag . PASSWORD . getLocalName (  )  )  )     {", "String   value    =    rawElementText ( reader )  ;", "Constants . PASSWORD . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "} else", "if    ( localName . equals ( DsSecurity . Tag . USER _ NAME . getLocalName (  )  )  )     {", "String   value    =    rawElementText ( reader )  ;", "Constants . USERNAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "} else", "if    ( localName . equals ( DsSecurity . Tag . SECURITY _ DOMAIN . getLocalName (  )  )  )     {", "if    ( securityDomainMatched )     {", "throw   new   ParserException (  . bundle . unexpectedElement ( Constants . SECURITY _ DOMAIN . getXmlName (  )  )  )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . SECURITY _ DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "securityDomainMatched    =    true ;", "break ;", "} else", "if    ( localName . equals ( DsSecurity . Tag . REAUTH _ PLUGIN . getLocalName (  )  )  )     {", "parseExtension ( reader ,    tag . getLocalName (  )  ,    operation ,    Constants . REAUTH _ PLUGIN _ CLASSNAME ,    Constants . REAUTHPLUGIN _ PROPERTIES )  ;", "break ;", "} else", "if    ( localName . equals ( Constants . CREDENTIAL _ REFERENCE . getXmlName (  )  )  )     {", "Constants . CREDENTIAL _ REFERENCE . getParser (  )  . parseElement ( Constants . CREDENTIAL _ REFERENCE ,    reader ,    operation )  ;", "break ;", "} else    {", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDsSecurity"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "boolean   securityDomainMatched    =    false ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     {", "return ;", "} else    {", "if    (  ( DsSecurity . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DsSecurity . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "DsSecurity . Tag   tag    =    DsSecurity . Tag . forName ( reader . getLocalName (  )  )  ;", "switch    ( tag )     {", "case   PASSWORD    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . PASSWORD . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   USER _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . USERNAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY _ DOMAIN    :", "{", "if    ( securityDomainMatched )     {", "throw   new   ParserException (  . bundle . unexpectedElement ( Constants . SECURITY _ DOMAIN . getXmlName (  )  )  )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . SECURITY _ DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "securityDomainMatched    =    true ;", "break ;", "}", "case   ELYTRON _ ENABLED    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . ELYTRON _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   AUTHENTICATION _ CONTEXT    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . AUTHENTICATION _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   REAUTH _ PLUGIN    :", "{", "parseExtension ( reader ,    tag . getLocalName (  )  ,    operation ,    Constants . REAUTH _ PLUGIN _ CLASSNAME ,    Constants . REAUTHPLUGIN _ PROPERTIES )  ;", "break ;", "}", "case   CREDENTIAL _ REFERENCE    :", "{", "Constants . CREDENTIAL _ REFERENCE . getParser (  )  . parseElement ( Constants . CREDENTIAL _ REFERENCE ,    reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDsSecurity_5_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . POOL )  )     {", "return ;", "} else    {", "if    (  ( DsPool . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DsPool . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( DsPool . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . MAX _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MAX _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . INITIAL _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . INITIAL _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . MIN _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MIN _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   PREFILL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ PREFILL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   FAIR    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FAIR . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   USE _ STRICT _ MIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ USE _ STRICT _ MIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   FLUSH _ STRATEGY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FLUSH _ STRATEGY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . ALLOW _ MULTIPLE _ USERS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . ALLOW _ MULTIPLE _ USERS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   CAPACITY    :", "{", "parseCapacity ( reader ,    operation )  ;", "break ;", "}", "case   CONNECTION _ LISTENER    :", "{", "parseExtension ( reader ,    reader . getLocalName (  )  ,    operation ,    Constants . CONNECTION _ LISTENER _ CLASS ,    Constants . CONNECTION _ LISTENER _ PROPERTIES )  ;", "break ;", "}", "case   UNKNOWN    :", "{", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "default    :", "{", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parsePool"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "for    ( Recovery . Attribute   attribute    :    Attribute . values (  )  )     {", "switch    ( attribute )     {", "case   Constants . NO _ RECOVERY    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . NO _ RECOVERY . getXmlName (  )  )  ;", "Constants . NO _ RECOVERY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "break ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . RECOVERY )  )     {", "return ;", "} else    {", "if    (  ( Recovery . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Recovery . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "Recovery . Tag   tag    =    Recovery . Tag . forName ( reader . getLocalName (  )  )  ;", "switch    ( tag )     {", "case   RECOVER _ CREDENTIAL    :", "{", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   DATASOURCES _  1  _  1     :", "case   DATASOURCES _  1  _  2     :", "case   DATASOURCES _  2  _  0     :", "case   DATASOURCES _  3  _  0     :", "case   DATASOURCES _  4  _  0     :", "parseCredential ( reader ,    operation )  ;", "break ;", "default    :", "parseCredential _  5  _  0  ( reader ,    operation )  ;", "break ;", "}", "break ;", "}", "case   RECOVER _ PLUGIN    :", "{", "parseExtension ( reader ,    tag . getLocalName (  )  ,    operation ,    Constants . RECOVER _ PLUGIN _ CLASSNAME ,    Constants . RECOVER _ PLUGIN _ PROPERTIES )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseRecovery"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . STATEMENT )  )     {", "return ;", "} else    {", "if    (  ( Statement . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Statement . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Statement . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   PREPARED _ STATEMENT _ CACHE _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . PREPARED _ STATEMENTS _ CACHE _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRACK _ STATEMENTS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRACK _ STATEMENTS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . SHARE _ PREPARED _ STATEMENTS    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . SHARE _ PREPARED _ STATEMENTS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseStatementSettings"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . TIMEOUT )  )     {", "return ;", "} else    {", "if    (  ( TimeOut . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( TimeOut . Tag . UNKNOWN )  )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( TimeOut . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . ALLOCATION _ RETRY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . ALLOCATION _ RETRY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   BLOCKING _ TIMEOUT _ MILLIS    :", "{", "String   value    =    rawElementText ( reader )  ;", "common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   IDLE _ TIMEOUT _ MINUTES    :", "{", "String   value    =    rawElementText ( reader )  ;", "common . pool . Constants . IDLETIMEOUTMINUTES . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . QUERY _ TIMEOUT    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . QUERY _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . SET _ TX _ QUERY _ TIMEOUT    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . SET _ TX _ QUERY _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . USE _ TRY _ LOCK    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . USE _ TRY _ LOCK . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . XA _ RESOURCE _ TIMEOUT    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . XA _ RESOURCE _ TIMEOUT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException ( DsParser . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseTimeOutSettings"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . VALIDATION )  )     {", "return ;", "} else    {", "if    (  ( Validation . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Validation . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "Validation . Tag   currTag    =    Validation . Tag . forName ( reader . getLocalName (  )  )  ;", "switch    ( currTag )     {", "case   BACKGROUND _ VALIDATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . BACKGROUNDVALIDATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   BACKGROUND _ VALIDATION _ MILLIS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . BACKGROUNDVALIDATIONMILLIS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . CHECK _ VALID _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . CHECK _ VALID _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   EXCEPTION _ SORTER    :", "{", "parseExtension ( reader ,    currTag . getLocalName (  )  ,    operation ,    Constants . EXCEPTION _ SORTER _ CLASSNAME ,    Constants . EXCEPTION _ SORTER _ PROPERTIES )  ;", "break ;", "}", "case   STALE _ CONNECTION _ CHECKER    :", "{", "parseExtension ( reader ,    currTag . getLocalName (  )  ,    operation ,    Constants . STALE _ CONNECTION _ CHECKER _ CLASSNAME ,    Constants . STALE _ CONNECTION _ CHECKER _ PROPERTIES )  ;", "break ;", "}", "case   Constants . USE _ FAST _ FAIL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . USE _ FAST _ FAIL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . VALIDATE _ ON _ MATCH    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . VALIDATE _ ON _ MATCH . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   VALID _ CONNECTION _ CHECKER    :", "{", "parseExtension ( reader ,    currTag . getLocalName (  )  ,    operation ,    Constants . VALID _ CONNECTION _ CHECKER _ CLASSNAME ,    Constants . VALID _ CONNECTION _ CHECKER _ PROPERTIES )  ;", "break ;", "}", "default    :", "{", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseValidationSetting"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   XaDataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . XA _ DATASOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    xaPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . XA _ DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( xaPropertiesOperations )  ;", "return ;", "} else    {", "if    (  ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( XaDataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   XA _ DATASOURCE _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . XADATASOURCE _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . XADATASOURCE _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "xaPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . XA _ DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . XA _ DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "parseXaPool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ PROPERTY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ PROPERTY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "case   RECOVERY    :", "{", "parseRecovery ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException ( DsParser . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseXADataSource_1_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "boolean   enabled    =    ENABLED . booleanValue (  )  ;", "boolean   persistEnabled    =    true ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   XaDataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "enabled    =    Boolean . parseBoolean ( value )  ;", "persistEnabled    =    true ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "if    ( Constants . STATISTICS _ ENABLED . getName (  )  . equals ( reader . getAttributeLocalName ( i )  )  )     {", "final   String   value    =    rawAttributeText ( reader ,    Constants . STATISTICS _ ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . XA _ DATASOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    xaPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . XA _ DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( xaPropertiesOperations )  ;", "if    ( enabled )     {", "final   ModelNode   enableOperation    =    new   ModelNode (  )  ;", "enableOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ENABLE )  ;", "enableOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "enableOperation . get ( ModelDescriptionConstants . PERSISTENT )  . set ( persistEnabled )  ;", "list . add ( enableOperation )  ;", "}", "return ;", "} else    {", "if    (  ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( XaDataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   XA _ DATASOURCE _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . XADATASOURCE _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . XADATASOURCE _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "xaPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . XA _ DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . XA _ DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "parseXaPool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "case   RECOVERY    :", "{", "parseRecovery ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException ( DsParser . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseXADataSource_1_2"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   XaDataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . CONNECTABLE . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . TRACKING    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . TRACKING . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . TRACKING . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "if    ( Constants . STATISTICS _ ENABLED . getName (  )  . equals ( reader . getAttributeLocalName ( i )  )  )     {", "final   String   value    =    rawAttributeText ( reader ,    Constants . STATISTICS _ ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . XA _ DATASOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    xaPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . XA _ DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( xaPropertiesOperations )  ;", "return ;", "} else    {", "if    (  ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( XaDataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   XA _ DATASOURCE _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . XADATASOURCE _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . XADATASOURCE _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "xaPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . XA _ DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . XA _ DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "parseXaPool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ PROPERTY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ PROPERTY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "case   RECOVERY    :", "{", "parseRecovery ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException ( DsParser . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseXADataSource_3_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  !  ( isNoNamespaceAttribute ( reader ,    i )  )  )     {", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "final   XaDataSource . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . JNDI _ NAME    :", "{", "final   String   jndiName    =    rawAttributeText ( reader ,    Constants . JNDI _ NAME . getXmlName (  )  )  ;", "Constants . JNDI _ NAME . parseAndSetParameter ( jndiName ,    operation ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOLNAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . SPY    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . SPY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . SPY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . USE _ CCM . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ CCM . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . CONNECTABLE . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . MCP    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . MCP . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . MCP . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "case   Constants . ENLISTMENT _ TRACE    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . ENLISTMENT _ TRACE . getXmlName (  )  )  ;", "Constants . ENLISTMENT _ TRACE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRACKING    :", "{", "final   String   value    =    rawAttributeText ( reader ,    Constants . TRACKING . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . TRACKING . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "if    ( Constants . STATISTICS _ ENABLED . getName (  )  . equals ( reader . getAttributeLocalName ( i )  )  )     {", "final   String   value    =    rawAttributeText ( reader ,    Constants . STATISTICS _ ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "}", "break ;", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "final   ModelNode   dsAddress    =    parentAddress . clone (  )  ;", "dsAddress . add ( Constants . XA _ DATASOURCE ,    poolName )  ;", "dsAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dsAddress )  ;", "List < ModelNode >    xaPropertiesOperations    =    new   ArrayList < ModelNode >  (  0  )  ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . XA _ DATASOURCE )  )     {", "list . add ( operation )  ;", "list . addAll ( xaPropertiesOperations )  ;", "return ;", "} else    {", "if    (  ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( XaDataSource . Tag . UNKNOWN )  )     {", "throw   new   ParserException ( DsParser . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( XaDataSource . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   XA _ DATASOURCE _ PROPERTY    :", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   ModelNode   configOperation    =    new   ModelNode (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   ModelNode   configAddress    =    dsAddress . clone (  )  ;", "configAddress . add ( Constants . XADATASOURCE _ PROPERTIES . getName (  )  ,    name )  ;", "configAddress . protect (  )  ;", "configOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configAddress )  ;", "Constants . XADATASOURCE _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    configOperation ,    reader )  ;", "xaPropertiesOperations . add ( configOperation )  ;", "break ;", "}", "case   Constants . XA _ DATASOURCE _ CLASS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . XA _ DATASOURCE _ CLASS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DRIVER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . DATASOURCE _ DRIVER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "parseXaPool ( reader ,    operation )  ;", "break ;", "}", "case   Constants . NEW _ CONNECTION _ SQL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . NEW _ CONNECTION _ SQL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ DELIMITER    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ DELIMITER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ PROPERTY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ PROPERTY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . TRANSACTION _ ISOLATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ ISOLATION . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   SECURITY    :", "{", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   DATASOURCES _  4  _  0     :", "parseDsSecurity ( reader ,    operation )  ;", "break ;", "default    :", "parseDsSecurity _  5  _  0  ( reader ,    operation )  ;", "break ;", "}", "break ;", "}", "case   STATEMENT    :", "{", "parseStatementSettings ( reader ,    operation )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOutSettings ( reader ,    operation )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidationSetting ( reader ,    operation )  ;", "break ;", "}", "case   RECOVERY    :", "{", "parseRecovery ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException ( DsParser . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException ( DsParser . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseXADataSource_4_0"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . XA _ POOL )  )     {", "return ;", "} else    {", "if    (  ( DsXaPool . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( DsXaPool . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( DsXaPool . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . MAX _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MAX _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . INITIAL _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . INITIAL _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . MIN _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MIN _ POOL _ SIZE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   PREFILL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ PREFILL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   FAIR    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FAIR . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   USE _ STRICT _ MIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ USE _ STRICT _ MIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   FLUSH _ STRATEGY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FLUSH _ STRATEGY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . ALLOW _ MULTIPLE _ USERS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . ALLOW _ MULTIPLE _ USERS . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   CONNECTION _ LISTENER    :", "{", "parseExtension ( reader ,    reader . getLocalName (  )  ,    operation ,    Constants . CONNECTION _ LISTENER _ CLASS ,    Constants . CONNECTION _ LISTENER _ PROPERTIES )  ;", "break ;", "}", "case   Constants . INTERLEAVING    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . INTERLEAVING . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   IS _ SAME _ RM _ OVERRIDE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . SAME _ RM _ OVERRIDE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   NO _ TX _ SEPARATE _ POOLS    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . NO _ TX _ SEPARATE _ POOL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . PAD _ XID    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . PAD _ XID . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   Constants . WRAP _ XA _ RESOURCE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . WRAP _ XA _ RESOURCE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   CAPACITY    :", "{", "parseCapacity ( reader ,    operation )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseXaPool"], "fileName": "org.jboss.as.connector.subsystems.datasources.DsParser"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.connector.subsystems.datasources.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.connector.subsystems.datasources.Element"}, {"methodBody": ["METHOD_START", "{", "if    (  ( str . length (  )  )     =  =     1  )     {", "return   str . toLowerCase ( Locale . US )  ;", "}", "if    ( str . equals ( str . toUpperCase ( Locale . US )  )  )     {", "return   str ;", "}", "return    ( sttring (  0  ,     1  )  . toLowerCase ( Locale . US )  )     +     ( sttring (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["deCapitalize"], "fileName": "org.jboss.as.connector.subsystems.datasources.GetDataSourceClassInfoOperationHandler"}, {"methodBody": ["METHOD_START", "{", "ModelNode   result    =    new   ModelNode (  )  ;", "if    ( dsClsName    !  =    null )     {", "ModelNode   dsNode    =    new   ModelNode (  )  ;", "dsNode . get ( dsClsName )  . set (  . findPropsFromCls ( serviceModuleLoader ,    mid ,    dsClsName )  )  ;", "result . add ( dsNode )  ;", "}", "if    ( xaDSClsName    !  =    null )     {", "ModelNode   xaDSNode    =    new   ModelNode (  )  ;", "xaDSNode . get ( xaDSClsName )  . set (  . findPropsFromCls ( serviceModuleLoader ,    mid ,    xaDSClsName )  )  ;", "result . add ( xaDSNode )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["dsClsInfoNode"], "fileName": "org.jboss.as.connector.subsystems.datasources.GetDataSourceClassInfoOperationHandler"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    cls    =    null ;", "if    ( mid    !  =    null )     {", "try    {", "cls    =    Class . forName ( clsName ,    true ,    serviceModuleLoader . loadModule ( mid . toString (  )  )  . getClassLoader (  )  )  ;", "}    catch    ( ModuleLoadException    |    ClassNotFoundException   e )     {", "throw   ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . failedToLoadDataSourceClass ( clsName ,    e )  ;", "}", "}", "if    ( cls    =  =    null )     {", "try    {", "cls    =    Class . forName ( clsName )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . failedToLoadDataSourceClass ( clsName ,    e )  ;", "}", "}", "Map < String ,    Type >    methodsMap    =    new   TreeMap <  >  (  )  ;", "for    ( Method   method    :     . possiblePropsSetters ( cls )  )     {", "methodsMap . putIfAbsent (  . deCapitalize ( method . getName (  )  . substring (  3  )  )  ,    method . getParameterTypes (  )  [  0  ]  )  ;", "}", "final   ModelNode   result    =    new   ModelNode (  )  ;", "for    ( Map . Entry < String ,    Type >    prop    :    methodsMap . entrySet (  )  )     {", "result . get ( prop . getKey (  )  )  . set ( prop . getValue (  )  . getTypeName (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findPropsFromCls"], "fileName": "org.jboss.as.connector.subsystems.datasources.GetDataSourceClassInfoOperationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( clz . equals ( String . class )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( byte . class )  )     |  |     ( clz . equals ( Byte . class )  )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( short . class )  )     |  |     ( clz . equals ( Short . class )  )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( int . class )  )     |  |     ( clz . equals ( Integer . class )  )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( long . class )  )     |  |     ( clz . equals ( Long . class )  )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( float . class )  )     |  |     ( clz . equals ( Float . class )  )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( double . class )  )     |  |     ( clz . equals ( Double . class )  )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( boolean . class )  )     |  |     ( clz . equals ( Boolean . class )  )  )     {", "return   true ;", "} else", "if    (  ( clz . equals ( char . class )  )     |  |     ( clz . equals ( Character . class )  )  )     {", "return   true ;", "} else", "if    ( clz . equals ( class )  )     {", "return   true ;", "} else", "if    ( clz . equals (  . class )  )     {", "return   true ;", "} else", "if    ( clz . equals ( class )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTypeMatched"], "fileName": "org.jboss.as.connector.subsystems.datasources.GetDataSourceClassInfoOperationHandler"}, {"methodBody": ["METHOD_START", "{", "List < Method >    hits    =    new   ArrayList <  >  (  )  ;", "while    (  !  ( clz . equals ( Object . class )  )  )     {", "Method [  ]    methods    =    clz . getMethods (  )  ;", "for    ( int   i    =     0  ;    i    <     ( methods . length )  ;    i +  +  )     {", "final   Method   method    =    methods [ i ]  ;", "if    (  (  (  (  (  !  ( Modifier . isStatic ( method . getModifiers (  )  )  )  )     &  &     (  ( method . getName (  )  . length (  )  )     >     3  )  )     &  &     ( method . getName (  )  . startsWith (  \" set \"  )  )  )     &  &     (  ( method . getParameterCount (  )  )     =  =     1  )  )     &  &     (  . isTypeMatched ( method . getParameterTypes (  )  [  0  ]  )  )  )", "hits . add ( method )  ;", "}", "clz    =    clz . getSuperclass (  )  ;", "}", "return   hits ;", "}", "METHOD_END"], "methodName": ["possiblePropsSetters"], "fileName": "org.jboss.as.connector.subsystems.datasources.GetDataSourceClassInfoOperationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( context . isNormalServer (  )  )     {", "context . addStep ( new   OperationStepHandler (  )     {", "public   void   execute ( OperationContext   context ,    ModelNode   operation )    throws   OperationFailedException    {", "ServiceRegistry   registry    =    context . getServiceRegistry ( false )  ;", "DriverRegistry   driverRegistry    =     (  ( DriverRegistry )     ( registry . getRequiredService ( ConnectorServices . JDBC _ DRIVER _ REGISTRY _ SERVICE )  . getValue (  )  )  )  ;", "ServiceModuleLoader   serviceModuleLoader    =     (  ( ServiceModuleLoader )     ( registry . getRequiredService ( JBOSS _ SERVICE _ MODULE _ LOADER )  . getValue (  )  )  )  ;", "Resource   rootNode    =    context . readResourceFromRoot ( EMPTY _ ADDRESS ,    false )  ;", "ModelNode   rootModel    =    rootNode . getModel (  )  ;", "String   profile    =     ( rootModel . hasDefined (  \" profile - name \"  )  )     ?    rootModel . get (  \" profile - name \"  )  . asString (  )     :    null ;", "ModelNode   result    =    context . getResult (  )  ;", "for    ( InstalledDriver   driver    :    driverRegistry . get (  )  )     {", "ModelNode   driverNode    =    new   ModelNode (  )  ;", "driverNode . get ( Constants . DRIVER _ NAME . getName (  )  )  . set ( driver . getDriverName (  )  )  ;", "if    ( driver . isFromDeployment (  )  )     {", "driverNode . get ( Constants . DEPLOYMENT _ NAME . getName (  )  )  . set ( driver . getDriverName (  )  )  ;", "driverNode . get ( Constants . DRIVER _ MODULE _ NAME . getName (  )  )  ;", "driverNode . get ( Constants . MODULE _ SLOT . getName (  )  )  ;", "driverNode . get ( Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . getName (  )  )  ;", "driverNode . get ( Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . getName (  )  )  ;", "} else    {", "driverNode . get ( Constants . DEPLOYMENT _ NAME . getName (  )  )  ;", "driverNode . get ( Constants . DRIVER _ MODULE _ NAME . getName (  )  )  . set ( driver . getModuleName (  )  . getName (  )  )  ;", "driverNode . get ( Constants . MODULE _ SLOT . getName (  )  )  . set (  (  ( driver . getModuleName (  )  )     !  =    null    ?    driver . getModuleName (  )  . getSlot (  )     :     \"  \"  )  )  ;", "driverNode . get ( Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . getName (  )  )  . set (  (  ( driver . getDataSourceClassName (  )  )     !  =    null    ?    driver . getDataSourceClassName (  )     :     \"  \"  )  )  ;", "driverNode . get ( Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . getName (  )  )  . set (  (  ( driver . getXaDataSourceClassName (  )  )     !  =    null    ?    driver . getXaDataSourceClassName (  )     :     \"  \"  )  )  ;", "}", "driverNode . get ( Constants . DATASOURCE _ CLASS _ INFO . getName (  )  )  . set ( GetDataSourceClassInfoOperationHandler . dsClsInfoNode ( serviceModuleLoader ,    driver . getModuleName (  )  ,    driver . getDataSourceClassName (  )  ,    driver . getXaDataSourceClassName (  )  )  )  ;", "driverNode . get ( Constants . DRIVER _ CLASS _ NAME . getName (  )  )  . set ( driver . getDriverClassName (  )  )  ;", "driverNode . get ( Constants . DRIVER _ MAJOR _ VERSION . getName (  )  )  . set ( driver . getMajorVersion (  )  )  ;", "driverNode . get ( Constants . DRIVER _ MINOR _ VERSION . getName (  )  )  . set ( driver . getMinorVersion (  )  )  ;", "driverNode . get ( Constants . JDBC _ COMPLIANT . getName (  )  )  . set ( driver . isJdbcCompliant (  )  )  ;", "if    ( profile    !  =    null )     {", "driverNode . get ( Constants . PROFILE . getName (  )  )  . set ( profile )  ;", "}", "result . add ( driverNode )  ;", "}", "}", "}  ,    RUNTIME )  ;", "} else    {", "context . getFailureDescription (  )  . set ( ConnectorLogger . ROOT _ LOGGER . noMetricsAvailable (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.connector.subsystems.datasources.InstalledDriversListOperationHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    operation . require ( ModelDescriptionConstants . OP _ ADDR )  ;", "final   String   driverName    =    PathAddress . pathAddress ( address )  . getLastElement (  )  . getValue (  )  ;", "if    (  ( operation . get ( Constants . DRIVER _ NAME . getName (  )  )  . isDefined (  )  )     &  &     (  !  ( driverName . equals ( operation . get ( Constants . DRIVER _ NAME . getName (  )  )  . asString (  )  )  )  )  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . driverNameAndResourceNameNotEquals ( operation . get ( Constants . DRIVER _ NAME . getName (  )  )  . asString (  )  ,    driverName )  ;", "}", "String   moduleName    =    Constants . DRIVER _ MODULE _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )  ;", "final   Integer   majorVersion    =     ( model . hasDefined ( Constants . DRIVER _ MAJOR _ VERSION . getName (  )  )  )     ?    Constants . DRIVER _ MAJOR _ VERSION . resolveModelAttribute ( context ,    model )  . asInt (  )     :    null ;", "final   Integer   minorVersion    =     ( model . hasDefined ( Constants . DRIVER _ MINOR _ VERSION . getName (  )  )  )     ?    Constants . DRIVER _ MINOR _ VERSION . resolveModelAttribute ( context ,    model )  . asInt (  )     :    null ;", "final   String   driverClassName    =     ( model . hasDefined ( Constants . DRIVER _ CLASS _ NAME . getName (  )  )  )     ?    Constants . DRIVER _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )     :    null ;", "final   String   dataSourceClassName    =     ( model . hasDefined ( Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . getName (  )  )  )     ?    Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )     :    null ;", "final   String   xaDataSourceClassName    =     ( model . hasDefined ( Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . getName (  )  )  )     ?    Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . resolveModelAttribute ( context ,    model )  . asString (  )     :    null ;", "final   ServiceTarget   target    =    context . getServiceTarget (  )  ;", "final   ModuleIdentifier   moduleId ;", "final   Module   module ;", "String   slot    =     ( model . hasDefined ( Constants . MODULE _ SLOT . getName (  )  )  )     ?    Constants . MODULE _ SLOT . resolveModelAttribute ( context ,    model )  . asString (  )     :    null ;", "try    {", "moduleId    =    ModuleIdentifier . create ( moduleName ,    slot )  ;", "module    =    Module . getCallerModuleLoader (  )  . loadModule ( moduleId )  ;", "}    catch    ( ModuleLoadException   e )     {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . failedToLoadModuleDriver ( moduleName )  ,    e )  ;", "}", "if    ( driverClassName    =  =    null )     {", "final   ServiceLoader < Driver >    serviceLoader    =    module . loadService ( Driver . class )  ;", "boolean   driverLoaded    =    false ;", "if    ( serviceLoader    !  =    null )     {", "for    ( Driver   driver    :    serviceLoader )     {", ". startDriverServices ( target ,    moduleId ,    driver ,    driverName ,    majorVersion ,    minorVersion ,    dataSourceClassName ,    xaDataSourceClassName )  ;", "driverLoaded    =    true ;", "break ;", "}", "}", "if    (  ! driverLoaded )", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . cannotFindDriverClassName ( driverName )  ;", "} else    {", "try    {", "final   Class <  ?    extends   Driver >    driverClass    =    module . getClassLoader (  )  . loadClass ( driverClassName )  . asSubclass ( Driver . class )  ;", "final   Constructor <  ?    extends   Driver >    constructor    =    driverClass . getConstructor (  )  ;", "final   Driver   driver    =    constructor . newInstance (  )  ;", ". startDriverServices ( target ,    moduleId ,    driver ,    driverName ,    majorVersion ,    minorVersion ,    dataSourceClassName ,    xaDataSourceClassName )  ;", "}    catch    ( Exception   e )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . cannotInstantiateDriverClass ( driverClassName ,    e )  ;", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . cannotInstantiateDriverClass ( driverClassName )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.jboss.as.connector.subsystems.datasources.JdbcDriverAdd"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    operation . require ( ModelDescriptionConstants . OP _ ADDR )  ;", "final   String   dName    =    PathAddress . pathAddress ( address )  . getLastElement (  )  . getValue (  )  ;", "for    ( AttributeDefinition   attribute    :    Constants . JDBC _ DRIVER _ ATTRIBUTES )     {", "if    (  !  ( attribute . getName (  )  . equals ( Constants . DRIVER _ NAME _ NAME )  )  )     {", "attribute . validateAndSet ( operation ,    model )  ;", "}", "}", "model . get ( Constants . DRIVER _ NAME . getName (  )  )  . set ( dName )  ;", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.connector.subsystems.datasources.JdbcDriverAdd"}, {"methodBody": ["METHOD_START", "{", "final   int   majorVer    =    driver . getMajorVersion (  )  ;", "final   int   minorVer    =    driver . getMinorVersion (  )  ;", "if    (  (  ( majorVersion    !  =    null )     &  &     ( majorVersion    !  =    majorVer )  )     |  |     (  ( minorVersion    !  =    null )     &  &     ( minorVersion    !  =    minorVer )  )  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . driverVersionMismatch (  )  ;", "}", "final   boolean   compliant    =    driver . jdbcCompliant (  )  ;", "if    ( compliant )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . deployingCompliant ( driver . getClass (  )  ,    majorVer ,    minorVer )  ;", "} else    {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . deployingNonCompliant ( driver . getClass (  )  ,    majorVer ,    minorVer )  ;", "}", "InstalledDriver   driverMetadata    =    new   InstalledDriver ( driverName ,    moduleId ,    driver . getClass (  )  . getName (  )  ,    dataSourceClassName ,    xaDataSourceClassName ,    majorVer ,    minorVer ,    compliant )  ;", "DriverService   driverService    =    new   DriverService ( driverMetadata ,    driver )  ;", "final   ServiceBuilder < Driver >    builder    =    target . addService ( JBOSS . append (  \" jdbc - driver \"  ,    driverName . replaceAll (  \"  \\  \\  .  \"  ,     \"  _  \"  )  )  ,    driverService )  . addDependency ( ConnectorServices . JDBC _ DRIVER _ REGISTRY _ SERVICE ,    DriverRegistry . class ,    driverService . getDriverRegistryServiceInjector (  )  )  . setInitialMode ( ACTIVE )  ;", "builder . install (  )  ;", "}", "METHOD_END"], "methodName": ["startDriverServices"], "fileName": "org.jboss.as.connector.subsystems.datasources.JdbcDriverAdd"}, {"methodBody": ["METHOD_START", "{", "final   String   driverName    =    model . get ( Constants . DRIVER _ NAME . getName (  )  )  . asString (  )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "ServiceName   jdbcServiceName    =    JBOSS . append (  \" jdbc - driver \"  ,    driverName . replaceAll (  \"  \\  \\  .  \"  ,     \"  _  \"  )  )  ;", "ServiceController <  ?  >    jdbcServiceController    =    registry . getService ( jdbcServiceName )  ;", "context . removeService ( jdbcServiceController )  ;", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.jboss.as.connector.subsystems.datasources.JdbcDriverRemove"}, {"methodBody": ["METHOD_START", "{", "final   String   driverName    =    model . require ( Constants . DRIVER _ NAME . getName (  )  )  . asString (  )  ;", "final   String   moduleName    =    model . require ( Constants . DRIVER _ MODULE _ NAME . getName (  )  )  . asString (  )  ;", "final   Integer   majorVersion    =     ( model . hasDefined ( Constants . DRIVER _ MAJOR _ VERSION . getName (  )  )  )     ?    model . get ( Constants . DRIVER _ MAJOR _ VERSION . getName (  )  )  . asInt (  )     :    null ;", "final   Integer   minorVersion    =     ( model . hasDefined ( Constants . DRIVER _ MINOR _ VERSION . getName (  )  )  )     ?    model . get ( Constants . DRIVER _ MINOR _ VERSION . getName (  )  )  . asInt (  )     :    null ;", "final   String   driverClassName    =     ( model . hasDefined ( Constants . DRIVER _ CLASS _ NAME . getName (  )  )  )     ?    model . get ( Constants . DRIVER _ CLASS _ NAME . getName (  )  )  . asString (  )     :    null ;", "final   String   dataSourceClassName    =     ( model . hasDefined ( Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . getName (  )  )  )     ?    model . get ( Constants . DRIVER _ DATASOURCE _ CLASS _ NAME . getName (  )  )  . asString (  )     :    null ;", "final   String   xaDataSourceClassName    =     ( model . hasDefined ( Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . getName (  )  )  )     ?    model . get ( Constants . DRIVER _ XA _ DATASOURCE _ CLASS _ NAME . getName (  )  )  . asString (  )     :    null ;", "final   ServiceTarget   target    =    context . getServiceTarget (  )  ;", "final   ModuleIdentifier   moduleId ;", "final   Module   module ;", "try    {", "moduleId    =    ModuleIdentifier . fromString ( moduleName )  ;", "module    =    Module . getCallerModuleLoader (  )  . loadModule ( moduleId )  ;", "}    catch    ( ModuleLoadException   e )     {", "context . getFailureDescription (  )  . set ( ConnectorLogger . ROOT _ LOGGER . failedToLoadModuleDriver ( moduleName )  )  ;", "return ;", "}", "if    ( driverClassName    =  =    null )     {", "final   ServiceLoader < Driver >    serviceLoader    =    module . loadService ( Driver . class )  ;", "if    ( serviceLoader    !  =    null )", "for    ( Driver   driver    :    serviceLoader )     {", "Add . startDriverServices ( target ,    moduleId ,    driver ,    driverName ,    majorVersion ,    minorVersion ,    dataSourceClassName ,    xaDataSourceClassName )  ;", "}", "} else    {", "try    {", "final   Class <  ?    extends   Driver >    driverClass    =    module . getClassLoader (  )  . loadClass ( driverClassName )  . asSubclass ( Driver . class )  ;", "final   Constructor <  ?    extends   Driver >    constructor    =    driverClass . getConstructor (  )  ;", "final   Driver   driver    =    constructor . newInstance (  )  ;", "Add . startDriverServices ( target ,    moduleId ,    driver ,    driverName ,    majorVersion ,    minorVersion ,    dataSourceClassName ,    xaDataSourceClassName )  ;", "}    catch    ( Exception   e )     {", "ConnectorLogger . SUBSYSTEM _ DATASOURCES _ LOGGER . cannotInstantiateDriverClass ( driverClassName ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["recoverServices"], "fileName": "org.jboss.as.connector.subsystems.datasources.JdbcDriverRemove"}, {"methodBody": ["METHOD_START", "{", "return   dataSourceConfig ;", "}", "METHOD_END"], "methodName": ["getDataSourceConfigInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.LocalDataSourceService"}, {"methodBody": ["METHOD_START", "{", "connectionProperties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addConnectionProperty"], "fileName": "org.jboss.as.connector.subsystems.datasources.ModifiableDataSource"}, {"methodBody": ["METHOD_START", "{", "this . dataSourceClass    =    dataSourceClass ;", "}", "METHOD_END"], "methodName": ["forceDataSourceClass"], "fileName": "org.jboss.as.connector.subsystems.datasources.ModifiableDataSource"}, {"methodBody": ["METHOD_START", "{", "this . driverClass    =    driverClass ;", "}", "METHOD_END"], "methodName": ["forceDriverClass"], "fileName": "org.jboss.as.connector.subsystems.datasources.ModifiableDataSource"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSourceImpl ( connectionUrl ,    driverClass ,    dataSourceClass ,    driver ,    transactionIsolation ,    connectionProperties ,    timeOut ,    security ,    statement ,    validation ,    urlDelimiter ,    urlSelectorStrategyClassName ,    newConnectionSql ,    useJavaContext ,    poolName ,    enabled ,    jndiName ,    spy ,    useCcm ,    jta ,    connectable ,    tracking ,    mcp ,    enlistmentTrace ,    pool )  ;", "}", "METHOD_END"], "methodName": ["getUnModifiableInstance"], "fileName": "org.jboss.as.connector.subsystems.datasources.ModifiableDataSource"}, {"methodBody": ["METHOD_START", "{", "return   jta ;", "}", "METHOD_END"], "methodName": ["isJTA"], "fileName": "org.jboss.as.connector.subsystems.datasources.ModifiableDataSource"}, {"methodBody": ["METHOD_START", "{", "xaDataSourceProperty . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addXaDataSourceProperty"], "fileName": "org.jboss.as.connector.subsystems.datasources.ModifiableXaDataSource"}, {"methodBody": ["METHOD_START", "{", "return   new   XADataSourceImpl ( transactionIsolation ,    timeOut ,    security ,    statement ,    validation ,    urlDelimiter ,    urlProperty ,    urlSelectorStrategyClassName ,    useJavaContext ,    poolName ,    enabled ,    jndiName ,    spy ,    useCcm ,    connectable ,    tracking ,    mcp ,    enlistmentTrace ,    xaDataSourceProperty ,    xaDataSourceClass ,    driver ,    newConnectionSql ,    getXaPool (  )  ,    recovery )  ;", "}", "METHOD_END"], "methodName": ["getUnModifiableInstance"], "fileName": "org.jboss.as.connector.subsystems.datasources.ModifiableXaDataSource"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.connector.subsystems.datasources.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.connector.subsystems.datasources.Namespace"}, {"methodBody": ["METHOD_START", "{", "final   String   jndiName ;", "if    (  (  !  ( rawJndiName . startsWith (  \" java :  \"  )  )  )     &  &    useJavaContext )     {", "if    ( rawJndiName . startsWith (  \"  /  \"  )  )     {", "jndiName    =     \" java :  \"     +    rawJndiName ;", "} else    {", "jndiName    =     \" java :  /  \"     +    rawJndiName ;", "}", "} else    {", "jndiName    =    rawJndiName ;", "}", "return   jndiName ;", "}", "METHOD_END"], "methodName": ["cleanJndiName"], "fileName": "org.jboss.as.connector.subsystems.datasources.Util"}, {"methodBody": ["METHOD_START", "{", "final   String   rawJndiName    =    Constants . JNDI _ NAME . resolveModelAttribute ( context ,    modelNode )  . asString (  )  ;", "return    . cleanJndiName ( rawJndiName ,     (  ( modelNode . hasDefined ( Constants . USE _ JAVA _ CONTEXT . getName (  )  )  )     &  &     ( modelNode . get ( Constants . USE _ JAVA _ CONTEXT . getName (  )  )  . asBoolean (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getJndiName"], "fileName": "org.jboss.as.connector.subsystems.datasources.Util"}, {"methodBody": ["METHOD_START", "{", "in . defaultReadObject (  )  ;", "jndiName    =     (  ( String )     ( in . readObject (  )  )  )  ;", "try    {", "InitialContext   context    =    new   InitialContext (  )  ;", "originalDs    =     (  (  )     ( context . lookup ( jndiName )  )  )  ;", "this . delegate    =    originalDs ;", "}    catch    ( Exception   e )     {", "throw   new   IOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.jboss.as.connector.subsystems.datasources.WildFlyDataSource"}, {"methodBody": ["METHOD_START", "{", "out . defaultWriteObject (  )  ;", "out . writeObject ( jndiName )  ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.jboss.as.connector.subsystems.datasources.WildFlyDataSource"}, {"methodBody": ["METHOD_START", "{", "return   new   ConcurrentMapInjector ( xaDataSourceProperties ,    key )  ;", "}", "METHOD_END"], "methodName": ["getXaDataSourcePropertyInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.XADataSourceConfigService"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    String >    xaDataSourceProperty    :    xaDataSourceProperties . entrySet (  )  )     {", "d . addXaDataSourceProperty ( xaDataSourceProperty . getKey (  )  ,    xaDataSourceProperty . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.jboss.as.connector.subsystems.datasources.XADataSourceConfigService"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeName . equals ( Constants . CONNECTION _ URL . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getConnectionUrl (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . CONNECTION _ PROPERTIES . getName (  )  )  )     {", "final   Map < String ,    String >    propertiesMap    =    dataSource . getConnectionProperties (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . DRIVER _ CLASS . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getDriverClass (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . DATASOURCE _ CLASS . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getDataSourceClass (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . JNDI _ NAME . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getJndiName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . DATASOURCE _ DRIVER . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getDriver (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . NEW _ CONNECTION _ SQL . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getNewConnectionSql (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . URL _ DELIMITER . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getUrlDelimiter (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getUrlSelectorStrategyClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . USE _ JAVA _ CONTEXT . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isUseJavaContext (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . JTA . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isJTA (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ENABLED . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isEnabled (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . MAX _ POOL _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getPool (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getPool (  )  . getMaxPoolSize (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . INITIAL _ POOL _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getPool (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getPool (  )  . getInitialPoolSize (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . MIN _ POOL _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getPool (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getPool (  )  . getMinPoolSize (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ PREFILL . getName (  )  )  )     {", "if    (  ( dataSource . getPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getPool (  )  . isPrefill (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ FAIR . getName (  )  )  )     {", "if    (  ( dataSource . getPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getPool (  )  . isFair (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ USE _ STRICT _ MIN . getName (  )  )  )     {", "if    (  ( dataSource . getPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getPool (  )  . isUseStrictMin (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS . getName (  )  )  )     {", "if    (  (  (  ( dataSource . getPool (  )  )     =  =    null )     |  |     (  ( dataSource . getPool (  )  . getCapacity (  )  )     =  =    null )  )     |  |     (  ( dataSource . getPool (  )  . getCapacity (  )  . getIncrementer (  )  )     =  =    null )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getPool (  )  . getCapacity (  )  . getIncrementer (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS . getName (  )  )  )     {", "if    (  (  (  ( dataSource . getPool (  )  )     =  =    null )     |  |     (  ( dataSource . getPool (  )  . getCapacity (  )  )     =  =    null )  )     |  |     (  ( dataSource . getPool (  )  . getCapacity (  )  . getDecrementer (  )  )     =  =    null )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getPool (  )  . getCapacity (  )  . getDecrementer (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES . getName (  )  )  )     {", "Pool   pool    =    dataSource . getPool (  )  ;", "if    (  (  ( pool    =  =    null )     |  |     (  ( pool . getCapacity (  )  )     =  =    null )  )     |  |     (  ( pool . getCapacity (  )  . getIncrementer (  )  )     =  =    null )  )", "return ;", "final   Map < String ,    String >    propertiesMap    =    pool . getCapacity (  )  . getIncrementer (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES . getName (  )  )  )     {", "Pool   pool    =    dataSource . getPool (  )  ;", "if    (  (  ( pool    =  =    null )     |  |     (  ( pool . getCapacity (  )  )     =  =    null )  )     |  |     (  ( pool . getCapacity (  )  . getDecrementer (  )  )     =  =    null )  )", "return ;", "final   Map < String ,    String >    propertiesMap    =    pool . getCapacity (  )  . getDecrementer (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . USERNAME . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getUserName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . PASSWORD . getName (  )  )  )     {", "} else", "if    ( attributeName . equals ( Constants . CREDENTIAL _ REFERENCE . getName (  )  )  )     {", "} else", "if    ( attributeName . equals ( Constants . SECURITY _ DOMAIN . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getSecurity (  )  )    instanceof   DsSecurity ;", "if    (  (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getSecurityDomain (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ELYTRON _ ENABLED . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getSecurity (  )  )    instanceof   DsSecurity ;", "if    (  !  (  (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )  )     {", "return ;", "}", "setBooleanIfNotNull ( context ,     (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . AUTHENTICATION _ CONTEXT . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getSecurity (  )  )    instanceof   DsSecurity ;", "if    (  !  (  (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getSecurityDomain (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . REAUTH _ PLUGIN _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getSecurity (  )  . getReauthPlugin (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getReauthPlugin (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . REAUTHPLUGIN _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getSecurity (  )  . getReauthPlugin (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getSecurity (  )  . getReauthPlugin (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ FLUSH _ STRATEGY . getName (  )  )  )     {", "if    (  ( dataSource . getPool (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getPool (  )  . getFlushStrategy (  )  . getName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . PREPARED _ STATEMENTS _ CACHE _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getStatement (  )  . getPreparedStatementsCacheSize (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SHARE _ PREPARED _ STATEMENTS . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getStatement (  )  . isSharePreparedStatements (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . TRACK _ STATEMENTS . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getStatement (  )  . getTrackStatements (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getStatement (  )  . getTrackStatements (  )  . name (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOCATION _ RETRY . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getTimeOut (  )  . getAllocationRetry (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getAllocationRetryWaitMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getBlockingTimeoutMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . IDLETIMEOUTMINUTES . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getIdleTimeoutMinutes (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . QUERY _ TIMEOUT . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getQueryTimeout (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . USE _ TRY _ LOCK . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getUseTryLock (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SET _ TX _ QUERY _ TIMEOUT . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getTimeOut (  )  . isSetTxQueryTimeout (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . TRANSACTION _ ISOLATION . getName (  )  )  )     {", "if    (  ( dataSource . getTransactionIsolation (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getTransactionIsolation (  )  . name (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . CHECK _ VALID _ CONNECTION _ SQL . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getCheckValidConnectionSql (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . EXCEPTION _ SORTER _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getExceptionSorter (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getExceptionSorter (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . EXCEPTION _ SORTER _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getExceptionSorter (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getValidation (  )  . getExceptionSorter (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . STALE _ CONNECTION _ CHECKER _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getStaleConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getStaleConnectionChecker (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . STALE _ CONNECTION _ CHECKER _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getStaleConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getValidation (  )  . getStaleConnectionChecker (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . VALID _ CONNECTION _ CHECKER _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getValidConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getValidConnectionChecker (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . VALID _ CONNECTION _ CHECKER _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getValidConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getValidation (  )  . getValidConnectionChecker (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( common . pool . Constants . BACKGROUNDVALIDATIONMILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getValidation (  )  . getBackgroundValidationMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . BACKGROUNDVALIDATION . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getValidation (  )  . isBackgroundValidation (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . USE _ FAST _ FAIL . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getValidation (  )  . isUseFastFail (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . VALIDATE _ ON _ MATCH . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getValidation (  )  . isValidateOnMatch (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SPY . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isSpy (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . USE _ CCM . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isUseCcm (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOW _ MULTIPLE _ USERS . getName (  )  )  )     {", "Pool   pool    =    dataSource . getPool (  )  ;", "if    (  !  ( pool   instanceof   DsPool )  )     {", "return ;", "}", "setBooleanIfNotNull ( context ,     (  ( DsPool )     ( pool )  )  . isAllowMultipleUsers (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . CONNECTION _ LISTENER _ CLASS . getName (  )  )  )     {", "Pool   pool    =    dataSource . getPool (  )  ;", "if    (  (  !  ( pool   instanceof   DsPool )  )     |  |     (  (  (  ( DsPool )     ( pool )  )  . getConnectionListener (  )  )     =  =    null )  )     {", "return ;", "}", "setStringIfNotNull ( context ,     (  ( DsPool )     ( pool )  )  . getConnectionListener (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . CONNECTION _ LISTENER _ PROPERTIES . getName (  )  )  )     {", "Pool   pool    =    dataSource . getPool (  )  ;", "if    (  (  !  ( pool   instanceof   DsPool )  )     |  |     (  (  (  ( DsPool )     ( pool )  )  . getConnectionListener (  )  )     =  =    null )  )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =     (  ( DsPool )     ( pool )  )  . getConnectionListener (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . CONNECTABLE . getName (  )  )  )     {", "context . getResult (  )  . set ( false )  ;", "} else", "if    ( attributeName . equals ( Constants . STATISTICS _ ENABLED . getName (  )  )  )     {", "context . getResult (  )  . set ( false )  ;", "} else", "if    ( attributeName . equals ( Constants . TRACKING . getName (  )  )  )     {", "return ;", "} else", "if    ( attributeName . equals ( Constants . MCP . getName (  )  )  )     {", "return ;", "} else", "if    ( attributeName . equals ( Constants . ENLISTMENT _ TRACE . getName (  )  )  )     {", "return ;", "} else    {", "throw   unknownAttribute ( attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["handleDatasourceAttribute"], "fileName": "org.jboss.as.connector.subsystems.datasources.XMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeName . equals ( VALUE )  )     {", "setStringIfNotNull ( context ,    d . getConnectionProperties (  )  . get ( propName )  )  ;", "} else    {", "throw   ConnectorLogger . ROOT _ LOGGER . unknownAttribute ( attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["handlePropertyAttribute"], "fileName": "org.jboss.as.connector.subsystems.datasources.XMLDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeName . equals ( Constants . XA _ DATASOURCE _ CLASS . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getXaDataSourceClass (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . JNDI _ NAME . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getJndiName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . DATASOURCE _ DRIVER . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getDriver (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . NEW _ CONNECTION _ SQL . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getNewConnectionSql (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . URL _ DELIMITER . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getUrlDelimiter (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . URL _ PROPERTY . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getUrlProperty (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . URL _ SELECTOR _ STRATEGY _ CLASS _ NAME . getName (  )  )  )     {", "setStringIfNotNull ( context ,    dataSource . getUrlSelectorStrategyClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . USE _ JAVA _ CONTEXT . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isUseJavaContext (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ENABLED . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isEnabled (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . MAX _ POOL _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getXaPool (  )  . getMaxPoolSize (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . INITIAL _ POOL _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getXaPool (  )  . getInitialPoolSize (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . MIN _ POOL _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getXaPool (  )  . getMinPoolSize (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ PREFILL . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isPrefill (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ FAIR . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isFair (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ USE _ STRICT _ MIN . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isUseStrictMin (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . POOL _ FLUSH _ STRATEGY . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getXaPool (  )  . getFlushStrategy (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getXaPool (  )  . getFlushStrategy (  )  . getName (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS . getName (  )  )  )     {", "if    (  (  (  ( dataSource . getXaPool (  )  )     =  =    null )     |  |     (  ( dataSource . getXaPool (  )  . getCapacity (  )  )     =  =    null )  )     |  |     (  ( dataSource . getXaPool (  )  . getCapacity (  )  . getIncrementer (  )  )     =  =    null )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getXaPool (  )  . getCapacity (  )  . getIncrementer (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS . getName (  )  )  )     {", "if    (  (  (  ( dataSource . getXaPool (  )  )     =  =    null )     |  |     (  ( dataSource . getXaPool (  )  . getCapacity (  )  )     =  =    null )  )     |  |     (  ( dataSource . getXaPool (  )  . getCapacity (  )  . getDecrementer (  )  )     =  =    null )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getXaPool (  )  . getCapacity (  )  . getDecrementer (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES . getName (  )  )  )     {", "XaPool   pool    =    dataSource . getXaPool (  )  ;", "if    (  (  ( pool    =  =    null )     |  |     (  ( pool . getCapacity (  )  )     =  =    null )  )     |  |     (  ( pool . getCapacity (  )  . getIncrementer (  )  )     =  =    null )  )", "return ;", "final   Map < String ,    String >    propertiesMap    =    pool . getCapacity (  )  . getIncrementer (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES . getName (  )  )  )     {", "XaPool   pool    =    dataSource . getXaPool (  )  ;", "if    (  (  ( pool    =  =    null )     |  |     (  ( pool . getCapacity (  )  )     =  =    null )  )     |  |     (  ( pool . getCapacity (  )  . getDecrementer (  )  )     =  =    null )  )", "return ;", "final   Map < String ,    String >    propertiesMap    =    pool . getCapacity (  )  . getDecrementer (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . INTERLEAVING . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isInterleaving (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . NO _ TX _ SEPARATE _ POOL . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isNoTxSeparatePool (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . PAD _ XID . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isPadXid (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SAME _ RM _ OVERRIDE . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isSameRmOverride (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . WRAP _ XA _ RESOURCE . getName (  )  )  )     {", "if    (  ( dataSource . getXaPool (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getXaPool (  )  . isWrapXaResource (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . PREPARED _ STATEMENTS _ CACHE _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getStatement (  )  . getPreparedStatementsCacheSize (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SHARE _ PREPARED _ STATEMENTS . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getStatement (  )  . isSharePreparedStatements (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . TRACK _ STATEMENTS . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getStatement (  )  . getTrackStatements (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getStatement (  )  . getTrackStatements (  )  . name (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOCATION _ RETRY . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getTimeOut (  )  . getAllocationRetry (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getAllocationRetryWaitMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getBlockingTimeoutMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . IDLETIMEOUTMINUTES . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getIdleTimeoutMinutes (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . XA _ RESOURCE _ TIMEOUT . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getTimeOut (  )  . getXaResourceTimeout (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . RECOVERY _ USERNAME . getName (  )  )  )     {", "if    (  ( dataSource . getRecovery (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getRecovery (  )  . getCredential (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getRecovery (  )  . getCredential (  )  . getUserName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . RECOVERY _ PASSWORD . getName (  )  )  )     {", "} else", "if    ( attributeName . equals ( Constants . RECOVERY _ SECURITY _ DOMAIN . getName (  )  )  )     {", "if    (  ( dataSource . getRecovery (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getRecovery (  )  . getCredential (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getRecovery (  )  . getCredential (  )  )    instanceof   Credential ;", "if    (  (  ( Credential )     ( dataSource . getRecovery (  )  . getCredential (  )  )  )  . isElytronEnabled (  )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getRecovery (  )  . getCredential (  )  . getSecurityDomain (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . RECOVERY _ ELYTRON _ ENABLED . getName (  )  )  )     {", "if    (  ( dataSource . getRecovery (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getRecovery (  )  . getCredential (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getRecovery (  )  . getCredential (  )  )    instanceof   Credential ;", "if    (  !  (  (  ( Credential )     ( dataSource . getRecovery (  )  . getCredential (  )  )  )  . isElytronEnabled (  )  )  )     {", "return ;", "}", "setBooleanIfNotNull ( context ,     (  ( Credential )     ( dataSource . getRecovery (  )  . getCredential (  )  )  )  . isElytronEnabled (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . RECOVERY _ CREDENTIAL _ REFERENCE . getName (  )  )  )     {", "} else", "if    ( attributeName . equals ( Constants . RECOVERY _ AUTHENTICATION _ CONTEXT . getName (  )  )  )     {", "if    (  ( dataSource . getRecovery (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getRecovery (  )  . getCredential (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getRecovery (  )  . getCredential (  )  )    instanceof   Credential ;", "if    (  !  (  (  ( Credential )     ( dataSource . getRecovery (  )  . getCredential (  )  )  )  . isElytronEnabled (  )  )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getRecovery (  )  . getCredential (  )  . getSecurityDomain (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . RECOVER _ PLUGIN _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getRecovery (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getRecovery (  )  . getRecoverPlugin (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getRecovery (  )  . getRecoverPlugin (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . RECOVER _ PLUGIN _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getRecovery (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getRecovery (  )  . getRecoverPlugin (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getRecovery (  )  . getRecoverPlugin (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . NO _ RECOVERY . getName (  )  )  )     {", "if    (  ( dataSource . getRecovery (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getRecovery (  )  . getNoRecovery (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . CHECK _ VALID _ CONNECTION _ SQL . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getCheckValidConnectionSql (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . EXCEPTION _ SORTER _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getExceptionSorter (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getExceptionSorter (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . EXCEPTION _ SORTER _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getExceptionSorter (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getValidation (  )  . getExceptionSorter (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . STALE _ CONNECTION _ CHECKER _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getStaleConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getStaleConnectionChecker (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . STALE _ CONNECTION _ CHECKER _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getStaleConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getValidation (  )  . getStaleConnectionChecker (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . VALID _ CONNECTION _ CHECKER _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getValidConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getValidation (  )  . getValidConnectionChecker (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . VALID _ CONNECTION _ CHECKER _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getValidation (  )  . getValidConnectionChecker (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getValidation (  )  . getValidConnectionChecker (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( common . pool . Constants . BACKGROUNDVALIDATIONMILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getValidation (  )  . getBackgroundValidationMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . BACKGROUNDVALIDATION . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getValidation (  )  . isBackgroundValidation (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . USE _ FAST _ FAIL . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getValidation (  )  . isUseFastFail (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . VALIDATE _ ON _ MATCH . getName (  )  )  )     {", "if    (  ( dataSource . getValidation (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getValidation (  )  . isValidateOnMatch (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . USERNAME . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getUserName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . PASSWORD . getName (  )  )  )     {", "} else", "if    ( attributeName . equals ( Constants . CREDENTIAL _ REFERENCE . getName (  )  )  )     {", "} else", "if    ( attributeName . equals ( Constants . SECURITY _ DOMAIN . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getSecurity (  )  )    instanceof   DsSecurity ;", "if    (  (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getSecurityDomain (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ELYTRON _ ENABLED . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getSecurity (  )  )    instanceof   DsSecurity ;", "if    (  !  (  (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )  )     {", "return ;", "}", "setBooleanIfNotNull ( context ,     (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . AUTHENTICATION _ CONTEXT . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "assert    ( dataSource . getSecurity (  )  )    instanceof   DsSecurity ;", "if    (  !  (  (  ( DsSecurity )     ( dataSource . getSecurity (  )  )  )  . isElytronEnabled (  )  )  )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getSecurityDomain (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . REAUTH _ PLUGIN _ CLASSNAME . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getSecurity (  )  . getReauthPlugin (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getSecurity (  )  . getReauthPlugin (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . REAUTHPLUGIN _ PROPERTIES . getName (  )  )  )     {", "if    (  ( dataSource . getSecurity (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getSecurity (  )  . getReauthPlugin (  )  )     =  =    null )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =    dataSource . getSecurity (  )  . getReauthPlugin (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . PREPARED _ STATEMENTS _ CACHE _ SIZE . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getStatement (  )  . getPreparedStatementsCacheSize (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SHARE _ PREPARED _ STATEMENTS . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getStatement (  )  . isSharePreparedStatements (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . TRACK _ STATEMENTS . getName (  )  )  )     {", "if    (  ( dataSource . getStatement (  )  )     =  =    null )     {", "return ;", "}", "if    (  ( dataSource . getStatement (  )  . getTrackStatements (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getStatement (  )  . getTrackStatements (  )  . name (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOCATION _ RETRY . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setIntIfNotNull ( context ,    dataSource . getTimeOut (  )  . getAllocationRetry (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getAllocationRetryWaitMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getBlockingTimeoutMillis (  )  )  ;", "} else", "if    ( attributeName . equals ( common . pool . Constants . IDLETIMEOUTMINUTES . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getIdleTimeoutMinutes (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . QUERY _ TIMEOUT . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getQueryTimeout (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . USE _ TRY _ LOCK . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setLongIfNotNull ( context ,    dataSource . getTimeOut (  )  . getUseTryLock (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SET _ TX _ QUERY _ TIMEOUT . getName (  )  )  )     {", "if    (  ( dataSource . getTimeOut (  )  )     =  =    null )     {", "return ;", "}", "setBooleanIfNotNull ( context ,    dataSource . getTimeOut (  )  . isSetTxQueryTimeout (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . TRANSACTION _ ISOLATION . getName (  )  )  )     {", "if    (  ( dataSource . getTransactionIsolation (  )  )     =  =    null )     {", "return ;", "}", "setStringIfNotNull ( context ,    dataSource . getTransactionIsolation (  )  . name (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . SPY . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isSpy (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . USE _ CCM . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    dataSource . isUseCcm (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . JTA . getName (  )  )  )     {", "setBooleanIfNotNull ( context ,    true )  ;", "} else", "if    ( attributeName . equals ( Constants . ALLOW _ MULTIPLE _ USERS . getName (  )  )  )     {", "XaPool   pool    =    dataSource . getXaPool (  )  ;", "if    (  !  ( pool   instanceof   DsXaPool )  )     {", "return ;", "}", "setBooleanIfNotNull ( context ,     (  ( DsXaPool )     ( pool )  )  . isAllowMultipleUsers (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . CONNECTION _ LISTENER _ CLASS . getName (  )  )  )     {", "XaPool   pool    =    dataSource . getXaPool (  )  ;", "if    (  (  !  ( pool   instanceof   DsXaPool )  )     |  |     (  (  (  ( DsXaPool )     ( pool )  )  . getConnectionListener (  )  )     =  =    null )  )     {", "return ;", "}", "setStringIfNotNull ( context ,     (  ( DsXaPool )     ( pool )  )  . getConnectionListener (  )  . getClassName (  )  )  ;", "} else", "if    ( attributeName . equals ( Constants . CONNECTION _ LISTENER _ PROPERTIES . getName (  )  )  )     {", "XaPool   pool    =    dataSource . getXaPool (  )  ;", "if    (  (  !  ( pool   instanceof   DsXaPool )  )     |  |     (  (  (  ( DsXaPool )     ( pool )  )  . getConnectionListener (  )  )     =  =    null )  )     {", "return ;", "}", "final   Map < String ,    String >    propertiesMap    =     (  ( DsXaPool )     ( pool )  )  . getConnectionListener (  )  . getConfigPropertiesMap (  )  ;", "if    ( propertiesMap    =  =    null )     {", "return ;", "}", "for    ( final   Entry < String ,    String >    entry    :    propertiesMap . entrySet (  )  )     {", "context . getResult (  )  . asPropertyList (  )  . add ( new   ModelNode (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  . asProperty (  )  )  ;", "}", "} else", "if    ( attributeName . equals ( Constants . CONNECTABLE . getName (  )  )  )     {", "context . getResult (  )  . set ( false )  ;", "} else", "if    ( attributeName . equals ( Constants . STATISTICS _ ENABLED . getName (  )  )  )     {", "context . getResult (  )  . set ( false )  ;", "} else", "if    ( attributeName . equals ( Constants . TRACKING . getName (  )  )  )     {", "return ;", "} else", "if    ( attributeName . equals ( Constants . MCP . getName (  )  )  )     {", "return ;", "} else", "if    ( attributeName . equals ( Constants . ENLISTMENT _ TRACE . getName (  )  )  )     {", "return ;", "} else    {", "throw   unknownAttribute ( attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["handleDatasourceAttribute"], "fileName": "org.jboss.as.connector.subsystems.datasources.XMLXaDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeName . equals ( VALUE )  )     {", "setStringIfNotNull ( context ,    dataSource . getProperty (  )  . get ( propName )  )  ;", "} else    {", "throw   ConnectorLogger . ROOT _ LOGGER . unknownAttribute ( attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["handlePropertyAttribute"], "fileName": "org.jboss.as.connector.subsystems.datasources.XMLXaDataSourceRuntimeHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   XaDataSourceService ( dsName ,    ContextNames . bindInfoFor ( jndiName )  )  ;", "}", "METHOD_END"], "methodName": ["createDataSourceService"], "fileName": "org.jboss.as.connector.subsystems.datasources.XaDataSourceAdd"}, {"methodBody": ["METHOD_START", "{", "return   new   XaDataSourceDefinition ( registerRuntimeOnly ,    deployed )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.connector.subsystems.datasources.XaDataSourceDefinition"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.jboss.as.connector.subsystems.datasources.XaDataSourcePropertiesService"}, {"methodBody": ["METHOD_START", "{", "return   dataSourceConfig ;", "}", "METHOD_END"], "methodName": ["getDataSourceConfigInjector"], "fileName": "org.jboss.as.connector.subsystems.datasources.XaDataSourceService"}, {"methodBody": ["METHOD_START", "{", "return   jcaConfig ;", "}", "METHOD_END"], "methodName": ["getJcaConfigInjector"], "fileName": "org.jboss.as.connector.subsystems.jca.ArchiveValidationService"}, {"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.connector.subsystems.jca.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.connector.subsystems.jca.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   jcaConfig ;", "}", "METHOD_END"], "methodName": ["getJcaConfigInjector"], "fileName": "org.jboss.as.connector.subsystems.jca.BeanValidationService"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.connector.subsystems.jca.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.connector.subsystems.jca.Element"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   builder    =    parentBuilder . addChildResource ( JcaCachedConnectionManagerDefinition . PATH _ CACHED _ CONNECTION _ MANAGER )  ;", "builder . getAttributeBuilder (  )  . setDiscard ( ALWAYS ,    JcaCachedConnectionManagerDefinition . CcmParameters . IGNORE _ UNKNOWN _ CONNECTIONS . getAttribute (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers110"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaCachedConnectionManagerDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   JcaDistributedWorkManagerDefinition ( registerRuntimeOnly )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaDistributedWorkManagerDefinition"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder ( JcaExtension . SUBSYSTEM _ NAME )  ;", "for    ( String   kp    :    keyPrefix )     {", "prefix . append (  '  .  '  )  . append ( kp )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,    JcaExtension . RESOURCE _ NAME ,    JcaExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaExtension"}, {"methodBody": ["METHOD_START", "{", "context . removeService ( ConnectorServices . CONNECTOR _ CONFIG _ SERVICE )  ;", "}", "METHOD_END"], "methodName": ["performRuntime"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubSystemRemove"}, {"methodBody": ["METHOD_START", "{", "final   boolean   appclient    =     ( context . getProcessType (  )  )     =  =     ( ProcessType . APPLICATION _ CLIENT )  ;", "final   RaDeploymentActivator   raDeploymentActivator    =    new   RaDeploymentActivator ( appclient )  ;", "context . addStep ( new   AbstractDeploymentChainStep (  )     {", "protected   void   execute ( DeploymentProcessorTarget   processorTarget )     {", "raDeploymentActivator . activateProcessors ( processorTarget )  ;", "}", "}  ,    RUNTIME )  ;", "ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "TransactionIntegrationService   tiService    =    new   TransactionIntegrationService (  )  ;", "serviceTarget . addService ( ConnectorServices . TRANSACTION _ INTEGRATION _ SERVICE ,    tiService )  . addDependency ( JBOSS _ TXN _ TRANSACTION _ MANAGER ,    TransactionManager . class ,    tiService . getTmInjector (  )  )  . addDependency ( JBOSS _ TXN _ SYNCHRONIZATION _ REGISTRY ,    TransactionSynchronizationRegistry . class ,    tiService . getTsrInjector (  )  )  . addDependency ( JBOSS _ TXN _ USER _ TRANSACTION _ REGISTRY ,    UserTransactionRegistry . class ,    tiService . getUtrInjector (  )  )  . addDependency ( JBOSS _ TXN _ CONTEXT _ XA _ TERMINATOR ,    JBossContextXATerminator . class ,    tiService . getTerminatorInjector (  )  )  . addDependency ( JBOSS _ TXN _ ARJUNA _ RECOVERY _ MANAGER ,    XAResourceRecoveryRegistry . class ,    tiService . getRrInjector (  )  )  . setInitialMode ( ACTIVE )  . install (  )  ;", "final   Configuration   config    =    new   Configuration (  )  ;", "final   JcaConfigService   connectorConfigService    =    new   JcaConfigService ( config )  ;", "serviceTarget . addService ( ConnectorServices . CONNECTOR _ CONFIG _ SERVICE ,    connectorConfigService )  . setInitialMode ( Mode . ACTIVE )  . install (  )  ;", "final   IdleRemoverService   idleRemoverService    =    new   IdleRemoverService (  )  ;", "serviceTarget . addService ( ConnectorServices . IDLE _ REMOVER _ SERVICE ,    idleRemoverService )  . setInitialMode ( Mode . ACTIVE )  . install (  )  ;", "final   ConnectionValidatorService   connectionValidatorService    =    new   ConnectionValidatorService (  )  ;", "serviceTarget . addService ( ConnectorServices . CONNECTION _ VALIDATOR _ SERVICE ,    connectionValidatorService )  . setInitialMode ( Mode . ACTIVE )  . install (  )  ;", "final   DriverRegistryService   driverRegistryService    =    new   DriverRegistryService (  )  ;", "serviceTarget . addService ( ConnectorServices . JDBC _ DRIVER _ REGISTRY _ SERVICE ,    driverRegistryService )  . install (  )  ;", "raDeploymentActivator . activateServices ( serviceTarget )  ;", "}", "METHOD_END"], "methodName": ["performBoottime"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "return   archiveValidation . get (  )  ;", "}", "METHOD_END"], "methodName": ["getArchiveValidation"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   archiveValidationFailOnError . get (  )  ;", "}", "METHOD_END"], "methodName": ["getArchiveValidationFailOnError"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   archiveValidationFailOnWarn . get (  )  ;", "}", "METHOD_END"], "methodName": ["getArchiveValidationFailOnWarn"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   beanValidation . get (  )  ;", "}", "METHOD_END"], "methodName": ["getBeanValidation"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   Tracer . isEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["getTracer"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "archiveValidation . set ( value )  ;", "}", "METHOD_END"], "methodName": ["setArchiveValidation"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "archiveValidationFailOnError . set ( value )  ;", "}", "METHOD_END"], "methodName": ["setArchiveValidationFailOnError"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "archiveValidationFailOnWarn . set ( value )  ;", "}", "METHOD_END"], "methodName": ["setArchiveValidationFailOnWarn"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "beanValidation . set ( value )  ;", "}", "METHOD_END"], "methodName": ["setBeanValidation"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "Tracer . setEnabled ( value )  ;", "}", "METHOD_END"], "methodName": ["setTracer"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   JcaSubsystemRootDefinition ( registerRuntimeOnly )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemRootDefinition"}, {"methodBody": ["METHOD_START", "{", "String   xml    =    readResource (  \" jca - minimal . xml \"  )  ;", "final   KernelServices   services    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setXml ( xml )  . build (  )  ;", "assertTrue (  \"    boot   failed !  \"  ,    services . isSuccessfulBoot (  )  )  ;", "final   ModelNode   model    =    services . readWholeModel (  )  ;", "ModelNode   ccm    =    model . get (  \" subsystem \"  ,     \" jca \"  ,     \" cached - connection - manager \"  ,     \" cached - connection - manager \"  )  ;", "assertTrue ( ccm . isDefined (  )  )  ;", "assertTrue ( ccm . hasDefined (  \" install \"  )  )  ;", "PathAddress   ccmAddress    =    PathAddress . pathAddress (  \" subsystem \"  ,     \" jca \"  )  . append (  \" cached - connection - manager \"  ,     \" cached - connection - manager \"  )  ;", "ModelNode   writeOp    =    Util . getWriteAttributeOperation ( ccmAddress ,     \" install \"  ,    true )  ;", "services . executeForResult ( writeOp )  ;", "ModelNode   readOp    =    Util . getReadAttributeOperation ( ccmAddress ,     \" install \"  )  ;", "ModelNode   result    =    services . executeForResult ( readOp )  ;", "assertTrue ( result . asBoolean (  )  )  ;", "ModelNode   removeOp    =    Util . createRemoveOperation ( ccmAddress )  ;", "services . executeForResult ( removeOp )  ;", "result    =    services . executeForResult ( readOp )  ;", "assertFalse ( result . asBoolean (  )  )  ;", "services . executeForResult ( writeOp )  ;", "ModelNode   addOp    =    Util . createAddOperation ( ccmAddress )  ;", "addOp . get (  \" debug \"  )  . set ( true )  ;", "services . executeForFailure ( addOp )  ;", "ModelNode   undefineOp    =    Util . createEmptyOperation (  \" undefine - attribute \"  ,    ccmAddress )  ;", "undefineOp . get (  \" name \"  )  . set (  \" install \"  )  ;", "services . executeForResult ( undefineOp )  ;", "result    =    services . executeForResult ( readOp )  ;", "assertFalse ( result . asBoolean (  )  )  ;", "services . executeForResult ( addOp )  ;", "ModelNode   readOp 2     =    Util . getReadAttributeOperation ( ccmAddress ,     \" debug \"  )  ;", "result    =    services . executeForResult ( readOp 2  )  ;", "assertTrue ( result . asBoolean (  )  )  ;", "services . executeForFailure ( addOp )  ;", "services . executeForResult ( removeOp )  ;", "result    =    services . executeForResult ( readOp 2  )  ;", "assertFalse ( result . asBoolean (  )  )  ;", "services . executeForResult ( addOp )  ;", "result    =    services . executeForResult ( readOp 2  )  ;", "assertTrue ( result . asBoolean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCCMHandling"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" jca - full - expression . xml \"  ,     \" jca - full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressionConfig"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" jca - full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFullConfig"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  (  ( controllerVersion . getMavenGroupId (  )  )     +     \"  : wildfly - connector :  \"  )     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  (  ( controllerVersion . getCoreMavenGroupId (  )  )     +     \"  : wildfly - threads :  \"  )     +     ( controllerVersion . getCoreVersion (  )  )  )  )  . setExtensionClassName (  \" Extension \"  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertNotNull ( legacyServices )  ;", "assertTrue (  \" main   services   did   not   boot \"  ,    mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    xmlOps    =    builder . parseXmlResource ( xmlResourceName )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    xmlOps ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( JcaSubsystemRootDefinition . PATH _ SUBSYSTEM ,    JcaDistributedWorkManagerDefinition . PATH _ DISTRIBUTED _ WORK _ MANAGER )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( JcaDistributedWorkManagerDefinition . DWmParameters . ELYTRON _ ENABLED . getAttribute (  )  )  )  . addFailedAttribute ( PathAddress . pathAddress ( JcaSubsystemRootDefinition . PATH _ SUBSYSTEM ,    JcaWorkManagerDefinition . PATH _ WORK _ MANAGER )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( JcaDistributedWorkManagerDefinition . DWmParameters . ELYTRON _ ENABLED . getAttribute (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformerElytronEnabled"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - connector :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  \" as : jboss - as - threads :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . setExtensionClassName (  \" Extension \"  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertNotNull ( legacyServices )  ;", "assertTrue (  \" main   services   did   not   boot \"  ,    mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "List < ModelNode >    xmlOps    =    builder . parseXmlResource ( xmlResourceName )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    xmlOps ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( JcaSubsystemRootDefinition . PATH _ SUBSYSTEM ,    JcaDistributedWorkManagerDefinition . PATH _ DISTRIBUTED _ WORK _ MANAGER )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( JcaSubsystemRootDefinition . PATH _ SUBSYSTEM ,    JcaDistributedWorkManagerDefinition . PATH _ DISTRIBUTED _ WORK _ MANAGER ,    PathElement . pathElement ( Constants . WORKMANAGER _ SHORT _ RUNNING )  )  ,    REJECTED _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformer"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource ( xmlResourceName )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  (  ( controllerVersion . getMavenGroupId (  )  )     +     \"  : wildfly - connector :  \"  )     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  (  ( controllerVersion . getCoreMavenGroupId (  )  )     +     \"  : wildfly - threads :  \"  )     +     ( controllerVersion . getCoreVersion (  )  )  )  )  . setExtensionClassName (  \" Extension \"  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  . configureReverseControllerCheck ( MANAGEMENT ,    new   ModelFixer (  )     {", "@ Override", "public   ModelNode   fixModel ( ModelNode   modelNode )     {", "modelNode . get ( Constants . TRACER ,    Constants . TRACER ,    TracerDefinition . TracerParameters . TRACER _ ENABLED . getAttribute (  )  . getName (  )  )  . set ( true )  ;", "return   modelNode ;", "}", "}  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertNotNull ( legacyServices )  ;", "assertTrue (  \" main   services   did   not   boot \"  ,    mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformer7"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     2  ,     0  )  ,     \" jca - full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP62"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     2  ,     0  )  ,     \" jca - full - expression . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP62WithExpressions"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer 7  ( EAP _  7  _  0  _  0  ,    ModelVersion . create (  4  ,     0  ,     0  )  ,     \" jca - full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP7"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformerElytronEnabled ( EAP _  7  _  0  _  0  ,    ModelVersion . create (  4  ,     0  ,     0  )  ,     \" jca - full - elytron . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP7Elytron"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource ( xmlResourceName )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" wildfly : wildfly - connector :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  \" wildfly : wildfly - threads :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . setExtensionClassName (  \" Extension \"  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  . configureReverseControllerCheck ( MANAGEMENT ,    new   ModelFixer (  )     {", "@ Override", "public   ModelNode   fixModel ( ModelNode   modelNode )     {", "modelNode . get ( Constants . TRACER ,    Constants . TRACER ,    TracerDefinition . TracerParameters . TRACER _ ENABLED . getAttribute (  )  . getName (  )  )  . set ( true )  ;", "return   modelNode ;", "}", "}  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertNotNull ( legacyServices )  ;", "assertTrue (  \" main   services   did   not   boot \"  ,    mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformerWF"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "PathAddress   threadPoolPath    =    context . getCurrentAddress (  )  ;", "PathAddress   workManagerPath    =    threadPoolPath . getParent (  )  ;", "Set < String >    entrySet    =    context . readResourceFromRoot ( workManagerPath ,    false )  . getChildrenNames ( type )  ;", "if    (  (  ( entrySet . size (  )  )     >     0  )     &  &     (  !  ( entrySet . iterator (  )  . next (  )  . equals ( threadPoolPath . getLastElement (  )  . getValue (  )  )  )  )  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . oneThreadPool ( threadPoolPath . getLastElement (  )  . getValue (  )  ,    type ,    workManagerPath . getLastElement (  )  . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkThreadPool"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaWorkManagerDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   JcaWorkManagerDefinition ( registerRuntimeOnly )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaWorkManagerDefinition"}, {"methodBody": ["METHOD_START", "{", "final   BoundedQueueThreadPoolAdd   shortRunningThreadPoolAdd    =    new   BoundedQueueThreadPoolAdd ( false ,    ThreadsServices . STANDARD _ THREAD _ FACTORY _ RESOLVER ,    ThreadsServices . STANDARD _ HANDOFF _ EXECUTOR _ RESOLVER ,    EXECUTOR . append ( Constants . WORKMANAGER _ SHORT _ RUNNING )  )     {", "@ Override", "protected   void   populateModel ( final   OperationContext   context ,    final   ModelNode   operation ,    final   Resource   resource )    throws   OperationFailedException    {", "super . populateModel ( context ,    operation ,    resource )  ;", "context . addStep ( new   OperationStepHandler (  )     {", "public   void   execute ( OperationContext   oc ,    ModelNode   op )    throws   OperationFailedException    {", ". checkThreadPool ( oc ,    op ,    Constants . WORKMANAGER _ SHORT _ RUNNING )  ;", "}", "}  ,    Stage . MODEL )  ;", "}", "}  ;", "resourceRegistration . registerSubModel ( new    . JCAThreadPoolResourceDefinition ( false ,    runtimeOnly ,    Constants . WORKMANAGER _ SHORT _ RUNNING ,    EXECUTOR . append ( Constants . WORKMANAGER _ SHORT _ RUNNING )  ,    CommonAttributes . BOUNDED _ QUEUE _ THREAD _ POOL ,    shortRunningThreadPoolAdd ,    ReloadRequiredRemoveStepHandler . INSTANCE )  )  ;", "final   BoundedQueueThreadPoolAdd   longRunningThreadPoolAdd    =    new   BoundedQueueThreadPoolAdd ( false ,    ThreadsServices . STANDARD _ THREAD _ FACTORY _ RESOLVER ,    ThreadsServices . STANDARD _ HANDOFF _ EXECUTOR _ RESOLVER ,    EXECUTOR . append ( Constants . WORKMANAGER _ LONG _ RUNNING )  )     {", "@ Override", "protected   void   populateModel ( final   OperationContext   context ,    final   ModelNode   operation ,    final   Resource   resource )    throws   OperationFailedException    {", "super . populateModel ( context ,    operation ,    resource )  ;", "context . addStep ( new   OperationStepHandler (  )     {", "public   void   execute ( OperationContext   oc ,    ModelNode   op )    throws   OperationFailedException    {", ". checkThreadPool ( oc ,    op ,    Constants . WORKMANAGER _ LONG _ RUNNING )  ;", "}", "}  ,    Stage . MODEL )  ;", "}", "}  ;", "resourceRegistration . registerSubModel ( new    . JCAThreadPoolResourceDefinition ( false ,    runtimeOnly ,    Constants . WORKMANAGER _ LONG _ RUNNING ,    EXECUTOR . append ( Constants . WORKMANAGER _ LONG _ RUNNING )  ,    CommonAttributes . BOUNDED _ QUEUE _ THREAD _ POOL ,    longRunningThreadPoolAdd ,    new   BoundedQueueThreadPoolRemove ( longRunningThreadPoolAdd )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubModels"], "fileName": "org.jboss.as.connector.subsystems.jca.JcaWorkManagerDefinition"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.connector.subsystems.jca.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.connector.subsystems.jca.Namespace"}, {"methodBody": ["METHOD_START", "{", "return    ( operation . has ( name )  )     &  &     ( operation . get ( name )  . isDefined (  )  )  ;", "}", "METHOD_END"], "methodName": ["has"], "fileName": "org.jboss.as.connector.subsystems.jca.ParamsUtils"}, {"methodBody": ["METHOD_START", "{", "return   ParamsUtils . parseBooleanParameter ( operation ,    name ,    false )  ;", "}", "METHOD_END"], "methodName": ["parseBooleanParameter"], "fileName": "org.jboss.as.connector.subsystems.jca.ParamsUtils"}, {"methodBody": ["METHOD_START", "{", "return   ParamsUtils . has ( operation ,    name )     ?    operation . get ( name )  . asBoolean (  )     :    defaultValue ;", "}", "METHOD_END"], "methodName": ["parseBooleanParameter"], "fileName": "org.jboss.as.connector.subsystems.jca.ParamsUtils"}, {"methodBody": ["METHOD_START", "{", "return   ParamsUtils . has ( operation ,    name )     ?    operation . get ( name )  . toString (  )     :    null ;", "}", "METHOD_END"], "methodName": ["parseStringParameter"], "fileName": "org.jboss.as.connector.subsystems.jca.ParamsUtils"}, {"methodBody": ["METHOD_START", "{", "return   jcaConfig ;", "}", "METHOD_END"], "methodName": ["getJcaConfigInjector"], "fileName": "org.jboss.as.connector.subsystems.jca.TracerService"}, {"methodBody": ["METHOD_START", "{", "return   ao ;", "}", "METHOD_END"], "methodName": ["getAOInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.AOConfigPropertiesService"}, {"methodBody": ["METHOD_START", "{", "final   AS 7 ResourceAdapterTags   element    =    AS 7 ResourceAdapterTags . MAP . get ( localName )  ;", "return   element    =  =    null    ?    AS 7 ResourceAdapterTags . UNKNOWN . value ( localName )     :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.AS7ResourceAdapterTags"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.AS7ResourceAdapterTags"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.AS7ResourceAdapterTags"}, {"methodBody": ["METHOD_START", "{", "name    =    v ;", "turn   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.AS7ResourceAdapterTags"}, {"methodBody": ["METHOD_START", "{", "return   ra ;", "}", "METHOD_END"], "methodName": ["getRaInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.AdminObjectService"}, {"methodBody": ["METHOD_START", "{", "return   cd ;", "}", "METHOD_END"], "methodName": ["getRaInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CDConfigPropertiesService"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   adminObjectNode    =    new   ModelNode (  )  ;", "adminObjectNode . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "int   attributeSize    =    reader . getAttributeCount (  )  ;", "String   poolName    =    null ;", "String   jndiName    =    null ;", "for    ( int   i    =     0  ;    i    <    attributeSize ;    i +  +  )     {", "AdminObject . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . ENABLED . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . ENABLED . parseAndSetParameter ( value ,    adminObjectNode ,    reader )  ;", "}", "break ;", "}", "case   JNDI _ NAME    :", "{", "jndiName    =    rawAttributeText ( reader ,    Constants . JNDINAME . getXmlName (  )  )  ;", "if    ( jndiName    !  =    null )     {", "Constants . JNDINAME . parseAndSetParameter ( jndiName ,    adminObjectNode ,    reader )  ;", "}", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    rawAttributeText ( reader ,    Constants . POOL _ NAME _ NAME )  ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . USE _ JAVA _ CONTEXT . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    adminObjectNode ,    reader )  ;", "}", "break ;", "}", "case   Constants . CLASS _ NAME    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . CLASS _ NAME . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . CLASS _ NAME . parseAndSetParameter ( value ,    adminObjectNode ,    reader )  ;", "}", "break ;", "}", "default    :", "throw   Utils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( poolName    =  =    null )     |  |     ( poolName . trim (  )  . equals (  \"  \"  )  )  )     {", "if    (  ( jndiName    !  =    null )     &  &     (  ( jndiName . trim (  )  . length (  )  )     !  =     0  )  )     {", "if    ( jndiName . contains (  \"  /  \"  )  )     {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  /  \"  )  )     +     1  )  )  ;", "} else    {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  :  \"  )  )     +     1  )  )  ;", "}", "} else    {", "throw   Utils . missingRequired ( reader ,    EnumSet . of ( JNDI _ NAME )  )  ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . ADMIN _ OBJECT )  )     {", "map . put ( poolName ,    adminObjectNode )  ;", "return ;", "} else    {", "if    (  ( AdminObject . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( AdminObject . Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( AdminObject . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONFIG _ PROPERTY    :", "{", "if    (  !  ( configMap . containsKey ( poolName )  )  )     {", "configMap . put ( poolName ,    new   HashMap < String ,    ModelNode >  (  0  )  )  ;", "}", "parseConfigProperties ( reader ,    configMap . get ( poolName )  )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseAdminObjects"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . CAPACITY )  )     {", "return ;", "} else    {", "if    (  ( Capacity . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Capacity . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Capacity . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   INCREMENTER    :", "{", "parseExtension ( reader ,    reader . getLocalName (  )  ,    operation ,    Constants . CAPACITY _ INCREMENTER _ CLASS ,    Constants . CAPACITY _ INCREMENTER _ PROPERTIES )  ;", "break ;", "}", "case   DECREMENTER    :", "{", "parseExtension ( reader ,    reader . getLocalName (  )  ,    operation ,    Constants . CAPACITY _ DECREMENTER _ CLASS ,    Constants . CAPACITY _ DECREMENTER _ PROPERTIES )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseCapacity"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    rawAttributeText ( reader ,     \" name \"  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "String   value    =    rawElementText ( reader )  ;", "Constants . CONFIG _ PROPERTY _ VALUE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "if    ( map . containsKey ( name )  )     {", "throw   Utils . unexpectedElement ( reader )  ;", "}", "map . put ( name ,    operation )  ;", "}", "METHOD_END"], "methodName": ["parseConfigProperties"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "String   poolName    =    null ;", "String   jndiName    =    null ;", "int   attributeSize    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    attributeSize ;    i +  +  )     {", "ConnectionDefinition . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "Constants . ENABLED . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . TRACKING    :", "{", "Constants . TRACKING . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   JNDI _ NAME    :", "{", "jndiName    =    value ;", "Constants . JNDINAME . parseAndSetParameter ( jndiName ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    value ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "Constants . USE _ CCM . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . SHARABLE    :", "{", "Constants . SHARABLE . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . ENLISTMENT    :", "{", "Constants . ENLISTMENT . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . CLASS _ NAME    :", "{", "Constants . CLASS _ NAME . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . MCP    :", "{", "Constants . MCP . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . ENLISTMENT _ TRACE    :", "Constants . ENLISTMENT _ TRACE . parseAndSetParameter ( value ,    ionDefinitionNode ,    reader )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( poolName    =  =    null )     |  |     ( poolName . trim (  )  . equals (  \"  \"  )  )  )     {", "if    (  ( jndiName    !  =    null )     &  &     (  ( jndiName . trim (  )  . length (  )  )     !  =     0  )  )     {", "if    ( jndiName . contains (  \"  /  \"  )  )     {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  /  \"  )  )     +     1  )  )  ;", "} else    {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  :  \"  )  )     +     1  )  )  ;", "}", "} else    {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( JNDI _ NAME )  )  ;", "}", "}", "return   poolName ;", "}", "METHOD_END"], "methodName": ["parseConnectionAttributes_5_0"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   connectionDefinitionNode    =    new   ModelNode (  )  ;", "connectionDefinitionNode . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "String   poolName    =    null ;", "String   jndiName    =    null ;", "int   attributeSize    =    reader . getAttributeCount (  )  ;", "boolean   poolDefined    =    Boolean . FALSE ;", "for    ( int   i    =     0  ;    i    <    attributeSize ;    i +  +  )     {", "ConnectionDefinition . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "Constants . ENABLED . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   JNDI _ NAME    :", "{", "jndiName    =    value ;", "Constants . JNDINAME . parseAndSetParameter ( jndiName ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    value ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "Constants . USE _ CCM . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . SHARABLE    :", "{", "Constants . SHARABLE . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . ENLISTMENT    :", "{", "Constants . ENLISTMENT . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . CLASS _ NAME    :", "{", "Constants . CLASS _ NAME . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( poolName    =  =    null )     |  |     ( poolName . trim (  )  . equals (  \"  \"  )  )  )     {", "if    (  ( jndiName    !  =    null )     &  &     (  ( jndiName . trim (  )  . length (  )  )     !  =     0  )  )     {", "if    ( jndiName . contains (  \"  /  \"  )  )     {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  /  \"  )  )     +     1  )  )  ;", "} else    {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  :  \"  )  )     +     1  )  )  ;", "}", "} else    {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( JNDI _ NAME )  )  ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . CONNECTION _ DEFINITION )  )     {", "map . put ( poolName ,    connectionDefinitionNode )  ;", "return ;", "} else    {", "if    (  ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( ConnectionDefinition . Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONFIG _ PROPERTY    :", "{", "if    (  !  ( configMap . containsKey ( poolName )  )  )     {", "configMap . put ( poolName ,    new   HashMap < String ,    ModelNode >  (  0  )  )  ;", "}", "parseConfigProperties ( reader ,    configMap . get ( poolName )  )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseSecuritySettings ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOut ( reader ,    isXa ,    connectionDefinitionNode )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidation ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "if    (  ! isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parseXaPool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   POOL    :", "{", "if    ( isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parsePool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   RECOVERY    :", "{", "parseRecovery ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseConnectionDefinitions_1_0"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   connectionDefinitionNode    =    new   ModelNode (  )  ;", "connectionDefinitionNode . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "String   poolName    =    null ;", "String   jndiName    =    null ;", "int   attributeSize    =    reader . getAttributeCount (  )  ;", "boolean   poolDefined    =    Boolean . FALSE ;", "for    ( int   i    =     0  ;    i    <    attributeSize ;    i +  +  )     {", "ConnectionDefinition . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "Constants . ENABLED . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . TRACKING    :", "{", "Constants . TRACKING . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   JNDI _ NAME    :", "{", "jndiName    =    value ;", "Constants . JNDINAME . parseAndSetParameter ( jndiName ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    value ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "Constants . USE _ CCM . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . SHARABLE    :", "{", "Constants . SHARABLE . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . ENLISTMENT    :", "{", "Constants . ENLISTMENT . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . CLASS _ NAME    :", "{", "Constants . CLASS _ NAME . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( poolName    =  =    null )     |  |     ( poolName . trim (  )  . equals (  \"  \"  )  )  )     {", "if    (  ( jndiName    !  =    null )     &  &     (  ( jndiName . trim (  )  . length (  )  )     !  =     0  )  )     {", "if    ( jndiName . contains (  \"  /  \"  )  )     {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  /  \"  )  )     +     1  )  )  ;", "} else    {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  :  \"  )  )     +     1  )  )  ;", "}", "} else    {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( JNDI _ NAME )  )  ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . CONNECTION _ DEFINITION )  )     {", "map . put ( poolName ,    connectionDefinitionNode )  ;", "return ;", "} else    {", "if    (  ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( ConnectionDefinition . Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONFIG _ PROPERTY    :", "{", "if    (  !  ( configMap . containsKey ( poolName )  )  )     {", "configMap . put ( poolName ,    new   HashMap < String ,    ModelNode >  (  0  )  )  ;", "}", "parseConfigProperties ( reader ,    configMap . get ( poolName )  )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseSecuritySettings ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOut ( reader ,    isXa ,    connectionDefinitionNode )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidation ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "if    (  ! isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parseXaPool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   POOL    :", "{", "if    ( isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parsePool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   RECOVERY    :", "{", "parseRecovery ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseConnectionDefinitions_3_0"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   connectionDefinitionNode    =    new   ModelNode (  )  ;", "connectionDefinitionNode . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "String   poolName    =    null ;", "String   jndiName    =    null ;", "int   attributeSize    =    reader . getAttributeCount (  )  ;", "boolean   poolDefined    =    Boolean . FALSE ;", "for    ( int   i    =     0  ;    i    <    attributeSize ;    i +  +  )     {", "ConnectionDefinition . Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( attribute )     {", "case   Constants . ENABLED    :", "{", "Constants . ENABLED . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . CONNECTABLE    :", "{", "Constants . CONNECTABLE . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . TRACKING    :", "{", "Constants . TRACKING . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   JNDI _ NAME    :", "{", "jndiName    =    value ;", "Constants . JNDINAME . parseAndSetParameter ( jndiName ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   POOL _ NAME    :", "{", "poolName    =    value ;", "break ;", "}", "case   Constants . USE _ JAVA _ CONTEXT    :", "{", "Constants . USE _ JAVA _ CONTEXT . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . USE _ CCM    :", "{", "Constants . USE _ CCM . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . SHARABLE    :", "{", "Constants . SHARABLE . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . ENLISTMENT    :", "{", "Constants . ENLISTMENT . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . CLASS _ NAME    :", "{", "Constants . CLASS _ NAME . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . MCP    :", "{", "Constants . MCP . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "}", "case   Constants . ENLISTMENT _ TRACE    :", "Constants . ENLISTMENT _ TRACE . parseAndSetParameter ( value ,    connectionDefinitionNode ,    reader )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( poolName    =  =    null )     |  |     ( poolName . trim (  )  . equals (  \"  \"  )  )  )     {", "if    (  ( jndiName    !  =    null )     &  &     (  ( jndiName . trim (  )  . length (  )  )     !  =     0  )  )     {", "if    ( jndiName . contains (  \"  /  \"  )  )     {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  /  \"  )  )     +     1  )  )  ;", "} else    {", "poolName    =    jndiName . substring (  (  ( jndiName . lastIndexOf (  \"  :  \"  )  )     +     1  )  )  ;", "}", "} else    {", "throw   ParseUtils . missingRequired ( reader ,    EnumSet . of ( JNDI _ NAME )  )  ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . CONNECTION _ DEFINITION )  )     {", "map . put ( poolName ,    connectionDefinitionNode )  ;", "return ;", "} else    {", "if    (  ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( ConnectionDefinition . Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONFIG _ PROPERTY    :", "{", "if    (  !  ( configMap . containsKey ( poolName )  )  )     {", "configMap . put ( poolName ,    new   HashMap < String ,    ModelNode >  (  0  )  )  ;", "}", "parseConfigProperties ( reader ,    configMap . get ( poolName )  )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseSecuritySettings ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOut ( reader ,    isXa ,    connectionDefinitionNode )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidation ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "if    (  ! isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parseXaPool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   POOL    :", "{", "if    ( isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parsePool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   RECOVERY    :", "{", "parseRecovery ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseConnectionDefinitions_4_0"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   connectionDefinitionNode    =    new   ModelNode (  )  ;", "connectionDefinitionNode . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "final   String   poolName    =    parseConnectionAttributes _  5  _  0  ( reader ,    connectionDefinitionNode )  ;", "boolean   poolDefined    =    Boolean . FALSE ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . CONNECTION _ DEFINITION )  )     {", "map . put ( poolName ,    connectionDefinitionNode )  ;", "return ;", "} else    {", "if    (  ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( ConnectionDefinition . Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( ConnectionDefinition . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONFIG _ PROPERTY    :", "{", "if    (  !  ( configMap . containsKey ( poolName )  )  )     {", "configMap . put ( poolName ,    new   HashMap < String ,    ModelNode >  (  0  )  )  ;", "}", "parseConfigProperties ( reader ,    configMap . get ( poolName )  )  ;", "break ;", "}", "case   SECURITY    :", "{", "parseElytronSupportedSecuritySettings ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   TIMEOUT    :", "{", "parseTimeOut ( reader ,    isXa ,    connectionDefinitionNode )  ;", "break ;", "}", "case   VALIDATION    :", "{", "parseValidation ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "case   XA _ POOL    :", "{", "if    (  ! isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parseXaPool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   POOL    :", "{", "if    ( isXa )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "if    ( poolDefined )     {", "throw   new   ParserException (  . bundle . multiplePools (  )  )  ;", "}", "parsePool ( reader ,    connectionDefinitionNode )  ;", "poolDefined    =    true ;", "break ;", "}", "case   RECOVERY    :", "{", "parseElytronSupportedRecovery ( reader ,    connectionDefinitionNode )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseConnectionDefinitions_5_0"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "for    ( Recovery . Attribute   attribute    :    Attribute . values (  )  )     {", "switch    ( attribute )     {", "case   Constants . NO _ RECOVERY    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . NO _ RECOVERY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . NO _ RECOVERY . parseAndSetParameter ( value ,    node ,    reader )  ;", "}", "break ;", "}", "default    :", "break ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . RECOVERY )  )     {", "return ;", "} else    {", "if    (  ( Recovery . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Recovery . Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "Recovery . Tag   tag    =    Recovery . Tag . forName ( reader . getLocalName (  )  )  ;", "switch    ( tag )     {", "case   RECOVER _ CREDENTIAL    :", "{", "parseElytronSupportedRecoveryCredential ( reader ,    node )  ;", "break ;", "}", "case   RECOVER _ PLUGIN    :", "{", "parseExtension ( reader ,    tag . getLocalName (  )  ,    node ,    Constants . RECOVERLUGIN _ CLASSNAME ,    Constants . RECOVERLUGIN _ PROPERTIES )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseElytronSupportedRecovery"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     |  |     (  ( Recovery . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Recovery . Tag . RECOVER _ CREDENTIAL )  )  )     {", "return ;", "} else    {", "if    (  ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Credential . Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   PASSWORD    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ PASSWORD . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   CREDENTIAL _ REFERENCE    :", "{", "Constants . RECOVERY _ CREDENTIAL _ REFERENCE . get (  )  . parseAndSetParameter ( Constants . RECOVERY _ CREDENTIAL _ REFERENCE ,    null ,    node ,    reader )  ;", "break ;", "}", "case   USER _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ USERNAME . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . SECURITY _ DOMAIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . ELYTRON _ ENABLED    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . RECOVERY _ ELYTRON _ ENABLED . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . AUTHENTICATION _ CONTEXT    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ AUTHENTICATION _ CONTEXT . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseElytronSupportedRecoveryCredential"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "boolean   securityDomainMatched    =    false ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     {", "return ;", "} else    {", "if    (  ( Security . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Security . Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Security . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . SECURITY _ DOMAIN    :", "{", "if    ( securityDomainMatched )     {", "throw   Utils . unexpectedElement ( reader )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . SECURITY _ DOMAIN . parseAndSetParameter ( value ,    node ,    reader )  ;", "securityDomainMatched    =    true ;", "break ;", "}", "case   Constants . SECURITY _ DOMAIN _ AND _ APPLICATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . SECURITY _ DOMAIN _ AND _ APPLICATION . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . ELYTRON _ ENABLED    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . ELYTRON _ ENABLED . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . AUTHENTICATION _ CONTEXT    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . AUTHENTICATION _ CONTEXT . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . AUTHENTICATION _ CONTEXT _ AND _ APPLICATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . AUTHENTICATION _ CONTEXT _ AND _ APPLICATION . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . APPLICATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . APPLICATION . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseElytronSupportedSecuritySettings"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . POOL )  )     {", "return ;", "} else    {", "if    (  ( Pool . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Pool . Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Pool . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . MAX _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MAX _ POOL _ SIZE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . INITIAL _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . INITIAL _ POOL _ SIZE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . MIN _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MIN _ POOL _ SIZE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   PREFILL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ PREFILL . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   FAIR    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FAIR . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   USE _ STRICT _ MIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ USE _ STRICT _ MIN . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   FLUSH _ STRATEGY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FLUSH _ STRATEGY . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   CAPACITY    :", "{", "parseCapacity ( reader ,    node )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parsePool"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "for    ( Recovery . Attribute   attribute    :    Attribute . values (  )  )     {", "switch    ( attribute )     {", "case   Constants . NO _ RECOVERY    :", "{", "String   value    =    rawAttributeText ( reader ,    Constants . NO _ RECOVERY . getXmlName (  )  )  ;", "if    ( value    !  =    null )     {", "Constants . NO _ RECOVERY . parseAndSetParameter ( value ,    node ,    reader )  ;", "}", "break ;", "}", "default    :", "break ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . RECOVERY )  )     {", "return ;", "} else    {", "if    (  ( Recovery . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Recovery . Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "Recovery . Tag   tag    =    Recovery . Tag . forName ( reader . getLocalName (  )  )  ;", "switch    ( tag )     {", "case   RECOVER _ CREDENTIAL    :", "{", "parseRecoveryCredential ( reader ,    node )  ;", "break ;", "}", "case   RECOVER _ PLUGIN    :", "{", "parseExtension ( reader ,    tag . getLocalName (  )  ,    node ,    Constants . RECOVERLUGIN _ CLASSNAME ,    Constants . RECOVERLUGIN _ PROPERTIES )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseRecovery"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     |  |     (  ( Recovery . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Recovery . Tag . RECOVER _ CREDENTIAL )  )  )     {", "return ;", "} else    {", "if    (  ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Credential . Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Credential . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   PASSWORD    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ PASSWORD . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   USER _ NAME    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ USERNAME . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   CREDENTIAL _ REFERENCE    :", "{", "Constants . RECOVERY _ CREDENTIAL _ REFERENCE . get (  )  . parseAndSetParameter ( Constants . RECOVERY _ CREDENTIAL _ REFERENCE ,    null ,    node ,    reader )  ;", "}", "case   Constants . SECURITY _ DOMAIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . RECOVERY _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseRecoveryCredential"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "boolean   securtyDomainMatched    =    false ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     {", "return ;", "} else    {", "if    (  ( Security . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Security . Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Security . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . SECURITY _ DOMAIN    :", "{", "if    ( securtyDomainMatched )     {", "throw   Utils . unexpectedElement ( reader )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . SECURITY _ DOMAIN . parseAndSetParameter ( value ,    node ,    reader )  ;", "securtyDomainMatched    =    true ;", "break ;", "}", "case   Constants . SECURITY _ DOMAIN _ AND _ APPLICATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . SECURITY _ DOMAIN _ AND _ APPLICATION . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . APPLICATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . APPLICATION . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseSecuritySettings"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . TIMEOUT )  )     {", "return ;", "} else    {", "if    (  ( TimeOut . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( TimeOut . Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "String   value    =    rawElementText ( reader )  ;", "switch    ( TimeOut . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . ALLOCATION _ RETRY    :", "{", "Constants . ALLOCATION _ RETRY . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS    :", "{", "Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   BLOCKING _ TIMEOUT _ MILLIS    :", "{", "common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   IDLE _ TIMEOUT _ MINUTES    :", "{", "common . pool . Constants . IDLETIMEOUTMINUTES . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . XA _ RESOURCE _ TIMEOUT    :", "{", "Constants . XA _ RESOURCE _ TIMEOUT . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseTimeOut"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . VALIDATION )  )     {", "return ;", "} else    {", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Validation . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   BACKGROUND _ VALIDATION    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . BACKGROUNDVALIDATION . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   BACKGROUND _ VALIDATION _ MILLIS    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . BACKGROUNDVALIDATIONMILLIS . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . USE _ FAST _ FAIL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . USE _ FAST _ FAIL . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . VALIDATE _ ON _ MATCH    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . VALIDATE _ ON _ MATCH . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseValidation"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . XA _ POOL )  )     {", "return ;", "} else    {", "if    (  ( XaPool . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( XaPool . Tag . UNKNOWN )  )     {", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( XaPool . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   Constants . MAX _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MAX _ POOL _ SIZE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . MIN _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . MIN _ POOL _ SIZE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . INITIAL _ POOL _ SIZE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . INITIAL _ POOL _ SIZE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   PREFILL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ PREFILL . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   FAIR    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FAIR . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   USE _ STRICT _ MIN    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ USE _ STRICT _ MIN . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   FLUSH _ STRATEGY    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . POOL _ FLUSH _ STRATEGY . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . INTERLEAVING    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . INTERLEAVING . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   IS _ SAME _ RM _ OVERRIDE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . SAME _ RM _ OVERRIDE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   NO _ TX _ SEPARATE _ POOLS    :", "{", "String   value    =    rawElementText ( reader )  ;", "value    =     ( value    =  =    null )     ?     \" true \"     :    value ;", "Constants . NOTXSEPARATEPOOL . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . PAD _ XID    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . PAD _ XID . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   Constants . WRAP _ XA _ RESOURCE    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . WRAP _ XA _ RESOURCE . parseAndSetParameter ( value ,    node ,    reader )  ;", "break ;", "}", "case   CAPACITY    :", "{", "parseCapacity ( reader ,    node )  ;", "break ;", "}", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "break ;", "}", "}", "}", "throw   Utils . unexpectedEndElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseXaPool"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.CommonIronJacamarParser"}, {"methodBody": ["METHOD_START", "{", "return   ra ;", "}", "METHOD_END"], "methodName": ["getRaInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ConfigPropertiesService"}, {"methodBody": ["METHOD_START", "{", "ExceptionSupplier < ModifiableConnDef ,    Exception >    connDefSupplier    =    connectionDefinitionSupplier . getValue (  )  ;", "try    {", "if    ( connDefSupplier    !  =    null )", "value . inject ( connDefSupplier . get (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   IllegalStateException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createConnectionDefinition"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ConnectionDefinitionService"}, {"methodBody": ["METHOD_START", "{", "return   connectionDefinitionSupplier ;", "}", "METHOD_END"], "methodName": ["getConnectionDefinitionSupplierInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ConnectionDefinitionService"}, {"methodBody": ["METHOD_START", "{", "return   credentialSourceSupplier ;", "}", "METHOD_END"], "methodName": ["getCredentialSourceSupplier"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ConnectionDefinitionService"}, {"methodBody": ["METHOD_START", "{", "return   ra ;", "}", "METHOD_END"], "methodName": ["getRaInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ConnectionDefinitionService"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.Element"}, {"methodBody": ["METHOD_START", "{", "delegate    =    updated ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResource"}, {"methodBody": ["METHOD_START", "{", "final   Resource   adminObjectResource    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "final   ModelNode   model    =    adminObjectResource . getModel (  )  ;", "setAttribute ( model ,    Constants . CLASS _ NAME ,    adminObject . getClassName (  )  )  ;", "setAttribute ( model ,    Constants . JNDINAME ,    adminObject . getJndiName (  )  )  ;", "setAttribute ( model ,    Constants . USE _ JAVA _ CONTEXT ,    adminObject . isUseJavaContext (  )  )  ;", "setAttribute ( model ,    Constants . ENABLED ,    adminObject . isEnabled (  )  )  ;", "if    (  ( adminObject . getConfigProperties (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    config    :    adminObject . getConfigProperties (  )  . entrySet (  )  )     {", "addConfigProperties ( adminObjectResource ,    config . getKey (  )  ,    config . getValue (  )  )  ;", "}", "}", "final   PathElement   element    =    PathElement . pathElement ( Constants . ADMIN _ OBJECTS _ NAME ,    adminObject . getJndiName (  )  )  ;", "parent . registerChild ( element ,    adminObjectResource )  ;", "}", "METHOD_END"], "methodName": ["addAdminObject"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "final   Resource   config    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "final   ModelNode   model    =    config . getModel (  )  ;", "model . get ( Constants . CONFIG _ PROPERTY _ VALUE . getName (  )  )  . set ( value )  ;", "final   PathElement   element    =    PathElement . pathElement ( Constants . CONFIG _ PROPERTIES . getName (  )  ,    name )  ;", "parent . registerChild ( element ,    config )  ;", "}", "METHOD_END"], "methodName": ["addConfigProperties"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "final   Resource   connDefResource    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "final   ModelNode   model    =    connDefResource . getModel (  )  ;", "setAttribute ( model ,    Constants . JNDINAME ,    connDef . getJndiName (  )  )  ;", "if    (  ( connDef . getConfigProperties (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    config    :    connDef . getConfigProperties (  )  . entrySet (  )  )     {", "addConfigProperties ( connDefResource ,    config . getKey (  )  ,    config . getValue (  )  )  ;", "}", "}", "setAttribute ( model ,    Constants . CLASS _ NAME ,    connDef . getClassName (  )  )  ;", "setAttribute ( model ,    Constants . JNDINAME ,    connDef . getJndiName (  )  )  ;", "setAttribute ( model ,    Constants . USE _ JAVA _ CONTEXT ,    connDef . isUseJavaContext (  )  )  ;", "setAttribute ( model ,    Constants . ENABLED ,    connDef . isEnabled (  )  )  ;", "setAttribute ( model ,    Constants . CONNECTABLE ,    connDef . isConnectable (  )  )  ;", "if    (  ( connDef . isTracking (  )  )     !  =    null )     {", "setAttribute ( model ,    Constants . TRACKING ,    connDef . isTracking (  )  )  ;", "}", "setAttribute ( model ,    Constants . USE _ CCM ,    connDef . isUseCcm (  )  )  ;", "setAttribute ( model ,    Constants . SHARABLE ,    connDef . isSharable (  )  )  ;", "setAttribute ( model ,    Constants . ENLISTMENT ,    connDef . isEnlistment (  )  )  ;", "final   Pool   pool    =    connDef . getPool (  )  ;", "if    ( pool    !  =    null )     {", "setAttribute ( model ,    common . pool . Constants . MAX _ POOL _ SIZE ,    pool . getMaxPoolSize (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . MIN _ POOL _ SIZE ,    pool . getMinPoolSize (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . INITIAL _ POOL _ SIZE ,    pool . getInitialPoolSize (  )  )  ;", "if    (  ( pool . getCapacity (  )  )     !  =    null )     {", "if    (  ( pool . getCapacity (  )  . getIncrementer (  )  )     !  =    null )     {", "setAttribute ( model ,    common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS ,    pool . getCapacity (  )  . getIncrementer (  )  . getClassName (  )  )  ;", "if    (  ( pool . getCapacity (  )  . getIncrementer (  )  . getConfigPropertiesMap (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    config    :    pool . getCapacity (  )  . getIncrementer (  )  . getConfigPropertiesMap (  )  . entrySet (  )  )     {", "model . get ( common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES . getName (  )  ,    config . getKey (  )  )  . set ( config . getValue (  )  )  ;", "}", "}", "}", "if    (  ( pool . getCapacity (  )  . getDecrementer (  )  )     !  =    null )     {", "setAttribute ( model ,    common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS ,    pool . getCapacity (  )  . getDecrementer (  )  . getClassName (  )  )  ;", "if    (  ( pool . getCapacity (  )  . getDecrementer (  )  . getConfigPropertiesMap (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    config    :    pool . getCapacity (  )  . getDecrementer (  )  . getConfigPropertiesMap (  )  . entrySet (  )  )     {", "model . get ( common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES . getName (  )  ,    config . getKey (  )  )  . set ( config . getValue (  )  )  ;", "}", "}", "}", "}", "setAttribute ( model ,    common . pool . Constants . POOL _ USE _ STRICT _ MIN ,    pool . isUseStrictMin (  )  )  ;", "if    (  ( pool . getFlushStrategy (  )  )     !  =    null )", "setAttribute ( model ,    common . pool . Constants . POOL _ FLUSH _ STRATEGY ,    pool . getFlushStrategy (  )  . name (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . POOL _ PREFILL ,    pool . isPrefill (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . POOL _ FAIR ,    pool . isFair (  )  )  ;", "if    ( connDef . isXa (  )  )     {", "assert    ( connDef . getPool (  )  )    instanceof   XaPool ;", "XaPool   xaPool    =     (  ( XaPool )     ( connDef . getPool (  )  )  )  ;", "setAttribute ( model ,    Constants . WRAP _ XA _ RESOURCE ,    xaPool . isWrapXaResource (  )  )  ;", "setAttribute ( model ,    Constants . SAME _ RM _ OVERRIDE ,    xaPool . isSameRmOverride (  )  )  ;", "setAttribute ( model ,    Constants . PAD _ XID ,    xaPool . isPadXid (  )  )  ;", "setAttribute ( model ,    Constants . INTERLEAVING ,    xaPool . isInterleaving (  )  )  ;", "setAttribute ( model ,    Constants . NOTXSEPARATEPOOL ,    xaPool . isNoTxSeparatePool (  )  )  ;", "}", "}", "final   Security   security    =    connDef . getSecurity (  )  ;", "if    ( security    !  =    null )     {", "setAttribute ( model ,    Constants . APPLICATION ,    security . isApplication (  )  )  ;", "if    (  ( security   instanceof   Security )     &  &     (  (  ( Security )     ( security )  )  . isElytronEnabled (  )  )  )     {", "setAttribute ( model ,    Constants . ELYTRON _ ENABLED ,    true )  ;", "setAttribute ( model ,    Constants . AUTHENTICATION _ CONTEXT ,    security . getSecurityDomain (  )  )  ;", "setAttribute ( model ,    Constants . AUTHENTICATION _ CONTEXT _ AND _ APPLICATION ,    security . getSecurityDomainAndApplication (  )  )  ;", "} else    {", "setAttribute ( model ,    Constants . SECURITY _ DOMAIN ,    security . getSecurityDomain (  )  )  ;", "setAttribute ( model ,    Constants . SECURITY _ DOMAIN _ AND _ APPLICATION ,    security . getSecurityDomainAndApplication (  )  )  ;", "}", "}", "final   TimeOut   timeOut    =    connDef . getTimeOut (  )  ;", "if    ( timeOut    !  =    null )     {", "setAttribute ( model ,    Constants . ALLOCATION _ RETRY ,    timeOut . getAllocationRetry (  )  )  ;", "setAttribute ( model ,    Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS ,    timeOut . getAllocationRetryWaitMillis (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS ,    timeOut . getBlockingTimeoutMillis (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . IDLETIMEOUTMINUTES ,    timeOut . getIdleTimeoutMinutes (  )  )  ;", "setAttribute ( model ,    Constants . XA _ RESOURCE _ TIMEOUT ,    timeOut . getXaResourceTimeout (  )  )  ;", "}", "final   Validation   validation    =    connDef . getValidation (  )  ;", "if    ( validation    !  =    null )     {", "setAttribute ( model ,    common . pool . Constants . BACKGROUNDVALIDATIONMILLIS ,    validation . getBackgroundValidationMillis (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . BACKGROUNDVALIDATION ,    validation . isBackgroundValidation (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . USE _ FAST _ FAIL ,    validation . isUseFastFail (  )  )  ;", "setAttribute ( model ,    common . pool . Constants . VALIDATE _ ON _ MATCH ,    validation . isValidateOnMatch (  )  )  ;", "}", "final   Recovery   recovery    =    connDef . getRecovery (  )  ;", "if    ( recovery    !  =    null )     {", "setAttribute ( model ,    Constants . NO _ RECOVERY ,    recovery . getNoRecovery (  )  )  ;", "final   Extension   recoverPlugin    =    recovery . getRecoverPlugin (  )  ;", "if    ( recoverPlugin    !  =    null )     {", "setAttribute ( model ,    Constants . RECOVERLUGIN _ CLASSNAME ,    recoverPlugin . getClassName (  )  )  ;", "if    (  ( recoverPlugin . getConfigPropertiesMap (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    config    :    recoverPlugin . getConfigPropertiesMap (  )  . entrySet (  )  )     {", "model . get ( Constants . RECOVERLUGIN _ PROPERTIES . getName (  )  ,    config . getKey (  )  )  . set ( config . getValue (  )  )  ;", "}", "}", "}", "final   Credential   recoveryCredential    =    recovery . getCredential (  )  ;", "if    ( recoveryCredential    !  =    null )     {", "setAttribute ( model ,    Constants . RECOVERY _ PASSWORD ,    recoveryCredential . getPassword (  )  )  ;", "if    (  ( recoveryCredential   instanceof   Credential )     &  &     (  (  ( Credential )     ( recoveryCredential )  )  . isElytronEnabled (  )  )  )     {", "setAttribute ( model ,    Constants . RECOVERY _ ELYTRON _ ENABLED ,    true )  ;", "setAttribute ( model ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT ,    recoveryCredential . getSecurityDomain (  )  )  ;", "} else    {", "setAttribute ( model ,    Constants . RECOVERY _ SECURITY _ DOMAIN ,    recoveryCredential . getSecurityDomain (  )  )  ;", "}", "setAttribute ( model ,    Constants . RECOVERY _ USERNAME ,    recoveryCredential . getUserName (  )  )  ;", "}", "}", "final   Resource   statsResource    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "connDefResource . registerChild ( PathElement . pathElement ( Constants . STATISTICS _ NAME ,     \" local \"  )  ,    statsResource )  ;", "final   PathElement   element    =    PathElement . pathElement ( Constants . CONNECTIONDEFINITIONS _ NAME ,    connDef . getJndiName (  )  )  ;", "parent . registerChild ( element ,    connDefResource )  ;", "}", "METHOD_END"], "methodName": ["addConnectionDefinition"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "final   Resource   ijResourceAdapter    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "final   ModelNode   model    =    ijResourceAdapter . getModel (  )  ;", "model . get ( Constants . ARCHIVE . getName (  )  )  . set ( name )  ;", "setAttribute ( model ,    Constants . BOOTSTRAP _ CONTEXT ,    ironJacamarMetadata . getBootstrapContext (  )  )  ;", "if    (  ( ironJacamarMetadata . getTransactionSupport (  )  )     !  =    null )", "model . get ( Constants . TRANSACTION _ SUPPORT . getName (  )  )  . set ( ironJacamarMetadata . getTransactionSupport (  )  . name (  )  )  ;", "if    (  (  ( ironJacamarMetadata . getWorkManager (  )  )     !  =    null )     &  &     (  ( ironJacamarMetadata . getWorkManager (  )  . getSecurity (  )  )     !  =    null )  )     {", "WorkManagerSecurity   security    =    ironJacamarMetadata . getWorkManager (  )  . getSecurity (  )  ;", "model . get ( Constants . WM _ SECURITY . getName (  )  )  . set ( true )  ;", "if    (  ( security . getDefaultGroups (  )  )     !  =    null )     {", "for    ( String   group    :    security . getDefaultGroups (  )  )     {", "model . get ( Constants . WM _ SECURITY _ DEFAULT _ GROUPS . getName (  )  )  . add ( group )  ;", "}", "}", "if    (  ( security . getDefaultPrincipal (  )  )     !  =    null )", "model . get ( Constants . WM _ SECURITY _ DEFAULT _ PRINCIPAL . getName (  )  )  . set ( security . getDefaultPrincipal (  )  )  ;", "model . get ( Constants . WM _ SECURITY _ MAPPING _ REQUIRED . getName (  )  )  . set ( security . isMappingRequired (  )  )  ;", "if    (  ( security   instanceof   metadata . api . resourceadapter . WorkManagerSecurity )     &  &     (  (  ( metadata . api . resourceadapter . WorkManagerSecurity )     ( security )  )  . isElytronEnabled (  )  )  )     {", "model . get ( Constants . WM _ ELYTRON _ SECURITY _ DOMAIN . getName (  )  )  . set ( security . getDomain (  )  )  ;", "} else    {", "model . get ( Constants . WM _ SECURITY _ DOMAIN . getName (  )  )  . set ( security . getDomain (  )  )  ;", "}", "if    (  ( security . getGroupMappings (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    entry    :    security . getGroupMappings (  )  . entrySet (  )  )     {", "final   Resource   mapping    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "final   ModelNode   subModel    =    mapping . getModel (  )  ;", "subModel . get ( Constants . WM _ SECURITY _ MAPPING _ FROM . getName (  )  )  . set ( entry . getKey (  )  )  ;", "subModel . get ( Constants . WM _ SECURITY _ MAPPING _ TO . getName (  )  )  . set ( entry . getKey (  )  )  ;", "final   PathElement   element    =    PathElement . pathElement ( Constants . WM _ SECURITY _ MAPPING _ GROUPS . getName (  )  ,    Constants . WM _ SECURITY _ MAPPING _ GROUP . getName (  )  )  ;", "ijResourceAdapter . registerChild ( element ,    mapping )  ;", "}", "}", "if    (  ( security . getUserMappings (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    entry    :    security . getUserMappings (  )  . entrySet (  )  )     {", "final   Resource   mapping    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "final   ModelNode   subModel    =    mapping . getModel (  )  ;", "subModel . get ( Constants . WM _ SECURITY _ MAPPING _ FROM . getName (  )  )  . set ( entry . getKey (  )  )  ;", "subModel . get ( Constants . WM _ SECURITY _ MAPPING _ TO . getName (  )  )  . set ( entry . getKey (  )  )  ;", "final   PathElement   element    =    PathElement . pathElement ( Constants . WM _ SECURITY _ MAPPING _ USERS . getName (  )  ,    Constants . WM _ SECURITY _ MAPPING _ USER . getName (  )  )  ;", "ijResourceAdapter . registerChild ( element ,    mapping )  ;", "}", "}", "}", "if    (  ( ironJacamarMetadata . getBeanValidationGroups (  )  )     !  =    null )     {", "for    ( String   bv    :    ironJacamarMetadata . getBeanValidationGroups (  )  )     {", "model . get ( Constants . BEANVALIDATION _ GROUPS . getName (  )  )  . add ( new   ModelNode (  )  . set ( bv )  )  ;", "}", "}", "if    (  ( ironJacamarMetadata . getConfigProperties (  )  )     !  =    null )     {", "for    ( Map . Entry < String ,    String >    config    :    ironJacamarMetadata . getConfigProperties (  )  . entrySet (  )  )     {", "addConfigProperties ( ijResourceAdapter ,    config . getKey (  )  ,    config . getValue (  )  )  ;", "}", "}", "if    (  ( ironJacamarMetadata . getConnectionDefinitions (  )  )     !  =    null )     {", "for    ( ConnectionDefinition   connDef    :    ironJacamarMetadata . getConnectionDefinitions (  )  )     {", "addConnectionDefinition ( ijResourceAdapter ,    connDef )  ;", "}", "}", "if    (  ( ironJacamarMetadata . getAdminObjects (  )  )     !  =    null )     {", "for    ( AdminObject   adminObject    :    ironJacamarMetadata . getAdminObjects (  )  )     {", "addAdminObject ( ijResourceAdapter ,    adminObject )  ;", "}", "}", "final   Resource   statsResource    =    new   IronJacamarResource . IronJacamarRuntimeResource (  )  ;", "ijResourceAdapter . registerChild ( PathElement . pathElement ( Constants . STATISTICS _ NAME ,     \" local \"  )  ,    statsResource )  ;", "final   PathElement   element    =    PathElement . pathElement ( Constants . RESOURCEADAPTER _ NAME ,    name )  ;", "parent . registerChild ( element ,    ijResourceAdapter )  ;", "}", "METHOD_END"], "methodName": ["addResourceAdapter"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "final   IronJacamarResource   ironJacamarResource    =    new   IronJacamarResource (  )  ;", "final   Resource   storeModel    =    getIronJacamarResource ( mdr ,    name )  ;", "ironJacamarResource . update ( storeModel )  ;", "PathElement   ijPe    =    PathElement . pathElement ( Constants . IRONJACAMAR _ NAME ,    Constants . IRONJACAMAR _ NAME )  ;", "if    (  ( parentResource . getChild ( ijPe )  )     =  =    null )     {", "parentResource . registerChild ( ijPe ,    ironJacamarResource )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "final   Resource   resource    =    Factory . create (  )  ;", "Activation   activation    =    mdr . getMetaData ( name )  ;", "if    ( activation    !  =    null )", "addResourceAdapter ( resource ,    name ,    activation )  ;", "return   resource ;", "}", "METHOD_END"], "methodName": ["getIronJacamarResource"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "model . get ( node . getNe (  )  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "model . get ( node . getNe (  )  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "model . get ( node . getNe (  )  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "model . get ( node . getNe (  )  )  . set ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stats . getType ( attributeName )  )     =  =     ( int . class )  )     {", "ult . set (  (  ( Integer )     ( stats . getValue ( attributeName )  )  )  )  ;", "} else", "if    (  ( stats . getType ( attributeName )  )     =  =     ( long . class )  )     {", "ult . set (  (  ( Long )     ( stats . getValue ( attributeName )  )  )  )  ;", "} else    {", "ult . set (  (  \"  \"     +     ( stats . getValue ( attributeName )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setStatsModelValue"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.IronJacamarResourceCreator"}, {"methodBody": ["METHOD_START", "{", "return   configProperties . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["addConfigProperty"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableAdminObject"}, {"methodBody": ["METHOD_START", "{", "return   configProperties . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["addConfigProperty"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableConnDef"}, {"methodBody": ["METHOD_START", "{", "adminObjects . add ( value )  ;", "}", "METHOD_END"], "methodName": ["addAdminObject"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "configProperties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addConfigProperty"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "connectionDefinitions . add ( value )  ;", "}", "METHOD_END"], "methodName": ["addConnectionDefinition"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   adminObjects . size (  )  ;", "}", "METHOD_END"], "methodName": ["adminObjectSize"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   connectionDefinitions . size (  )  ;", "}", "METHOD_END"], "methodName": ["connectionDefinitionSize"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   raXmlDeploymentServiceName ;", "}", "METHOD_END"], "methodName": ["getRaXmlDeploymentServiceName"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . raXmlDeploymentServiceName    =    raXmlDeploymentServiceName ;", "}", "METHOD_END"], "methodName": ["setRaXmlDeploymentServiceName"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ModifiableResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.Namespace"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    operation . require ( ModelDescriptionConstants . OP _ ADDR )  ;", "final   String   idName    =    PathAddress . pathAddress ( address )  . getLastElement (  )  . getValue (  )  ;", "ModelNode   model    =    context . readResource ( EMPTY _ ADDRESS )  . getModel (  )  ;", "final   String   archiveOrModuleName ;", "if    (  (  !  ( model . hasDefined ( Constants . ARCHIVE . getName (  )  )  )  )     &  &     (  !  ( model . hasDefined ( Constants . MODULE . getName (  )  )  )  )  )     {", "throw   CLogger . ROOT _ LOGGER . archiveOrModuleRequired (  )  ;", "}", "if    ( model . get ( Constants . ARCHIVE . getName (  )  )  . isDefined (  )  )     {", "archiveOrModuleName    =    model . get ( Constants . ARCHIVE . getName (  )  )  . asString (  )  ;", "} else    {", "archiveOrModuleName    =    model . get ( Constants . MODULE . getName (  )  )  . asString (  )  ;", "}", "if    ( context . isNormalServer (  )  )     {", "context . addStep ( new   OperationStepHandler (  )     {", "public   void   execute ( final   OperationContext   context ,    ModelNode   operation )    throws   OperationFailedException    {", "ServiceName   restartedServiceName    =    RaOperationUtil . restartIfPresent ( context ,    archiveOrModuleName ,    idName )  ;", "if    ( restartedServiceName    =  =    null )     {", "RaOperationUtil . activate ( context ,    idName ,    archiveOrModuleName )  ;", "}", "context . completeStep ( new   OperationContext . RollbackHandler (  )     {", "@ Override", "public   void   handleRollback ( OperationContext   context ,    ModelNode   operation )     {", "try    {", "RaOperationUtil . removeIfActive ( context ,    archiveOrModuleName ,    idName )  ;", "}    catch    ( OperationFailedException   e )     {", "}", "}", "}  )  ;", "}", "}  ,    RUNTIME )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaActivate"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "ServiceController <  ?  >    inactiveRaController    =    registry . getService ( CServices . INACTIVE _ RESOURCE _ ADAPTER _ SERVICE . append ( archiveName )  )  ;", "if    ( inactiveRaController    =  =    null )     {", "inactiveRaController    =    registry . getService ( CServices . INACTIVE _ RESOURCE _ ADAPTER _ SERVICE . append ( raName )  )  ;", "if    ( inactiveRaController    =  =    null )     {", "throw   CLogger . ROOT _ LOGGER . RARNotYetDeployed ( raName )  ;", "}", "}", "InactiveResourceAdapterDeploymentService . InactiveResourceAdapterDeployment   inactive    =     (  ( InactiveResourceAdapterDeploymentService . InactiveResourceAdapterDeployment )     ( inactiveRaController . getValue (  )  )  )  ;", "final   ServiceController <  ?  >    RaxmlController    =    registry . getService ( ServiceName . of ( CServices . RA _ SERVICE ,    raName )  )  ;", "Activation   raxml    =     (  ( Activation )     ( RaxmlController . getValue (  )  )  )  ;", "RaServicesFactory . createDeploymentService ( inactive . getRegistration (  )  ,    inactive . getCXmlDescriptor (  )  ,    inactive . getModule (  )  ,    inactive . getServiceTarget (  )  ,    archiveName ,    inactive . getDeploymentUnitServiceName (  )  ,    inactive . getDeployment (  )  ,    raxml ,    inactive . getResource (  )  ,    registry )  ;", "}", "METHOD_END"], "methodName": ["activate"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    configProperties    =    new   HashMap < String ,    String >  (  0  )  ;", "String   className    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    o ,    Constants . CLASS _ NAME )  ;", "String   jndiName    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    o ,    Constants . JNDINAME )  ;", "boolean   enabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    o ,    Constants . ENABLED )  ;", "boolean   useJavaContext    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    o ,    Constants . USE _ JAVA _ CONTEXT )  ;", "ModifiableAdminObject   adminObject    =    new   ModifiableAdminObject ( configProperties ,    className ,    jndiName ,    poolName ,    enabled ,    useJavaContext )  ;", "return   adminObject ;", "}", "METHOD_END"], "methodName": ["buildAdminObjects"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    configProperties    =    new   HashMap < String ,    String >  (  0  )  ;", "String   className    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . CLASS _ NAME )  ;", "String   jndiName    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . JNDINAME )  ;", "boolean   enabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . ENABLED )  ;", "boolean   connectable    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . CONNECTABLE )  ;", "Boolean   tracking    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . TRACKING )  ;", "boolean   useJavaContext    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . USE _ JAVA _ CONTEXT )  ;", "boolean   useCcm    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . USE _ CCM )  ;", "boolean   sharable    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . SHARABLE )  ;", "boolean   enlistment    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . ENLISTMENT )  ;", "final   String   mcp    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . MCP )  ;", "final   Boolean   enlistmentTrace    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . ENLISTMENT _ TRACE )  ;", "int   maxPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . MAX _ POOL _ SIZE )  ;", "int   minPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . MIN _ POOL _ SIZE )  ;", "Integer   initialPoolSize    =    ModelNodeUtil . getIntIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . INITIAL _ POOL _ SIZE )  ;", "boolean   prefill    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . POOL _ PREFILL )  ;", "boolean   fair    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . POOL _ FAIR )  ;", "boolean   useStrictMin    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . POOL _ USE _ STRICT _ MIN )  ;", "String   flushStrategyString    =    common . pool . Constants . POOL _ FLUSH _ STRATEGY . resolveModelAttribute ( context ,    connDefModel )  . asString (  )  ;", "final   FlushStrategy   flushStrategy    =    FlushStrategy . forName ( flushStrategyString )  ;", "Boolean   isSameRM    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . SAME _ RM _ OVERRIDE )  ;", "boolean   interlivng    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . INTERLEAVING )  ;", "boolean   padXid    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . PAD _ XID )  ;", "boolean   wrapXaResource    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . WRAP _ XA _ RESOURCE )  ;", "boolean   noTxSeparatePool    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . NOTXSEPARATEPOOL )  ;", "Integer   allocationRetry    =    ModelNodeUtil . getIntIfSetOrGetDefault ( context ,    connDefModel ,    Constants . ALLOCATION _ RETRY )  ;", "Long   allocationRetryWaitMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( context ,    connDefModel ,    Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS )  ;", "Long   blockingTimeoutMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS )  ;", "Long   idleTimeoutMinutes    =    ModelNodeUtil . getLongIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . IDLETIMEOUTMINUTES )  ;", "Integer   xaResourceTimeout    =    ModelNodeUtil . getIntIfSetOrGetDefault ( context ,    connDefModel ,    Constants . XA _ RESOURCE _ TIMEOUT )  ;", "TimeOut   timeOut    =    new   TimeOutImpl ( blockingTimeoutMillis ,    idleTimeoutMinutes ,    allocationRetry ,    allocationRetryWaitMillis ,    xaResourceTimeout )  ;", "Extension   incrementer    =    ModelNodeUtil . extractExtension ( context ,    connDefModel ,    common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS ,    common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES )  ;", "Extension   decrementer    =    ModelNodeUtil . extractExtension ( context ,    connDefModel ,    common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS ,    common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES )  ;", "final   Capacity   capacity    =    new   Capacity ( incrementer ,    decrementer )  ;", "Pool   pool ;", "if    ( isXa )     {", "pool    =    new   XaPoolImpl ( minPoolSize ,    initialPoolSize ,    maxPoolSize ,    prefill ,    useStrictMin ,    flushStrategy ,    capacity ,    fair ,    isSameRM ,    interlivng ,    padXid ,    wrapXaResource ,    noTxSeparatePool )  ;", "} else    {", "pool    =    new   PoolImpl ( minPoolSize ,    initialPoolSize ,    maxPoolSize ,    prefill ,    useStrictMin ,    flushStrategy ,    capacity ,    fair )  ;", "}", "String   securityDomain    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . SECURITY _ DOMAIN )  ;", "String   securityDomainAndApplication    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . SECURITY _ DOMAIN _ AND _ APPLICATION )  ;", "boolean   elytronEnabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . ELYTRON _ ENABLED )  ;", "String   authenticationContext    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . AUTHENTICATION _ CONTEXT )  ;", "String   authenticationContextAndApplication    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . AUTHENTICATION _ CONTEXT _ AND _ APPLICATION )  ;", "boolean   application    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . APPLICATION )  ;", "Security   security    =    null ;", "if    (  (  (  (  ( securityDomain    !  =    null )     |  |     ( authenticationContext    !  =    null )  )     |  |     ( securityDomainAndApplication    !  =    null )  )     |  |     ( authenticationContextAndApplication    !  =    null )  )     |  |    application )     {", "security    =    new   SecurityImpl (  ( elytronEnabled    ?    authenticationContext    :    securityDomain )  ,     ( elytronEnabled    ?    authenticationContextAndApplication    :    securityDomainAndApplication )  ,    application ,    elytronEnabled )  ;", "}", "Long   backgroundValidationMillis    =    ModelNodeUtil . getLongIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . BACKGROUNDVALIDATIONMILLIS )  ;", "Boolean   backgroundValidation    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . BACKGROUNDVALIDATION )  ;", "boolean   useFastFail    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . USE _ FAST _ FAIL )  ;", "final   Boolean   validateOnMatch    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    common . pool . Constants . VALIDATE _ ON _ MATCH )  ;", "Validation   validation    =    new   ValidationImpl ( validateOnMatch ,    backgroundValidation ,    backgroundValidationMillis ,    useFastFail )  ;", "final   String   recoveryUsername    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . RECOVERY _ USERNAME )  ;", "final   String   recoveryPassword    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . RECOVERY _ PASSWORD )  ;", "final   String   recoverySecurityDomain    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . RECOVERY _ SECURITY _ DOMAIN )  ;", "final   boolean   recoveryElytronEnabled    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . RECOVERY _ ELYTRON _ ENABLED )  ;", "final   String   recoveryAuthenticationContext    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    connDefModel ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT )  ;", "Boolean   noRecovery    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    connDefModel ,    Constants . NO _ RECOVERY )  ;", "Recovery   recovery    =    null ;", "if    (  (  (  (  ( recoveryUsername    !  =    null )     &  &     (  ( recoveryPassword    !  =    null )     |  |     ( recoveryCredentialSourceSupplier    !  =    null )  )  )     |  |     ( recoverySecurityDomain    !  =    null )  )     |  |     ( recoveryAuthenticationContext    !  =    null )  )     |  |     ( noRecovery    !  =    null )  )     {", "Credential   credential    =    null ;", "if    (  (  (  ( recoveryUsername    !  =    null )     &  &     (  ( recoveryPassword    !  =    null )     |  |     ( recoveryCredentialSourceSupplier    !  =    null )  )  )     |  |     ( recoverySecurityDomain    !  =    null )  )     |  |     ( recoveryAuthenticationContext    !  =    null )  )", "credential    =    new   CredentialImpl ( recoveryUsername ,    recoveryPassword ,     ( recoveryElytronEnabled    ?    recoveryAuthenticationContext    :    recoverySecurityDomain )  ,    recoveryElytronEnabled ,    recoveryCredentialSourceSupplier )  ;", "Extension   recoverPlugin    =    ModelNodeUtil . extractExtension ( context ,    connDefModel ,    Constants . RECOVERLUGIN _ CLASSNAME ,    Constants . RECOVERLUGIN _ PROPERTIES )  ;", "if    ( noRecovery    =  =    null )", "noRecovery    =    Boolean . FALSE ;", "recovery    =    new   Recovery ( credential ,    recoverPlugin ,    noRecovery )  ;", "}", "ModifiableConnDef   connectionDefinition    =    new   ModifiableConnDef ( configProperties ,    className ,    jndiName ,    poolName ,    enabled ,    useJavaContext ,    useCcm ,    pool ,    timeOut ,    validation ,    security ,    recovery ,    sharable ,    enlistment ,    connectable ,    tracking ,    mcp ,    enlistmentTrace )  ;", "return   connectionDefinition ;", "}", "METHOD_END"], "methodName": ["buildConnectionDefinitionObject"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    configProperties    =    new   HashMap <  >  (  0  )  ;", "List < ConnectionDefinition >    connectionDefinitions    =    new   ArrayList <  >  (  0  )  ;", "List < AdminObject >    adminObjects    =    new   ArrayList <  >  (  0  )  ;", "TransactionSupportEnum   transactionSupport    =     ( o . hasDefined ( Constants . TRANSACTION _ SUPPORT . getName (  )  )  )     ?    TransactionSupportEnum . valueOf ( o . get ( Constants . TRANSACTION _ SUPPORT . getName (  )  )  . asString (  )  )     :    null ;", "String   bootstrapContext    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    o ,    Constants . BOOTSTRAP _ CONTEXT )  ;", "List < String >    beanValidationGroups    =    Constants . BEANVALIDATION _ GROUPS . unwrap ( context ,    o )  ;", "boolean   wmSecurity    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    o ,    Constants . WM _ SECURITY )  ;", "WorkManager   workManager    =    null ;", "if    ( wmSecurity )     {", "final   boolean   mappingRequired    =    ModelNodeUtil . getBooleanIfSetOrGetDefault ( context ,    o ,    Constants . WM _ SECURITY _ MAPPING _ REQUIRED )  ;", "String   domain ;", "final   String   elytronDomain    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    o ,    Constants . WM _ ELYTRON _ SECURITY _ DOMAIN )  ;", "if    ( elytronDomain    !  =    null )     {", "domain    =    elytronDomain ;", "} else    {", "domain    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    o ,    Constants . WM _ SECURITY _ DOMAIN )  ;", "}", "final   String   defaultPrincipal    =    ModelNodeUtil . getResolvedStringIfSetOrGetDefault ( context ,    o ,    Constants . WM _ SECURITY _ DEFAULT _ PRINCIPAL )  ;", "final   List < String >    defaultGroups    =    Constants . WM _ SECURITY _ DEFAULT _ GROUPS . unwrap ( context ,    o )  ;", "final   Map < String ,    String >    groups    =    ModelNodeUtil . extractMap ( o ,    Constants . WM _ SECURITY _ MAPPING _ GROUPS ,    Constants . WM _ SECURITY _ MAPPING _ FROM ,    Constants . WM _ SECURITY _ MAPPING _ TO )  ;", "final   Map < String ,    String >    users    =    ModelNodeUtil . extractMap ( o ,    Constants . WM _ SECURITY _ MAPPING _ USERS ,    Constants . WM _ SECURITY _ MAPPING _ FROM ,    Constants . WM _ SECURITY _ MAPPING _ TO )  ;", "workManager    =    new   WorkManagerImpl ( new   WorkManagerSecurityImpl ( mappingRequired ,    domain ,     ( elytronDomain    !  =    null )  ,    defaultPrincipal ,    defaultGroups ,    users ,    groups )  )  ;", "}", "ModifiableResourceAdapter   ra ;", "ra    =    new   ModifiableResourceAdapter ( id ,    archiveOrModule ,    transactionSupport ,    connectionDefinitions ,    adminObjects ,    configProperties ,    beanValidationGroups ,    bootstrapContext ,    workManager )  ;", "return   ra ;", "}", "METHOD_END"], "methodName": ["buildResourceAdaptersObject"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   ServiceController <  ?  >    resourceAdaptersService    =    context . getServiceRegistry ( false )  . getService ( ConnectorServices . RESOURCEADAPTERS _ SERVICE )  ;", "if    ( resourceAdaptersService    =  =    null )     {", "newControllers . add ( serviceTarget . addService ( ConnectorServices . RESOURCEADAPTERS _ SERVICE ,    new   ResourceAdaptersService (  )  )  . setInitialMode ( ACTIVE )  . install (  )  )  ;", "}", "ServiceName   raServiceName    =    ServiceName . of ( ConnectorServices . RA _ SERVICE ,    name )  ;", "final   ServiceController <  ?  >    service    =    context . getServiceRegistry ( true )  . getService ( raServiceName )  ;", "if    ( service    =  =    null )     {", "ResourceAdapterService   raService    =    new   ResourceAdapterService ( resourceAdapter ,    name )  ;", "ServiceBuilder   builder    =    serviceTarget . addService ( raServiceName ,    raService )  . setInitialMode ( ACTIVE )  . addDependency ( ConnectorServices . RESOURCEADAPTERS _ SERVICE ,    ResourceAdaptersService . ModifiableResourceAdaptors . class ,    raService . getResourceAdaptersInjector (  )  )  . addDependency ( ConnectorServices . RESOURCEADAPTERS _ SUBSYSTEM _ SERVICE ,    CopyOnWriteArrayListMultiMap . class ,    raService . getResourceAdaptersMapInjector (  )  )  ;", "for    ( ConnectionDefinition   cd    :    resourceAdapter . getConnectionDefinitions (  )  )     {", "Security   security    =    cd . getSecurity (  )  ;", "if    ( security    !  =    null )     {", "final   boolean   elytronEnabled    =     ( security   instanceof   SecurityMetadata )     &  &     (  (  ( SecurityMetadata )     ( security )  )  . isElytronEnabled (  )  )  ;", "if    (  ( security . getSecurityDomain (  )  )     !  =    null )     {", "if    (  ! elytronEnabled )     {", "builder . addDependency ( SERVICE _ NAME . append ( security . getSecurityDomain (  )  )  )  ;", "} else    {", "builder . addDependency ( context . getCapabilityServiceName ( Capabilities . AUTHENTICATION _ CONTEXT _ CAPABILITY ,    security . getSecurityDomain (  )  ,    AuthenticationContext . class )  )  ;", "}", "}", "if    (  ( security . getSecurityDomainAndApplication (  )  )     !  =    null )     {", "if    (  ! elytronEnabled )     {", "builder . addDependency ( SERVICE _ NAME . append ( security . getSecurityDomainAndApplication (  )  )  )  ;", "} else    {", "builder . addDependency ( context . getCapabilityServiceName ( Capabilities . AUTHENTICATION _ CONTEXT _ CAPABILITY ,    security . getSecurityDomainAndApplication (  )  ,    AuthenticationContext . class )  )  ;", "}", "}", "if    (  (  (  ( cd . getRecovery (  )  )     !  =    null )     &  &     (  ( cd . getRecovery (  )  . getCredential (  )  )     !  =    null )  )     &  &     (  ( cd . getRecovery (  )  . getCredential (  )  . getSecurityDomain (  )  )     !  =    null )  )     {", "if    (  ! elytronEnabled )     {", "builder . addDependency ( SERVICE _ NAME . append ( cd . getRecovery (  )  . getCredential (  )  . getSecurityDomain (  )  )  )  ;", "} else    {", "builder . addDependency ( context . getCapabilityServiceName ( Capabilities . AUTHENTICATION _ CONTEXT _ CAPABILITY ,    cd . getRecovery (  )  . getCredential (  )  . getSecurityDomain (  )  ,    AuthenticationContext . class )  )  ;", "}", "}", "}", "}", "if    (  ( resourceAdapter . getWorkManager (  )  )     !  =    null )     {", "final   WorkManagerSecurity   workManagerSecurity    =    resourceAdapter . getWorkManager (  )  . getSecurity (  )  ;", "if    ( workManagerSecurity    !  =    null )     {", "final   boolean   elytronEnabled    =     ( workManagerSecurity   instanceof   metadata . api . resourceadapter . WorkManagerSecurity )     &  &     (  (  ( metadata . api . resourceadapter . WorkManagerSecurity )     ( workManagerSecurity )  )  . isElytronEnabled (  )  )  ;", "final   String   securityDomainName    =    workManagerSecurity . getDomain (  )  ;", "if    ( securityDomainName    !  =    null )     {", "if    (  ! elytronEnabled )     {", "builder . addDependency ( SERVICE _ NAME . append ( securityDomainName )  )  ;", "} else    {", "builder . addDependency ( context . getCapabilityServiceName ( Capabilities . ELYTRON _ SECURITY _ DOMAIN _ CAPABILITY ,    securityDomainName ,    SecurityDomain . class )  )  ;", "}", "}", "}", "}", "newControllers . add ( builder . install (  )  )  ;", "}", "return   raServiceName ;", "}", "METHOD_END"], "methodName": ["installRaServices"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "ServiceName   raServiceName    =    RaOperationUtil . installRaServices ( context ,    name ,    resourceAdapter ,    newControllers )  ;", "final   boolean   resolveProperties    =    true ;", "final   ServiceTarget   serviceTarget    =    context . getServiceTarget (  )  ;", "final   String   moduleName ;", "String   slot    =     \" main \"  ;", "if    ( fullModuleName . contains (  \"  :  \"  )  )     {", "slot    =    fullModuleName . substring (  (  ( fullModuleName . indexOf (  \"  :  \"  )  )     +     1  )  )  ;", "moduleName    =    fullModuleName . substring (  0  ,    fullModuleName . indexOf (  \"  :  \"  )  )  ;", "} else    {", "moduleName    =    fullModuleName ;", "}", "Module   module ;", "try    {", "ModuleIdentifier   moduleId    =    ModuleIdentifier . create ( moduleName ,    slot )  ;", "module    =    Module . getCallerModuleLoader (  )  . loadModule ( moduleId )  ;", "}    catch    ( ModuleLoadException   e )     {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . failedToLoadModuleRA ( moduleName )  ,    e )  ;", "}", "URL   path    =    module . getExportedResource (  \" META - INF / ra . xml \"  )  ;", "Closeable   closable    =    null ;", "try    {", "VirtualFile   child ;", "if    ( path . getPath (  )  . contains (  \"  !  \"  )  )     {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . compressedRarNotSupportedInModuleRA ( moduleName )  )  ;", "} else    {", "child    =    VFS . getChild ( path . getPath (  )  . split (  \" META - INF \"  )  [  0  ]  )  ;", "closable    =    VFS . mountReal ( new   File ( path . getPath (  )  . split (  \" META - INF \"  )  [  0  ]  )  ,    child )  ;", "}", "final   MountHandle   mountHandle    =    new   MountHandle ( closable )  ;", "final   ResourceRoot   resourceRoot    =    new   ResourceRoot ( child ,    mountHandle )  ;", "final   VirtualFile   deploymentRoot    =    resourceRoot . getRoot (  )  ;", "if    (  ( deploymentRoot    =  =    null )     |  |     (  !  ( deploymentRoot . exists (  )  )  )  )", "return ;", "ConnectorXmlDescriptor   connectorXmlDescriptor    =    RaDeploymentParsingProcessor . process ( resolveProperties ,    deploymentRoot ,    null ,    name )  ;", "IronJacamarXmlDescriptor   ironJacamarXmlDescriptor    =    IronJacamarDeploymentParsingProcessor . process ( deploymentRoot ,    resolveProperties )  ;", "RaNativeProcessor . process ( deploymentRoot )  ;", "Map < ResourceRoot ,    Index >    annotationIndexes    =    new   HashMap < ResourceRoot ,    Index >  (  )  ;", "ResourceRootIndexer . indexResourceRoot ( resourceRoot )  ;", "Index   index    =    resourceRoot . getAttachment ( ANNOTATION _ INDEX )  ;", "if    ( index    !  =    null )     {", "annotationIndexes . put ( resourceRoot ,    index )  ;", "}", "if    ( ironJacamarXmlDescriptor    !  =    null )     {", "ConnectorLogger . SUBSYSTEM _ RA _ LOGGER . forceIJToNull (  )  ;", "ironJacamarXmlDescriptor    =    null ;", "}", "final   ServiceName   deployerServiceName    =    ConnectorServices . RESOURCE _ ADAPTER _ DEPLOYER _ SERVICE _ PREFIX . append ( connectorXmlDescriptor . getDeploymentName (  )  )  ;", "final   ServiceController <  ?  >    deployerService    =    context . getServiceRegistry ( true )  . getService ( deployerServiceName )  ;", "if    ( deployerService    =  =    null )     {", "ServiceBuilder   builder    =    ParsedRaDeploymentProcessor . process ( connectorXmlDescriptor ,    ironJacamarXmlDescriptor ,    module . getClassLoader (  )  ,    serviceTarget ,    annotationIndexes ,    RaOperationUtil . RAR _ MODULE . append ( name )  ,    null ,    null )  ;", "newControllers . add ( builder . addDependency ( raServiceName )  . setInitialMode ( ACTIVE )  . install (  )  )  ;", "}", "String   rarName    =    resourceAdapter . getArchive (  )  ;", "if    ( fullModuleName . equals ( rarName )  )     {", "ServiceName   serviceName    =    ConnectorServices . INACTIVE _ RESOURCE _ ADAPTER _ SERVICE . append ( name )  ;", "InactiveResourceAdapterDeploymentService   service    =    new   InactiveResourceAdapterDeploymentService ( connectorXmlDescriptor ,    module ,    name ,    name ,    RaOperationUtil . RAR _ MODULE . append ( name )  ,    null ,    serviceTarget ,    null )  ;", "newControllers . add ( serviceTarget . addService ( serviceName ,    service )  . setInitialMode ( ACTIVE )  . install (  )  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   OperationFailedException ( ConnectorLogger . ROOT _ LOGGER . failedToLoadModuleRA ( moduleName )  ,    e )  ;", "}    finally    {", "if    ( closable    !  =    null )     {", "try    {", "closable . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["installRaServicesAndDeployFromModule"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "boolean   wasActive    =    false ;", "final   ServiceName   raDeploymentServiceName ;", "if    ( raName    =  =    null )     {", "raDeploymentServiceName    =    CServices . getDeploymentServiceName ( id )  ;", "} else    {", "raDeploymentServiceName    =    CServices . getDeploymentServiceName ( raName ,    id )  ;", "}", "if    (  ( context . getServiceRegistry ( true )  . getService ( raDeploymentServiceName )  )     !  =    null )     {", "context . removeService ( raDeploymentServiceName )  ;", "wasActive    =    true ;", "}", "return   wasActive ;", "}", "METHOD_END"], "methodName": ["removeIfActive"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "final   ServiceName   raDeploymentServiceName    =    ConnectorServices . getDeploymentServiceName ( raName ,    id )  ;", "final   ServiceRegistry   registry    =    context . getServiceRegistry ( true )  ;", "ServiceController   raServiceController    =    registry . getService ( raDeploymentServiceName )  ;", "if    ( raServiceController    !  =    null )     {", "final   ServiceController . Mode   originalMode    =    raServiceController . getMode (  )  ;", "raServiceController . addListener ( new   AbstractServiceListener (  )     {", "@ Override", "public   void   transition ( ServiceController   controller ,    ServiceController . Transition   transition )     {", "switch    ( transition )     {", "case   STOPPING _ to _ DOWN    :", "try    {", "final   ServiceController <  ?  >    RaxmlController    =    registry . getService ( ServiceName . of ( ConnectorServices . RA _ SERVICE ,    id )  )  ;", "Activation   raxml    =     (  ( Activation )     ( RaxmlController . getValue (  )  )  )  ;", "(  ( ResourceAdapterXmlDeploymentService )     ( controller . getService (  )  )  )  . setRaxml ( raxml )  ;", "controller . compareAndSetMode ( NEVER ,    originalMode )  ;", "}    finally    {", "controller . removeListener ( this )  ;", "}", "}", "}", "@ Override", "public   void   listenerAdded ( ServiceController   controller )     {", "controller . setMode ( NEVER )  ;", "}", "}  )  ;", "return   raDeploymentServiceName ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["restartIfPresent"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaOperationUtil"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   opAddr    =    operation . require ( ModelDescriptionConstants . OP _ ADDR )  ;", "final   String   idName    =    PathAddress . pathAddress ( opAddr )  . getLastElement (  )  . getValue (  )  ;", "final   boolean   isModule ;", "final   ModelNode   model    =    context . readResource ( EMPTY _ ADDRESS ,    false )  . getModel (  )  ;", "final   String   archiveOrModuleName ;", "if    (  (  !  ( model . hasDefined ( Constants . ARCHIVE . getName (  )  )  )  )     &  &     (  !  ( model . hasDefined ( Constants . MODULE . getName (  )  )  )  )  )     {", "throw   CLogger . ROOT _ LOGGER . archiveOrModuleRequired (  )  ;", "}", "if    ( model . get ( Constants . ARCHIVE . getName (  )  )  . isDefined (  )  )     {", "isModule    =    false ;", "archiveOrModuleName    =    model . get ( Constants . ARCHIVE . getName (  )  )  . asString (  )  ;", "} else    {", "isModule    =    true ;", "archiveOrModuleName    =    model . get ( Constants . MODULE . getName (  )  )  . asString (  )  ;", "}", "final   ModelNode   compensating    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    opAddr )  ;", "if    ( model . hasDefined ( Constants . RESOURCEADAPTERS _ NAME )  )     {", "for    ( ModelNode   raNode    :    model . get ( Constants . RESOURCEADAPTERS _ NAME )  . asList (  )  )     {", "ModelNode   raCompensatingNode    =    raNode . clone (  )  ;", "compensating . get ( Constants . RESOURCEADAPTERS _ NAME )  . add ( raCompensatingNode )  ;", "}", "}", "context . removeResource ( EMPTY _ ADDRESS )  ;", "if    ( context . isDefaultRequiresRuntime (  )  )     {", "context . addStep ( new   OperationStepHandler (  )     {", "public   void   execute ( OperationContext   context ,    ModelNode   operation )    throws   OperationFailedException    {", "final   boolean   wasActive ;", "wasActive    =    RaOperationUtil . removeIfActive ( context ,    archiveOrModuleName ,    idName )  ;", "if    ( wasActive )     {", "if    (  !  ( context . isResourceServiceRestartAllowed (  )  )  )     {", "context . reloadRequired (  )  ;", "context . completeStep ( new   OperationContext . RollbackHandler (  )     {", "@ Override", "public   void   handleRollback ( OperationContext   context ,    ModelNode   operation )     {", "context . revertReloadRequired (  )  ;", "}", "}  )  ;", "return ;", "}", "}", "ServiceName   raServiceName    =    ServiceName . of ( CServices . RA _ SERVICE ,    idName )  ;", "ServiceController <  ?  >    serviceController    =    context . getServiceRegistry ( false )  . getService ( raServiceName )  ;", "final   ModifiableResourceAdapter   resourceAdapter ;", "if    ( serviceController    !  =    null )     {", "resourceAdapter    =     (  ( ModifiableResourceAdapter )     ( serviceController . getValue (  )  )  )  ;", "} else    {", "resourceAdapter    =    null ;", "}", "final   List < ServiceName >    serviceNameList    =    context . getServiceRegistry ( false )  . getServiceNames (  )  ;", "for    ( ServiceName   name    :    serviceNameList )     {", "if    ( raServiceName . isParentOf ( name )  )     {", "context . removeService ( name )  ;", "}", "}", "if    ( model . get ( Constants . MODULE . getName (  )  )  . isDefined (  )  )     {", "ServiceName   deployerServiceName    =    CServices . RESOURCE _ ADAPTER _ DEPLOYER _ SERVICE _ PREFIX . append ( idName )  ;", "context . removeService ( deployerServiceName )  ;", "ServiceName   inactiveServiceName    =    CServices . INACTIVE _ RESOURCE _ ADAPTER _ SERVICE . append ( idName )  ;", "context . removeService ( inactiveServiceName )  ;", "}", "context . removeService ( raServiceName )  ;", "context . completeStep ( new   OperationContext . RollbackHandler (  )     {", "@ Override", "public   void   handleRollback ( OperationContext   context ,    ModelNode   operation )     {", "if    ( resourceAdapter    !  =    null )     {", "List < ServiceController <  ?  >  >    newControllers    =    new   LinkedList < ServiceController <  ?  >  >  (  )  ;", "if    ( model . get ( Constants . ARCHIVE . getName (  )  )  . isDefined (  )  )     {", "RaOperationUtil . installRaServices ( context ,    idName ,    resourceAdapter ,    newControllers )  ;", "} else    {", "try    {", "RaOperationUtil . installRaServicesAndDeployFromModule ( context ,    idName ,    resourceAdapter ,    archiveOrModuleName ,    newControllers )  ;", "}    catch    ( OperationFailedException   e )     {", "}", "}", "try    {", "if    ( wasActive )     {", "RaOperationUtil . activate ( context ,    idName ,    archiveOrModuleName )  ;", "}", "}    catch    ( OperationFailedException   e )     {", "}", "}", "}", "}  )  ;", "}", "}  ,    RUNTIME )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.RaRemove"}, {"methodBody": ["METHOD_START", "{", "int   iterate ;", "try    {", "iterate    =    reader . nextTag (  )  ;", "}    catch    ( XMLStreamException   e )     {", "iterate    =    reader . nextTag (  )  ;", "}", "switch    ( iterate )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    (  . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   RESOURCE _ ADAPTERS    :", "{", "parseResourceAdapters ( reader ,    list ,    parentAddress )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "default    :", "throw   new   IllegalStateException (  )  ;", "}", "return ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   raAddress    =    parentAddress . clone (  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "String   archiveOrModuleName    =    null ;", "HashMap < String ,    ModelNode >    configPropertiesOperations    =    new   HashMap < String ,    ModelNode >  (  )  ;", "HashMap < String ,    ModelNode >    connectionDefinitionsOperations    =    new   HashMap < String ,    ModelNode >  (  )  ;", "HashMap < String ,    HashMap < String ,    ModelNode >  >    cfConfigPropertiesOperations    =    new   HashMap < String ,    HashMap < String ,    ModelNode >  >  (  )  ;", "HashMap < String ,    ModelNode >    adminObjectsOperations    =    new   HashMap < String ,    ModelNode >  (  )  ;", "HashMap < String ,    HashMap < String ,    ModelNode >  >    aoConfigPropertiesOperations    =    new   HashMap < String ,    HashMap < String ,    ModelNode >  >  (  )  ;", "boolean   archiveOrModuleMatched    =    false ;", "boolean   txSupportMatched    =    false ;", "boolean   isXa    =    false ;", "String   id    =    null ;", "int   attributeSize    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    attributeSize ;    i +  +  )     {", ". Attribute   attribute    =     . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( attribute )     {", "case   ID    :", "{", "id    =    value ;", "break ;", "}", "case   STATISTICS _ ENABLED    :", "Constants . STATISTICS _ ENABLED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "break ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . RESOURCE _ ADAPTER )  )     {", "if    (  ! archiveOrModuleMatched )     {", "throw   new   ParserException (  . bundle . requiredElementMissing ( Constants . ARCHIVE . getName (  )  ,    Constants . RESOURCEADAPTER _ NAME )  )  ;", "}", "if    ( id    !  =    null )     {", "raAddress . add ( Constants . RESOURCEADAPTER _ NAME ,    id )  ;", "} else    {", "raAddress . add ( Constants . RESOURCEADAPTER _ NAME ,    archiveOrModuleName )  ;", "}", "raAddress . protect (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( raAddress )  ;", "list . add ( operation )  ;", "for    ( Map . Entry < String ,    ModelNode >    entry    :    configPropertiesOperations . entrySet (  )  )     {", "final   ModelNode   env    =    raAddress . clone (  )  ;", "env . add ( Constants . CONFIG _ PROPERTIES . getName (  )  ,    entry . getKey (  )  )  ;", "env . protect (  )  ;", "entry . getValue (  )  . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( env )  ;", "list . add ( entry . getValue (  )  )  ;", "}", "for    ( Map . Entry < String ,    ModelNode >    entry    :    connectionDefinitionsOperations . entrySet (  )  )     {", "final   ModelNode   env    =    raAddress . clone (  )  ;", "env . add ( Constants . CONNECTIONDEFINITIONS _ NAME ,    entry . getKey (  )  )  ;", "env . protect (  )  ;", "entry . getValue (  )  . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( env )  ;", "list . add ( entry . getValue (  )  )  ;", "final   HashMap < String ,    ModelNode >    properties    =    cfConfigPropertiesOperations . get ( entry . getKey (  )  )  ;", "if    ( properties    !  =    null )     {", "for    ( Map . Entry < String ,    ModelNode >    configEntry    :    properties . entrySet (  )  )     {", "final   ModelNode   configEnv    =    env . clone (  )  ;", "configEnv . add ( Constants . CONFIG _ PROPERTIES . getName (  )  ,    configEntry . getKey (  )  )  ;", "configEnv . protect (  )  ;", "configEntry . getValue (  )  . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configEnv )  ;", "list . add ( configEntry . getValue (  )  )  ;", "}", "}", "}", "for    ( Map . Entry < String ,    ModelNode >    entry    :    adminObjectsOperations . entrySet (  )  )     {", "final   ModelNode   env    =    raAddress . clone (  )  ;", "env . add ( Constants . ADMIN _ OBJECTS _ NAME ,    entry . getKey (  )  )  ;", "env . protect (  )  ;", "entry . getValue (  )  . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( env )  ;", "list . add ( entry . getValue (  )  )  ;", "final   HashMap < String ,    ModelNode >    aoProperties    =    aoConfigPropertiesOperations . get ( entry . getKey (  )  )  ;", "if    ( aoProperties    !  =    null )     {", "for    ( Map . Entry < String ,    ModelNode >    configEntry    :    aoProperties . entrySet (  )  )     {", "final   ModelNode   configEnv    =    env . clone (  )  ;", "configEnv . add ( Constants . CONFIG _ PROPERTIES . getName (  )  ,    configEntry . getKey (  )  )  ;", "configEnv . protect (  )  ;", "configEntry . getValue (  )  . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( configEnv )  ;", "list . add ( configEntry . getValue (  )  )  ;", "}", "}", "}", "return ;", "} else    {", "if    (  ( AS 7 ResourceAdapterTags . forName ( reader . getLocalName (  )  )  )     =  =     ( AS 7 ResourceAdapterTags . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( AS 7 ResourceAdapterTags . forName ( reader . getLocalName (  )  )  )     {", "case   ADMIN _ OBJECTS    :", "case   CONNECTION _ DEFINITIONS    :", "case   BEAN _ VALIDATION _ GROUPS    :", "{", "break ;", "}", "case   ADMIN _ OBJECT    :", "{", "parseAdminObjects ( reader ,    adminObjectsOperations ,    aoConfigPropertiesOperations )  ;", "break ;", "}", "case   CONNECTION _ DEFINITION    :", "{", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   RESOURCEADAPTERS _  1  _  0     :", "case   RESOURCEADAPTERS _  1  _  1     :", "case   RESOURCEADAPTERS _  2  _  0     :", "parseConnectionDefinitions _  1  _  0  ( reader ,    connectionDefinitionsOperations ,    cfConfigPropertiesOperations ,    isXa )  ;", "break ;", "case   RESOURCEADAPTERS _  3  _  0     :", "parseConnectionDefinitions _  3  _  0  ( reader ,    connectionDefinitionsOperations ,    cfConfigPropertiesOperations ,    isXa )  ;", "break ;", "case   RESOURCEADAPTERS _  4  _  0     :", "parseConnectionDefinitions _  4  _  0  ( reader ,    connectionDefinitionsOperations ,    cfConfigPropertiesOperations ,    isXa )  ;", "break ;", "default    :", "parseConnectionDefinitions _  5  _  0  ( reader ,    connectionDefinitionsOperations ,    cfConfigPropertiesOperations ,    isXa )  ;", "break ;", "}", "break ;", "}", "case   BEAN _ VALIDATION _ GROUP    :", "{", "String   value    =    rawElementText ( reader )  ;", "operation . get ( Constants . BEANVALIDATION _ GROUPS . getName (  )  )  . add ( Constants . BEANVALIDATIONGROUP . parse ( value ,    reader )  )  ;", "break ;", "}", "case   Constants . BOOTSTRAP _ CONTEXT    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . BOOTSTRAP _ CONTEXT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   CONFIG _ PROPERTY    :", "{", "parseConfigProperties ( reader ,    configPropertiesOperations )  ;", "break ;", "}", "case   Constants . TRANSACTION _ SUPPORT    :", "{", "if    ( txSupportMatched )     {", "throw   new   ParserException (  . bundle . unexpectedElement ( Constants . TRANSACTION _ SUPPORT . getXmlName (  )  )  )  ;", "}", "String   value    =    rawElementText ( reader )  ;", "Constants . TRANSACTION _ SUPPORT . parseAndSetParameter ( value ,    operation ,    reader )  ;", "isXa    =     ( value    !  =    null )     &  &     (  ( TransactionSupportEnum . valueOf ( value )  )     =  =     ( TransactionSupportEnum . XATransaction )  )  ;", "txSupportMatched    =    true ;", "break ;", "}", "case   WORKMANAGER    :", "{", "parseWorkManager ( operation ,    reader )  ;", "break ;", "}", "case   Constants . ARCHIVE    :", "{", "if    ( archiveOrModuleMatched )     {", "throw   new   ParserException (  . bundle . unexpectedElement ( Constants . ARCHIVE . getXmlName (  )  )  )  ;", "}", "archiveOrModuleName    =    rawElementText ( reader )  ;", "Constants . ARCHIVE . parseAndSetParameter ( archiveOrModuleName ,    operation ,    reader )  ;", "archiveOrModuleMatched    =    true ;", "break ;", "}", "case   Constants . MODULE    :", "{", "if    ( archiveOrModuleMatched )     {", "throw   new   ParserException (  . bundle . unexpectedElement ( Constants . MODULE . getXmlName (  )  )  )  ;", "}", "String   moduleId    =    rawAttributeText ( reader ,     \" id \"  )  ;", "String   moduleSlot    =    rawAttributeText ( reader ,     \" slot \"  ,     \" main \"  )  ;", "archiveOrModuleName    =     ( moduleId    +     \"  :  \"  )     +    moduleSlot ;", "Constants . MODULE . parseAndSetParameter ( archiveOrModuleName ,    operation ,    reader )  ;", "archiveOrModuleMatched    =    true ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseResourceAdapter"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterParser"}, {"methodBody": ["METHOD_START", "{", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  (  . Tag . forName ( reader . getLocalName (  )  )  )     =  =     (  . Tag . RESOURCE _ ADAPTERS )  )     {", "return ;", "} else    {", "if    (  ( Activations . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Activations . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Activations . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   RESOURCE _ ADAPTER    :", "{", "parseResourceAdapter ( reader ,    list ,    parentAddress )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseResourceAdapters"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterParser"}, {"methodBody": ["METHOD_START", "{", "WorkManagerSecurity   security    =    null ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . WORKMANAGER )  )     {", "return   new   WorkManagerImpl ( security )  ;", "} else    {", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( WorkManager . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   SECURITY    :", "{", "Constants . WM _ SECURITY . parseAndSetParameter (  \" true \"  ,    operation ,    reader )  ;", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   RESOURCEADAPTERS _  1  _  0     :", "case   RESOURCEADAPTERS _  1  _  1     :", "case   RESOURCEADAPTERS _  2  _  0     :", "case   RESOURCEADAPTERS _  3  _  0     :", "case   RESOURCEADAPTERS _  4  _  0     :", "security    =    parseWorkManagerSecurity ( operation ,    reader )  ;", "break ;", "default    :", "security    =    parseWorkManagerSecurity _  5  _  0  ( operation ,    reader )  ;", "}", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseWorkManager"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterParser"}, {"methodBody": ["METHOD_START", "{", "boolean   mappingRequired    =    false ;", "String   domain    =    null ;", "String   defaultPrincipal    =    null ;", "List < String >    defaultGroups    =    null ;", "Map < String ,    String >    userMappings    =    null ;", "Map < String ,    String >    groupMappings    =    null ;", "boolean   userMappingEnabled    =    false ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     {", "return   new   WorkManagerSecurityImpl ( mappingRequired ,    domain ,    false ,    defaultPrincipal ,    defaultGroups ,    userMappings ,    groupMappings )  ;", "} else    {", "if    (  ( WorkManagerSecurity . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( WorkManagerSecurity . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( WorkManagerSecurity . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   DEFAULT _ GROUPS    :", "case   MAPPINGS    :", "{", "break ;", "}", "case   MAPPING _ REQUIRED    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . WM _ SECURITY _ MAPPING _ REQUIRED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DOMAIN    :", "{", "String   value    =    domain    =    rawElementText ( reader )  ;", "Constants . WM _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DEFAULT _ PRINCIPAL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . WM _ SECURITY _ DEFAULT _ PRINCIPAL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   GROUP    :", "{", "String   value    =    rawElementText ( reader )  ;", "operation . get ( Constants . WM _ SECURITY _ DEFAULT _ GROUPS . getName (  )  )  . add ( Constants . WM _ SECURITY _ DEFAULT _ GROUP . parse ( value ,    reader )  )  ;", "break ;", "}", "case   USERS    :", "{", "userMappingEnabled    =    true ;", "break ;", "}", "case   GROUPS    :", "{", "userMappingEnabled    =    false ;", "break ;", "}", "case   MAP    :", "{", "if    ( userMappingEnabled )     {", "String   from    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( from    =  =    null )     |  |     ( from . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "String   to    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( to    =  =    null )     |  |     ( to . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "ModelNode   object    =    new   ModelNode (  )  ;", "Constants . WM _ SECURITY _ MAPPING _ FROM . parseAndSetParameter ( from ,    object ,    reader )  ;", "Constants . WM _ SECURITY _ MAPPING _ TO . parseAndSetParameter ( to ,    object ,    reader )  ;", "operation . get ( Constants . WM _ SECURITY _ MAPPING _ USERS . getName (  )  )  . add ( object )  ;", "} else    {", "String   from    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( from    =  =    null )     |  |     ( from . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "String   to    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( to    =  =    null )     |  |     ( to . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "ModelNode   object    =    new   ModelNode (  )  ;", "Constants . WM _ SECURITY _ MAPPING _ FROM . parseAndSetParameter ( from ,    object ,    reader )  ;", "Constants . WM _ SECURITY _ MAPPING _ TO . parseAndSetParameter ( to ,    object ,    reader )  ;", "operation . get ( Constants . WM _ SECURITY _ MAPPING _ GROUPS . getName (  )  )  . add ( object )  ;", "}", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseWorkManagerSecurity"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterParser"}, {"methodBody": ["METHOD_START", "{", "boolean   mappingRequired    =    false ;", "String   domain    =    null ;", "boolean   elytronEnabled    =    false ;", "String   defaultPrincipal    =    null ;", "List < String >    defaultGroups    =    null ;", "Map < String ,    String >    userMappings    =    null ;", "Map < String ,    String >    groupMappings    =    null ;", "boolean   userMappingEnabled    =    false ;", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . SECURITY )  )     {", "return   new   WorkManagerSecurityImpl ( mappingRequired ,    domain ,    elytronEnabled ,    defaultPrincipal ,    defaultGroups ,    userMappings ,    groupMappings )  ;", "} else    {", "if    (  ( WorkManagerSecurity . Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( WorkManagerSecurity . Tag . UNKNOWN )  )     {", "throw   new   ParserException (  . bundle . unexpectedEndTag ( reader . getLocalName (  )  )  )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( WorkManagerSecurity . Tag . forName ( reader . getLocalName (  )  )  )     {", "case   DEFAULT _ GROUPS    :", "case   MAPPINGS    :", "{", "break ;", "}", "case   MAPPING _ REQUIRED    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . WM _ SECURITY _ MAPPING _ REQUIRED . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DOMAIN    :", "{", "String   value    =    domain    =    rawElementText ( reader )  ;", "Constants . WM _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   ELYTRON _ SECURITY _ DOMAIN    :", "{", "elytronEnabled    =    true ;", "String   value    =    domain    =    rawElementText ( reader )  ;", "Constants . WM _ ELYTRON _ SECURITY _ DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   DEFAULT _ PRINCIPAL    :", "{", "String   value    =    rawElementText ( reader )  ;", "Constants . WM _ SECURITY _ DEFAULT _ PRINCIPAL . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "case   GROUP    :", "{", "String   value    =    rawElementText ( reader )  ;", "operation . get ( Constants . WM _ SECURITY _ DEFAULT _ GROUPS . getName (  )  )  . add ( Constants . WM _ SECURITY _ DEFAULT _ GROUP . parse ( value ,    reader )  )  ;", "break ;", "}", "case   USERS    :", "{", "userMappingEnabled    =    true ;", "break ;", "}", "case   GROUPS    :", "{", "userMappingEnabled    =    false ;", "break ;", "}", "case   MAP    :", "{", "if    ( userMappingEnabled )     {", "String   from    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( from    =  =    null )     |  |     ( from . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "String   to    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( to    =  =    null )     |  |     ( to . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "ModelNode   object    =    new   ModelNode (  )  ;", "Constants . WM _ SECURITY _ MAPPING _ FROM . parseAndSetParameter ( from ,    object ,    reader )  ;", "Constants . WM _ SECURITY _ MAPPING _ TO . parseAndSetParameter ( to ,    object ,    reader )  ;", "operation . get ( Constants . WM _ SECURITY _ MAPPING _ USERS . getName (  )  )  . add ( object )  ;", "} else    {", "String   from    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( from    =  =    null )     |  |     ( from . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "String   to    =    rawAttributeText ( reader ,    Attribute . getLocalName (  )  )  ;", "if    (  ( to    =  =    null )     |  |     ( to . trim (  )  . equals (  \"  \"  )  )  )", "throw   new   ParserException (  . bundle . requiredAttributeMissing ( Attribute . getLocalName (  )  ,    reader . getLocalName (  )  )  )  ;", "ModelNode   object    =    new   ModelNode (  )  ;", "Constants . WM _ SECURITY _ MAPPING _ FROM . parseAndSetParameter ( from ,    object ,    reader )  ;", "Constants . WM _ SECURITY _ MAPPING _ TO . parseAndSetParameter ( to ,    object ,    reader )  ;", "operation . get ( Constants . WM _ SECURITY _ MAPPING _ GROUPS . getName (  )  )  . add ( object )  ;", "}", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseWorkManagerSecurity_5_0"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterParser"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdapters ;", "}", "METHOD_END"], "methodName": ["getResourceAdaptersInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterService"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdaptersMap ;", "}", "METHOD_END"], "methodName": ["getResourceAdaptersMapInjector"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterService"}, {"methodBody": ["METHOD_START", "{", "streamWriter . writeStartElement ( ADMIN _ OBJECT . getLocalName (  )  )  ;", "Constants . CLASS _ NAME . marshallAsAttribute ( adminObject ,    streamWriter )  ;", "Constants . JNDINAME . marshallAsAttribute ( adminObject ,    streamWriter )  ;", "Constants . ENABLED . marshallAsAttribute ( adminObject ,    streamWriter )  ;", "Constants . USE _ JAVA _ CONTEXT . marshallAsAttribute ( adminObject ,    streamWriter )  ;", "streamWriter . writeAttribute (  \" pool - name \"  ,    poolName )  ;", "writeNewConfigProperties ( streamWriter ,    adminObject )  ;", "streamWriter . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeAdminObject"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "streamWriter . writeStartElement ( CONNECTION _ DEFINITION . getLocalName (  )  )  ;", "Constants . CLASS _ NAME . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . JNDINAME . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . ENABLED . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . CONNECTABLE . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . TRACKING . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . USE _ JAVA _ CONTEXT . marshallAsAttribute ( conDef ,    streamWriter )  ;", "streamWriter . writeAttribute (  \" pool - name \"  ,    poolName )  ;", "Constants . USE _ CCM . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . SHARABLE . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . ENLISTMENT . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . MCP . marshallAsAttribute ( conDef ,    streamWriter )  ;", "Constants . ENLISTMENT _ TRACE . marshallAsAttribute ( conDef ,    streamWriter )  ;", "writeNewConfigProperties ( streamWriter ,    conDef )  ;", "boolean   poolRequired    =     (  (  (  (  (  ( common . pool . Constants . INITIAL _ POOL _ SIZE . isMarshallable ( conDef )  )     |  |     ( common . pool . Constants . MAX _ POOL _ SIZE . isMarshallable ( conDef )  )  )     |  |     ( common . pool . Constants . MIN _ POOL _ SIZE . isMarshallable ( conDef )  )  )     |  |     ( common . pool . Constants . POOL _ USE _ STRICT _ MIN . isMarshallable ( conDef )  )  )     |  |     ( common . pool . Constants . POOL _ PREFILL . isMarshallable ( conDef )  )  )     |  |     ( common . pool . Constants . POOL _ FAIR . isMarshallable ( conDef )  )  )     |  |     ( common . pool . Constants . POOL _ FLUSH _ STRATEGY . isMarshallable ( conDef )  )  ;", "final   boolean   capacityRequired    =     (  (  ( common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS . isMarshallable ( conDef )  )     |  |     ( common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES . isMarshallable ( conDef )  )  )     |  |     ( common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS . isMarshallable ( conDef )  )  )     |  |     ( common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES . isMarshallable ( conDef )  )  ;", "poolRequired    =    poolRequired    |  |    capacityRequired ;", "if    ( poolRequired )     {", "if    ( isXa )     {", "streamWriter . writeStartElement ( XA _ POOL . getLocalName (  )  )  ;", "common . pool . Constants . MIN _ POOL _ SIZE . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . INITIAL _ POOL _ SIZE . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . MAX _ POOL _ SIZE . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . POOL _ PREFILL . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . POOL _ FAIR . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . POOL _ USE _ STRICT _ MIN . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . POOL _ FLUSH _ STRATEGY . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . SAME _ RM _ OVERRIDE . marshallAsElement ( conDef ,    streamWriter )  ;", "if    (  ( conDef . hasDefined ( Constants . INTERLEAVING . getName (  )  )  )     &  &     ( conDef . get ( Constants . INTERLEAVING . getName (  )  )  . asBoolean (  )  )  )     {", "streamWriter . writeEmptyElement ( Constants . INTERLEAVING . getXmlName (  )  )  ;", "} else    {", "Constants . INTERLEAVING . marshallAsElement ( conDef ,    streamWriter )  ;", "}", "if    (  ( conDef . hasDefined ( Constants . NOTXSEPARATEPOOL . getName (  )  )  )     &  &     ( conDef . get ( Constants . NOTXSEPARATEPOOL . getName (  )  )  . asBoolean (  )  )  )     {", "streamWriter . writeEmptyElement ( Constants . NOTXSEPARATEPOOL . getXmlName (  )  )  ;", "} else    {", "Constants . NOTXSEPARATEPOOL . marshallAsElement ( conDef ,    streamWriter )  ;", "}", "Constants . PAD _ XID . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . WRAP _ XA _ RESOURCE . marshallAsElement ( conDef ,    streamWriter )  ;", "} else    {", "streamWriter . writeStartElement ( POOL . getLocalName (  )  )  ;", "common . pool . Constants . MIN _ POOL _ SIZE . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . INITIAL _ POOL _ SIZE . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . MAX _ POOL _ SIZE . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . POOL _ PREFILL . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . POOL _ USE _ STRICT _ MIN . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . POOL _ FLUSH _ STRATEGY . marshallAsElement ( conDef ,    streamWriter )  ;", "}", "if    ( capacityRequired )     {", "streamWriter . writeStartElement ( CAPACITY . getLocalName (  )  )  ;", "if    ( conDef . hasDefined ( common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS . getName (  )  )  )     {", "streamWriter . writeStartElement ( INCREMENTER . getLocalName (  )  )  ;", "common . pool . Constants . CAPACITY _ INCREMENTER _ CLASS . marshallAsAttribute ( conDef ,    streamWriter )  ;", "common . pool . Constants . CAPACITY _ INCREMENTER _ PROPERTIES . marshallAsElement ( conDef ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "if    ( conDef . hasDefined ( common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS . getName (  )  )  )     {", "streamWriter . writeStartElement ( DECREMENTER . getLocalName (  )  )  ;", "common . pool . Constants . CAPACITY _ DECREMENTER _ CLASS . marshallAsAttribute ( conDef ,    streamWriter )  ;", "common . pool . Constants . CAPACITY _ DECREMENTER _ PROPERTIES . marshallAsElement ( conDef ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "if    (  (  (  ( conDef . hasDefined ( Constants . APPLICATION . getName (  )  )  )     |  |     ( conDef . hasDefined ( Constants . SECURITY _ DOMAIN . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . SECURITY _ DOMAIN _ AND _ APPLICATION . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . ELYTRON _ ENABLED . getName (  )  )  )  )     {", "streamWriter . writeStartElement ( SECURITY . getLocalName (  )  )  ;", "if    (  ( conDef . hasDefined ( Constants . APPLICATION . getName (  )  )  )     &  &     ( conDef . get ( Constants . APPLICATION . getName (  )  )  . asBoolean (  )  )  )     {", "streamWriter . writeEmptyElement ( Constants . APPLICATION . getXmlName (  )  )  ;", "} else    {", "Constants . APPLICATION . marshallAsElement ( conDef ,    streamWriter )  ;", "}", "Constants . SECURITY _ DOMAIN . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . SECURITY _ DOMAIN _ AND _ APPLICATION . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . ELYTRON _ ENABLED . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . AUTHENTICATION _ CONTEXT . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . AUTHENTICATION _ CONTEXT _ AND _ APPLICATION . marshallAsElement ( conDef ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "if    (  (  (  (  ( conDef . hasDefined ( common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS . getName (  )  )  )     |  |     ( conDef . hasDefined ( common . pool . Constants . IDLETIMEOUTMINUTES . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . ALLOCATION _ RETRY . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . XA _ RESOURCE _ TIMEOUT . getName (  )  )  )  )     {", "streamWriter . writeStartElement ( TIMEOUT . getLocalName (  )  )  ;", "common . pool . Constants . BLOCKING _ TIMEOUT _ WAIT _ MILLIS . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . IDLETIMEOUTMINUTES . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . ALLOCATION _ RETRY . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . ALLOCATION _ RETRY _ WAIT _ MILLIS . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . XA _ RESOURCE _ TIMEOUT . marshallAsElement ( conDef ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "if    (  (  (  ( conDef . hasDefined ( common . pool . Constants . BACKGROUNDVALIDATION . getName (  )  )  )     |  |     ( conDef . hasDefined ( common . pool . Constants . BACKGROUNDVALIDATIONMILLIS . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( common . pool . Constants . USE _ FAST _ FAIL . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( common . pool . Constants . VALIDATE _ ON _ MATCH . getName (  )  )  )  )     {", "streamWriter . writeStartElement ( VALIDATION . getLocalName (  )  )  ;", "common . pool . Constants . BACKGROUNDVALIDATION . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . BACKGROUNDVALIDATIONMILLIS . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . USE _ FAST _ FAIL . marshallAsElement ( conDef ,    streamWriter )  ;", "common . pool . Constants . VALIDATE _ ON _ MATCH . marshallAsElement ( conDef ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "if    (  (  (  (  (  (  ( conDef . hasDefined ( Constants . RECOVERY _ USERNAME . getName (  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERY _ PASSWORD . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERY _ SECURITY _ DOMAIN . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERLUGIN _ CLASSNAME . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERLUGIN _ PROPERTIES . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . NO _ RECOVERY . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . ELYTRON _ ENABLED . getName (  )  )  )  )     {", "streamWriter . writeStartElement ( RECOVERY . getLocalName (  )  )  ;", "Constants . NO _ RECOVERY . marshallAsAttribute ( conDef ,    streamWriter )  ;", "if    (  (  (  (  ( conDef . hasDefined ( Constants . RECOVERY _ USERNAME . getName (  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERY _ PASSWORD . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERY _ CREDENTIAL _ REFERENCE . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERY _ SECURITY _ DOMAIN . getName (  )  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERY _ ELYTRON _ ENABLED . getName (  )  )  )  )     {", "streamWriter . writeStartElement ( RECOVER _ CREDENTIAL . getLocalName (  )  )  ;", "Constants . RECOVERY _ USERNAME . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . RECOVERY _ PASSWORD . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . RECOVERY _ CREDENTIAL _ REFERENCE . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . RECOVERY _ SECURITY _ DOMAIN . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . RECOVERY _ ELYTRON _ ENABLED . marshallAsElement ( conDef ,    streamWriter )  ;", "Constants . RECOVERY _ AUTHENTICATION _ CONTEXT . marshallAsElement ( conDef ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "if    (  ( conDef . hasDefined ( Constants . RECOVERLUGIN _ CLASSNAME . getName (  )  )  )     |  |     ( conDef . hasDefined ( Constants . RECOVERLUGIN _ PROPERTIES . getName (  )  )  )  )     {", "streamWriter . writeStartElement ( RECOVER _ PLUGIN . getLocalName (  )  )  ;", "Constants . RECOVERLUGIN _ CLASSNAME . marshallAsAttribute ( conDef ,    streamWriter )  ;", "if    ( conDef . hasDefined ( Constants . RECOVERLUGIN _ PROPERTIES . getName (  )  )  )     {", "for    ( Property   property    :    conDef . get ( Constants . RECOVERLUGIN _ PROPERTIES . getName (  )  )  . asPropertyList (  )  )     {", "writeProperty ( streamWriter ,    conDef ,    property . getName (  )  ,    property . getValue (  )  . asString (  )  ,    CONFIG _ PROPERTY . getLocalName (  )  )  ;", "}", "}", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeConDef"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    ( ra . hasDefined ( Constants . CONFIG _ PROPERTIES . getName (  )  )  )     {", "for    ( Property   ionProperty    :    ra . get ( Constants . CONFIG _ PROPERTIES . getName (  )  )  . asPropertyList (  )  )     {", "writeProperty ( streamWriter ,    ra ,    ionProperty . getName (  )  ,    ionProperty . getValue (  )  . get (  \" value \"  )  . asString (  )  ,    CONFIG _ PROPERTY . getLocalName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeNewConfigProperties"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( localName )  ;", "writer . writeAttribute (  \" name \"  ,    name )  ;", "writer . writeCharac ( value )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeProperty"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "streamWriter . writeStartElement ( RESOURCE _ ADAPTER . getLocalName (  )  )  ;", "streamWriter . writeAttribute ( Parser . Attribute . ID . getLocalName (  )  ,    name )  ;", "Constants . STATISTICS _ ENABLED . marshallAsAttribute ( ra ,    streamWriter )  ;", "Constants . ARCHIVE . marshallAsElement ( ra ,    streamWriter )  ;", "Constants . MODULE . marshallAsElement ( ra ,    streamWriter )  ;", "Constants . BOOTSTRAP _ CONTEXT . marshallAsElement ( ra ,    streamWriter )  ;", "if    ( ra . hasDefined ( Constants . BEANVALIDATION _ GROUPS . getName (  )  )  )     {", "streamWriter . writeStartElement ( BEAN _ VALIDATION _ GROUPS . getLocalName (  )  )  ;", "for    ( ModelNode   bvg    :    ra . get ( Constants . BEANVALIDATION _ GROUPS . getName (  )  )  . asList (  )  )     {", "streamWriter . writeStartElement ( Constants . BEANVALIDATION _ GROUPS . getXmlName (  )  )  ;", "streamWriter . writeCharacters ( bvg . asString (  )  )  ;", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "Constants . TRANSACTION _ SUPPORT . marshallAsElement ( ra ,    streamWriter )  ;", "writeNewConfigProperties ( streamWriter ,    ra )  ;", "TransactionSupportEnum   transactionSupport    =     ( ra . hasDefined ( Constants . TRANSACTION _ SUPPORT . getName (  )  )  )     ?    TransactionSupportEnum . valueOf ( ra . get ( Constants . TRANSACTION _ SUPPORT . getName (  )  )  . asString (  )  )     :    null ;", "boolean   isXa    =    false ;", "if    ( transactionSupport    =  =     ( TransactionSupportEnum . XATransaction )  )     {", "isXa    =    true ;", "}", "if    (  ( ra . hasDefined ( Constants . WM _ SECURITY . getName (  )  )  )     &  &     ( ra . get ( Constants . WM _ SECURITY . getName (  )  )  . asBoolean (  )  )  )     {", "streamWriter . writeStartElement ( WORKMANAGER . getLocalName (  )  )  ;", "streamWriter . writeStartElement ( SECURITY . getLocalName (  )  )  ;", "Constants . WM _ SECURITY _ MAPPING _ REQUIRED . marshallAsElement ( ra ,    streamWriter )  ;", "Constants . WM _ SECURITY _ DOMAIN . marshallAsElement ( ra ,    streamWriter )  ;", "Constants . WM _ ELYTRON _ SECURITY _ DOMAIN . marshallAsElement ( ra ,    streamWriter )  ;", "Constants . WM _ SECURITY _ DEFAULT _ PRINCIPAL . marshallAsElement ( ra ,    streamWriter )  ;", "if    ( ra . hasDefined ( Constants . WM _ SECURITY _ DEFAULT _ GROUPS . getName (  )  )  )     {", "streamWriter . writeStartElement ( Constants . WM _ SECURITY _ DEFAULT _ GROUPS . getXmlName (  )  )  ;", "for    ( ModelNode   group    :    ra . get ( Constants . WM _ SECURITY _ DEFAULT _ GROUPS . getName (  )  )  . asList (  )  )     {", "streamWriter . writeStartElement ( Constants . WM _ SECURITY _ DEFAULT _ GROUP . getXmlName (  )  )  ;", "streamWriter . writeCharacters ( group . asString (  )  )  ;", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "if    (  ( ra . hasDefined ( Constants . WM _ SECURITY _ MAPPING _ USERS . getName (  )  )  )     |  |     ( ra . hasDefined ( Constants . WM _ SECURITY _ MAPPING _ GROUPS . getName (  )  )  )  )     {", "streamWriter . writeStartElement ( WorkManagerSecurity . Tag . MAPPINGS . getLocalName (  )  )  ;", "if    ( ra . hasDefined ( Constants . WM _ SECURITY _ MAPPING _ USERS . getName (  )  )  )     {", "streamWriter . writeStartElement ( WorkManagerSecurity . Tag . USERS . getLocalName (  )  )  ;", "for    ( ModelNode   node    :    ra . get ( Constants . WM _ SECURITY _ MAPPING _ USERS . getName (  )  )  . asList (  )  )     {", "streamWriter . writeStartElement ( WorkManagerSecurity . Tag . MAP . getLocalName (  )  )  ;", "Constants . WM _ SECURITY _ MAPPING _ FROM . marshallAsAttribute ( node ,    streamWriter )  ;", "Constants . WM _ SECURITY _ MAPPING _ TO . marshallAsAttribute ( node ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "if    ( ra . hasDefined ( Constants . WM _ SECURITY _ MAPPING _ GROUPS . getName (  )  )  )     {", "streamWriter . writeStartElement ( WorkManagerSecurity . Tag . GROUPS . getLocalName (  )  )  ;", "for    ( ModelNode   node    :    ra . get ( Constants . WM _ SECURITY _ MAPPING _ GROUPS . getName (  )  )  . asList (  )  )     {", "streamWriter . writeStartElement ( WorkManagerSecurity . Tag . MAP . getLocalName (  )  )  ;", "Constants . WM _ SECURITY _ MAPPING _ FROM . marshallAsAttribute ( node ,    streamWriter )  ;", "Constants . WM _ SECURITY _ MAPPING _ TO . marshallAsAttribute ( node ,    streamWriter )  ;", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "streamWriter . writeEndElement (  )  ;", "}", "if    ( ra . hasDefined ( Constants . CONNECTIONDEFINITIONS _ NAME )  )     {", "streamWriter . writeStartElement ( CONNECTION _ DEFINITIONS . getLocalName (  )  )  ;", "for    ( Property   conDef    :    ra . get ( Constants . CONNECTIONDEFINITIONS _ NAME )  . asPropertyList (  )  )     {", "writeConDef ( streamWriter ,    conDef . getValue (  )  ,    conDef . getName (  )  ,    isXa )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "if    ( ra . hasDefined ( Constants . ADMIN _ OBJECTS _ NAME )  )     {", "streamWriter . writeStartElement ( ADMIN _ OBJECTS . getLocalName (  )  )  ;", "for    ( Property   adminObject    :    ra . get ( Constants . ADMIN _ OBJECTS _ NAME )  . asPropertyList (  )  )     {", "writeAdminObject ( streamWriter ,    adminObject . getValue (  )  ,    adminObject . getName (  )  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "streamWriter . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeRaElement"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdapterSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardResourceDescriptionResolver ( keyPrefix ,    ResourceAdaptersExtension . RESOURCE _ NAME ,    ResourceAdaptersExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersExtension"}, {"methodBody": ["METHOD_START", "{", "model . setEmptyObject (  )  ;", "model . get ( Constants . RESOURCEADAPTER _ NAME )  ;", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "return   AdditionalInitialization . MANAGEMENT ;", "}", "METHOD_END"], "methodName": ["createAdditionalInitialization"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "final   AdditionalInitialization   additionalInit    =    createAdditionalInitialization (  )  ;", "final   String   Xml    =     ( configId    =  =    null )     ?    getSubsystemXml (  )     :    getSubsystemXml ( configId )  ;", "final   KernelServices   servicesA    =    super . createKernelServicesBuilder ( additionalInit )  . setSubsystemXml ( Xml )  . build (  )  ;", "Assert . assertTrue (  \" Subsystem   boot   failed !  \"  ,    servicesA . isSuccessfulBoot (  )  )  ;", "final   ModelNode   modelA    =    servicesA . readWholeModel (  )  ;", "validateModel ( modelA )  ;", "final   String   marshalled    =    servicesA . getPersistedSubsystemXml (  )  ;", "servicesA . shutdown (  )  ;", "String   normalizedSubsystem    =    normalizeXML ( Xml )  ;", "if    ( compareXml )     {", "compareXml ( configId ,    normalizedSubsystem ,    normalizeXML ( marshalled )  )  ;", "}", "final   KernelServices   servicesB    =    super . createKernelServicesBuilder ( additionalInit )  . setSubsystemXml ( marshalled )  . build (  )  ;", "final   ModelNode   modelB    =    servicesB . readWholeModel (  )  ;", "final   ModelNode   operation    =    createDescribeOperation (  )  ;", "final   ModelNode   result    =    servicesB . executeOperation ( operation )  ;", "Assert . assertTrue (  \" the      describe   operation   has   to   generate   a   list   of   operations   to   recreate   the    \"  ,     (  !  ( result . hasDefined ( FAILURE _ DESCRIPTION )  )  )  )  ;", "final   List < ModelNode >    operations    =    result . get ( RESULT )  . asList (  )  ;", "servicesB . shutdown (  )  ;", "final   KernelServices   servicesC    =    super . createKernelServicesBuilder ( additionalInit )  . setBootOperations ( operations )  . build (  )  ;", "final   ModelNode   modelC    =    servicesC . readWholeModel (  )  ;", "compare ( modelB ,    modelC )  ;", "assertRemoveSubsystemResources ( servicesC ,    getIgnoredChildResourcesForRemovalTest (  )  )  ;", "if    ( configIdResolvedModel    !  =    null )     {", "final   String   ResolvedXml    =    getSubsystemXml ( configIdResolvedModel )  ;", "final   KernelServices   servicesD    =    super . createKernelServicesBuilder ( additionalInit )  . setSubsystemXml ( ResolvedXml )  . build (  )  ;", "Assert . assertTrue (  \" Subsystem   w /    reolved   xml   boot   failed !  \"  ,    servicesD . isSuccessfulBoot (  )  )  ;", "final   ModelNode   modelD    =    servicesD . readWholeModel (  )  ;", "validateModel ( modelD )  ;", "resolveandCompareModel ( modelA ,    modelD )  ;", "}", "return   servicesA ;", "}", "METHOD_END"], "methodName": ["standardSubsystemTest"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformerElytronEnabled (  \" resource - adapters - pool - elytron - enabled . xml \"  ,    EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testElytronEnabledEAP62"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformer 7 ElytronEnabled (  \" resource - adapters - pool - elytron - enabled . xml \"  ,    EAP _  7  _  0  _  0  ,    ModelVersion . create (  4  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testElytronEnabledEAP7"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" resource - adapters - pool - expression . xml \"  ,     \" resource - adapters - pool . xml \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testExpressionConfig"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" resource - adapters - xapool - expression . xml \"  ,     \" resource - adapters - xapool . xml \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testExpressionConfigXa"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformer (  \" resource - adapters - xapool - expression 2  . xml \"  ,    EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testExpressionsEAP62"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" resource - adapters - pool . xml \"  ,    null ,    true )  ;", "}", "METHOD_END"], "methodName": ["testFullConfig"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" resource - adapters - xapool . xml \"  ,    null ,    true )  ;", "}", "METHOD_END"], "methodName": ["testFullConfigXa"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - connector :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  \" ironjacamar : ironjacamar - spec - api :  1  .  1  .  4  . Final \"  )  . addMavenResourceURL (  \" ironjacamar : ironjacamar - common - api :  1  .  1  .  4  . Final \"  )  . setExtensionClassName (  \" Extension \"  )  . addOperationValidationResolve (  \" add \"  ,    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    getMainSubsystemName (  )  )  ,    PathElement . pathElement (  \" resource - adapter \"  ,     \"  *  \"  )  ,    PathElement . pathElement (  \" connection - definitions \"  ,     \"  *  \"  )  )  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  . skipReverseControllerCheck (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( subsystemXml )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( ResourceAdaptersExtension . SUBSYSTEM _ PATH )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( Constants . RESOURCEADAPTER _ NAME )  )  ,    new   FailedOperationTransformationConfig . AttributesPathAddressConfig ( Constants . WM _ SECURITY . getName (  )  ,    Constants . WM _ SECURITY _ MAPPING _ REQUIRED . getName (  )  ,    Constants . WM _ SECURITY _ DOMAIN . getName (  )  ,    Constants . MODULE . getName (  )  ,    Constants . STATISTICS _ ENABLED . getName (  )  )     {", "@ Override", "protected   boolean   isAttributeWritable ( String   attributeName )     {", "return   false ;", "}", "@ Override", "protected   boolean   checkValue ( String   attrName ,    ModelNode   attribute ,    boolean   isWriteAttribute )     {", "return   attribute . isDefined (  )  ;", "}", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "return   new   ModelNode (  )  ;", "}", "}  )  . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( Constants . RESOURCEADAPTER _ NAME )  ,    ConnectionDefinitionResourceDefinition . PATH )  ,    ChainedConfig . createBuilder ( Constants . CONNECTABLE ,    Constants . TRACKING )  . addConfig ( new   FailedOperationTransformationConfig . RejectExpressionsConfig ( Constants . CONNECTABLE )     {", "@ Override", "protected   boolean   checkValue ( String   attrName ,    ModelNode   attribute ,    boolean   isWriteAttribute )     {", "if    ( super . checkValue ( attrName ,    attribute ,    isWriteAttribute )  )     {", "return   true ;", "}", "return   attribute . asBoolean (  )  ;", "}", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "return   new   ModelNode ( false )  ;", "}", "}  )  . addConfig ( new   FailedOperationTransformationConfig . AttributesPathAddressConfig ( Constants . TRACKING . getName (  )  )     {", "@ Override", "protected   boolean   isAttributeWritable ( String   attributeName )     {", "return   false ;", "}", "@ Override", "protected   boolean   checkValue ( String   attrName ,    ModelNode   attribute ,    boolean   isWriteAttribute )     {", "return   attribute . isDefined (  )  ;", "}", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "return   new   ModelNode (  )  ;", "}", "}  )  . build (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformer"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "String   artifactId    =     \"  : wildfly - connector :  \"  ;", "String   ironJacamarVersion    =     \"  1  .  3  .  3  . Final - redhat -  1  \"  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  (  ( controllerVersion . getMavenGroupId (  )  )     +    artifactId )     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  \" ironjacamar : ironjacamar - spec - api :  \"     +    ironJacamarVersion )  )  . addMavenResourceURL (  (  \" ironjacamar : ironjacamar - common - api :  \"     +    ironJacamarVersion )  )  . setExtensionClassName (  \" Extension \"  )  . addOperationValidationResolve (  \" add \"  ,    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    getMainSubsystemName (  )  )  ,    PathElement . pathElement (  \" resource - adapter \"  ,     \"  *  \"  )  ,    PathElement . pathElement (  \" connection - definitions \"  ,     \"  *  \"  )  )  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  . skipReverseControllerCheck (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( subsystemXml )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( ResourceAdaptersExtension . SUBSYSTEM _ PATH )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( Constants . RESOURCEADAPTER _ NAME )  )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . WM _ ELYTRON _ SECURITY _ DOMAIN )  )  . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( Constants . RESOURCEADAPTER _ NAME )  ,    ConnectionDefinitionResourceDefinition . PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( Constants . ELYTRON _ ENABLED ,    Constants . AUTHENTICATION _ CONTEXT ,    Constants . AUTHENTICATION _ CONTEXT _ AND _ APPLICATION ,    Constants . RECOVERY _ ELYTRON _ ENABLED ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT ,    Constants . RECOVERY _ CREDENTIAL _ REFERENCE )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformer7ElytronEnabled"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - connector :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  \" ironjacamar : ironjacamar - spec - api :  1  .  1  .  4  . Final \"  )  . addMavenResourceURL (  \" ironjacamar : ironjacamar - common - api :  1  .  1  .  4  . Final \"  )  . setExtensionClassName (  \" Extension \"  )  . addOperationValidationResolve (  \" add \"  ,    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    getMainSubsystemName (  )  )  ,    PathElement . pathElement (  \" resource - adapter \"  ,     \"  *  \"  )  ,    PathElement . pathElement (  \" connection - definitions \"  ,     \"  *  \"  )  )  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  . skipReverseControllerCheck (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "List < ModelNode >    ops    =    builder . parseXmlResource ( subsystemXml )  ;", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( ResourceAdaptersExtension . SUBSYSTEM _ PATH )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( Constants . RESOURCEADAPTER _ NAME )  )  ,    new   FailedOperationTransformationConfig . AttributesPathAddressConfig ( Constants . WM _ SECURITY . getName (  )  ,    Constants . WM _ SECURITY _ MAPPING _ REQUIRED . getName (  )  ,    Constants . WM _ ELYTRON _ SECURITY _ DOMAIN . getName (  )  ,    Constants . MODULE . getName (  )  ,    Constants . STATISTICS _ ENABLED . getName (  )  )     {", "@ Override", "protected   boolean   isAttributeWritable ( String   attributeName )     {", "return   false ;", "}", "@ Override", "protected   boolean   checkValue ( String   attrName ,    ModelNode   attribute ,    boolean   isWriteAttribute )     {", "return   attribute . isDefined (  )  ;", "}", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "return   new   ModelNode (  )  ;", "}", "}  )  . addFailedAttribute ( subsystemAddress . append ( PathElement . pathElement ( Constants . RESOURCEADAPTER _ NAME )  ,    ConnectionDefinitionResourceDefinition . PATH )  ,    ChainedConfig . createBuilder ( Constants . CONNECTABLE ,    Constants . TRACKING )  . addConfig ( new   FailedOperationTransformationConfig . RejectExpressionsConfig ( Constants . CONNECTABLE )     {", "@ Override", "protected   boolean   checkValue ( String   attrName ,    ModelNode   attribute ,    boolean   isWriteAttribute )     {", "if    ( super . checkValue ( attrName ,    attribute ,    isWriteAttribute )  )     {", "return   true ;", "}", "return   attribute . asBoolean (  )  ;", "}", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "return   new   ModelNode ( false )  ;", "}", "}  )  . addConfig ( new   FailedOperationTransformationConfig . AttributesPathAddressConfig ( Constants . TRACKING . getName (  )  ,    Constants . ELYTRON _ ENABLED . getName (  )  ,    Constants . AUTHENTICATION _ CONTEXT . getName (  )  ,    Constants . MCP . getName (  )  ,    Constants . AUTHENTICATION _ CONTEXT _ AND _ APPLICATION . getName (  )  ,    Constants . RECOVERY _ ELYTRON _ ENABLED . getName (  )  ,    Constants . RECOVERY _ AUTHENTICATION _ CONTEXT . getName (  )  ,    Constants . RECOVERY _ CREDENTIAL _ REFERENCE . getName (  )  )     {", "@ Override", "protected   boolean   isAttributeWritable ( String   attributeName )     {", "return   false ;", "}", "@ Override", "protected   boolean   checkValue ( String   attrName ,    ModelNode   attribute ,    boolean   isWriteAttribute )     {", "return   attribute . isDefined (  )  ;", "}", "@ Override", "protected   ModelNode   correctValue ( ModelNode   toResolve ,    boolean   isWriteAttribute )     {", "return   new   ModelNode (  )  ;", "}", "}  )  . build (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformerElytronEnabled"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  . setSubsystemXmlResource ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - connector :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  \" ironjacamar : ironjacamar - spec - api :  1  .  1  .  4  . Final \"  )  . addMavenResourceURL (  \" ironjacamar : ironjacamar - common - api :  1  .  1  .  4  . Final \"  )  . excludeFromParent ( SingleClassFilter . createFilter ( ConnectorLogger . class )  )  . configureReverseControllerCheck ( null ,    new   ModelFixer (  )     {", "@ Override", "public   ModelNode   fixModel ( ModelNode   modelNode )     {", "if    ( modelNode . get ( Constants . RESOURCEADAPTER _ NAME )  . hasDefined (  \" myRA \"  )  )     {", "if    ( modelNode . get ( Constants . RESOURCEADAPTER _ NAME )  . get (  \" myRA \"  )  . get ( Constants . CONNECTIONDEFINITIONS _ NAME )  . get (  \" poolName \"  )  . get ( Constants . ENLISTMENT . getName (  )  )  . isDefined (  )  )     {", "modelNode . get ( Constants . RESOURCEADAPTER _ NAME )  . get (  \" myRA \"  )  . get ( Constants . CONNECTIONDEFINITIONS _ NAME )  . get (  \" poolName \"  )  . get ( Constants . ENLISTMENT . getName (  )  )  . set ( false )  ;", "}", "if    ( modelNode . get ( Constants . RESOURCEADAPTER _ NAME )  . get (  \" myRA \"  )  . get ( Constants . CONNECTIONDEFINITIONS _ NAME )  . get (  \" poolName \"  )  . get ( Constants . SHARABLE . getName (  )  )  . isDefined (  )  )     {", "modelNode . get ( Constants . RESOURCEADAPTER _ NAME )  . get (  \" myRA \"  )  . get ( Constants . CONNECTIONDEFINITIONS _ NAME )  . get (  \" poolName \"  )  . get ( Constants . SHARABLE . getName (  )  )  . set ( false )  ;", "}", "}", "return   modelNode ;", "}", "}  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "Assert . assertNotNull ( legacyServices )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion ,    null ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransformer"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformer (  \" resource - adapters - pool -  2  0  . xml \"  ,    EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformerEAP62"], "fileName": "org.jboss.as.connector.subsystems.resourceadapters.ResourceAdaptersSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "for    ( Extension . Attribute   attribute    :    Attribute . values (  )  )     {", "switch    ( attribute )     {", "case   CLASS _ NAME    :", "{", "requireSingleAttribute ( reader ,    attribute . getLocalName (  )  )  ;", "final   String   value    =    reader . getAttributeValue (  0  )  ;", "extensionClassName . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "break ;", "}", "}", "while    ( reader . hasNext (  )  )     {", "switch    ( reader . nextTag (  )  )     {", "case   XMLStreamConstants . END _ ELEMENT    :", "{", "if    ( reader . getLocalName (  )  . equals ( enclosingTag )  )     {", "return ;", "} else    {", "if    (  ( Tag . forName ( reader . getLocalName (  )  )  )     =  =     ( Tag . UNKNOWN )  )     {", "throw   ParseUtils . unexpectedEndElement ( reader )  ;", "}", "}", "break ;", "}", "case   XMLStreamConstants . START _ ELEMENT    :", "{", "switch    ( Tag . forName ( reader . getLocalName (  )  )  )     {", "case   CONFIG _ PROPERTY    :", "{", "requireSingleAttribute ( reader ,     \" name \"  )  ;", "final   String   name    =    reader . getAttributeValue (  0  )  ;", "String   value    =    rawElementText ( reader )  ;", "final   String   trimmed    =     ( value    =  =    null )     ?    null    :    value . trim (  )  ;", "extensionProperties . parseAndAddParameterElement ( name ,    trimmed ,    operation ,    reader )  ;", "break ;", "}", "default    :", "throw   new   ParserException (  . bundle . unexpectedElement ( reader . getLocalName (  )  )  )  ;", "}", "break ;", "}", "}", "}", "throw   new   ParserException (  . bundle . unexpectedEndOfDocument (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseExtension"], "fileName": "org.jboss.as.connector.util.AbstractParser"}, {"methodBody": ["METHOD_START", "{", "return   rawAttributeText ( reader ,    attributeName ,    null )  ;", "}", "METHOD_END"], "methodName": ["rawAttributeText"], "fileName": "org.jboss.as.connector.util.AbstractParser"}, {"methodBody": ["METHOD_START", "{", "return    ( reader . getAttributeValue (  \"  \"  ,    attributeName )  )     =  =    null    ?    defaultValue    :    reader . getAttributeValue (  \"  \"  ,    attributeName )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["rawAttributeText"], "fileName": "org.jboss.as.connector.util.AbstractParser"}, {"methodBody": ["METHOD_START", "{", "String   elementText    =    reader . getElementText (  )  ;", "elementText    =     (  ( elementText    =  =    null )     |  |     (  ( elementText . trim (  )  . length (  )  )     =  =     0  )  )     ?    null    :    elementText . trim (  )  ;", "return   elementText ;", "}", "METHOD_END"], "methodName": ["rawElementText"], "fileName": "org.jboss.as.connector.util.AbstractParser"}, {"methodBody": ["METHOD_START", "{", "if    ( raName    =  =    null )", "throw   ConnectorLogger . ROOT _ LOGGER . undefinedVar (  \" RaName \"  )  ;", "final   ServiceName   serviceName    =     . RESOURCE _ ADAPTER _ DEPLOYMENT _ SERVICE _ PREFIX . append ( raName )  ;", "ConnectorLogger . ROOT _ LOGGER . tracef (  \"  :    getDeploymentServiceName (  % s )     -  >     % s \"  ,    raName ,    serviceName )  ;", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getDeploymentServiceName"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "if    ( raName    =  =    null )", "throw   ConnectorLogger . ROOT _ LOGGER . undefinedVar (  \" RaName \"  )  ;", "ServiceName   serviceName    =    null ;", "if    (  ( raId    =  =    null )     |  |     ( raId . equals ( raName )  )  )     {", "serviceName    =     . RESOURCE _ ADAPTER _ DEPLOYMENT _ SERVICE _ PREFIX . append ( raName )  ;", "} else    {", "serviceName    =     . RESOURCE _ ADAPTER _ DEPLOYMENT _ SERVICE _ PREFIX . append (  (  ( raName    +     \"  _  \"  )     +    raId )  )  ;", "}", "ConnectorLogger . ROOT _ LOGGER . tracef (  \"  :    getDeploymentServiceName (  % s ,  % s )     -  >     % s \"  ,    raName ,    raId ,    serviceName )  ;", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getDeploymentServiceName"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "if    ( raName    =  =    null )", "throw   ConnectorLogger . ROOT _ LOGGER . undefinedVar (  \" RaName \"  )  ;", "ServiceName   serviceName    =    null ;", "ModifiableResourceAdapter   ra    =     (  ( ModifiableResourceAdapter )     ( raxml )  )  ;", "if    (  ( ra    !  =    null )     &  &     (  ( ra . getId (  )  )     !  =    null )  )     {", "serviceName    =     . getDeploymentServiceName ( raName ,    ra . getId (  )  )  ;", "} else    {", "serviceName    =     . getDeploymentServiceName ( raName ,     (  ( String )     ( null )  )  )  ;", "}", "ConnectorLogger . ROOT _ LOGGER . tracef (  \"  :    getDeploymentServiceName (  % s ,  % s )     -  >     % s \"  ,    raName ,    raxml ,    serviceName )  ;", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getDeploymentServiceName"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "synchronized ( ConnectorServices . resourceAdapterRepositoryIdentifiers )     {", "return   ConnectorServices . resourceAdapterRepositoryIdentifiers . get ( raName )  ;", "}", "}", "METHOD_END"], "methodName": ["getRegisteredResourceAdapterIdentifier"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( id    =  =    null )     |  |     ( id . trim (  )  . isEmpty (  )  )  )     {", "throw   ConnectorLogger . ROOT _ LOGGER . undefinedVar (  \" id \"  )  ;", "}", "ServiceName   serviceName    =     . RESOURCE _ ADAPTER _ SERVICE _ PREFIX . append (  . stripDotRarSuffix ( id )  )  ;", "ConnectorLogger . ROOT _ LOGGER . tracef (  \"  :    getResourceAdapterServiceName (  % s )     -  >     % s \"  ,    id ,    serviceName )  ;", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getResourceAdapterServiceName"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )", "throw   logging . ConnectorLogger . ROOT _ LOGGER . serviceNotStarted (  )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["notNull"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "synchronized ( ConnectorServices . resourceAdapterRepositoryIdentifiers )     {", "ConnectorServices . resourceAdapterRepositoryIdentifiers . put ( raName ,    raIdentifier )  ;", "}", "}", "METHOD_END"], "methodName": ["registerResourceAdapterIdentifier"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "if    ( raName    =  =    null )     {", "return   null ;", "}", "if    ( raName . endsWith (  \"  . rar \"  )  )     {", "return   raName . substring (  0  ,    raName . indexOf (  \"  . rar \"  )  )  ;", "}", "return   raName ;", "}", "METHOD_END"], "methodName": ["stripDotRarSuffix"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "synchronized ( ConnectorServices . resourceAdapterRepositoryIdentifiers )     {", "ConnectorServices . resourceAdapterRepositoryIdentifiers . remove ( raName )  ;", "}", "}", "METHOD_END"], "methodName": ["unregisterResourceAdapterIdentifier"], "fileName": "org.jboss.as.connector.util.ConnectorServices"}, {"methodBody": ["METHOD_START", "{", "return   cache . get ( k )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jboss.as.connector.util.CopyOnWriteArrayListMultiMap"}, {"methodBody": ["METHOD_START", "{", "List < V >    list    =    cache . get ( k )  ;", "if    (  ( list    =  =    null )     |  |     ( list . isEmpty (  )  )  )     {", "list    =    new    < V >  (  )  ;", "} else    {", "list    =    new    < V >  ( list )  ;", "}", "if    (  !  ( list . contains ( v )  )  )     {", "list . add ( v )  ;", "cache . put ( k ,    list )  ;", "}", "}", "METHOD_END"], "methodName": ["putIfAbsent"], "fileName": "org.jboss.as.connector.util.CopyOnWriteArrayListMultiMap"}, {"methodBody": ["METHOD_START", "{", "return   cache . remove ( k )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.connector.util.CopyOnWriteArrayListMultiMap"}, {"methodBody": ["METHOD_START", "{", "List < V >    list    =    cache . get ( k )  ;", "if    ( list    =  =    null )     {", "return   false ;", "}", "if    ( list . isEmpty (  )  )     {", "cache . remove ( k )  ;", "return   false ;", "}", "boolean   removed    =    list . remove ( v )  ;", "if    ( removed )     {", "if    ( list . isEmpty (  )  )     {", "cache . remove ( k )  ;", "} else    {", "list    =    new    < V >  ( list )  ;", "cache . put ( k ,    list )  ;", "}", "}", "return   removed ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.jboss.as.connector.util.CopyOnWriteArrayListMultiMap"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  ( classType . equals ( propertyType )  )     |  |     (  ( classType . equals (  \" Byte \"  )  )     &  &     ( propertyType . equals (  \" byte \"  )  )  )  )     |  |     (  ( classType . equals (  \" Short \"  )  )     &  &     ( propertyType . equals (  \" short \"  )  )  )  )     |  |     (  ( classType . equals (  \" Integer \"  )  )     &  &     ( propertyType . equals (  \" int \"  )  )  )  )     |  |     (  ( classType . equals (  \" Long \"  )  )     &  &     ( propertyType . equals (  \" long \"  )  )  )  )     |  |     (  ( classType . equals (  \" Float \"  )  )     &  &     ( propertyType . equals (  \" float \"  )  )  )  )     |  |     (  ( classType . equals (  \" Double \"  )  )     &  &     ( propertyType . equals (  \" double \"  )  )  )  )     |  |     (  ( classType . equals (  \" Boolean \"  )  )     &  &     ( propertyType . equals (  \" boolean \"  )  )  )  )     |  |     (  ( classType . equals (  \" Character \"  )  )     &  &     ( propertyType . equals (  \" char \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["argumentMatches"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "while    (  !  ( clz . equals ( Object . class )  )  )     {", "List < Field >    hits    =    null ;", "Field [  ]    fields    =    SecurityActions . getDeclaredFields ( clz )  ;", "for    ( int   i    =     0  ;    i    <     ( fields . length )  ;    i +  +  )     {", "final   Field   field    =    fields [ i ]  ;", "if    ( fieldName . equals ( field . getName (  )  )  )     {", "if    (  ( fieldType    =  =    null )     |  |     ( argumentMatches ( fieldType ,    field . getType (  )  . getName (  )  )  )  )     {", "if    ( hits    =  =    null )", "hits    =    new   ArrayList < Field >  (  1  )  ;", "SecurityActions . setAccessible ( field )  ;", "hits . add ( field )  ;", "}", "}", "}", "if    ( hits    !  =    null )     {", "if    (  ( hits . size (  )  )     =  =     1  )     {", "return   hits . get (  0  )  ;", "} else    {", "Collections . sort ( hits ,    new    . FieldSorter (  )  )  ;", "if    ( fieldType    !  =    null )     {", "for    ( Field   f    :    hits )     {", "if    ( fieldType . equals ( f . getType (  )  . getName (  )  )  )", "return   f ;", "}", "}", "return   hits . get (  0  )  ;", "}", "}", "clz    =    clz . getSuperclass (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findField"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "while    (  !  ( clz . equals ( Object . class )  )  )     {", "List < Method >    hits    =    null ;", "Method [  ]    methods    =    SecurityActions . getDeclaredMethods ( clz )  ;", "for    ( int   i    =     0  ;    i    <     ( methods . length )  ;    i +  +  )     {", "final   Method   method    =    methods [ i ]  ;", "if    (  ( methodName . equals ( method . getName (  )  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     1  )  )     {", "if    (  ( propertyType    =  =    null )     |  |     ( argumentMatches ( propertyType ,    method . getParameterTypes (  )  [  0  ]  . getName (  )  )  )  )     {", "if    ( hits    =  =    null )", "hits    =    new   ArrayList < Method >  (  1  )  ;", "SecurityActions . setAccessible ( method )  ;", "hits . add ( method )  ;", "}", "}", "}", "if    ( hits    !  =    null )     {", "if    (  ( hits . size (  )  )     =  =     1  )     {", "return   hits . get (  0  )  ;", "} else    {", "Collections . sort ( hits ,    new    . MethodSorter (  )  )  ;", "if    ( propertyType    !  =    null )     {", "for    ( Method   m    :    hits )     {", "if    ( propertyType . equals ( m . getParameterTypes (  )  [  0  ]  . getName (  )  )  )", "return   m ;", "}", "}", "return   hits . get (  0  )  ;", "}", "}", "clz    =    clz . getSuperclass (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( input    =  =    null )     |  |     ( input . trim (  )  . equals (  \"  \"  )  )  )", "return   input ;", "while    (  ( input . indexOf (  \"  $  {  \"  )  )     !  =     (  -  1  )  )     {", "int   from    =    input . indexOf (  \"  $  {  \"  )  ;", "int   to    =    input . indexOf (  \"  }  \"  )  ;", "int   dv    =    input . indexOf (  \"  :  \"  ,     ( from    +     2  )  )  ;", "if    ( dv    !  =     (  -  1  )  )     {", "if    ( dv    >    to )", "dv    =     -  1  ;", "}", "String   systemProperty    =     \"  \"  ;", "String   defaultValue    =     \"  \"  ;", "if    ( dv    =  =     (  -  1  )  )     {", "String   s    =    input . substring (  ( from    +     2  )  ,    to )  ;", "if    (  \"  /  \"  . equals ( s )  )     {", "systemProperty    =    File . separa ;", "} else", "if    (  \"  :  \"  . equals ( s )  )     {", "systemProperty    =    File . pathSepara ;", "} else    {", "systemProperty    =    WildFlySecurityManager . getSystemPropertiesPrivileged (  )  . getProperty ( s )  ;", "}", "} else    {", "systemProperty    =    WildFlySecurityManager . getSystemPropertiesPrivileged (  )  . getProperty ( input . substring (  ( from    +     2  )  ,    dv )  )  ;", "defaultValue    =    input . substring (  ( dv    +     1  )  ,    to )  ;", "}", "String   prefix    =     \"  \"  ;", "String   postfix    =     \"  \"  ;", "if    ( from    !  =     0  )     {", "prefix    =    input . substring (  0  ,    from )  ;", "}", "if    (  ( to    +     1  )     <     (  ( input . length (  )  )     -     1  )  )     {", "postfix    =    input . substring (  ( to    +     1  )  )  ;", "}", "if    (  ( systemProperty    !  =    null )     &  &     (  !  ( systemProperty . trim (  )  . equals (  \"  \"  )  )  )  )     {", "input    =     ( prefix    +    systemProperty )     +    postfix ;", "} else", "if    (  !  ( defaultValue . trim (  )  . equals (  \"  \"  )  )  )     {", "input    =     ( prefix    +    defaultValue )     +    postfix ;", "} else    {", "input    =    prefix    +    postfix ;", "}", "}", "return   input ;", "}", "METHOD_END"], "methodName": ["getSubstitutionValue"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "if    ( v   instanceof   String )     {", "String   substituredValue    =    getSubstitutionValue (  (  ( String )     ( v )  )  )  ;", "if    ( clz . equals ( String . class )  )     {", "v    =    substituredValue ;", "} else", "if    (  ( clz . equals ( byte . class )  )     |  |     ( clz . equals ( Byte . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Byte . valueOf ( substituredValue )  ;", "} else", "if    (  ( clz . equals ( short . class )  )     |  |     ( clz . equals ( Short . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Short . valueOf ( substituredValue )  ;", "} else", "if    (  ( clz . equals ( int . class )  )     |  |     ( clz . equals ( Integer . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Integer . valueOf ( substituredValue )  ;", "} else", "if    (  ( clz . equals ( long . class )  )     |  |     ( clz . equals ( Long . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Long . valueOf ( substituredValue )  ;", "} else", "if    (  ( clz . equals ( float . class )  )     |  |     ( clz . equals ( Float . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Float . valueOf ( substituredValue )  ;", "} else", "if    (  ( clz . equals ( double . class )  )     |  |     ( clz . equals ( Double . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Double . valueOf ( substituredValue )  ;", "} else", "if    (  ( clz . equals ( boolean . class )  )     |  |     ( clz . equals ( Boolean . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Boolean . valueOf ( substituredValue )  ;", "} else", "if    (  ( clz . equals ( char . class )  )     |  |     ( clz . equals ( Character . class )  )  )     {", "if    (  ( substituredValue    !  =    null )     &  &     (  !  ( substituredValue . trim (  )  . equals (  \"  \"  )  )  )  )", "v    =    Character . valueOf ( substituredValue . charAt (  0  )  )  ;", "} else", "if    ( clz . equals ( class )  )     {", "v    =    getByName ( substituredValue )  ;", "} else", "if    ( clz . equals ( Class . class )  )     {", "v    =    Class . forName ( substituredValue ,    true ,    cl )  ;", "} else", "if    ( clz . equals ( class )  )     {", "Properties   prop    =    new   Properties (  )  ;", "StringTokenizer   st    =    new   StringTokenizer ( substituredValue ,     \"     ,  \"  )  ;", "while    ( st . hasMoreTokens (  )  )     {", "String   token    =    st . nextToken (  )  ;", "String   key    =     \"  \"  ;", "String   value    =     \"  \"  ;", "int   index    =    token . indexOf (  \"  =  \"  )  ;", "if    ( index    !  =     (  -  1  )  )     {", "key    =    token . substring (  0  ,    index )  ;", "if    (  ( token . length (  )  )     >     ( index    +     1  )  )", "value    =    token . substring (  ( index    +     1  )  )  ;", "} else    {", "key    =    token ;", "}", "if    (  !  (  \"  \"  . equals ( key )  )  )", "prop . setProperty ( key ,    value )  ;", "}", "v    =    prop ;", "} else    {", "try    {", "Constructor <  ?  >    constructor    =    SecurityActions . getConstructor ( clz ,    String . class )  ;", "v    =    constructor . newInstance ( substituredValue )  ;", "}    catch    ( Throwable   t )     {", "try    {", "Method   valueOf    =    SecurityActions . getMethod ( clz ,     \" valueOf \"  ,    String . class )  ;", "v    =    valueOf . invoke (  (  ( Object )     ( null )  )  ,    substituredValue )  ;", "}    catch    ( Throwable   inner )     {", "throw   logging . ConnectorLogger . ROOT _ LOGGER . noPropertyResolution ( name )  ;", "}", "}", "}", "}", "return   v ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "inject ( object ,    propertyName ,    propertyValue ,    null ,    false )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "inject ( object ,    propertyName ,    propertyValue ,    propertyType ,    false )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )", "throw   new   IllegalArgumentException ( CLogger . ROOT _ LOGGER . nullVar (  \" Object \"  )  )  ;", "if    (  ( propertyName    =  =    null )     |  |     ( propertyName . trim (  )  . equals (  \"  \"  )  )  )", "throw   CLogger . ROOT _ LOGGER . undefinedVar (  \" PropertyName \"  )  ;", "String   methodName    =     \" set \"     +     ( propertyName . substring (  0  ,     1  )  . toUpperCase ( Locale . US )  )  ;", "if    (  ( propertyName . length (  )  )     >     1  )     {", "methodName    +  =    propertyName . substring (  1  )  ;", "}", "Method   method    =    findMethod ( object . getClass (  )  ,    methodName ,    propertyType )  ;", "if    ( method    !  =    null )     {", "Class <  ?  >    parameterClass    =    method . getParameterTypes (  )  [  0  ]  ;", "Object   parameterValue    =    null ;", "try    {", "parameterValue    =    getValue ( propertyName ,    parameterClass ,    propertyValue ,    WildFlySecurityManager . getClassLoaderPrivileged ( object . getClass (  )  )  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   InvocationTargetException ( t ,    t . getMessage (  )  )  ;", "}", "if    (  (  !  ( parameterClass . isPrimitive (  )  )  )     |  |     ( parameterValue    !  =    null )  )", "method . invoke ( object ,    new   Object [  ]  {    parameterValue    }  )  ;", "} else    {", "if    (  ! includeFields )", "throw   CLogger . ROOT _ LOGGER . noSuchMethod ( methodName )  ;", "Field   field    =    findField ( object . getClass (  )  ,    propertyName ,    propertyType )  ;", "if    ( field    !  =    null )     {", "Class <  ?  >    fieldClass    =    field . getType (  )  ;", "Object   fieldValue    =    null ;", "try    {", "fieldValue    =    getValue ( propertyName ,    fieldClass ,    propertyValue ,    WildFlySecurityManager . getClassLoaderPrivileged ( object . getClass (  )  )  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   InvocationTargetException ( t ,    t . getMessage (  )  )  ;", "}", "field . set ( object ,    fieldValue )  ;", "} else    {", "throw   CLogger . ROOT _ LOGGER . noSuchField ( propertyName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.jboss.as.connector.util.Injection"}, {"methodBody": ["METHOD_START", "{", "ValidatorFactory   result    =    delegate ;", "if    ( result    =  =    null )     {", "synchronized ( this )     {", "result    =    delegate ;", "if    ( result    =  =    null )     {", "delegate    =    result    =    initFactory (  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.jboss.as.connector.util.JCAValidatorFactory"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   oldTCCL    =    WildFlySecurityManager . getCurrentContextClassLoaderPrivileged (  )  ;", "try    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( classLoader )  ;", "if    (  ( configuration )     =  =    null )     {", "return   Validation . byDefaultProvider (  )  . providerResolver ( new   WildFlyProviderResolver (  )  )  . configure (  )  . build (  )  ;", "} else    {", "return   configuration . build (  )  ;", "}", "}    finally    {", "WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTCCL )  ;", "}", "}", "METHOD_END"], "methodName": ["initFactory"], "fileName": "org.jboss.as.connector.util.JCAValidatorFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( dataSourceNode . hasDefined ( className . getName (  )  )  )     {", "String   exceptionSorterClassName    =     . getResolvedStringIfSetOrGetDefault ( operationContext ,    dataSourceNode ,    className )  ;", "Map < String ,    String >    unwrapped    =    propertyName . unwrap ( operationContext ,    dataSourceNode )  ;", "Map < String ,    String >    exceptionSorterProperty    =     (  ( unwrapped . size (  )  )     >     0  )     ?    unwrapped    :    null ;", "return   new   Extension ( exceptionSorterClassName ,    exceptionSorterProperty )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["extractExtension"], "fileName": "org.jboss.as.connector.util.ModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    returnMap    =    null ;", "if    ( operation . hasDefined ( objList . getName (  )  )  )     {", "returnMap    =    new   HashMap < String ,    String >  ( operation . get ( objList . getName (  )  )  . asList (  )  . size (  )  )  ;", "for    (    node    :    operation . get ( objList . getName (  )  )  . asList (  )  )     {", "returnMap . put ( node . asObject (  )  . get ( keyAttribute . getName (  )  )  . asString (  )  ,    node . asObject (  )  . get ( valueAttribute . getName (  )  )  . asString (  )  )  ;", "}", "}", "return   returnMap ;", "}", "METHOD_END"], "methodName": ["extractMap"], "fileName": "org.jboss.as.connector.util.ModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "ModelNode   resolvedNode    =    key . resolveModelAttribute ( context ,    dataSourceNode )  ;", "return   resolvedNode . isDefined (  )     ?    resolvedNode . asBoolean (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getBooleanIfSetOrGetDefault"], "fileName": "org.jboss.as.connector.util.ModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "ModelNode   resolvedNode    =    key . resolveModelAttribute ( context ,    dataSourceNode )  ;", "return   resolvedNode . isDefined (  )     ?    resolvedNode . asInt (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getIntIfSetOrGetDefault"], "fileName": "org.jboss.as.connector.util.ModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "ModelNode   resolvedNode    =    key . resolveModelAttribute ( context ,    dataSourceNode )  ;", "return   resolvedNode . isDefined (  )     ?    resolvedNode . asLong (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getLongIfSetOrGetDefault"], "fileName": "org.jboss.as.connector.util.ModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "ModelNode   resolvedNode    =    key . resolveModelAttribute ( context ,    dataSourceNode )  ;", "String   resolvedString    =     ( resolvedNode . isDefined (  )  )     ?    resolvedNode . asString (  )     :    null ;", "if    (  ( resolvedString    !  =    null )     &  &     (  ( resolvedString . trim (  )  . length (  )  )     =  =     0  )  )     {", "resolvedString    =    null ;", "}", "return   resolvedString ;", "}", "METHOD_END"], "methodName": ["getResolvedStringIfSetOrGetDefault"], "fileName": "org.jboss.as.connector.util.ModelNodeUtil"}, {"methodBody": ["METHOD_START", "{", "ServiceName   serviceName    =    ConnectorServices . getDeploymentServiceName ( deploymentUnitName ,    raxml )  ;", "ResourceAdapterXmlDeploymentService   service    =    new   ResourceAdapterXmlDeploymentService ( XmlDescriptor ,    raxml ,    module ,    deployment ,    serviceName ,    deploymentUnitServiceName )  ;", "String   bootStrapCtxName    =    Constants . DEFAULT _ NAME ;", "if    (  (  ( raxml . getBootstrapContext (  )  )     !  =    null )     &  &     (  !  ( raxml . getBootstrapContext (  )  . equals (  \" undefined \"  )  )  )  )     {", "bootStrapCtxName    =    raxml . getBootstrapContext (  )  ;", "}", "ServiceBuilder < ResourceAdapterDeployment >    builder    =    Services . addServerExecutorDependency ( serviceTarget . addService ( serviceName ,    service )  ,    service . getExecutorServiceInjector (  )  )  . addDependency ( ConnectorServices . IRONJACAMAR _ MDR ,    AS 7 MetadataRepository . class ,    service . getMdrInjector (  )  )  . addDependency ( ConnectorServices . RA _ REPOSITORY _ SERVICE ,    ResourceAdapterRepository . class ,    service . getRaRepositoryInjector (  )  )  . addDependency ( ConnectorServices . MANAGEMENT _ REPOSITORY _ SERVICE ,    ManagementRepository . class ,    service . getManagementRepositoryInjector (  )  )  . addDependency ( ConnectorServices . RESOURCE _ ADAPTER _ REGISTRY _ SERVICE ,    ResourceAdapterDeploymentRegistry . class ,    service . getRegistryInjector (  )  )  . addDependency ( ConnectorServices . TRANSACTION _ INTEGRATION _ SERVICE ,    TransactionIntegration . class ,    service . getTxIntegrationInjector (  )  )  . addDependency ( ConnectorServices . CONNECTOR _ CONFIG _ SERVICE ,    JcaSubsystemConfiguration . class ,    service . getConfigInjector (  )  )  . addDependency ( ConnectorServices . CCM _ SERVICE ,    CachedConnectionManager . class ,    service . getCcmInjector (  )  )  . addDependency ( ConnectorServices . IDLE _ REMOVER _ SERVICE )  . addDependency ( ConnectorServices . CONNECTION _ VALIDATOR _ SERVICE )  . addDependency ( SERVICE _ NAME )  . addDependency ( ConnectorServices . BOOTSTRAP _ CONTEXT _ SERVICE . append ( bootStrapCtxName )  )  . addDependency ( ConnectorServices . RESOURCE _ ADAPTER _ DEPLOYER _ SERVICE _ PREFIX . append ( XmlDescriptor . getDeploymentName (  )  )  )  ;", "if    ( ActivationSecurityUtil . isLegacySecurityRequired ( raxml )  )     {", "builder . addDependency ( SubjectFactoryService . SERVICE _ NAME ,    SubjectFactory . class ,    service . getSubjectFactoryInjector (  )  )  . addDependency ( SimpleSecurityManagerService . SERVICE _ NAME ,    ServerSecurityManager . class ,    service . getServerSecurityManager (  )  )  ;", "}", "String   raName    =    deployment ;", "if    (  ( raxml . getId (  )  )     !  =    null )     {", "raName    =    raxml . getId (  )  ;", "}", "ServiceName   parentName    =    ServiceName . of ( ConnectorServices . RA _ SERVICE ,    raName )  ;", "for    ( ServiceName   subServiceName    :    serviceRegistry . getServiceNames (  )  )     {", "if    (  ( parentName . isParentOf ( subServiceName )  )     &  &     (  !  ( subServiceName . getSimpleName (  )  . equals ( ConnectorServices . STATISTICS _ SUFFIX )  )  )  )     {", "builder . addDependency ( subServiceName )  ;", "}", "}", "if    (  ( registration    !  =    null )     &  &     ( deploymentResource    !  =    null )  )     {", "if    (  ( registration . isAllowsOverride (  )  )     &  &     (  ( registration . getOverrideModel ( deploymentUnitName )  )     =  =    null )  )     {", "registration . registerOverrideModel ( deploymentUnitName ,    new   OverrideDescriptionProvider (  )     {", "@ Override", "public   Map < String ,    ModelNode >    getAttributeOverrideDescriptions ( Locale   locale )     {", "return   Collections . emptyMap (  )  ;", "}", "@ Override", "public   Map < String ,    ModelNode >    getChildTypeOverrideDescriptions ( Locale   locale )     {", "return   Collections . emptyMap (  )  ;", "}", "}  )  ;", "}", "}", "builder . setInitialMode ( ACTIVE )  . install (  )  ;", "}", "METHOD_END"], "methodName": ["createDeploymentService"], "fileName": "org.jboss.as.connector.util.RaServicesFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )", "return   c . getConstructor ( params )  ;", "Constructor <  ?  >    result    =    AccessController . doPrivileged ( new   PrivilegedAction < Constructor <  ?  >  >  (  )     {", "public   Constructor <  ?  >    run (  )     {", "try    {", "return   c . getConstructor ( params )  ;", "}    catch    ( NoSuchMethodException   e )     {", "return   null ;", "}", "}", "}  )  ;", "if    ( result    !  =    null )", "return   result ;", "throw   new   NoSuchMethodException (  )  ;", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "org.jboss.as.connector.util.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )", "return   c . getDeclaredFields (  )  ;", "return   AccessController . doPrivileged ( new   PrivilegedAction < Field [  ]  >  (  )     {", "public   Field [  ]    run (  )     {", "return   c . getDeclaredFields (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredFields"], "fileName": "org.jboss.as.connector.util.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )", "return   c . getDeclaredMethods (  )  ;", "return   AccessController . doPrivileged ( new   PrivilegedAction < Method [  ]  >  (  )     {", "public   Method [  ]    run (  )     {", "return   c . getDeclaredMethods (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredMethods"], "fileName": "org.jboss.as.connector.util.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )", "return   c . getMethod ( name ,    params )  ;", "Method   result    =    AccessController . doPrivileged ( new   PrivilegedAction < Method >  (  )     {", "public   Method   run (  )     {", "try    {", "return   c . getMethod ( name ,    params )  ;", "}    catch    ( NoSuchMethodException   e )     {", "return   null ;", "}", "}", "}  )  ;", "if    ( result    !  =    null )", "return   result ;", "throw   new   NoSuchMethodException (  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.jboss.as.connector.util.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     =  =    null )", "ao . setAccessible ( true )  ;", "AccessController . doPrivileged ( new   PrivilegedAction < Object >  (  )     {", "public   Object   run (  )     {", "ao . setAccessible ( true )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setAccessible"], "fileName": "org.jboss.as.connector.util.SecurityActions"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" rawtypes \"  )", "Iterator < Validation >    providerIterator    =    ServiceLoader . load ( Validation . class ,    classLoader )  . iterator (  )  ;", "LinkedList < Validation <  ?  >  >    providers    =    new   LinkedList < Validation <  ?  >  >  (  )  ;", "while    ( providerIterator . hasNext (  )  )     {", "try    {", "Validation <  ?  >    provider    =    providerIterator . next (  )  ;", "if    ( provider . getClass (  )  . getName (  )  . equals (  \" HibernateValidator \"  )  )     {", "providers . addFirst ( provider )  ;", "} else    {", "providers . add ( provider )  ;", "}", "}    catch    ( ServiceConfigurationError   e )     {", "}", "}", "return   providers ;", "}", "METHOD_END"], "methodName": ["loadProviders"], "fileName": "org.jboss.as.connector.util.WildFlyProviderResolver"}]