[{"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.cmp.subsystem.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.cmp.subsystem.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   getLocalName (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jboss.as.cmp.subsystem.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   new   DeprecatedResourceDescriptionResolver ( CmpExtension . SUBSYSTEM _ NAME ,    keyPrefix ,    CmpExtension . RESOURCE _ NAME ,    CmpExtension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResolver"], "fileName": "org.jboss.as.cmp.subsystem.CmpExtension"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( operationName ,    operation . get ( ModelDescriptionConstants . OP )  . asString (  )  )  ;", "final   PathAddress   addr    =    PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   PathElement   element    =    addr . getLastElement (  )  ;", "assertEquals ( lastElement . getKey (  )  ,    element . getKey (  )  )  ;", "assertEquals ( lastElement . getValue (  )  ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertOperation"], "fileName": "org.jboss.as.cmp.subsystem.CmpKeyGeneratorSubsystem10TestCase"}, {"methodBody": ["METHOD_START", "{", "final   List < ModelNode >    operations    =    super . parse ( getSubsystemXml (  \" subsystem - cmp - key - generators _  1  _  0  . xml \"  )  )  ;", "assertEquals (  5  ,    operations . size (  )  )  ;", "assertOperation ( operations . get (  0  )  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    getMainSubsystemName (  )  )  )  ;", "assertOperation ( operations . get (  1  )  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . UUID _ KEY _ GENERATOR ,     \" uuid 1  \"  )  )  ;", "assertOperation ( operations . get (  2  )  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . UUID _ KEY _ GENERATOR ,     \" uuid 2  \"  )  )  ;", "final   ModelNode   hilo 1     =    operations . get (  3  )  ;", "assertOperation ( hilo 1  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . HILO _ KEY _ GENERATOR ,     \" hilo 1  \"  )  )  ;", "assertEquals (  \" java :  / jdbc / DB 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . DATA _ SOURCE )  . asString (  )  )  ;", "assertEquals (  \" HILOSEQUENCES 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . TABLE _ NAME )  . asString (  )  )  ;", "assertEquals (  \" SEQUENCENAME 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . SEQUENCE _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" HIGHVALUES 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . ID _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" create   table   HILOSEQUENCES 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . CREATE _ TABLE _ DDL )  . asString (  )  )  ;", "assertEquals (  \" general 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . SEQUENCE _ NAME )  . asString (  )  )  ;", "assertEquals ( true ,    hilo 1  . get ( CmpSubsystemModel . CREATE _ TABLE )  . asBoolean (  )  )  ;", "assertEquals ( true ,    hilo 1  . get ( CmpSubsystemModel . DROP _ TABLE )  . asBoolean (  )  )  ;", "assertEquals (  1  0  ,    hilo 1  . get ( CmpSubsystemModel . BLOCK _ SIZE )  . asLong (  )  )  ;", "final   ModelNode   hilo 2     =    operations . get (  4  )  ;", "assertOperation ( hilo 2  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . HILO _ KEY _ GENERATOR ,     \" hilo 2  \"  )  )  ;", "assertEquals (  \" java :  / jdbc / DB 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . DATA _ SOURCE )  . asString (  )  )  ;", "assertEquals (  \" HILOSEQUENCES 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . TABLE _ NAME )  . asString (  )  )  ;", "assertEquals (  \" SEQUENCENAME 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . SEQUENCE _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" HIGHVALUES 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . ID _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" create   table   HILOSEQUENCES 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . CREATE _ TABLE _ DDL )  . asString (  )  )  ;", "assertEquals (  \" general 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . SEQUENCE _ NAME )  . asString (  )  )  ;", "assertEquals ( false ,    hilo 2  . get ( CmpSubsystemModel . CREATE _ TABLE )  . asBoolean (  )  )  ;", "assertEquals ( false ,    hilo 2  . get ( CmpSubsystemModel . DROP _ TABLE )  . asBoolean (  )  )  ;", "assertEquals (  1  1  ,    hilo 2  . get ( CmpSubsystemModel . BLOCK _ SIZE )  . asLong (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseSubsystem"], "fileName": "org.jboss.as.cmp.subsystem.CmpKeyGeneratorSubsystem10TestCase"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( operationName ,    operation . get ( ModelDescriptionConstants . OP )  . asString (  )  )  ;", "final   PathAddress   addr    =    PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "final   PathElement   element    =    addr . getLastElement (  )  ;", "assertEquals ( lastElement . getKey (  )  ,    element . getKey (  )  )  ;", "assertEquals ( lastElement . getValue (  )  ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertOperation"], "fileName": "org.jboss.as.cmp.subsystem.CmpKeyGeneratorSubsystem11TestCase"}, {"methodBody": ["METHOD_START", "{", "final   List < ModelNode >    operations    =    super . parse ( getSubsystemXml (  \" subsystem - cmp - key - generators _  1  _  1  . xml \"  )  )  ;", "assertEquals (  5  ,    operations . size (  )  )  ;", "assertOperation ( operations . get (  0  )  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    getMainSubsystemName (  )  )  )  ;", "assertOperation ( operations . get (  1  )  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . UUID _ KEY _ GENERATOR ,     \" uuid 1  \"  )  )  ;", "final   ModelNode   uuid 2     =    operations . get (  2  )  ;", "assertOperation ( uuid 2  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . UUID _ KEY _ GENERATOR ,     \" uuid 2  \"  )  )  ;", "assertEquals (  \" java : jboss / uuid 2  \"  ,    uuid 2  . get ( CmpSubsystemModel . JNDI _ NAME )  . asString (  )  )  ;", "final   ModelNode   hilo 1     =    operations . get (  3  )  ;", "assertOperation ( hilo 1  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . HILO _ KEY _ GENERATOR ,     \" hilo 1  \"  )  )  ;", "assertEquals (  \" java :  / jdbc / DB 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . DATA _ SOURCE )  . asString (  )  )  ;", "assertEquals (  \" HILOSEQUENCES 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . TABLE _ NAME )  . asString (  )  )  ;", "assertEquals (  \" SEQUENCENAME 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . SEQUENCE _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" HIGHVALUES 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . ID _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" create   table   HILOSEQUENCES 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . CREATE _ TABLE _ DDL )  . asString (  )  )  ;", "assertEquals (  \" general 1  \"  ,    hilo 1  . get ( CmpSubsystemModel . SEQUENCE _ NAME )  . asString (  )  )  ;", "assertEquals ( true ,    hilo 1  . get ( CmpSubsystemModel . CREATE _ TABLE )  . asBoolean (  )  )  ;", "assertEquals ( true ,    hilo 1  . get ( CmpSubsystemModel . DROP _ TABLE )  . asBoolean (  )  )  ;", "assertEquals (  1  0  ,    hilo 1  . get ( CmpSubsystemModel . BLOCK _ SIZE )  . asLong (  )  )  ;", "final   ModelNode   hilo 2     =    operations . get (  4  )  ;", "assertOperation ( hilo 2  ,    ModelDescriptionConstants . ADD ,    PathElement . pathElement ( CmpSubsystemModel . HILO _ KEY _ GENERATOR ,     \" hilo 2  \"  )  )  ;", "assertEquals (  \" java : jboss / hilo 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . JNDI _ NAME )  . asString (  )  )  ;", "assertEquals (  \" java :  / jdbc / DB 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . DATA _ SOURCE )  . asString (  )  )  ;", "assertEquals (  \" HILOSEQUENCES 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . TABLE _ NAME )  . asString (  )  )  ;", "assertEquals (  \" SEQUENCENAME 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . SEQUENCE _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" HIGHVALUES 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . ID _ COLUMN )  . asString (  )  )  ;", "assertEquals (  \" create   table   HILOSEQUENCES 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . CREATE _ TABLE _ DDL )  . asString (  )  )  ;", "assertEquals (  \" general 2  \"  ,    hilo 2  . get ( CmpSubsystemModel . SEQUENCE _ NAME )  . asString (  )  )  ;", "assertEquals ( false ,    hilo 2  . get ( CmpSubsystemModel . CREATE _ TABLE )  . asBoolean (  )  )  ;", "assertEquals ( false ,    hilo 2  . get ( CmpSubsystemModel . DROP _ TABLE )  . asBoolean (  )  )  ;", "assertEquals (  1  1  ,    hilo 2  . get ( CmpSubsystemModel . BLOCK _ SIZE )  . asLong (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseSubsystem"], "fileName": "org.jboss.as.cmp.subsystem.CmpKeyGeneratorSubsystem11TestCase"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "final   ModelNode   op    =    Util . createAddOperation ( parentAddress . append ( Model . HILO _ KEY _ GENERATOR ,    name )  )  ;", "final   EnumSet < Element >    required    =    EnumSet . of ( Element . DATA _ SOURCE ,    Element . TABLE _ NAME ,    Element . ID _ COLUMN ,    Element . SEQUENCE _ COLUMN ,    Element . SEQUENCE _ NAME )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   String   value    =    reader . getElementText (  )  ;", "final   String   tag    =    reader . getLocalName (  )  ;", "final   Element   element    =    Element . forName ( tag )  ;", "required . remove ( element )  ;", "SimpleAttributeDefinition   attribute    =    HiLoKeyGeneratorResourceDefinition . ATTRIBUTE _ MAP . get ( tag )  ;", "if    ( attribute    =  =    null )     {", "throw   unexpectedElement ( reader )  ;", "}", "attribute . parseAndSetParameter ( value ,    op ,    reader )  ;", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequiredElement ( reader ,    required )  ;", "}", "return   op ;", "}", "METHOD_END"], "methodName": ["parseHilo"], "fileName": "org.jboss.as.cmp.subsystem.CmpSubsystem10Parser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Element . forName ( reader . getLocalName (  )  )  )     {", "case   UUID    :", "{", "operations . add ( pUuid ( reader ,    parentAddress )  )  ;", "break ;", "}", "case   HILO    :", "{", "operations . add ( pHilo ( reader ,    parentAddress )  )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseKeyGenerators"], "fileName": "org.jboss.as.cmp.subsystem.CmpSubsystem10Parser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "final   ModelNode   op    =    Util . createAddOperation ( parentAddress . append ( Model . UUID _ KEY _ GENERATOR ,    name )  )  ;", "requireNoContent ( reader )  ;", "return   op ;", "}", "METHOD_END"], "methodName": ["parseUuid"], "fileName": "org.jboss.as.cmp.subsystem.CmpSubsystem10Parser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    EMPTY _ ADDRESS . append ( ModelDescriptionConstants . SUBSYSTEM ,    CmpExtension . SUBSYSTEM _ NAME )  ;", "requireNoAttributes ( reader )  ;", "final   ModelNode   c    =    Util . createAddOperation ( address )  ;", "operations . add ( c )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   KEY _ GENERATORS    :", "{", "this . parseKeyGenerators ( reader ,    operations ,    address )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.jboss.as.cmp.subsystem.CmpSubsystem10Parser"}, {"methodBody": ["METHOD_START", "{", "context . startSubsystemElement ( Namespace . CURRENT . getUriString (  )  ,    false )  ;", "final   ModelNode   model    =    context . getModelNode (  )  ;", "if    (  ( model . hasDefined ( Model . UUID _ KEY _ GENERATOR )  )     |  |     ( model . hasDefined ( Model . HILO _ KEY _ GENERATOR )  )  )     {", "writer . writeStartElement ( Element . KEY _ GENERATORS . getLocalName (  )  )  ;", "if    ( model . hasDefined ( Model . UUID _ KEY _ GENERATOR )  )     {", "for    ( Property   keyGen    :    model . get ( Model . UUID _ KEY _ GENERATOR )  . asPropertyList (  )  )     {", "final   String   name    =    keyGen . getName (  )  ;", "final   ModelNode   keyGenModel    =    keyGen . getValue (  )  ;", "writeUuid ( writer ,    name ,    keyGenModel )  ;", "}", "}", "if    ( model . hasDefined ( Model . HILO _ KEY _ GENERATOR )  )     {", "for    ( Property   keyGen    :    model . get ( Model . HILO _ KEY _ GENERATOR )  . asPropertyList (  )  )     {", "final   String   name    =    keyGen . getName (  )  ;", "final   ModelNode   keyGenModel    =    keyGen . getValue (  )  ;", "writeHilo ( writer ,    name ,    keyGenModel )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeContent"], "fileName": "org.jboss.as.cmp.subsystem.CmpSubsystem10Parser"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . HILO . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    name )  ;", "HiLoKeyGeneratorResourceDefinition . JNDI _ NAME . mhallAsAttribute ( model ,    writer )  ;", "for    ( SimpleAttributeDefinition   attribute    :    HiLoKeyGeneratorResourceDefinition . ATTRIBUTES )     {", "if    (  !  ( attribute . equals ( HiLoKeyGeneratorResourceDefinition . JNDI _ NAME )  )  )", "attribute . mhallAsElement ( model ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeHilo"], "fileName": "org.jboss.as.cmp.subsystem.CmpSubsystem10Parser"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . UUID . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    name )  ;", "UUIDKeyGeneratorResourceDefinition . JNDI _ NAME . mhallAsAttribute ( model ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeUuid"], "fileName": "org.jboss.as.cmp.subsystem.CmpSubsystem10Parser"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.cmp.subsystem.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.cmp.subsystem.Element"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attribute    :    HiLoKeyGeneratorResourceDefinition . ATTRIBUTES )     {", "attribute . validateAndSet ( operation ,    model )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.cmp.subsystem.HiLoKeyGeneratorAdd"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.cmp.subsystem.Namespace"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attribute    :    UUIDKeyGeneratorResourceDefinition . ATTRIBUTES )     {", "attribute . validateAndSet ( operation ,    model )  ;", "}", "}", "METHOD_END"], "methodName": ["populateModel"], "fileName": "org.jboss.as.cmp.subsystem.UUIDKeyGeneratorAdd"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardResourceDescriptionResolver ( keyPrefix ,    ConfigAdminExtension . RESOURCE _ NAME ,    ConfigAdminExtension . class . getClassLoader (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.configadmin.parser.ConfigAdminExtension"}, {"methodBody": ["METHOD_START", "{", "String   pid    =    ParseUtils . requireAttributes ( reader ,    Namespace 1  0  . Attribute . PID . getLocalName (  )  )  [  0  ]  ;", "ModelNode   operation    =    Util . createAddOperation ( parent . append ( ModelConstants . CONFIGURATION ,    pid )  )  ;", "operations . add ( operation )  ;", "while    (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )     {", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   VERSION _  1  _  0     :", "{", "final   Namespace 1  0  . Element   element    =    Namespace 1  0  . Element . forName ( reader . getLocalName (  )  )  ;", "if    ( element    =  =     ( Namespace 1  0  . Element . PROPERTY )  )     {", "final   String [  ]    array    =    requireAttributes ( reader ,    NAME . getLocalName (  )  ,    VALUE . getLocalName (  )  )  ;", "ConfigurationResource . ENTRIESAndAddParameterElement ( array [  0  ]  ,    array [  1  ]  ,    operation ,    reader )  ;", "ParseUtils . requireNoContent ( reader )  ;", "break ;", "} else    {", "throw   unexpectedElement ( reader )  ;", "}", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseConfigurations"], "fileName": "org.jboss.as.configadmin.parser.ConfigAdminParser"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" expressions \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.jboss.as.configadmin.parser.ConfigAdminSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest ( null )  ;", "}", "METHOD_END"], "methodName": ["testParseEmptySubsystem"], "fileName": "org.jboss.as.configadmin.parser.ConfigAdminSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =     (  (  \"  < subsystem   xmlns =  \\  \"  \"     +     ( Namespace . CURRENT . getUriString (  )  )  )     +     \"  \\  \"  >  \"  )     +     \"  <  / subsystem >  \"  ;", "ModelNode   testModel    =    new   ModelNode (  )  ;", "testModel . get ( SUBSYSTEM ,    Extension . SUBSYSTEM _ NAME )  . setEmptyObject (  )  ;", "String   triggered    =    outputModel ( testModel )  ;", "Assert . assertEquals ( normalizeXML ( subsystemXml )  ,    normalizeXML ( triggered )  )  ;", "}", "METHOD_END"], "methodName": ["testReadWriteEmptySubsystem"], "fileName": "org.jboss.as.configadmin.parser.ConfigAdminSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.configadmin.parser.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.configadmin.parser.Namespace"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )", "return   null ;", "IORASContextMetaData   metaData    =    new   IORASContextMetaData (  )  ;", "metaData . setAuthMethod (  . AUTH _ METHOD . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "if    ( model . hasDefined (  . REALM . getName (  )  )  )     {", "metaData . setRealm (  . REALM . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "}", "metaData . setRequired (  . REQUIRED . resolveModelAttribute ( context ,    model )  . asBoolean (  )  )  ;", "return   metaData ;", "}", "METHOD_END"], "methodName": ["getIORASContextMetaData"], "fileName": "org.jboss.as.jacorb.IORASContextDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )", "return   null ;", "IORSASContextMetaData   metaData    =    new   IORSASContextMetaData (  )  ;", "metaData . setCallerPropagation (  . CALLER _ PROPAGATION . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "return   metaData ;", "}", "METHOD_END"], "methodName": ["getIORSASContextMetaData"], "fileName": "org.jboss.as.jacorb.IORSASContextDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( model . isDefined (  )  )  )", "return   null ;", "IORTransportConfigMetaData   metaData    =    new   IORTransportConfigMetaData (  )  ;", "metaData . setIntegrity (  . INTEGRITY . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "metaData . setConfidentiality (  . CONFIDENTIALITY . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "metaData . setEstablishTrustInTarget (  . TRUST _ IN _ TARGET . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "metaData . setEstablishTrustInClient (  . TRUST _ IN _ CLIENT . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "metaData . setDetectMisordering (  . DETECT _ MISORDERING . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "metaData . setDetectReplay (  . DETECT _ REPLAY . resolveModelAttribute ( context ,    model )  . asString (  )  )  ;", "return   metaData ;", "}", "METHOD_END"], "methodName": ["getTransportConfigMetaData"], "fileName": "org.jboss.as.jacorb.IORTransportConfigDefinition"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder ( JacORBExtension . SUBSYSTEM _ NAME )  ;", "for    ( String   kp    :    keyPrefix )     {", "prefix . append (  '  .  '  )  . append ( kp )  ;", "}", "return   new   DeprecatedResourceDescriptionResolver ( JacORBExtension . SUBSYSTEM _ NAME ,    prefix . toString (  )  ,    JacORBExtension . RESOURCE _ NAME ,    JacORBExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.jacorb.JacORBExtension"}, {"methodBody": ["METHOD_START", "{", "ChainedTransformationDescriptionBuilder   chained    =    Factory . createChainedSubystemInstance ( JacORBExtension . CURRENT _ MODEL _ VERSION )  ;", "ModelVersion   MODEL _ VERSION _ EAP 6  4     =    ModelVersion . create (  1  ,     4  ,     0  )  ;", "ModelVersion   MODEL _ VERSION _ EAP 6  3     =    ModelVersion . create (  1  ,     3  ,     0  )  ;", "ResourceTransformationDescriptionBuilder   builder 6  4     =    chained . createBuilder ( JacORBExtension . CURRENT _ MODEL _ VERSION ,    MODEL _ VERSION _ EAP 6  4  )  ;", "builder 6  4  . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    JacORBSubsystemDefinitions . PERSISTENT _ SERVER _ ID )  . setDiscard ( new   DiscardAttributeValueChecker ( JacORBSubsystemDefinitions . PERSISTENT _ SERVER _ ID . getDefaultValue (  )  )  ,    JacORBSubsystemDefinitions . PERSISTENT _ SERVER _ ID )  . setValueConverter ( new   DefaultValueAttributeConverter ( JacORBSubsystemDefinitions . INTEROP _ CHUNK _ RMI _ VALUETYPES )  ,    JacORBSubsystemDefinitions . INTEROP _ CHUNK _ RMI _ VALUETYPES )  ;", "ResourceTransformationDescriptionBuilder   builder 6  3     =    chained . createBuilder ( MODEL _ VERSION _ EAP 6  4  ,    MODEL _ VERSION _ EAP 6  3  )  ;", "builder 6  3  . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    IORTransportConfigDefinition . ATTRIBUTES . toArray ( new   AttributeDefinition [  0  ]  )  )  . addRejectCheck ( DEFINED ,    IORASContextDefinition . ATTRIBUTES . toArray ( new   AttributeDefinition [  0  ]  )  )  . addRejectCheck ( DEFINED ,    IORSASContextDefinition . ATTRIBUTES . toArray ( new   AttributeDefinition [  0  ]  )  )  . end (  )  . rejectChildResource ( IORSettingsDefinition . INSTANCE . getPathElement (  )  )  ;", "chained . buildAndRegister ( subsystem ,    new   ModelVersion [  ]  {    MODEL _ VERSION _ EAP 6  4  ,    MODEL _ VERSION _ EAP 6  3     }  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers"], "fileName": "org.jboss.as.jacorb.JacORBExtension"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem . xml \"  )  ;", ". NewSubsystemAdditionalInitialization   additionalInitialization    =    new    . NewSubsystemAdditionalInitialization (  )  ;", "KernelServices   services    =    createKernelServicesBuilder ( additionalInitialization )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   model    =    services . readWholeModel (  )  ;", "Assert . assertFalse ( additionalInitialization . extensionAdded )  ;", "Assert . assertTrue ( model . get ( ModelDescriptionConstants . SUBSYSTEM )  . hasDefined ( JacORBExtension . SUBSYSTEM _ NAME )  )  ;", "Assert . assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM )  . hasDefined ( SUBSYSTEM _ NAME )  )  ;", "ModelNode   migrateOp    =    new   ModelNode (  )  ;", "migrateOp . get ( ModelDescriptionConstants . OP )  . set (  \" migrate \"  )  ;", "migrateOp . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    JacORBExtension . SUBSYSTEM _ NAME )  )  . toModelNode (  )  )  ;", "checkOutcome ( services . executeOperation ( migrateOp )  )  ;", "model    =    services . readWholeModel (  )  ;", "Assert . assertTrue ( additionalInitialization . extensionAdded )  ;", "Assert . assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM )  . hasDefined ( JacORBExtension . SUBSYSTEM _ NAME )  )  ;", "Assert . assertTrue ( model . get ( ModelDescriptionConstants . SUBSYSTEM )  . hasDefined ( SUBSYSTEM _ NAME )  )  ;", "ModelNode   newSubsystem    =    model . get ( ModelDescriptionConstants . SUBSYSTEM )  . get (  \" iiop - openjdk \"  )  ;", "Assert . assertTrue ( newSubsystem . get (  \" export - corbaloc \"  )  . equals ( new   ModelNode ( true )  )  )  ;", "Assert . assertTrue ( newSubsystem . get (  \" confidentiality \"  )  . equals ( new   ModelNode (  \" required \"  )  )  )  ;", "Assert . assertTrue ( newSubsystem . get (  \" iona \"  )  . equals ( new   ModelNode ( true )  )  )  ;", "}", "METHOD_END"], "methodName": ["migrateTest"], "fileName": "org.jboss.as.jacorb.JacORBMigrateTestCase"}, {"methodBody": ["METHOD_START", "{", "JacORBLogger . ROOT _ LOGGER . jacorbEmulationWarning (  )  ;", "}", "METHOD_END"], "methodName": ["printJacORBEmulationWarningMessage"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemAdd"}, {"methodBody": ["METHOD_START", "{", "return   JacORBSubsystemDefinitions . ATTRIBUTES _ BY _ NAME . get ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["valueOf"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemDefinitions"}, {"methodBody": ["METHOD_START", "{", "boolean   isWritable    =    false ;", "for    ( SimpleAttributeDefinition   attributeDefinition    :    attributeDefinitions )     {", "if    ( attributeDefinition . isMhallable ( node )  )     {", "isWritable    =    true ;", "break ;", "}", "}", "return   isWritable ;", "}", "METHOD_END"], "methodName": ["isWritable"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    parsedAttributes    =    EnumSet . noneOf ( JacORBSubsystemParser . Attribute . class )  ;", "if    ( requiredAttributes    =  =    null )     {", "requiredAttributes    =    EnumSet . noneOf ( JacORBSubsystemParser . Attribute . class )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   JacORBSubsystemParser . Attribute   attribute    =    JacORBSubsystemParser . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "if    (  !  ( expectedAttributes . contains ( attribute )  )  )", "throw   unexpectedAttribute ( reader ,    i )  ;", "if    (  !  ( parsedAttributes . add ( attribute )  )  )     {", "throw   duplicateAttribute ( reader ,    attribute . getLocalName (  )  )  ;", "}", "requiredAttributes . remove ( attribute )  ;", "(  ( SimpleAttributeDefinition )     ( JacORBSubsystemDefinitions . valueOf ( attribute . getLocalName (  )  )  )  )  . parseAndSetParameter ( attrValue ,    node ,    reader )  ;", "}", "if    (  !  ( requiredAttributes . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    requiredAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAttributes"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "ModelNode   val    =    null ;", "EnumSet <  . Attribute >    required    =    EnumSet . of (  . Attribute . NAME ,     . Attribute . PROP _ VALUE )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final    . Attribute   attribute    =     . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    value ;", "break ;", "}", "case   PROP _ VALUE    :", "{", "val    =    JacORBSubsystemDefinitions . PROPERTIES . parse ( value ,    reader . getLocation (  )  )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "node . get ( name )  . set ( val )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseGenericProperty"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "String   val    =    null ;", "EnumSet <  . Attribute >    required    =    EnumSet . of (  . Attribute . PROP _ KEY ,     . Attribute . PROP _ VALUE )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final    . Attribute   attribute    =     . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   PROP _ KEY    :", "{", "name    =    value ;", "break ;", "}", "case   PROP _ VALUE    :", "{", "val    =    value ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "node . get ( name )  . set ( val )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseGenericProperty_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    expectedAttributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . INTEROP _ SUN ,    JacORBSubsystemParser . Attribute . INTEROP _ COMET ,    JacORBSubsystemParser . Attribute . INTEROP _ IONA ,    JacORBSubsystemParser . Attribute . INTEROP _ CHUNK _ RMI _ VALUETYPES ,    JacORBSubsystemParser . Attribute . INTEROP _ LAX _ BOOLEAN _ ENCODING ,    JacORBSubsystemParser . Attribute . INTEROP _ INDIRECTION _ ENCODING _ DISABLE ,    JacORBSubsystemParser . Attribute . INTEROP _ STRICT _ CHECK _ ON _ TC _ CREATION )  ;", "this . parseAttributes ( reader ,    node ,    expectedAttributes ,    null )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseInteropConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    expectedAttributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . NAMING _ ROOT _ CONTEXT ,    JacORBSubsystemParser . Attribute . NAMING _ EXPORT _ CORBALOC )  ;", "this . parseAttributes ( reader ,    node ,    expectedAttributes ,    null )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseNamingConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    expectedAttributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . NAME ,    JacORBSubsystemParser . Attribute . ORB _ PRINT _ VERSION ,    JacORBSubsystemParser . Attribute . ORB _ GIOP _ MINOR _ VERSION ,    JacORBSubsystemParser . Attribute . ORB _ USE _ BOM ,    JacORBSubsystemParser . Attribute . ORB _ USE _ IMR ,    JacORBSubsystemParser . Attribute . ORB _ CACHE _ POA _ NAMES ,    JacORBSubsystemParser . Attribute . ORB _ CACHE _ TYPECODES )  ;", "if    (  ( namespace . ordinal (  )  )     >  =     ( JacORBSubsystemParser . Namespace . JacORB _  1  _  2  . ordinal (  )  )  )     {", "expectedAttributes . add ( JacORBSubsystemParser . Attribute . ORB _ SOCKET _ BINDING )  ;", "expectedAttributes . add ( JacORBSubsystemParser . Attribute . ORB _ SSL _ SOCKET _ BINDING )  ;", "}", "if    (  ( namespace . ordinal (  )  )     >  =     ( JacORBSubsystemParser . Namespace . JacORB _  2  _  0  . ordinal (  )  )  )     {", "expectedAttributes . add ( JacORBSubsystemParser . Attribute . ORB _ PERSISTENT _ SERVER _ ID )  ;", "}", "this . parseAttributes ( reader ,    node ,    expectedAttributes ,    null )  ;", "EnumSet < JacORBSubsystemParser . Element >    encountered    =    EnumSet . noneOf ( JacORBSubsystemParser . Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    ( namespace    !  =     ( JacORBSubsystemParser . Namespace . forUri ( reader . getNamespaceURI (  )  )  )  )", "throw   unexpectedElement ( reader )  ;", "final   JacORBSubsystemParser . Element   element    =    JacORBSubsystemParser . Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( encountered . add ( element )  )  )     {", "throw   duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "switch    ( element )     {", "case   ORB _ CONNECTION    :", "{", "this . parseORBConnectionConfig ( reader ,    node )  ;", "break ;", "}", "case   ORB _ INITIALIZERS    :", "{", "this . parseORBInitializersConfig ( reader ,    node )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseORBConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    expectedAttributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . NAME ,    JacORBSubsystemParser . Attribute . ORB _ PRINT _ VERSION ,    JacORBSubsystemParser . Attribute . ORB _ GIOP _ MINOR _ VERSION ,    JacORBSubsystemParser . Attribute . ORB _ USE _ BOM ,    JacORBSubsystemParser . Attribute . ORB _ USE _ IMR ,    JacORBSubsystemParser . Attribute . ORB _ CACHE _ POA _ NAMES ,    JacORBSubsystemParser . Attribute . ORB _ CACHE _ TYPECODES )  ;", "this . parseAttributes ( reader ,    node ,    expectedAttributes ,    null )  ;", "EnumSet < JacORBSubsystemParser . Element >    encountered    =    EnumSet . noneOf ( JacORBSubsystemParser . Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    (  ( JacORBSubsystemParser . Namespace . JacORB _  1  _  0  )     !  =     ( JacORBSubsystemParser . Namespace . forUri ( reader . getNamespaceURI (  )  )  )  )", "throw   unexpectedElement ( reader )  ;", "final   JacORBSubsystemParser . Element   element    =    JacORBSubsystemParser . Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( encountered . add ( element )  )  )     {", "throw   duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "switch    ( element )     {", "case   ORB _ CONNECTION    :", "{", "this . parseORBConnectionConfig ( reader ,    node )  ;", "break ;", "}", "case   NAMING    :", "{", "this . parseNamingConfig ( reader ,    node )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseORBConfig_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    attributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . ORB _ CONN _ RETRIES ,    JacORBSubsystemParser . Attribute . ORB _ CONN _ RETRY _ INTERVAL ,    JacORBSubsystemParser . Attribute . ORB _ CONN _ CLIENT _ TIMEOUT ,    JacORBSubsystemParser . Attribute . ORB _ CONN _ SERVER _ TIMEOUT ,    JacORBSubsystemParser . Attribute . ORB _ CONN _ MAX _ SERVER _ CONNECTIONS ,    JacORBSubsystemParser . Attribute . ORB _ CONN _ MAX _ MANAGED _ BUF _ SIZE ,    JacORBSubsystemParser . Attribute . ORB _ CONN _ OUTBUF _ SIZE ,    JacORBSubsystemParser . Attribute . ORB _ CONN _ OUTBUF _ CACHE _ TIMEOUT )  ;", "this . parseAttributes ( reader ,    node ,    attributes ,    null )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseORBConnectionConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    attributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . ORB _ INIT _ SECURITY ,    JacORBSubsystemParser . Attribute . ORB _ INIT _ TRANSACTIONS )  ;", "this . parseAttributes ( reader ,    node ,    attributes ,    null )  ;", "requireNoContent ( reader )  ;", "if    (  ( node . has ( JacORBSubsystemConstants . SECURITY )  )     &  &     ( node . get ( JacORBSubsystemConstants . SECURITY )  . asString (  )  . equals ( JacORBSubsystemConstants . ON )  )  )     {", "node . get ( JacORBSubsystemConstants . SECURITY )  . set ( SecurityAllowedValues . IDENTITY . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseORBInitializersConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "String   initializersList    =    reader . getElementText (  )  ;", "if    ( initializersList    !  =    null )     {", "String [  ]    initializers    =    initializersList . split (  \"  ,  \"  )  ;", "for    ( String   initializer    :    initializers )     {", "SimpleAttributeDefinition   definition    =     (  ( SimpleAttributeDefinition )     ( JacORBSubsystemDefinitions . valueOf ( initializer )  )  )  ;", "if    (  ( definition    !  =    null )     &  &     ( JacORBSubsystemDefinitions . ORB _ INIT _ ATTRIBUTES . contains ( definition )  )  )", "node . get ( definition . getName (  )  )  . set ( JacORBSubsystemConstants . ON )  ;", "else", "throw   logging . JacORBLogger . ROOT _ LOGGER . invalidInitializerConfig ( initializer ,    reader . getLocation (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseORBInitializersConfig_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    expectedAttributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . POA _ MONITORING ,    JacORBSubsystemParser . Attribute . POA _ QUEUE _ WAIT ,    JacORBSubsystemParser . Attribute . POA _ QUEUE _ MIN ,    JacORBSubsystemParser . Attribute . POA _ QUEUE _ MAX )  ;", "this . parseAttributes ( reader ,    node ,    expectedAttributes ,    null )  ;", "EnumSet < JacORBSubsystemParser . Element >    encountered    =    EnumSet . noneOf ( JacORBSubsystemParser . Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    ( namespace    !  =     ( JacORBSubsystemParser . Namespace . forUri ( reader . getNamespaceURI (  )  )  )  )", "throw   unexpectedElement ( reader )  ;", "final   JacORBSubsystemParser . Element   element    =    JacORBSubsystemParser . Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( encountered . add ( element )  )  )     {", "throw   duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "switch    ( element )     {", "case   POA _ REQUEST _ PROC    :", "{", "EnumSet < JacORBSubsystemParser . Attribute >    attributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . POA _ REQUEST _ PROC _ POOL _ SIZE ,    JacORBSubsystemParser . Attribute . POA _ REQUEST _ PROC _ MAX _ THREADS )  ;", "this . parseAttributes ( reader ,    node ,    attributes ,    null )  ;", "requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parsePOAConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    ( namespace    !  =     (  . Namespace . forUri ( reader . getNamespaceURI (  )  )  )  )", "throw   unexpectedElement ( reader )  ;", "final    . Element   element    =     . Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "{", "this . parseGenericProperty ( reader ,    node . get ( JacORBSubsystemConstants . PROPERTIES )  )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parsePropertiesConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    expectedAttributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . SECURITY _ SUPPORT _ SSL ,    JacORBSubsystemParser . Attribute . SECURITY _ SECURITY _ DOMAIN ,    JacORBSubsystemParser . Attribute . SECURITY _ ADD _ COMPONENT _ INTERCEPTOR ,    JacORBSubsystemParser . Attribute . SECURITY _ CLIENT _ SUPPORTS ,    JacORBSubsystemParser . Attribute . SECURITY _ CLIENT _ REQUIRES ,    JacORBSubsystemParser . Attribute . SECURITY _ SERVER _ SUPPORTS ,    JacORBSubsystemParser . Attribute . SECURITY _ SERVER _ REQUIRES )  ;", "this . parseAttributes ( reader ,    node ,    expectedAttributes ,    null )  ;", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseSecurityConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "EnumSet < JacORBSubsystemParser . Attribute >    expectedAttributes    =    EnumSet . of ( JacORBSubsystemParser . Attribute . SECURITY _ SUPPORT _ SSL ,    JacORBSubsystemParser . Attribute . SECURITY _ ADD _ COMPONENT _ INTERCEPTOR ,    JacORBSubsystemParser . Attribute . SECURITY _ CLIENT _ SUPPORTS ,    JacORBSubsystemParser . Attribute . SECURITY _ CLIENT _ REQUIRES ,    JacORBSubsystemParser . Attribute . SECURITY _ SERVER _ SUPPORTS ,    JacORBSubsystemParser . Attribute . SECURITY _ SERVER _ REQUIRES ,    JacORBSubsystemParser . Attribute . SECURITY _ USE _ DOMAIN _ SF ,    JacORBSubsystemParser . Attribute . SECURITY _ USE _ DOMAIN _ SSF )  ;", "EnumSet < JacORBSubsystemParser . Attribute >    parsedAttributes    =    EnumSet . noneOf ( JacORBSubsystemParser . Attribute . class )  ;", "for    ( int   i    =     0  ;    i    <     ( reader . getAttributeCount (  )  )  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   JacORBSubsystemParser . Attribute   attribute    =    JacORBSubsystemParser . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "if    (  !  ( expectedAttributes . contains ( attribute )  )  )", "throw   unexpectedAttribute ( reader ,    i )  ;", "if    (  !  ( parsedAttributes . add ( attribute )  )  )     {", "throw   duplicateAttribute ( reader ,    attribute . getLocalName (  )  )  ;", "}", "switch    ( attribute )     {", "case   SECURITY _ CLIENT _ SUPPORTS    :", "case   SECURITY _ CLIENT _ REQUIRES    :", "case   SECURITY _ SERVER _ SUPPORTS    :", "case   SECURITY _ SERVER _ REQUIRES    :", "SSLConfigValue   value    =    SSLConfigValue . fromValue ( attrValue )  ;", "if    ( value    =  =    null )", "throw   invalidSSLConfig ( attrValue ,    reader . getLocation (  )  )  ;", "attrValue    =    value . toString (  )  ;", "default    :", "SimpleAttributeDefinition   definition    =     (  ( SimpleAttributeDefinition )     ( JacORBSubsystemDefinitions . valueOf ( attribute . getLocalName (  )  )  )  )  ;", "if    ( definition    !  =    null )", "definition . parseAndSetParameter ( attrValue ,    node ,    reader )  ;", "}", "}", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseSecurityConfig_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   EnumSet < JacORBSubsystemParser . Element >    encountered    =    EnumSet . noneOf ( JacORBSubsystemParser . Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    (  ( JacORBSubsystemParser . Namespace . JacORB _  1  _  0  )     !  =     ( JacORBSubsystemParser . Namespace . forUri ( reader . getNamespaceURI (  )  )  )  )", "throw   unexpectedElement ( reader )  ;", "final   JacORBSubsystemParser . Element   element    =    JacORBSubsystemParser . Element . forName ( reader . getLocalName (  )  )  ;", "if    (  (  !  ( encountered . add ( element )  )  )     &  &     ( element    !  =     ( JacORBSubsystemParser . Element . PROPERTY )  )  )     {", "throw   duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "switch    ( element )     {", "case   ORB    :", "{", "this . parseORBConfig _  1  _  0  ( reader ,    node )  ;", "break ;", "}", "case   POA    :", "{", "this . parsePOAConfig ( namespace ,    reader ,    node )  ;", "break ;", "}", "case   INTEROP    :", "{", "this . parseInteropConfig ( reader ,    node )  ;", "break ;", "}", "case   SECURITY    :", "{", "this . parseSecurityConfig _  1  _  0  ( reader ,    node )  ;", "break ;", "}", "case   PROPERTY    :", "{", "ModelNode   propertiesNode    =    node . get ( JacORBSubsystemConstants . PROPERTIES )  ;", "this . parseGenericProperty _  1  _  0  ( reader ,    propertiesNode )  ;", "break ;", "}", "case   ORB _ INITIALIZERS    :", "{", "this . parseORBInitializersConfig _  1  _  0  ( reader ,    node )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["readElement_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   EnumSet < JacORBSubsystemParser . Element >    encountered    =    EnumSet . noneOf ( JacORBSubsystemParser . Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    ( namespace    !  =     ( JacORBSubsystemParser . Namespace . forUri ( reader . getNamespaceURI (  )  )  )  )", "throw   unexpectedElement ( reader )  ;", "final   JacORBSubsystemParser . Element   element    =    JacORBSubsystemParser . Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( encountered . add ( element )  )  )     {", "throw   duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "switch    ( element )     {", "case   ORB    :", "{", "this . parseORBConfig ( namespace ,    reader ,    node )  ;", "break ;", "}", "case   POA    :", "{", "this . parsePOAConfig ( namespace ,    reader ,    node )  ;", "break ;", "}", "case   NAMING    :", "{", "this . parseNamingConfig ( reader ,    node )  ;", "break ;", "}", "case   INTEROP    :", "{", "this . parseInteropConfig ( reader ,    node )  ;", "break ;", "}", "case   SECURITY    :", "{", "this . parseSecurityConfig ( reader ,    node )  ;", "break ;", "}", "case   PROPERTIES    :", "{", "this . parsePropertiesConfig ( namespace ,    reader ,    node )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["readElement_1_1"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   EnumSet < JacORBSubsystemParser . Element >    encountered    =    EnumSet . noneOf ( JacORBSubsystemParser . Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "if    ( namespace    !  =     ( JacORBSubsystemParser . Namespace . forUri ( reader . getNamespaceURI (  )  )  )  )", "throw   unexpectedElement ( reader )  ;", "final   JacORBSubsystemParser . Element   element    =    JacORBSubsystemParser . Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( encountered . add ( element )  )  )     {", "throw   duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "ModelNode   node    =    nodes . get (  0  )  ;", "switch    ( element )     {", "case   ORB    :", "{", "this . parseORBConfig ( namespace ,    reader ,    nodes . get (  0  )  )  ;", "break ;", "}", "case   POA    :", "{", "this . parsePOAConfig ( namespace ,    reader ,    node )  ;", "break ;", "}", "case   NAMING    :", "{", "this . parseNamingConfig ( reader ,    node )  ;", "break ;", "}", "case   INTEROP    :", "{", "this . parseInteropConfig ( reader ,    node )  ;", "break ;", "}", "case   SECURITY    :", "{", "this . parseSecurityConfig ( reader ,    node )  ;", "break ;", "}", "case   IOR _ SETTINGS    :", "{", "IORSettingsParser . INSTANCE . readElement ( reader ,    nodes )  ;", "break ;", "}", "case   PROPERTIES    :", "{", "this . parsePropertiesConfig ( namespace ,    reader ,    node )  ;", "break ;", "}", "default    :", "{", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["readElement_1_4"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "readElement _  1  _  4  ( namespace ,    reader ,    nodes )  ;", "}", "METHOD_END"], "methodName": ["readElement_2_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "for    ( SimpleAttributeDefinition   definition    :    attributes )", "definition . mhallAsAttribute ( node ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeAttributes"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( JacORBSubsystemConstants . PROPERTIES )  ;", "for    ( Property   prop    :    node . asPropertyList (  )  )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . PROPERTY )  ;", "writer . writeAttribute ( JacORBSubsystemConstants . NAME ,    prop . getName (  )  )  ;", "writer . writeAttribute ( JacORBSubsystemConstants . PROPERTY _ VALUE ,    prop . getValue (  )  . asString (  )  )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeGenericProperties"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   writeInterop    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . INTEROP _ ATTRIBUTES )  ;", "if    ( writeInterop )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . INTEROP )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . INTEROP _ ATTRIBUTES )  ;", "}", "}", "METHOD_END"], "methodName": ["writeInteropConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   writeNaming    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . NAMING _ ATTRIBUTES )  ;", "if    ( writeNaming )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . NAMING )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . NAMING _ ATTRIBUTES )  ;", "}", "}", "METHOD_END"], "methodName": ["writeNamingConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   writeORB    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . ORB _ ATTRIBUTES )  ;", "boolean   writeORBConnection    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . ORB _ CONN _ ATTRIBUTES )  ;", "boolean   writeORBInitializer    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . ORB _ INIT _ ATTRIBUTES )  ;", "if    (  (  ! writeORBConnection )     &  &     (  ! writeORBInitializer )  )     {", "if    ( writeORB )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . ORB )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . ORB _ ATTRIBUTES )  ;", "}", "} else    {", "writer . writeStartElement ( JacORBSubsystemConstants . ORB )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . ORB _ ATTRIBUTES )  ;", "if    ( writeORBConnection )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . ORB _ CONN )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . ORB _ CONN _ ATTRIBUTES )  ;", "}", "if    ( writeORBInitializer )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . ORB _ INIT )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . ORB _ INIT _ ATTRIBUTES )  ;", "}", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeORBConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   writePOA    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . POA _ ATTRIBUTES )  ;", "boolean   writePOARP    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . POA _ RP _ ATTRIBUTES )  ;", "if    (  ! writePOARP )     {", "if    ( writePOA )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . POA )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . POA _ ATTRIBUTES )  ;", "}", "} else    {", "writer . writeStartElement ( JacORBSubsystemConstants . POA )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . POA _ ATTRIBUTES )  ;", "writer . writeEmptyElement ( JacORBSubsystemConstants . POA _ RP )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . POA _ RP _ ATTRIBUTES )  ;", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writePOAConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   writeSecurity    =    this . isWritable ( node ,    JacORBSubsystemDefinitions . SECURITY _ ATTRIBUTES )  ;", "if    ( writeSecurity )     {", "writer . writeEmptyElement ( JacORBSubsystemConstants . SECURITY )  ;", "this . writeAttributes ( writer ,    node ,    JacORBSubsystemDefinitions . SECURITY _ ATTRIBUTES )  ;", "}", "}", "METHOD_END"], "methodName": ["writeSecurityConfig"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" expressions . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =     (  (  \"  < subsystem   xmlns =  \\  \"  \"     +     ( JacORBSubsystemParser . Namespace . CURRENT . getUriString (  )  )  )     +     \"  \\  \"  >  \"  )     +     \"  <  / subsystem >  \"  ;", "List < ModelNode >    operations    =    super . parse ( subsystemXml )  ;", "Assert . assertEquals (  1  ,    operations . size (  )  )  ;", "ModelNode   addSubsystem    =    operations . get (  0  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . ADD ,    addSubsystem . get ( ModelDescriptionConstants . OP )  . asString (  )  )  ;", "PathAddress   addr    =    PathAddress . pathAddress ( addSubsystem . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "Assert . assertEquals (  1  ,    addr . size (  )  )  ;", "PathElement   element    =    addr . getElement (  0  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUBSYSTEM ,    element . getKey (  )  )  ;", "Assert . assertEquals ( JacORBExtension . SUBSYSTEM _ NAME ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseEmptySubsystem"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =     (  (  \"  < subsystem   xmlns =  \\  \"  \"     +     ( JacORBSubsystemParser . Namespace . JacORB _  1  _  0  . getUriString (  )  )  )     +     \"  \\  \"  >  \"  )     +     \"  <  / subsystem >  \"  ;", "List < ModelNode >    operations    =    super . parse ( subsystemXml )  ;", "Assert . assertEquals (  1  ,    operations . size (  )  )  ;", "ModelNode   addSubsystem    =    operations . get (  0  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . ADD ,    addSubsystem . get ( ModelDescriptionConstants . OP )  . asString (  )  )  ;", "PathAddress   addr    =    PathAddress . pathAddress ( addSubsystem . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "Assert . assertEquals (  1  ,    addr . size (  )  )  ;", "PathElement   element    =    addr . getElement (  0  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUBSYSTEM ,    element . getKey (  )  )  ;", "Assert . assertEquals ( JacORBExtension . SUBSYSTEM _ NAME ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseEmptySubsystem_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =     (  (  \"  < subsystem   xmlns =  \\  \"  \"     +     ( JacORBSubsystemParser . Namespace . CURRENT . getUriString (  )  )  )     +     \"  \\  \"    bad =  \\  \" very _ bad \\  \"  >  \"  )     +     \"  <  / subsystem >  \"  ;", "try    {", "super . parse ( subsystemXml )  ;", "Assert . fail (  \" Should   not   have   parsed   bad   attribute \"  )  ;", "}    catch    ( XMLStreamException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testParseSubsystemWithBadAttribute"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =     (  (  (  \"  < subsystem   xmlns =  \\  \"  \"     +     ( JacORBSubsystemParser . Namespace . CURRENT . getUriString (  )  )  )     +     \"  \\  \"  >  \"  )     +     \"           < invalid /  >  \"  )     +     \"  <  / subsystem >  \"  ;", "try    {", "super . parse ( subsystemXml )  ;", "Assert . fail (  \" Should   not   have   parsed   bad   child \"  )  ;", "}    catch    ( XMLStreamException   expected )     {", "}", "subsystemXml    =     \"  < subsystem   xmlns =  \\  \" urn : jboss : domain : jacorb :  1  .  0  \\  \"  >  \"     +     (  (  (  \"              < orb   name =  \\  \" JBoss \\  \"    print - version =  \\  \" off \\  \"  >  \"     +     \"                          < poa /  >  \"  )     +     \"              <  / orb >  \"  )     +     \"  <  / subsystem >  \"  )  ;", "try    {", "super . parse ( subsystemXml )  ;", "Assert . fail (  \" Should   not   have   parsed   bad   child \"  )  ;", "}    catch    ( XMLStreamException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testParseSubsystemWithBadChild"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =     (  (  (  \"  < subsystem   xmlns =  \\  \"  \"     +     ( JacORBSubsystemParser . Namespace . JacORB _  1  _  0  . getUriString (  )  )  )     +     \"  \\  \"  >  \"  )     +     \"           < initializers > invalid <  / initializers >  \"  )     +     \"  <  / subsystem >  \"  ;", "try    {", "super . parse ( subsystemXml )  ;", "Assert . fail (  \" Should   not   have   parsed   bad   initializer \"  )  ;", "}    catch    ( XMLStreamException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testParseSubsystemWithBadInitializer_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    operations    =    super . parse ( ModelTestUtils . readResource ( this . getClass (  )  ,     \" subsystem -  1  .  0  . xml \"  )  )  ;", "Assert . assertEquals (  1  ,    operations . size (  )  )  ;", "ModelNode   add    =    operations . get (  0  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . ADD ,    add . get ( ModelDescriptionConstants . OP )  . asString (  )  )  ;", "PathAddress   addr    =    PathAddress . pathAddress ( add . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "Assert . assertEquals (  1  ,    addr . size (  )  )  ;", "PathElement   element    =    addr . getElement (  0  )  ;", "Assert . assertEquals ( ModelDescriptionConstants . SUBSYSTEM ,    element . getKey (  )  )  ;", "Assert . assertEquals ( JacORBExtension . SUBSYSTEM _ NAME ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseSubsystem_1_0"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "super . standardSubsystemTest (  \" subsystem - ior - settings . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystemWithIORSettings"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "super . standardSubsystemTest (  \" subsystem - security - client . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystemWithSecurityClient"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "super . standardSubsystemTest (  \" subsystem - security - identity . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystemWithSecurityIdentity"], "fileName": "org.jboss.as.jacorb.JacORBSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( ADMIN _ ONLY _ HC )  . setSubsystemXmlResource (  \" subsystem - transform . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( ADMIN _ ONLY _ HC ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - jacorb :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . configureReverseControllerCheck ( ADMIN _ ONLY _ HC ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion ,    new   ModelFixer (  )     {", "@ Override", "public   ModelNode   fixModel ( ModelNode   modelNode )     {", "modelNode . get ( JacORBSubsystemDefinitions . INTEROP _ CHUNK _ RMI _ VALUETYPES . getName (  )  )  . set ( JacORBSubsystemDefinitions . INTEROP _ CHUNK _ RMI _ VALUETYPES . getDefaultValue (  )  )  ;", "return   modelNode ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     3  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP620"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  6  _  3  _  0  ,    ModelVersion . create (  1  ,     4  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP630"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     4  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP640"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( ADMIN _ ONLY _ HC )  ;", "builder . createLegacyKernelServicesBuilder ( ADMIN _ ONLY _ HC ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - jacorb :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . configureReverseControllerCheck ( ADMIN _ ONLY _ HC ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "assertNotNull ( legacyServices )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    builder . parseXmlResource (  \" subsystem - ior - settings . xml \"  )  ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( JacORBSubsystemResource . INSTANCE . getPathElement (  )  ,    IORSettingsDefinition . INSTANCE . getPathElement (  )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( JacORBSubsystemResource . INSTANCE . getPathElement (  )  ,    IORSettingsDefinition . INSTANCE . getPathElement (  )  ,    IORTransportConfigDefinition . INSTANCE . getPathElement (  )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( JacORBSubsystemResource . INSTANCE . getPathElement (  )  ,    IORSettingsDefinition . INSTANCE . getPathElement (  )  ,    IORASContextDefinition . INSTANCE . getPathElement (  )  )  ,    REJECTED _ RESOURCE )  . addFailedAttribute ( PathAddress . pathAddress ( JacORBSubsystemResource . INSTANCE . getPathElement (  )  ,    IORSettingsDefinition . INSTANCE . getPathElement (  )  ,    IORSASContextDefinition . INSTANCE . getPathElement (  )  )  ,    REJECTED _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersIORSettings"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersIORSettings ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersIORSettingsEAP620"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersIORSettings ( EAP _  6  _  3  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersIORSettingsEAP630"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( ADMIN _ ONLY _ HC )  ;", "builder . createLegacyKernelServicesBuilder ( ADMIN _ ONLY _ HC ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - jacorb :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . configureReverseControllerCheck ( ADMIN _ ONLY _ HC ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "assertNotNull ( legacyServices )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    builder . parseXmlResource (  \" subsystem - security - client . xml \"  )  ,    config )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityClient"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersSecurityClient ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityClientEAP620"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersSecurityClient ( EAP _  6  _  3  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityClientEAP630"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersSecurityClient ( EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     4  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityClientEAP640"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( ADMIN _ ONLY _ HC )  . setSubsystemXml ( readResource (  \" subsystem - security - identity . xml \"  )  )  ;", "builder . createLegacyKernelServicesBuilder ( ADMIN _ ONLY _ HC ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \"  : jboss - as - jacorb :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . configureReverseControllerCheck ( ADMIN _ ONLY _ HC ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "assertNotNull ( legacyServices )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "ModelNode   transformed    =    checkSubsystemModelTransformation ( mainServices ,    modelVersion )  . get ( ModelDescriptionConstants . SUBSYSTEM ,    JacORBExtension . SUBSYSTEM _ NAME )  ;", "Assert . assertEquals (  \" identity \"  ,    transformed . get (  \" security \"  )  . asString (  )  )  ;", "List < ModelNode >    properties    =    transformed . get ( PROPERTIES )  . asList (  )  ;", "Assert . assertEquals (  1  ,    properties . size (  )  )  ;", "Assert . assertEquals (  \" some _ value \"  ,    properties . get (  0  )  . get (  \" some _ property \"  )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityIdentity"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersSecurityIdentity ( EAP _  6  _  2  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityIdentityEAP620"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersSecurityIdentity ( EAP _  6  _  3  _  0  ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityIdentityEAP630"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformersSecurityIdentity ( EAP _  6  _  4  _  0  ,    ModelVersion . create (  1  ,     4  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformersSecurityIdentityEAP640"], "fileName": "org.jboss.as.jacorb.JacORBTransformersTestCase"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   extensionAddress    =    EMPTY _ ADDRESS . append ( MigrateOperation . OPENJDK _ EXTENSION _ ELEMENT )  ;", "OperationEntry   addEntry    =    context . getRootResourceRegistration (  )  . getOperationEntry ( extensionAddress ,    ModelDescriptionConstants . ADD )  ;", "final   ModelNode   addOperation    =    Util . createAddOperation ( extensionAddress )  ;", "if    ( describe )     {", "migrateOperations . put ( extensionAddress ,    addOperation )  ;", "} else    {", "context . addStep ( context . getResult (  )  . get ( extensionAddress . toString (  )  )  ,    addOperation ,    addEntry . getOperationHandler (  )  ,    Stage . MODEL )  ;", "}", "}", "METHOD_END"], "methodName": ["addOpenjdkExtension"], "fileName": "org.jboss.as.jacorb.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   operation    =    Util . createAddOperation ( address )  ;", "for    ( final   Property   property    :    model . asPropertyList (  )  )     {", "if    ( property . getValue (  )  . isDefined (  )  )     {", "operation . get ( property . getName (  )  )  . set ( property . getValue (  )  )  ;", "}", "}", "ms . put ( address ,    operation )  ;", "}", "METHOD_END"], "methodName": ["addOpenjdkSubsystem"], "fileName": "org.jboss.as.jacorb.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    transformedExpressionProperties    =    new   LinkedList <  >  (  )  ;", "for    ( Property   property    :    legacyModel . asPropertyList (  )  )     {", "if    (  (  ( property . getValue (  )  . getType (  )  )     =  =     ( EXPRESSION )  )     &  &     (  . TRANSFORMED _ PROPERTIES . contains ( property . getName (  )  )  )  )     {", "transformedExpressionProperties . add ( property . getName (  )  )  ;", "}", "}", "if    (  !  ( transformedExpressionProperties . isEmpty (  )  )  )     {", "warnings . add ( JacORBLogger . ROOT _ LOGGER . expressionMigrationWarning ( transformedExpressionProperties . toString (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkPropertiesWithExpression"], "fileName": "org.jboss.as.jacorb.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   Map < PathAddress ,    ModelNode >    result    =    new   LinkedHashMap <  >  (  )  ;", "MultistepUtil . recordSteps ( context ,    migrations ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["migrateSubsystems"], "fileName": "org.jboss.as.jacorb.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( MigrateOperation . MIGRATE ,    resourceDescriptionResolver )  . setReplyParameters ( MigrateOperation . MIGRATION _ WARNINGS _ ATTR ,    MigrateOperation . MIGRATION _ ERROR _ ATTR )  . build (  )  ,    new   MigrateOperation ( false )  )  ;", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( MigrateOperation . DESCRIBE _ MIGRATION ,    resourceDescriptionResolver )  . setReplyParameters ( MigrateOperation . MIGRATION _ WARNINGS _ ATTR ,    MigrateOperation . MIGRATION _ ERROR _ ATTR )  . setReadOnly (  )  . build (  )  ,    new   MigrateOperation ( true )  )  ;", "}", "METHOD_END"], "methodName": ["registerOperation"], "fileName": "org.jboss.as.jacorb.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   removeLegacySubsystemOperation    =    Util . createRemoveOperation ( address )  ;", "migrateOperations . put ( address ,    removeLegacySubsystemOperation )  ;", "if    ( standalone )     {", "removeLegacySubsystemOperation    =    createRemoveOperation (  . JACORB _ EXTENSION )  ;", "migrateOperations . put (  . JACORB _ EXTENSION ,    removeLegacySubsystemOperation )  ;", "}", "}", "METHOD_END"], "methodName": ["removeJacorbSubsystem"], "fileName": "org.jboss.as.jacorb.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "return   SSLConfigValue . MAP . get ( value )  ;", "}", "METHOD_END"], "methodName": ["fromValue"], "fileName": "org.jboss.as.jacorb.SSLConfigValue"}, {"methodBody": ["METHOD_START", "{", "return   this . iiopValue ;", "}", "METHOD_END"], "methodName": ["getIIOPValue"], "fileName": "org.jboss.as.jacorb.SSLConfigValue"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Property   category    :    legacyValue . get ( JacORBSubsystemConstants . DEFAULT )  . get ( JacORBSubsystemConstants . SETTING )  . asPropertyList (  )  )     {", "for    ( final   Property   property    :    category . getValue (  )  . asPropertyList (  )  )     {", "model . get ( property . getName (  )  )  . set ( property . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["transformIorSettings"], "fileName": "org.jboss.as.jacorb.TransformUtils"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   model    =    new   ModelNode (  )  ;", "for    ( Property   property    :    legacyModel . asPropertyList (  )  )     {", "String   name    =    property . getName (  )  ;", "ModelNode   legacyValue    =    property . getValue (  )  ;", "if    ( legacyValue . isDefined (  )  )     {", "if    ( name . equals ( JacORBSubsystemConstants . IOR _ SETTINGS )  )     {", ". transformIorSettings ( model ,    legacyValue )  ;", "continue ;", "}", "final   boolean   expression ;", "final   String   expressionVariable ;", "if    (  ( legacyValue . getType (  )  )     =  =     ( ModelType . EXPRESSION )  )     {", "expression    =    true ;", "final   Matcher   matcher    =    Pattern . compile (  \"  \\  \\ A \\  \\  $  \\  \\  {  (  .  *  )  :  (  .  *  )  \\  \\  }  \\  \\ Z \"  )  . matcher ( legacyValue . asExpression (  )  . getExpressionString (  )  )  ;", "if    ( matcher . find (  )  )     {", "expressionVariable    =    matcher . group (  1  )  ;", "String   abc    =    matcher . group (  2  )  ;", "legacyValue    =    new   ModelNode ( abc )  ;", "} else    {", "model . get ( name )  . set ( legacyValue )  ;", "continue ;", "}", "} else    {", "expression    =    false ;", "expressionVariable    =    null ;", "}", "ModelNode   value ;", "switch    ( name )     {", "case   JacORBSubsystemConstants . ORB _ GIOP _ MINOR _ VERSION    :", "name    =    Constants . ORB _ GIOP _ VERSION ;", "value    =    new   ModelNode ( new   StringBuilder (  )  . append (  \"  1  .  \"  )  . append ( legacyValue . asString (  )  )  . toString (  )  )  ;", "break ;", "case   JacORBSubsystemConstants . ORB _ INIT _ TRANSACTIONS    :", "if    ( legacyValue . asString (  )  . equals ( JacORBSubsystemConstants . ON )  )     {", "value    =    new   ModelNode ( Constants . FULL )  ;", "} else", "if    ( legacyValue . asString (  )  . equals ( JacORBSubsystemConstants . OFF )  )     {", "value    =    new   ModelNode ( Constants . NONE )  ;", "} else    {", "value    =    legacyValue ;", "}", "break ;", "case   JacORBSubsystemConstants . ORB _ INIT _ SECURITY    :", "if    ( legacyValue . asString (  )  . equals ( JacORBSubsystemConstants . OFF )  )     {", "value    =    new   ModelNode ( Constants . NONE )  ;", "} else    {", "value    =    legacyValue ;", "}", "break ;", "case   JacORBSubsystemConstants . SECURITY _ SUPPORT _ SSL    :", "case   JacORBSubsystemConstants . SECURITY _ ADD _ COMP _ VIA _ INTERCEPTOR    :", "case   JacORBSubsystemConstants . NAMING _ EXPORT _ CORBALOC    :", "case   JacORBSubsystemConstants . INTEROP _ IONA    :", "if    ( legacyValue . asString (  )  . equals ( JacORBSubsystemConstants . ON )  )     {", "value    =    new   ModelNode ( true )  ;", "} else    {", "value    =    new   ModelNode ( false )  ;", "}", "break ;", "default    :", "value    =    legacyValue ;", "}", "if    (  !  ( value . asString (  )  . equals ( JacORBSubsystemConstants . OFF )  )  )     {", "if    ( expression )     {", "String   newExpression    =     \"  $  {  \"     +    expressionVariable ;", "if    ( expressionVariable    !  =    null )     {", "newExpression    +  =     \"  :  \"     +     ( value . asString (  )  )  ;", "}", "newExpression    +  =     \"  }  \"  ;", "value    =    new   ModelNode ( new   ValueExpression ( newExpression )  )  ;", "}", "model . get ( name )  . set ( value )  ;", "}", "}", "}", "return   model ;", "}", "METHOD_END"], "methodName": ["transformModel"], "fileName": "org.jboss.as.jacorb.TransformUtils"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    propertiesToReject    =    new   LinkedList <  >  (  )  ;", "( final   AttributeDefinition   attribute    :    JacORBSubsystemDefinitions . ON _ OFF _ ATTRIBUTES _ TO _ REJECT )     {", "if    (  ( model . hasDefined ( attribute . getName (  )  )  )     &  &     ( model . get ( attribute . getName (  )  )  . equals ( JacORBSubsystemDefinitions . DEFAULT _ ENABLED _ PROPERTY )  )  )     {", "propertiesToReject . add ( attribute . getName (  )  )  ;", "}", "}", "( final   AttributeDefinition   attribute    :    JacORBSubsystemDefinitions . ATTRIBUTES _ TO _ REJECT )     {", "if    ( model . hasDefined ( attribute . getName (  )  )  )     {", "propertiesToReject . add ( attribute . getName (  )  )  ;", "}", "}", "return   propertiesToReject ;", "}", "METHOD_END"], "methodName": ["validateDeprecatedProperites"], "fileName": "org.jboss.as.jacorb.TransformUtils"}, {"methodBody": ["METHOD_START", "{", "ModelNode   legacyModel    =    new   ModelNode (  )  ;", "legacyModel . get (  \" name \"  )  . set ( new   ValueExpression (  \"  $  { name }  \"  )  )  ;", "legacyModel . get (  \" giop - minor - version \"  )  . set ( new   ValueExpression (  \"  $  { giop . minor . version :  2  }  \"  )  )  ;", "ModelNode   newModel    =     . transformModel ( legacyModel )  ;", "Assert . assertTrue ( newModel . get (  \" name \"  )  . equals ( new   ModelNode ( new   ValueExpression (  \"  $  { name }  \"  )  )  )  )  ;", "Assert . assertTrue ( newModel . get (  \" giop - version \"  )  . equals ( new   ModelNode ( new   ValueExpression (  \"  $  { giop . minor . version :  1  .  2  }  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.jboss.as.jacorb.TransformUtilsTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    new   ModelNode (  )  ;", "model . get (  \" queue - min \"  )  . set (  5  )  ;", "List < String >    result    =     . validateDeprecatedProperites ( model )  ;", "Assert . assertFalse ( result . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectedAttribute"], "fileName": "org.jboss.as.jacorb.TransformUtilsTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    new   ModelNode (  )  ;", "model . get (  \" monitoring \"  )  . set (  \" on \"  )  ;", "List < String >    result    =     . validateDeprecatedProperites ( model )  ;", "Assert . assertFalse ( result . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectedOnOffAttribute"], "fileName": "org.jboss.as.jacorb.TransformUtilsTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   model    =    new   ModelNode (  )  ;", "model . get (  \" monitoring \"  )  . set (  \" off \"  )  ;", "List < String >    result    =     . validateDeprecatedProperites ( model )  ;", "Assert . assertTrue ( result . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectedOnOffAttributeTurnedOff"], "fileName": "org.jboss.as.jacorb.TransformUtilsTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   legacyModel    =    new   ModelNode (  )  ;", "legacyModel . get (  \" name \"  )  . set (  \" test \"  )  ;", "legacyModel . get (  \" giop - minor - version \"  )  . set (  2  )  ;", "legacyModel . get (  \" transactions \"  )  . set (  \" on \"  )  ;", "legacyModel . get (  \" security \"  )  . set (  \" off \"  )  ;", "legacyModel . get (  \" export - corbaloc \"  )  . set (  \" on \"  )  ;", "legacyModel . get (  \" support - ssl \"  )  . set (  \" off \"  )  ;", "legacyModel . get (  \" sun \"  )  . set (  \" on \"  )  ;", "legacyModel . get (  \" comet \"  )  . set (  \" off \"  )  ;", "legacyModel . get (  \" iona \"  )  . set (  \" on \"  )  ;", "ModelNode   newModel    =     . transformModel ( legacyModel )  ;", "Assert . assertTrue ( newModel . get (  \" name \"  )  . equals ( new   ModelNode (  \" test \"  )  )  )  ;", "Assert . assertTrue ( newModel . get (  \" giop - version \"  )  . equals ( new   ModelNode (  \"  1  .  2  \"  )  )  )  ;", "Assert . assertTrue ( newModel . get (  \" security \"  )  . equals ( new   ModelNode (  \" none \"  )  )  )  ;", "Assert . assertTrue ( newModel . get (  \" transactions \"  )  . equals ( new   ModelNode (  \" full \"  )  )  )  ;", "Assert . assertTrue ( newModel . get (  \" export - corbaloc \"  )  . equals ( new   ModelNode ( true )  )  )  ;", "Assert . assertTrue ( newModel . get (  \" support - ssl \"  )  . equals ( new   ModelNode ( false )  )  )  ;", "Assert . assertTrue ( newModel . get (  \" iona \"  )  . equals ( new   ModelNode ( true )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformation"], "fileName": "org.jboss.as.jacorb.TransformUtilsTestCase"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder ( JAXRExtension . SUBSYSTEM _ NAME )  ;", "for    ( String   kp    :    keyPrefix )     {", "prefix . append (  '  .  '  )  . append ( kp )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,    JAXRExtension . RESOURCE _ NAME ,    JAXRExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResolver"], "fileName": "org.jboss.as.jaxr.extension.JAXRExtension"}, {"methodBody": ["METHOD_START", "{", "String   jndiName    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   JAXRConstants . Attribute   attribute    =    JAXRConstants . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   JNDI _ NAME    :", "{", "jndiName    =    attrValue ;", "RootResource . CONNECTION _ FACTORY _ ATTRIBUTE . parseAndSetParameter ( jndiName ,    addOp ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( jndiName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( JAXRConstants . Attribute . JNDI _ NAME )  )  ;", "}", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseBinding1_0"], "fileName": "org.jboss.as.jaxr.extension.JAXRSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   jndiName    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   JAXRConstants . Attribute   attribute    =    JAXRConstants . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   JNDI _ NAME    :", "{", "jndiName    =    attrValue ;", "RootResource . CONNECTION _ FACTORY _ ATTRIBUTE . parseAndSetParameter ( jndiName ,    addOp ,    reader )  ;", "break ;", "}", "case   CLASS    :", "{", "RootResource . CONNECTION _ FACTORY _ IMPL _ ATTRIBUTE . parseAndSetParameter ( attrValue ,    addOp ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( jndiName    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( JAXRConstants . Attribute . JNDI _ NAME )  )  ;", "}", "requireNoContent ( reader )  ;", "}", "METHOD_END"], "methodName": ["parseBinding1_1"], "fileName": "org.jboss.as.jaxr.extension.JAXRSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    result    =    new   ArrayList < ModelNode >  (  )  ;", "Set < Constants . Attribute >    required    =    EnumSet . of ( Constants . Attribute . PUBLISH _ URL ,    Constants . Attribute . QUERY _ URL )  ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   Constants . Attribute   attribute    =    Constants . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   PUBLISH _ URL    :", "{", "ModelNode   propOp    =    Util . createAddOperation ( parent . append ( PROPERTY ,     \" lifeCycleManagerURL \"  )  )  ;", "PropertyDefinition . VALUE . parseAndSetParameter ( attrValue ,    propOp ,    reader )  ;", "result . add ( propOp )  ;", "break ;", "}", "case   QUERY _ URL    :", "{", "ModelNode   propOp    =    Util . createAddOperation ( parent . append ( PROPERTY ,     \" queryManagerURL \"  )  )  ;", "PropertyDefinition . VALUE . parseAndSetParameter ( attrValue ,    propOp ,    reader )  ;", "result . add ( propOp )  ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  ( required . size (  )  )     >     0  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "requireNoContent ( reader )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["parseJuddiServer"], "fileName": "org.jboss.as.jaxr.extension.JAXRSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "List < ModelNode >    result    =    new   ArrayList < ModelNode >  (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Constants . Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case    _  1  _  1     :", "{", "final   Constants . Element   element    =    Constants . Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "{", "ModelNode   propNode    =    parseProperty ( reader ,    address )  ;", "result . add ( propNode )  ;", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseProperties"], "fileName": "org.jboss.as.jaxr.extension.JAXRSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "String   value    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   Constants . Attribute   attribute    =    Constants . Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    attrValue ;", "break ;", "}", "case   VALUE    :", "{", "value    =    attrValue ;", "break ;", "}", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Constants . Attribute . NAME )  )  ;", "}", "if    ( value    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Constants . Attribute . VALUE )  )  ;", "}", "requireNoContent ( reader )  ;", "final   PathAddress   address    =    parent . append ( PROPERTY ,    name )  ;", "ModelNode   propNode    =    Util . createAddOperation ( address )  ;", "propNode . get ( VALUE )  . set ( value )  ;", "return   propNode ;", "}", "METHOD_END"], "methodName": ["parseProperty"], "fileName": "org.jboss.as.jaxr.extension.JAXRSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( JAXRExtension . SUBSYSTEM _ PATH )  ;", "final   ModelNode   addOp    =    Util . createAddOperation ( address )  ;", "operations . add ( addOp )  ;", "List < ModelNode >    propertiesOps    =    null ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( JAXRConstants . Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   JAXR _  1  _  0     :", "{", "final   JAXRConstants . Element   element    =    JAXRConstants . Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONNECTION _ FACTORY    :", "{", "parseBinding 1  _  0  ( reader ,    addOp )  ;", "break ;", "}", "case   JUDDI _ SERVER    :", "{", "propertiesOps    =    parseJuddiServer ( reader ,    address )  ;", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "if    ( propertiesOps    !  =    null )     {", "operations . addAll ( propertiesOps )  ;", "}", "}", "METHOD_END"], "methodName": ["readElement1_0"], "fileName": "org.jboss.as.jaxr.extension.JAXRSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( JAXRExtension . SUBSYSTEM _ PATH )  ;", "final   ModelNode   addOp    =    Util . createAddOperation ( address )  ;", "operations . add ( addOp )  ;", "List < ModelNode >    propertiesOps    =    null ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( JAXRConstants . Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   JAXR _  1  _  1     :", "{", "final   JAXRConstants . Element   element    =    JAXRConstants . Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONNECTION _ FACTORY    :", "{", "parseBinding 1  _  1  ( reader ,    addOp )  ;", "break ;", "}", "case   PROPERTIES    :", "{", "propertiesOps    =    parseProperties ( reader ,    address )  ;", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "}", "if    ( propertiesOps    !  =    null )     {", "operations . addAll ( propertiesOps )  ;", "}", "}", "METHOD_END"], "methodName": ["readElement1_1"], "fileName": "org.jboss.as.jaxr.extension.JAXRSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" xsd 1  _  1 full . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFullConfig"], "fileName": "org.jboss.as.jaxr.extension.JaxrSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" xsd 1  _  1 expressions . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testFullExpressions"], "fileName": "org.jboss.as.jaxr.extension.JaxrSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" xsd 1  _  0  . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSubsystem1_0"], "fileName": "org.jboss.as.jaxr.extension.JaxrSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   deadLetterAddress    =    CommonAttributes . DEAD _ LETTER _ ADDRESS . resolveModelAttribute ( context ,    model )  ;", "if    (  !  (  . findMatchingResource ( deadLetterAddress ,    hornetqServer )  )  )     {", "MessagingLogger . ROOT _ LOGGER . noMatchingDeadLetterAddress ( deadLetterAddress . asString (  )  ,    addressSetting )  ;", "}", "}", "METHOD_END"], "methodName": ["checkDeadLetterAddress"], "fileName": "org.jboss.as.messaging.AddressSettingsValidator"}, {"methodBody": ["METHOD_START", "{", "ModelNode   expiryAddress    =    CommonAttributes . EXPIRY _ ADDRESS . resolveModelAttribute ( context ,    model )  ;", "if    (  !  (  . findMatchingResource ( expiryAddress ,    hornetqServer )  )  )     {", "MessagingLogger . ROOT _ LOGGER . noMatchingExpiryAddress ( expiryAddress . asString (  )  ,    addressSetting )  ;", "}", "}", "METHOD_END"], "methodName": ["checkExpiryAddress"], "fileName": "org.jboss.as.messaging.AddressSettingsValidator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( addressNode . isDefined (  )  )  )     {", "return   true ;", "}", "final   String   address    =    addressNode . asString (  )  ;", "final   String   addressPrefix ;", "final   String   childType ;", "if    ( address . startsWith (  . JMS _ QUEUE _ ADDRESS _ PREFIX )  )     {", "childType    =    CommonAttributes . JMS _ QUEUE ;", "addressPrefix    =     . JMS _ QUEUE _ ADDRESS _ PREFIX ;", "} else", "if    ( address . startsWith (  . JMS _ TOPIC _ ADDRESS _ PREFIX )  )     {", "childType    =    CommonAttributes . JMS _ TOPIC ;", "addressPrefix    =     . JMS _ TOPIC _ ADDRESS _ PREFIX ;", "} else    {", "childType    =    CommonAttributes . CORE _ QUEUE ;", "addressPrefix    =     \"  \"  ;", "}", "for    ( String   childName    :    hornetqServer . getChildrenNames ( childType )  )     {", "if    ( address . equals (  ( addressPrefix    +    childName )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["findMatchingResource"], "fileName": "org.jboss.as.messaging.AddressSettingsValidator"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeDefinitions . containsKey ( attributeName )  )     {", "AttributeDefinition   attr    =    attributeDefinitions . get ( attributeName )  ;", "final   Resource   resource    =    context . readResource ( PathAddress . EMPTY _ ADDRESS )  ;", "if    ( alternativeMustBeSet )     {", "if    (  !  ( attr . has ( resource . getModel (  )  )  )  )     {", "throw   new   OperationFailedException ( MessagingLogger . ROOT _ LOGGER . undefineAttributeWithout ( attributeName )  )  ;", "}", "} else    {", "if    ( attr . has ( resource . getModel (  )  )  )     {", "throw   new   OperationFailedException ( MessagingLogger . ROOT _ LOGGER . altAttributeAlreadyDefined ( attributeName )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkAlternativeAttribute"], "fileName": "org.jboss.as.messaging.AlternativeAttributeCheckHandler"}, {"methodBody": ["METHOD_START", "{", "boolean   hasAttr 1     =    operation . hasDefined ( attr 1  )  ;", "boolean   hasAttr 2     =    operation . hasDefined ( attr 2  )  ;", "if    (  (  (  ! hasAttr 1  )     &  &     (  ! hasAttr 2  )  )     &  &     (  ! acceptNone )  )     {", "throw   new   OperationFailedException ( MLogger . ROOT _ LOGGER . invalidOperationParameters ( attr 1  ,    attr 2  )  )  ;", "} else", "if    ( hasAttr 1     &  &    hasAttr 2  )     {", "throw   new   OperationFailedException ( MLogger . ROOT _ LOGGER . cannotIncludeOperationParameters ( attr 1  ,    attr 2  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkAlternatives"], "fileName": "org.jboss.as.messaging.AlternativeAttributeCheckHandler"}, {"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.messaging.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   definition ;", "}", "METHOD_END"], "methodName": ["getDefinition"], "fileName": "org.jboss.as.messaging.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.messaging.Attribute"}, {"methodBody": ["METHOD_START", "{", "PathAddress   hornetqServer    =    context . getCurrentAddress (  )  . getParent (  )  ;", "Resource   hornetQServerResource    =    context . readResourceFromRoot ( hornetqServer ,    false )  ;", "Set < String >    availableConnectors    =    new   HashSet < String >  (  )  ;", "availableConnectors . addAll ( hornetQServerResource . getChildrenNames ( CommonAttributes . HTTP _ CONNECTOR )  )  ;", "availableConnectors . addAll ( hornetQServerResource . getChildrenNames ( CommonAttributes . IN _ VM _ CONNECTOR )  )  ;", "availableConnectors . addAll ( hornetQServerResource . getChildrenNames ( CommonAttributes . REMOTE _ CONNECTOR )  )  ;", "availableConnectors . addAll ( hornetQServerResource . getChildrenNames ( CommonAttributes . CONNECTOR )  )  ;", "return   availableConnectors ;", "}", "METHOD_END"], "methodName": ["getAvailableConnectors"], "fileName": "org.jboss.as.messaging.BroadcastGroupDefinition"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    availableConnectors    =    BroadcastGroupDefinition . getAvailableConnectors ( context ,    operation )  ;", "final   List < ModelNode >    operationAddress    =    operation . get ( ADDRESS )  . asList (  )  ;", "final   String   broadCastGroup    =    operationAddress . get (  (  ( operationAddress . size (  )  )     -     1  )  )  . get ( CommonAttributes . BROADCAST _ GROUP )  . asString (  )  ;", "for    ( ModelNode   connectorRef    :    connectorRefs . asList (  )  )     {", "final   String   connectorName    =    connectorRef . asString (  )  ;", "if    (  !  ( availableConnectors . contains ( connectorName )  )  )     {", "throw   MessagingLogger . ROOT _ LOGGER . wrongConnectorRefInBroadCastGroup ( broadCastGroup ,    connectorName ,    availableConnectors )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateConnectors"], "fileName": "org.jboss.as.messaging.BroadcastGroupDefinition"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( attributeDefinitions )  ;", "}", "METHOD_END"], "methodName": ["getAttributeDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . CHECK _ PERIOD )  ;", "result . put (  \" default \"  ,    CommonAttributes . CHECK _ PERIOD )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getCheckPeriodDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . CONFIRMATION _ WINDOW _ SIZE )  ;", "result . put (  \" bridge \"  ,    CommonAttributes . BRIDGE _ CONFIRMATION _ WINDOW _ SIZE )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getConfirmationWindowSizeDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" source \"  ,    JMSBridgeDefinition . SOURCE _ CONNECTION _ FACTORY )  ;", "result . put (  \" target \"  ,    JMSBridgeDefinition . TARGET _ CONNECTION _ FACTORY )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getConnectionFactoryDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . CONNECTION _ TTL )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . CONNECTION _ TTL )  ;", "result . put (  \" default \"  ,    CommonAttributes . CONNECTION _ TTL )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getConnectionTTLDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" simple \"  ,    ClusterConnectionDefinition . CONNECTOR _ REF )  ;", "result . put (  \" broadcast - group \"  ,    BroadcastGroupDefinition . CONNECTOR _ REFS )  ;", "result . put (  \" bridge \"  ,    BridgeDefinition . CONNECTOR _ REFS )  ;", "result . put (  \" cluster - connection \"  ,    ClusterConnectionDefinition . CONNECTOR _ REFS )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getConnectorRefDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" source \"  ,    JMSBridgeDefinition . SOURCE _ CONTEXT )  ;", "result . put (  \" target \"  ,    JMSBridgeDefinition . TARGET _ CONTEXT )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getContextDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "return   definition ;", "}", "METHOD_END"], "methodName": ["getDefinition"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "return   definitions . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getDefinition"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" source \"  ,    JMSBridgeDefinition . SOURCE _ DESTINATION )  ;", "result . put (  \" target \"  ,    JMSBridgeDefinition . TARGET _ DESTINATION )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getDestinationDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . USE _ DUPLICATE _ DETECTION )  ;", "result . put (  \" bridge \"  ,    BridgeDefinition . USE _ DUPLICATE _ DETECTION )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getDuplicateDetectionDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" divert \"  ,    DivertDefinition . FORWARDING _ ADDRESS )  ;", "result . put (  \" bridge \"  ,    BridgeDefinition . FORWARDING _ ADDRESS )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getForwardingAddressDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" bridge \"  ,    BridgeDefinition . INITIAL _ CONNECT _ ATTEMPTS )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . INITIAL _ CONNECT _ ATTEMPTS )  ;", "result . put (  \" pooled \"  ,    ConnectionFactoryAttributes . Pooled . INITIAL _ CONNECT _ ATTEMPTS )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getInitialConnectAttemptsDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . MAX _ RETRY _ INTERVAL )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . MAX _ RETRY _ INTERVAL )  ;", "result . put (  \" default \"  ,    CommonAttributes . MAX _ RETRY _ INTERVAL )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getMaxRetryIntervalDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . MIN _ LARGE _ MESSAGE _ SIZE )  ;", "result . put (  \" default \"  ,    CommonAttributes . MIN _ LARGE _ MESSAGE _ SIZE )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getMinLargeMessageSizeDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" source \"  ,    JMSBridgeDefinition . SOURCE _ PASSWORD )  ;", "result . put (  \" target \"  ,    JMSBridgeDefinition . TARGET _ PASSWORD )  ;", "result . put (  \" default \"  ,    BridgeDefinition . PASSWORD )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getPasswordDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . RECONNECT _ ATTEMPTS )  ;", "result . put (  \" pooled - connection \"  ,    ConnectionFactoryAttributes . Pooled . RECONNECT _ ATTEMPTS )  ;", "result . put (  \" bridge \"  ,    BridgeDefinition . RECONNECT _ ATTEMPTS )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . RECONNECT _ ATTEMPTS )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getReconnectAttemptsDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . RETRY _ INTERVAL )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . RETRY _ INTERVAL )  ;", "result . put (  \" default \"  ,    CommonAttributes . RETRY _ INTERVAL )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getRetryIntervalDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" cluster \"  ,    ClusterConnectionDefinition . RETRY _ INTERVAL _ MULTIPLIER )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . RETRY _ INTERVAL _ MULTIPLIER )  ;", "result . put (  \" default \"  ,    CommonAttributes . RETRY _ INTERVAL _ MULTIPLIER )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getRetryIntervalMultiplierDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" server \"  ,    CommonAttributes . SCHEDULED _ THREAD _ POOL _ MAX _ SIZE )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . SCHEDULED _ THREAD _ POOL _ MAX _ SIZE )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getScheduledThreadPoolDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" server \"  ,    CommonAttributes . THREAD _ POOL _ MAX _ SIZE )  ;", "result . put (  \" connection \"  ,    ConnectionFactoryAttributes . Common . THREAD _ POOL _ MAX _ SIZE )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getThreadPoolDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    AttributeDefinition >    result    =    new   HashMap < String ,    AttributeDefinition >  (  )  ;", "result . put (  \" source \"  ,    JMSBridgeDefinition . SOURCE _ USER )  ;", "result . put (  \" target \"  ,    JMSBridgeDefinition . TARGET _ USER )  ;", "result . put (  \" default \"  ,    BridgeDefinition . USER )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getUserDefinitions"], "fileName": "org.jboss.as.messaging.Element"}, {"methodBody": ["METHOD_START", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["handleUnknownBridgeAttribute"], "fileName": "org.jboss.as.messaging.Messaging12SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "String   name    =    reader . getAttributeValue (  0  )  ;", "ModelNode   bridgeAdd    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . BRIDGE ,    name )  )  ;", "EnumSet < Element >    required    =    EnumSet . of ( Element . QUEUE _ NAME )  ;", "Set < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( seen . add ( element )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "required . remove ( element )  ;", "switch    ( element )     {", "case   QUEUE _ NAME    :", "case   HA    :", "case   TRANSFORMER _ CLASS _ NAME    :", "case   USER    :", "case   PASSWORD    :", "Messaging . handleElementText ( reader ,    element ,    bridgeAdd )  ;", "break ;", "case   FILTER    :", "{", "String   string    =    readStringAttributeElement ( reader ,    CommonAttributes . STRING )  ;", "CommonAttributes . FILTER . parseAndSetParameter ( string ,    bridgeAdd ,    reader )  ;", "break ;", "}", "case   CHECK _ PERIOD    :", "case   CONNECTION _ TTL    :", "case   MAX _ RETRY _ INTERVAL    :", "case   MIN _ LARGE _ MESSAGE _ SIZE    :", "case   RETRY _ INTERVAL    :", "case   RETRY _ INTERVAL _ MULTIPLIER    :", "Messaging . handleElementText ( reader ,    element ,     \" default \"  ,    bridgeAdd )  ;", "break ;", "case   CONFIRMATION _ WINDOW _ SIZE    :", "case   FORWARDING _ ADDRESS    :", "case   RECONNECT _ ATTEMPTS    :", "case   USE _ DUPLICATE _ DETECTION    :", "Messaging . handleElementText ( reader ,    element ,     \" bridge \"  ,    bridgeAdd )  ;", "break ;", "case   STATIC _ CONNECTORS    :", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . STATIC _ CONNECTORS ,    Element . DISCOVERY _ GROUP _ REF )  ;", "processStaticConnectors ( reader ,    bridgeAdd ,    false )  ;", "break ;", "case   DISCOVERY _ GROUP _ REF    :", "{", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . DISCOVERY _ GROUP _ REF ,    Element . STATIC _ CONNECTORS )  ;", "final   String   groupRef    =    readStringAttributeElement ( reader ,    BridgeDefinition . DISCOVERY _ GROUP _ NAME . getXmlName (  )  )  ;", "BridgeDefinition . DISCOVERY _ GROUP _ NAME . parseAndSetParameter ( groupRef ,    bridgeAdd ,    reader )  ;", "break ;", "}", "case   FAILOVER _ ON _ SERVER _ SHUTDOWN    :", "{", "MessagingLogger . ROOT _ LOGGER . deprecatedXMLElement ( element . toString (  )  )  ;", "Messaging . handleElementText ( reader ,    element ,    bridgeAdd )  ;", "break ;", "}", "default    :", "{", "handleUnknownBridgeAttribute ( reader ,    element ,    bridgeAdd )  ;", "}", "}", "}", "Messaging . checkOnlyOneOfElements ( reader ,    seen ,    Element . STATIC _ CONNECTORS ,    Element . DISCOVERY _ GROUP _ REF )  ;", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "updates . add ( bridgeAdd )  ;", "}", "METHOD_END"], "methodName": ["processBridge"], "fileName": "org.jboss.as.messaging.Messaging12SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( seen . contains ( element 1  )  )     &  &     ( seen . contains ( element 2  )  )  )     {", "throw   new   XMLStreamException ( Logger . ROOT _ LOGGER . onlyOneRequired ( element 1  . getLocalName (  )  ,    element 2  . getLocalName (  )  )  ,    reader . getLocation (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNotBothElements"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition   attributeDefinition    =    element . getDefinition ( modelName )  ;", "final   String   value    =    readStringAttributeElement ( reader ,    attributeName )  ;", "if    ( attributeDefinition   instanceof   SimpleAttributeDefinition )     {", "(  ( SimpleAttributeDefinition )     ( attributeDefinition )  )  . parseAndSetParameter ( value ,    node ,    reader )  ;", "} else", "if    ( attributeDefinition   instanceof   controller . ListAttributeDefinition )     {", "(  ( controller . ListAttributeDefinition )     ( attributeDefinition )  )  . parseAndAddParameterElement ( value ,    node ,    reader )  ;", "}", "}", "METHOD_END"], "methodName": ["handleSingleAttribute"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "switch    ( element )     {", "case   CALL _ FAILOVER _ TIMEOUT    :", "case   COMPRESS _ LARGE _ MESSAGES    :", "Messaging . handleElementText ( reader ,    element ,    connectionFactory )  ;", "break ;", "case   USE _ AUTO _ RECOVERY    :", "case   INITIAL _ MESSAGE _ PACKET _ SIZE    :", "if    (  ! pooled )     {", "throw   unexpectedElement ( reader )  ;", "}", "Messaging . handleElementText ( reader ,    element ,    connectionFactory )  ;", "break ;", "case   INITIAL _ CONNECT _ ATTEMPTS    :", "if    (  ! pooled )     {", "throw   unexpectedElement ( reader )  ;", "}", "Messaging . handleElementText ( reader ,    element ,     \" pooled \"  ,    connectionFactory )  ;", "break ;", "default    :", "{", "super . handleUnknownConnectionFactoryAttribute ( reader ,    element ,    connectionFactory ,    pooled )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleUnknownConnectionFactoryAttribute"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PROPERTY    :", "int   count    =    reader . getAttributeCount (  )  ;", "String   key    =    null ;", "String   value    =    null ;", "for    ( int   n    =     0  ;    n    <    count ;    n +  +  )     {", "String   attrName    =    reader . getAttributeLocalName ( n )  ;", "Attribute   attribute    =    Attribute . forName ( attrName )  ;", "switch    ( attribute )     {", "case   KEY    :", "key    =    reader . getAttributeValue ( n )  ;", "break ;", "case   VALUE    :", "value    =    reader . getAttributeValue ( n )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    n )  ;", "}", "}", "context . get ( key )  . set ( value )  ;", "Utils . requireNoContent ( reader )  ;", "break ;", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processContext"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Namespace   schemaVer    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "switch    ( schemaVer )     {", "case   MESSAGING _  1  _  0     :", "case   UNKNOWN    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "default    :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   HORNETQ _ SERVER    :", "processHornetQServer ( reader ,    sAddress ,    list ,    schemaVer )  ;", "break ;", "case   JMS _ BRIDGE    :", "processJmsBridge ( reader ,    sAddress ,    list )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processHornetQServers"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   bridgeName    =    null ;", "String   moduleName    =    null ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   n    =     0  ;    n    <    count ;    n +  +  )     {", "String   attrName    =    reader . getAttributeLocalName ( n )  ;", "Attribute   attribute    =    Attribute . forName ( attrName )  ;", "switch    ( attribute )     {", "case   NAME    :", "bridgeName    =    reader . getAttributeValue ( n )  ;", "break ;", "case   MODULE    :", "moduleName    =    reader . getAttributeValue ( n )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    n )  ;", "}", "}", "if    (  ( bridgeName    =  =    null )     |  |     (  ( bridgeName . length (  )  )     =  =     0  )  )     {", "bridgeName    =    CommonAttributes . DEFAULT ;", "}", "final   ModelNode   address    =    subsystemAddress . clone (  )  ;", "address . add ( CommonAttributes . JMS _ BRIDGE ,    bridgeName )  ;", "address . protect (  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "list . add ( operation )  ;", "if    (  ( moduleName    !  =    null )     &  &     (  ( moduleName . length (  )  )     >     0  )  )     {", "JMSBridgeDefinition . MODULE . parseAndSetParameter ( moduleName ,    operation ,    reader )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   SOURCE    :", "case   TARGET    :", "processJmsBridgeResource ( reader ,    operation ,    element . getLocalName (  )  )  ;", "break ;", "case   QUALITY _ OF _ SERVICE    :", "case   FAILURE _ RETRY _ INTERVAL    :", "case   MAX _ RETRIES    :", "case   MAX _ BATCH _ SIZE    :", "case   MAX _ BATCH _ TIME    :", "case   SUBSCRIPTION _ NAME    :", "case   CLIENT _ ID    :", "case   ADD _ MESSAGE _ ID _ IN _ HEADER    :", "Messaging . handleElementText ( reader ,    element ,    operation )  ;", "break ;", "case   SELECTOR    :", "requireSingleAttribute ( reader ,    CommonAttributes . STRING )  ;", "final   String   selector    =    readStringAttributeElement ( reader ,    CommonAttributes . STRING )  ;", "CommonAttributes . SELECTOR . parseAndSetParameter ( selector ,    operation ,    reader )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processJmsBridge"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   USER    :", "case   PASSWORD    :", "MessagingSubsystemParser . handleElementText ( reader ,    element ,    modelName ,    operation )  ;", "break ;", "case   CONNECTION _ FACTORY    :", "case   DESTINATION    :", ". handleSingleAttribute ( reader ,    element ,    modelName ,    CommonAttributes . NAME ,    operation )  ;", "break ;", "case   CONTEXT    :", "ModelNode   context    =    operation . get ( element . getDefinition ( modelName )  . getName (  )  )  ;", "processContext ( reader ,    context )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processJmsBridgeResource"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CLASS _ NAME    :", "{", "final   String   value    =    reader . getElementText (  )  ;", "CommonAttributes . REMOTING _ INCOMING _ INTERCEPTORS . parseAndAddParameterElement ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processRemotingIncomingInterceptors"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CLASS _ NAME    :", "{", "final   String   value    =    reader . getElementText (  )  ;", "CommonAttributes . REMOTING _ OUTGOING _ INTERCEPTORS . parseAndAddParameterElement ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processRemotingOutgoingInterceptors"], "fileName": "org.jboss.as.messaging.Messaging13SubsystemParser"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder (  )  ;", "for    ( String   kp    :    keyPrefix )     {", "if    (  ( prefix . length (  )  )     >     0  )     {", "prefix . append (  '  .  '  )  ;", "}", "prefix . append ( kp )  ;", "}", "return   new   DeprecatedResourceDescriptionResolver (  . SUBSYSTEM _ NAME ,    prefix . toString (  )  ,     . RESOURCE _ NAME ,     . class . getClassLoader (  )  ,    true ,    useUnprefixedChildTypes )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.messaging.MessagingExtension"}, {"methodBody": ["METHOD_START", "{", "return   MessagingExtension . getResourceDescriptionResolver ( true ,    keyPrefix )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.messaging.MessagingExtension"}, {"methodBody": ["METHOD_START", "{", "MessagingSubsystemParser . checkOnlyOneOfElements ( reader ,    seen ,    Element . GROUP _ ADDRESS ,    Element . SOCKET _ BINDING )  ;", "if    (  ( seen . contains ( Element . GROUP _ ADDRESS )  )     &  &     (  !  ( seen . contains ( Element . GROUP _ PORT )  )  )  )     {", "throw   missingRequired ( reader ,    EnumSet . of ( Element . GROUP _ PORT )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkBroadcastGroupConstraints"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "MessagingSubsystemParser . checkOnlyOneOfElements ( reader ,    seen ,    Element . GROUP _ ADDRESS ,    Element . SOCKET _ BINDING )  ;", "if    (  ( seen . contains ( Element . GROUP _ ADDRESS )  )     &  &     (  !  ( seen . contains ( Element . GROUP _ PORT )  )  )  )     {", "throw   missingRequired ( reader ,    EnumSet . of ( Element . GROUP _ PORT )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkDiscoveryGroupConstraints"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( seen . contains ( element 1  )  )  )     &  &     (  !  ( seen . contains ( element 2  )  )  )  )     {", "throw   new   XMLStreamException ( Logger . ROOT _ LOGGER . required ( element 1  . getLocalName (  )  ,    element 2  . getLocalName (  )  )  ,    reader . getLocation (  )  )  ;", "}", "if    (  ( seen . contains ( element 1  )  )     &  &     ( seen . contains ( element 2  )  )  )     {", "throw   new   XMLStreamException ( Logger . ROOT _ LOGGER . onlyOneRequired ( element 1  . getLocalName (  )  ,    element 2  . getLocalName (  )  )  ,    reader . getLocation (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkOnlyOneOfElements"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    ( seen . contains ( otherElement )  )     {", "throw   new   XMLStreamException ( Logger . ROOT _ LOGGER . illegalElement ( currentElement . getLocalName (  )  ,    otherElement . getLocalName (  )  )  ,    reader . getLocation (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkOtherElementIsNotAlreadyDefined"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "Set < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( seen . add ( element )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "switch    ( element )     {", "case   DISCOVERY _ GROUP _ REF    :", "{", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . DISCOVERY _ GROUP _ REF ,    Element . CONNECTORS )  ;", "final   String   groupRef    =    readStringAttributeElement ( reader ,    ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP _ NAME . getXmlName (  )  )  ;", "ConnectionFactoryAttributes . Common . DISCOVERY _ GROUP _ NAME . parseAndSetParameter ( groupRef ,    connectionFactory ,    reader )  ;", "break ;", "}", "case   CONNECTORS    :", "{", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . CONNECTORS ,    Element . DISCOVERY _ GROUP _ REF )  ;", "connectionFactory . get ( CommonAttributes . CONNECTOR )  . set (  . processJmsConnectors ( reader )  )  ;", "break ;", "}", "case   ENTRIES    :", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   local    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    ( local    !  =     ( Element . ENTRY )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "final   String   entry    =    readStringAttributeElement ( reader ,    CommonAttributes . NAME )  ;", "ConnectionFactoryAttributes . Common . ENTRIES . parseAndAddParameterElement ( entry ,    connectionFactory ,    reader )  ;", "}", "break ;", "}", "case   HA    :", "case   CLIENT _ FAILURE _ CHECK _ PERIOD    :", "case   CALL _ TIMEOUT    :", "case   CONSUMER _ WINDOW _ SIZE    :", "case   CONSUMER _ MAX _ RATE    :", "case   PRODUCER _ WINDOW _ SIZE    :", "case   PRODUCER _ MAX _ RATE    :", "case   CACHE _ LARGE _ MESSAGE _ CLIENT    :", "case   CLIENT _ ID    :", "case   DUPS _ OK _ BATCH _ SIZE    :", "case   TRANSACTION _ BATH _ SIZE    :", "case   BLOCK _ ON _ ACK    :", "case   BLOCK _ ON _ NON _ DURABLE _ SEND    :", "case   BLOCK _ ON _ DURABLE _ SEND    :", "case   AUTO _ GROUP    :", "case   PRE _ ACK    :", "case   FAILOVER _ ON _ INITIAL _ CONNECTION    :", "case   FAILOVER _ ON _ SERVER _ SHUTDOWN    :", "case   LOAD _ BALANCING _ CLASS _ NAME    :", "case   USE _ GLOBAL _ POOLS    :", "case   GROUP _ ID    :", ". handleElementText ( reader ,    element ,    connectionFactory )  ;", "break ;", "case   CONFIRMATION _ WINDOW _ SIZE    :", "case   CONNECTION _ TTL    :", "case   MAX _ RETRY _ INTERVAL    :", "case   MIN _ LARGE _ MESSAGE _ SIZE    :", "case   RECONNECT _ ATTEMPTS    :", "case   RETRY _ INTERVAL    :", "case   RETRY _ INTERVAL _ MULTIPLIER    :", "case   SCHEDULED _ THREAD _ POOL _ MAX _ SIZE    :", "case   THREAD _ POOL _ MAX _ SIZE    :", ". handleElementText ( reader ,    element ,     \" connection \"  ,    connectionFactory )  ;", "break ;", "case   DISCOVERY _ INITIAL _ WAIT _ TIMEOUT    :", "MessagingLogger . ROOT _ LOGGER . deprecatedXMLElement ( element . toString (  )  )  ;", ". skipElementText ( reader )  ;", "break ;", "case   CONNECTION _ FACTORY _ TYPE    :", "if    ( pooled )     {", "throw   unexpectedElement ( reader )  ;", "}", ". handleElementText ( reader ,    element ,    connectionFactory )  ;", "break ;", "case   INBOUND _ CONFIG    :", "{", "if    (  ! pooled )     {", "throw   unexpectedElement ( reader )  ;", "}", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   local    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( local )     {", "case   USE _ JNDI    :", "case   JNDI _ PARAMS    :", "case   USE _ LOCAL _ TX    :", "case   SETUP _ ATTEMPTS    :", "case   SETUP _ INTERVAL    :", ". handleElementText ( reader ,    local ,    connectionFactory )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "break ;", "}", "case   TRANSACTION    :", "{", "if    (  ! pooled )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "final   String   txType    =    reader . getAttributeValue (  0  )  ;", "if    ( txType    !  =    null )     {", "connectionFactory . get ( ConnectionFactoryAttributes . Pooled . TRANSACTION . getName (  )  )  . set ( txType )  ;", "}", "ParseUtils . requireNoContent ( reader )  ;", "break ;", "}", "case   USER    :", "if    (  ! pooled )     {", "throw   unexpectedElement ( reader )  ;", "}", "ConnectionFactoryAttributes . Pooled . USER . parseAndSetParameter ( reader . getElementText (  )  ,    connectionFactory ,    reader )  ;", "break ;", "case   PASSWORD    :", "if    (  ! pooled )     {", "throw   unexpectedElement ( reader )  ;", "}", "ConnectionFactoryAttributes . Pooled . PASSWORD . parseAndSetParameter ( reader . getElementText (  )  ,    connectionFactory ,    reader )  ;", "break ;", "default    :", "{", "handleUnknownConnectionFactoryAttribute ( reader ,    element ,    connectionFactory ,    pooled )  ;", "}", "}", "}", ". checkOnlyOneOfElements ( reader ,    seen ,    Element . CONNECTORS ,    Element . DISCOVERY _ GROUP _ REF )  ;", "return   connectionFactory ;", "}", "METHOD_END"], "methodName": ["createConnectionFactory"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   MessagingLogger . ROOT _ LOGGER . unsupportedElement ( element . getLocalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleComplexConfigurationAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition   attributeDefinition    =     ( modelName    =  =    null )     ?    element . getDefinition (  )     :    element . getDefinition ( modelName )  ;", "if    ( attributeDefinition    !  =    null )     {", "final   String   value    =    reader . getElementText (  )  ;", "if    ( attributeDefinition   instanceof   SimpleAttributeDefinition )     {", "(  ( SimpleAttributeDefinition )     ( attributeDefinition )  )  . parseAndSetParameter ( value ,    node ,    reader )  ;", "} else", "if    ( attributeDefinition   instanceof   ListAttributeDefinition )     {", "(  ( ListAttributeDefinition )     ( attributeDefinition )  )  . parseAndAddParameterElement ( value ,    node ,    reader )  ;", "}", "} else    {", ". handleElementText ( reader ,    element ,    node ,    STRING ,    true ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["handleElementText"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "MessagingSubsystemParser . handleElementText ( reader ,    element ,    null ,    node )  ;", "}", "METHOD_END"], "methodName": ["handleElementText"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   String   value    =    reader . getElementText (  )  ;", "if    (  ( value    !  =    null )     &  &     (  ( value . length (  )  )     >     0  )  )     {", "ModelNode   toSet    =    node . get ( element . getLocalName (  )  )  ;", "ModelNode   modelValue    =     ( allowExpression )     ?    parsePossibleExpression ( value . trim (  )  )     :    new   ModelNode (  )  . set ( value . trim (  )  )  ;", "if    (  (  ! allowExpression )     |  |     (  ( modelValue . getType (  )  )     !  =     ( ModelType . EXPRESSION )  )  )     {", "toSet . set ( modelValue )  ;", "} else    {", "try    {", "switch    ( expectedType )     {", "case   BOOLEAN    :", "toSet . set ( modelValue . asBoolean (  )  )  ;", "break ;", "case   BIG _ DECIMAL    :", "toSet . set ( modelValue . asBigDecimal (  )  )  ;", "break ;", "case   BIG _ INTEGER    :", "toSet . set ( modelValue . asBigInteger (  )  )  ;", "break ;", "case   BYTES    :", "toSet . set ( modelValue . asBytes (  )  )  ;", "break ;", "case   DOUBLE    :", "toSet . set ( modelValue . asDouble (  )  )  ;", "break ;", "case   INT    :", "toSet . set ( modelValue . asInt (  )  )  ;", "break ;", "case   LONG    :", "toSet . set ( modelValue . asLong (  )  )  ;", "break ;", "case   STRING    :", "toSet . set ( modelValue . asString (  )  )  ;", "break ;", "default    :", "throw   new   XMLStreamException ( Logger . ROOT _ LOGGER . illegalValue ( value ,    element . getLocalName (  )  )  ,    reader . getLocation (  )  )  ;", "}", "}    catch    ( IllegalArgumentException   iae )     {", "throw   new   XMLStreamException ( Logger . ROOT _ LOGGER . illegalValue ( value ,    element . getLocalName (  )  ,    expectedType )  ,    reader . getLocation (  )  )  ;", "}", "}", "} else", "if    (  ! allowNull )     {", "throw   new   XMLStreamException ( Logger . ROOT _ LOGGER . illegalValue ( value ,    element . getLocalName (  )  )  ,    reader . getLocation (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleElementText"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["handleUnknownBroadcastGroupAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["handleUnknownClusterConnectionAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["handleUnknownConfigurationAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["handleUnknownConnectionFactoryAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["handleUnknownDiscoveryGroupAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "METHOD_END"], "methodName": ["handleUnknownGroupingHandlerAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   addressSettingsSpec    =    new   ModelNode (  )  ;", "String   localName ;", "do    {", "reader . nextTag (  )  ;", "localName    =    reader . getLocalName (  )  ;", "final   Element   element    =    Element . forName ( localName )  ;", "switch    ( element )     {", "case   DEAD _ LETTER _ ADDRESS    :", "case   EXPIRY _ ADDRESS    :", "case   REDELIVERY _ DELAY    :", "case   MAX _ SIZE _ BYTES    :", "case   PAGE _ MAX _ CACHE _ SIZE    :", "case   PAGE _ SIZE _ BYTES    :", "case   MESSAGE _ COUNTER _ HISTORY _ DAY _ LIMIT    :", "case   ADDRESS _ FULL _ MESSAGE _ POLICY    :", "case   LVQ    :", "case   MAX _ DELIVERY _ ATTEMPTS    :", "case   REDISTRIBUTION _ DELAY    :", "case   SEND _ TO _ DLA _ ON _ NO _ ROUTE    :", "{", ". handleElementText ( reader ,    element ,    addressSettingsSpec )  ;", "break ;", "}", "default    :", "{", "handleUnknownAddressSetting ( reader ,    element ,    addressSettingsSpec )  ;", "break ;", "}", "}", "}    while    (  (  !  ( reader . getLocalName (  )  . equals ( Element . ADDRESS _ SETTING . getLocalName (  )  )  )  )     &  &     (  ( reader . getEventType (  )  )     =  =     ( XMLExtendedStreamReader . END _ ELEMENT )  )     )  ;", "return   addressSettingsSpec ;", "}", "METHOD_END"], "methodName": ["parseAddressSettings"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    attrValue ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "ModelNode   broadcastGroupAdd    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . BROADCAST _ GROUP ,    name )  )  ;", "Set < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "seen . add ( element )  ;", "switch    ( element )     {", "case   LOCAL _ BIND _ ADDRESS    :", "case   LOCAL _ BIND _ PORT    :", "case   GROUP _ ADDRESS    :", "case   GROUP _ PORT    :", "case   SOCKET _ BINDING    :", "case   BROADCAST _ PERIOD    :", ". handleElementText ( reader ,    element ,    broadcastGroupAdd )  ;", "break ;", "case   CONNECTOR _ REF    :", ". handleElementText ( reader ,    element ,     \" broadcast - group \"  ,    broadcastGroupAdd )  ;", "break ;", "default    :", "{", "handleUnknownBroadcastGroupAttribute ( reader ,    element ,    broadcastGroupAdd )  ;", "}", "}", "}", "checkBroadcastGroupConstraints ( reader ,    seen )  ;", "updates . add ( broadcastGroupAdd )  ;", "}", "METHOD_END"], "methodName": ["parseBroadcastGroup"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "ModelNode   path    =    null ;", "String   relativeTo    =    null ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "switch    ( attribute )     {", "case   RELATIVE _ TO    :", "relativeTo    =    value ;", "break ;", "case   PATH    :", "path    =    PathDefinition . PATHS . get ( name )  . parse ( value ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( path    =  =    null )     {", "throw   Utils . missingRequired ( reader ,    Collections . singleton ( Attribute . PATH )  )  ;", "}", "requireNoContent ( reader )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( PATH ,    name )  ;", "operation . get ( PATH )  . set ( path )  ;", "if    ( relativeTo    !  =    null )", "operation . get ( ModelDescriptionConstants . RELATIVE _ TO )  . set ( relativeTo )  ;", "updates . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseDirectory"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    attrValue ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "ModelNode   discoveryGroup    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . DISCOVERY _ GROUP ,    name )  )  ;", "Set < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "seen . add ( element )  ;", "switch    ( element )     {", "case   LOCAL _ BIND _ ADDRESS    :", "case   GROUP _ ADDRESS    :", "case   GROUP _ PORT    :", "case   REFRESH _ TIMEOUT    :", "case   SOCKET _ BINDING    :", "case   INITIAL _ WAIT _ TIMEOUT    :", ". handleElementText ( reader ,    element ,    discoveryGroup )  ;", "break ;", "default    :", "{", "handleUnknownDiscoveryGroupAttribute ( reader ,    element ,    discoveryGroup )  ;", "}", "}", "}", "checkDiscoveryGroupConstraints ( reader ,    seen )  ;", "updates . add ( discoveryGroup )  ;", "}", "METHOD_END"], "methodName": ["parseDiscoveryGroup"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "String   name    =    reader . getAttributeValue (  0  )  ;", "ModelNode   divertAdd    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . DIVERT ,    name )  )  ;", "EnumSet < Element >    required    =    EnumSet . of ( Element . ADDRESS ,    Element . FORWARDING _ ADDRESS )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "required . remove ( element )  ;", "switch    ( element )     {", "case   ROUTING _ NAME    :", "{", ". handleElementText ( reader ,    element ,    divertAdd )  ;", "break ;", "}", "case   ADDRESS    :", "{", ". handleElementText ( reader ,    element ,    DivertDefinition . ADDRESS . getName (  )  ,    divertAdd )  ;", "break ;", "}", "case   FORWARDING _ ADDRESS    :", "{", ". handleElementText ( reader ,    element ,     \" divert \"  ,    divertAdd )  ;", "break ;", "}", "case   FILTER    :", "{", "String   string    =    readStringAttributeElement ( reader ,    CommonAttributes . STRING )  ;", "CommonAttributes . FILTER . parseAndSetParameter ( string ,    divertAdd ,    reader )  ;", "break ;", "}", "case   TRANSFORMER _ CLASS _ NAME    :", "{", ". handleElementText ( reader ,    element ,    divertAdd )  ;", "break ;", "}", "case   EXCLUSIVE    :", "{", ". handleElementText ( reader ,    element ,    divertAdd )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "list . add ( divertAdd )  ;", "}", "METHOD_END"], "methodName": ["parseDivert"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   DIVERT    :", "{", ". parseDivert ( reader ,    address ,    list )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseDiverts"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ADDRESS    :", "{", ". handleElementText ( reader ,    element ,    QueueDefinition . ADDRESS . getName (  )  ,    queue )  ;", "break ;", "}", "case   FILTER    :", "{", "String   string    =    readStringAttributeElement ( reader ,    CommonAttributes . STRING )  ;", "CommonAttributes . FILTER . parseAndSetParameter ( string ,    queue ,    reader )  ;", "break ;", "}", "case   DURABLE    :", "{", ". handleElementText ( reader ,    element ,    queue )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseQueue"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "String   name    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    attrValue ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   QUEUE    :", "{", "if    ( name    =  =    null )     {", "throw   ParseUtils . missingRequired ( reader ,    Collections . singleton ( Attribute . NAME . getLocalName (  )  )  )  ;", "}", "final   ModelNode   op    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . QUEUE ,    name )  )  ;", ". parseQueue ( reader ,    op )  ;", "if    (  !  ( op . hasDefined ( QueueDefinition . ADDRESS . getName (  )  )  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    Collections . singleton ( Element . ADDRESS . getLocalName (  )  )  )  ;", "}", "list . add ( op )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseQueues"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "return   reader . getListAttributeValue ( index )  ;", "}", "METHOD_END"], "methodName": ["parseRolesAttribute"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    Set < AttributeDefinition >  >    permsByRole    =    new   HashMap < String ,    Set < AttributeDefinition >  >  (  )  ;", "String   localName    =    null ;", "do    {", "reader . nextTag (  )  ;", "localName    =    reader . getLocalName (  )  ;", "final   Element   element    =    Element . forName ( localName )  ;", "if    ( element    !  =     ( Element . PERMISSION _ ELEMENT _ NAME )  )     {", "break ;", "}", "final   Set < Attribute >    required    =    EnumSet . of ( Attribute . ROLES _ ATTR _ NAME ,    Attribute . TYPE _ ATTR _ NAME )  ;", "List < String >    roles    =    null ;", "AttributeDefinition   perm    =    null ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "required . remove ( attribute )  ;", "switch    ( attribute )     {", "case   ROLES _ ATTR _ NAME    :", "roles    =    parseRolesAttribute ( reader ,    i )  ;", "break ;", "case   TYPE _ ATTR _ NAME    :", "perm    =    SecurityRoleDefinition . ROLE _ ATTRIBUTES _ BY _ XML _ NAME . get ( reader . getAttributeValue ( i )  )  ;", "if    ( perm    =  =    null )     {", "throw   ROOT _ LOGGER . invalidAttributeValue ( reader . getAttributeValue ( i )  ,    reader . getAttributeName ( i )  ,    SecurityRoleDefinition . ROLE _ ATTRIBUTES _ BY _ XML _ NAME . keySet (  )  ,    reader . getLocation (  )  )  ;", "}", "break ;", "default    :", "throw   Utils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "for    ( String   role    :    roles )     {", "role    =    role . trim (  )  ;", "Set < AttributeDefinition >    perms    =    permsByRole . get ( role )  ;", "if    ( perms    =  =    null )     {", "perms    =    new   HashSet < AttributeDefinition >  (  )  ;", "permsByRole . put ( role ,    perms )  ;", "}", "perms . add ( perm )  ;", "}", "reader . discardRemainder (  )  ;", "}    while    ( reader . hasNext (  )     )  ;", "for    ( Map . Entry < String ,    Set < AttributeDefinition >  >    entry    :    permsByRole . entrySet (  )  )     {", "final   String   role    =    entry . getKey (  )  ;", "final   Set < AttributeDefinition >    perms    =    entry . getValue (  )  ;", "final   ModelNode   addr    =    address . clone (  )  ;", "addr . add ( CommonAttributes . ROLE ,    role )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( addr )  ;", "for    ( AttributeDefinition   perm    :    SecurityRoleDefinition . ATTRIBUTES )     {", "operation . get ( perm . getName (  )  )  . set ( perms . contains ( perm )  )  ;", "}", "operations . add ( operation )  ;", "}", "}", "METHOD_END"], "methodName": ["parseSecurityRoles"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   FACTORY _ CLASS    :", "{", "if    (  ! generic )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", ". handleElementText ( reader ,    element ,    operation )  ;", "break ;", "}", "case   PARAM    :", "{", "int   count    =    reader . getAttributeCount (  )  ;", "String   key    =    null ;", "String   value    =    null ;", "for    ( int   n    =     0  ;    n    <    count ;    n +  +  )     {", "String   attrName    =    reader . getAttributeLocalName ( n )  ;", "Attribute   attribute    =    Attribute . forName ( attrName )  ;", "switch    ( attribute )     {", "case   KEY    :", "key    =    reader . getAttributeValue ( n )  ;", "break ;", "case   VALUE    :", "value    =    reader . getAttributeValue ( n )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    n )  ;", "}", "}", "ModelNode   addParam    =    new   ModelNode (  )  ;", "addParam . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "ModelNode   transportAddress    =    operation . get ( ModelDescriptionConstants . OP _ ADDR )  . clone (  )  ;", "addParam . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( transportAddress . add ( CommonAttributes . PARAM ,    key )  )  ;", "TransportParamDefinition . VALUE . parseAndSetParameter ( value ,    addParam ,    reader )  ;", "updates . add ( addParam )  ;", "ParseUtils . requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTransportConfiguration"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "String   name    =    null ;", "String   socketBinding    =    null ;", "String   serverId    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    attrValue ;", "break ;", "}", "case   SOCKET _ BINDING    :", "{", "socketBinding    =    attrValue ;", "break ;", "}", "case   SERVER _ ID    :", "{", "serverId    =    attrValue ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    ( name    =  =    null )     {", "throw   Utils . missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "final   ModelNode   acceptorAddress    =    address . clone (  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "boolean   generic    =    false ;", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ACCEPTOR    :", "{", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( acceptorAddress . add ( CommonAttributes . ACCEPTOR ,    name )  )  ;", "if    ( socketBinding    !  =    null )     {", "operation . get ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  )  . set ( socketBinding )  ;", "}", "generic    =    true ;", "break ;", "}", "case   NETTY _ ACCEPTOR    :", "{", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( acceptorAddress . add ( CommonAttributes . REMOTE _ ACCEPTOR ,    name )  )  ;", "if    ( socketBinding    =  =    null )     {", "throw   Utils . missingRequired ( reader ,    Collections . singleton ( Attribute . SOCKET _ BINDING )  )  ;", "}", "operation . get ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  )  . set ( socketBinding )  ;", "break ;", "}", "case   IN _ VM _ ACCEPTOR    :", "{", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( acceptorAddress . add ( CommonAttributes . IN _ VM _ ACCEPTOR ,    name )  )  ;", "if    ( serverId    !  =    null )     {", "InVMTransportDefinition . SERVER _ ID . parseAndSetParameter ( serverId ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "updates . add ( operation )  ;", "parseTransportConfiguration ( reader ,    operation ,    generic ,    updates )  ;", "}", "}", "METHOD_END"], "methodName": ["processAcceptors"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   localName    =    null ;", "do    {", "reader . nextTag (  )  ;", "localName    =    reader . getLocalName (  )  ;", "final   Element   element    =    Element . forName ( localName )  ;", "switch    ( element )     {", "case   ADDRESS _ SETTING    :", "final   String   match    =    reader . getAttributeValue (  0  )  ;", "final   ModelNode   operation    =    pAddressSettings ( reader )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( CommonAttributes . ADDRESS _ SETTING ,    match )  ;", "operations . add ( operation )  ;", "break ;", "}", "}    while    (  ( reader . hasNext (  )  )     &  &     ( localName . equals ( Element . ADDRESS _ SETTING . getLocalName (  )  )  )     )  ;", "}", "METHOD_END"], "methodName": ["processAddressSettings"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "String   name    =    reader . getAttributeValue (  0  )  ;", "ModelNode   bridgeAdd    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . BRIDGE ,    name )  )  ;", "EnumSet < Element >    required    =    EnumSet . of ( Element . QUEUE _ NAME )  ;", "Set < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( seen . add ( element )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "required . remove ( element )  ;", "switch    ( element )     {", "case   QUEUE _ NAME    :", "case   HA    :", "case   TRANSFORMER _ CLASS _ NAME    :", "case   USER    :", "case   PASSWORD    :", ". handleElementText ( reader ,    element ,    bridgeAdd )  ;", "break ;", "case   CONFIRMATION _ WINDOW _ SIZE    :", ". handleElementText ( reader ,    element ,     \" bridge \"  ,    bridgeAdd )  ;", "break ;", "case   FILTER    :", "{", "String   string    =    readStringAttributeElement ( reader ,    CommonAttributes . STRING )  ;", "CommonAttributes . FILTER . parseAndSetParameter ( string ,    bridgeAdd ,    reader )  ;", "break ;", "}", "case   RETRY _ INTERVAL _ MULTIPLIER    :", "case   RETRY _ INTERVAL    :", ". handleElementText ( reader ,    element ,    CommonAttributes . DEFAULT ,    bridgeAdd )  ;", "break ;", "case   FORWARDING _ ADDRESS    :", "case   RECONNECT _ ATTEMPTS    :", "case   USE _ DUPLICATE _ DETECTION    :", ". handleElementText ( reader ,    element ,     \" bridge \"  ,    bridgeAdd )  ;", "break ;", "case   STATIC _ CONNECTORS    :", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . STATIC _ CONNECTORS ,    Element . DISCOVERY _ GROUP _ REF )  ;", "processStaticConnectors ( reader ,    bridgeAdd ,    false )  ;", "break ;", "case   DISCOVERY _ GROUP _ REF    :", "{", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . DISCOVERY _ GROUP _ REF ,    Element . STATIC _ CONNECTORS )  ;", "final   String   groupRef    =    readStringAttributeElement ( reader ,    BridgeDefinition . DISCOVERY _ GROUP _ NAME . getXmlName (  )  )  ;", "BridgeDefinition . DISCOVERY _ GROUP _ NAME . parseAndSetParameter ( groupRef ,    bridgeAdd ,    reader )  ;", "break ;", "}", "case   FAILOVER _ ON _ SERVER _ SHUTDOWN    :", "{", "MessagingLogger . ROOT _ LOGGER . deprecatedXMLElement ( element . toString (  )  )  ;", ". skipElementText ( reader )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", ". checkOnlyOneOfElements ( reader ,    seen ,    Element . STATIC _ CONNECTORS ,    Element . DISCOVERY _ GROUP _ REF )  ;", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "updates . add ( bridgeAdd )  ;", "}", "METHOD_END"], "methodName": ["processBridge"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   BRIDGE    :", "{", "processBridge ( reader ,    address ,    updates )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processBridges"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   BROADCAST _ GROUP    :", "{", "parseBroadcastGroup ( reader ,    address ,    updates )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processBroadcastGroups"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "String   name    =    reader . getAttributeValue (  0  )  ;", "ModelNode   clusterConnectionAdd    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . CLUSTER _ CONNECTION ,    name )  )  ;", "EnumSet < Element >    required    =    EnumSet . of ( Element . ADDRESS ,    Element . CONNECTOR _ REF )  ;", "Set < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( seen . add ( element )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "required . remove ( element )  ;", "switch    ( element )     {", "case   FORWARD _ WHEN _ NO _ CONSUMERS    :", "case   MAX _ HOPS    :", ". handleElementText ( reader ,    element ,    clusterConnectionAdd )  ;", "break ;", "case   ADDRESS    :", "{", ". handleElementText ( reader ,    element ,    ClusterConnectionDefinition . ADDRESS . getName (  )  ,    clusterConnectionAdd )  ;", "break ;", "}", "case   CONNECTOR _ REF    :", "{", ". handleElementText ( reader ,    element ,     \" simple \"  ,    clusterConnectionAdd )  ;", "break ;", "}", "case   CONFIRMATION _ WINDOW _ SIZE    :", ". handleElementText ( reader ,    element ,     \" bridge \"  ,    clusterConnectionAdd )  ;", "break ;", "case   USE _ DUPLICATE _ DETECTION    :", "case   RETRY _ INTERVAL    :", ". handleElementText ( reader ,    element ,     \" cluster \"  ,    clusterConnectionAdd )  ;", "break ;", "case   STATIC _ CONNECTORS    :", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . STATIC _ CONNECTORS ,    Element . DISCOVERY _ GROUP _ REF )  ;", "processStaticConnectors ( reader ,    clusterConnectionAdd ,    true )  ;", "break ;", "case   DISCOVERY _ GROUP _ REF    :", "{", "checkOtherElementIsNotAlreadyDefined ( reader ,    seen ,    Element . DISCOVERY _ GROUP _ REF ,    Element . STATIC _ CONNECTORS )  ;", "final   String   groupRef    =    readStringAttributeElement ( reader ,    ClusterConnectionDefinition . DISCOVERY _ GROUP _ NAME . getXmlName (  )  )  ;", "ClusterConnectionDefinition . DISCOVERY _ GROUP _ NAME . parseAndSetParameter ( groupRef ,    clusterConnectionAdd ,    reader )  ;", "break ;", "}", "default    :", "{", "handleUnknownClusterConnectionAttribute ( reader ,    element ,    clusterConnectionAdd )  ;", "}", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "checkClusterConnectionConstraints ( reader ,    seen )  ;", "updates . add ( clusterConnectionAdd )  ;", "}", "METHOD_END"], "methodName": ["processClusterConnection"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CLUSTER _ CONNECTION    :", "{", "processClusterConnection ( reader ,    address ,    updates )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processClusterConnections"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONNECTION _ FACTORY    :", "processConnectionFactory ( reader ,    address ,    updates )  ;", "break ;", "case   POOLED _ CONNECTION _ FACTORY    :", "processPooledConnectionFactory ( reader ,    address ,    updates )  ;", "break ;", "default    :", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processConnectionFactories"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "final   String   name    =    reader . getAttributeValue (  0  )  ;", "final   ModelNode   connectionFactory    =    new   ModelNode (  )  ;", "connectionFactory . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "connectionFactory . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  . add ( CommonAttributes . CONNECTION _ FACTORY ,    name )  ;", "updates . add ( createConnectionFactory ( reader ,    connectionFactory ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["processConnectionFactory"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "String   name    =    reader . getAttributeValue (  0  )  ;", "final   ModelNode   serviceAddress    =    address . clone (  )  . add ( CommonAttributes . CONNECTOR _ SERVICE ,    name )  ;", "final   ModelNode   add    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    serviceAddress )  ;", "updates . add ( add )  ;", "EnumSet < Element >    required    =    EnumSet . of ( Element . FACTORY _ CLASS )  ;", "Set < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    (  (  !  ( seen . add ( element )  )  )     &  &     ( element    !  =     ( Element . PARAM )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "required . remove ( element )  ;", "switch    ( element )     {", "case   FACTORY _ CLASS    :", "{", ". handleElementText ( reader ,    element ,    add )  ;", "break ;", "}", "case   PARAM    :", "{", "String [  ]    attrs    =    ParseUtils . requireAttributes ( reader ,    Attribute . KEY . getLocalName (  )  ,    Attribute . VALUE . getLocalName (  )  )  ;", "final   String   key    =    attrs [  0  ]  ;", "final   String   value    =    attrs [  1  ]  ;", "final   ModelNode   paramAdd    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    serviceAddress . clone (  )  . add ( CommonAttributes . PARAM ,    key )  )  ;", "ConnectorServiceParamDefinition . VALUE . parseAndSetParameter ( value ,    paramAdd ,    reader )  ;", "updates . add ( paramAdd )  ;", "requireNoContent ( reader )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "}", "METHOD_END"], "methodName": ["processConnectorService"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONNECTOR _ SERVICE    :", "{", ". processConnectorService ( reader ,    address ,    updates )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processConnectorServices"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "String   name    =    null ;", "String   socketBinding    =    null ;", "String   serverId    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "{", "name    =    attrValue ;", "break ;", "}", "case   SOCKET _ BINDING    :", "{", "socketBinding    =    attrValue ;", "break ;", "}", "case   SERVER _ ID    :", "{", "serverId    =    attrValue ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "final   ModelNode   connectorAddress    =    address . clone (  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "boolean   generic    =    false ;", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONNECTOR    :", "{", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( connectorAddress . add ( CommonAttributes . CONNECTOR ,    name )  )  ;", "if    ( socketBinding    !  =    null )     {", "operation . get ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  )  . set ( socketBinding )  ;", "}", "generic    =    true ;", "break ;", "}", "case   NETTY _ CONNECTOR    :", "{", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( connectorAddress . add ( CommonAttributes . REMOTE _ CONNECTOR ,    name )  )  ;", "if    ( socketBinding    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . SOCKET _ BINDING )  )  ;", "}", "operation . get ( RemoteTransportDefinition . SOCKET _ BINDING . getName (  )  )  . set ( socketBinding )  ;", "break ;", "}", "case   IN _ VM _ CONNECTOR    :", "{", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( connectorAddress . add ( CommonAttributes . IN _ VM _ CONNECTOR ,    name )  )  ;", "if    ( serverId    !  =    null )     {", "InVMTransportDefinition . SERVER _ ID . parseAndSetParameter ( serverId ,    operation ,    reader )  ;", "}", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "updates . add ( operation )  ;", "parseTransportConfiguration ( reader ,    operation ,    generic ,    updates )  ;", "}", "}", "METHOD_END"], "methodName": ["processConnectors"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   DISCOVERY _ GROUP    :", "{", "parseDiscoveryGroup ( reader ,    address ,    updates )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processDiscoveryGroups"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "String   name    =    reader . getAttributeValue (  0  )  ;", "ModelNode   groupingHandlerAdd    =    Util . getEmptyOperation ( ModelDescriptionConstants . ADD ,    address . clone (  )  . add ( CommonAttributes . GROUPING _ HANDLER ,    name )  )  ;", "EnumSet < Element >    required    =    EnumSet . of ( Element . ADDRESS ,    Element . TYPE )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "required . remove ( element )  ;", "switch    ( element )     {", "case   TYPE    :", "case   TIMEOUT    :", "{", ". handleElementText ( reader ,    element ,    groupingHandlerAdd )  ;", "break ;", "}", "case   ADDRESS    :", "{", ". handleElementText ( reader ,    element ,    GroupingHandlerDefinition . GROUPING _ HANDLER _ ADDRESS . getName (  )  ,    groupingHandlerAdd )  ;", "break ;", "}", "default    :", "{", "handleUnknownGroupingHandlerAttribute ( reader ,    element ,    groupingHandlerAdd )  ;", "}", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "updates . add ( groupingHandlerAdd )  ;", "}", "METHOD_END"], "methodName": ["processGroupingHandler"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   hqServerName    =    null ;", "String   elementName    =    null ;", "switch    ( namespace )     {", "case   MESSAGING _  1  _  0     :", "requireNoAttributes ( reader )  ;", "elementName    =    ModelDescriptionConstants . SUBSYSTEM ;", "break ;", "default    :", "{", "final   int   count    =    reader . getAttributeCount (  )  ;", "if    ( count    >     0  )     {", "requireSingleAttribute ( reader ,    Attribute . NAME . getLocalName (  )  )  ;", "hqServerName    =    reader . getAttributeValue (  0  )  . trim (  )  ;", "}", "elementName    =    CommonAttributes . HORNETQ _ SERVER ;", "}", "}", "if    (  ( hqServerName    =  =    null )     |  |     (  ( hqServerName . length (  )  )     =  =     0  )  )     {", "hqServerName    =    CommonAttributes . DEFAULT ;", "}", "final   ModelNode   address    =    subsystemAddress . clone (  )  ;", "address . add ( CommonAttributes . HORNETQ _ SERVER ,    hqServerName )  ;", "address . protect (  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "list . add ( operation )  ;", "EnumSet < Element >    seen    =    EnumSet . noneOf ( Element . class )  ;", "String   localName    =    null ;", "do    {", "reader . nextTag (  )  ;", "localName    =    reader . getLocalName (  )  ;", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    (  !  ( seen . add ( element )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    element . getLocalName (  )  )  ;", "}", "switch    ( element )     {", "case   ACCEPTORS    :", "processAcceptors ( reader ,    address ,    list )  ;", "break ;", "case   ADDRESS _ SETTINGS    :", "processAddressSettings ( reader ,    address ,    list )  ;", "break ;", "case   BINDINGS _ DIRECTORY    :", ". parseDirectory ( reader ,    CommonAttributes . BINDINGS _ DIRECTORY ,    address ,    list )  ;", "break ;", "case   BRIDGES    :", "processBridges ( reader ,    address ,    list )  ;", "break ;", "case   BROADCAST _ GROUPS    :", "processBroadcastGroups ( reader ,    address ,    list )  ;", "break ;", "case   CLUSTER _ CONNECTIONS    :", "processClusterConnections ( reader ,    address ,    list )  ;", "break ;", "case   CONNECTORS    :", "processConnectors ( reader ,    address ,    list )  ;", "break ;", "case   CONNECTOR _ SERVICES    :", ". processConnectorServices ( reader ,    address ,    list )  ;", "break ;", "case   DISCOVERY _ GROUPS    :", "processDiscoveryGroups ( reader ,    address ,    list )  ;", "break ;", "case   DIVERTS    :", ". parseDiverts ( reader ,    address ,    list )  ;", "break ;", "case   FILE _ DEPLOYMENT _ ENABLED    :", ". unhandledElement ( reader ,    element )  ;", "break ;", "case   GROUPING _ HANDLER    :", "processGroupingHandler ( reader ,    address ,    list )  ;", "break ;", "case   JOURNAL _ DIRECTORY    :", ". parseDirectory ( reader ,    CommonAttributes . JOURNAL _ DIRECTORY ,    address ,    list )  ;", "break ;", "case   LARGE _ MESSAGES _ DIRECTORY    :", ". parseDirectory ( reader ,    CommonAttributes . LARGE _ MESSAGES _ DIRECTORY ,    address ,    list )  ;", "break ;", "case   LIVE _ CONNECTOR _ REF    :", "{", "MessagingLogger . ROOT _ LOGGER . deprecatedXMLElement ( element . toString (  )  )  ;", ". skipElementText ( reader )  ;", "break ;", "}", "case   PAGING _ DIRECTORY    :", ". parseDirectory ( reader ,    CommonAttributes . PAGING _ DIRECTORY ,    address ,    list )  ;", "break ;", "case   REMOTING _ INTERCEPTORS    :", "processRemotingInterceptors ( reader ,    operation )  ;", "break ;", "case   SECURITY _ DOMAIN    :", ". handleElementText ( reader ,    element ,    null ,    operation )  ;", "break ;", "case   SECURITY _ SETTINGS    :", "{", "processSecuritySettings ( reader ,    address ,    list )  ;", "break ;", "}", "case   CORE _ QUEUES    :", "{", ". parseQueues ( reader ,    address ,    list )  ;", "break ;", "}", "case   CONNECTION _ FACTORIES    :", "{", "processConnectionFactories ( reader ,    address ,    list )  ;", "break ;", "}", "case   JMS _ DESTINATIONS    :", "{", ". processJmsDestinations ( reader ,    address ,    list )  ;", "break ;", "}", "case   SCHEDULED _ THREAD _ POOL _ MAX _ SIZE    :", "case   THREAD _ POOL _ MAX _ SIZE    :", "{", ". handleElementText ( reader ,    element ,     \" server \"  ,    operation )  ;", "break ;", "}", "case   MESSAGE _ COUNTER _ ENABLED    :", "{", "MessagingLogger . ROOT _ LOGGER . deprecatedXMLElement ( element . toString (  )  ,    Element . STATISTICS _ ENABLED . toString (  )  )  ;", ". handleElementText ( reader ,    element ,    operation )  ;", "break ;", "}", "case   HORNETQ _ SERVER    :", "if    ( namespace    =  =     ( Namespace . MESSAGING _  1  _  0  )  )     {", "throw   unexpectedEndElement ( reader )  ;", "}", "break ;", "case   SUBSYSTEM    :", "if    ( namespace    !  =     ( Namespace . MESSAGING _  1  _  0  )  )     {", "throw   unexpectedEndElement ( reader )  ;", "}", "break ;", "case   CLUSTERED    :", "MessagingLogger . ROOT _ LOGGER . deprecatedXMLElement ( element . toString (  )  )  ;", "default    :", "if    (  . SIMPLE _ ROOT _ RESOURCE _ ELEMENTS . contains ( element )  )     {", "AttributeDefinition   attributeDefinition    =    element . getDefinition (  )  ;", "if    ( attributeDefinition   instanceof   SimpleAttributeDefinition )     {", ". handleElementText ( reader ,    element ,    operation )  ;", "} else    {", "handleComplexConfigurationAttribute ( reader ,    element ,    operation )  ;", "}", "} else    {", "handleUnknownConfigurationAttribute ( reader ,    element ,    operation )  ;", "}", "}", "}    while    (  ( reader . hasNext (  )  )     &  &     (  ( localName . equals ( elementName )  )     =  =    false )     )  ;", "}", "METHOD_END"], "methodName": ["processHornetQServer"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Namespace   schemaVer    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "switch    ( schemaVer )     {", "case   MESSAGING _  1  _  0     :", "case   UNKNOWN    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "default    :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   HORNETQ _ SERVER    :", "processHornetQServer ( reader ,    sAddress ,    list ,    schemaVer )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processHornetQServers"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireSingleAttribute ( reader ,    CommonAttributes . NAME )  ;", "final   String   name    =    reader . getAttributeValue (  0  )  ;", "final   ModelNode   queue    =    new   ModelNode (  )  ;", "queue . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "queue . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  . add ( CommonAttributes . JMS _ QUEUE ,    name )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ENTRY    :", "{", "final   String   entry    =    readStringAttributeElement ( reader ,    CommonAttributes . NAME )  ;", "CommonAttributes . DESTINATION _ ENTRIES . parseAndAddParameterElement ( entry ,    queue ,    reader )  ;", "break ;", "}", "case   SELECTOR    :", "{", "if    ( queue . has ( CommonAttributes . SELECTOR . getName (  )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    Element . SELECTOR . getLocalName (  )  )  ;", "}", "requireSingleAttribute ( reader ,    CommonAttributes . STRING )  ;", "final   String   selector    =    readStringAttributeElement ( reader ,    CommonAttributes . STRING )  ;", "CommonAttributes . SELECTOR . parseAndSetParameter ( selector ,    queue ,    reader )  ;", "break ;", "}", "case   DURABLE    :", "{", "if    ( queue . has ( CommonAttributes . DURABLE . getName (  )  )  )     {", "throw   ParseUtils . duplicateNamedElement ( reader ,    Element . DURABLE . getLocalName (  )  )  ;", "}", ". handleElementText ( reader ,    element ,    queue )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "updates . add ( queue )  ;", "}", "METHOD_END"], "methodName": ["processJMSQueue"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    reader . getAttributeValue (  0  )  ;", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton (  \" name \"  )  )  ;", "}", "final   ModelNode   topic    =    new   ModelNode (  )  ;", "topic . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "topic . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  . add ( CommonAttributes . JMS _ TOPIC ,    name )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ENTRY    :", "{", "final   String   entry    =    readStringAttributeElement ( reader ,    CommonAttributes . NAME )  ;", "CommonAttributes . DESTINATION _ ENTRIES . parseAndAddParameterElement ( entry ,    topic ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "updates . add ( topic )  ;", "}", "METHOD_END"], "methodName": ["processJMSTopic"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   connectors    =    new   ModelNode (  )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "String   name    =    null ;", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   CONNECTOR _ NAME    :", "{", "name    =    value . trim (  )  ;", "break ;", "}", "case   BACKUP _ CONNECTOR _ NAME    :", "{", "Logger . ROOT _ LOGGER . deprecatedXMLAttribute ( attribute . toString (  )  )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "if    ( name    =  =    null )     {", "throw   ParseUtils . missingRequired ( reader ,    Collections . singleton ( Attribute . CONNECTOR _ NAME )  )  ;", "}", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "if    ( element    !  =     ( Element . CONNECTOR _ REF )  )     {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "ParseUtils . requireNoContent ( reader )  ;", "connectors . get ( name )  ;", "}", "return   connectors ;", "}", "METHOD_END"], "methodName": ["processJmsConnectors"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   JMS _ QUEUE    :", ". processJMSQueue ( reader ,    address ,    updates )  ;", "break ;", "case   JMS _ TOPIC    :", ". processJMSTopic ( reader ,    address ,    updates )  ;", "break ;", "default    :", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processJmsDestinations"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    reader . getAttributeValue (  0  )  ;", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton (  \" name \"  )  )  ;", "}", "final   ModelNode   connectionFactory    =    new   ModelNode (  )  ;", "connectionFactory . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "connectionFactory . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  . add ( CommonAttributes . POOLED _ CONNECTION _ FACTORY ,    name )  ;", "updates . add ( createConnectionFactory ( reader ,    connectionFactory ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["processPooledConnectionFactory"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "requireNoAttributes ( reader )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CLASS _ NAME    :", "{", "final   String   value    =    reader . getElementText (  )  ;", "CommonAttributes . REMOTING _ INTERCEPTORS . parseAndAddParameterElement ( value ,    operation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   Utils . unexpectedElement ( reader )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processRemotingInterceptors"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   security    =    new   ModelNode (  )  ;", "String   localName    =    null ;", "do    {", "reader . nextTag (  )  ;", "localName    =    reader . getLocalName (  )  ;", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   SECURITY _ SETTING    :", "final   String   match    =    reader . getAttributeValue (  0  )  ;", "final   ModelNode   addr    =    address . clone (  )  ;", "addr . add ( CommonAttributes . SECURITY _ SETTING ,    match )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( addr )  ;", "operations . add ( operation )  ;", "pSecurityRoles ( reader ,    addr ,    operations )  ;", "break ;", "}", "}    while    (  ( reader . hasNext (  )  )     &  &     ( localName . equals ( Element . SECURITY _ SETTING . getLocalName (  )  )  )     )  ;", "return   security ;", "}", "METHOD_END"], "methodName": ["processSecuritySettings"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    ( cluster )     {", "int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   ALLOW _ DIRECT _ CONNECTIONS _ ONLY    :", "{", "final   String   attrValue    =    reader . getAttributeValue ( i )  ;", "ClusterConnectionDefinition . ALLOW _ DIRECT _ CONNECTIONS _ ONLY . parseAndSetParameter ( attrValue ,    addOperation ,    reader )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedAttribute ( reader ,    i )  ;", "}", "}", "}", "} else    {", "requireNoAttributes ( reader )  ;", "}", "EnumSet < Element >    required    =    EnumSet . of ( Element . CONNECTOR _ REF )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "required . remove ( element )  ;", "switch    ( element )     {", "case   CONNECTOR _ REF    :", "{", ". handleElementText ( reader ,    element ,     ( cluster    ?     \" cluster - connection \"     :     \" bridge \"  )  ,    addOperation )  ;", "break ;", "}", "default    :", "{", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "if    (  !  ( required . isEmpty (  )  )  )     {", "throw   missingRequired ( reader ,    required )  ;", "}", "}", "METHOD_END"], "methodName": ["processStaticConnectors"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add ( CommonAttributes . SUBSYSTEM ,    Extension . SUBSYSTEM _ NAME )  ;", "address . protect (  )  ;", "final   ModelNode   subsystemAdd    =    new   ModelNode (  )  ;", "subsystemAdd . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "subsystemAdd . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address )  ;", "list . add ( subsystemAdd )  ;", "final   Namespace   schemaVer    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "switch    ( schemaVer )     {", "case   MESSAGING _  1  _  0     :", "processHornetQServer ( reader ,    address ,    list ,    schemaVer )  ;", "break ;", "case   MESSAGING _  1  _  1     :", "case   MESSAGING _  1  _  2     :", "case   MESSAGING _  1  _  3     :", "case   MESSAGING _  1  _  4     :", "case   MESSAGING _  1  _  5     :", "case   MESSAGING _  2  _  0     :", "case   MESSAGING _  3  _  0     :", "processHornetQServers ( reader ,    address ,    list )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "METHOD_END"], "methodName": ["readElement"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "reader . getElementText (  )  ;", "}", "METHOD_END"], "methodName": ["skipElementText"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "throw   MessagingLogger . ROOT _ LOGGER . ignoringUnhandledElement ( element ,    reader . getLocation (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["unhandledElement"], "fileName": "org.jboss.as.messaging.MessagingSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   hornetqServer    =    builder . addChildResource ( PathElement . pathElement ( CommonAttributes . HORNETQ _ SERVER )  )  ;", ". rejectDefinedAttributeWithDefaultValue ( hornetqServer ,    CommonAttributes . OVERRIDE _ IN _ VM _ SECURITY )  ;", "hornetqServer . rejectChildResource ( HTTPAcceptorDefinition . PATH )  ;", "hornetqServer . rejectChildResource ( PathElement . pathElement ( CommonAttributes . HTTP _ CONNECTOR )  )  ;", "ResourceTransformationDescriptionBuilder   addressSetting    =    hornetqServer . addChildResource ( AddressSettingDefinition . PATH )  ;", ". rejectDefinedAttributeWithDefaultValue ( addressSetting ,    AddressSettingDefinition . SLOW _ CONSUMER _ CHECK _ PERIOD ,    AddressSettingDefinition . SLOW _ CONSUMER _ POLICY ,    AddressSettingDefinition . SLOW _ CONSUMER _ THRESHOLD )  ;", "}", "METHOD_END"], "methodName": ["buildTransformers1_3_0"], "fileName": "org.jboss.as.messaging.MessagingTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   hornetqServer    =    builder . addChildResource ( PathElement . pathElement ( CommonAttributes . HORNETQ _ SERVER )  )  ;", ". renameAttribute ( hornetqServer ,    CommonAttributes . STATISTICS _ ENABLED ,    CommonAttributes . MESSAGE _ COUNTER _ ENABLED )  ;", "ResourceTransformationDescriptionBuilder   bridge    =    hornetqServer . addChildResource ( BridgeDefinition . PATH )  ;", ". rejectDefinedAttributeWithDefaultValue ( bridge ,    BridgeDefinition . RECONNECT _ ATTEMPTS _ ON _ SAME _ NODE ,    BridgeDefinition . INITIAL _ CONNECT _ ATTEMPTS )  ;", "ResourceTransformationDescriptionBuilder   clusterConnection    =    hornetqServer . addChildResource ( ClusterConnectionDefinition . PATH )  ;", ". rejectDefinedAttributeWithDefaultValue ( clusterConnection ,    ClusterConnectionDefinition . INITIAL _ CONNECT _ ATTEMPTS )  ;", "ResourceTransformationDescriptionBuilder   addressSetting    =    hornetqServer . addChildResource ( AddressSettingDefinition . PATH )  ;", ". rejectDefinedAttributeWithDefaultValue ( addressSetting ,    AddressSettingDefinition . EXPIRY _ DELAY )  ;", "}", "METHOD_END"], "methodName": ["buildTransformers1_4_0"], "fileName": "org.jboss.as.messaging.MessagingTransformers"}, {"methodBody": ["METHOD_START", "{", "ResourceTransformationDescriptionBuilder   hornetqServer    =    builder . addChildResource ( PathElement . pathElement ( CommonAttributes . HORNETQ _ SERVER )  )  ;", "ResourceTransformationDescriptionBuilder   addressSetting    =    hornetqServer . addChildResource ( AddressSettingDefinition . PATH )  ;", ". rejectDefinedAttributeWithDefaultValue ( addressSetting ,    AddressSettingDefinition . MAX _ REDELIVERY _ DELAY ,    AddressSettingDefinition . REDELIVERY _ MULTIPLIER )  ;", "ResourceTransformationDescriptionBuilder   bridge    =    hornetqServer . addChildResource ( BridgeDefinition . PATH )  ;", "bridge . getAttributeBuilder (  )  . setValueConverter ( new    . DoubleToBigDecimalConverter (  )  ,    CommonAttributes . RETRY _ INTERVAL _ MULTIPLIER )  ;", "ResourceTransformationDescriptionBuilder   clusterConnection    =    hornetqServer . addChildResource ( ClusterConnectionDefinition . PATH )  ;", "clusterConnection . getAttributeBuilder (  )  . setValueConverter ( new    . DoubleToBigDecimalConverter (  )  ,    CommonAttributes . RETRY _ INTERVAL _ MULTIPLIER )  ;", "ResourceTransformationDescriptionBuilder   connectionFactory    =    hornetqServer . addChildResource ( ConnectionFactoryDefinition . PATH )  ;", "connectionFactory . getAttributeBuilder (  )  . setValueConverter ( new    . DoubleToBigDecimalConverter (  )  ,    CommonAttributes . RETRY _ INTERVAL _ MULTIPLIER )  ;", "ResourceTransformationDescriptionBuilder   pooledConnectionFactory    =    hornetqServer . addChildResource ( PooledConnectionFactoryDefinition . PATH )  ;", "pooledConnectionFactory . getAttributeBuilder (  )  . setValueConverter ( new    . DoubleToBigDecimalConverter (  )  ,    CommonAttributes . RETRY _ INTERVAL _ MULTIPLIER )  ;", "}", "METHOD_END"], "methodName": ["buildTransformers2_1_0"], "fileName": "org.jboss.as.messaging.MessagingTransformers"}, {"methodBody": ["METHOD_START", "{", "ChainedTransformationDescriptionBuilder   chainedBuilder    =    Factory . createChainedSubystemInstance ( subsystem . getSubsystemVersion (  )  )  ;", ". buildTransformers 2  _  1  _  0  ( chainedBuilder . createBuilder ( subsystem . getSubsystemVersion (  )  ,    MessagingExtension . VERSION _  2  _  1  _  0  )  )  ;", ". buildTransformers 2  _  0  _  0  ( chainedBuilder . createBuilder ( MessagingExtension . VERSION _  2  _  1  _  0  ,    MessagingExtension . VERSION _  2  _  0  _  0  )  )  ;", ". buildTransformers 1  _  4  _  0  ( chainedBuilder . createBuilder ( MessagingExtension . VERSION _  2  _  0  _  0  ,    MessagingExtension . VERSION _  1  _  4  _  0  )  )  ;", ". buildTransformers 1  _  3  _  0  ( chainedBuilder . createBuilder ( MessagingExtension . VERSION _  1  _  4  _  0  ,    MessagingExtension . VERSION _  1  _  3  _  0  )  )  ;", "chainedBuilder . buildAndRegister ( subsystem ,    new   ModelVersion [  ]  {    MessagingExtension . VERSION _  1  _  3  _  0  ,    MessagingExtension . VERSION _  1  _  4  _  0  ,    MessagingExtension . VERSION _  2  _  0  _  0  ,    MessagingExtension . VERSION _  2  _  1  _  0     }  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers"], "fileName": "org.jboss.as.messaging.MessagingTransformers"}, {"methodBody": ["METHOD_START", "{", "for    ( AttributeDefinition   attr    :    attrs )     {", "builder . getAttributeBuilder (  )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( attr . getDefaultValue (  )  )  ,    attr )  . addRejectCheck ( DEFINED ,    attr )  ;", "}", "}", "METHOD_END"], "methodName": ["rejectDefinedAttributeWithDefaultValue"], "fileName": "org.jboss.as.messaging.MessagingTransformers"}, {"methodBody": ["METHOD_START", "{", "builder . getAttributeBuilder (  )  . addRename ( attribute ,    alias . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["renameAttribute"], "fileName": "org.jboss.as.messaging.MessagingTransformers"}, {"methodBody": ["METHOD_START", "{", "for    ( ConnectionFactoryAttribute   attribute    :    PooledConnectionFactoryDefinition . ATTRIBUTES )     {", "if    (  ( attribute . isInboundConfig (  )  )     &  &     ( pcf . hasDefined ( attribute . getDefinition (  )  . getName (  )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasDefinedInboundConfigAttributes"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "final   ModelNode   value    =    property . getValue (  )  ;", "RemoteTransportDefinition . SOCKET _ BINDING . marshallAsAttribute ( value ,    writer )  ;", "InVMTransportDefinition . SERVER _ ID . marshallAsAttribute ( value ,    writer )  ;", ". writeTransportParam ( writer ,    value . get ( CommonAttributes . PARAM )  )  ;", "CommonAttributes . FACTORY _ CLASS . marshallAsElement ( value ,    writer )  ;", "}", "METHOD_END"], "methodName": ["writeAcceptorContent"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( node . hasDefined ( CommonAttributes . ACCEPTOR )  )     |  |     ( node . hasDefined ( CommonAttributes . REMOTE _ ACCEPTOR )  )  )     |  |     ( node . hasDefined ( CommonAttributes . IN _ VM _ ACCEPTOR )  )  )     {", "writer . writeStartElement ( Element . ACCEPTORS . getLocalName (  )  )  ;", "if    ( node . hasDefined ( CommonAttributes . HTTP _ ACCEPTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . HTTP _ ACCEPTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . HTTP _ ACCEPTOR . getLocalName (  )  )  ;", "HTTPAcceptorDefinition . HTTP _ LISTENER . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", ". writeAcceptorContent ( writer ,    property )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( node . hasDefined ( CommonAttributes . REMOTE _ ACCEPTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . REMOTE _ ACCEPTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . NETTY _ ACCEPTOR . getLocalName (  )  )  ;", ". writeAcceptorContent ( writer ,    property )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( node . hasDefined ( CommonAttributes . IN _ VM _ ACCEPTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . IN _ VM _ ACCEPTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . IN _ VM _ ACCEPTOR . getLocalName (  )  )  ;", ". writeAcceptorContent ( writer ,    property )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( node . hasDefined ( CommonAttributes . ACCEPTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . ACCEPTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . ACCEPTOR . getLocalName (  )  )  ;", ". writeAcceptorContent ( writer ,    property )  ;", "writer . writeEndElement (  )  ;", "}", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAcceptors"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . ADDRESS _ SETTINGS . getLocalName (  )  )  ;", "for    ( Property   matchSetting    :    properties )     {", "writer . writeStartElement ( Element . ADDRESS _ SETTING . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . MATCH . getLocalName (  )  ,    matchSetting . getName (  )  )  ;", "final   ModelNode   setting    =    matchSetting . getValue (  )  ;", "for    ( AttributeDefinition   attribute    :    AddressSettingDefinition . ATTRIBUTES )     {", "attribute . marshallAsElement ( setting ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAddressSettings"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . BRIDGES . getLocalName (  )  )  ;", "for    ( final   Property   property    :    node . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . BRIDGE . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( AttributeDefinition   attribute    :    BridgeDefinition . ATTRIBUTES )     {", "if    (  ( CommonAttributes . FILTER )     =  =    attribute )     {", ". writeFilter ( writer ,    property . getValue (  )  )  ;", "} else    {", "attribute . marshallAsElement ( property . getValue (  )  ,    writer )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeBridges"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . BROADCAST _ GROUPS . getLocalName (  )  )  ;", "for    ( final   Property   property    :    properties )     {", "writer . writeStartElement ( Element . BROADCAST _ GROUP . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( AttributeDefinition   attribute    :    BroadcastGroupDefinition . ATTRIBUTES )     {", "attribute . marshallAsElement ( property . getValue (  )  ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeBroadcastGroups"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . CLUSTER _ CONNECTIONS . getLocalName (  )  )  ;", "for    ( final   Property   property    :    node . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . CLUSTER _ CONNECTION . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "final   ModelNode   cluster    =    property . getValue (  )  ;", "for    ( AttributeDefinition   attribute    :    ClusterConnectionDefinition . ATTRIBUTES )     {", "if    ( attribute    =  =     ( ClusterConnectionDefinition . ALLOW _ DIRECT _ CONNECTIONS _ ONLY )  )     {", "continue ;", "}", "if    ( attribute    =  =     ( ClusterConnectionDefinition . CONNECTOR _ REFS )  )     {", "if    ( attribute . isMarshallable ( cluster )  )     {", "writer . writeStartElement ( Element . STATIC _ CONNECTORS . getLocalName (  )  )  ;", "ClusterConnectionDefinition . ALLOW _ DIRECT _ CONNECTIONS _ ONLY . marshallAsAttribute ( cluster ,    writer )  ;", "ClusterConnectionDefinition . CONNECTOR _ REFS . marshallAsElement ( cluster ,    writer )  ;", "writer . writeEndElement (  )  ;", "} else", "if    ( ClusterConnectionDefinition . ALLOW _ DIRECT _ CONNECTIONS _ ONLY . isMarshallable ( cluster )  )     {", "writer . writeEmptyElement ( Element . STATIC _ CONNECTORS . getLocalName (  )  )  ;", "ClusterConnectionDefinition . ALLOW _ DIRECT _ CONNECTIONS _ ONLY . marshallAsAttribute ( cluster ,    writer )  ;", "}", "} else    {", "attribute . marshallAsElement ( property . getValue (  )  ,    writer )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeClusterConnections"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "if    (  ( node . asInt (  )  )     >     0  )     {", "for    ( String   name    :    node . keys (  )  )     {", "final   ModelNode   factory    =    node . get ( name )  ;", "if    ( factory . isDefined (  )  )     {", "w . writeStartElement ( Element . CONNECTION _ FACTORY . getLocalName (  )  )  ;", "w . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    name )  ;", "for    ( AttributeDefinition   attribute    :    ConnectionFactoryDefinition . ATTRIBUTES )     {", "attribute . marshallAsElement ( factory ,    w )  ;", "}", "w . writeEndElement (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writeConnectionFactories"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . CONNECTOR _ SERVICES . getLocalName (  )  )  ;", "for    ( final   Property   property    :    node . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . CONNECTOR _ SERVICE . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "final   ModelNode   service    =    property . getValue (  )  ;", "for    ( AttributeDefinition   attribute    :    ConnectorServiceDefinition . ATTRIBUTES )     {", "attribute . marshallAsElement ( property . getValue (  )  ,    writer )  ;", "}", "if    ( service . hasDefined ( CommonAttributes . PARAM )  )     {", "for    ( Property   param    :    service . get ( CommonAttributes . PARAM )  . asPropertyList (  )  )     {", "writer . writeEmptyElement ( Element . PARAM . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . KEY . getLocalName (  )  ,    param . getName (  )  )  ;", "writer . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    param . getValue (  )  . get ( ConnectorServiceParamDefinition . VALUE . getName (  )  )  . asString (  )  )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeConnectorServices"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( node . hasDefined ( CommonAttributes . CONNECTOR )  )     |  |     ( node . hasDefined ( CommonAttributes . REMOTE _ CONNECTOR )  )  )     |  |     ( node . hasDefined ( CommonAttributes . IN _ VM _ CONNECTOR )  )  )     {", "writer . writeStartElement ( Element . CONNECTORS . getLocalName (  )  )  ;", "if    ( node . hasDefined ( CommonAttributes . HTTP _ CONNECTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . HTTP _ CONNECTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . HTTP _ CONNECTOR . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "HTTPConnectorDefinition . SOCKET _ BINDING . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", ". writeTransportParam ( writer ,    property . getValue (  )  . get ( CommonAttributes . PARAM )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( node . hasDefined ( CommonAttributes . REMOTE _ CONNECTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . REMOTE _ CONNECTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . NETTY _ CONNECTOR . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "RemoteTransportDefinition . SOCKET _ BINDING . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", ". writeTransportParam ( writer ,    property . getValue (  )  . get ( CommonAttributes . PARAM )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( node . hasDefined ( CommonAttributes . IN _ VM _ CONNECTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . IN _ VM _ CONNECTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . IN _ VM _ CONNECTOR . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "InVMTransportDefinition . SERVER _ ID . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", ". writeTransportParam ( writer ,    property . getValue (  )  . get ( CommonAttributes . PARAM )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( node . hasDefined ( CommonAttributes . CONNECTOR )  )     {", "for    ( final   Property   property    :    node . get ( CommonAttributes . CONNECTOR )  . asPropertyList (  )  )     {", "writer . writeStartElement ( Element . CONNECTOR . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "GenericTransportDefinition . SOCKET _ BINDING . marshallAsAttribute ( property . getValue (  )  ,    writer )  ;", ". writeTransportParam ( writer ,    property . getValue (  )  . get ( CommonAttributes . PARAM )  )  ;", "CommonAttributes . FACTORY _ CLASS . marshallAsElement ( property . getValue (  )  ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeConnectors"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "final   String   localName    =    element . getLocalName (  )  ;", "if    ( node . hasDefined ( localName )  )     {", "final   ModelNode   localNode    =    node . get ( localName )  ;", "if    (  ( PathDefinition . RELATIVE _ TO . isMarshallable ( localNode )  )     |  |     ( PathDefinition . PATHS . get ( localName )  . isMarshallable ( localNode )  )  )     {", "w . writeEmptyElement ( localName )  ;", "PathDefinition . PATHS . get ( localName )  . marshallAsAttribute ( node . get ( localName )  ,    w )  ;", "PathDefinition . RELATIVE _ TO . marshallAsAttribute ( node . get ( localName )  ,    w )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeDirectory"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . DISCOVERY _ GROUPS . getLocalName (  )  )  ;", "for    ( final   Property   property    :    properties )     {", "writer . writeStartElement ( Element . DISCOVERY _ GROUP . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( AttributeDefinition   attribute    :    DiscoveryGroupDefinition . ATTRIBUTES )     {", "attribute . marshallAsElement ( property . getValue (  )  ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDiscoveryGroups"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . DIVERTS . getLocalName (  )  )  ;", "for    ( final   Property   property    :    properties )     {", "writer . writeStartElement ( Element . DIVERT . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    property . getName (  )  )  ;", "for    ( AttributeDefinition   attribute    :    DivertDefinition . ATTRIBUTES )     {", "if    (  ( CommonAttributes . FILTER )     =  =    attribute )     {", ". writeFilter ( writer ,    property . getValue (  )  )  ;", "} else    {", "attribute . marshallAsElement ( property . getValue (  )  ,    writer )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDiverts"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( node . hasDefined ( CommonAttributes . FILTER . getName (  )  )  )     {", "w . writeEmptyElement ( CommonAttributes . FILTER . getXmlName (  )  )  ;", "w . writeAttribute ( CommonAttributes . STRING ,    node . get ( CommonAttributes . FILTER . getName (  )  )  . asString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFilter"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "boolean   wroteHandler    =    false ;", "for    ( Property   handler    :    node . asPropertyList (  )  )     {", "if    ( wroteHandler )     {", "throw   MessagingLogger . ROOT _ LOGGER . multipleChildrenFound ( CommonAttributes . GROUPING _ HANDLER )  ;", "} else    {", "wroteHandler    =    true ;", "}", "writer . writeStartElement ( Element . GROUPING _ HANDLER . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    handler . getName (  )  )  ;", "final   ModelNode   resourceModel    =    handler . getValue (  )  ;", "for    ( AttributeDefinition   attr    :    GroupingHandlerDefinition . ATTRIBUTES )     {", "attr . marshallAsElement ( resourceModel ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeGroupingHandler"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . HORNETQ _ SERVER . getLocalName (  )  )  ;", "if    (  !  ( CommonAttributes . DEFAULT . equals ( serverName )  )  )     {", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    serverName )  ;", "}", "for    ( AttributeDefinition   simpleAttribute    :    CommonAttributes . SIMPLE _ ROOT _ RESOURCE _ ATTRIBUTES )     {", "simpleAttribute . marshallAsElement ( node ,    writer )  ;", "}", "final   ModelNode   paths    =    node . get ( PATH )  ;", ". writeDirectory ( writer ,    Element . PAGING _ DIRECTORY ,    paths )  ;", ". writeDirectory ( writer ,    Element . BINDINGS _ DIRECTORY ,    paths )  ;", ". writeDirectory ( writer ,    Element . JOURNAL _ DIRECTORY ,    paths )  ;", ". writeDirectory ( writer ,    Element . LARGE _ MESSAGES _ DIRECTORY ,    paths )  ;", ". writeNewLine ( writer )  ;", ". writeConnectors ( writer ,    node )  ;", ". writeAcceptors ( writer ,    node )  ;", ". writeBroadcastGroups ( writer ,    node . get ( CommonAttributes . BROADCAST _ GROUP )  )  ;", ". writeDiscoveryGroups ( writer ,    node . get ( CommonAttributes . DISCOVERY _ GROUP )  )  ;", ". writeDiverts ( writer ,    node . get ( CommonAttributes . DIVERT )  )  ;", ". writeQueues ( writer ,    node . get ( CommonAttributes . QUEUE )  )  ;", ". writeBridges ( writer ,    node . get ( CommonAttributes . BRIDGE )  )  ;", ". writeClusterConnections ( writer ,    node . get ( CommonAttributes . CLUSTER _ CONNECTION )  )  ;", ". writeGroupingHandler ( writer ,    node . get ( CommonAttributes . GROUPING _ HANDLER )  )  ;", ". writeSecuritySettings ( writer ,    node . get ( CommonAttributes . SECURITY _ SETTING )  )  ;", ". writeAddressSettings ( writer ,    node . get ( CommonAttributes . ADDRESS _ SETTING )  )  ;", ". writeConnectorServices ( writer ,    node . get ( CommonAttributes . CONNECTOR _ SERVICE )  )  ;", "if    (  ( node . hasDefined ( CommonAttributes . CONNECTION _ FACTORY )  )     |  |     ( node . hasDefined ( CommonAttributes . POOLED _ CONNECTION _ FACTORY )  )  )     {", "ModelNode   cf    =    node . get ( CommonAttributes . CONNECTION _ FACTORY )  ;", "ModelNode   pcf    =    node . get ( CommonAttributes . POOLED _ CONNECTION _ FACTORY )  ;", "boolean   hasCf    =     ( cf . isDefined (  )  )     &  &     (  ( cf . keys (  )  . size (  )  )     >     0  )  ;", "boolean   hasPcf    =     ( pcf . isDefined (  )  )     &  &     (  ( pcf . keys (  )  . size (  )  )     >     0  )  ;", "if    ( hasCf    |  |    hasPcf )     {", "writer . writeStartElement ( CommonAttributes . JMS _ CONNECTION _ FACTORIES )  ;", ". writeConnectionFactories ( writer ,    cf )  ;", ". writePooledConnectionFactories ( writer ,    pcf )  ;", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "if    (  ( node . hasDefined ( CommonAttributes . JMS _ QUEUE )  )     |  |     ( node . hasDefined ( CommonAttributes . JMS _ TOPIC )  )  )     {", "ModelNode   queue    =    node . get ( CommonAttributes . JMS _ QUEUE )  ;", "ModelNode   topic    =    node . get ( CommonAttributes . JMS _ TOPIC )  ;", "boolean   hasQueue    =     ( queue . isDefined (  )  )     &  &     (  ( queue . keys (  )  . size (  )  )     >     0  )  ;", "boolean   hasTopic    =     ( topic . isDefined (  )  )     &  &     (  ( topic . keys (  )  . size (  )  )     >     0  )  ;", "if    ( hasQueue    |  |    hasTopic )     {", "writer . writeStartElement ( CommonAttributes . JMS _ DESTINATIONS )  ;", ". writeJmsQueues ( writer ,    node . get ( CommonAttributes . JMS _ QUEUE )  )  ;", ". writeTopics ( writer ,    node . get ( CommonAttributes . JMS _ TOPIC )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeHornetQServer"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeStartElement ( Element . JMS _ BRIDGE . getLocalName (  )  )  ;", "if    (  !  ( CommonAttributes . DEFAULT . equals ( bridgeName )  )  )     {", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    bridgeName )  ;", "}", "JMSBridgeDefinition . MODULE . marshallAsAttribute ( value ,    writer )  ;", "writer . writeStartElement ( Element . SOURCE . getLocalName (  )  )  ;", "for    ( AttributeDefinition   attr    :    JMSBridgeDefinition . JMS _ SOURCE _ ATTRIBUTES )     {", "attr . marshallAsElement ( value ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "writer . writeStartElement ( Element . TARGET . getLocalName (  )  )  ;", "for    ( AttributeDefinition   attr    :    JMSBridgeDefinition . JMS _ TARGET _ ATTRIBUTES )     {", "attr . marshallAsElement ( value ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "for    ( AttributeDefinition   attr    :    JMSBridgeDefinition . JMS _ BRIDGE _ ATTRIBUTES )     {", "if    ( attr    =  =     ( JMSBridgeDefinition . MODULE )  )     {", "continue ;", "}", "attr . marshallAsElement ( value ,    writer )  ;", "}", "writer . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writeJmsBridge"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "if    (  ( node . asInt (  )  )     >     0  )     {", "for    ( String   name    :    node . keys (  )  )     {", "final   ModelNode   queue    =    node . get ( name )  ;", "if    ( queue . isDefined (  )  )     {", "w . writeStartElement ( Element . JMS _ QUEUE . getLocalName (  )  )  ;", "w . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    name )  ;", "for    ( AttributeDefinition   attribute    :    JMSQueueDefinition . ATTRIBUTES )     {", "attribute . marshallAsElement ( queue ,    w )  ;", "}", "w . writeEndElement (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writeJmsQueues"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "writer . writeCharacters ( MessagingXMLWriter . NEW _ LINE ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["writeNewLine"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( roles . size (  )  )     =  =     0  )     {", "return ;", "}", "w . writeStartElement ( Element . PERMISSION _ ELEMENT _ NAME . getLocalName (  )  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( String   role    :    roles )     {", "if    (  ( sb . length (  )  )     >     0  )     {", "sb . append (  \"     \"  )  ;", "}", "sb . append ( role )  ;", "}", "w . writeAttribute ( Attribute . TYPE _ ATTR _ NAME . getLocalName (  )  ,    type )  ;", "w . writeAttribute ( Attribute . ROLES _ ATTR _ NAME . getLocalName (  )  ,    sb . toString (  )  )  ;", "w . writeEndElement (  )  ;", "}", "METHOD_END"], "methodName": ["writePermission"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "if    (  ( node . asInt (  )  )     >     0  )     {", "for    ( String   name    :    node . keys (  )  )     {", "final   ModelNode   factory    =    node . get ( name )  ;", "if    ( factory . isDefined (  )  )     {", "writer . writeStartElement ( Element . POOLED _ CONNECTION _ FACTORY . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    name )  ;", "if    (  . hasDefinedInboundConfigAttributes ( factory )  )     {", "writer . writeStartElement ( Element . INBOUND _ CONFIG . getLocalName (  )  )  ;", "for    ( ConnectionFactoryAttribute   attribute    :    PooledConnectionFactoryDefinition . ATTRIBUTES )     {", "if    ( attribute . isInboundConfig (  )  )     {", "attribute . getDefinition (  )  . marshallAsElement ( factory ,    writer )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "for    ( ConnectionFactoryAttribute   attribute    :    PooledConnectionFactoryDefinition . ATTRIBUTES )     {", "if    (  !  ( attribute . isInboundConfig (  )  )  )     {", "attribute . getDefinition (  )  . marshallAsElement ( factory ,    writer )  ;", "}", "}", "writer . writeEndElement (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writePooledConnectionFactories"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "if    (  ( node . asInt (  )  )     >     0  )     {", "writer . writeStartElement ( Element . CORE _ QUEUES . getLocalName (  )  )  ;", "for    ( String   queueName    :    node . keys (  )  )     {", "writer . writeStartElement ( Element . QUEUE . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    queueName )  ;", "final   ModelNode   queue    =    node . get ( queueName )  ;", "QueueDefinition . ADDRESS . marshallAsElement ( queue ,    writer )  ;", ". writeFilter ( writer ,    queue )  ;", "CommonAttributes . DURABLE . marshallAsElement ( queue ,    writer )  ;", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeQueues"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "List < Property >    properties    =    node . asPropertyList (  )  ;", "if    (  !  ( properties . isEmpty (  )  )  )     {", "writer . writeStartElement ( Element . SECURITY _ SETTINGS . getLocalName (  )  )  ;", "for    ( Property   matchRoles    :    properties )     {", "writer . writeStartElement ( Element . SECURITY _ SETTING . getLocalName (  )  )  ;", "writer . writeAttribute ( Attribute . MATCH . getLocalName (  )  ,    matchRoles . getName (  )  )  ;", "if    ( matchRoles . getValue (  )  . hasDefined ( CommonAttributes . ROLE )  )     {", "ArrayList < String >    send    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    consume    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    createDurableQueue    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    deleteDurableQueue    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    createNonDurableQueue    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    deleteNonDurableQueue    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    manageRoles    =    new   ArrayList < String >  (  )  ;", "for    ( Property   rolePerms    :    matchRoles . getValue (  )  . get ( CommonAttributes . ROLE )  . asPropertyList (  )  )     {", "final   String   role    =    rolePerms . getName (  )  ;", "final   ModelNode   perms    =    rolePerms . getValue (  )  ;", "if    ( perms . get ( SecurityRoleDefinition . SEND . getName (  )  )  . asBoolean ( false )  )     {", "send . add ( role )  ;", "}", "if    ( perms . get ( SecurityRoleDefinition . CONSUME . getName (  )  )  . asBoolean ( false )  )     {", "consume . add ( role )  ;", "}", "if    ( perms . get ( SecurityRoleDefinition . CREATE _ DURABLE _ QUEUE . getName (  )  )  . asBoolean ( false )  )     {", "createDurableQueue . add ( role )  ;", "}", "if    ( perms . get ( SecurityRoleDefinition . DELETE _ DURABLE _ QUEUE . getName (  )  )  . asBoolean ( false )  )     {", "deleteDurableQueue . add ( role )  ;", "}", "if    ( perms . get ( SecurityRoleDefinition . CREATE _ NON _ DURABLE _ QUEUE . getName (  )  )  . asBoolean ( false )  )     {", "createNonDurableQueue . add ( role )  ;", "}", "if    ( perms . get ( SecurityRoleDefinition . DELETE _ NON _ DURABLE _ QUEUE . getName (  )  )  . asBoolean ( false )  )     {", "deleteNonDurableQueue . add ( role )  ;", "}", "if    ( perms . get ( SecurityRoleDefinition . MANAGE . getName (  )  )  . asBoolean ( false )  )     {", "manageRoles . add ( role )  ;", "}", "}", ". writePermission ( writer ,    SecurityRoleDefinition . SEND . getXmlName (  )  ,    send )  ;", ". writePermission ( writer ,    SecurityRoleDefinition . CONSUME . getXmlName (  )  ,    consume )  ;", ". writePermission ( writer ,    SecurityRoleDefinition . CREATE _ DURABLE _ QUEUE . getXmlName (  )  ,    createDurableQueue )  ;", ". writePermission ( writer ,    SecurityRoleDefinition . DELETE _ DURABLE _ QUEUE . getXmlName (  )  ,    deleteDurableQueue )  ;", ". writePermission ( writer ,    SecurityRoleDefinition . CREATE _ NON _ DURABLE _ QUEUE . getXmlName (  )  ,    createNonDurableQueue )  ;", ". writePermission ( writer ,    SecurityRoleDefinition . DELETE _ NON _ DURABLE _ QUEUE . getXmlName (  )  ,    deleteNonDurableQueue )  ;", ". writePermission ( writer ,    SecurityRoleDefinition . MANAGE . getXmlName (  )  ,    manageRoles )  ;", "}", "writer . writeEndElement (  )  ;", "}", "writer . writeEndElement (  )  ;", ". writeNewLine ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeSecuritySettings"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isDefined (  )  )  )     {", "return ;", "}", "if    (  ( node . asInt (  )  )     >     0  )     {", "for    ( String   name    :    node . keys (  )  )     {", "final   ModelNode   topic    =    node . get ( name )  ;", "if    ( topic . isDefined (  )  )     {", "w . writeStartElement ( Element . JMS _ TOPIC . getLocalName (  )  )  ;", "w . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    name )  ;", "for    ( AttributeDefinition   attribute    :    JMSTopicDefinition . ATTRIBUTES )     {", "attribute . marshallAsElement ( topic ,    w )  ;", "}", "w . writeEndElement (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writeTopics"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( param . isDefined (  )  )     {", "for    ( final   Property   parameter    :    param . asPropertyList (  )  )     {", "w . writeStartElement ( Element . PARAM . getLocalName (  )  )  ;", "w . writeAttribute ( Attribute . KEY . getLocalName (  )  ,    parameter . getName (  )  )  ;", "w . writeAttribute ( Attribute . VALUE . getLocalName (  )  ,    parameter . getValue (  )  . get ( TransportParamDefinition . VALUE . getName (  )  )  . asString (  )  )  ;", "w . writeEndElement (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeTransportParam"], "fileName": "org.jboss.as.messaging.MessagingXMLWriter"}, {"methodBody": ["METHOD_START", "{", "newAddOp . get (  \" legacy - entries \"  )  . set ( newAddOp . get ( CommonAttributes . ENTRIES )  )  ;", "newAddOp . remove ( CommonAttributes . ENTRIES )  ;", "for    ( ModelNode   legacyEntry    :    newAddOp . get (  \" legacy - entries \"  )  . asList (  )  )     {", "String   newEntry    =     ( legacyEntry . asString (  )  )     +     (  . NEW _ ENTRY _ SUFFIX )  ;", "newAddOp . get ( CommonAttributes . ENTRIES )  . add ( newEntry )  ;", "}", "}", "METHOD_END"], "methodName": ["addLegacyEntries"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "Resource   root    =    context . readResourceFromRoot ( EMPTY _ ADDRESS ,    false )  ;", "if    ( root . getChildrenNames ( ModelDescriptionConstants . EXTENSION )  . contains (  . MESSAGING _ ACTIVEMQ _ EXTENSION )  )     {", "return ;", "}", "PathAddress   extensionAddress    =    PathAddress . pathAddress ( ModelDescriptionConstants . EXTENSION ,     . MESSAGING _ ACTIVEMQ _ EXTENSION )  ;", "OperationEntry   addEntry    =    context . getRootResourceRegistration (  )  . getOperationEntry ( extensionAddress ,    ModelDescriptionConstants . ADD )  ;", "ModelNode   addOperation    =    createAddOperation ( extensionAddress )  ;", "addOperation . get ( ModelDescriptionConstants . MODULE )  . set (  . MESSAGING _ ACTIVEMQ _ MODULE )  ;", "if    ( describe )     {", "migrationOperations . put ( extensionAddress ,    addOperation )  ;", "} else    {", "context . addStep ( context . getResult (  )  . get ( extensionAddress . toString (  )  )  ,    addOperation ,    addEntry . getOperationHandler (  )  ,    Stage . MODEL )  ;", "}", "}", "METHOD_END"], "methodName": ["addMessagingActiveMQExtension"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   connector    =    connectionFactoryAddOp . get ( CommonAttributes . CONNECTOR )  ;", "if    ( connector . isDefined (  )  )     {", "PathAddress   connectionFactoryAddress    =    PathAddress . pathAddress ( connectionFactoryAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "PathElement   relativeLegacyServerAddress    =    connectionFactoryAddress . getParent (  )  . getLastElement (  )  ;", "Resource   serverResource    =    context . readResource ( PathAddress . pathAddress ( relativeLegacyServerAddress )  ,    false )  ;", "Set < String >    definedInVMConnectors    =    serverResource . getChildrenNames (  \" in - vm - connector \"  )  ;", "List < Property >    connectorProps    =    connector . asPropertyList (  )  ;", "for    ( Property   connectorProp    :    connectorProps )     {", "String   connectorName    =    connectorProp . getName (  )  ;", "if    ( definedInVMConnectors . contains ( connectorName )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["connectionFactoryIsUsingInVMConnectors"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   describeLegacySubsystem    =    createOperation ( DEFINITION ,    context . getCurrentAddress (  )  )  ;", "context . addStep ( legacyModelDescription ,    describeLegacySubsystem ,    INSTANCE ,    Stage . MODEL ,    true )  ;", "}", "METHOD_END"], "methodName": ["describeLegacyMessagingResources"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( newAddOp . hasDefined ( CommonAttributes . FAILBACK _ DELAY . getName (  )  )  )     {", "newAddOp . remove ( CommonAttributes . FAILBACK _ DELAY . getName (  )  )  ;", "warnings . add ( MLogger . ROOT _ LOGGER . couldNotMigrateFailbackDelayAttribute ( PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["discardFailbackDelay"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( addOperation . get ( legacyInterceptorsAttributeName )  . isDefined (  )  )  )     {", "return ;", "}", "warnings . add ( MessagingLogger . ROOT _ LOGGER . couldNotMigrateInterceptors ( legacyInterceptorsAttributeName )  )  ;", "addOperation . remove ( legacyInterceptorsAttributeName )  ;", "}", "METHOD_END"], "methodName": ["discardInterceptors"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( newAddOp . hasDefined ( legacyAttributeDefinition . getName (  )  )  )     {", "newAddOp . remove ( legacyAttributeDefinition . getName (  )  )  ;", "warnings . add ( MLogger . ROOT _ LOGGER . couldNotMigrateUnsupportedAttribute ( legacyAttributeDefinition . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["discardUnsupportedAttribute"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   rw    =    new   ModelNode (  )  . setEmptyList (  )  ;", "for    ( String   warning    :    warnings )     {", "rw . add ( warning )  ;", "}", "result . get (  . MIGRATION _ WARNINGS )  . set ( rw )  ;", "}", "METHOD_END"], "methodName": ["fillWarnings"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parentAddress . size (  )  )     =  =     0  )     {", "return ;", "}", "Map < PathAddress ,    ModelNode >    fixedMigrations    =    new   LinkedHashMap ( migrations )  ;", "migrations . clear (  )  ;", "for    ( Map . Entry < PathAddress ,    ModelNode >    entry    :    fixedMigrations . entrySet (  )  )     {", "PathAddress   fixedAddress    =    parentAddress . append ( entry . getKey (  )  )  ;", "entry . getValue (  )  . get ( CommonAttributes . ADDRESS )  . set ( fixedAddress . toModelNode (  )  )  ;", "migrations . put ( fixedAddress ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fixAddressesForDomainMode"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "migrateDiscoveryGroupNameAttribute ( addOperation )  ;", "}", "METHOD_END"], "methodName": ["migrateBridge"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   Collection < String >    unmigratedProperties    =    Arrays . asList ( CommonAttributes . LOCAL _ BIND _ ADDRESS . getName (  )  ,    CommonAttributes . LOCAL _ BIND _ PORT . getName (  )  ,    CommonAttributes . GROUP _ ADDRESS . getName (  )  ,    CommonAttributes . GROUP _ PORT . getName (  )  )  ;", "for    ( Property   property    :    newAddOp . asPropertyList (  )  )     {", "if    ( unmigratedProperties . contains ( property . getName (  )  )  )     {", "warnings . add ( MLogger . ROOT _ LOGGER . couldNotMigrateBroadcastGroupAttribute ( property . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  )  )  ;", "}", "}", "removePropertiesWithExpression ( newAddOp ,    warnings ,    CommonAttributes . JGROUPS _ CHANNEL . getName (  )  ,    CommonAttributes . JGROUPS _ STACK . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["migrateBroadcastGroup"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "addOperation . get (  \" connector - name \"  )  . set ( addOperation . get ( CommonAttributes . CONNECTOR _ REF _ STRING )  )  ;", "addOperation . remove ( CommonAttributes . CONNECTOR _ REF _ STRING )  ;", "ModelNode   forwardWhenNoConsumers    =    addOperation . get ( ClusterConnectionDefinition . FORWARD _ WHEN _ NO _ CONSUMERS . getName (  )  )  ;", "if    (  ( forwardWhenNoConsumers . getType (  )  )     =  =     ( EXPRESSION )  )     {", "warnings . add ( MessagingLogger . ROOT _ LOGGER . couldNotMigrateResourceAttributeWithExpression ( ClusterConnectionDefinition . FORWARD _ WHEN _ NO _ CONSUMERS . getName (  )  ,    PathAddress . pathAddress ( addOperation . get ( ModelDescriptionConstants . OP _ ADDR )  )  )  )  ;", "} else    {", "boolean   value    =    forwardWhenNoConsumers . asBoolean ( ClusterConnectionDefinition . FORWARD _ WHEN _ NO _ CONSUMERS . getDefaultValue (  )  . asBoolean (  )  )  ;", "String   messageLoadBalancingType    =     ( value )     ?     \" STRICT \"     :     \" ON _ DEMAND \"  ;", "addOperation . get (  \" message - load - balancing - type \"  )  . set ( messageLoadBalancingType )  ;", "}", "addOperation . remove ( ClusterConnectionDefinition . FORWARD _ WHEN _ NO _ CONSUMERS . getName (  )  )  ;", "migrateDiscoveryGroupNameAttribute ( addOperation )  ;", "}", "METHOD_END"], "methodName": ["migrateClusterConnection"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "migrateConnectorAttribute ( addOperation )  ;", "migrateDiscoveryGroupNameAttribute ( addOperation )  ;", "if    (  !  ( entrySuffix . isEmpty (  )  )  )     {", "List < ModelNode >    entries    =    addOperation . get ( CommonAttributes . ENTRIES )  . asList (  )  ;", "addOperation . remove ( CommonAttributes . ENTRIES )  ;", "for    ( ModelNode   entry    :    entries )     {", "String   newEntry    =     ( entry . asString (  )  )     +    entrySuffix ;", "addOperation . get ( CommonAttributes . ENTRIES )  . add ( newEntry )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["migrateConnectionFactory"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   connector    =    addOperation . get ( CommonAttributes . CONNECTOR )  ;", "if    ( connector . isDefined (  )  )     {", "List < Property >    connectorProps    =    connector . asPropertyList (  )  ;", "for    ( Property   connectorProp    :    connectorProps )     {", "addOperation . get (  \" connectors \"  )  . add ( connectorProp . getName (  )  )  ;", "}", "addOperation . remove ( CommonAttributes . CONNECTOR )  ;", "}", "}", "METHOD_END"], "methodName": ["migrateConnectorAttribute"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( String   property    :    Arrays . asList ( CommonAttributes . LOCAL _ BIND _ ADDRESS . getName (  )  ,    CommonAttributes . GROUP _ ADDRESS . getName (  )  ,    CommonAttributes . GROUP _ PORT . getName (  )  )  )     {", "if    ( newAddOp . has ( property )  )     {", "newAddOp . remove ( property )  ;", "warnings . add ( MLogger . ROOT _ LOGGER . couldNotMigrateDiscoveryGroupAttribute ( property ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  )  )  ;", "}", "}", "removePropertiesWithExpression ( newAddOp ,    warnings ,    CommonAttributes . JGROUPS _ CHANNEL . getName (  )  ,    CommonAttributes . JGROUPS _ STACK . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["migrateDiscoveryGroup"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   discoveryGroup    =    addOperation . get ( CommonAttributes . DISCOVERY _ GROUP _ NAME )  ;", "if    ( discoveryGroup . isDefined (  )  )     {", "addOperation . get (  \" discovery - group \"  )  . set ( discoveryGroup )  ;", "addOperation . remove ( CommonAttributes . DISCOVERY _ GROUP _ NAME )  ;", "}", "}", "METHOD_END"], "methodName": ["migrateDiscoveryGroupNameAttribute"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "String   factoryClass    =    addOperation . get ( CommonAttributes . FACTORY _ CLASS . getName (  )  )  . asString (  )  ;", "final   String   newFactoryClass ;", "switch    ( factoryClass )     {", "case    . HORNETQ _ NETTY _ ACCEPTOR _ FACTORY    :", "newFactoryClass    =     . ARTEMIS _ NETTY _ ACCEPTOR _ FACTORY ;", "break ;", "case    . HORNETQ _ NETTY _ CONNECTOR _ FACTORY    :", "newFactoryClass    =     . ARTEMIS _ NETTY _ CONNECTOR _ FACTORY ;", "break ;", "default    :", "newFactoryClass    =    factoryClass ;", "}", "addOperation . get ( CommonAttributes . FACTORY _ CLASS . getName (  )  )  . set ( newFactoryClass )  ;", "}", "METHOD_END"], "methodName": ["migrateGenericTransport"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "PathAddress   serverAddress    =    PathAddress . pathAddress ( serverAddOperation . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "ModelNode   sharedStoreAttr    =    serverAddOperation . get ( CommonAttributes . SHARED _ STORE . getName (  )  )  ;", "ModelNode   backupAttr    =    serverAddOperation . get ( CommonAttributes . BACKUP . getName (  )  )  ;", "if    (  (  ( sharedStoreAttr . getType (  )  )     =  =     ( EXPRESSION )  )     |  |     (  ( backupAttr . getType (  )  )     =  =     ( EXPRESSION )  )  )     {", "warnings . add ( MessagingLogger . ROOT _ LOGGER . couldNotMigrateHA ( legacyAddress )  )  ;", "return ;", "}", "boolean   sharedStore    =     ( sharedStoreAttr . isDefined (  )  )     ?    sharedStoreAttr . asBoolean (  )     :    CommonAttributes . SHARED _ STORE . getDefaultValue (  )  . asBoolean (  )  ;", "boolean   backup    =     ( backupAttr . isDefined (  )  )     ?    backupAttr . asBoolean (  )     :    CommonAttributes . BACKUP . getDefaultValue (  )  . asBoolean (  )  ;", "ModelNode   haPolicyAddOperation    =    createAddOperation (  )  ;", "final   PathAddress   haPolicyAddress ;", "if    ( sharedStore )     {", "if    ( backup )     {", "haPolicyAddress    =    serverAddress . append (  . HA _ POLICY ,     \" shared - store - slave \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . ALLOW _ FAILBACK ,     \" allow - failback \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . FAILOVER _ ON _ SHUTDOWN ,     \" failover - on - server - shutdown \"  )  ;", "discardFailbackDelay ( serverAddOperation ,    warnings )  ;", "} else    {", "haPolicyAddress    =    serverAddress . append (  . HA _ POLICY ,     \" shared - store - master \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . FAILOVER _ ON _ SHUTDOWN ,     \" failover - on - server - shutdown \"  )  ;", "discardFailbackDelay ( serverAddOperation ,    warnings )  ;", "}", "} else    {", "if    ( backup )     {", "haPolicyAddress    =    serverAddress . append (  . HA _ POLICY ,     \" replication - slave \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . ALLOW _ FAILBACK ,     \" allow - failback \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . MAX _ SAVED _ REPLICATED _ JOURNAL _ SIZE ,     \" max - saved - replicated - journal - size \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . BACKUP _ GROUP _ NAME ,     \" group - name \"  )  ;", "discardFailbackDelay ( serverAddOperation ,    warnings )  ;", "} else    {", "haPolicyAddress    =    serverAddress . append (  . HA _ POLICY ,     \" replication - master \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . CHECK _ FOR _ LIVE _ SERVER ,     \" check - for - live - server \"  )  ;", "setAndDiscard ( haPolicyAddOperation ,    serverAddOperation ,    CommonAttributes . BACKUP _ GROUP _ NAME ,     \" group - name \"  )  ;", "}", "}", "haPolicyAddOperation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( haPolicyAddress . toModelNode (  )  )  ;", "newAddOperations . put ( haPolicyAddress ,    haPolicyAddOperation )  ;", "}", "METHOD_END"], "methodName": ["migrateHAPolicy"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "migrateConnectorAttribute ( addOperation )  ;", "migrateDiscoveryGroupNameAttribute ( addOperation )  ;", "addOperation . get (  \" allow - local - transactions \"  )  . set ( new   ModelNode ( true )  )  ;", "}", "METHOD_END"], "methodName": ["migratePooledConnectionFactory"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "discardInterceptors ( addOperation ,    CommonAttributes . REMOTING _ INTERCEPTORS . getName (  )  ,    warnings )  ;", "discardInterceptors ( addOperation ,    CommonAttributes . REMOTING _ INCOMING _ INTERCEPTORS . getName (  )  ,    warnings )  ;", "discardInterceptors ( addOperation ,    CommonAttributes . REMOTING _ OUTGOING _ INTERCEPTORS . getName (  )  ,    warnings )  ;", "newAddOperations . put ( PathAddress . pathAddress ( addOperation . get ( ModelDescriptionConstants . OP _ ADDR )  )  ,    addOperation )  ;", "migrateHAPolicy ( legacyAddress ,    addOperation ,    newAddOperations ,    warnings )  ;", "}", "METHOD_END"], "methodName": ["migrateServer"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   Map < PathAddress ,    ModelNode >    result    =    new   LinkedHashMap <  >  (  )  ;", "MultistepUtil . recordSteps ( context ,    migrations ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["migrateSubsystems"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "switch    ( resourceType )     {", "case   CommonAttributes . REMOTE _ ACCEPTOR    :", "case   CommonAttributes . HTTP _ ACCEPTOR    :", "case   CommonAttributes . REMOTE _ CONNECTOR    :", "case   CommonAttributes . HTTP _ CONNECTOR    :", "if    (  \" use - nio \"  . equals ( name )  )     {", "return   false ;", "} else    {", "return   true ;", "}", "default    :", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["parameterIsAllowed"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( MigrateOperation . MIGRATE ,    resourceDescriptionResolver )  . setParameters ( MigrateOperation . ADD _ LEGACY _ ENTRIES )  . setReplyParameters ( MigrateOperation . MIGRATION _ WARNINGS _ ATTR ,    MigrateOperation . MIGRATION _ ERROR _ ATTR )  . setAccessConstraints ( READ _ WHOLE _ CONFIG )  . build (  )  ,    MigrateOperation . MIGRATE _ INSTANCE )  ;", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( MigrateOperation . DESCRIBE _ MIGRATION ,    resourceDescriptionResolver )  . addParameter ( MigrateOperation . ADD _ LEGACY _ ENTRIES )  . setReplyParameters ( MigrateOperation . MIGRATION _ WARNINGS _ ATTR )  . setAccessConstraints ( READ _ WHOLE _ CONFIG )  . setReadOnly (  )  . build (  )  ,    MigrateOperation . DESCRIBE _ MIGRATION _ INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "PathAddress   subsystemAddress    =    PathAddress . pathAddress ( MessagingExtension . SUBSYSTEM _ PATH )  ;", "ModelNode   removeOperation    =    createRemoveOperation ( subsystemAddress )  ;", "migrationOperations . put ( subsystemAddress ,    removeOperation )  ;", "if    ( standalone )     {", "removeOperation    =    createRemoveOperation (  . MESSAGING _ EXTENSION )  ;", "migrationOperations . put (  . MESSAGING _ EXTENSION ,    removeOperation )  ;", "}", "}", "METHOD_END"], "methodName": ["removeMessagingSubsystem"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( String   property    :    properties )     {", "if    (  ( newAddOp . hasDefined ( property )  )     &  &     (  ( newAddOp . get ( property )  . getType (  )  )     =  =     ( EXPRESSION )  )  )     {", "newAddOp . remove ( property )  ;", "warnings . add ( MLogger . ROOT _ LOGGER . couldNotMigrateResourceAttributeWithExpression ( property ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removePropertiesWithExpression"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   attribute    =    discardNode . get ( legacyAttributeDefinition . getName (  )  )  ;", "if    ( attribute . isDefined (  )  )     {", "setNode . get ( newAttributeName )  . set ( attribute )  ;", "discardNode . remove ( legacyAttributeDefinition . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAndDiscard"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   newAddress    =    new   ModelNode (  )  ;", "for    ( Property   segment    :    legacyAddress . asPropertyList (  )  )     {", "final   Property   newSegment ;", "switch    ( segment . getName (  )  )     {", "case   CommonAttributes . SUBSYSTEM    :", "newSegment    =    new   Property ( ModelDescriptionConstants . SUBSYSTEM ,    new   ModelNode (  \"  - activemq \"  )  )  ;", "break ;", "case   CommonAttributes . HORNETQ _ SERVER    :", "newSegment    =    new   Property (  \" server \"  ,    segment . getValue (  )  )  ;", "break ;", "default    :", "newSegment    =    segment ;", "}", "newAddress . add ( newSegment )  ;", "}", "return   newAddress ;", "}", "METHOD_END"], "methodName": ["transformAddress"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelNode   legacyAddOp    :    legacyModelDescription . get ( ModelDescriptionConstants . RESULT )  . asList (  )  )     {", "final   ModelNode   newAddOp    =    legacyAddOp . clone (  )  ;", "ModelNode   legacyAddress    =    legacyAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  ;", "ModelNode   newAddress    =    transformAddress ( legacyAddress . clone (  )  )  ;", "newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( newAddress )  ;", "PathAddress   address    =    PathAddress . pathAddress ( newAddress )  ;", "if    (  (  ( address . size (  )  )     =  =     2  )     &  &     (  \" server \"  . equals ( address . getLastElement (  )  . getKey (  )  )  )  )     {", "migrateServer ( PathAddress . pathAddress ( legacyAddress )  ,    newAddOp ,    newAddOperations ,    warnings )  ;", "continue ;", "}", "if    (  ( newAddress . asList (  )  . size (  )  )     >     2  )     {", "String   parentType    =    address . getElement (  1  )  . getKey (  )  ;", "String   resourceType    =    address . getElement (  2  )  . getKey (  )  ;", "if    (  \" server \"  . equals ( parentType )  )     {", "switch    ( resourceType )     {", "case   CommonAttributes . BROADCAST _ GROUP    :", "migrateBroadcastGroup ( newAddOp ,    warnings )  ;", "break ;", "case   CommonAttributes . DISCOVERY _ GROUP    :", "migrateDiscoveryGroup ( newAddOp ,    warnings )  ;", "break ;", "case   CommonAttributes . CONNECTION _ FACTORY    :", "if    ( addLegacyEntries )     {", "if    ( connectionFactoryIsUsingInVMConnectors ( context ,    legacyAddOp )  )     {", "warnings . add ( MessagingLogger . ROOT _ LOGGER . couldNotCreateLegacyConnectionFactoryUsingInVMConnector ( address )  )  ;", "} else    {", "PathAddress   legacyConnectionFactoryAddress    =    address . getParent (  )  . append (  \" legacy - connection - factory \"  ,    address . getLastElement (  )  . getValue (  )  )  ;", "final   ModelNode   addLegacyConnectionFactoryOp    =    legacyAddOp . clone (  )  ;", "addLegacyConnectionFactoryOp . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( legacyConnectionFactoryAddress . toModelNode (  )  )  ;", "migrateConnectionFactory ( addLegacyConnectionFactoryOp ,     \"  \"  )  ;", "newAddOperations . put ( legacyConnectionFactoryAddress ,    addLegacyConnectionFactoryOp )  ;", "}", "}", "migrateConnectionFactory ( newAddOp ,     ( addLegacyEntries    ?     . NEW _ ENTRY _ SUFFIX    :     \"  \"  )  )  ;", "break ;", "case   CommonAttributes . POOLED _ CONNECTION _ FACTORY    :", "migratePooledConnectionFactory ( newAddOp )  ;", "break ;", "case   CommonAttributes . CLUSTER _ CONNECTION    :", "migrateClusterConnection ( newAddOp ,    warnings )  ;", "break ;", "case   CommonAttributes . BRIDGE    :", "migrateBridge ( newAddOp )  ;", "break ;", "case   CommonAttributes . JMS _ QUEUE    :", "case   CommonAttributes . JMS _ TOPIC    :", "if    ( addLegacyEntries )     {", "addLegacyEntries ( newAddOp )  ;", "}", "break ;", "case   CommonAttributes . ACCEPTOR    :", "case   CommonAttributes . CONNECTOR    :", "migrateGenericTransport ( newAddOp )  ;", "case   CommonAttributes . HTTP _ ACCEPTOR    :", "case   CommonAttributes . REMOTE _ ACCEPTOR    :", "case   CommonAttributes . HTTP _ CONNECTOR    :", "case   CommonAttributes . REMOTE _ CONNECTOR    :", "case   CommonAttributes . CONNECTOR _ SERVICE    :", "if    (  ( address . size (  )  )     =  =     4  )     {", "String   name    =    address . getLastElement (  )  . getValue (  )  ;", "ModelNode   value    =    newAddOp . get ( ModelDescriptionConstants . VALUE )  ;", "ModelNode   parentAddOp    =    newAddOperations . get ( address . getParent (  )  )  ;", "if    (  ( name . equals (  \" http - upgrade - endpoint \"  )  )     &  &     ( address . getParent (  )  . getLastElement (  )  . getKey (  )  . equals (  \" http - connector \"  )  )  )     {", "parentAddOp . get (  \" endpoint \"  )  . set ( value )  ;", "} else    {", "if    ( parameterIsAllowed ( name ,    resourceType )  )     {", "parentAddOp . get (  \" params \"  )  . add ( new   Property ( name ,    value )  )  ;", "} else    {", "warnings . add ( MessagingLogger . ROOT _ LOGGER . couldNotMigrateUnsupportedAttribute ( name ,    address . getParent (  )  )  )  ;", "}", "}", "continue ;", "}", "break ;", "}", "}", "}", "newAddOperations . put ( address ,    newAddOp )  ;", "}", "}", "METHOD_END"], "methodName": ["transformResources"], "fileName": "org.jboss.as.messaging.MigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.messaging.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   new   QName ( name ,     \" subsystem \"  )  ;", "}", "METHOD_END"], "methodName": ["getQName"], "fileName": "org.jboss.as.messaging.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.messaging.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   new   AttributeDefinition [  ]  {    PathDefinition . PATHS . get ( path )  ,    PathDefinition . RELATIVE _ TO    }  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.jboss.as.messaging.PathDefinition"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getMinOccurs"], "fileName": "org.jboss.as.messaging.PathDefinition"}, {"methodBody": ["METHOD_START", "{", "return   SimpleAttributeDefinitionBuilder . create ( name ,    BOOLEAN )  . setXmlName ( xmlName )  . setDefaultValue ( new   ModelNode ( false )  )  . setFlags ( RESTART _ NONE )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.messaging.SecurityRoleDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   ConnectionFactoryAttribute ( attributeDefinition ,    propertyName ,    resourceAdapterProperty ,    false )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ConnectionFactoryAttribute ( attributeDefinition ,    propertyName ,    resourceAdapterProperty ,    inboundConfig )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "switch    ( attributeDefinition . getType (  )  )     {", "case   BOOLEAN    :", "return   Boolean . class . getName (  )  ;", "case   BIG _ DECIMAL    :", "return   Double . class . getName (  )  ;", "case   LONG    :", "return   Long . class . getName (  )  ;", "case   INT    :", "return   Integer . class . getName (  )  ;", "case   STRING    :", "return   String . class . getName (  )  ;", "default    :", "throw   MessagingLogger . ROOT _ LOGGER . invalidType ( attributeDefinition . getName (  )  ,    attributeDefinition . getType (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getClassType"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   attributeDefinition ;", "}", "METHOD_END"], "methodName": ["getDefinition"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition [  ]    definitions    =    new   AttributeDefinition [ attrs . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( attrs . length )  ;    i +  +  )     {", "attr    =    attrs [ i ]  ;", "definitions [ i ]     =    attr . getDefinition (  )  ;", "}", "return   definitions ;", "}", "METHOD_END"], "methodName": ["getDefinitions"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   inboundConfig ;", "}", "METHOD_END"], "methodName": ["isInboundConfig"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "return   resourceAdapterProperty ;", "}", "METHOD_END"], "methodName": ["isResourceAdapterProperty"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryAttribute"}, {"methodBody": ["METHOD_START", "{", "int   size    =     ( common . length )     +     ( specific . length )  ;", "Attribute [  ]    result    =    new   Attribute [ size ]  ;", "System . arraycopy ( common ,     0  ,    result ,     0  ,    common . length )  ;", "System . arraycopy ( specific ,     0  ,    result ,    common . length ,    specific . length )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["concat"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryDefinition"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jboss.as.messaging.jms.ConnectionFactoryType"}, {"methodBody": ["METHOD_START", "{", "AbstractAttributeDefinitionBuilder   builder ;", "if    ( attribute   instanceof   SimpleListAttributeDefinition )     {", "builder    =    new   SimpleListAttributeDefinition . Builder (  (  ( SimpleListAttributeDefinition )     ( attribute )  )  )  ;", "(  ( SimpleListAttributeDefinition . Builder )     ( builder )  )  . setListValidator ( attribute . getValidator (  )  )  ;", "} else", "if    ( attribute   instanceof   controller . SimpleMapAttributeDefinition )     {", "builder    =    new   controller . SimpleMapAttributeDefinition . Builder (  (  ( controller . SimpleMapAttributeDefinition )     ( attribute )  )  )  ;", "} else", "if    ( attribute   instanceof   controller . PrimitiveListAttributeDefinition )     {", "builder    =    new   controller . PrimitiveListAttributeDefinition . Builder (  (  ( controller . PrimitiveListAttributeDefinition )     ( attribute )  )  )  ;", "(  ( controller . PrimitiveListAttributeDefinition . Builder )     ( builder )  )  . setListValidator ( attribute . getValidator (  )  )  ;", "} else    {", "builder    =    new   controller . SimpleAttributeDefinitionBuilder (  (  ( controller . SimpleAttributeDefinition )     ( attribute )  )  )  ;", "}", "builder . setFlags ( flag )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.jboss.as.messaging.jms.PooledConnectionFactoryDefinition"}, {"methodBody": ["METHOD_START", "{", "int   size    =     ( common . length )     +     ( specific . length )  ;", "ConnectionFactoryAttribute [  ]    result    =    new   ConnectionFactoryAttribute [ size ]  ;", "System . arraycopy ( specific ,     0  ,    result ,     0  ,    specific . length )  ;", "for    ( int   i    =     0  ;    i    <     ( common . length )  ;    i +  +  )     {", "ConnectionFactoryAttribute   attr    =    common [ i ]  ;", "AttributeDefinition   definition    =    attr . getDefinition (  )  ;", "ConnectionFactoryAttribute   newAttr ;", "if    ( definition    =  =     ( ConnectionFactoryAttributes . Common . RECONNECT _ ATTEMPTS )  )     {", "AttributeDefinition   copy    =     . copy ( ConnectionFactoryAttributes . Pooled . RECONNECT _ ATTEMPTS ,    RESTART _ ALL _ SERVICES )  ;", "newAttr    =    ConnectionFactoryAttribute . create ( copy ,    ConnectionFactoryAttributes . Pooled . RECONNECT _ ATTEMPTS _ PROP _ NAME ,    true )  ;", "} else    {", "AttributeDefinition   copy    =     . copy ( definition ,    RESTART _ ALL _ SERVICES )  ;", "newAttr    =    ConnectionFactoryAttribute . create ( copy ,    attr . getPropertyName (  )  ,    attr . isResourceAdapterProperty (  )  ,    attr . isInboundConfig (  )  )  ;", "}", "result [  (  ( specific . length )     +    i )  ]     =    newAttr ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["define"], "fileName": "org.jboss.as.messaging.jms.PooledConnectionFactoryDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   ListValidator ( elementValidator ,    false ,     1  ,    Integer . MAX _ VALUE )     {", "@ Override", "public   void   validateParameter ( String   parameterName ,    ModelNode   value )    throws   OperationFailedException    {", "super . validateParameter ( parameterName ,    value )  ;", "int   elementsSize    =    value . asList (  )  . size (  )  ;", "Set < ModelNode >    set    =    new   HashSet ( value . asList (  )  )  ;", "if    (  ( set . size (  )  )     !  =    elementsSize )     {", "throw   MessagingLogger . ROOT _ LOGGER . duplicateElements ( parameterName ,    value )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["noDuplicateElements"], "fileName": "org.jboss.as.messaging.jms.Validators"}, {"methodBody": ["METHOD_START", "{", "List < AttributeDefinition >    allAttributes    =    new   ArrayList <  >  (  )  ;", "allAttributes . addAll ( Arrays . asList (  . JMS _ BRIDGE _ ATTRIBUTES )  )  ;", "allAttributes . addAll ( Arrays . asList (  . JMS _ SOURCE _ ATTRIBUTES )  )  ;", "allAttributes . addAll ( Arrays . asList (  . JMS _ TARGET _ ATTRIBUTES )  )  ;", "return   allAttributes . toArray ( new   AttributeDefinition [ allAttributes . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getAllAttributes"], "fileName": "org.jboss.as.messaging.jms.bridge.JMSBridgeDefinition"}, {"methodBody": ["METHOD_START", "{", "return   MessagingDependencies . HORNETQ _ DEPENDENCIES . get ( controllerVersion )  ;", "}", "METHOD_END"], "methodName": ["getHornetQDependencies"], "fileName": "org.jboss.as.messaging.test.MessagingDependencies"}, {"methodBody": ["METHOD_START", "{", "return    (  ( version . getMavenGroupId (  )  )     +     \"  : jboss - as - messaging :  \"  )     +     ( version . getMavenGavVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessagingGAV"], "fileName": "org.jboss.as.messaging.test.MessagingDependencies"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  1  _  3  _ expressions . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem13TestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  1  _  4  _ expressions . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem14TestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  1  _  5  _ expressions . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testExpressions"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem15TestCase"}, {"methodBody": ["METHOD_START", "{", "return ;", "}", "METHOD_END"], "methodName": ["compareXml"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem20TestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" subsystem _  2  _  0  _ message _ counter . xml \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageCounterEnabled"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem20TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource ( xmlFileName )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addMavenResourceURL ( MessagingDependencies . getMessagingGAV ( controllerVersion )  )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    fixer )  . addMavenResourceURL ( MessagingDependencies . getHornetQDependencies ( controllerVersion )  )  . dontPersistXml (  )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["createKernelServicesBuilder"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( Extension . VERSION _  1  _  3  _  0  )  ;", "assertNotNull ( legacyServices )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestRejectExpressions_1_3_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( Extension . VERSION _  1  _  4  _  0  )  ;", "assertNotNull ( legacyServices )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestRejectExpressions_1_4_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( EAP _  6  _  2  _  0  ,    MessagingExtension . VERSION _  1  _  3  _  0  ,    ModelFixers . PATH _ FIXER ,     \" empty _ subsystem _  3  _  0  . xml \"  )  ;", "doTestRejectExpressions _  1  _  3  _  0  ( builder )  ;", "}", "METHOD_END"], "methodName": ["testRejectExpressionsEAP_6_2_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( EAP _  6  _  3  _  0  ,    MessagingExtension . VERSION _  1  _  3  _  0  ,    ModelFixers . PATH _ FIXER ,     \" empty _ subsystem _  3  _  0  . xml \"  )  ;", "doTestRejectExpressions _  1  _  3  _  0  ( builder )  ;", "}", "METHOD_END"], "methodName": ["testRejectExpressionsEAP_6_3_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( EAP _  6  _  4  _  0  ,    MessagingExtension . VERSION _  1  _  4  _  0  ,    ModelFixers . PATH _ FIXER ,     \" empty _ subsystem _  3  _  0  . xml \"  )  ;", "doTestRejectExpressions _  1  _  4  _  0  ( builder )  ;", "}", "METHOD_END"], "methodName": ["testRejectExpressionsEAP_6_4_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( controllerVersion ,    messagingVersion ,    fixer ,    null )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" subsystem _  3  _  0  . xml \"  )  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    messagingVersion )  . addMavenResourceURL ( MessagingDependencies . getMessagingGAV ( controllerVersion )  )  . addMavenResourceURL ( MessagingDependencies . getHornetQDependencies ( controllerVersion )  )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    fixer )  . dontPersistXml (  )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "assertTrue ( mainServices . getLegacyServices ( messagingVersion )  . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    messagingVersion ,    legacyModelFixer )  ;", "}", "METHOD_END"], "methodName": ["testTransformers"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  6  _  2  _  0  ,    MessagingExtension . VERSION _  1  _  3  _  0  ,    ModelFixers . PATH _ FIXER )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_6_2_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  6  _  3  _  0  ,    MessagingExtension . VERSION _  1  _  3  _  0  ,    ModelFixers . PATH _ FIXER )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_6_3_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformers ( EAP _  6  _  4  _  0  ,    MessagingExtension . VERSION _  1  _  4  _  0  ,    ModelFixers . PATH _ FIXER )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP_6_4_0"], "fileName": "org.jboss.as.messaging.test.MessagingSubsystem30TestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem _ migration _ ha . xml \"  )  ;", ". newSubsystemAdditionalInitialization   additionalInitialization    =    new    . newSubsystemAdditionalInitialization (  )  ;", "KernelServices   services    =    createKernelServicesBuilder ( additionalInitialization )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   model    =    services . readWholeModel (  )  ;", "assertFalse ( additionalInitialization . extensionAdded )  ;", "assertTrue ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,    MessagingExtension . SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "ModelNode   migrateOp    =    new   ModelNode (  )  ;", "migrateOp . get ( ModelDescriptionConstants . OP )  . set (  \" migrate \"  )  ;", "migrateOp . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( ModelDescriptionConstants . SUBSYSTEM ,    MessagingExtension . SUBSYSTEM _ NAME )  ;", "ModelNode   response    =    services . executeOperation ( migrateOp )  ;", "checkOutcome ( response )  ;", "ModelNode   warnings    =    response . get ( ModelDescriptionConstants . RESULT ,     \" migration - warnings \"  )  ;", "assertEquals ( warnings . toString (  )  ,     (  (  1     +     1  )     +     3  )  ,    warnings . asList (  )  . size (  )  )  ;", "model    =    services . readWholeModel (  )  ;", "assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME ,     \" server \"  ,     \" unmigrated - backup \"  ,     \" ha - policy \"  )  . isDefined (  )  )  ;", "assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME ,     \" server \"  ,     \" unmigrated - shared - store \"  ,     \" ha - policy \"  )  . isDefined (  )  )  ;", "ModelNode   haPolicyForDefaultServer    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME ,     \" server \"  ,     \" default \"  ,     \" ha - policy \"  ,     \" shared - store - master \"  )  ;", "assertTrue ( haPolicyForDefaultServer . isDefined (  )  )  ;", "assertFalse ( haPolicyForDefaultServer . get (  \" failback - delay \"  )  . isDefined (  )  )  ;", "assertEquals ( false ,    haPolicyForDefaultServer . get (  \" failover - on - server - shutdown \"  )  . asBoolean (  )  )  ;", "ModelNode   haPolicyForSharedStoreMasterServer    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME ,     \" server \"  ,     \" shared - store - master \"  ,     \" ha - policy \"  ,     \" shared - store - master \"  )  ;", "assertTrue ( haPolicyForSharedStoreMasterServer . isDefined (  )  )  ;", "assertFalse ( haPolicyForSharedStoreMasterServer . get (  \" failback - delay \"  )  . isDefined (  )  )  ;", "assertEquals (  \"  $  { failover . on . shutdown : true }  \"  ,    haPolicyForSharedStoreMasterServer . get (  \" failover - on - server - shutdown \"  )  . asString (  )  )  ;", "ModelNode   haPolicyForSharedStoreSlaveServer    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME ,     \" server \"  ,     \" shared - store - slave \"  ,     \" ha - policy \"  ,     \" shared - store - slave \"  )  ;", "assertTrue ( haPolicyForSharedStoreSlaveServer . isDefined (  )  )  ;", "assertEquals (  \"  $  { allow . failback .  1  : false }  \"  ,    haPolicyForSharedStoreSlaveServer . get (  \" allow - failback \"  )  . asString (  )  )  ;", "assertFalse ( haPolicyForSharedStoreSlaveServer . get (  \" failback - delay \"  )  . isDefined (  )  )  ;", "assertEquals (  \"  $  { failover . on . shutdown .  1  : true }  \"  ,    haPolicyForSharedStoreSlaveServer . get (  \" failover - on - server - shutdown \"  )  . asString (  )  )  ;", "ModelNode   haPolicyForReplicationMasterServer    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME ,     \" server \"  ,     \" replication - master \"  ,     \" ha - policy \"  ,     \" replication - master \"  )  ;", "assertTrue ( haPolicyForReplicationMasterServer . isDefined (  )  )  ;", "assertEquals (  \"  $  { check . for . live . server : true }  \"  ,    haPolicyForReplicationMasterServer . get (  \" check - for - live - server \"  )  . asString (  )  )  ;", "assertEquals (  \"  $  { replication . master . group . name : mygroup }  \"  ,    haPolicyForReplicationMasterServer . get (  \" group - name \"  )  . asString (  )  )  ;", "ModelNode   haPolicyForReplicationSlaveServer    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME ,     \" server \"  ,     \" replication - slave \"  ,     \" ha - policy \"  ,     \" replication - slave \"  )  ;", "assertTrue ( haPolicyForReplicationSlaveServer . isDefined (  )  )  ;", "assertEquals (  \"  $  { allow . failback .  2  : false }  \"  ,    haPolicyForReplicationSlaveServer . get (  \" allow - failback \"  )  . asString (  )  )  ;", "assertFalse ( haPolicyForReplicationSlaveServer . get (  \" failback - delay \"  )  . isDefined (  )  )  ;", "assertEquals (  \"  $  { max . saved . replicated . journal . size :  2  }  \"  ,    haPolicyForReplicationSlaveServer . get (  \" max - saved - replicated - journal - size \"  )  . asString (  )  )  ;", "assertEquals (  \"  $  { replication . master . group . name : mygroup 2  }  \"  ,    haPolicyForReplicationSlaveServer . get (  \" group - name \"  )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMigrateHA"], "fileName": "org.jboss.as.messaging.test.MigrateTestCase"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem _ migration . xml \"  )  ;", ". newSubsystemAdditionalInitialization   additionalInitialization    =    new    . newSubsystemAdditionalInitialization (  )  ;", "KernelServices   services    =    createKernelServicesBuilder ( additionalInitialization )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   model    =    services . readWholeModel (  )  ;", "assertFalse ( additionalInitialization . extensionAdded )  ;", "assertTrue ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,    MessagingExtension . SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "ModelNode   migrateOp    =    new   ModelNode (  )  ;", "migrateOp . get ( ModelDescriptionConstants . OP )  . set (  \" migrate \"  )  ;", "migrateOp . get (  \" add - legacy - entries \"  )  . set ( addLegacyEntries )  ;", "migrateOp . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( ModelDescriptionConstants . SUBSYSTEM ,    MessagingExtension . SUBSYSTEM _ NAME )  ;", "ModelNode   response    =    services . executeOperation ( migrateOp )  ;", "checkOutcome ( response )  ;", "ModelNode   warnings    =    response . get ( ModelDescriptionConstants . RESULT ,     \" migration - warnings \"  )  ;", "int   expectedNumberOfWarnings    =     (  (  (  (  (  (  6     +     2  )     +     5  )     +     2  )     +     3  )     +     1  )     +     1  )     +     1  ;", "if    ( addLegacyEntries )     {", "expectedNumberOfWarnings    +  =     1  ;", "}", "assertEquals ( warnings . toString (  )  ,    expectedNumberOfWarnings ,    warnings . asList (  )  . size (  )  )  ;", "model    =    services . readWholeModel (  )  ;", "assertTrue ( additionalInitialization . extensionAdded )  ;", "assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,    MessagingExtension . SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "assertTrue ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "ModelNode   newSubsystem    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . MESSAGING _ ACTIVEMQ _ SUBSYSTEM _ NAME )  ;", "ModelNode   newServer    =    newSubsystem . get (  \" server \"  ,     \" default \"  )  ;", "assertNotNull ( newServer )  ;", "assertTrue ( newServer . isDefined (  )  )  ;", "assertEquals (  \" STRICT \"  ,    newServer . get (  \" cluster - connection \"  ,     \" cc 2  \"  ,     \" message - load - balancing - type \"  )  . asString (  )  )  ;", "assertEquals (  \" ON _ DEMAND \"  ,    newServer . get (  \" cluster - connection \"  ,     \" cc 3  \"  ,     \" message - load - balancing - type \"  )  . asString (  )  )  ;", "assertEquals ( true ,    newServer . get (  \" pooled - connection - factory \"  ,     \" hornetq - ra \"  ,     \" allow - local - transactions \"  )  . asBoolean (  )  )  ;", "if    ( addLegacyEntries )     {", "ModelNode   jmsQueueLegacyEntries    =    newServer . get (  \" jms - queue \"  ,     \" testQueue \"  ,     \" legacy - entries \"  )  ;", "assertTrue ( jmsQueueLegacyEntries . toJSONString ( true )  ,    jmsQueueLegacyEntries . isDefined (  )  )  ;", "assertEquals (  1  ,    jmsQueueLegacyEntries . asList (  )  . size (  )  )  ;", "ModelNode   jmsTopicLegacyEntries    =    newServer . get (  \" jms - topic \"  ,     \" testTopic \"  ,     \" legacy - entries \"  )  ;", "assertTrue ( jmsTopicLegacyEntries . toJSONString ( true )  ,    jmsQueueLegacyEntries . isDefined (  )  )  ;", "assertEquals (  1  ,    jmsTopicLegacyEntries . asList (  )  . size (  )  )  ;", "assertTrue ( newServer . get (  \" legacy - connection - factory \"  ,     \" RemoteConnectionFactory \"  )  . isDefined (  )  )  ;", "} else    {", "assertFalse ( newServer . get (  \" jms - queue \"  ,     \" testQueue \"  ,     \" legacy - entries \"  )  . isDefined (  )  )  ;", "assertFalse ( newServer . get (  \" jms - topic \"  ,     \" testTopic \"  ,     \" legacy - entries \"  )  . isDefined (  )  )  ;", "assertFalse ( newServer . get (  \" jms - topic \"  ,     \" testTopic \"  ,     \" legacy - entries \"  )  . isDefined (  )  )  ;", "assertFalse ( newServer . get (  \" legacy - connection - factory \"  ,     \" RemoteConnectionFactory \"  )  . isDefined (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMigrateOperation"], "fileName": "org.jboss.as.messaging.test.MigrateTestCase"}, {"methodBody": ["METHOD_START", "{", "testMigrateOperation ( true )  ;", "}", "METHOD_END"], "methodName": ["testMigrateOperationWithLegacyEntries"], "fileName": "org.jboss.as.messaging.test.MigrateTestCase"}, {"methodBody": ["METHOD_START", "{", "testMigrateOperation ( false )  ;", "}", "METHOD_END"], "methodName": ["testMigrateOperationWithoutLegacyEntries"], "fileName": "org.jboss.as.messaging.test.MigrateTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \" xsd 1  0  . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testXsd10"], "fileName": "org.jboss.as.messaging.test.Subsystem11ParsingUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   address    =    new   ModelNode (  )  ;", "address . add (  \" subsystem \"  ,     \"  \"  )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( OP )  . set ( READ _ RESOURCE _ DESCRIPTION _ OPERATION )  ;", "operation . get ( OP _ ADDR )  . set ( address )  ;", "operation . get ( RECURSIVE )  . set ( true )  ;", "operation . get ( OPERATIONS )  . set ( true )  ;", "operation . get ( INHERITED )  . set ( false )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["createReadResourceDescriptionOperation"], "fileName": "org.jboss.as.messaging.test.SubsystemDescriptionsUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "List < ModelNode >    empty    =    Collections . emptyList (  )  ;", "KernelServices   servicesA    =    createKernelServicesBuilder ( ADMIN _ ONLY _ HC )  . setBootOperations ( empty )  . build (  )  ;", "final   ModelNode   operation    =     . createReadResourceDescriptionOperation (  )  ;", "final   ModelNode   result    =    servicesA . executeOperation ( operation )  ;", "Assert . assertEquals ( SUCCESS ,    result . get ( OUTCOME )  . asString (  )  )  ;", "servicesA . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["testSubsystemDescriptions"], "fileName": "org.jboss.as.messaging.test.SubsystemDescriptionsUnitTestCase"}, {"methodBody": ["METHOD_START", "{", "String [  ]    newAttrs    =    new   String [  ( attrs 1  . length )     +     ( attrs 2  . length )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( attrs 1  . length )  ;    i +  +  )     {", "newAttrs [ i ]     =    attrs 1  [ i ]  . getName (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( attrs 2  . length )  ;    i +  +  )     {", "newAttrs [  (  ( attrs 1  . length )     +    i )  ]     =    attrs 2  [ i ]  ;", "}", "return   newAttrs ;", "}", "METHOD_END"], "methodName": ["concat"], "fileName": "org.jboss.as.messaging.test.TransformerUtils"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition [  ]    newAttrs    =    new   AttributeDefinition [  ( attrs 1  . length )     +     ( attrs 2  . length )  ]  ;", "( int   i    =     0  ;    i    <     ( attrs 1  . length )  ;    i +  +  )     {", "newAttrs [ i ]     =    attrs 1  [ i ]  ;", "}", "( int   i    =     0  ;    i    <     ( attrs 2  . length )  ;    i +  +  )     {", "newAttrs [  (  ( attrs 1  . length )     +    i )  ]     =    attrs 2  [ i ]  ;", "}", "return   newAttrs ;", "}", "METHOD_END"], "methodName": ["concat"], "fileName": "org.jboss.as.messaging.test.TransformerUtils"}, {"methodBody": ["METHOD_START", "{", "AttributeDefinition [  ]    allAttributes    =    new   AttributeDefinition [  ( rejectedExpression . length )     +     ( newAttributes . length )  ]  ;", "System . arraycopy ( rejectedExpression ,     0  ,    allAttributes ,     0  ,    rejectedExpression . length )  ;", "System . arraycopy ( newAttributes ,     0  ,    allAttributes ,    rejectedExpression . length ,    newAttributes . length )  ;", "return   ChainedConfig . createBuilder ( allAttributes )  . addConfig ( new   odel . test . FailedOperationTransformationConfig . RejectExpressionsConfig ( rejectedExpression )  )  . addConfig ( new   odel . test . FailedOperationTransformationConfig . NewAttributesConfig ( newAttributes )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createChainedConfig"], "fileName": "org.jboss.as.messaging.test.TransformerUtils"}, {"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.web.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.web.Attribute"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.jboss.as.web.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.jboss.as.web.Element"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.jboss.as.web.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.jboss.as.web.Namespace"}, {"methodBody": ["METHOD_START", "{", "final   String   prefix    =     ( WebExtension . SUBSYSTEM _ NAME )     +     ( keyPrefix    =  =    null    ?     \"  \"     :     \"  .  \"     +    keyPrefix )  ;", "return   new   DeprecatedResourceDescriptionResolver ( WebExtension . SUBSYSTEM _ NAME ,    prefix ,    WebExtension . RESOURCE _ NAME ,    WebExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.jboss.as.web.WebExtension"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    WebMigrateOperation . DEFAULT _ SERVER _ PATH )  ;", "ModelNode   add    =    createAddOperation ( address )  ;", "ModelNode   defaultSessionTimeout    =    null ;", "ModelNode   directoryListing    =    null ;", "ModelNode   sendfile    =    null ;", "ModelNode   fileEncoding    =    null ;", "ModelNode   readOnly    =    null ;", "ModelNode   webdav    =    null ;", "ModelNode   secret    =    null ;", "ModelNode   maxDepth    =    null ;", "ModelNode   disabled    =    null ;", "for    ( ModelNode   legacyAddOp    :    legacyModelDescription . get ( ModelDescriptionConstants . RESULT )  . asList (  )  )     {", "final   PathAddress   la    =    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  ;", "if    ( la . equals ( PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH )  )  )     {", "ModelNode   defaultHost    =    legacyAddOp . get ( WebDefinition . DEFAULT _ VIRTUAL _ SERVER . getName (  )  )  ;", "if    ( defaultHost . isDefined (  )  )     {", "add . get ( DEFAULT _ HOST )  . set ( defaultHost . clone (  )  )  ;", "}", "ModelNode   sessionTimeout    =    legacyAddOp . get ( WebDefinition . DEFAULT _ SESSION _ TIMEOUT . getName (  )  )  ;", "if    ( sessionTimeout . isDefined (  )  )     {", "defaultSessionTimeout    =    sessionTimeout ;", "}", "} else", "if    ( la . equals ( PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . STATIC _ RESOURCES _ PATH )  )  )     {", "ModelNode   node    =    legacyAddOp . get ( WebStaticResources . LISTINGS . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "directoryListing    =    node ;", "}", "node    =    legacyAddOp . get ( WebStaticResources . SENDFILE . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebStaticResources . SENDFILE . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "sendfile    =    node ;", "}", "node    =    legacyAddOp . get ( WebStaticResources . FILE _ ENCODING . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebStaticResources . FILE _ ENCODING . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "fileEncoding    =    node ;", "}", "node    =    legacyAddOp . get ( WebStaticResources . READ _ ONLY . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebStaticResources . READ _ ONLY . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "readOnly    =    node ;", "}", "node    =    legacyAddOp . get ( WebStaticResources . WEBDAV . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebStaticResources . WEBDAV . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "webdav    =    node ;", "}", "node    =    legacyAddOp . get ( WebStaticResources . SECRET . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebStaticResources . SECRET . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "secret    =    node ;", "}", "node    =    legacyAddOp . get ( WebStaticResources . MAX _ DEPTH . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebStaticResources . MAX _ DEPTH . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "maxDepth    =    node ;", "}", "node    =    legacyAddOp . get ( WebStaticResources . DISABLED . getName (  )  )  ;", "if    ( node . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebStaticResources . DISABLED . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "disabled    =    node ;", "}", "}", "}", "migrationOperations . put ( address ,    add )  ;", "address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    PathElement . pathElement ( BUFFER _ CACHE ,     \" default \"  )  )  ;", "add    =    createAddOperation ( address )  ;", "migrationOperations . put ( address ,    add )  ;", "address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    PathElement . pathElement ( SERVLET _ CONTAINER ,     \" default \"  )  )  ;", "add    =    createAddOperation ( address )  ;", "if    ( defaultSessionTimeout    !  =    null )     {", "add . get ( Constants . DEFAULT _ SESSION _ TIMEOUT )  . set ( defaultSessionTimeout . clone (  )  )  ;", "}", "if    ( directoryListing    !  =    null )     {", "add . get ( DIRECTORY _ LISTING )  . set ( directoryListing )  ;", "}", "migrationOperations . put ( address ,    add )  ;", "}", "METHOD_END"], "methodName": ["addDefaultResources"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "Resource   root    =    context . readResourceFromRoot ( EMPTY _ ADDRESS ,    false )  ;", "if    ( root . getChildrenNames ( ModelDescriptionConstants . EXTENSION )  . contains ( extension )  )     {", "return ;", "}", "PathAddress   extensionAddress    =    PathAddress . pathAddress ( ModelDescriptionConstants . EXTENSION ,    extension )  ;", "Entry   addEntry    =    context . getRootResourceRegistration (  )  . getEntry ( extensionAddress ,    ModelDescriptionConstants . ADD )  ;", "ModelNode   add    =    createAdd ( extensionAddress )  ;", "add . get ( ModelDescriptionConstants . MODULE )  . set ( extension )  ;", "if    ( describe )     {", "migrations . put ( extensionAddress ,    add )  ;", "} else    {", "context . addStep ( context . getResult (  )  . get ( extensionAddress . toString (  )  )  ,    add ,    addEntry . getHandler (  )  ,    Stage . MODEL )  ;", "}", "}", "METHOD_END"], "methodName": ["addExtension"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( newAddOp . hasDefined ( WebValveDefinition . PARAMS . getName (  )  )  )     {", "StringBuilder   expression    =    new   StringBuilder (  )  ;", "expression . append (  \" access - control ( acl =  {  \"  )  ;", "ModelNode   params    =    newAddOp . get ( WebValveDefinition . PARAMS . getName (  )  )  ;", "boolean   isValid    =    false ;", "if    ( params . hasDefined (  \" deny \"  )  )     {", "isValid    =    true ;", "String [  ]    denied    =    params . get (  \" deny \"  )  . asString (  )  . split (  \"  ,  \"  )  ;", "for    ( String   deny    :    denied )     {", "expression . append (  '  \\  '  '  )  . append ( deny . trim (  )  )  . append (  \"    deny \\  '  ,     \"  )  ;", "}", "}", "if    ( params . hasDefined (  \" allow \"  )  )     {", "isValid    =    true ;", "String [  ]    allowed    =    params . get (  \" allow \"  )  . asString (  )  . split (  \"  ,  \"  )  ;", "for    ( String   allow    :    allowed )     {", "expression . append (  '  \\  '  '  )  . append ( allow . trim (  )  )  . append (  \"    allow \\  '  ,     \"  )  ;", "}", "}", "if    ( isValid )     {", "expression . delete (  (  ( expression . length (  )  )     -     2  )  ,    expression . length (  )  )  ;", "expression . append (  \"  }     ,    attribute =  \"  )  . append ( attribute . trim (  )  )  . append (  '  )  '  )  ;", "createExpressionFilter ( newAdds ,    name ,    expression . toString (  )  )  ;", "} else    {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValve ( name )  )  ;", "}", "} else    {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValve ( name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createAccesControlExpressionFilter"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "newAddOperations . putIfAbsent ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS )  ,    createAddOperation ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS )  )  )  ;", "PathAddress   filterAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS ,    PathElement . pathElement ( INSTANCE . getPathElement (  )  . getKey (  )  ,    name )  )  ;", "ModelNode   filterAdd    =    createAddOperation ( filterAddress )  ;", "filterAdd . get ( EXPRESSION . getName (  )  )  . set ( expression )  ;", "newAddOperations . put ( filterAddress ,    filterAdd )  ;", "}", "METHOD_END"], "methodName": ["createExpressionFilter"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "PathAddress   addres    =    PathAddress . pathAddress ( managementCoreService ,    PathElement . pathElement ( ModelDescriptionConstants . SECURITY _ REALM ,    realmName )  )  ;", "migrations . put ( addres ,    createAdd ( addres )  )  ;", "addres    =    PathAddress . pathAddress ( managementCoreService ,    PathElement . pathElement ( ModelDescriptionConstants . SECURITY _ REALM ,    realmName )  ,    PathElement . pathElement ( ModelDescriptionConstants . AUTHENTICATION ,    ModelDescriptionConstants . TRUSTSTORE )  )  ;", "ModelNode   addOp    =    createAdd ( addres )  ;", "addOp . get ( KEYSTORE _ PATH )  . set ( caCertificateFile )  ;", "addOp . get ( KEYSTORE _ PASSWORD )  . set ( caCertificatePassword )  ;", "addOp . get ( KEYSTORE _ PROVIDER )  . set ( trustStoreType )  ;", "migrations . put ( addres ,    addOp )  ;", "addres    =    PathAddress . pathAddress ( managementCoreService ,    PathElement . pathElement ( ModelDescriptionConstants . SECURITY _ REALM ,    realmName )  ,    PathElement . pathElement ( ModelDescriptionConstants . SERVER _ IDENTITY ,    ModelDescriptionConstants . SSL )  )  ;", "addOp    =    createAdd ( addres )  ;", "addOp . get ( KEYSTORE _ PATH )  . set ( certificateKeyFile )  ;", "addOp . get ( KEYSTORE _ PASSWORD )  . set ( password )  ;", "addOp . get ( KEYSTORE _ PROVIDER )  . set ( keystoreType )  ;", "addOp . get ( ALIAS )  . set ( keyAlias )  ;", "addOp . get ( ModelDescriptionConstants . PROTOCOL )  . set ( protocol )  ;", "migrations . put ( addres ,    addOp )  ;", "return   realmName ;", "}", "METHOD_END"], "methodName": ["createHostSSLConfig"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "Resource   root    =    context . readResourceFromRoot ( baseAddress ,    false )  ;", "if    ( root . getChildrenNames ( ModelDescriptionConstants . SUBSYSTEM )  . contains ( SUBSYSTEM _ NAME )  )     {", "return ;", "}", "PathAddress   address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  )  ;", "migrations . put ( address ,    createAdd ( address )  )  ;", "address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    PathElement . pathElement (  \" worker \"  ,     \" default \"  )  )  ;", "migrations . put ( address ,    createAdd ( address )  )  ;", "address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    PathElement . pathElement (  \" buffer - pool \"  ,     \" default \"  )  )  ;", "migrations . put ( address ,    createAdd ( address )  )  ;", "}", "METHOD_END"], "methodName": ["createIoSubsystem"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   legacyAddOp    =    WebMigrateOperation . findResource ( PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    PathElement . pathElement ( WebExtension . CONNECTOR _ PATH . getKey (  )  ,    connector )  ,    PathElement . pathElement (  \" configuration \"  ,     \" ssl \"  )  )  ,    legacyModelAddOps )  ;", "if    ( legacyAddOp    =  =    null )     {", "return   null ;", "}", "ModelNode   keyAlias    =    legacyAddOp . get ( WebSSLDefinition . KEY _ ALIAS . getName (  )  )  ;", "ModelNode   password    =    legacyAddOp . get ( WebSSLDefinition . PASSWORD . getName (  )  )  ;", "ModelNode   certificateKeyFile    =    legacyAddOp . get ( WebSSLDefinition . CERTIFICATE _ KEY _ FILE . getName (  )  )  ;", "ModelNode   cipherSuite    =    legacyAddOp . get ( WebSSLDefinition . CIPHER _ SUITE . getName (  )  )  ;", "ModelNode   protocol    =    legacyAddOp . get ( WebSSLDefinition . PROTOCOL . getName (  )  )  ;", "ModelNode   verifyClient    =    legacyAddOp . get ( WebSSLDefinition . VERIFY _ CLIENT . getName (  )  )  ;", "ModelNode   verifyDepth    =    legacyAddOp . get ( WebSSLDefinition . VERIFY _ DEPTH . getName (  )  )  ;", "ModelNode   certificateFile    =    legacyAddOp . get ( WebSSLDefinition . CERTIFICATE _ FILE . getName (  )  )  ;", "ModelNode   caCertificateFile    =    legacyAddOp . get ( WebSSLDefinition . CA _ CERTIFICATE _ FILE . getName (  )  )  ;", "ModelNode   caCertificatePassword    =    legacyAddOp . get ( WebSSLDefinition . CA _ CERTIFICATE _ PASSWORD . getName (  )  )  ;", "ModelNode   csRevocationURL    =    legacyAddOp . get ( WebSSLDefinition . CA _ REVOCATION _ URL . getName (  )  )  ;", "ModelNode   trustStoreType    =    legacyAddOp . get ( WebSSLDefinition . TRUSTSTORE _ TYPE . getName (  )  )  ;", "ModelNode   keystoreType    =    legacyAddOp . get ( WebSSLDefinition . KEYSTORE _ TYPE . getName (  )  )  ;", "ModelNode   sessionCacheSize    =    legacyAddOp . get ( WebSSLDefinition . SESSION _ CACHE _ SIZE . getName (  )  )  ;", "ModelNode   sessionTimeout    =    legacyAddOp . get ( WebSSLDefinition . SESSION _ TIMEOUT . getName (  )  )  ;", "ModelNode   sslProvider    =    legacyAddOp . get ( WebSSLDefinition . SSL _ PROTOCOL . getName (  )  )  ;", "if    ( verifyDepth . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebSSLDefinition . VERIFY _ DEPTH . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "if    ( certificateFile . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebSSLDefinition . CERTIFICATE _ FILE . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "if    ( sslProvider . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebSSLDefinition . SSL _ PROTOCOL . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "if    ( csRevocationURL . isDefined (  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebSSLDefinition . CA _ REVOCATION _ URL . getName (  )  ,    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "String   realmName ;", "PathAddress   managementCoreService ;", "if    ( domainMode )     {", "Set < String >    hosts    =    new   HashSet <  >  (  )  ;", "Resource   hostResource    =    context . readResourceFromRoot ( PathAddress . pathAddress (  )  ,    false )  ;", "hosts . addAll ( hostResource . getChildrenNames ( ModelDescriptionConstants . HOST )  )  ;", "int   counter    =     1  ;", "realmName    =     ( WebMigrateOperation . REALM _ NAME )     +    counter ;", "while    ( true )     {", "boolean   hostOk    =    true ;", "for    ( String   host    :    hosts )     {", "Resource   root    =    context . readResourceFromRoot ( PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . HOST ,    host )  ,    PathElement . pathElement ( ModelDescriptionConstants . CORE _ SERVICE ,    ModelDescriptionConstants . MANAGEMENT )  )  ,    false )  ;", "if    ( root . getChildrenNames ( ModelDescriptionConstants . SECURITY _ REALM )  . contains ( realmName )  )     {", "counter +  +  ;", "realmName    =     ( WebMigrateOperation . REALM _ NAME )     +    counter ;", "hostOk    =    false ;", "break ;", "}", "}", "if    ( hostOk )     {", "break ;", "}", "}", "for    ( String   host    :    hosts )     {", "createHostSSLConfig ( realmName ,    migrationOperations ,    keyAlias ,    password ,    certificateKeyFile ,    protocol ,    caCertificateFile ,    caCertificatePassword ,    trustStoreType ,    keystoreType ,    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . HOST ,    host )  ,    PathElement . pathElement ( ModelDescriptionConstants . CORE _ SERVICE ,    ModelDescriptionConstants . MANAGEMENT )  )  )  ;", "}", "} else    {", "managementCoreService    =    PathAddress . pathAddress ( ModelDescriptionConstants . CORE _ SERVICE ,    ModelDescriptionConstants . MANAGEMENT )  ;", "int   counter    =     1  ;", "realmName    =     ( WebMigrateOperation . REALM _ NAME )     +    counter ;", "boolean   ok    =    false ;", "do    {", "Resource   root    =    context . readResourceFromRoot ( managementCoreService ,    false )  ;", "if    ( root . getChildrenNames ( ModelDescriptionConstants . SECURITY _ REALM )  . contains ( realmName )  )     {", "counter +  +  ;", "realmName    =     ( WebMigrateOperation . REALM _ NAME )     +    counter ;", "} else    {", "ok    =    true ;", "}", "}    while    (  ! ok    )  ;", "createHostSSLConfig ( realmName ,    migrationOperations ,    keyAlias ,    password ,    certificateKeyFile ,    protocol ,    caCertificateFile ,    caCertificatePassword ,    trustStoreType ,    keystoreType ,    managementCoreService )  ;", "}", "return   new   WebMigrateOperation . SSLInformation ( realmName ,    verifyClient ,    sessionCacheSize ,    sessionTimeout ,    protocol ,    cipherSuite )  ;", "}", "METHOD_END"], "methodName": ["createSecurityRealm"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    PathElement . pathElement ( Constants . CONFIGURATION ,    HANDLER )  )  ;", "migrations . put ( address ,    createAdd ( address )  )  ;", "address    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    PathElement . pathElement ( Constants . CONFIGURATION ,    HANDLER )  ,    PathElement . pathElement ( FILE ,     \" welcome - content \"  )  )  ;", "final   ModelNode   add    =    createAdd ( address )  ;", "add . get ( Constants . PATH )  . set ( new   ModelNode ( new   ValueExpression (  \"  $  { jboss . home . dir }  / welcome - content \"  )  )  )  ;", "migrations . put ( address ,    add )  ;", "}", "METHOD_END"], "methodName": ["createWelcomeContentHandler"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   describeLegacySubsystem    =    createOperation ( DEFINITION ,    context . getCurrentAddress (  )  )  ;", "context . addStep ( legacyModelDescription ,    describeLegacySubsystem ,    INSTANCE ,    Stage . MODEL ,    true )  ;", "}", "METHOD_END"], "methodName": ["describeLegacyWebResources"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelNode   legacyAddOp    :    legacyAddOps . get ( ModelDescriptionConstants . RESULT )  . asList (  )  )     {", "final   PathAddress   la    =    PathAddress . pathAddress ( legacyAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  ;", "if    ( la . equals ( address )  )     {", "return   legacyAddOp ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findResource"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "while    ( i    <     ( migrateAddress . size (  )  )  )     {", "if    ( migrateAddress . getElement ( i )  . equals ( WebExtension . SUBSYSTEM _ PATH )  )     {", "break ;", "}", "+  + i ;", "}", "if    ( i    =  =     0  )     {", "return ;", "}", "PathAddress   prefix    =    migrateAddress . subAddress (  0  ,    i )  ;", "Map < PathAddress ,    ModelNode >    old    =    new   HashMap ( migrations )  ;", "migrations . clear (  )  ;", "for    ( Map . Entry < PathAddress ,    ModelNode >    e    :    old . entrySet (  )  )     {", "if    ( e . getKey (  )  . getElement (  0  )  . getKey (  )  . equals ( ModelDescriptionConstants . SUBSYSTEM )  )     {", "final   PathAddress   oldAddress    =    PathAddress . pathAddress ( e . getValue (  )  . get ( ModelDescriptionConstants . ADDRESS )  )  ;", "List < PathElement >    elements    =    new   ArrayList <  >  (  )  ;", "for    ( PathElement   j    :    prefix )     {", "elements . add ( j )  ;", "}", "for    ( PathElement   j    :    oldAddress )     {", "elements . add ( j )  ;", "}", "PathAddress   newAddress    =    PathAddress . pathAddress ( elements )  ;", "e . getValue (  )  . get ( ModelDescriptionConstants . ADDRESS )  . set ( newAddress . toModelNode (  )  )  ;", "migrations . put ( newAddress ,    e . getValue (  )  )  ;", "} else    {", "migrations . put ( e . getKey (  )  ,    e . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["fixAddressesForDomainMode"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "PathAddress   newAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    WebMigrateOperation . DEFAULT _ SERVER _ PATH ,    PathElement . pathElement ( HOST ,    address . getElement (  (  ( address . size (  )  )     -     2  )  )  . getValue (  )  )  ,    PATH _ ACCESS _ LOG )  ;", "ModelNode   add    =    createAddOperation ( newAddress )  ;", "ModelNode   patternNode    =    newAddOp . get ( WebAccessLogDefinition . PATTERN . getName (  )  )  ;", "if    ( patternNode . isDefined (  )  )     {", "add . get ( Constants . PATTERN )  . set ( migrateAccessLogPattern ( patternNode . asString (  )  )  )  ;", "}", "add . get ( Constants . PREFIX )  . set ( newAddOp . get ( WebAccessLogDefinition . PREFIX . getName (  )  )  . clone (  )  )  ;", "add . get ( Constants . ROTATE )  . set ( newAddOp . get ( WebAccessLogDefinition . ROTATE . getName (  )  )  . clone (  )  )  ;", "if    ( newAddOp . hasDefined ( WebAccessLogDefinition . RESOLVE _ HOSTS . getName (  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebAccessLogDefinition . RESOLVE _ HOSTS . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "add . get ( Constants . EXTENDED )  . set ( newAddOp . get ( WebAccessLogDefinition . EXTENDED . getName (  )  )  . clone (  )  )  ;", "ModelNode   directory    =    WebMigrateOperation . findResource ( PathAddress . pathAddress ( PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  ,    WebExtension . DIRECTORY _ PATH )  ,    legacyAddOps )  ;", "if    ( directory    !  =    null )     {", "add . get ( Constants . DIRECTORY )  . set ( directory . get ( ModelDescriptionConstants . PATH )  )  ;", "add . get ( Constants . RELATIVE _ TO )  . set ( directory . get ( ModelDescriptionConstants . RELATIVE _ TO )  )  ;", "}", "newAddOperations . put ( newAddress ,    add )  ;", "}", "METHOD_END"], "methodName": ["migrateAccessLog"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "Matcher   m    =    WebMigrateOperation . ACCESS _ LOG _ PATTERN . matcher ( legacyPattern )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "int   lastIndex    =     0  ;", "while    ( m . find (  )  )     {", "sb . append ( legacyPattern . substring ( lastIndex ,    m . start (  )  )  )  ;", "lastIndex    =    m . end (  )  ;", "sb . append (  \"  %  {  \"  )  ;", "sb . append ( m . group (  2  )  )  ;", "sb . append (  \"  ,  \"  )  ;", "sb . append ( m . group (  1  )  )  ;", "sb . append (  \"  }  \"  )  ;", "}", "sb . append ( legacyPattern . substring ( lastIndex )  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["migrateAccessLogPattern"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   add    =    createAddOperation ( WebMigrateOperation . VALVE _ ACCESS _ LOG _ ADDRESS )  ;", "final   ModelNode   params    =    newAddOp . get ( WebValveDefinition . PARAMS . getName (  )  )  ;", "final   ModelNode   patternNode    =    params . get ( Constants . PATTERN )  ;", "if    ( patternNode . isDefined (  )  )     {", "add . get ( Constants . PATTERN )  . set ( migrateAccessLogPattern ( patternNode . asString (  )  )  )  ;", "}", "add . get ( Constants . PREFIX )  . set ( params . get ( Constants . PREFIX )  . clone (  )  )  ;", "add . get ( SUFFIX )  . set ( params . get ( SUFFIX )  . clone (  )  )  ;", "add . get ( Constants . ROTATE )  . set ( params . get (  \" rotatable \"  )  . clone (  )  )  ;", "add . get ( Constants . EXTENDED )  . set ( newAddOp . get ( Constants . EXTENDED )  . clone (  )  )  ;", "if    ( params . hasDefined ( Constants . DIRECTORY )  )     {", "add . get ( Constants . DIRECTORY )  . set ( params . get ( Constants . DIRECTORY )  . clone (  )  )  ;", "}", "if    ( params . hasDefined (  \" conditionIf \"  )  )     {", "add . get ( PREDICATE )  . set (  (  (  \" exists (  %  { r ,  \"     +     ( params . get (  \" conditionIf \"  )  . asString (  )  )  )     +     \"  }  )  \"  )  )  ;", "}", "if    ( params . hasDefined (  \" conditionUnless \"  )  )     {", "add . get ( PREDICATE )  . set (  (  (  \" not   exists (  %  { r ,  \"     +     ( params . get (  \" conditionUnless \"  )  . asString (  )  )  )     +     \"  }  )  \"  )  )  ;", "}", "if    ( params . hasDefined (  \" condition \"  )  )     {", "add . get ( PREDICATE )  . set (  (  (  \" not   exists (  %  { r ,  \"     +     ( params . get (  \" condition \"  )  . asString (  )  )  )     +     \"  }  )  \"  )  )  ;", "}", "final   String [  ]    unsupportedConfigParams    =    new   String [  ]  {     \" resolveHosts \"  ,     \" fileDateFormat \"  ,     \" renameOnRotate \"  ,     \" encoding \"  ,     \" locale \"  ,     \" requestAttributesEnabled \"  ,     \" buffered \"     }  ;", "for    ( String   unsupportedConfigParam    :    unsupportedConfigParams )     {", "if    ( params . hasDefined ( unsupportedConfigParam )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute ( unsupportedConfigParam ,    valveName )  )  ;", "}", "}", "newAddOperations . put ( WebMigrateOperation . VALVE _ ACCESS _ LOG _ ADDRESS ,    add )  ;", "}", "METHOD_END"], "methodName": ["migrateAccessLogValve"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =    newAddOp . get ( WebConnectorDefinition . PROTOCOL . getName (  )  )  . asString (  )  ;", "String   scheme    =    null ;", "if    ( newAddOp . hasDefined ( WebConnectorDefinition . SCHEME . getName (  )  )  )     {", "scheme    =    newAddOp . get ( WebConnectorDefinition . SCHEME . getName (  )  )  . asString (  )  ;", "}", "final   PathAddress   newAddress ;", "final   ModelNode   addConnector ;", "switch    ( protocol )     {", "case    \" Http 1  1 Protocol \"     :", "case    \" Http 1  1 NioProtocol \"     :", "case    \" Http 1  1 AprProtocol \"     :", "case    \" HTTP /  1  .  1  \"     :", "if    (  ( scheme    =  =    null )     |  |     ( scheme . equals (  \" http \"  )  )  )     {", "newAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,     . DEFAULT _ SERVER _ PATH ,    PathElement . pathElement ( HTTP _ LISTENER ,    address . getLastElement (  )  . getValue (  )  )  )  ;", "addConnector    =    createAddOperation ( newAddress )  ;", "} else", "if    ( scheme . equals (  \" https \"  )  )     {", "newAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,     . DEFAULT _ SERVER _ PATH ,    PathElement . pathElement ( HTTPS _ LISTENER ,    address . getLastElement (  )  . getValue (  )  )  )  ;", "addConnector    =    createAddOperation ( newAddress )  ;", ". SSLInformation   sslInfo    =    createSecurityRealm ( context ,    newAddOperations ,    legacyModelAddOps ,    newAddress . getLastElement (  )  . getValue (  )  ,    warnings ,    domainMode )  ;", "if    ( sslInfo    =  =    null )     {", "throw   WebLogger . ROOT _ LOGGER . noSslConfig (  )  ;", "} else    {", "addConnector . get ( SECURITY _ REALM )  . set ( sslInfo . realmName )  ;", "ModelNode   verify    =    sslInfo . verifyClient ;", "if    ( verify . isDefined (  )  )     {", "if    (  ( verify . getType (  )  )     =  =     ( EXPRESSION )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotTranslateVerifyClientExpression ( verify . toString (  )  )  )  ;", "addConnector . get ( Constants . VERIFY _ CLIENT )  . set ( verify )  ;", "} else    {", "String   translated    =    translateVerifyClient ( verify . asString (  )  ,    warnings )  ;", "if    ( translated    !  =    null )     {", "addConnector . get ( Constants . VERIFY _ CLIENT )  . set ( translated )  ;", "}", "}", "}", "addConnector . get ( SSL _ SESSION _ CACHE _ SIZE )  . set ( sslInfo . sessionCacheSize )  ;", "addConnector . get ( SSL _ SESSION _ TIMEOUT )  . set ( sslInfo . sessionTimeout )  ;", "addConnector . get ( ENABLED _ PROTOCOLS )  . set ( sslInfo . sslProtocol )  ;", "addConnector . get ( ENABLED _ CIPHER _ SUITES )  . set ( sslInfo . cipherSuites )  ;", "}", "} else    {", "newAddress    =    null ;", "addConnector    =    null ;", "}", "break ;", "case    \" AjpAprProtocol \"     :", "case    \" AjpProtocol \"     :", "case    \" AJP /  1  .  3  \"     :", "newAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,     . DEFAULT _ SERVER _ PATH ,    PathElement . pathElement ( AJP _ LISTENER ,    address . getLastElement (  )  . getValue (  )  )  )  ;", "addConnector    =    createAddOperation ( newAddress )  ;", "addConnector . get ( Constants . SCHEME )  . set ( newAddOp . get ( Constants . SCHEME )  )  ;", "break ;", "default    :", "newAddress    =    null ;", "addConnector    =    null ;", "}", "if    ( newAddress    =  =    null )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( newAddOp )  )  ;", "return ;", "}", "addConnector . get ( Constants . SOCKET _ BINDING )  . set ( newAddOp . get ( ModelDescriptionConstants . SOCKET _ BINDING )  )  ;", "addConnector . get ( Constants . SECURE )  . set ( newAddOp . get ( WebConnectorDefinition . SECURE . getName (  )  )  )  ;", "addConnector . get ( REDIRECT _ SOCKET )  . set ( newAddOp . get ( WebConnectorDefinition . REDIRECT _ BINDING . getName (  )  )  )  ;", "addConnector . get ( Constants . ENABLED )  . set ( newAddOp . get ( WebConnectorDefinition . ENABLED . getName (  )  )  )  ;", "addConnector . get ( RESOLVE _ PEER _ ADDRESS )  . set ( newAddOp . get ( WebConnectorDefinition . ENABLE _ LOOKUPS . getName (  )  )  )  ;", "addConnector . get ( Constants . MAX _ POST _ SIZE )  . set ( newAddOp . get ( WebConnectorDefinition . MAX _ POST _ SIZE . getName (  )  )  )  ;", "addConnector . get ( REDIRECT _ SOCKET )  . set ( newAddOp . get ( WebConnectorDefinition . REDIRECT _ BINDING . getName (  )  )  )  ;", "addConnector . get ( Constants . MAX _ CONNECTIONS )  . set ( newAddOp . get ( WebConnectorDefinition . MAX _ CONNECTIONS . getName (  )  )  )  ;", "addConnector . get ( MAX _ BUFFERED _ REQUEST _ SIZE )  . set ( newAddOp . get ( WebConnectorDefinition . MAX _ SAVE _ POST _ SIZE . getName (  )  )  )  ;", "addConnector . get ( Constants . SECURE )  . set ( newAddOp . get ( WebConnectorDefinition . SECURE . getName (  )  )  )  ;", "if    ( newAddOp . hasDefined ( WebConnectorDefinition . REDIRECT _ PORT . getName (  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebConnectorDefinition . REDIRECT _ PORT . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "if    ( newAddOp . hasDefined ( WebConnectorDefinition . PROXY _ BINDING . getName (  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebConnectorDefinition . PROXY _ BINDING . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "if    ( newAddOp . hasDefined ( WebConnectorDefinition . EXECUTOR . getName (  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebConnectorDefinition . EXECUTOR . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "newAddOperations . put ( PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  ,    addConnector )  ;", "}", "METHOD_END"], "methodName": ["migrateConnector"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "newAddOp . get ( ModelDescriptionConstants . ADDRESS )  . set ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    PathElement . pathElement ( SERVLET _ CONTAINER ,     \" default \"  )  ,    PATH _ JSP )  . toModelNode (  )  )  ;", "newAdds . put ( PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  ,    newAddOp )  ;", "}", "METHOD_END"], "methodName": ["migrateJSPConfig"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "migrateWelcomeFiles ( newAddOperations ,    newAddOp )  ;", "ModelNode   mime    =    newAddOp . get (  \" mime - mapping \"  )  ;", "if    ( mime . isDefined (  )  )     {", "for    ( ModelNode   w    :    mime . asList (  )  )     {", "PathAddress   wa    =    PathAddress . pathAddress ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    PathElement . pathElement ( SERVLET _ CONTAINER ,     \" default \"  )  ,    PathElement . pathElement ( Constants . MIME _ MAPPING ,    w . asProperty (  )  . getName (  )  )  )  )  ;", "ModelNode   add    =    createAddOperation ( wa )  ;", "add . get ( Constants . VALUE )  . set ( w . asProperty (  )  . getValue (  )  )  ;", "newAddOperations . put ( wa ,    add )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["migrateMimeMapping"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "PathAddress   newAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    WebMigrateOperation . DEFAULT _ SERVER _ PATH ,    PathElement . pathElement ( HOST ,    address . getElement (  (  ( address . size (  )  )     -     2  )  )  . getValue (  )  )  ,    PATH _ SSO )  ;", "ModelNode   add    =    createAddOperation ( newAddress )  ;", "add . get ( Constants . DOMAIN )  . set ( newAddOp . get ( WebSSODefinition . DOMAIN . getName (  )  )  . clone (  )  )  ;", "add . get ( Constants . HTTP _ ONLY )  . set ( newAddOp . get ( WebSSODefinition . HTTP _ ONLY . getName (  )  )  . clone (  )  )  ;", "if    ( newAddOp . hasDefined ( WebSSODefinition . CACHE _ CONTAINER . getName (  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebSSODefinition . CACHE _ CONTAINER . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "if    ( newAddOp . hasDefined ( WebSSODefinition . REAUTHENTICATE . getName (  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebSSODefinition . REAUTHENTICATE . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "if    ( newAddOp . hasDefined ( WebSSODefinition . CACHE _ NAME . getName (  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( WebSSODefinition . CACHE _ NAME . getName (  )  ,    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  )  )  ;", "}", "newAddOperations . put ( newAddress ,    add )  ;", "}", "METHOD_END"], "methodName": ["migrateSso"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "newAddOp . get ( ModelDescriptionConstants . ADDRESS )  . set ( PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  )  . toModelNode (  )  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . OP _ ADDR )  )  ;", "ModelNode   subsystemAdd    =    createAddOperation ( address )  ;", "ModelNode   defaultServer    =    newAddOperations . get ( address . append (  . DEFAULT _ SERVER _ PATH )  )  ;", "if    ( defaultServer . hasDefined ( DEFAULT _ HOST )  )     {", "subsystemAdd . get ( DEFAULT _ VIRTUAL _ HOST )  . set ( defaultServer . get ( DEFAULT _ HOST )  )  ;", "}", "newAddOperations . put ( address ,    subsystemAdd )  ;", "}", "METHOD_END"], "methodName": ["migrateSubsystem"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   Map < PathAddress ,    ModelNode >    result    =    new   LinkedHashMap <  >  (  )  ;", "MultistepUtil . recordSteps ( context ,    migrations ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["migrateSubsystems"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( newAddOp . hasDefined ( WebValveDefinition . CLASS _ NAME . getName (  )  )  )     {", "String   valveClassName    =    newAddOp . get ( WebValveDefinition . CLASS _ NAME . getName (  )  )  . asString (  )  ;", "String   valveName    =    address . getLastElement (  )  . getValue (  )  ;", "switch    ( valveClassName )     {", "case    \" CrawlerSessionManagerValve \"     :", "PathAddress   crawlerAddress    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    SUBSYSTEM _ NAME )  ,    PathElement . pathElement ( SERVLET _ CONTAINER ,     \" default \"  )  ,    PathElement . pathElement ( Constants . SETTING ,    CRAWLER _ SESSION _ MANAGEMENT )  )  ;", "ModelNode   crawlerAdd    =    createAdd ( crawlerAddress )  ;", "if    ( newAddOp . hasDefined ( WebValveDefinition . PARAMS . getName (  )  )  )     {", "ModelNode   params    =    newAddOp . get ( WebValveDefinition . PARAMS . getName (  )  )  ;", "if    ( params . hasDefined (  \" crawlerUserAgents \"  )  )     {", "crawlerAdd . get ( USER _ AGENTS )  . set ( params . get (  \" crawlerUserAgents \"  )  )  ;", "}", "if    ( params . hasDefined (  \" sessionInactiveInterval \"  )  )     {", "crawlerAdd . get ( Constants . SESSION _ TIMEOUT )  . set ( params . get (  \" sessionInactiveInterval \"  )  )  ;", "}", "}", "newAdds . put ( crawlerAddress ,    crawlerAdd )  ;", "break ;", "case    \" RequestDumperValve \"     :", "newAdds . putIfAbsent ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS )  ,    createAdd ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS )  )  )  ;", "PathAddress   filterAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS ,    PathElement . pathElement ( INSTANCE . getPathElement (  )  . getKey (  )  ,    valveName )  )  ;", "ModelNode   filterAdd    =    createAdd ( filterAddress )  ;", "filterAdd . get ( EXPRESSION . getName (  )  )  . set (  \" dump - request \"  )  ;", "newAdds . put ( filterAddress ,    filterAdd )  ;", "break ;", "case    \" StuckThreadDetectionValve \"     :", "newAdds . putIfAbsent ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS )  ,    createAdd ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS )  )  )  ;", "PathAddress   filterAddressStuckThread    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS ,    PathElement . pathElement ( INSTANCE . getPathElement (  )  . getKey (  )  ,    valveName )  )  ;", "ModelNode   filterAddStuckThread    =    createAdd ( filterAddressStuckThread )  ;", "StringBuilder   expressionStruckThread    =    new   StringBuilder (  \" stuck - thread - detector \"  )  ;", "if    ( newAddOp . hasDefined ( WebValveDefinition . PARAMS . getName (  )  )  )     {", "ModelNode   params    =    newAddOp . get ( WebValveDefinition . PARAMS . getName (  )  )  ;", "if    ( params . hasDefined (  \" threshold \"  )  )     {", "expressionStruckThread . append (  \"  ( threshhold =  '  \"  )  . append ( params . get (  \" threshold \"  )  . asInt (  )  )  . append (  \"  '  )  \"  )  ;", "}", "if    ( params . hasDefined (  \" interruptThreadThreshold \"  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute (  \" interruptThreadThreshold \"  ,    valveName )  )  ;", "}", "}", "filterAddStuckThread . get ( EXPRESSION . getName (  )  )  . set ( expressionStruckThread . toString (  )  )  ;", "newAdds . put ( filterAddressStuckThread ,    filterAddStuckThread )  ;", "break ;", "case    \" AccessLogValve \"     :", "newAddOp . get ( WebAccessLogDefinition . EXTENDED . getName (  )  )  . set ( false )  ;", "migrateAccessLogValve ( newAdds ,    newAddOp ,    valveName ,    warnings )  ;", "break ;", "case    \" ExtendedAccessLogValve \"     :", "newAddOp . get ( WebAccessLogDefinition . EXTENDED . getName (  )  )  . set ( true )  ;", "migrateAccessLogValve ( newAdds ,    newAddOp ,    valveName ,    warnings )  ;", "break ;", "case    \" RemoteHostValve \"     :", "createAccesControlExpressionFilter ( newAdds ,    warnings ,    valveName ,     \"  % h \"  ,    newAddOp )  ;", "break ;", "case    \" RemoteAddrValve \"     :", "createAccesControlExpressionFilter ( newAdds ,    warnings ,    valveName ,     \"  % a \"  ,    newAddOp )  ;", "break ;", "case    \" RemoteIpValve \"     :", "if    ( newAddOp . hasDefined ( WebValveDefinition . PARAMS . getName (  )  )  )     {", "StringBuilder   expression    =    new   StringBuilder (  )  ;", "ModelNode   params    =    newAddOp . get ( WebValveDefinition . PARAMS . getName (  )  )  ;", "if    (  ( params . hasDefined (  \" remoteIpHeader \"  )  )     &  &     (  !  ( Headers . X _ FORWARDED _ FOR _ STRING . equalsIgnoreCase ( params . get (  \" remoteIpHeader \"  )  . asString (  )  )  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute (  \" remoteIpHeader \"  ,    valveName )  )  ;", "}", "if    (  ( params . hasDefined (  \" protocolHeader \"  )  )     &  &     (  !  ( Headers . X _ FORWARDED _ PROTO _ STRING . equalsIgnoreCase ( params . get (  \" protocolHeader \"  )  . asString (  )  )  )  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute (  \" protocolHeader \"  ,    valveName )  )  ;", "}", "if    ( params . hasDefined (  \" httpServerPort \"  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute (  \" httpServerPort \"  ,    valveName )  )  ;", "}", "if    ( params . hasDefined (  \" httpsServerPort \"  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute (  \" httpsServerPort \"  ,    valveName )  )  ;", "}", "if    ( params . hasDefined (  \" proxiesHeader \"  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute (  \" proxiesHeader \"  ,    valveName )  )  ;", "}", "if    ( params . hasDefined (  \" protocolHeaderHttpsValue \"  )  )     {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValveAttribute (  \" protocolHeaderHttpsValue \"  ,    valveName )  )  ;", "}", "boolean   trustedProxies    =    false ;", "if    ( params . hasDefined (  \" trustedProxies \"  )  )     {", "expression . append (  \" regex ( pattern =  \\  \"  \"  )  . append ( params . get (  \" trustedProxies \"  )  . asString (  )  )  . append (  \"  \\  \"  ,    value =  %  { i , x - forwarded - for }  ,    full - match = true )  \"  )  ;", "trustedProxies    =    true ;", "}", "String   internalProxies ;", "if    ( params . hasDefined (  \" internalProxies \"  )  )     {", "internalProxies    =    params . get (  \" internalProxies \"  )  . asString (  )  ;", "} else    {", "internalProxies    =     \"  1  0  \\  \\  .  \\  \\ d {  1  ,  3  }  \\  \\  .  \\  \\ d {  1  ,  3  }  \\  \\  .  \\  \\ d {  1  ,  3  }  |  1  9  2  \\  \\  .  1  6  8  \\  \\  .  \\  \\ d {  1  ,  3  }  \\  \\  .  \\  \\ d {  1  ,  3  }  |  1  6  9  \\  \\  .  2  5  4  \\  \\  .  \\  \\ d {  1  ,  3  }  \\  \\  .  \\  \\ d {  1  ,  3  }  |  1  2  7  \\  \\  .  \\  \\ d {  1  ,  3  }  \\  \\  .  \\  \\ d {  1  ,  3  }  \\  \\  .  \\  \\ d {  1  ,  3  }  \"  ;", "}", "if    ( trustedProxies )     {", "expression . append (  \"    and    \"  )  ;", "}", "expression . append (  \" regex ( pattern =  \\  \"  \"  )  . append ( internalProxies )  . append (  \"  \\  \"  ,    value =  %  { i , x - forwarded - for }  ,    full - match = true )  \"  )  ;", "expression . append (  \"     -  >    proxy - peer - address \"  )  ;", "createExpressionFilter ( newAdds ,    valveName ,    expression . toString (  )  )  ;", "}", "break ;", "default    :", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateValve ( valveName )  )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["migrateValves"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "PathAddress   newAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    WebMigrateOperation . DEFAULT _ SERVER _ PATH ,    PathElement . pathElement ( HOST ,    host )  )  ;", "ModelNode   add    =    createAddOperation ( newAddress )  ;", "if    (  ( newAddOp . hasDefined ( WebVirtualHostDefinition . ENABLE _ WELCOME _ ROOT . getName (  )  )  )     &  &     ( newAddOp . get ( WebVirtualHostDefinition . ENABLE _ WELCOME _ ROOT . getName (  )  )  . asBoolean (  )  )  )     {", "PathAddress   welcomeAddress    =    PathAddress . pathAddress ( newAddress ,    PathElement . pathElement ( LOCATION ,     \"  /  \"  )  )  ;", "ModelNode   welcomeAdd    =    createAddOperation ( welcomeAddress )  ;", "welcomeAdd . get ( HANDLER )  . set (  \" welcome - content \"  )  ;", "newAddOperations . put ( welcomeAddress ,    welcomeAdd )  ;", "}", "add . get ( Constants . ALIAS )  . set ( newAddOp . get ( WebVirtualHostDefinition . ALIAS . getName (  )  )  . clone (  )  )  ;", "add . get ( Constants . DEFAULT _ WEB _ MODULE )  . set ( newAddOp . get ( WebVirtualHostDefinition . DEFAULT _ WEB _ MODULE . getName (  )  )  )  ;", "newAddOperations . put ( newAddress ,    add )  ;", "}", "METHOD_END"], "methodName": ["migrateVirtualHost"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   customFilterAddresses    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS ,    PathElement . pathElement ( INSTANCE . getPathElement (  )  . getKey (  )  )  )  ;", "final   PathAddress   expressionFilterAddresses    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    UndertowExtension . PATH _ FILTERS ,    PathElement . pathElement ( ExpressionFilterDefinition . INSTANCE . getPathElement (  )  . getKey (  )  )  )  ;", "List < PathAddress >    filterAddresses    =    new   ArrayList <  >  (  )  ;", "for    ( PathAddress   a    :    newAddOperations . keySet (  )  )     {", "if    (  ( wildcardEquals ( customFilterAddresses ,    a )  )     |  |     ( wildcardEquals ( expressionFilterAddresses ,    a )  )  )     {", "filterAddresses . add ( a )  ;", "}", "}", "boolean   hasAccessLogValve    =    newAddOperations . containsKey (  . VALVE _ ACCESS _ LOG _ ADDRESS )  ;", "if    ( hasAccessLogValve    |  |     (  !  ( filterAddresses . isEmpty (  )  )  )  )     {", "for    ( String   host    :    hosts )     {", "PathAddress   hostAddress    =    PathAddress . pathAddress ( SUBSYSTEM _ PATH ,     . DEFAULT _ SERVER _ PATH ,    PathElement . pathElement ( HOST ,    host )  )  ;", "for    ( PathAddress   filterAddress    :    filterAddresses )     {", "PathAddress   filterRefAddress    =    PathAddress . pathAddress ( hostAddress ,    PathElement . pathElement ( FILTER _ REF ,    filterAddress . getLastElement (  )  . getValue (  )  )  )  ;", "ModelNode   filterRefAdd    =    createAddOperation ( filterRefAddress )  ;", "newAddOperations . put ( filterRefAddress ,    filterRefAdd )  ;", "}", "if    ( hasAccessLogValve )     {", "PathAddress   accessLogAddress    =    PathAddress . pathAddress ( hostAddress ,    PATH _ ACCESS _ LOG )  ;", "if    (  !  ( newAddOperations . containsKey ( accessLogAddress )  )  )     {", "ModelNode   operation    =    newAddOperations . get (  . VALVE _ ACCESS _ LOG _ ADDRESS )  . clone (  )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( accessLogAddress . toModelNode (  )  )  ;", "newAddOperations . put ( accessLogAddress ,    operation )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["migrateVirtualHostChildren"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   welcome    =    newAddOp . get (  \" welcome - file \"  )  ;", "if    ( welcome . isDefined (  )  )     {", "for    ( ModelNode   w    :    welcome . asList (  )  )     {", "PathAddress   wa    =    PathAddress . pathAddress ( PathAddress . pathAddress ( SUBSYSTEM _ PATH ,    PathElement . pathElement ( SERVLET _ CONTAINER ,     \" default \"  )  ,    PathElement . pathElement ( Constants . WELCOME _ FILE ,    w . asString (  )  )  )  )  ;", "ModelNode   add    =    createAdd ( wa )  ;", "newAdds . put ( wa ,    add )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["migrateWelcomeFiles"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( WebMigrateOperation . MIGRATE ,    resourceDescriptionResolver )  . setAccessConstraints ( READ _ WHOLE _ CONFIG )  . setReplyParameters ( WebMigrateOperation . MIGRATION _ WARNINGS _ ATTR ,    WebMigrateOperation . MIGRATION _ ERROR _ ATTR )  . build (  )  ,    WebMigrateOperation . MIGRATE _ INSTANCE )  ;", "registry . registerOperationHandler ( new   SimpleOperationDefinitionBuilder ( WebMigrateOperation . DESCRIBE _ MIGRATION ,    resourceDescriptionResolver )  . setAccessConstraints ( READ _ WHOLE _ CONFIG )  . setReplyParameters ( WebMigrateOperation . MIGRATION _ WARNINGS _ ATTR )  . setReadOnly (  )  . build (  )  ,    WebMigrateOperation . DESCRIBE _ MIGRATION _ INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["registerOperations"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "ModelNode   removeOperation    =    createRemoveOperation ( subsystemAddress )  ;", "migrationOperations . put ( subsystemAddress ,    removeOperation )  ;", "if    ( standalone )     {", "removeOperation    =    createRemoveOperation (  . EXTENSION _ ADDRESS )  ;", "migrationOperations . put (  . EXTENSION _ ADDRESS ,    removeOperation )  ;", "}", "}", "METHOD_END"], "methodName": ["removeWebSubsystem"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "Set < String >    hosts    =    new   LinkedHashSet <  >  (  )  ;", "for    ( ModelNode   legacyAddOp    :    legacyModelDescription . get ( ModelDescriptionConstants . RESULT )  . asList (  )  )     {", "final   ModelNode   newAddOp    =    legacyAddOp . clone (  )  ;", "PathAddress   address    =    PathAddress . pathAddress ( newAddOp . get ( ModelDescriptionConstants . ADDRESS )  )  ;", "if    (  ( address . size (  )  )     =  =     1  )     {", "migrateSubsystem ( newAddOperations ,    newAddOp )  ;", "} else", "if    ( address . equals ( PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . STATIC _ RESOURCES _ PATH )  )  )     {", "} else", "if    ( address . equals ( PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . JSP _ CONFIGURATION _ PATH )  )  )     {", "migrateJSPConfig ( newAddOperations ,    newAddOp )  ;", "} else", "if    ( address . equals ( PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . CONTAINER _ PATH )  )  )     {", "migrateMimeMapping ( newAddOperations ,    newAddOp )  ;", "} else", "if    ( wildcardEquals ( address ,    PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . CONNECTOR _ PATH )  )  )     {", "migrateConnector ( context ,    newAddOperations ,    newAddOp ,    address ,    legacyModelDescription ,    warnings ,    domainMode )  ;", "} else", "if    ( wildcardEquals ( address ,    PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . CONNECTOR _ PATH ,    WebExtension . SSL _ PATH )  )  )     {", "} else", "if    ( wildcardEquals ( address ,    PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . HOST _ PATH )  )  )     {", "String   host    =    address . getLastElement (  )  . getValue (  )  ;", "hosts . add ( host )  ;", "migrateVirtualHost ( newAddOperations ,    newAddOp ,    host )  ;", "} else", "if    ( wildcardEquals ( address ,    PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . VALVE _ PATH )  )  )     {", "migrateValves ( newAddOperations ,    newAddOp ,    address ,    warnings )  ;", "} else", "if    ( wildcardEquals ( address ,    PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . HOST _ PATH ,    WebExtension . ACCESS _ LOG _ PATH )  )  )     {", "migrateAccessLog ( newAddOperations ,    newAddOp ,    address ,    legacyModelDescription ,    warnings )  ;", "} else", "if    ( wildcardEquals ( address ,    PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . HOST _ PATH ,    WebExtension . ACCESS _ LOG _ PATH ,    WebExtension . DIRECTORY _ PATH )  )  )     {", "} else", "if    ( wildcardEquals ( address ,    PathAddress . pathAddress ( WebExtension . SUBSYSTEM _ PATH ,    WebExtension . HOST _ PATH ,    WebExtension . SSO _ PATH )  )  )     {", "migrateSso ( newAddOperations ,    newAddOp ,    address ,    warnings )  ;", "} else    {", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotMigrateResource ( legacyAddOp )  )  ;", "}", "}", "if    (  !  ( hosts . isEmpty (  )  )  )     {", "migrateVirtualHostChildren ( newAddOperations ,    hosts )  ;", "}", "newAddOperations . remove (  . VALVE _ ACCESS _ LOG _ ADDRESS )  ;", "}", "METHOD_END"], "methodName": ["transformResources"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "switch    ( s )     {", "case    \" opalNoCA \"     :", "case    \" opal \"     :", "{", "return    \" REQUESTED \"  ;", "}", "case    \" require \"     :", "{", "return    \" REQUIRED \"  ;", "}", "case    \" none \"     :", "{", "return    \" NOT _ REQUESTED \"  ;", "}", "case    \" true \"     :", "{", "return    \" REQUIRED \"  ;", "}", "case    \" false \"     :", "{", "return    \" NOT _ REQUESTED \"  ;", "}", "default    :", "{", "warnings . add ( WebLogger . ROOT _ LOGGER . couldNotTranslateVerifyClient ( s )  )  ;", "return   null ;", "}", "}", "}", "METHOD_END"], "methodName": ["translateVerifyClient"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( a 1  . size (  )  )     !  =     ( a 2  . size (  )  )  )     {", "return   false ;", "}", "f    ( int   i    =     0  ;    i    <     ( a 1  . size (  )  )  ;     +  + i )     {", "PathElement   p 1     =    a 1  . getElement ( i )  ;", "PathElement   p 2     =    a 2  . getElement ( i )  ;", "if    (  !  ( p 1  . getKey (  )  . equals ( p 2  . getKey (  )  )  )  )     {", "return   false ;", "}", "if    (  (  !  ( p 1  . isWildcard (  )  )  )     &  &     (  !  ( p 2  . isWildcard (  )  )  )  )     {", "if    (  !  ( p 1  . getValue (  )  . equals ( p 2  . getValue (  )  )  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["wildcardEquals"], "fileName": "org.jboss.as.web.WebMigrateOperation"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   config    =    new   ModelNode (  )  ;", "PathAddress   containerPath    =    PathAddress . pathAddress ( parent ,    WebExtension . CONTAINER _ PATH )  ;", "config . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "config . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( containerPath . toModelNode (  )  )  ;", "list . add ( config )  ;", ". addDefaultStaticConfiguration ( parent ,    list )  ;", ". addDefaultJSPConfiguration ( parent ,    list )  ;", "}", "METHOD_END"], "methodName": ["addDefaultContainerConfig"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   jspAddress    =    PathAddress . pathAddress ( parent ,    WebExtension . JSP _ CONFIGURATION _ PATH )  ;", "final   ModelNode   jsp    =    new   ModelNode (  )  ;", "jsp . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "jsp . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( jspAddress . toModelNode (  )  )  ;", "list . add ( jsp )  ;", "}", "METHOD_END"], "methodName": ["addDefaultJSPConfiguration"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( parent ,    WebExtension . STATIC _ RESOURCES _ PATH )  ;", "final   ModelNode   resources    =    new   ModelNode (  )  ;", "resources . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "resources . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "list . add ( resources )  ;", "}", "METHOD_END"], "methodName": ["addDefaultStaticConfiguration"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "Namespace   currentNamespace    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "if    (  ( currentNamespace . compareTo ( namespace )  )     >  =     0  )     {", "return ;", "}", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "METHOD_END"], "methodName": ["attributeSupportedSince"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "final   ModelNode   connector    =    new   ModelNode (  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value ;", "break ;", "case   SOCKET _ BINDING    :", "WebConnectorDefinition . SOCKET _ BINDING . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   SCHEME    :", "WebConnectorDefinition . SCHEME . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   PROTOCOL    :", "WebConnectorDefinition . PROTOCOL . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   EXECUTOR    :", "WebConnectorDefinition . EXECUTOR . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   ENABLED    :", "WebConnectorDefinition . ENABLED . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   ENABLE _ LOOKUPS    :", "WebConnectorDefinition . ENABLE _ LOOKUPS . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   PROXY _ BINDING    :", ". attributeSupportedSince ( Namespace . WEB _  2  _  1  ,    reader ,    i )  ;", "WebConnectorDefinition . PROXY _ BINDING . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   PROXY _ NAME    :", "WebConnectorDefinition . PROXY _ NAME . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   PROXY _ PORT    :", "WebConnectorDefinition . PROXY _ PORT . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   MAX _ POST _ SIZE    :", "WebConnectorDefinition . MAX _ POST _ SIZE . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   MAX _ SAVE _ POST _ SIZE    :", "WebConnectorDefinition . MAX _ SAVE _ POST _ SIZE . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   SECURE    :", "WebConnectorDefinition . SECURE . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   REDIRECT _ BINDING    :", ". attributeSupportedSince ( Namespace . WEB _  2  _  1  ,    reader ,    i )  ;", "WebConnectorDefinition . REDIRECT _ BINDING . parseAndSetParameter ( value ,    connector ,    reader )  ;", "connector . remove ( WebConnectorDefinition . REDIRECT _ PORT . getName (  )  )  ;", "break ;", "case   REDIRECT _ PORT    :", "WebConnectorDefinition . REDIRECT _ PORT . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "case   MAX _ CONNECTIONS    :", "WebConnectorDefinition . MAX _ CONNECTIONS . parseAndSetParameter ( value ,    connector ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "connector . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "PathAddress   address    =    PathAddress . pathAddress ( parent ,    PathElement . pathElement ( Constants . CONNECTOR ,    name )  )  ;", "connector . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "list . add ( connector )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   WEB _  1  _  0     :", "case   WEB _  1  _  1     :", "case   WEB _  1  _  2     :", "case   WEB _  1  _  3     :", "case   WEB _  1  _  4     :", "case   WEB _  1  _  5     :", "case   WEB _  2  _  0     :", "case   WEB _  2  _  1     :", "case   WEB _  2  _  2     :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   SSL    :", ". parseSsl ( reader ,    address ,    list )  ;", "break ;", "case   VIRTUAL _ SERVER    :", "String   value    =    readStringAttributeElement ( reader ,    Attribute . NAME . getLocalName (  )  )  ;", "WebConnectorDefinition . VIRTUAL _ SERVER . parseAndAddParameterElement ( value ,    connector ,    reader )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseConnector"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( parent ,    WebExtension . CONTAINER _ PATH )  ;", "final   ModelNode   config    =    new   ModelNode (  )  ;", "config . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "config . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "list . add ( config )  ;", "if    (  ( reader . getAttributeCount (  )  )     >     0  )     {", "throw   unexpectedAttribute ( reader ,     0  )  ;", "}", "boolean   staticResourcesConfigured    =    false ;", "boolean   jspConfigured    =    false ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   STATIC _ RESOURCES    :", "{", ". parseStaticResources ( reader ,    parent ,    list )  ;", "staticResourcesConfigured    =    true ;", "break ;", "}", "case   JSP _ CONFIGURATION    :", "{", ". parseJSPConfiguration ( reader ,    parent ,    list )  ;", "jspConfigured    =    true ;", "break ;", "}", "case   MIME _ MAPPING    :", "{", "final   String [  ]    array    =    requireAttributes ( reader ,    Attribute . NAME . getLocalName (  )  ,    Attribute . VALUE . getLocalName (  )  )  ;", "WebContainerDefinition . MIME _ MAPPINGS . parseAndAddParameterElement ( array [  0  ]  ,    array [  1  ]  ,    config ,    reader )  ;", "requireNoContent ( reader )  ;", "break ;", "}", "case   WELCOME _ FILE    :", "{", "final   String   welcomeFile    =    reader . getElementText (  )  . trim (  )  ;", "WebContainerDefinition . WELCOME _ FILES . parseAndAddParameterElement ( welcomeFile ,    config ,    reader )  ;", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "if    (  ! staticResourcesConfigured )     {", ". addDefaultStaticConfiguration ( parent ,    list )  ;", "}", "if    (  ! jspConfigured )     {", ". addDefaultJSPConfiguration ( parent ,    list )  ;", "}", "}", "METHOD_END"], "methodName": ["parseContainerConfig"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   dirAddress    =    PathAddress . pathAddress ( address ,    filePath )  ;", "final   ModelNode   directory    =    new   ModelNode (  )  ;", "directory . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "directory . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( dirAddress . toModelNode (  )  )  ;", "final   int   count 2     =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count 2  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PATH    :", "directory . get ( Constants . PATH )  . set ( value )  ;", "break ;", "case   RELATIVE _ TO    :", "directory . get ( Constants . RELATIVE _ TO )  . set ( value )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "list . add ( directory )  ;", "}", "METHOD_END"], "methodName": ["parseDirOrFile"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "final   ModelNode   host    =    new   ModelNode (  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value ;", "break ;", "case   DEFAULT _ WEB _ MODULE    :", "WebVirtualHostDefinition . DEFAULT _ WEB _ MODULE . parseAndSetParameter ( value ,    host ,    reader )  ;", "break ;", "case   ENABLE _ WELCOME _ ROOT    :", "WebVirtualHostDefinition . ENABLE _ WELCOME _ ROOT . parseAndSetParameter ( value ,    host ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "final   PathAddress   address    =    PathAddress . pathAddress ( parent ,    PathElement . pathElement ( Constants . VIRTUAL _ SERVER ,    name )  )  ;", "host . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "host . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "list . add ( host )  ;", "int   rewriteCount    =     0  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   WEB _  1  _  0     :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ALIAS    :", "host . get ( Constants . ALIAS )  . add ( readStringAttributeElement ( reader ,    Attribute . NAME . getLocalName (  )  )  )  ;", "break ;", "case   ACCESS _ LOG    :", ". parseHostAccessLog ( reader ,    address ,    list )  ;", "break ;", "case   REWRITE    :", ". parseHostRewrite ( reader ,    address ,    list ,     (  +  + rewriteCount )  )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "break ;", "}", "case   WEB _  1  _  1     :", "case   WEB _  1  _  2     :", "case   WEB _  1  _  3     :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ALIAS    :", "host . get ( Constants . ALIAS )  . add ( readStringAttributeElement ( reader ,    Attribute . NAME . getLocalName (  )  )  )  ;", "break ;", "case   ACCESS _ LOG    :", ". parseHostAccessLog ( reader ,    address ,    list )  ;", "break ;", "case   REWRITE    :", ". parseHostRewrite ( reader ,    address ,    list ,     (  +  + rewriteCount )  )  ;", "break ;", "case   SSO    :", ". parseSso ( reader ,    address ,    list )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "break ;", "}", "case   WEB _  1  _  4     :", "case   WEB _  1  _  5     :", "case   WEB _  2  _  0     :", "case   WEB _  2  _  1     :", "case   WEB _  2  _  2     :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   ALIAS    :", "host . get ( Constants . ALIAS )  . add ( readStringAttributeElement ( reader ,    Attribute . NAME . getLocalName (  )  )  )  ;", "break ;", "case   ACCESS _ LOG    :", ". parseHostAccessLog ( reader ,    address ,    list )  ;", "break ;", "case   REWRITE    :", ". parseHostRewrite ( reader ,    address ,    list ,     (  +  + rewriteCount )  )  ;", "break ;", "case   SSO    :", ". parseSso ( reader ,    address ,    list )  ;", "break ;", "case   VALVE    :", ". parseValve ( reader ,    address ,    list )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseHost"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( parent ,    WebExtension . ACCESS _ LOG _ PATH )  ;", "final   ModelNode   log    =    new   ModelNode (  )  ;", "log . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "log . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PATTERN    :", "WebAccessLogDefinition . PATTERN . parseAndSetParameter ( value ,    log ,    reader )  ;", "break ;", "case   RESOLVE _ HOSTS    :", "WebAccessLogDefinition . RESOLVE _ HOSTS . parseAndSetParameter ( value ,    log ,    reader )  ;", "break ;", "case   EXTENDED    :", "WebAccessLogDefinition . EXTENDED . parseAndSetParameter ( value ,    log ,    reader )  ;", "break ;", "case   PREFIX    :", "WebAccessLogDefinition . PREFIX . parseAndSetParameter ( value ,    log ,    reader )  ;", "break ;", "case   ROTATE    :", "WebAccessLogDefinition . ROTATE . parseAndSetParameter ( value ,    log ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "list . add ( log )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   WEB _  1  _  0     :", "case   WEB _  1  _  1     :", "case   WEB _  1  _  2     :", "case   WEB _  1  _  3     :", "case   WEB _  1  _  4     :", "case   WEB _  1  _  5     :", "case   WEB _  2  _  0     :", "case   WEB _  2  _  1     :", "case   WEB _  2  _  2     :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   DIRECTORY    :", ". parseDirOrFile ( reader ,    address ,    list ,    WebExtension . DIRECTORY _ PATH )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseHostAccessLog"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   rewrite    =    Util . createAddOperation (  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "String   name    =     (  . RULE _ PREFIX )     +    rewriteCount ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   PATTERN    :", "WebReWriteDefinition . PATTERN . parseAndSetParameter ( value ,    rewrite ,    reader )  ;", "break ;", "case   SUBSTITUTION    :", "WebReWriteDefinition . SUBSTITUTION . parseAndSetParameter ( value ,    rewrite ,    reader )  ;", "break ;", "case   FLAGS    :", "WebReWriteDefinition . FLAGS . parseAndSetParameter ( value ,    rewrite ,    reader )  ;", "break ;", "case   NAME    :", "name    =    value ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "final   PathAddress   address    =    PathAddress . pathAddress ( parent ,    PathElement . pathElement ( Constants . REWRITE ,    name )  )  ;", "rewrite . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "list . add ( rewrite )  ;", "int   conditionCount    =     0  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "switch    ( Namespace . forUri ( reader . getNamespaceURI (  )  )  )     {", "case   WEB _  1  _  0     :", "case   WEB _  1  _  1     :", "case   WEB _  1  _  2     :", "case   WEB _  1  _  3     :", "case   WEB _  1  _  4     :", "case   WEB _  1  _  5     :", "case   WEB _  2  _  0     :", "case   WEB _  2  _  1     :", "case   WEB _  2  _  2     :", "{", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   CONDITION    :", "final   ModelNode   condition    =    Util . createAddOperation (  )  ;", "String   condName    =     (  . CONDITION _ PREFIX )     +    conditionCount ;", "final   int   count 2     =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count 2  ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "condName    =    value ;", "break ;", "case   TEST    :", "WebReWriteConditionDefinition . TEST . parseAndSetParameter ( value ,    condition ,    reader )  ;", "break ;", "case   PATTERN    :", "WebReWriteConditionDefinition . PATTERN . parseAndSetParameter ( value ,    condition ,    reader )  ;", "break ;", "case   FLAGS    :", "WebReWriteConditionDefinition . FLAGS . parseAndSetParameter ( value ,    condition ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "PathAddress   condAddress    =    address . append ( PathElement . pathElement ( Constants . CONDITION ,    condName )  )  ;", "condition . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( condAddress . toModelNode (  )  )  ;", "requireNoContent ( reader )  ;", "list . add ( condition )  ;", "conditionCount +  +  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "break ;", "}", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseHostRewrite"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( parent ,    WebExtension . JSP _ CONFIGURATION _ PATH )  ;", "final   ModelNode   jsp    =    new   ModelNode (  )  ;", "jsp . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "jsp . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   DEVELOPMENT    :", "case   DISABLED    :", "case   KEEP _ GENERATED    :", "case   TRIM _ SPACES    :", "case   TAG _ POOLING    :", "case   MAPPED _ FILE    :", "case   CHECK _ INTERVAL    :", "case   MODIFICATION _ TEST _ INTERVAL    :", "case   RECOMPILE _ ON _ FAIL    :", "case   SMAP    :", "case   DUMP _ SMAP    :", "case   GENERATE _ STRINGS _ AS _ CHAR _ ARRAYS    :", "case   ERROR _ ON _ USE _ BEAN _ INVALID _ CLASS _ ATTRIBUTE    :", "case   SCRATCH _ DIR    :", "case   SOURCE _ VM    :", "case   TARGET _ VM    :", "case   JAVA _ ENCODING    :", "case   X _ POWERED _ BY    :", "case   DISPLAY _ SOURCE _ FRAGMENT    :", "WebJSPDefinition . ATTRIBUTES _ MAP . get ( attribute . getLocalName (  )  )  . pAndSetParameter ( value ,    jsp ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "list . add ( jsp )  ;", "}", "METHOD_END"], "methodName": ["parseJSPConfiguration"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( parent ,    WebExtension . SSL _ PATH )  ;", "final   ModelNode   ssl    =    Util . createAddOperation ( address )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "WebSSLDefinition . NAME . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   KEY _ ALIAS    :", "WebSSLDefinition . KEY _ ALIAS . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   PASSWORD    :", "WebSSLDefinition . PASSWORD . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   CERTIFICATE _ KEY _ FILE    :", "WebSSLDefinition . CERTIFICATE _ KEY _ FILE . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   CIPHER _ SUITE    :", "WebSSLDefinition . CIPHER _ SUITE . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   PROTOCOL    :", "WebSSLDefinition . PROTOCOL . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   VERIFY _ CLIENT    :", "WebSSLDefinition . VERIFY _ CLIENT . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   VERIFY _ DEPTH    :", "WebSSLDefinition . VERIFY _ DEPTH . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   CERTIFICATE _ FILE    :", "WebSSLDefinition . CERTIFICATE _ FILE . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   CA _ CERTIFICATE _ FILE    :", "WebSSLDefinition . CA _ CERTIFICATE _ FILE . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   CA _ REVOCATION _ URL    :", "WebSSLDefinition . CA _ REVOCATION _ URL . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   SESSION _ CACHE _ SIZE    :", "WebSSLDefinition . SESSION _ CACHE _ SIZE . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   SESSION _ TIMEOUT    :", "WebSSLDefinition . SESSION _ TIMEOUT . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   CA _ CERTIFICATE _ PASSWORD    :", "WebSSLDefinition . CA _ CERTIFICATE _ PASSWORD . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   KEYSTORE _ TYPE    :", "WebSSLDefinition . KEYSTORE _ TYPE . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   TRUSTSTORE _ TYPE    :", "WebSSLDefinition . TRUSTSTORE _ TYPE . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "case   SSL _ PROTOCOL    :", "WebSSLDefinition . SSL _ PROTOCOL . parseAndSetParameter ( value ,    ssl ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "Namespace   namespace    =    Namespace . forUri ( reader . getNamespaceURI (  )  )  ;", "if    (  ( namespace    =  =     ( Namespace . WEB _  1  _  1  )  )     |  |     ( namespace    =  =     ( Namespace . WEB _  1  _  0  )  )  )     {", "if    (  !  ( ssl . hasDefined ( WebSSLDefinition . KEY _ ALIAS . getName (  )  )  )  )     {", "ssl . get ( WebSSLDefinition . KEY _ ALIAS . getName (  )  )  . set (  \"  \"  )  ;", "}", "}", "requireNoContent ( reader )  ;", "list . add ( ssl )  ;", "}", "METHOD_END"], "methodName": ["parseSsl"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    PathAddress . pathAddress ( parent ,    WebExtension . SSO _ PATH )  ;", "final   ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   CACHE _ CONTAINER    :", "WebSSODefinition . CACHE _ CONTAINER . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   CACHE _ NAME    :", "WebSSODefinition . CACHE _ NAME . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   DOMAIN    :", "WebSSODefinition . DOMAIN . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   REAUTHENTICATE    :", "WebSSODefinition . REAUTHENTICATE . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "case   HTTP _ ONLY    :", ". attributeSupportedSince ( Namespace . WEB _  2  _  2  ,    reader ,    i )  ;", "WebSSODefinition . HTTP _ ONLY . parseAndSetParameter ( value ,    operation ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "list . add ( operation )  ;", "}", "METHOD_END"], "methodName": ["parseSso"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "PathAddress   address    =    PathAddress . pathAddress ( parent ,    WebExtension . STATIC _ RESOURCES _ PATH )  ;", "final   ModelNode   resources    =    new   ModelNode (  )  ;", "resources . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "resources . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   LISTINGS    :", "taticResources . LISTINGS . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "case   SENDFILE    :", "taticResources . SENDFILE . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "case   FILE _ ENCODING    :", "taticResources . FILE _ ENCODING . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "case   READ _ ONLY    :", "taticResources . READ _ ONLY . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "case   WEBDAV    :", "taticResources . WEBDAV . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "case   SECRET    :", "taticResources . SECRET . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "case   MAX _ DEPTH    :", "taticResources . MAX _ DEPTH . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "case   DISABLED    :", "taticResources . DISABLED . parseAndSetParameter ( value ,    resources ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "requireNoContent ( reader )  ;", "list . add ( resources )  ;", "}", "METHOD_END"], "methodName": ["parseStaticResources"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    null ;", "final   ModelNode   valve    =    new   ModelNode (  )  ;", "final   int   count    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "requireNoNamespaceAttribute ( reader ,    i )  ;", "final   String   value    =    reader . getAttributeValue ( i )  ;", "final   Attribute   attribute    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "switch    ( attribute )     {", "case   NAME    :", "name    =    value ;", "break ;", "case   MODULE    :", "WebValveDefinition . MODULE . pAndSetParameter ( value ,    valve ,    reader )  ;", "break ;", "case   CLASS _ NAME    :", "WebValveDefinition . CLASS _ NAME . pAndSetParameter ( value ,    valve ,    reader )  ;", "break ;", "case   ENABLED    :", "WebValveDefinition . ENABLED . pAndSetParameter ( value ,    valve ,    reader )  ;", "break ;", "default    :", "throw   unexpectedAttribute ( reader ,    i )  ;", "}", "}", "if    ( name    =  =    null )     {", "throw   missingRequired ( reader ,    Collections . singleton ( Attribute . NAME )  )  ;", "}", "valve . get ( ModelDescriptionConstants . OP )  . set ( ModelDescriptionConstants . ADD )  ;", "PathAddress   address    =    PathAddress . pathAddress ( parent ,    PathElement . pathElement ( Constants . VALVE ,    name )  )  ;", "valve . get ( ModelDescriptionConstants . OP _ ADDR )  . set ( address . toModelNode (  )  )  ;", "list . add ( valve )  ;", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   Element   element    =    Element . forName ( reader . getLocalName (  )  )  ;", "switch    ( element )     {", "case   PARAM    :", "final   String [  ]    array    =    requireAttributes ( reader ,    Attribute . PARAM _ NAME . getLocalName (  )  ,    Attribute . PARAM _ VALUE . getLocalName (  )  )  ;", "valve . get ( Constants . PARAM )  . get ( array [  0  ]  )  . set ( array [  1  ]  )  ;", "requireNoContent ( reader )  ;", "break ;", "default    :", "throw   unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseValve"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    ( attribute . isMarshallable ( node ,    false )  )     {", "if    (  ! startWriten )     {", "startWriten    =    true ;", "writer . writeStartElement ( origin )  ;", "}", "attribute . marshallAsAttribute ( node ,    false ,    writer )  ;", "}", "return   startWriten ;", "}", "METHOD_END"], "methodName": ["writeAttribute"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   containerConfigStartWritten    =    false ;", "if    ( config . hasDefined ( Constants . STATIC _ RESOURCES )  )     {", "containerConfigStartWritten    =    writeStaticResources ( writer ,    config . get ( Constants . STATIC _ RESOURCES )  )  ;", "}", "if    ( config . hasDefined ( Constants . JSP _ CONFIGURATION )  )     {", "containerConfigStartWritten    =     ( writeJSPConfiguration ( writer ,    config . get ( Constants . JSP _ CONFIGURATION )  ,    containerConfigStartWritten )  )     |  |    containerConfigStartWritten ;", "}", "ModelNode   container    =    config ;", "if    ( config . hasDefined ( Constants . CONTAINER )  )     {", "container    =    config . get ( Constants . CONTAINER )  ;", "}", "if    ( container . hasDefined ( Constants . MIME _ MAPPING )  )     {", "if    (  ! containerConfigStartWritten )     {", "writer . writeStartElement ( Element . CONTAINER _ CONFIG . getLocalName (  )  )  ;", "containerConfigStartWritten    =    true ;", "}", "ContainerDefinition . MIME _ MAPPINGS . marshallAsElement ( container ,    writer )  ;", "}", "if    ( container . hasDefined ( Constants . WELCOME _ FILE )  )     {", "if    (  ! containerConfigStartWritten )     {", "writer . writeStartElement ( Element . CONTAINER _ CONFIG . getLocalName (  )  )  ;", "containerConfigStartWritten    =    true ;", "}", "for    ( final   ModelNode   file    :    container . get ( Constants . WELCOME _ FILE )  . asList (  )  )     {", "writer . writeStartElement ( Element . WELCOME _ FILE . getLocalName (  )  )  ;", "writer . writeCharacters ( file . asString (  )  )  ;", "writer . writeEndElement (  )  ;", "}", "}", "if    ( containerConfigStartWritten )     {", "writer . writeEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeContainerConfig"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   startWritten    =    false ;", "for    ( SimpleAttributeDefinition   def    :    JSPDefinition . JSP _ ATTRIBUTES )     {", "startWritten    =     ( writeJspConfigAttribute ( writer ,    def ,    jsp ,    startWritten ,    containerConfigStartWritten )  )     |  |    startWritten ;", "}", "if    ( startWritten )     {", "writer . writeEndElement (  )  ;", "}", "return   startWritten ;", "}", "METHOD_END"], "methodName": ["writeJSPConfiguration"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    ( attribute . isMarshallable ( config ,    false )  )     {", "if    (  ! startWritten )     {", "if    (  ! containerConfigStartWritten )     {", "writer . writeStartElement ( Element . CONTAINER _ CONFIG . getLocalName (  )  )  ;", "}", "writer . writeStartElement ( Element . JSP _ CONFIGURATION . getLocalName (  )  )  ;", "}", "attribute . marshallAsAttribute ( config ,    false ,    writer )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["writeJspConfigAttribute"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "if    ( attribute . isMarshallable ( config ,    false )  )     {", "if    (  ! startWritten )     {", "writer . writeStartElement ( Element . CONTAINER _ CONFIG . getLocalName (  )  )  ;", "writer . writeStartElement ( Element . STATIC _ RESOURCES . getLocalName (  )  )  ;", "}", "attribute . marshallAsAttribute ( config ,    false ,    writer )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["writeStaticResourceAttribute"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "boolean   startWritten    =    false ;", "for    ( SimpleAttributeDefinition   def    :    taticResources . STATIC _ ATTRIBUTES )     {", "startWritten    =     ( writeStaticResourceAttribute ( writer ,    def ,    config ,    startWritten )  )     |  |    startWritten ;", "}", "if    ( startWritten )     {", "writer . writeEndElement (  )  ;", "}", "return   startWritten ;", "}", "METHOD_END"], "methodName": ["writeStaticResources"], "fileName": "org.jboss.as.web.WebSubsystemParser"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   subsystemRoot    =    Factory . createSubsystemInstance (  )  ;", "subsystemRoot . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebDefinition . DEFAULT _ SESSION _ TIMEOUT )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( false ,    true ,    new   ModelNode (  3  0  )  )  ,    WebDefinition . DEFAULT _ SESSION _ TIMEOUT )  . end (  )  ;", "final   ResourceTransformationDescriptionBuilder   hostBuilder    =    subsystemRoot . addChildResource ( WebExtension . HOST _ PATH )  ;", "final   ResourceTransformationDescriptionBuilder   ssoBuilder    =    hostBuilder . addChildResource ( WebExtension . SSO _ PATH )  ;", "ssoBuilder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebSSODefinition . HTTP _ ONLY )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( false ,    true ,    new   ModelNode ( true )  )  ,    WebSSODefinition . HTTP _ ONLY )  . end (  )  ;", "final   ResourceTransformationDescriptionBuilder   connectorBuilder    =    subsystemRoot . addChildResource ( WebExtension . CONNECTOR _ PATH )  ;", "connectorBuilder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebConnectorDefinition . PROXY _ BINDING ,    WebConnectorDefinition . REDIRECT _ BINDING )  . setDiscard ( UNDEFINED ,    WebSSLDefinition . SSL _ PROTOCOL ,    WebConnectorDefinition . PROXY _ BINDING ,    WebConnectorDefinition . REDIRECT _ BINDING )  . end (  )  ;", "connectorBuilder . addChildResource ( WebExtension . SSL _ PATH )  . getAttributeBuilder (  )  . addRejectCheck ( RejectAttributeChecker . UNDEFINED ,    WebSSLDefinition . CIPHER _ SUITE )  . end (  )  ;", "Tools . register ( subsystemRoot . build (  )  ,    registration ,    ModelVersion . create (  1  ,     3  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_1_3_0"], "fileName": "org.jboss.as.web.WebTransformers"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   subsystemRoot    =    Factory . createSubsystemInstance (  )  ;", "subsystemRoot . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebDefinition . DEFAULT _ SESSION _ TIMEOUT )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( false ,    true ,    new   ModelNode (  3  0  )  )  ,    WebDefinition . DEFAULT _ SESSION _ TIMEOUT )  . end (  )  ;", "final   ResourceTransformationDescriptionBuilder   hostBuilder    =    subsystemRoot . addChildResource ( WebExtension . HOST _ PATH )  ;", "final   ResourceTransformationDescriptionBuilder   ssoBuilder    =    hostBuilder . addChildResource ( WebExtension . SSO _ PATH )  ;", "ssoBuilder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebSSODefinition . HTTP _ ONLY )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( false ,    true ,    new   ModelNode ( true )  )  ,    WebSSODefinition . HTTP _ ONLY )  . end (  )  ;", "Tools . register ( subsystemRoot . build (  )  ,    registration ,    ModelVersion . create (  1  ,     4  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_1_4_0"], "fileName": "org.jboss.as.web.WebTransformers"}, {"methodBody": ["METHOD_START", "{", "final   ResourceTransformationDescriptionBuilder   subsystemRoot    =    Factory . createSubsystemInstance (  )  ;", "subsystemRoot . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebDefinition . DEFAULT _ SESSION _ TIMEOUT )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( false ,    true ,    new   ModelNode (  3  0  )  )  ,    WebDefinition . DEFAULT _ SESSION _ TIMEOUT )  . end (  )  ;", "final   ResourceTransformationDescriptionBuilder   hostBuilder    =    subsystemRoot . addChildResource ( WebExtension . HOST _ PATH )  ;", "final   ResourceTransformationDescriptionBuilder   ssoBuilder    =    hostBuilder . addChildResource ( WebExtension . SSO _ PATH )  ;", "ssoBuilder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebSSODefinition . HTTP _ ONLY )  . setDiscard ( new   controller . transform . description . DiscardAttributeChecker . DiscardAttributeValueChecker ( false ,    true ,    new   ModelNode ( true )  )  ,    WebSSODefinition . HTTP _ ONLY )  . end (  )  ;", "if    ( minor    =  =     0  )     {", "final   ResourceTransformationDescriptionBuilder   connectorBuilder    =    subsystemRoot . addChildResource ( WebExtension . CONNECTOR _ PATH )  ;", "connectorBuilder . getAttributeBuilder (  )  . addRejectCheck ( DEFINED ,    WebConnectorDefinition . PROXY _ BINDING ,    WebConnectorDefinition . REDIRECT _ BINDING )  . setDiscard ( UNDEFINED ,    WebSSLDefinition . SSL _ PROTOCOL ,    WebConnectorDefinition . PROXY _ BINDING ,    WebConnectorDefinition . REDIRECT _ BINDING )  . end (  )  ;", "connectorBuilder . addChildResource ( WebExtension . SSL _ PATH )  . getAttributeBuilder (  )  . addRejectCheck ( RejectAttributeChecker . UNDEFINED ,    WebSSLDefinition . CIPHER _ SUITE )  . end (  )  ;", "}", "Tools . register ( subsystemRoot . build (  )  ,    registration ,    ModelVersion . create (  2  ,    minor ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransformers_2_x_0"], "fileName": "org.jboss.as.web.WebTransformers"}, {"methodBody": ["METHOD_START", "{", "String   subsystemXml    =    readResource (  \" subsystem - migrate -  2  .  2  .  0  . xml \"  )  ;", ". NewSubsystemAdditionalInitialization   additionalInitialization    =    new    . NewSubsystemAdditionalInitialization (  )  ;", "KernelServices   services    =    createKernelServicesBuilder ( additionalInitialization )  . setSubsystemXml ( subsystemXml )  . build (  )  ;", "ModelNode   model    =    services . readWholeModel (  )  ;", "assertFalse ( additionalInitialization . extensionAdded )  ;", "assertTrue ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . UNDERTOW _ SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "ModelNode   migrateOp    =    new   ModelNode (  )  ;", "migrateOp . get ( ModelDescriptionConstants . OP )  . set (  \" migrate \"  )  ;", "migrateOp . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME )  ;", "checkOutcome ( services . executeOperation ( migrateOp )  )  ;", "model    =    services . readWholeModel (  )  ;", "assertTrue ( additionalInitialization . extensionAdded )  ;", "assertFalse ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "assertTrue ( model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . UNDERTOW _ SUBSYSTEM _ NAME )  . isDefined (  )  )  ;", "ModelNode   ioSubsystem    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     \" io \"  )  ;", "assertTrue ( ioSubsystem . isDefined (  )  )  ;", "assertTrue ( ioSubsystem . get (  \" worker \"  ,     \" default \"  )  . isDefined (  )  )  ;", "assertTrue ( ioSubsystem . get (  \" buffer - pool \"  ,     \" default \"  )  . isDefined (  )  )  ;", "ModelNode   newSubsystem    =    model . get ( ModelDescriptionConstants . SUBSYSTEM ,     . UNDERTOW _ SUBSYSTEM _ NAME )  ;", "ModelNode   newServer    =    newSubsystem . get (  \" server \"  ,     \" default - server \"  )  ;", "assertNotNull ( newServer )  ;", "assertTrue ( newServer . isDefined (  )  )  ;", "assertEquals (  \" default - host \"  ,    newServer . get ( DEFAULT _ HOST )  . asString (  )  )  ;", "ModelNode   servletContainer    =    newSubsystem . get ( SERVLET _ CONTAINER ,     \" default \"  )  ;", "assertNotNull ( servletContainer )  ;", "assertTrue ( servletContainer . isDefined (  )  )  ;", "assertEquals (  \"  $  { prop . default - session - timeout :  3  0  }  \"  ,    servletContainer . get ( DEFAULT _ SESSION _ TIMEOUT )  . asString (  )  )  ;", "assertEquals (  \"  $  { prop . listings : true }  \"  ,    servletContainer . get ( DIRECTORY _ LISTING )  . asString (  )  )  ;", "ModelNode   jsp    =    servletContainer . get ( SETTING ,    JSP )  ;", "assertNotNull ( jsp )  ;", "assertEquals (  \"  $  { prop . recompile - on - fail : true }  \"  ,    jsp . get ( RECOMPILE _ ON _ FAIL )  . asString (  )  )  ;", "ModelNode   welcome    =    servletContainer . get ( WELCOME _ FILE ,     \" toto \"  )  ;", "assertTrue ( welcome . isDefined (  )  )  ;", "ModelNode   mimeMapping    =    servletContainer . get ( MIME _ MAPPING ,     \" ogx \"  )  ;", "assertTrue ( mimeMapping . isDefined (  )  )  ;", "assertEquals (  \" application / ogg \"  ,    mimeMapping . get ( VALUE )  . asString (  )  )  ;", "ModelNode   connector    =    newServer . get ( HTTP _ LISTENER ,     \" http \"  )  ;", "assertTrue ( connector . isDefined (  )  )  ;", "assertEquals (  \" http \"  ,    connector . get ( SOCKET _ BINDING )  . asString (  )  )  ;", "assertEquals (  \"  $  { prop . enabled : true }  \"  ,    connector . get ( ENABLED )  . asString (  )  )  ;", "assertEquals (  \"  $  { prop . enable - lookups : false }  \"  ,    connector . get ( RESOLVE _ PEER _ ADDRESS )  . asString (  )  )  ;", "assertEquals (  \"  $  { prop . max - post - size :  2  0  9  7  1  5  3  }  \"  ,    connector . get ( MAX _ POST _ SIZE )  . asString (  )  )  ;", "assertEquals (  \" https \"  ,    connector . get ( REDIRECT _ SOCKET )  . asString (  )  )  ;", "ModelNode   httpsConnector    =    newServer . get ( HTTPS _ LISTENER ,     \" https \"  )  ;", "String   realmName    =    httpsConnector . get ( SECURITY _ REALM )  . asString (  )  ;", "assertTrue ( realmName ,    realmName . startsWith (  \" jbossweb - migration - security - realm \"  )  )  ;", "assertEquals (  \"  $  { prop . session - cache - size :  5  1  2  }  \"  ,    httpsConnector . get ( SSL _ SESSION _ CACHE _ SIZE )  . asString (  )  )  ;", "assertEquals (  \" REQUESTED \"  ,    httpsConnector . get ( VERIFY _ CLIENT )  . asString (  )  )  ;", "ModelNode   realm    =    model . get ( ModelDescriptionConstants . CORE _ SERVICE ,    ModelDescriptionConstants . MANAGEMENT )  . get ( ModelDescriptionConstants . SECURITY _ REALM ,    realmName )  ;", "ModelNode   trustStore    =    realm . get ( ModelDescriptionConstants . AUTHENTICATION ,    ModelDescriptionConstants . TRUSTSTORE )  ;", "assertEquals (  \"  $  { file - base }  / jsse . keystore \"  ,    trustStore . get ( KEYSTORE _ PATH . getName (  )  )  . asString (  )  )  ;", "ModelNode   filters    =    newSubsystem . get ( CONFIGURATION ,    FILTER )  ;", "ModelNode   dumpFilter    =    filters . get (  \" expression - filter \"  ,     \" request - dumper \"  )  ;", "assertEquals (  \" dump - request \"  ,    dumpFilter . get (  \" expression \"  )  . asString (  )  )  ;", "validateExpressionFilter ( dumpFilter )  ;", "ModelNode   remoteAddrFilter    =    filters . get (  \" expression - filter \"  ,     \" remote - addr \"  )  ;", "assertEquals (  \" access - control ( acl =  {  '  1  9  2  .  1  6  8  .  1  .  2  0    deny '  ,     '  1  2  7  .  0  .  0  .  1    allow '  ,     '  1  2  7  .  0  .  0  .  2    allow '  }     ,    attribute =  % a )  \"  ,    remoteAddrFilter . get (  \" expression \"  )  . asString (  )  )  ;", "validateExpressionFilter ( remoteAddrFilter )  ;", "ModelNode   stuckFilter    =    filters . get (  \" expression - filter \"  ,     \" stuck \"  )  ;", "assertEquals (  \" stuck - thread - detector ( threshhold =  '  1  0  0  0  '  )  \"  ,    stuckFilter . get (  \" expression \"  )  . asString (  )  )  ;", "validateExpressionFilter ( stuckFilter )  ;", "ModelNode   proxyFilter    =    filters . get (  \" expression - filter \"  ,     \" proxy \"  )  ;", "assertEquals (  \" regex ( pattern =  \\  \" proxy 1  | proxy 2  \\  \"  ,    value =  %  { i , x - forwarded - for }  ,    full - match = true )    and   regex ( pattern =  \\  \"  1  9  2  \\  \\  .  1  6  8  \\  \\  .  0  \\  \\  .  1  0  |  1  9  2  \\  \\  .  1  6  8  \\  \\  .  0  \\  \\  .  1  1  \\  \"  ,    value =  %  { i , x - forwarded - for }  ,    full - match = true )     -  >    proxy - peer - address \"  ,    proxyFilter . get (  \" expression \"  )  . asString (  )  )  ;", "validateExpressionFilter ( proxyFilter )  ;", "ModelNode   crawler    =    servletContainer . get ( SETTING ,    CRAWLER _ SESSION _ MANAGEMENT )  ;", "assertTrue ( crawler . isDefined (  )  )  ;", "assertEquals (  1  ,    crawler . get ( SESSION _ TIMEOUT )  . asInt (  )  )  ;", "assertEquals (  \" Google \"  ,    crawler . get ( USER _ AGENTS )  . asString (  )  )  ;", "ModelNode   virtualHost    =    newServer . get ( HOST ,     \" default - host \"  )  ;", "assertEquals (  \" welcome - content \"  ,    virtualHost . get (  \" location \"  ,     \"  /  \"  )  . get ( HANDLER )  . asString (  )  )  ;", "assertEquals (  \" localhost \"  ,    virtualHost . get (  \" alias \"  )  . asList (  )  . get (  0  )  . asString (  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" request - dumper \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" remote - addr \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" proxy \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" stuck \"  )  )  ;", "assertFalse ( virtualHost . hasDefined ( FILTER _ REF ,     \" myvalve \"  )  )  ;", "ModelNode   accessLog    =    virtualHost . get ( SETTING ,    ACCESS _ LOG )  ;", "assertEquals (  \" prefix \"  ,    accessLog . get ( PREFIX )  . asString (  )  )  ;", "assertEquals (  \" true \"  ,    accessLog . get ( ROTATE )  . asString (  )  )  ;", "assertEquals (  \" extended \"  ,    accessLog . get ( PATTERN )  . asString (  )  )  ;", "assertEquals (  \" toto \"  ,    accessLog . get ( DIRECTORY )  . asString (  )  )  ;", "assertEquals (  \" jboss . server . base . dir \"  ,    accessLog . get ( RELATIVE _ TO )  . asString (  )  )  ;", "ModelNode   sso    =    virtualHost . get ( SETTING ,    SINGLE _ SIGN _ ON )  ;", "assertEquals (  \"  $  { prop . domain : myDomain }  \"  ,    sso . get ( DOMAIN )  . asString (  )  )  ;", "assertEquals (  \"  $  { prop . http - only : true }  \"  ,    sso . get ( HTTP _ ONLY )  . asString (  )  )  ;", "virtualHost    =    newServer . get ( HOST ,     \" vs 1  \"  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" request - dumper \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" remote - addr \"  )  )  ;", "assertFalse ( virtualHost . hasDefined ( FILTER _ REF ,     \" myvalve \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" proxy \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" stuck \"  )  )  ;", "accessLog    =    virtualHost . get ( SETTING ,    ACCESS _ LOG )  ;", "assertEquals (  \" myapp _ access _ log .  \"  ,    accessLog . get ( PREFIX )  . asString (  )  )  ;", "assertEquals (  \"  . log \"  ,    accessLog . get ( SUFFIX )  . asString (  )  )  ;", "assertEquals (  \" true \"  ,    accessLog . get ( ROTATE )  . asString (  )  )  ;", "assertEquals (  \" common \"  ,    accessLog . get ( PATTERN )  . asString (  )  )  ;", "assertEquals (  \"  $  { jboss . server . log . dir }  \"  ,    accessLog . get ( DIRECTORY )  . asString (  )  )  ;", "assertEquals (  \" exists (  %  { r , log - enabled }  )  \"  ,    accessLog . get ( PREDICATE )  . asString (  )  )  ;", "virtualHost    =    newServer . get ( HOST ,     \" vs 1  \"  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" request - dumper \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" remote - addr \"  )  )  ;", "assertFalse ( virtualHost . hasDefined ( FILTER _ REF ,     \" myvalve \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" proxy \"  )  )  ;", "assertTrue ( virtualHost . hasDefined ( FILTER _ REF ,     \" stuck \"  )  )  ;", "assertEquals (  \" myapp _ access _ log .  \"  ,    accessLog . get ( PREFIX )  . asString (  )  )  ;", "assertEquals (  \"  . log \"  ,    accessLog . get ( SUFFIX )  . asString (  )  )  ;", "assertEquals (  \" true \"  ,    accessLog . get ( ROTATE )  . asString (  )  )  ;", "assertEquals (  \" common \"  ,    accessLog . get ( PATTERN )  . asString (  )  )  ;", "assertEquals (  \"  $  { jboss . server . log . dir }  \"  ,    accessLog . get ( DIRECTORY )  . asString (  )  )  ;", "assertEquals (  \" exists (  %  { r , log - enabled }  )  \"  ,    accessLog . get ( PREDICATE )  . asString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMigrateOperation"], "fileName": "org.jboss.as.web.test.WebMigrateTestCase"}, {"methodBody": ["METHOD_START", "{", "PredicatedHandlersParser . parse ( filter . get (  \" expression \"  )  . asString (  )  ,    PredicateParser . class . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateExpressionFilter"], "fileName": "org.jboss.as.web.test.WebMigrateTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   success    =    new   ModelNode (  )  ;", "success . get ( OUTCOME )  . set ( SUCCESS )  ;", "success . get ( RESULT )  ;", "success . protect (  )  ;", "PathAddress   addr    =    PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM ,    getMainName (  )  )  ,    PathElement . pathElement (  \" connector \"  ,     \" https \"  )  ,    PathElement . pathElement (  \" configuration \"  ,     \" ssl \"  )  )  ;", "ModelNode   op    =    Util . createOperation ( ModelDescriptionConstants . WRITE _ ATTRIBUTE _ OPERATION ,    addr )  ;", "op . get ( ModelDescriptionConstants . NAME )  . set (  \" cipher - suite \"  )  ;", "op . get ( ModelDescriptionConstants . VALUE )  . set ( new   ModelNode (  )  )  ;", "TransformedOperation   transOp    =    services . transformOperation ( version ,    op )  ;", "Assert . assertTrue ( transOp . rejectOperation ( success )  )  ;", "op . get ( ModelDescriptionConstants . VALUE )  . set (  \" SSL _ RSA _ WITH _  3 DES _ EDE _ CBC _ SHA \"  )  ;", "transOp    =    services . transformOperation ( version ,    op )  ;", "Assert . assertFalse ( transOp . rejectOperation ( success )  )  ;", "}", "METHOD_END"], "methodName": ["checkUndefinedCipherSuite"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   operation    =    new   ModelNode (  )  ;", "operation . get ( ModelDescriptionConstants . OP )  . set ( operationName )  ;", "if    (  ( addrelength )     >     0  )     {", "if    (  (  ( addrelength )     %     2  )     !  =     0  )     {", "throw   new   IllegalArgumentException (  \" Addremust   be   in   pairs \"  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( addrelength )  ;    i    +  =     2  )     {", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . add ( addrei ]  ,    addre ( i    +     1  )  ]  )  ;", "}", "} else    {", "operation . get ( ModelDescriptionConstants . OP _ ADDR )  . setEmptyList (  )  ;", "}", "return   operation ;", "}", "METHOD_END"], "methodName": ["createOperation"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "return   addr ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   op    =    createOperation ( ModelDescriptionConstants . READ _ ATTRIBUTE _ OPERATION ,    address )  ;", "op . get ( ModelDescriptionConstants . NAME )  . set ( name )  ;", "ModelNode   result    =    services . executeForResult ( op )  ;", "if    ( result . isDefined (  )  )     {", "return   resultString (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readAttribute"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String [  ]    targetAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . CONFIGURATION ,    Constants . ACCESS _ LOG )  ;", "String [  ]    aliasAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . ACCESS _ LOG ,    Constants . CONFIGURATION )  ;", "Aliases ( services ,    noAliasModel ,    aliasModel ,    targetAddr ,    aliasAddr )  ;", "String [  ]    targetChildMainAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . CONFIGURATION ,    Constants . ACCESS _ LOG ,    Constants . SETTING ,    Constants . DIRECTORY )  ;", "String [  ]    targetChildAliasAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . CONFIGURATION ,    Constants . ACCESS _ LOG ,    Constants . DIRECTORY ,    Constants . CONFIGURATION )  ;", "Assert . assertTrue ( noAliasModel . get ( targetChildMainAddr )  . isDefined (  )  )  ;", "Assert . assertFalse ( noAliasModel . get ( targetChildAliasAddr )  . isDefined (  )  )  ;", "String [  ]    aliasChildMainAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . ACCESS _ LOG ,    Constants . CONFIGURATION ,    Constants . SETTING ,    Constants . DIRECTORY )  ;", "String [  ]    aliasChildAliasAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . ACCESS _ LOG ,    Constants . CONFIGURATION ,    Constants . DIRECTORY ,    Constants . CONFIGURATION )  ;", "Assert . assertEquals ( aliasModel . get ( targetChildMainAddr )  ,    aliasModel . get ( targetChildAliasAddr )  )  ;", "Assert . assertEquals ( aliasModel . get ( aliasChildMainAddr )  ,    aliasModel . get ( targetChildAliasAddr )  )  ;", "Assert . assertEquals ( aliasModel . get ( aliasChildMainAddr )  ,    aliasModel . get ( aliasChildAliasAddr )  )  ;", "ChangeAttribute ( services ,     \" pattern \"  ,     \" pattern 1  2  3  \"  ,     \"  1  2  3 pattern \"  ,    targetAddr ,    aliasAddr )  ;", "ChangeAttribute ( services ,     \" path \"  ,     \" path 1  2  3  \"  ,     \"  1  2  3 path \"  ,    targetChildMainAddr ,    targetChildAliasAddr )  ;", "ChangeAttribute ( services ,     \" path \"  ,     \" path 3  4  5  \"  ,     \"  3  4  5 path \"  ,    targetChildMainAddr ,    aliasChildAliasAddr )  ;", "ChangeAttribute ( services ,     \" path \"  ,     \" path 6  7  8  \"  ,     \"  6  7  8 path \"  ,    targetChildMainAddr ,    aliasChildMainAddr )  ;", "}", "METHOD_END"], "methodName": ["testAccessLogAlias"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "KernelServices   services    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \" subsystem . xml \"  )  . build (  )  ;", "ModelNode   noAliasModel    =    services . readWholeModel (  )  ;", "ModelNode   aliasModel    =    services . readWholeModel ( true )  ;", "testSSLAlias ( services ,    noAliasModel ,    aliasModel )  ;", "testSSOAlias ( services ,    noAliasModel ,    aliasModel )  ;", "testAccessLogAlias ( services ,    noAliasModel ,    aliasModel )  ;", "}", "METHOD_END"], "methodName": ["testAliases"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( noAliasModel . get ( targetAddr )  . isDefined (  )  )  ;", "Assert . assertFalse ( noAliasModel . get ( aliasAddr )  . isDefined (  )  )  ;", "Assert . assertEquals ( aliasModel . get ( targetAddr )  ,    aliasModel . get ( aliasAddr )  )  ;", "}", "METHOD_END"], "methodName": ["testAliases"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "writeAttribute ( services ,    attributeName ,    value 1  ,    alAddr )  ;", "AssertsertEquals ( value 1  ,    readAttribute ( services ,    attributeName ,    alAddr )  )  ;", "AssertsertEquals ( value 1  ,    readAttribute ( services ,    attributeName ,    targetAddr )  )  ;", "writeAttribute ( services ,    attributeName ,    value 2  ,    targetAddr )  ;", "AssertsertEquals ( value 2  ,    readAttribute ( services ,    attributeName ,    alAddr )  )  ;", "AssertsertEquals ( value 2  ,    readAttribute ( services ,    attributeName ,    targetAddr )  )  ;", "}", "METHOD_END"], "methodName": ["testChangeAttribute"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformers _  1  _  3  _  0  ( EAP _  6  _  2  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformersAS620"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testRejectingTransformers _  1  _  4  _  0  ( EAP _  6  _  3  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformersAS630"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     3  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - web :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . setExtensionClassName (  \" WebExtension \"  )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue (  \" main   services   did   not   boot \"  ,    mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "final   PathAddress   subsystem    =    EMPTY _ ADDRESS . append (  \" subsystem \"  ,     \" web \"  )  ;", "List < ModelNode >    xmlOps    =    builder . parseXmlResource (  \" subsystem -  2  .  2  .  0  . xml \"  )  ;", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystem ,    new    . IntExpressionConfig (  \" default - session - timeout \"  )  )  . addFailedAttribute ( subsystem . append ( PathElement . pathElement (  \" connector \"  ,     \" http \"  )  )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig (  \" redirect - binding \"  ,     \" proxy - binding \"  )  )  . addFailedAttribute ( subsystem . append (  \" virtual - server \"  ,     \" default - host \"  )  . append (  \" configuration \"  ,     \" sso \"  )  ,    new    . BooleanExpressionConfig (  \" http - only \"  )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    xmlOps ,    config )  ;", "checkUndefinedCipherSuite ( mainServices ,    modelVersion )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformers_1_3_0"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     4  ,     0  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - web :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . setExtensionClassName (  \" WebExtension \"  )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue (  \" main   services   did   not   boot \"  ,    mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "final   PathAddress   subsystem    =    EMPTY _ ADDRESS . append (  \" subsystem \"  ,     \" web \"  )  ;", "List < ModelNode >    xmlOps    =    builder . parseXmlResource (  \" subsystem -  2  .  2  .  0  . xml \"  )  ;", "FailedOperationTransformationConfig   config    =    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( subsystem ,    new    . IntExpressionConfig (  \" default - session - timeout \"  )  )  . addFailedAttribute ( subsystem . append (  \" virtual - server \"  ,     \" default - host \"  )  . append (  \" configuration \"  ,     \" sso \"  )  ,    new    . BooleanExpressionConfig (  \" http - only \"  )  )  ;", "ModelTestUtils . checkFailedTransformedBootOperations ( mainServices ,    modelVersion ,    xmlOps ,    config )  ;", "}", "METHOD_END"], "methodName": ["testRejectingTransformers_1_4_0"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String [  ]    targetAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . CONNECTOR ,     \" https \"  ,    Constants . CONFIGURATION ,    Constants . SSL )  ;", "String [  ]    aliasAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . CONNECTOR ,     \" https \"  ,    Constants . SSL ,    Constants . CONFIGURATION )  ;", "Aliases ( services ,    noAliasModel ,    aliasModel ,    targetAddr ,    aliasAddr )  ;", "ChangeAttribute ( services ,     \" ca - certificate - password \"  ,     \" pwd 1  2  3  \"  ,     \"  1  2  3 pwd \"  ,    targetAddr ,    aliasAddr )  ;", "}", "METHOD_END"], "methodName": ["testSSLAlias"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "String [  ]    targetAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . CONFIGURATION ,    Constants . SSO )  ;", "String [  ]    aliasAddr    =    getAddress ( ModelDescriptionConstants . SUBSYSTEM ,    WebExtension . SUBSYSTEM _ NAME ,    Constants . VIRTUAL _ SERVER ,     \" default - host \"  ,    Constants . SSO ,    Constants . CONFIGURATION )  ;", "Aliases ( services ,    noAliasModel ,    aliasModel ,    targetAddr ,    aliasAddr )  ;", "ChangeAttribute ( services ,     \" domain \"  ,     \" domain 1  2  3  \"  ,     \"  1  2  3 domain \"  ,    targetAddr ,    aliasAddr )  ;", "}", "METHOD_END"], "methodName": ["testSSOAlias"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation _  1  _  3  _  0  ( EAP _  6  _  2  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformationEAP620"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "testTransformation _  1  _  4  _  0  ( EAP _  6  _  3  _  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransformationEAP630"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     3  ,     0  )  ;", "String   subsystemXml    =    readResource (  \" subsystem -  1  .  3  .  0  . xml \"  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXml ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - web :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . setExtensionClassName (  \" WebExtension \"  )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion ,    new   CumulativeModelFixer (  . SSLConfigurationNameFixer . INSTANCE ,     . AccessLogPrefixFixer _  1  _  2  _  0  . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformation_1_3_0"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelVersion   modelVersion    =    ModelVersion . create (  1  ,     4  ,     0  )  ;", "String   subsystemXml    =    readResource (  \" subsystem -  1  .  4  .  0  . xml \"  )  ;", "KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXml ( subsystemXml )  ;", "builder . createLegacyKernelServicesBuilder ( null ,    controllerVersion ,    modelVersion )  . addMavenResourceURL (  (  \" as : jboss - as - web :  \"     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . setExtensionClassName (  \" WebExtension \"  )  . configureReverseControllerCheck ( createAdditionalInitialization (  )  ,    null )  ;", "KernelServices   mainServices    =    builder . build (  )  ;", "KernelServices   legacyServices    =    mainServices . getLegacyServices ( modelVersion )  ;", "Assert . assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    modelVersion ,    new   CumulativeModelFixer (  . SSLConfigurationNameFixer . INSTANCE ,     . AccessLogPrefixFixer _  1  _  2  _  0  . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["testTransformation_1_4_0"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}, {"methodBody": ["METHOD_START", "{", "ModelNode   op    =    createOperation ( ModelDescriptionConstants . WRITE _ ATTRIBUTE _ OPERATION ,    address )  ;", "op . get ( ModelDescriptionConstants . NAME )  . set ( name )  ;", "op . get ( ModelDescriptionConstants . VALUE )  . set ( value )  ;", "services . executeForResult ( op )  ;", "}", "METHOD_END"], "methodName": ["writeAttribute"], "fileName": "org.jboss.as.web.test.WebSubsystemTestCase"}]