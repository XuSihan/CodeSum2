[{"methodBody": ["METHOD_START", "{", "return   boot ( getSubsystemXml (  )  )  ;", "}", "METHOD_END"], "methodName": ["boot"], "fileName": "org.wildfly.extension.batch.jberet.AbstractBatchTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   result ;", "if    ( subsystemXml    =  =    null )     {", "result    =    createKernelServicesBuer ( createAdditionalInitialization (  )  )  . bu (  )  ;", "} else    {", "result    =    createKernelServicesBuer ( createAdditionalInitialization (  )  )  . setSubsystemXml ( subsystemXml )  . bu (  )  ;", "}", "Assert . assertTrue ( result . isSuccessfulBoot (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["boot"], "fileName": "org.wildfly.extension.batch.jberet.AbstractBatchTestCase"}, {"methodBody": ["METHOD_START", "{", "return   AbstractBatchTestCase . createAddress ( PathElement . pathElement ( resourceKey ,    resourceValue )  )  ;", "}", "METHOD_END"], "methodName": ["createAddress"], "fileName": "org.wildfly.extension.batch.jberet.AbstractBatchTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( pathElement    =  =    null )     {", "return   PathAddress . pathAddress ( SubsystemDefinition . SUBSYSTEM _ PATH )  . toModelNode (  )  ;", "}", "return   PathAddress . pathAddress ( SubsystemDefinition . SUBSYSTEM _ PATH ,    pathElement )  . toModelNode (  )  ;", "}", "METHOD_END"], "methodName": ["createAddress"], "fileName": "org.wildfly.extension.batch.jberet.AbstractBatchTestCase"}, {"methodBody": ["METHOD_START", "{", "return   AbstractBatchTestCase . executeOperation ( kernelServices ,    op . getOperation (  )  )  ;", "}", "METHOD_END"], "methodName": ["executeOperation"], "fileName": "org.wildfly.extension.batch.jberet.AbstractBatchTestCase"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   result    =    kernelServices . executeOperation ( op )  ;", "Assert . assertTrue ( SubsystemOperations . getFailureDescriptionAsString ( result )  ,    SubsystemOperations . isSuccessfulOutcome ( result )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["executeOperation"], "fileName": "org.wildfly.extension.batch.jberet.AbstractBatchTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Attribute   element    =    Attribute . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Attribute . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.wildfly.extension.batch.jberet.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.wildfly.extension.batch.jberet.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   Attribute . MAP ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "org.wildfly.extension.batch.jberet.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   AttributeParsers . readRequiredAttributes ( reader ,    EnumSet . of ( Attribute . NAME )  )  . get ( Attribute . NAME )  ;", "}", "METHOD_END"], "methodName": ["readNameAttribute"], "fileName": "org.wildfly.extension.batch.jberet.AttributeParsers"}, {"methodBody": ["METHOD_START", "{", "final   int   attributeCount    =    reader . getAttributeCount (  )  ;", "final   Map < Attribute ,    String >    result    =    new   EnumMap <  >  ( Attribute . class )  ;", "for    ( int   i    =     0  ;    i    <    attributeCount ;    i +  +  )     {", "final   Attribute   current    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "if    ( attributes . contains ( current )  )     {", "if    (  ( result . put ( current ,    reader . getAttributeValue ( i )  )  )     !  =    null )     {", "throw   ParseUtils . duplicateAttribute ( reader ,    current . getLocalName (  )  )  ;", "}", "} else    {", "throw   ParseUtils . unexpectedAttribute ( reader ,    i ,    attributes . stream (  )  . map ( Attribute :  : getLocalName )  . collect ( Collectors . toSet (  )  )  )  ;", "}", "}", "if    ( result . isEmpty (  )  )     {", "throw   ParseUtils . missingRequired ( reader ,    attributes . stream (  )  . map ( Attribute :  : getLocalName )  . collect ( Collectors . toSet (  )  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["readRequiredAttributes"], "fileName": "org.wildfly.extension.batch.jberet.AttributeParsers"}, {"methodBody": ["METHOD_START", "{", "return   AttributeParsers . readRequiredAttributes ( reader ,    EnumSet . of ( Attribute . VALUE )  )  . get ( Attribute . VALUE )  ;", "}", "METHOD_END"], "methodName": ["readValueAttribute"], "fileName": "org.wildfly.extension.batch.jberet.AttributeParsers"}, {"methodBody": ["METHOD_START", "{", "return   jobExecutorInjector ;", "}", "METHOD_END"], "methodName": ["getJobExecutorInjector"], "fileName": "org.wildfly.extension.batch.jberet.BatchConfigurationService"}, {"methodBody": ["METHOD_START", "{", "return   jobRepositoryInjector ;", "}", "METHOD_END"], "methodName": ["getJobRepositoryInjector"], "fileName": "org.wildfly.extension.batch.jberet.BatchConfigurationService"}, {"methodBody": ["METHOD_START", "{", "return   securityDomainInjector ;", "}", "METHOD_END"], "methodName": ["getSecurityDomainInjector"], "fileName": "org.wildfly.extension.batch.jberet.BatchConfigurationService"}, {"methodBody": ["METHOD_START", "{", "this . restartOnResume    =    restartOnResume ;", "}", "METHOD_END"], "methodName": ["setRestartOnResume"], "fileName": "org.wildfly.extension.batch.jberet.BatchConfigurationService"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardResourceDescriptionResolver ( BatchResourceDescriptionResolver . BASE ,    BatchResourceDescriptionResolver . RESOURCE _ NAME ,    BatchSubsystemExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.wildfly.extension.batch.jberet.BatchResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =     ( BatchResourceDescriptionResolver . BASE )     +     ( keyPrefix    =  =    null    ?     \"  \"     :     \"  .  \"     +    keyPrefix )  ;", "return   new   StandardResourceDescriptionResolver ( prefix ,    BatchResourceDescriptionResolver . RESOURCE _ NAME ,    BatchSubsystemExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.wildfly.extension.batch.jberet.BatchResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   prefix    =    new   StringBuilder ( BatchResourceDescriptionResolver . BASE )  ;", "for    ( String   p    :    prefixes )     {", "prefix . append (  '  .  '  )  . append ( p )  ;", "}", "return   new   StandardResourceDescriptionResolver ( prefix . toString (  )  ,    BatchResourceDescriptionResolver . RESOURCE _ NAME ,    BatchSubsystemExtension . class . getClassLoader (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescriptionResolver"], "fileName": "org.wildfly.extension.batch.jberet.BatchResourceDescriptionResolver"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append (  \" batch \"  )  . append (  \" artifact \"  )  . append (  \" factory \"  )  ;", "}", "METHOD_END"], "methodName": ["batchArtifactFactoryServiceName"], "fileName": "org.wildfly.extension.batch.jberet.BatchServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append (  \" batch \"  )  . append (  \" environment \"  )  ;", "}", "METHOD_END"], "methodName": ["batchEnvironmentServiceName"], "fileName": "org.wildfly.extension.batch.jberet.BatchServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append (  \" beanmanager \"  )  ;", "}", "METHOD_END"], "methodName": ["beanManagerServiceName"], "fileName": "org.wildfly.extension.batch.jberet.BatchServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   Services . deploymentUnitName ( deploymentRuntimeName )  . append (  \" batch \"  )  . append (  \" job - operator \"  )  ;", "}", "METHOD_END"], "methodName": ["jobOperatorServiceName"], "fileName": "org.wildfly.extension.batch.jberet.BatchServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   Services . deploymentUnitName ( deploymentRuntimeName ,    subdeploymentName )  . append (  \" batch \"  )  . append (  \" job - operator \"  )  ;", "}", "METHOD_END"], "methodName": ["jobOperatorServiceName"], "fileName": "org.wildfly.extension.batch.jberet.BatchServiceNames"}, {"methodBody": ["METHOD_START", "{", "return   deploymentUnit . getServiceName (  )  . append (  \" batch \"  )  . append (  \" job - operator \"  )  ;", "}", "METHOD_END"], "methodName": ["jobOperatorServiceName"], "fileName": "org.wildfly.extension.batch.jberet.BatchServiceNames"}, {"methodBody": ["METHOD_START", "{", "while    (  ( reader . hasNext (  )  )     &  &     (  ( reader . nextTag (  )  )     !  =     ( XMLStreamConstants . END _ ELEMENT )  )  )     {", "final   String   localName    =    reader . getLocalName (  )  ;", "final   Element   element    =    Element . forName ( localName )  ;", "if    ( element    =  =     ( Element . IN _ MEMORY )  )     {", "ops . add ( Util . createAddOperation ( subsystemAddress . append ( InMemoryJobRepositoryDefinition . NAME ,    name )  )  )  ;", "ParseUtils . requireNoContent ( reader )  ;", "} else", "if    ( element    =  =     ( Element . JDBC )  )     {", "final   Map < Attribute ,    String >    attributes    =    AttributeParsers . readRequiredAttributes ( reader ,    of ( Attribute . DATA _ SOURCE )  )  ;", "final   ModelNode   op    =    Util . createAddOperation ( subsystemAddress . append ( job . repository . JdbcJobRepositoryDefinition . NAME ,    name )  )  ;", "job . repository . JdbcJobRepositoryDefinition . DATA _ SOURCE . parseAndSetParameter ( attributes . get ( Attribute . DATA _ SOURCE )  ,    op ,    reader )  ;", "ops . add ( op )  ;", "ParseUtils . requireNoContent ( reader )  ;", "} else    {", "throw   ParseUtils . unexpectedElement ( reader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseJobRepository"], "fileName": "org.wildfly.extension.batch.jberet.BatchSubsystemParser_1_0"}, {"methodBody": ["METHOD_START", "{", "writer . writeAttribute ( Attribute . NAME . getLocalName (  )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["writeNameAttribute"], "fileName": "org.wildfly.extension.batch.jberet.BatchSubsystemWriter"}, {"methodBody": ["METHOD_START", "{", "final   Element   element    =    Element . MAP . get ( localName )  ;", "return   element    =  =    null    ?    Element . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.wildfly.extension.batch.jberet.Element"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.wildfly.extension.batch.jberet.Element"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \"  / jdbc - default - subsystem . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testJdbcSubsystem"], "fileName": "org.wildfly.extension.batch.jberet.JBeretSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Pattern   pattern    =    Pattern . compile (  \"  (  .  *  - subsystem )  _  \\  \\ d +  _  \\  \\ d +  \\  \\  . xml \"  )  ;", "final   String   cp    =    WildFlySecurityManager . getPropertyPrivileged (  \" path \"  ,     \"  .  \"  )  ;", "final   String [  ]    entries    =    cp . split ( Pattern . quote ( File . pathSeparator )  )  ;", "final   List < String >    configs    =    new   ArrayList <  >  (  )  ;", "for    ( String   entry    :    entries )     {", "final   Path   path    =    Paths . get ( entry )  ;", "if    ( Files . isDirectory ( path )  )     {", "Files . walkFileTree ( path ,    new   SimpleFileVisitor < Path >  (  )     {", "@ Override", "public   FileVisitResult   visitFile ( final   Path   file ,    final   BasicFileAttributes   attrs )    throws   IOException    {", "final   String   name    =    file . getFileName (  )  . toString (  )  ;", "if    ( pattern . matcher ( name )  . matches (  )  )     {", "configs . add (  (  \"  /  \"     +    name )  )  ;", "}", "return   FileVisitResult . CONTINUE ;", "}", "}  )  ;", "}", "}", "Assert . assertFalse (  \" No   configs   were   found \"  ,    configs . isEmpty (  )  )  ;", "for    ( String   configId    :    configs )     {", "standardTest ( configId ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["testLegacySubsystems"], "fileName": "org.wildfly.extension.batch.jberet.JBeretSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \"  / minimal - subsystem . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMinimalSubsystem"], "fileName": "org.wildfly.extension.batch.jberet.JBeretSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \"  / multi - thread - factory - subsystem . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultiThreadFactory"], "fileName": "org.wildfly.extension.batch.jberet.JBeretSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "standardSubsystemTest (  \"  / security - domain - subsystem . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testSecurityDomainSubsystem"], "fileName": "org.wildfly.extension.batch.jberet.JBeretSubsystemParsingTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Namespace   element    =    Namespace . MAP . get ( uri )  ;", "return   element    =  =    null    ?    Namespace . UNKNOWN    :    element ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.wildfly.extension.batch.jberet.Namespace"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getUriString"], "fileName": "org.wildfly.extension.batch.jberet.Namespace"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   kernelServices    =    boot ( getSubsystemXml (  \"  / minimal - subsystem . xml \"  )  )  ;", "final   ModelNode   address    =    AbstractBatchTestCase . createAddress (  \" thread - pool \"  ,     \" test - pool \"  )  ;", "final   ModelNode   addOp    =     . createAddOperation ( address )  ;", "addOp . get (  \" max - threads \"  )  . set (  1  0 L )  ;", "final   ModelNode   keepAlive    =    addOp . get (  \" keepalive - time \"  )  ;", "keepAlive . get (  \" time \"  )  . set (  1  0  0 L )  ;", "keepAlive . get (  \" unit \"  )  . set ( TimeUnit . MILLISECONDS . toString (  )  )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    addOp )  ;", "final   ModelNode   removeOp    =     . createRemoveOperation ( address )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    removeOp )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    addOp )  ;", "final   Operation   compositeOp    =    CompositeOperationBuilder . create (  )  . addStep ( removeOp )  . addStep ( addOp )  . build (  )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    compositeOp )  ;", "}", "METHOD_END"], "methodName": ["testAddRemoveThreadPool"], "fileName": "org.wildfly.extension.batch.jberet.SubsystemOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   kernelServices    =    boot ( null )  ;", "final   CompositeOperationBuilder   operationBuilder    =    CompositeOperationBuilder . create (  )  ;", "final   ModelNode   subsystemAddress    =    AbstractBatchTestCase . createAddress ( null )  ;", "final   ModelNode   subsystemAddOp    =     . createAddOperation ( subsystemAddress )  ;", "subsystemAddOp . get (  \" default - job - repository \"  )  . set (  \" in - memory \"  )  ;", "subsystemAddOp . get (  \" default - thread - pool \"  )  . set (  \" batch \"  )  ;", "operationBuilder . addStep ( subsystemAddOp )  ;", "operationBuilder . addStep (  . createAddOperation ( AbstractBatchTestCase . createAddress ( InMemoryJobRepositoryDefinition . NAME ,     \" in - memory \"  )  )  )  ;", "final   ModelNode   threadPool    =     . createAddOperation ( AbstractBatchTestCase . createAddress (  \" thread - pool \"  ,     \" batch \"  )  )  ;", "threadPool . get (  \" max - threads \"  )  . set (  1  0  )  ;", "final   ModelNode   keepAlive    =    threadPool . get (  \" keepalive - time \"  )  ;", "keepAlive . get (  \" time \"  )  . set (  1  0  0 L )  ;", "keepAlive . get (  \" unit \"  )  . set ( TimeUnit . MILLISECONDS . toString (  )  )  ;", "operationBuilder . addStep ( threadPool )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    operationBuilder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddSubsystem"], "fileName": "org.wildfly.extension.batch.jberet.SubsystemOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   kernelServices    =    boot (  )  ;", "final   CompositeOperationBuilder   compositeOp    =    CompositeOperationBuilder . create (  )  ;", "final   ModelNode   address    =    AbstractBatchTestCase . createAddress ( InMemoryJobRepositoryDefinition . NAME ,     \" new - job - repo \"  )  ;", "compositeOp . addStep (  . createAddOperation ( address )  )  ;", "compositeOp . addStep (  . createWriteAttributeOperation ( AbstractBatchTestCase . createAddress ( null )  ,     \" default - thread - pool \"  ,     \" new - job - repo \"  )  )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    compositeOp . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJobRepositoryChange"], "fileName": "org.wildfly.extension.batch.jberet.SubsystemOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   kernelServices    =    boot (  )  ;", "final   ModelNode   removeSubsystemOp    =     . createRemoveOperation ( AbstractBatchTestCase . createAddress ( null )  )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    removeSubsystemOp )  ;", "}", "METHOD_END"], "methodName": ["testRemoveSubsystem"], "fileName": "org.wildfly.extension.batch.jberet.SubsystemOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServices   kernelServices    =    boot (  )  ;", "final   CompositeOperationBuilder   compositeOp    =    CompositeOperationBuilder . create (  )  ;", "final   ModelNode   address    =    AbstractBatchTestCase . createAddress (  \" thread - pool \"  ,     \" test - pool \"  )  ;", "final   ModelNode   addOp    =     . createAddOperation ( address )  ;", "addOp . get (  \" max - threads \"  )  . set (  1  0 L )  ;", "final   ModelNode   keepAlive    =    addOp . get (  \" keepalive - time \"  )  ;", "keepAlive . get (  \" time \"  )  . set (  1  0  0 L )  ;", "keepAlive . get (  \" unit \"  )  . set ( TimeUnit . MILLISECONDS . toString (  )  )  ;", "compositeOp . addStep ( addOp )  ;", "compositeOp . addStep (  . createWriteAttributeOperation ( AbstractBatchTestCase . createAddress ( null )  ,     \" default - thread - pool \"  ,     \" test - pool \"  )  )  ;", "AbstractBatchTestCase . executeOperation ( kernelServices ,    compositeOp . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThreadPoolChange"], "fileName": "org.wildfly.extension.batch.jberet.SubsystemOperationsTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServicesBuilder   builder    =    createKernelServicesBuilder ( MANAGEMENT )  ;", "final   ModelVersion   legacyVersion    =    ModelVersion . create (  1  ,     1  ,     0  )  ;", "final   ModelTestControllerVersion   controllerVersion    =    ModelTestControllerVersion . EAP _  7  _  0  _  0  ;", "builder . createLegacyKernelServicesBuilder ( MANAGEMENT ,    controllerVersion ,    legacyVersion )  . addMavenResourceURL (  (  (  ( controllerVersion . getMavenGroupId (  )  )     +     \"  : wildfly - batch - jberet :  \"  )     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  (  ( controllerVersion . getCoreMavenGroupId (  )  )     +     \"  : wildfly - threads :  \"  )     +     ( controllerVersion . getCoreVersion (  )  )  )  )  ;", "final   KernelServices   mainServices    =    builder . build (  )  ;", "final   KernelServices   legacyServices    =    mainServices . getLegacyServices ( legacyVersion )  ;", "Assert . assertNotNull ( legacyServices )  ;", "Assert . assertTrue (  \" main   services   did   not   boot \"  ,    mainServices . isSuccessfulBoot (  )  )  ;", "Assert . assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "final   List < ModelNode >    ops    =    builder . parseXmlResource (  \"  / default - subsystem . xml \"  )  ;", "ModelTestUtils . checkFaileddBootOperations ( mainServices ,    legacyVersion ,    ops ,    new   FailedOperationTransformationConfig (  )  . addFailedAttribute ( PathAddress . pathAddress ( BatchSubsystemDefinition . SUBSYSTEM _ PATH )  ,    new   FailedOperationTransformationConfig . NewAttributesConfig ( BatchSubsystemDefinition . SECURITY _ DOMAIN )  )  )  ;", "}", "METHOD_END"], "methodName": ["testFailedTransformersEAP700"], "fileName": "org.wildfly.extension.batch.jberet.SubsystemTransformerTestCase"}, {"methodBody": ["METHOD_START", "{", "final   KernelServicesBuilder   builder    =    createKernelServicesBuilder ( createAdditionalInitialization (  )  )  . setSubsystemXmlResource (  \"  / default - subsystem _  1  _  0  . xml \"  )  ;", "final   ModelVersion   legacyVersion    =    ModelVersion . create (  1  ,     1  ,     0  )  ;", "final   ModelTestControllerVersion   controllerVersion    =    ModelTestControllerVersion . EAP _  7  _  0  _  0  ;", "builder . createLegacyKernelServicesBuilder ( createAdditionalInitialization (  )  ,    controllerVersion ,    legacyVersion )  . addMavenResourceURL (  (  (  ( controllerVersion . getMavenGroupId (  )  )     +     \"  : wildfly - batch - jberet :  \"  )     +     ( controllerVersion . getMavenGavVersion (  )  )  )  )  . addMavenResourceURL (  (  (  ( controllerVersion . getCoreMavenGroupId (  )  )     +     \"  : wildfly - threads :  \"  )     +     ( controllerVersion . getCoreVersion (  )  )  )  )  ;", "final   KernelServices   mainServices    =    builder . build (  )  ;", "assertTrue ( mainServices . isSuccessfulBoot (  )  )  ;", "final   KernelServices   legacyServices    =    mainServices . getLegacyServices ( legacyVersion )  ;", "assertNotNull ( legacyServices )  ;", "assertTrue ( legacyServices . isSuccessfulBoot (  )  )  ;", "checkSubsystemModelTransformation ( mainServices ,    legacyVersion ,    null ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransformersEAP700"], "fileName": "org.wildfly.extension.batch.jberet.SubsystemTransformerTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( beanManager    =  =    null )     {", "return   null ;", "}", "BLogger . LOGGER . tracef (  \" Looking   up   bean   reference   for    '  % s '  \"  ,    ref )  ;", "final   Set < Bean <  ?  >  >    beans    =    beanManager . getBeans ( ref )  ;", "final   Bean <  ?  >    bean    =    beanManager . resolve ( beans )  ;", "if    ( bean    !  =    null )     {", "BLogger . LOGGER . tracef (  \" Found   bean    '  % s '    for   reference    '  % s '  \"  ,    bean ,    ref )  ;", "} else    {", "BLogger . LOGGER . tracef (  \" No   bean   found   for   reference    '  % s ;  '  \"  ,    ref )  ;", "}", "return   bean ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.wildfly.extension.batch.jberet.deployment.ArtifactFactoryService"}, {"methodBody": ["METHOD_START", "{", "final   BeanManager   beanManager    =    this . beanManager ;", "urn   beanManager    =  =    null    ?    null    :    BeanManagerProxy . unwrap ( beanManager )  ;", "}", "METHOD_END"], "methodName": ["getBeanManager"], "fileName": "org.wildfly.extension.batch.jberet.deployment.ArtifactFactoryService"}, {"methodBody": ["METHOD_START", "{", "return   beanManagerInjector ;", "}", "METHOD_END"], "methodName": ["getBeanManagerInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.ArtifactFactoryService"}, {"methodBody": ["METHOD_START", "{", "final   int   attributeCount    =    reader . getAttributeCount (  )  ;", "for    ( int   i    =     0  ;    i    <    attributeCount ;    i +  +  )     {", "final   Attribute   current    =    Attribute . forName ( reader . getAttributeLocalName ( i )  )  ;", "if    ( current    =  =    attribute )     {", "return   reader . getAttributeValue ( i )  ;", "}", "}", "throw   Utils . missingRequired ( reader ,    attribute . getLocalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["readRequiredAttribute"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchDeploymentDescriptorParser_1_0"}, {"methodBody": ["METHOD_START", "{", "return   executorName ;", "}", "METHOD_END"], "methodName": ["getExecutorName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentMetaData"}, {"methodBody": ["METHOD_START", "{", "return   jobRepository ;", "}", "METHOD_END"], "methodName": ["getJobRepository"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentMetaData"}, {"methodBody": ["METHOD_START", "{", "return   jobRepositoryName ;", "}", "METHOD_END"], "methodName": ["getJobRepositoryName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentMetaData"}, {"methodBody": ["METHOD_START", "{", "return   restartJobsOnResume ;", "}", "METHOD_END"], "methodName": ["getRestartJobsOnResume"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentMetaData"}, {"methodBody": ["METHOD_START", "{", "return   artifactFactoryInjector ;", "}", "METHOD_END"], "methodName": ["getArtifactFactoryInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentService"}, {"methodBody": ["METHOD_START", "{", "return   batchConfigurationInjector ;", "}", "METHOD_END"], "methodName": ["getBatchConfigurationInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentService"}, {"methodBody": ["METHOD_START", "{", "return   jobExecutorInjector ;", "}", "METHOD_END"], "methodName": ["getJobExecutorInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentService"}, {"methodBody": ["METHOD_START", "{", "return   jobRepositoryInjector ;", "}", "METHOD_END"], "methodName": ["getJobRepositoryInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentService"}, {"methodBody": ["METHOD_START", "{", "return   requestControllerInjector ;", "}", "METHOD_END"], "methodName": ["getRequestControllerInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentService"}, {"methodBody": ["METHOD_START", "{", "return   transactionManagerInjector ;", "}", "METHOD_END"], "methodName": ["getTransactionManagerInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchEnvironmentService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( children )     {", "if    ( children . contains ( eName )  )     {", "return   true ;", "}", "refreshChildren (  )  ;", "return   children . contains ( eName )  ;", "}", "}", "METHOD_END"], "methodName": ["hasJobExecution"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchJobExecutionResource"}, {"methodBody": ["METHOD_START", "{", "final   List < JobExecution >    executions    =    new   ArrayList <  >  (  )  ;", "final   List < JobInstance >    instances    =    jobOperator . allowMissingJob (  (  ( Supplier < List < JobInstance >  >  )     (  (  )     -  >    jobOperator . getJobInstances ( jobName ,     0  ,    jobOperator . getJobInstanceCount ( jobName )  )  )  )  ,    Collections . emptyList (  )  )  ;", "for    ( JobInstance   instance    :    instances )     {", "executions . addAll ( jobOperator . getJobExecutions ( instance )  )  ;", "}", "for    ( JobExecution   execution    :    executions )     {", "final   String   name    =    Long . toString ( execution . getExecutionId (  )  )  ;", "if    (  !  ( children . contains ( name )  )  )     {", "children . add ( name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refreshChildren"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchJobExecutionResource"}, {"methodBody": ["METHOD_START", "{", "Assert . checkNotNullParam (  \" name \"  ,    name )  ;", "return    \"  *  \"  . equals ( name )     ?     . allPermission    :     . mapping . getItemByString ( name )  ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchPermission"}, {"methodBody": ["METHOD_START", "{", "return   BatchPermission . forName ( name )  ;", "}", "METHOD_END"], "methodName": ["withName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.BatchPermission"}, {"methodBody": ["METHOD_START", "{", "final   String   msg    =    cause . getLocalizedMessage (  )  ;", "BatchLogger . LOGGER . debugf ( cause ,     \" Failed   to   process   batch   operation :     % s \"  ,    msg )  ;", "return   new   FailedException ( msg ,    cause )  ;", "}", "METHOD_END"], "methodName": ["createOperationFailure"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperationStepHandler"}, {"methodBody": ["METHOD_START", "{", "final   ServiceController <  ?  >    controller    =    context . getServiceRegistry ( modify )  . getService ( JobOperationStepHandler . getServiceName ( context )  )  ;", "final   WildFlyJobOperator   jobOperator    =     (  ( WildFlyJobOperator )     ( controller . getService (  )  )  )  ;", "execute ( context ,    operation ,    jobOperator )  ;", "}", "METHOD_END"], "methodName": ["executeRuntime"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperationStepHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   deploymentModel    =    context . readResourceFromRoot ( PathAddress . pathAddress ( element )  ,    false )  . getModel (  )  ;", "if    (  !  ( deploymentModel . hasDefined ( RUNTIME _ NAME )  )  )     {", "throw   BatchLogger . LOGGER . couldNotFindDeploymentName ( context . getCurrentAddress (  )  . toString (  )  )  ;", "}", "return   deploymentModel . get ( RUNTIME _ NAME )  . asString (  )  ;", "}", "METHOD_END"], "methodName": ["getRuntimeName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperationStepHandler"}, {"methodBody": ["METHOD_START", "{", "final   PathAddress   address    =    context . getCurrentAddress (  )  ;", "String   deploymentName    =    null ;", "String   subdeploymentName    =    null ;", "for    ( PathElement   element    :    address )     {", "if    ( DEPLOYMENT . equals ( element . getKey (  )  )  )     {", "deploymentName    =     . getRuntimeName ( context ,    element )  ;", "} else", "if    ( ModelDescriptionConstants . SUBDEPLOYMENT . endsWith ( element . getKey (  )  )  )     {", "subdeploymentName    =    element . getValue (  )  ;", "}", "}", "if    ( deploymentName    =  =    null )     {", "throw   BatchLogger . LOGGER . couldNotFindDeploymentName ( address . toString (  )  )  ;", "}", "if    ( subdeploymentName    =  =    null )     {", "return   BatchServiceNames . jobOperatorServiceName ( deploymentName )  ;", "}", "return   BatchServiceNames . jobOperatorServiceName ( deploymentName ,    subdeploymentName )  ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperationStepHandler"}, {"methodBody": ["METHOD_START", "{", "final   Properties   properties    =    new   Properties (  )  ;", "if    ( operation . hasDefined ( attribute . getName (  )  )  )     {", "for    ( Property   p    :     . resolveValue ( context ,    operation ,    attribute )  . asPropertyList (  )  )     {", "properties . put ( p . getName (  )  ,    p . getValue (  )  . asString (  )  )  ;", "}", "}", "return   properties ;", "}", "METHOD_END"], "methodName": ["resolvePropertyValue"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperationStepHandler"}, {"methodBody": ["METHOD_START", "{", "final   ModelNode   value    =    new   ModelNode (  )  ;", "if    ( o . has ( attribute . getName (  )  )  )     {", "value . set ( o . get ( attribute . getName (  )  )  )  ;", "}", "return   attribute . resolveValue ( context ,    value )  ;", "}", "METHOD_END"], "methodName": ["resolveValue"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperationStepHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( permissionsCheckEnabled . get (  )  )     {", "final   SecurityAwareBatchEnvironenviron =    getBatchEnviron )  ;", "final   SecurityIdentity   identity    =    environgetIdentity (  )  ;", "if    ( identity    !  =    null )     {", "final   BatchPermission   permission    =    BatchPermission . forName ( targetName )  ;", "if    (  !  ( identity . implies ( permission )  )  )     {", "throw   BatchLogger . LOGGER . unauthorized ( identity . getPrincipal (  )  . getName (  )  ,    permission )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkPermission"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "checkState ( null )  ;", "}", "METHOD_END"], "methodName": ["checkState"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "checkState ( jobName ,     \" read \"  )  ;", "}", "METHOD_END"], "methodName": ["checkState"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( batchEnvironment )     =  =    null )     |  |     (  ( classLoader )     =  =    null )  )     {", "throw   BatchLogger . LOGGER . jStopped (  )  ;", "}", "checkPermission ( targetName )  ;", "if    ( jobName    !  =    null )     {", "validateJob ( jobName )  ;", "}", "}", "METHOD_END"], "methodName": ["checkState"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "return   batchConfigurationInjector ;", "}", "METHOD_END"], "methodName": ["getBatchConfigurationInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "return   batchEnvironmentInjector ;", "}", "METHOD_END"], "methodName": ["getBatchEnvironmentInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "return   executorInjector ;", "}", "METHOD_END"], "methodName": ["getExecutorServiceInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "return   suspendControllerInjector ;", "}", "METHOD_END"], "methodName": ["getSuspendControllerInjector"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name    =  =    null )     |  |     (  \"  *  \"  . equals ( name )  )  )", "return ;", "if    (  !  ( resolver . isValidJobName ( name )  )  )     {", "throw   BLogger . LOGGER . noSuchJobException ( name )  ;", "}", "}", "METHOD_END"], "methodName": ["validateJob"], "fileName": "org.wildfly.extension.batch.jberet.deployment.JobOperatorService"}, {"methodBody": ["METHOD_START", "{", "final   SecurityIdentity   securityIdentity    =    getIdentity (  )  ;", "if    (  ( securityIdentity    !  =    null )     &  &     (  !  ( securityIdentity . isAnonymous (  )  )  )  )     {", "return   securityIdentity . getPrincipal (  )  . getName (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCurrentUserName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.SecurityAwareBatchEnvironment"}, {"methodBody": ["METHOD_START", "{", "final   SecurityDomain   securityDomain    =    getSecurityDomain (  )  ;", "if    ( securityDomain    !  =    null )     {", "return   securityDomain . getCurrentSecurityIdentity (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getIdentity"], "fileName": "org.wildfly.extension.batch.jberet.deployment.SecurityAwareBatchEnvironment"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "return   AccessController . doPrivileged ( new   PrivilegedAction <  >  (  )     {", "@ Override", "public      run (  )     {", "return   Association . get (  )  ;", "}", "}  )  ;", "}", "return   Association . get (  )  ;", "}", "METHOD_END"], "methodName": ["getSecurityContext"], "fileName": "org.wildfly.extension.batch.jberet.deployment.SecurityContextHandle"}, {"methodBody": ["METHOD_START", "{", "if    ( WildFlySecurityManager . isChecking (  )  )     {", "AccessController . doPrivileged ( new   PrivilegedAction < Void >  (  )     {", "@ Override", "public   Void   run (  )     {", "Association . set ( securityContext )  ;", "return   null ;", "}", "}  )  ;", "} else    {", "Association . set ( securityContext )  ;", "}", "}", "METHOD_END"], "methodName": ["setSecurityContext"], "fileName": "org.wildfly.extension.batch.jberet.deployment.SecurityContextHandle"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   supplier . get (  )  ;", "}    c    ( NoSuchJobException   ignore )     {", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["allowMissingJob"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobOperator"}, {"methodBody": ["METHOD_START", "{", "jobXmlNames . put ( jobXmlName ,    jobName )  ;", "final   Set < String >    xmlDescriptors    =    jobNames . computeIfAbsent ( jobName ,     (    s )     -  >    new   LinkedHashSet <  >  (  )  )  ;", "xmlDescriptors . add ( jobXmlName )  ;", "}", "METHOD_END"], "methodName": ["addJob"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( jobsDir    !  =    null )     &  &     ( jobsDir . exists (  )  )  )     {", "final   Map < String ,    VirtualFile >    xmlFiles    =    new   HashMap <  >  (  )  ;", "for    ( VirtualFile   f    :    jobsDir . getChildren (  . JobXmlFilter . INSTANCE )  )     {", "if    (  ( xmlFiles . put ( f . getName (  )  ,    f )  )     !  =    null )     {", "throw   new   IllegalStateException (  \" Duplicate   key \"  )  ;", "}", "}", "foundJobXmlFiles . putAll ( xmlFiles )  ;", "}", "}", "METHOD_END"], "methodName": ["addJobXmlFiles"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    VirtualFile >    foundJobXmlFiles    =    new   LinkedHashMap <  >  (  )  ;", "for    ( ResourceRoot   r    :    resources )     {", "final   VirtualFile   root    =    r . getRoot (  )  ;", "try    {", ". addJobXmlFiles ( foundJobXmlFiles ,    root . getChild ( DEFAULT _ PATH )  )  ;", "}    catch    ( IOException   e )     {", "throw   BatchLogger . LOGGER . errorProcessingBatchJobsDir ( e )  ;", "}", "}", "final      jobXmlResolver    =    new    ( foundJobXmlFiles )  ;", "jobXmlResolver . init ( classLoader )  ;", "return   jobXmlResolver ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( deploymentUnit . hasAttachment ( BatchAttachments . JOB _ XML _ RESOLVER )  )     {", "return   deploymentUnit . getAttachment ( BatchAttachments . JOB _ XML _ RESOLVER )  ;", "}", "final   Module   module    =    deploymentUnit . getAttachment ( MODULE )  ;", "final   ClassLoader   classLoader    =    module . getClassLoader (  )  ;", "resolver ;", "if    ( DeploymentTypeMarker . isType ( EAR ,    deploymentUnit )  )     {", "final   List < ResourceRoot >    resources    =    new   ArrayList <  >  (  )  ;", "for    ( ResourceRoot   r    :    deploymentUnit . getAttachmentList ( RESOURCE _ ROOTS )  )     {", "if    (  !  ( SubDeploymentMarker . isSubDeployment ( r )  )  )     {", "resources . add ( r )  ;", "}", "}", "resolver    =     . create ( classLoader ,    resources )  ;", "deploymentUnit . putAttachment ( BatchAttachments . JOB _ XML _ RESOLVER ,    resolver )  ;", "} else    {", "if    ( deploymentUnit . hasAttachment ( RESOURCE _ ROOTS )  )     {", "resolver    =     . create ( classLoader ,    deploymentUnit . getAttachmentList ( RESOURCE _ ROOTS )  )  ;", "} else    {", "resolver    =     . create ( classLoader ,    Collections . singletonList ( deploymentUnit . getAttachment ( DEPLOYMENT _ ROOT )  )  )  ;", "}", "deploymentUnit . putAttachment ( BatchAttachments . JOB _ XML _ RESOLVER ,    resolver )  ;", "final   List < DeploymentUnit >    accessibleDeployments    =    deploymentUnit . getAttachmentList ( ACCESSIBLE _ SUB _ DEPLOYMENTS )  ;", "for    ( DeploymentUnit   subDeployment    :    accessibleDeployments )     {", "if    ( deploymentUnit . equals ( subDeployment )  )     {", "continue ;", "}", "if    ( subDeployment . hasAttachment ( BatchAttachments . JOB _ XML _ RESOLVER )  )     {", "final      toCopy    =    subDeployment . getAttachment ( BatchAttachments . JOB _ XML _ RESOLVER )  ;", ". merge ( resolver ,    toCopy )  ;", "} else    {", "final      toCopy    =     . forDeployment ( subDeployment )  ;", "subDeployment . putAttachment ( BatchAttachments . JOB _ XML _ RESOLVER ,    toCopy )  ;", ". merge ( resolver ,    toCopy )  ;", "}", "}", "}", "return   resolver ;", "}", "METHOD_END"], "methodName": ["forDeployment"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashSet <  >  ( jobNames . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getJobNames"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( jobNames . containsKey ( jobName )  )     {", "urn   Collections . unmodifiableSet ( jobNames . get ( jobName )  )  ;", "}", "urn   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getJobXmlNames"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( JobXmlResolver   resolver    :    ServiceLoader . load ( JobXmlResolver . class ,    classLoader )  )     {", "jobXmlResolvers . add ( resolver )  ;", "for    ( String   jobXml    :    resolver . getJobXmlNames ( classLoader )  )     {", "addJob ( jobXml ,    resolver . resolveJobName ( jobXml ,    classLoader )  )  ;", "}", "}", "for    ( Map . Entry < String ,    VirtualFile >    entry    :    jobXmlFiles . entrySet (  )  )     {", "try    {", "final   Job   job    =    JobParser . parseJob ( entry . getValue (  )  . openStream (  )  ,    classLoader ,    new   XMLResolver (  )     {", "@ Override", "public   Object   resolveEntity ( final   String   publicID ,    final   String   systemID ,    final   String   baseURI ,    final   String   namespace )    throws   XMLStreamException    {", "try    {", "return   jobXmlFiles . containsKey ( systemID )     ?    jobXmlFiles . get ( systemID )  . openStream (  )     :    null ;", "}    catch    ( IOException   e )     {", "throw   new   XMLStreamException ( e )  ;", "}", "}", "}  )  ;", "addJob ( entry . getKey (  )  ,    job . getId (  )  )  ;", "}    catch    ( XMLStreamException    |    IOException   e )     {", "BatchLogger . LOGGER . invalidJobXmlFile ( entry . getKey (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "return   jobNames . containsKey ( jobName )  ;", "}", "METHOD_END"], "methodName": ["isValidJobName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "return   jobXmlNames . containsKey ( jobXmlName )  ;", "}", "METHOD_END"], "methodName": ["isValidJobXmlName"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "toCopy . jobXmlNames . forEach ( target . jobXmlNames :  : putIfAbsent )  ;", "toCopy . jobXmlFiles . forEach ( target . jobXmlFiles :  : putIfAbsent )  ;", "target . js . addAll ( toCopy . js )  ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "org.wildfly.extension.batch.jberet.deployment.WildFlyJobXmlResolver"}, {"methodBody": ["METHOD_START", "{", "return   dataSourceValue ;", "}", "METHOD_END"], "methodName": ["getDataSourceInjector"], "fileName": "org.wildfly.extension.batch.jberet.job.repository.JdbcJobRepositoryService"}, {"methodBody": ["METHOD_START", "{", "return   executor ;", "}", "METHOD_END"], "methodName": ["getExecutorServiceInjector"], "fileName": "org.wildfly.extension.batch.jberet.job.repository.JdbcJobRepositoryService"}, {"methodBody": ["METHOD_START", "{", "final   JobRepository   delegate    =    getDelegate (  )  ;", "if    (  ( started )     &  &     ( delegate    !  =    null )  )     {", "return   delegate ;", "}", "throw   BatchLogger . LOGGER . jobOperatorServiceStopped (  )  ;", "}", "METHOD_END"], "methodName": ["getAndCheckDelegate"], "fileName": "org.wildfly.extension.batch.jberet.job.repository.JobRepositoryService"}, {"methodBody": ["METHOD_START", "{", "return   threadPoolInjector ;", "}", "METHOD_END"], "methodName": ["getThreadPoolInjector"], "fileName": "org.wildfly.extension.batch.jberet.thread.pool.JobExecutorService"}]