[{"methodBody": ["METHOD_START", "{", "return   buttons . get ( buttonCode ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getButtonAmount"], "fileName": "com.badlogic.gdx.controllers.gwt.GwtController"}, {"methodBody": ["METHOD_START", "{", "return   index ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "com.badlogic.gdx.controllers.gwt.GwtController"}, {"methodBody": ["METHOD_START", "{", "return   listeners ;", "}", "METHOD_END"], "methodName": ["getListeners"], "fileName": "com.badlogic.gdx.controllers.gwt.GwtController"}, {"methodBody": ["METHOD_START", "{", "return   standardMapping ;", "}", "METHOD_END"], "methodName": ["isStandardMapping"], "fileName": "com.badlogic.gdx.controllers.gwt.GwtController"}, {"methodBody": ["METHOD_START", "{", "new   Runnable (  )     {", "@ SuppressWarnings (  \" synthetic - access \"  )", "@ Override", "public   void   run (  )     {", "synchronized ( eventQueue )     {", "for    ( Event   event    :    eventQueue )     {", "switch    ( event . type )     {", "case   Event . CONNECTED    :", "controllers . add ( event . controller )  ;", "for    ( ControllerListener   listener    :    listeners )     {", "listener . connected ( event . controller )  ;", "}", "break ;", "case   Event . DISCONNECTED    :", "controllers . removeValue ( event . controller ,    true )  ;", "for    ( ControllerListener   listener    :    listeners )     {", "listener . disconnected ( event . controller )  ;", "}", "for    ( ControllerListener   listener    :    event . controller . getListeners (  )  )     {", "listener . disconnected ( event . controller )  ;", "}", "break ;", "case   Event . BUTTON _ DOWN    :", "event . controller . buttons . put ( event . code ,    event . amount )  ;", "for    ( ControllerListener   listener    :    listeners )     {", "if    ( listener . buttonDown ( event . controller ,    event . code )  )", "break ;", "}", "for    ( ControllerListener   listener    :    event . controller . getListeners (  )  )     {", "if    ( listener . buttonDown ( event . controller ,    event . code )  )", "break ;", "}", "break ;", "case   Event . BUTTON _ UP    :", "event . controller . buttons . remove ( event . code ,    event . amount )  ;", "for    ( ControllerListener   listener    :    listeners )     {", "if    ( listener . buttonUp ( event . controller ,    event . code )  )", "break ;", "}", "for    ( ControllerListener   listener    :    event . controller . getListeners (  )  )     {", "if    ( listener . buttonUp ( event . controller ,    event . code )  )", "break ;", "}", "break ;", "case   Event . AXIS    :", "event . controller . axes [ event . code ]     =    event . amount ;", "for    ( ControllerListener   listener    :    listeners )     {", "if    ( listener . axisMoved ( event . controller ,    event . code ,    event . amount )  )", "break ;", "}", "for    ( ControllerListener   listener    :    event . controller . getListeners (  )  )     {", "if    ( listener . axisMoved ( event . controller ,    event . code ,    event . amount )  )", "break ;", "}", "break ;", "case   Event . POV    :", "for    ( ControllerListener   listener    :    listeners )     {", "if    ( listener . povMoved ( event . controller ,     0  ,    event . povDirection )  )", "break ;", "}", "for    ( ControllerListener   listener    :    event . controller . getListeners (  )  )     {", "if    ( listener . povMoved ( event . controller ,     0  ,    event . povDirection )  )", "break ;", "}", "break ;", "default    :", "}", "}", "eventPool . freeAll ( eventQueue )  ;", "eventQueue . clear (  )  ;", "}", "app . postRunnable ( this )  ;", "}", "}  . run (  )  ;", "}", "METHOD_END"], "methodName": ["setupEventQueue"], "fileName": "com.badlogic.gdx.controllers.gwt.GwtControllers"}, {"methodBody": ["METHOD_START", "{", "return   GamepadSupport . getGamepad ( index )  ;", "}", "METHOD_END"], "methodName": ["getGamepad"], "fileName": "com.badlogic.gdx.controllers.gwt.support.Gamepad"}, {"methodBody": ["METHOD_START", "{", "if    (  ( GamepadSupport . listener )     !  =    null )     {", "GamepadSupport . listener . onGamepadConnected ( index )  ;", "}", "}", "METHOD_END"], "methodName": ["fireGamepadConnected"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( GamepadSupport . listener )     !  =    null )     {", "GamepadSupport . listener . onGamepadDisconnected ( index )  ;", "}", "}", "METHOD_END"], "methodName": ["fireGamepadDisconnected"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( GamepadSupport . listener )     !  =    null )     {", "GamepadSupport . listener . onGamepadUpdated ( index )  ;", "}", "}", "METHOD_END"], "methodName": ["fireGamepadUpdated"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "return   GamepadSupport . gamepads . get ( index )  ;", "}", "METHOD_END"], "methodName": ["getGamepad"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "GamepadSupport . onGamepadConnect ( event . getGamepad (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleGamepadConnect"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "GamepadSupport . onGamepadDisconnect ( event . getGamepad (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleGamepadDisconnect"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "GamepadSupport . listener    =    listener ;", "GamepadSupport . nativeInit (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "GamepadSupport . consoleLog (  (  \" onGamepadConnect :     \"     +     ( gamepad . getId (  )  )  )  )  ;", "GamepadSupport . gamepads . put ( gamepad . getIndex (  )  ,    gamepad )  ;", "GamepadSupport . fireGamepadConnected ( gamepad . getIndex (  )  )  ;", "}", "METHOD_END"], "methodName": ["onGamepadConnect"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "GamepadSupport . consoleLog (  (  \" onGamepadDisconnect :     \"     +     ( gamepad . getId (  )  )  )  )  ;", "GamepadSupport . gamepads . remove ( gamepad . getIndex (  )  )  ;", "GamepadSupport . fireGamepadDisconnected ( gamepad . getIndex (  )  )  ;", "}", "METHOD_END"], "methodName": ["onGamepadDisconnect"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "JsArray < Gamepad >    currentGamepads    =    GamepadSupport . nativePollGamepads (  )  ;", "if    ( currentGamepads    !  =    null )     {", "GamepadSupport . gamepadsTemp . clear (  )  ;", "GamepadSupport . gamepadsTemp . putAll ( GamepadSupport . gamepads )  ;", "for    ( int   i    =     0  ,    j    =    currentGamepads . length (  )  ;    i    <    j ;    i +  +  )     {", "Gamepad   gamepad    =    currentGamepads . get ( i )  ;", "if    ( gamepad    !  =    null )     {", "if    (  !  ( GamepadSupport . gamepadsTemp . containsKey ( gamepad . getIndex (  )  )  )  )     {", "GamepadSupport . onGamepadConnect ( gamepad )  ;", "}", "GamepadSupport . gamepadsTemp . remove ( gamepad . getIndex (  )  )  ;", "}", "}", "for    ( Gamepad   gamepad    :    GamepadSupport . gamepadsTemp . values (  )  )     {", "GamepadSupport . onGamepadDisconnect ( gamepad )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["pollGamepads"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( Gamepad   gamepad    :    GamepadSupport . gamepads . values (  )  )     {", "if    (  ( gamepad . getPreviousTimestamp (  )  )     !  =     ( gamepad . getTimestamp (  )  )  )     {", "GamepadSupport . fireGamepadUpdated ( gamepad . getIndex (  )  )  ;", "}", "gamepad . setPreviousTimestamp ( gamepad . getTimestamp (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pollGamepadsStatus"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "GamepadSupport . consoleLog (  \" startPolling \"  )  ;", "GamepadSupport . ticker . start (  )  ;", "}", "METHOD_END"], "methodName": ["startPolling"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "GamepadSupport . ticker . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stopPolling"], "fileName": "com.badlogic.gdx.controllers.gwt.support.GamepadSupport"}, {"methodBody": ["METHOD_START", "{", "return   controller . getName (  )  . contains (  \" Xbox \"  )  ;", "}", "METHOD_END"], "methodName": ["isXboxController"], "fileName": "com.badlogic.gdx.controllers.mappings.Xbox"}]