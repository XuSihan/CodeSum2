[{"methodBody": ["METHOD_START", "{", "String   fileName    =    file . path (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "if    ( file . isDirectory (  )  )     {", "if    ( match ( fileName ,    excludes )  )", "return ;", "for    ( FileDesor   child    :    file . list (  )  )     {", "gatherSourceFiles ( child ,    includes ,    excludes ,    files )  ;", "}", "} else    {", "if    (  ( match ( fileName ,    includes )  )     &  &     (  !  ( match ( fileName ,    excludes )  )  )  )", "files . add ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["gatherSourceFiles"], "fileName": "com.badlogic.gdx.jnigen.AndroidNdkScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( target . os )     !  =     ( BuildTarget . TargetOs . Android )  )", "throw   new   IllegalArgumentException (  \" target   os   must   be   Android \"  )  ;", "if    (  !  ( config . libsDir . exists (  )  )  )     {", "if    (  !  ( config . libsDir . mkdirs (  )  )  )", "throw   new   RuntimeException (  (  (  \" Couldn ' t   create   directory   for   shared   library   files   in    '  \"     +     ( config . libsDir )  )     +     \"  '  \"  )  )  ;", "}", "if    (  !  ( config . jniDir . exists (  )  )  )     {", "if    (  !  ( config . jniDir . mkdirs (  )  )  )", "throw   new   RuntimeException (  (  (  \" Couldn ' t   create   native   code   directory    '  \"     +     ( config . jniDir )  )     +     \"  '  \"  )  )  ;", "}", "ArrayList < FileDescriptor >    files    =    new   ArrayList < FileDescriptor >  (  )  ;", "int   idx    =     0  ;", "String [  ]    includes    =    new   String [  ( target . cIncludes . length )     +     ( target . cppIncludes . length )  ]  ;", "for    ( String   include    :    target . cIncludes )", "includes [  ( idx +  +  )  ]     =     (  ( config . jniDir )     +     \"  /  \"  )     +    include ;", "for    ( String   include    :    target . cppIncludes )", "includes [  ( idx +  +  )  ]     =     (  ( config . jniDir )     +     \"  /  \"  )     +    include ;", "idx    =     0  ;", "String [  ]    excludes    =    new   String [  (  ( target . cExcludes . length )     +     ( target . cppExcludes . length )  )     +     1  ]  ;", "for    ( String   exclude    :    target . cExcludes )", "excludes [  ( idx +  +  )  ]     =     (  ( config . jniDir )     +     \"  /  \"  )     +    exclude ;", "for    ( String   exclude    :    target . cppExcludes )", "excludes [  ( idx +  +  )  ]     =     (  ( config . jniDir )     +     \"  /  \"  )     +    exclude ;", "excludes [ idx ]     =     \"  *  *  / target /  *  \"  ;", "gatherSourceFiles ( config . jniDir ,    includes ,    excludes ,    files )  ;", "FileDescriptor   application    =    config . jniDir . child (  \" Application . mk \"  )  ;", "application . writeString ( new   FileDescriptor (  \" com / badlogic / gdx / jnigen / resources / scripts / Application . mk . template \"  ,    FileDescriptor . FileType . Classpath )  . readString (  )  ,    false )  ;", "String   template    =    new   FileDescriptor (  \" com / badlogic / gdx / jnigen / resources / scripts / Android . mk . template \"  ,    FileDescriptor . FileType . Classpath )  . readString (  )  ;", "StringBuffer   srcFiles    =    new   StringBuffer (  )  ;", "for    ( int   i    =     0  ;    i    <     ( files . size (  )  )  ;    i +  +  )     {", "if    ( i    >     0  )", "srcFiles . append (  \"  \\ t \"  )  ;", "srcFiles . append ( files . get ( i )  . path (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  . replace (  (  ( config . jniDir . toString (  )  )     +     \"  /  \"  )  ,     \"  \"  )  )  ;", "if    ( i    <     (  ( files . size (  )  )     -     1  )  )", "srcFiles . append (  \"  \\  \\  \\ n \"  )  ;", "else", "srcFiles . append (  \"  \\ n \"  )  ;", "}", "StringBuffer   headerDirs    =    new   StringBuffer (  )  ;", "for    ( String   headerDir    :    target . headerDirs )     {", "headerDirs . append ( headerDir )  ;", "headerDirs . append (  \"     \"  )  ;", "}", "template    =    template . replace (  \"  % sharedLibName %  \"  ,    config . sharedLibName )  ;", "template    =    template . replace (  \"  % headerDirs %  \"  ,    headerDirs )  ;", "template    =    template . replace (  \"  % cFlags %  \"  ,    target . cFlags )  ;", "template    =    template . replace (  \"  % cppFlags %  \"  ,    target . cppFlags )  ;", "template    =    template . replace (  \"  % linkerFlags %  \"  ,    target . linkerFlags )  ;", "template    =    template . replace (  \"  % srcFiles %  \"  ,    srcFiles )  ;", "config . jniDir . child (  \" Android . mk \"  )  . writeString ( template ,    false )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.badlogic.gdx.jnigen.AndroidNdkScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "return   new   AntPathMatcher (  )  . match ( file ,    patterns )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "com.badlogic.gdx.jnigen.AndroidNdkScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( str . indexOf (  '  *  '  )  )     !  =     (  -  1  )  )     |  |     (  ( str . indexOf (  '  ?  '  )  )     !  =     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["isPattern"], "fileName": "com.badlogic.gdx.jnigen.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( str . startsWith (  \"  /  \"  )  )     !  =     ( pattern . startsWith (  \"  /  \"  )  )  )     {", "return   false ;", "}", "String [  ]    patDirs    =     . tokenizeToStringArray ( pattern ,     \"  /  \"  ,    true ,    true )  ;", "String [  ]    strDirs    =     . tokenizeToStringArray ( str ,     \"  /  \"  ,    true ,    true )  ;", "int   patIdxStart    =     0  ;", "int   patIdxEnd    =     ( patDirs . length )     -     1  ;", "int   strIdxStart    =     0  ;", "int   strIdxEnd    =     ( strDirs . length )     -     1  ;", "while    (  ( patIdxStart    <  =    patIdxEnd )     &  &     ( strIdxStart    <  =    strIdxEnd )  )     {", "String   patDir    =     (  ( String )     ( patDirs [ patIdxStart ]  )  )  ;", "if    ( patDir . equals (  \"  *  *  \"  )  )     {", "break ;", "}", "if    (  !  ( matchStrings ( patDir ,     (  ( String )     ( strDirs [ strIdxStart ]  )  )  )  )  )     {", "return   false ;", "}", "patIdxStart +  +  ;", "strIdxStart +  +  ;", "}", "if    ( strIdxStart    >    strIdxEnd )     {", "for    ( int   i    =    patIdxStart ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    (  !  ( patDirs [ i ]  . equals (  \"  *  *  \"  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "} else    {", "if    ( patIdxStart    >    patIdxEnd )     {", "return   false ;", "}", "}", "while    (  ( patIdxStart    <  =    patIdxEnd )     &  &     ( strIdxStart    <  =    strIdxEnd )  )     {", "String   patDir    =     (  ( String )     ( patDirs [ patIdxEnd ]  )  )  ;", "if    ( patDir . equals (  \"  *  *  \"  )  )     {", "break ;", "}", "if    (  !  ( matchStrings ( patDir ,     (  ( String )     ( strDirs [ strIdxEnd ]  )  )  )  )  )     {", "return   false ;", "}", "patIdxEnd -  -  ;", "strIdxEnd -  -  ;", "}", "if    ( strIdxStart    >    strIdxEnd )     {", "for    ( int   i    =    patIdxStart ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    (  !  ( patDirs [ i ]  . equals (  \"  *  *  \"  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "while    (  ( patIdxStart    !  =    patIdxEnd )     &  &     ( strIdxStart    <  =    strIdxEnd )  )     {", "int   patIdxTmp    =     -  1  ;", "for    ( int   i    =    patIdxStart    +     1  ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    ( patDirs [ i ]  . equals (  \"  *  *  \"  )  )     {", "patIdxTmp    =    i ;", "break ;", "}", "}", "if    ( patIdxTmp    =  =     ( patIdxStart    +     1  )  )     {", "patIdxStart +  +  ;", "continue ;", "}", "int   patLength    =     ( patIdxTmp    -    patIdxStart )     -     1  ;", "int   strLength    =     ( strIdxEnd    -    strIdxStart )     +     1  ;", "int   foundIdx    =     -  1  ;", "strLoop    :    for    ( int   i    =     0  ;    i    <  =     ( strLength    -    patLength )  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    patLength ;    j +  +  )     {", "String   subPat    =     (  ( String )     ( patDirs [  (  ( patIdxStart    +    j )     +     1  )  ]  )  )  ;", "String   subStr    =     (  ( String )     ( strDirs [  (  ( strIdxStart    +    i )     +    j )  ]  )  )  ;", "if    (  !  ( matchStrings ( subPat ,    subStr )  )  )     {", "continue   strLoop ;", "}", "}", "foundIdx    =    strIdxStart    +    i ;", "break ;", "}", "if    ( foundIdx    =  =     (  -  1  )  )     {", "return   false ;", "}", "patIdxStart    =    patIdxTmp ;", "strIdxStart    =    foundIdx    +    patLength ;", "}", "for    ( int   i    =    patIdxStart ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    (  !  ( patDirs [ i ]  . equals (  \"  *  *  \"  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "com.badlogic.gdx.jnigen.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( patterns    =  =    null )     |  |     (  ( patterns . length )     =  =     0  )  )", "return   true ;", "for    ( String   pattern    :    patterns )     {", "if    ( m ( pattern ,    file )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "com.badlogic.gdx.jnigen.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "char [  ]    patArr    =    pattern . toCharArray (  )  ;", "char [  ]    strArr    =    str . toCharArray (  )  ;", "int   patIdxStart    =     0  ;", "int   patIdxEnd    =     ( patArr . length )     -     1  ;", "int   strIdxStart    =     0  ;", "int   strIdxEnd    =     ( strArr . length )     -     1  ;", "char   ch ;", "boolean   containsStar    =    false ;", "for    ( int   i    =     0  ;    i    <     ( patArr . length )  ;    i +  +  )     {", "if    (  ( patArr [ i ]  )     =  =     '  *  '  )     {", "containsStar    =    true ;", "break ;", "}", "}", "if    (  ! containsStar )     {", "if    ( patIdxEnd    !  =    strIdxEnd )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <  =    patIdxEnd ;    i +  +  )     {", "ch    =    patArr [ i ]  ;", "if    ( ch    !  =     '  ?  '  )     {", "if    ( ch    !  =     ( strArr [ i ]  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "if    ( patIdxEnd    =  =     0  )     {", "return   true ;", "}", "while    (  (  ( ch    =    patArr [ patIdxStart ]  )     !  =     '  *  '  )     &  &     ( strIdxStart    <  =    strIdxEnd )  )     {", "if    ( ch    !  =     '  ?  '  )     {", "if    ( ch    !  =     ( strArr [ strIdxStart ]  )  )     {", "return   false ;", "}", "}", "patIdxStart +  +  ;", "strIdxStart +  +  ;", "}", "if    ( strIdxStart    >    strIdxEnd )     {", "for    ( int   i    =    patIdxStart ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    (  ( patArr [ i ]  )     !  =     '  *  '  )     {", "return   false ;", "}", "}", "return   true ;", "}", "while    (  (  ( ch    =    patArr [ patIdxEnd ]  )     !  =     '  *  '  )     &  &     ( strIdxStart    <  =    strIdxEnd )  )     {", "if    ( ch    !  =     '  ?  '  )     {", "if    ( ch    !  =     ( strArr [ strIdxEnd ]  )  )     {", "return   false ;", "}", "}", "patIdxEnd -  -  ;", "strIdxEnd -  -  ;", "}", "if    ( strIdxStart    >    strIdxEnd )     {", "for    ( int   i    =    patIdxStart ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    (  ( patArr [ i ]  )     !  =     '  *  '  )     {", "return   false ;", "}", "}", "return   true ;", "}", "while    (  ( patIdxStart    !  =    patIdxEnd )     &  &     ( strIdxStart    <  =    strIdxEnd )  )     {", "int   patIdxTmp    =     -  1  ;", "for    ( int   i    =    patIdxStart    +     1  ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    (  ( patArr [ i ]  )     =  =     '  *  '  )     {", "patIdxTmp    =    i ;", "break ;", "}", "}", "if    ( patIdxTmp    =  =     ( patIdxStart    +     1  )  )     {", "patIdxStart +  +  ;", "continue ;", "}", "int   patLength    =     ( patIdxTmp    -    patIdxStart )     -     1  ;", "int   strLength    =     ( strIdxEnd    -    strIdxStart )     +     1  ;", "int   foundIdx    =     -  1  ;", "strLoop    :    for    ( int   i    =     0  ;    i    <  =     ( strLength    -    patLength )  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    patLength ;    j +  +  )     {", "ch    =    patArr [  (  ( patIdxStart    +    j )     +     1  )  ]  ;", "if    ( ch    !  =     '  ?  '  )     {", "if    ( ch    !  =     ( strArr [  (  ( strIdxStart    +    i )     +    j )  ]  )  )     {", "continue   strLoop ;", "}", "}", "}", "foundIdx    =    strIdxStart    +    i ;", "break ;", "}", "if    ( foundIdx    =  =     (  -  1  )  )     {", "return   false ;", "}", "patIdxStart    =    patIdxTmp ;", "strIdxStart    =    foundIdx    +    patLength ;", "}", "for    ( int   i    =    patIdxStart ;    i    <  =    patIdxEnd ;    i +  +  )     {", "if    (  ( patArr [ i ]  )     !  =     '  *  '  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["matchStrings"], "fileName": "com.badlogic.gdx.jnigen.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "if    ( str    =  =    null )     {", "return   null ;", "}", "StringTokzer   st    =    new   StringTokzer ( str ,    delimiters )  ;", "List < String >    tok    =    new   ArrayList < String >  (  )  ;", "while    ( st . hasMoreTok (  )  )     {", "String   tok =    st . nextTok )  ;", "if    ( trimTok )     {", "tok =    toktrim (  )  ;", "}", "if    (  (  ! ignoreEmptyTok )     |  |     (  ( toklth (  )  )     >     0  )  )     {", "tok . add ( tok ;", "}", "}", "return   tok . toArray ( new   String [ tok . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["tokenizeToStringArray"], "fileName": "com.badlogic.gdx.jnigen.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "final   String   pack    =     \" com / badlogic / gdx / jnigen / resources / headers \"  ;", "String [  ]    files    =    new   String [  ]  {     \" classfile _ constants . h \"  ,     \" jawt . h \"  ,     \" jdwpTransport . h \"  ,     \" jni . h \"  ,     \" linux / jawt _ md . h \"  ,     \" linux / jni _ md . h \"  ,     \" mac / jni _ md . h \"  ,     \" win 3  2  / jawt _ md . h \"  ,     \" win 3  2  / jni _ md . h \"     }  ;", "for    ( String   file    :    files )     {", "new   FileDescriptor ( pack ,    FileDescriptor . FileType . Classpath )  . child ( file )  . copyTo ( new   FileDescriptor ( jniDir )  . child (  \" jni - headers \"  )  . child ( file )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyJniHeaders"], "fileName": "com.badlogic.gdx.jnigen.AntScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( config . libsDir . exists (  )  )  )     {", "if    (  !  ( config . libsDir . mkdirs (  )  )  )", "throw   new   RuntimeException (  (  (  \" Couldn ' t   create   directory   for   shared   library   files   in    '  \"     +     ( config . libsDir )  )     +     \"  '  \"  )  )  ;", "}", "if    (  !  ( config . jniDir . exists (  )  )  )     {", "if    (  !  ( config . jniDir . mkdirs (  )  )  )", "throw   new   RuntimeException (  (  (  \" Couldn ' t   create   native   code   directory    '  \"     +     ( config . jniDir )  )     +     \"  '  \"  )  )  ;", "}", "copyJniHeaders ( config . jniDir . path (  )  )  ;", "if    (  ( config . jniDir . child (  \" memcpy _ wrap . c \"  )  . exists (  )  )     =  =    false )     {", "new   FileDescriptor (  \" com /  / gdx / jnigen / resources / scripts / memcpy _ wrap . c \"  ,    FileDescriptor . FileType . Classpath )  . copyTo ( config . jniDir . child (  \" memcpy _ wrap . c \"  )  )  ;", "}", "ArrayList < String >    buildFiles    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    libsDirs    =    new   ArrayList < String >  (  )  ;", "ArrayList < String >    sharedLibFiles    =    new   ArrayList < String >  (  )  ;", "for    ( BuildTarget   target    :    targets )     {", "String   buildFile    =    generateBuildTargetTemplate ( config ,    target )  ;", "FileDescriptor   libsDir    =    new   FileDescriptor ( getLibsDirectory ( config ,    target )  )  ;", "if    (  !  ( libsDir . exists (  )  )  )     {", "if    (  !  ( libsDir . mkdirs (  )  )  )", "throw   new   RuntimeException (  (  (  \" Couldn ' t   create   libs   directory    '  \"     +    libsDir )     +     \"  '  \"  )  )  ;", "}", "String   buildFileName    =     (  (  \" build -  \"     +     ( target . os . toString (  )  . toLowerCase (  )  )  )     +     ( target . is 6  4 Bit    ?     \"  6  4  \"     :     \"  3  2  \"  )  )     +     \"  . xml \"  ;", "if    (  ( target . buildFileName )     !  =    null )", "buildFileName    =    target . buildFileName ;", "config . jniDir . child ( buildFileName )  . writeString ( buildFile ,    false )  ;", "System . out . println (  (  (  (  (  (  \" Wrote   target    '  \"     +     ( target . os )  )     +     ( target . is 6  4 Bit    ?     \"  6  4  \"     :     \"  \"  )  )     +     \"  '    build   script    '  \"  )     +     ( config . jniDir . child ( buildFileName )  )  )     +     \"  '  \"  )  )  ;", "if    (  !  ( target . excludeFromMasterBuildFile )  )     {", "if    (  (  ( target . os )     !  =     ( BuildTarget . TargetOs . MacOsX )  )     &  &     (  ( target . os )     !  =     ( BuildTarget . TargetOs . IOS )  )  )     {", "buildFiles . add ( buildFileName )  ;", "}", "String   sharedLibFilename    =    target . libName ;", "if    ( sharedLibFilename    =  =    null )", "sharedLibFilename    =    getSharedLibFilename ( target . os ,    target . is 6  4 Bit ,    config . sharedLibName )  ;", "sharedLibFiles . add ( sharedLibFilename )  ;", "if    (  (  ( target . os )     !  =     ( BuildTarget . TargetOs . Android )  )     &  &     (  ( target . os )     !  =     ( BuildTarget . TargetOs . IOS )  )  )     {", "libsDirs . add (  (  \"  .  .  /  \"     +     ( libsDir . path (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )  )  ;", "}", "}", "}", "String   template    =    new   FileDescriptor (  \" com /  / gdx / jnigen / resources / scripts / build . xml . template \"  ,    FileDescriptor . FileType . Classpath )  . readString (  )  ;", "StringBuffer   clean    =    new   StringBuffer (  )  ;", "StringBuffer   compile    =    new   StringBuffer (  )  ;", "StringBuffer   pack    =    new   StringBuffer (  )  ;", "for    ( int   i    =     0  ;    i    <     ( buildFiles . size (  )  )  ;    i +  +  )     {", "clean . append (  (  (  \"  \\ t \\ t < ant   antfile =  \\  \"  \"     +     ( buildFiles . get ( i )  )  )     +     \"  \\  \"    target =  \\  \" clean \\  \"  /  >  \\ n \"  )  )  ;", "compile . append (  (  (  \"  \\ t \\ t < ant   antfile =  \\  \"  \"     +     ( buildFiles . get ( i )  )  )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( libsDirs . size (  )  )  ;    i +  +  )     {", "pack . append (  (  (  (  (  \"  \\ t \\ t \\ t < fileset   dir =  \\  \"  \"     +     ( libsDirs . get ( i )  )  )     +     \"  \\  \"    includes =  \\  \"  \"  )     +     ( sharedLibFiles . get ( i )  )  )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "if    (  ( config . sharedLibs )     !  =    null )     {", "for    ( String   sharedLib    :    config . sharedLibs )     {", "pack . append (  (  (  \"  \\ t \\ t \\ t < fileset   dir =  \\  \"  \"     +    sharedLib )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "}", "template    =    template . replace (  \"  % projectName %  \"  ,     (  ( config . sharedLibName )     +     \"  - natives \"  )  )  ;", "template    =    template . replace (  \"  < clean /  >  \"  ,    clean . toString (  )  )  ;", "template    =    template . replace (  \"  < compile /  >  \"  ,    compile . toString (  )  )  ;", "template    =    template . replace (  \"  % packFile %  \"  ,     (  (  (  (  \"  .  .  /  \"     +     ( config . libsDir . path (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )     +     \"  /  \"  )     +     ( config . sharedLibName )  )     +     \"  - natives . jar \"  )  )  ;", "template    =    template . replace (  \"  < pack /  >  \"  ,    pack )  ;", "config . jniDir . child (  \" build . xml \"  )  . writeString ( template ,    false )  ;", "System . out . println (  (  (  \" Wrote   master   build   script    '  \"     +     ( config . jniDir . child (  \" build . xml \"  )  )  )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.badlogic.gdx.jnigen.AntScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( target . os )     =  =     ( BuildTarget . TargetOs . Android )  )     {", "new   AndroidNdk (  )  . generate ( config ,    target )  ;", "String   template    =    new   FileDescriptor (  \" com / badlogic / gdx / jnigen / resources / scripts / build - android . xml . template \"  ,    FileDescriptor . FileType . Classpath )  . readString (  )  ;", "template    =    template . replace (  \"  % precompile %  \"  ,     (  ( target . preCompileTask )     =  =    null    ?     \"  \"     :    target . preCompileTask )  )  ;", "template    =    template . replace (  \"  % postcompile %  \"  ,     (  ( target . postCompileTask )     =  =    null    ?     \"  \"     :    target . postCompileTask )  )  ;", "return   template ;", "}", "String   template    =    null ;", "if    (  ( target . os )     =  =     ( BuildTarget . TargetOs . IOS )  )     {", "template    =    new   FileDescriptor (  \" com / badlogic / gdx / jnigen / resources / scripts / build - ios . xml . template \"  ,    FileDescriptor . FileType . Classpath )  . readString (  )  ;", "} else    {", "template    =    new   FileDescriptor (  \" com / badlogic / gdx / jnigen / resources / scripts / build - target . xml . template \"  ,    FileDescriptor . FileType . Classpath )  . readString (  )  ;", "}", "String   libName    =    target . libName ;", "if    ( libName    =  =    null )", "libName    =    getSharedLibFilename ( target . os ,    target . is 6  4 Bit ,    config . sharedLibName )  ;", "String   jniPlatform    =    getJniPlatform ( target . os )  ;", "StringBuffer   cIncludes    =    new   StringBuffer (  )  ;", "cIncludes . append (  \"  \\ t \\ t < include   name =  \\  \" memcpy _ wrap . c \\  \"  /  >  \\ n \"  )  ;", "for    ( String   cInclude    :    target . cIncludes )     {", "cIncludes . append (  (  (  \"  \\ t \\ t < include   name =  \\  \"  \"     +    cInclude )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "StringBuffer   cppIncludes    =    new   StringBuffer (  )  ;", "for    ( String   cppInclude    :    target . cppIncludes )     {", "cppIncludes . append (  (  (  \"  \\ t \\ t < include   name =  \\  \"  \"     +    cppInclude )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "StringBuffer   cExcludes    =    new   StringBuffer (  )  ;", "for    ( String   cExclude    :    target . cExcludes )     {", "cExcludes . append (  (  (  \"  \\ t \\ t < exclude   name =  \\  \"  \"     +    cExclude )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "StringBuffer   cppExcludes    =    new   StringBuffer (  )  ;", "for    ( String   cppExclude    :    target . cppExcludes )     {", "cppExcludes . append (  (  (  \"  \\ t \\ t < exclude   name =  \\  \"  \"     +    cppExclude )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "StringBuffer   headerDirs    =    new   StringBuffer (  )  ;", "for    ( String   headerDir    :    target . headerDirs )     {", "headerDirs . append (  (  (  \"  \\ t \\ t \\ t < arg   value =  \\  \"  - I \"     +    headerDir )     +     \"  \\  \"  /  >  \\ n \"  )  )  ;", "}", "String   targetFolder    =    target . osFileName ;", "if    ( targetFolder    =  =    null )", "targetFolder    =     ( target . os . toString (  )  . toLowerCase (  )  )     +     ( target . is 6  4 Bit    ?     \"  6  4  \"     :     \"  3  2  \"  )  ;", "template    =    template . replace (  \"  % projectName %  \"  ,     (  (  (  (  ( config . sharedLibName )     +     \"  -  \"  )     +     ( target . os )  )     +     \"  -  \"  )     +     ( target . is 6  4 Bit    ?     \"  6  4  \"     :     \"  3  2  \"  )  )  )  ;", "template    =    template . replace (  \"  % buildDir %  \"  ,    config . buildDir . child ( targetFolder )  . path (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  ;", "template    =    template . replace (  \"  % libsDir %  \"  ,     (  \"  .  .  /  \"     +     ( getLibsDirectory ( config ,    target )  )  )  )  ;", "template    =    template . replace (  \"  % libName %  \"  ,    libName )  ;", "template    =    template . replace (  \"  % jniPlatform %  \"  ,    jniPlatform )  ;", "template    =    template . replace (  \"  % compilerPrefix %  \"  ,    target . compilerPrefix )  ;", "template    =    template . replace (  \"  % cFlags %  \"  ,    target . cFlags )  ;", "template    =    template . replace (  \"  % cppFlags %  \"  ,    target . cppFlags )  ;", "template    =    template . replace (  \"  % linkerFlags %  \"  ,    target . linkerFlags )  ;", "template    =    template . replace (  \"  % libraries %  \"  ,    target . libraries )  ;", "template    =    template . replace (  \"  % cIncludes %  \"  ,    cIncludes )  ;", "template    =    template . replace (  \"  % cExcludes %  \"  ,    cExcludes )  ;", "template    =    template . replace (  \"  % cppIncludes %  \"  ,    cppIncludes )  ;", "template    =    template . replace (  \"  % cppExcludes %  \"  ,    cppExcludes )  ;", "template    =    template . replace (  \"  % headerDirs %  \"  ,    headerDirs )  ;", "template    =    template . replace (  \"  % precompile %  \"  ,     (  ( target . preCompileTask )     =  =    null    ?     \"  \"     :    target . preCompileTask )  )  ;", "template    =    template . replace (  \"  % postcompile %  \"  ,     (  ( target . postCompileTask )     =  =    null    ?     \"  \"     :    target . postCompileTask )  )  ;", "return   template ;", "}", "METHOD_END"], "methodName": ["generateBuildTargetTemplate"], "fileName": "com.badlogic.gdx.jnigen.AntScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( os    =  =     ( BuildTarget . TargetOs . Windows )  )", "return    \" win 3  2  \"  ;", "if    ( os    =  =     ( BuildTarget . TargetOs . Linux )  )", "return    \" linux \"  ;", "if    ( os    =  =     ( BuildTarget . TargetOs . MacOsX )  )", "return    \" mac \"  ;", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getJniPlatform"], "fileName": "com.badlogic.gdx.jnigen.AntScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "String   targetName    =    target . osFileName ;", "if    ( targetName    =  =    null )", "targetName    =     ( target . os . toString (  )  . toLowerCase (  )  )     +     ( target . is 6  4 Bit    ?     \"  6  4  \"     :     \"  3  2  \"  )  ;", "return   config . libsDir . child ( targetName )  . path (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "}", "METHOD_END"], "methodName": ["getLibsDirectory"], "fileName": "com.badlogic.gdx.jnigen.AntScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "String   libPrefix    =     \"  \"  ;", "String   libSuffix    =     \"  \"  ;", "if    ( os    =  =     ( BuildTarget . TargetOs . Windows )  )     {", "libSuffix    =     ( is 6  4 Bit    ?     \"  6  4  \"     :     \"  \"  )     +     \"  . dll \"  ;", "}", "if    (  ( os    =  =     ( BuildTarget . TargetOs . Linux )  )     |  |     ( os    =  =     ( BuildTarget . TargetOsdroid )  )  )     {", "libPrefix    =     \" lib \"  ;", "libSuffix    =     ( is 6  4 Bit    ?     \"  6  4  \"     :     \"  \"  )     +     \"  . so \"  ;", "}", "if    ( os    =  =     ( BuildTarget . TargetOs . MacOsX )  )     {", "libPrefix    =     \" lib \"  ;", "libSuffix    =     ( is 6  4 Bit    ?     \"  6  4  \"     :     \"  \"  )     +     \"  . dylib \"  ;", "}", "if    ( os    =  =     ( BuildTarget . TargetOs . IOS )  )     {", "libPrefix    =     \" lib \"  ;", "libSuffix    =     \"  . a \"  ;", "}", "return    ( libPrefix    +    sharedLibName )     +    libSuffix ;", "}", "METHOD_END"], "methodName": ["getSharedLibFilename"], "fileName": "com.badlogic.gdx.jnigen.AntScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "FileDescriptor   build    =    new   FileDescriptor ( buildFile )  ;", "String   ant    =     ( System . getProperty (  \" os . name \"  )  . contains (  \" Windows \"  )  )     ?     \" ant . bat \"     :     \" ant \"  ;", "String   command    =     (  (  ( ant    +     \"     - f    \\  \"  \"  )     +     ( build . file (  )  . getAbsolutePath (  )  )  )     +     \"  \\  \"     \"  )     +    params ;", "System . out . println (  (  (  \" Executing    '  \"     +    command )     +     \"  '  \"  )  )  ;", "return    . startProcess ( command ,    build . parent (  )  . file (  )  )  ;", "}", "METHOD_END"], "methodName": ["executeAnt"], "fileName": "com.badlogic.gdx.jnigen.BuildExecutor"}, {"methodBody": ["METHOD_START", "{", "FileDescriptor   build    =    new   FileDescriptor ( directory )  ;", "String   command    =     \" ndk - build \"  ;", ". startProcess ( command ,    build . file (  )  )  ;", "}", "METHOD_END"], "methodName": ["executeNdk"], "fileName": "com.badlogic.gdx.jnigen.BuildExecutor"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Process   process    =    new   Processer ( command . split (  \"     \"  )  )  . redirectErrorStream ( true )  . start (  )  ;", "Thread   t    =    new   Thread ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( process . getInputStream (  )  )  )  ;", "String   line    =    null ;", "try    {", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "printFileLineNumber ( line )  ;", "}", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "private   void   printFileLineNumber ( String   line )     {", "if    (  ( line . contains (  \" warning \"  )  )     |  |     ( line . contains (  \" error \"  )  )  )     {", "try    {", "String   fileName    =    getFileName ( line )  ;", "String   error    =    getError ( line )  ;", "int   lineNumber    =     ( getLineNumber ( line )  )     -     1  ;", "if    (  ( fileName    !  =    null )     &  &     ( lineNumber    >  =     0  )  )     {", "FileDescriptor   file    =    new   FileDescriptor ( fileName )  ;", "if    ( file . exists (  )  )     {", "String [  ]    content    =    file . readString (  )  . split (  \"  \\ n \"  )  ;", "if    ( lineNumber    <     ( content . length )  )     {", "for    ( int   i    =    lineNumber ;    i    >  =     0  ;    i -  -  )     {", "String   contentLine    =    content [ i ]  ;", "if    ( contentLine . startsWith (  \"  /  /  @ line :  \"  )  )     {", "int   javaLineNumber    =    Integer . parseInt ( contentLine . split (  \"  :  \"  )  [  1  ]  . trim (  )  )  ;", "System . out . flush (  )  ;", "if    ( line . contains (  \" warning \"  )  )     {", "System . out . println (  (  (  (  (  (  (  (  \"  (  \"     +     ( file . nameWithoutExtension (  )  )  )     +     \"  . java :  \"  )     +     (  ( javaLineNumber    +     ( lineNumber    -    i )  )     -     1  )  )     +     \"  )  :     \"  )     +    error )     +     \"  ,    original :     \"  )     +    line )  )  ;", "System . out . flush (  )  ;", "} else    {", "System . err . println (  (  (  (  (  (  (  (  \"  (  \"     +     ( file . nameWithoutExtension (  )  )  )     +     \"  . java :  \"  )     +     (  ( javaLineNumber    +     ( lineNumber    -    i )  )     -     1  )  )     +     \"  )  :     \"  )     +    error )     +     \"  ,    original :     \"  )     +    line )  )  ;", "System . err . flush (  )  ;", "}", "return ;", "}", "}", "}", "} else    {", "System . out . println ( line )  ;", "}", "}", "}    catch    ( Throwable   t )     {", "System . out . println ( line )  ;", "}", "} else    {", "System . out . println ( line )  ;", "}", "}", "private   String   getFileName ( String   line )     {", "Pattern   pattern    =    Pattern . compile (  \"  (  .  *  )  :  (  [  0  -  9  ]  )  +  :  [  0  -  9  ]  +  :  \"  )  ;", "Matcher   matcher    =    pattern . matcher ( line )  ;", "matcher . find (  )  ;", "String   fileName    =     (  ( matcher . groupCount (  )  )     >  =     2  )     ?    matcher . group (  1  )  . trim (  )     :    null ;", "if    ( fileName    =  =    null )", "return   null ;", "int   index    =    fileName . indexOf (  \"     \"  )  ;", "if    ( index    !  =     (  -  1  )  )", "return   fileName . substring ( index )  . trim (  )  ;", "else", "return   fileName ;", "}", "private   String   getError ( String   line )     {", "Pattern   pattern    =    Pattern . compile (  \"  :  [  0  -  9  ]  +  :  [  0  -  9  ]  +  :  (  .  +  )  \"  )  ;", "Matcher   matcher    =    pattern . matcher ( line )  ;", "matcher . find (  )  ;", "return    ( matcher . groupCount (  )  )     >  =     1     ?    matcher . group (  1  )  . trim (  )     :    null ;", "}", "private   int   getLineNumber ( String   line )     {", "Pattern   pattern    =    Pattern . compile (  \"  :  (  [  0  -  9  ]  +  )  :  [  0  -  9  ]  +  :  \"  )  ;", "Matcher   matcher    =    pattern . matcher ( line )  ;", "matcher . find (  )  ;", "return    ( matcher . groupCount (  )  )     >  =     1     ?    Integer . parseInt ( matcher . group (  1  )  )     :     -  1  ;", "}", "}  )  ;", "t . setDaemon ( true )  ;", "t . start (  )  ;", "process . waitFor (  )  ;", "return    ( process . exitValue (  )  )     =  =     0  ;", "}    catch    ( Exception   e )     {", "e . printStackTrace (  )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["startProcess"], "fileName": "com.badlogic.gdx.jnigen.BuildExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type    =  =     ( BuildTarget . TargetOs . Windows )  )     &  &     (  ! is 6  4 Bit )  )     {", "return   new   BuildTarget ( BuildTarget . TargetOs . Windows ,    false ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \" i 6  8  6  - w 6  4  - mingw 3  2  -  \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse 2     - fmessage - length =  0     - m 3  2  \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse 2     - fmessage - length =  0     - m 3  2  \"  ,     \"  - Wl ,  -  - kill - at    - shared    - m 3  2     - static    - static - libgcc    - static - libstdc +  +  \"  )  ;", "}", "if    (  ( type    =  =     ( BuildTarget . TargetOs . Windows )  )     &  &    is 6  4 Bit )     {", "return   new   BuildTarget ( BuildTarget . TargetOs . Windows ,    true ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \" x 8  6  _  6  4  - w 6  4  - mingw 3  2  -  \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse 2     - fmessage - length =  0     - m 6  4  \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse 2     - fmessage - length =  0     - m 6  4  \"  ,     \"  - Wl ,  -  - kill - at    - shared    - static    - static - libgcc    - static - libstdc +  +     - m 6  4  \"  )  ;", "}", "if    (  ( type    =  =     ( BuildTarget . TargetOs . Linux )  )     &  &     (  ! is 6  4 Bit )  )     {", "return   new   BuildTarget ( BuildTarget . TargetOs . Linux ,    false ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \"  \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse    - fmessage - length =  0     - m 3  2     - fPIC \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse    - fmessage - length =  0     - m 3  2     - fPIC \"  ,     \"  - shared    - m 3  2  \"  )  ;", "}", "if    (  ( type    =  =     ( BuildTarget . TargetOs . Linux )  )     &  &    is 6  4 Bit )     {", "return   new   BuildTarget ( BuildTarget . TargetOs . Linux ,    true ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \"  \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse    - fmessage - length =  0     - m 6  4     - fPIC \"  ,     \"  - c    - Wall    - O 2     - mfpmath = sse    - msse    - fmessage - length =  0     - m 6  4     - fPIC \"  ,     \"  - shared    - m 6  4     - Wl ,  - wrap , memcpy \"  )  ;", "}", "if    (  ( type    =  =     ( BuildTarget . TargetOs . MacOsX )  )     &  &     (  ! is 6  4 Bit )  )     {", "BuildTarget   mac    =    new   BuildTarget ( BuildTarget . TargetOs . MacOsX ,    false ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \"  \"  ,     \"  - c    - Wall    - O 2     - arch   i 3  8  6     - DFIXED _ POINT    - fmessage - length =  0     - fPIC    - mmacosx - version - min =  1  0  .  5  \"  ,     \"  - c    - Wall    - O 2     - arch   i 3  8  6     - DFIXED _ POINT    - fmessage - length =  0     - fPIC    - mmacosx - version - min =  1  0  .  5  \"  ,     \"  - shared    - arch   i 3  8  6     - mmacosx - version - min =  1  0  .  5  \"  )  ;", "return   mac ;", "}", "if    (  ( type    =  =     ( BuildTarget . TargetOs . MacOsX )  )     &  &    is 6  4 Bit )     {", "BuildTarget   mac    =    new   BuildTarget ( BuildTarget . TargetOs . MacOsX ,    true ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \"  \"  ,     \"  - c    - Wall    - O 2     - arch   x 8  6  _  6  4     - DFIXED _ POINT    - fmessage - length =  0     - fPIC    - mmacosx - version - min =  1  0  .  5  \"  ,     \"  - c    - Wall    - O 2     - arch   x 8  6  _  6  4     - DFIXED _ POINT    - fmessage - length =  0     - fPIC    - mmacosx - version - min =  1  0  .  5  \"  ,     \"  - shared    - arch   x 8  6  _  6  4     - mmacosx - version - min =  1  0  .  5  \"  )  ;", "return   mac ;", "}", "if    ( type    =  =     ( BuildTarget . TargetOs . Android )  )     {", "BuildTarget   android    =    new   BuildTarget ( BuildTarget . TargetOs . Android ,    false ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \"  \"  ,     \"  - O 2     - Wall    - D _  _ ANDROID _  _  \"  ,     \"  - O 2     - Wall    - D _  _ ANDROID _  _  \"  ,     \"  - lm \"  )  ;", "return   android ;", "}", "if    ( type    =  =     ( BuildTarget . TargetOs . IOS )  )     {", "BuildTarget   ios    =    new   BuildTarget ( BuildTarget . TargetOs . IOS ,    false ,    new   String [  ]  {     \"  *  *  /  *  . c \"     }  ,    new   String [  0  ]  ,    new   String [  ]  {     \"  *  *  /  *  . cpp \"     }  ,    new   String [  0  ]  ,    new   String [  0  ]  ,     \"  \"  ,     \"  - c    - Wall    - O 2  \"  ,     \"  - c    - Wall    - O 2  \"  ,     \" rcs \"  )  ;", "return   ios ;", "}", "throw   new   RuntimeException (  \" Unknown   target   type \"  )  ;", "}", "METHOD_END"], "methodName": ["newDefaultTarget"], "fileName": "com.badlogic.gdx.jnigen.BuildTarget"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "return   new    ( new   File ( name )  ,    type )  ;", "return   new    ( new   File ( file ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "destDir . mkdirs (  )  ;", "[  ]    files    =    sourceDir . list (  )  ;", "for    ( int   i    =     0  ,    n    =    files . length ;    i    <    n ;    i +  +  )     {", "srcFile    =    files [ i ]  ;", "destFile    =    destDir . child ( srcFile . name (  )  )  ;", "if    ( srcFile . isDirectory (  )  )", ". copyDirectory ( srcFile ,    destFile )  ;", "else", ". copyFile ( srcFile ,    destFile )  ;", "}", "}", "METHOD_END"], "methodName": ["copyDirectory"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "dest . write ( source . read (  )  ,    false )  ;", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException (  (  (  (  (  (  (  (  (  (  \" Error   copying   source   f :     \"     +     ( source . f )  )     +     \"     (  \"  )     +     ( source . type )  )     +     \"  )  \\ n \"  )     +     \" To   destination :     \"  )     +     ( dest . f )  )     +     \"     (  \"  )     +     ( dest . type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFile"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isDirectory (  )  )  )     {", "if    ( dest . isDirectory (  )  )", "dest    =    dest . child ( name (  )  )  ;", ". copyFile ( this ,    dest )  ;", "return ;", "}", "if    ( dest . exists (  )  )     {", "if    (  !  ( dest . isDirectory (  )  )  )", "throw   new   RuntimeException (  (  \" Destination   exists   but   is   not   a   directory :     \"     +    dest )  )  ;", "} else    {", "dest . mkdirs (  )  ;", "if    (  !  ( dest . isDirectory (  )  )  )", "throw   new   RuntimeException (  (  \" Destination   directory   cannot   be   created :     \"     +    dest )  )  ;", "}", "dest    =    dest . child ( name (  )  )  ;", ". copyDirectory ( this ,    dest )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   delete   a   classpath   file :     \"     +     ( file )  )  )  ;", "return   file (  )  . delete (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   delete   a   classpath   file :     \"     +     ( file )  )  )  ;", "return   FileDescriptor . deleteDirectory ( file (  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( file . exists (  )  )     {", "File [  ]    files    =    file . listFiles (  )  ;", "if    ( files    !  =    null )     {", "for    ( int   i    =     0  ,    n    =    files . length ;    i    <    n ;    i +  +  )     {", "if    ( files [ i ]  . isDirectory (  )  )", ". deleteDirectory ( files [ i ]  )  ;", "else", "files [ i ]  . delete (  )  ;", "}", "}", "}", "return   file . delete (  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "return    ( FileDescriptor . class . getResource (  (  \"  /  \"     +     ( file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )  )  )     !  =    null ;", "return   file (  )  . exists (  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "String   name    =    file . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return    \"  \"  ;", "return   name . substring (  ( dotIndex    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["extension"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "return   false ;", "return   file (  )  . isDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   file (  )  . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )     |  |     (  !  ( file . exists (  )  )  )  )     {", "InputStream   input    =    read (  )  ;", "try    {", "return   input . available (  )  ;", "}    catch    ( Exception   ignored )     {", "}    finally    {", "try    {", "input . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "return    0  ;", "}", "return   file (  )  . length (  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "String [  ]    relativePaths    =    file (  )  . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileDescriptor [  0  ]  ;", "FileDescriptor [  ]    handles    =    new   FileDescriptor [ relativePaths . length ]  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )", "handles [ i ]     =    child ( relativePaths [ i ]  )  ;", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "String [  ]    relativePaths    =    file (  )  . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileDescriptor [  0  ]  ;", "FileDescriptor [  ]    handles    =    new   FileDescriptor [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "if    (  !  ( path . endsWith ( suffix )  )  )", "continue ;", "handles [ count ]     =    child ( path )  ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileDescriptor [  ]    newHandles    =    new   FileDescriptor [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   mkdirs   with   a   classpath   file :     \"     +     ( file )  )  )  ;", "return   file (  )  . mkdirs (  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   move   a   classpath   file :     \"     +     ( file )  )  )  ;", "copyTo ( dest )  ;", "delete (  )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   file . getName (  )  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "String   name    =    file . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return   name ;", "return   name . substring (  0  ,    dotIndex )  ;", "}", "METHOD_END"], "methodName": ["nameWithoutExtension"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "File   parent    =    file . getParentFile (  )  ;", "if    ( parent    =  =    null )     {", "if    (  ( type )     =  =     (  . FileType . Absolute )  )", "parent    =    new   File (  \"  /  \"  )  ;", "else", "parent    =    new   File (  \"  \"  )  ;", "}", "return   new    ( parent ,    type )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )     &  &     (  !  ( file . exists (  )  )  )  )     {", "InputStream   input    =    FileDescriptor . class . getResourceAsStream (  (  \"  /  \"     +     ( file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )  )  ;", "if    ( input    =  =    null )", "throw   new   RuntimeException (  (  (  (  (  \" File   not   found :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  )  ;", "return   input ;", "}", "try    {", "return   new   FileInputStream ( file (  )  )  ;", "}    catch    ( FileNotFoundException   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   RuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   RuntimeException (  (  (  (  (  \" Error   reading   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "int   length    =     (  ( int )     ( length (  )  )  )  ;", "if    ( length    =  =     0  )", "length    =     5  1  2  ;", "byte [  ]    buffer    =    new   byte [ length ]  ;", "int   position    =     0  ;", "InputStream   input    =    read (  )  ;", "try    {", "wh    ( true )     {", "int   count    =    input . read ( buffer ,    position ,     (  ( buffer . length )     -    position )  )  ;", "if    ( count    =  =     (  -  1  )  )", "break ;", "position    +  =    count ;", "if    ( position    =  =     ( buffer . length )  )     {", "byte [  ]    newBuffer    =    new   byte [  ( buffer . length )     *     2  ]  ;", "System . arraycopy ( buffer ,     0  ,    newBuffer ,     0  ,    position )  ;", "buffer    =    newBuffer ;", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "if    ( position    <     ( buffer . length )  )     {", "byte [  ]    newBuffer    =    new   byte [ position ]  ;", "System . arraycopy ( buffer ,     0  ,    newBuffer ,     0  ,    position )  ;", "buffer    =    newBuffer ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    read (  )  ;", "int   position    =     0  ;", "try    {", "wh    ( true )     {", "int   count    =    input . read ( bytes ,     ( offset    +    position )  ,     ( size    -    position )  )  ;", "if    ( count    <  =     0  )", "break ;", "position    +  =    count ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "return   position    -    offset ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   readString ( null )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   output    =    new   StringBuilder (  5  1  2  )  ;", "InputStreamReader   reader    =    null ;", "try    {", "if    ( charset    =  =    null )", "reader    =    new   InputStreamReader ( read (  )  )  ;", "else", "reader    =    new   InputStreamReader ( read (  )  ,    charset )  ;", "char [  ]    buffer    =    new   char [  2  5  6  ]  ;", "wh    ( true )     {", "int   length    =    reader . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "output . append ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  (  \" Error   reading   layout   f :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( reader    !  =    null )", "reader . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "return   output . toString (  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   InputStreamReader ( read (  )  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedReader ( new   InputStreamReader ( read (  )  )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   BufferedReader ( new   InputStreamReader ( read (  )  ,    charset )  ,    bufferSize )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   RuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   InputStreamReader ( read (  )  ,    charset )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   RuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   file    =    File . createTempFile ( prefix ,    null )  ;", "if    (  !  ( file . delete (  )  )  )", "throw   new   IOException (  (  \" Unable   to   delete   temp   file :     \"     +    file )  )  ;", "if    (  !  ( file . mkdir (  )  )  )", "throw   new   IOException (  (  \" Unable   to   create   temp   directory :     \"     +    file )  )  ;", "return   new    ( file )  ;", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  \" Unable   to   create   temp   file .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tempDirectory"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new    ( File . createTempFile ( prefix ,    null )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  \" Unable   to   create   temp   file .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tempFile"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   file . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   write   to   a   classpath   file :     \"     +     ( file )  )  )  ;", "parent (  )  . mkdirs (  )  ;", "try    {", "return   new   FileOutputStream ( file (  )  ,    append )  ;", "}    catch    ( FileNotFoundException   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   RuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   RuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    null ;", "try    {", "output    =    write ( append )  ;", "byte [  ]    buffer    =    new   byte [  4  0  9  6  ]  ;", "wh    ( true )     {", "int   length    =    input . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "output . write ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException (  (  (  (  (  \" Error   stream   writing   to   f :     \"     +     ( f )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "try    {", "if    ( output    !  =    null )", "output . close (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    write ( append )  ;", "try    {", "output . write ( bytes )  ;", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  (  (  (  (  \" Error   writing   f :     \"     +     ( f )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "try    {", "output . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "writeString ( string ,    append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "Writer   writer    =    null ;", "try    {", "writer    =    writer ( append ,    charset )  ;", "writer . write ( string )  ;", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException (  (  (  (  (  \" Error   writing   f :     \"     +     ( f )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( writer    !  =    null )", "writer . close (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   writer ( append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileDescriptor . FileType . Classpath )  )", "throw   new   RuntimeException (  (  \" Cannot   write   to   a   classpath   file :     \"     +     ( file )  )  )  ;", "parent (  )  . mkdirs (  )  ;", "try    {", "FileOutputStream   output    =    new   FileOutputStream ( file (  )  ,    append )  ;", "if    ( charset    =  =    null )", "return   new   OutputStreamWriter ( output )  ;", "else", "return   new   OutputStreamWriter ( output ,    charset )  ;", "}    catch    ( IOException   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   RuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   RuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.jnigen.FileDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( input    =  =    null )", "return    \"  \"     +     ( System . nanoTime (  )  )  ;", "CRC 3  2    crc    =    new   CRC 3  2  (  )  ;", "byte [  ]    buffer    =    new   byte [  4  0  9  6  ]  ;", "try    {", "while    ( true )     {", "int   length    =    input . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "crc . update ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( Exception   ex )     {", "try    {", "input . close (  )  ;", "}    catch    ( Exception   igno )     {", "}", "}", "return   Long . toString ( crc . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["crc"], "fileName": "com.badlogic.gdx.jnigen.JniGenSharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "String   srcCrc    =    crc ( JniGenSharedLibraryLoader . class . getResourceAsStream (  (  \"  /  \"     +    sharedLibName )  )  )  ;", "File   nativesDir    =    new   File (  (  (  ( System . getProperty (  \" tmpdir \"  )  )     +     \"  / jnigen /  \"  )     +    srcCrc )  )  ;", "File   nativeFile    =    new   File ( nativesDir ,    sharedLibName )  ;", "String   extractedCrc    =    null ;", "if    ( nativeFile . exists (  )  )     {", "try    {", "extractedCrc    =    crc ( new   FileInputStream ( nativeFile )  )  ;", "}    catch    ( FileNotFoundException   ignored )     {", "}", "}", "if    (  ( extractedCrc    =  =    null )     |  |     (  !  ( extractedCrc . equals ( srcCrc )  )  )  )     {", "try    {", "InputStream   input    =    null ;", "if    (  ( nativesJar )     =  =    null )", "input    =    JniGenSharedLibraryLoader . class . getResourceAsStream (  (  \"  /  \"     +    sharedLibName )  )  ;", "else", "input    =    getFromJar ( nativesJar ,    sharedLibName )  ;", "if    ( input    =  =    null )", "return   null ;", "nativeFile . getParentFile (  )  . mkdirs (  )  ;", "FileOutputStream   output    =    new   FileOutputStream ( nativeFile )  ;", "byte [  ]    buffer    =    new   byte [  4  0  9  6  ]  ;", "while    ( true )     {", "int   length    =    input . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "output . write ( buffer ,     0  ,    length )  ;", "}", "input . close (  )  ;", "output . close (  )  ;", "}    catch    ( IOException   ex )     {", "ex . printStackTrace (  )  ;", "throw   new   RuntimeException ( ex )  ;", "}", "}", "return   nativeFile . exists (  )     ?    nativeFile . getAbsolutePath (  )     :    null ;", "}", "METHOD_END"], "methodName": ["extractLibrary"], "fileName": "com.badlogic.gdx.jnigen.JniGenSharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "ZipFile   file    =    new   ZipFile ( nativesJar )  ;", "ZipEntry   entry    =    file . getEntry ( s )  ;", "return   file . getInputStream ( entry )  ;", "}", "METHOD_END"], "methodName": ["getFromJar"], "fileName": "com.badlogic.gdx.jnigen.JniGenSharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( JniGenSharedLibraryLoader . loadedLibraries . contains ( sharedLibName )  )", "return ;", "boolean   isWindows    =    System . getProperty (  \" os . name \"  )  . contains (  \" Windows \"  )  ;", "boolean   isLinux    =    System . getProperty (  \" os . name \"  )  . contains (  \" Linux \"  )  ;", "boolean   isMac    =    System . getProperty (  \" os . name \"  )  . contains (  \" Mac \"  )  ;", "boolean   isAndroid    =    false ;", "boolean   is 6  4 Bit    =     ( System . getProperty (  \" os . arch \"  )  . equals (  \" amd 6  4  \"  )  )     |  |     ( System . getProperty (  \" os . arch \"  )  . equals (  \" x 8  6  _  6  4  \"  )  )  ;", "boolean   isArm    =    System . getProperty (  \" os . arch \"  )  . equals (  \" arm \"  )  ;", "String   vm    =    System . getProperty (  \" name \"  )  ;", "if    (  ( vm    !  =    null )     &  &     ( vm . contains (  \" Dalvik \"  )  )  )     {", "isAndroid    =    true ;", "isWindows    =    false ;", "isLinux    =    false ;", "isMac    =    false ;", "is 6  4 Bit    =    false ;", "}", "boolean   loaded    =    false ;", "if    ( isWindows )     {", "if    (  ( libraryFinder )     !  =    null )", "loaded    =    loadLibrary ( libraryFinder . getSharedLibraryNameWindows ( sharedLibName ,    is 6  4 Bit ,    nativesZip )  )  ;", "else", "if    (  ! is 6  4 Bit )", "loaded    =    loadLibrary (  ( sharedLibName    +     \"  . dll \"  )  )  ;", "else", "loaded    =    loadLibrary (  ( sharedLibName    +     \"  6  4  . dll \"  )  )  ;", "}", "if    ( isLinux )     {", "if    (  ( libraryFinder )     !  =    null )", "loaded    =    loadLibrary ( libraryFinder . getSharedLibraryNameLinux ( sharedLibName ,    is 6  4 Bit ,    isArm ,    nativesZip )  )  ;", "else", "if    (  ! is 6  4 Bit )     {", "if    ( isArm )", "loaded    =    loadLibrary (  (  (  \" lib \"     +    sharedLibName )     +     \" Arm . so \"  )  )  ;", "else", "loaded    =    loadLibrary (  (  (  \" lib \"     +    sharedLibName )     +     \"  . so \"  )  )  ;", "} else    {", "if    ( isArm )", "loaded    =    loadLibrary (  (  (  \" lib \"     +    sharedLibName )     +     \" Arm 6  4  . so \"  )  )  ;", "else", "loaded    =    loadLibrary (  (  (  \" lib \"     +    sharedLibName )     +     \"  6  4  . so \"  )  )  ;", "}", "}", "if    ( isMac )     {", "if    (  ( libraryFinder )     !  =    null )", "loaded    =    loadLibrary ( libraryFinder . getSharedLibraryNameMac ( sharedLibName ,    is 6  4 Bit ,    nativesZip )  )  ;", "else", "if    (  ! is 6  4 Bit )", "loaded    =    loadLibrary (  (  (  \" lib \"     +    sharedLibName )     +     \"  . dylib \"  )  )  ;", "else", "loaded    =    loadLibrary (  (  (  \" lib \"     +    sharedLibName )     +     \"  6  4  . dylib \"  )  )  ;", "}", "if    ( isAndroid )     {", "if    (  ( libraryFinder )     !  =    null )", "System . loadLibrary ( libraryFinder . getSharedLibraryNameAndroid ( sharedLibName ,    nativesZip )  )  ;", "else", "System . loadLibrary ( sharedLibName )  ;", "loaded    =    true ;", "}", "if    ( loaded )", "JniGenSharedLibraryLoader . loadedLibraries . add ( sharedLibName )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.jnigen.JniGenSharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( sharedLibName    =  =    null )", "return   false ;", "String   path    =    extractLibrary ( sharedLibName )  ;", "if    ( path    !  =    null )", "System . load ( path )  ;", "return   path    !  =    null ;", "}", "METHOD_END"], "methodName": ["loadLibrary"], "fileName": "com.badlogic.gdx.jnigen.JniGenSharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "this . libraryFinder    =    libraryFinder ;", "if    (  ( nativesJar )     !  =    null )     {", "try    {", "nativesZip    =    new   ZipFile ( nativesJar )  ;", "}    catch    ( IOException   e )     {", "nativesZip    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["setSharedLibraryFinder"], "fileName": "com.badlogic.gdx.jnigen.JniGenSharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "buffer . append (  (  (  \"  # include    <  \"     +    fileName )     +     \"  >  \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["emitHeaderInclude"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   jniSetupCode    =    new   StringBuffer (  )  ;", "StringBuffer   jniCleanupCode    =    new   StringBuffer (  )  ;", "StringBuffer   additionalArgs    =    new   StringBuffer (  )  ;", "StringBuffer   wrapperArgs    =    new   StringBuffer (  )  ;", "emitJniSetupCode ( jniSetupCode ,    javaMethod ,    additionalArgs ,    wrapperArgs )  ;", "emitJniCleanupCode ( jniCleanupCode ,    javaMethod ,    cMethod )  ;", "boolean   isManual    =    isManual (  )  ;", "if    (  ( hasDisposableArgument (  )  )     &  &     ( getNativeCode (  )  . contains (  \" return \"  )  )  )     {", "if    ( isManual )     {", "emitMethodSignature ( buffer ,    javaMethod ,    cMethod ,    null ,    false )  ;", "emitMethodBody ( buffer ,    javaMethod )  ;", "buffer . append (  \"  }  \\ n \\ n \"  )  ;", "} else    {", "String   wrappedMethodName    =    emitMethodSignature ( buffer ,    javaMethod ,    cMethod ,    additionalArgs . toString (  )  )  ;", "emitMethodBody ( buffer ,    javaMethod )  ;", "buffer . append (  \"  }  \\ n \\ n \"  )  ;", "emitMethodSignature ( buffer ,    javaMethod ,    cMethod ,    null )  ;", "if    (  ! isManual )     {", "buffer . append ( jniSetupCode )  ;", "}", "if    ( cMethod . getReturnType (  )  . equals (  \" void \"  )  )     {", "buffer . append (  (  (  (  (  \"  \\ t \"     +    wrappedMethodName )     +     \"  (  \"  )     +     ( wrapperArgs . toString (  )  )  )     +     \"  )  ;  \\ n \\ n \"  )  )  ;", "if    (  ! isManual )     {", "buffer . append ( jniCleanupCode )  ;", "}", "buffer . append (  \"  \\ treturn ;  \\ n \"  )  ;", "} else    {", "buffer . append (  (  (  (  (  (  (  (  (  \"  \\ t \"     +     ( cMethod . getReturnType (  )  )  )     +     \"     \"  )     +     (  . JNI _ RETURN _ VALUE )  )     +     \"     =     \"  )     +    wrappedMethodName )     +     \"  (  \"  )     +     ( wrapperArgs . toString (  )  )  )     +     \"  )  ;  \\ n \\ n \"  )  )  ;", "if    (  ! isManual )     {", "buffer . append ( jniCleanupCode )  ;", "}", "buffer . append (  (  (  \"  \\ treturn    \"     +     (  . JNI _ RETURN _ VALUE )  )     +     \"  ;  \\ n \"  )  )  ;", "}", "buffer . append (  \"  }  \\ n \\ n \"  )  ;", "}", "} else    {", "emitMethodSignature ( buffer ,    javaMethod ,    cMethod ,    null )  ;", "if    (  ! isManual )     {", "buffer . append ( jniSetupCode )  ;", "}", "emitMethodBody ( buffer ,    javaMethod )  ;", "if    (  ! isManual )     {", "buffer . append ( jniCleanupCode )  ;", "}", "buffer . append (  \"  }  \\ n \\ n \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["emitJavaMethod"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "for    ( JavaMethodParser . Argument   arg    :    getArguments (  )  )     {", "if    ( arg . getType (  )  . isPrimitiveArray (  )  )     {", "buffer . append (  (  (  (  (  (  \"  \\ tenv -  > ReleasePrimitiveArrayCritical (  \"     +     (  . JNI _ ARG _ PREFIX )  )     +     ( arg . getName (  )  )  )     +     \"  ,     \"  )     +     ( arg . getName (  )  )  )     +     \"  ,     0  )  ;  \\ n \"  )  )  ;", "}", "}", "for    ( JavaMethodParser . Argument   arg    :    getArguments (  )  )     {", "if    ( arg . getType (  )  . isString (  )  )     {", "buffer . append (  (  (  (  (  (  \"  \\ tenv -  > ReleaseStringUTFChars (  \"     +     (  . JNI _ ARG _ PREFIX )  )     +     ( arg . getName (  )  )  )     +     \"  ,     \"  )     +     ( arg . getName (  )  )  )     +     \"  )  ;  \\ n \"  )  )  ;", "}", "}", "buffer . append (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["emitJniCleanupCode"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "emitLineMarker ( buffer ,    section . getStartIndex (  )  )  ;", "buffer . append ( section . get (  )  . replace (  \"  \\ r \"  ,     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["emitJniSection"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( isStatic (  )  )     {", "wrapperArgs . append (  \" env ,    clazz ,     \"  )  ;", "} else    {", "wrapperArgs . append (  \" env ,    object ,     \"  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( getArguments (  )  . size (  )  )  ;    i +  +  )     {", "JavaMethodParser . Argument   arg    =    getArguments (  )  . get ( i )  ;", "if    (  (  !  ( arg . getType (  )  . isPlainOldDataType (  )  )  )     &  &     (  !  ( arg . getType (  )  . isObject (  )  )  )  )     {", "wrapperArgs . append (  . JNI _ ARG _ PREFIX )  ;", "}", "wrapperArgs . append ( arg . getName (  )  )  ;", "if    ( i    <     (  ( getArguments (  )  . size (  )  )     -     1  )  )", "wrapperArgs . append (  \"  ,     \"  )  ;", "}", "for    ( JavaMethodParser . Argument   arg    :    getArguments (  )  )     {", "if    ( arg . getType (  )  . isBuffer (  )  )     {", "String   type    =    arg . getType (  )  . getBufferCType (  )  ;", "buffer . append (  (  (  (  (  (  (  (  (  (  (  (  (  \"  \\ t \"     +    type )     +     \"     \"  )     +     ( arg . getName (  )  )  )     +     \"     =     (  \"  )     +    type )     +     \"  )  (  \"  )     +     (  . JNI _ ARG _ PREFIX )  )     +     ( arg . getName (  )  )  )     +     \"  ? env -  > GetDirectBufferAddress (  \"  )     +     (  . JNI _ ARG _ PREFIX )  )     +     ( arg . getName (  )  )  )     +     \"  )  :  0  )  ;  \\ n \"  )  )  ;", "additionalArgs . append (  \"  ,     \"  )  ;", "additionalArgs . append ( type )  ;", "additionalArgs . append (  \"     \"  )  ;", "additionalArgs . append ( arg . getName (  )  )  ;", "wrapperArgs . append (  \"  ,     \"  )  ;", "wrapperArgs . append ( arg . getName (  )  )  ;", "}", "}", "for    ( JavaMethodParser . Argument   arg    :    getArguments (  )  )     {", "if    ( arg . getType (  )  . isString (  )  )     {", "String   type    =     \" char *  \"  ;", "buffer . append (  (  (  (  (  (  (  (  (  (  \"  \\ t \"     +    type )     +     \"     \"  )     +     ( arg . getName (  )  )  )     +     \"     =     (  \"  )     +    type )     +     \"  ) env -  > GetStringUTFChars (  \"  )     +     (  . JNI _ ARG _ PREFIX )  )     +     ( arg . getName (  )  )  )     +     \"  ,     0  )  ;  \\ n \"  )  )  ;", "additionalArgs . append (  \"  ,     \"  )  ;", "additionalArgs . append ( type )  ;", "additionalArgs . append (  \"     \"  )  ;", "additionalArgs . append ( arg . getName (  )  )  ;", "wrapperArgs . append (  \"  ,     \"  )  ;", "wrapperArgs . append ( arg . getName (  )  )  ;", "}", "}", "for    ( JavaMethodParser . Argument   arg    :    getArguments (  )  )     {", "if    ( arg . getType (  )  . isPrimitiveArray (  )  )     {", "String   type    =    arg . getType (  )  . getArrayCType (  )  ;", "buffer . append (  (  (  (  (  (  (  (  (  (  \"  \\ t \"     +    type )     +     \"     \"  )     +     ( arg . getName (  )  )  )     +     \"     =     (  \"  )     +    type )     +     \"  ) env -  > GetPrimitiveArrayCritical (  \"  )     +     (  . JNI _ ARG _ PREFIX )  )     +     ( arg . getName (  )  )  )     +     \"  ,     0  )  ;  \\ n \"  )  )  ;", "additionalArgs . append (  \"  ,     \"  )  ;", "additionalArgs . append ( type )  ;", "additionalArgs . append (  \"     \"  )  ;", "additionalArgs . append ( arg . getName (  )  )  ;", "wrapperArgs . append (  \"  ,     \"  )  ;", "wrapperArgs . append ( arg . getName (  )  )  ;", "}", "}", "buffer . append (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["emitJniSetupCode"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "buffer . append (  \"  \\ n /  /  @ line :  \"  )  ;", "buffer . append ( line )  ;", "buffer . append (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["emitLineMarker"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "emitLineMarker ( buffer ,    getEndIndex (  )  )  ;", "buffer . append ( get (  )  )  ;", "buffer . append (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["emitMethodBody"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "return   emitMethodSignature ( buffer ,    javaMethod ,    cMethod ,    additionalArguments ,    true )  ;", "}", "METHOD_END"], "methodName": ["emitMethodSignature"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "String   wrappedMethodName    =    null ;", "if    ( additionalArguments    !  =    null )     {", "String [  ]    tokens    =    cMethod . getHead (  )  . replace (  \"  \\ r \\ n \"  ,     \"  \"  )  . replace (  \"  \\ n \"  ,     \"  \"  )  . split (  \"     \"  )  ;", "wrappedMethodName    =     (  . JNI _ WRAPPER _ PREFIX )     +     ( tokens [  3  ]  )  ;", "buffer . append (  \" static   inline    \"  )  ;", "buffer . append ( tokens [  1  ]  )  ;", "buffer . append (  \"     \"  )  ;", "buffer . append ( wrappedMethodName )  ;", "buffer . append (  \"  \\ n \"  )  ;", "} else    {", "buffer . append ( cMethod . getHead (  )  )  ;", "}", "if    ( isStatic (  )  )     {", "buffer . append (  \"  ( JNIEnv *    env ,    jclass   clazz \"  )  ;", "} else    {", "buffer . append (  \"  ( JNIEnv *    env ,    jobject   object \"  )  ;", "}", "if    (  ( getArguments (  )  . size (  )  )     >     0  )", "buffer . append (  \"  ,     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( getArguments (  )  . size (  )  )  ;    i +  +  )     {", "buffer . append ( cMethod . getArgumentTypes (  )  [  ( i    +     2  )  ]  )  ;", "buffer . append (  \"     \"  )  ;", "JavaMethodParser . Argument   javaArg    =    getArguments (  )  . get ( i )  ;", "if    (  (  (  !  ( getType (  )  . isPlainOldDataType (  )  )  )     &  &     (  !  ( getType (  )  . isObject (  )  )  )  )     &  &    appendPrefix )     {", "buffer . append (  . JNI _ ARG _ PREFIX )  ;", "}", "buffer . append ( getName (  )  )  ;", "if    ( i    <     (  ( getArguments (  )  . size (  )  )     -     1  )  )", "buffer . append (  \"  ,     \"  )  ;", "}", "if    ( additionalArguments    !  =    null )     {", "buffer . append ( additionalArguments )  ;", "}", "buffer . append (  \"  )     {  \\ n \"  )  ;", "return   wrappedMethodName ;", "}", "METHOD_END"], "methodName": ["emitMethodSignature"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "for    ( CMethodParser . CMethod   cMethod    :    cMethods )     {", "String   javaMethodName    =    getName (  )  . replace (  \"  _  \"  ,     \"  _  1  \"  )  ;", "String   javaClassName    =    getClassName (  )  . toString (  )  . replace (  \"  _  \"  ,     \"  _  1  \"  )  ;", "if    (  ( cMethod . getHead (  )  . endsWith (  (  ( javaClassName    +     \"  _  \"  )     +    javaMethodName )  )  )     |  |     ( cMethod . getHead (  )  . contains (  (  (  ( javaClassName    +     \"  _  \"  )     +    javaMethodName )     +     \"  _  _  \"  )  )  )  )     {", "if    (  (  ( cMethod . getArgumentTypes (  )  . length )     -     2  )     =  =     ( getArguments (  )  . size (  )  )  )     {", "boolean   match    =    true ;", "for    ( int   i    =     2  ;    i    <     ( cMethod . getArgumentTypes (  )  . length )  ;    i +  +  )     {", "String   cType    =    cMethod . getArgumentTypes (  )  [ i ]  ;", "String   javaType    =    getArguments (  )  . get (  ( i    -     2  )  )  . getType (  )  . getJniType (  )  ;", "if    (  !  ( cType . equals ( javaType )  )  )     {", "match    =    false ;", "break ;", "}", "}", "if    ( match )     {", "return   cMethod ;", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findCMethod"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "generate (  \" src \"  ,     \" bin \"  ,     \" jni \"  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "generate ( sourceDir ,    classpath ,    jniDir ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "this . sourceDir    =    new   FileDescriptor ( sourceDir )  ;", "thisDir    =    new   FileDescriptorDir )  ;", "this . classpath    =    classpath ;", "this . includes    =    includes ;", "this . excludes    =    excludes ;", "if    (  !  ( this . sourceDir . exists (  )  )  )     {", "throw   new   Exception (  (  (  \" Java   source   directory    '  \"     +    sourceDir )     +     \"  '    does   not   exist \"  )  )  ;", "}", "if    (  !  ( thisDir . exists (  )  )  )     {", "if    (  !  ( thisDir . mkdirs (  )  )  )     {", "throw   new   Exception (  (  (  \" Couldn ' t   create   JNI   directory    '  \"     + Dir )     +     \"  '  \"  )  )  ;", "}", "}", "processDirectory ( this . sourceDir )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "String   headerFileContent    =    hFile . readString (  )  ;", "ArrayList < CMethodParser . CMethod >    cMethods    =    cMethodParser . parse ( headerFileContent )  . getMethods (  )  ;", "StringBuffer   buffer    =    new   StringBuffer (  )  ;", "emitHeaderInclude ( buffer ,    hFile . name (  )  )  ;", "for    ( JavaMethodParser . JavaSegment   segment    :    javaSegments )     {", "if    ( segment   instanceof   JavaMethodParser . JniSection )     {", "emitJniSection ( buffer ,     (  ( JavaMethodParser . JniSection )     ( segment )  )  )  ;", "}", "if    ( segment   instanceof   JavaMethodParser . JavaMethod )     {", "JavaMethodParser . JavaMethod   javaMethod    =     (  ( JavaMethodParser . JavaMethod )     ( segment )  )  ;", "if    (  ( get (  )  )     =  =    null )     {", "throw   new   RuntimeException (  (  (  \" Method    '  \"     +     ( getName (  )  )  )     +     \"  '    has   no   body \"  )  )  ;", "}", "CMethodParser . CMethod   cMethod    =    findCMethod ( javaMethod ,    cMethods )  ;", "if    ( cMethod    =  =    null )", "throw   new   RuntimeException (  (  (  (  (  \" Couldn ' t   find   C   method   for   Java   method    '  \"     +     ( getClassName (  )  )  )     +     \"  #  \"  )     +     ( getName (  )  )  )     +     \"  '  \"  )  )  ;", "emitJavaMethod ( buffer ,    javaMethod ,    cMethod )  ;", "}", "}", "cppFile . writeString ( buffer . toString (  )  ,    false ,     \" UTF -  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["generateCppFile"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "String   className    =    getFullyQualifiedClassName ( file )  ;", "String   mand    =     (  (  (  (  (  (  \" javah    - classpath    \"     +     ( classpath )  )     +     \"     - o    \"  )     +     ( jniDir . path (  )  )  )     +     \"  /  \"  )     +    className )     +     \"  . h    \"  )     +    className ;", "Process   process    =    Runtime . getRuntime (  )  . exec ( mand )  ;", "process . waitFor (  )  ;", "if    (  ( process . exitValue (  )  )     !  =     0  )     {", "System . out . println (  )  ;", "System . out . println (  (  \" Command :     \"     +    mand )  )  ;", "InputStream   errorStream    =    process . getErrorStream (  )  ;", "int   c    =     0  ;", "while    (  ( c    =    errorStream . read (  )  )     !  =     (  -  1  )  )     {", "System . out . print (  (  ( char )     ( c )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["generateHFile"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "String   className    =    file . path (  )  . replace ( sourceDir . path (  )  ,     \"  \"  )  . replace (  '  \\  \\  '  ,     '  .  '  )  . replace (  '  /  '  ,     '  .  '  )  . replace (  \"  . java \"  ,     \"  \"  )  ;", "if    ( className . startsWith (  \"  .  \"  )  )", "className    =    className . substring (  1  )  ;", "return   className ;", "}", "METHOD_END"], "methodName": ["getFullyQualifiedClassName"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "FileDescriptor [  ]    files    =    dir . list (  )  ;", "for    ( FileDescriptor   file    :    files )     {", "if    ( file . isDirectory (  )  )     {", "if    ( file . path (  )  . contains (  \"  . svn \"  )  )", "continue ;", "if    (  (  ( excludes )     !  =    null )     &  &     ( matcher . match ( file . path (  )  ,    excludes )  )  )", "continue ;", "processDirectory ( file )  ;", "} else    {", "if    ( file . extension (  )  . equals (  \" java \"  )  )     {", "if    ( file . name (  )  . contains (  \"  \"  )  )", "continue ;", "if    (  (  ( includes )     !  =    null )     &  &     (  !  ( matcher . match ( file . path (  )  ,    includes )  )  )  )", "continue ;", "if    (  (  ( excludes )     !  =    null )     &  &     ( matcher . match ( file . path (  )  ,    excludes )  )  )", "continue ;", "String   className    =    getFullyQualifiedClassName ( file )  ;", "FileDescriptor   hFile    =    new   FileDescriptor (  (  (  (  ( jniDir . path (  )  )     +     \"  /  \"  )     +    className )     +     \"  . h \"  )  )  ;", "FileDescriptor   cppFile    =    new   FileDescriptor (  (  (  (  ( jniDir )     +     \"  /  \"  )     +    className )     +     \"  . cpp \"  )  )  ;", "if    (  ( file . lastModified (  )  )     <     ( cppFile . lastModified (  )  )  )     {", "System . out . println (  (  (  \" C / C +  +    for    '  \"     +     ( file . path (  )  )  )     +     \"  '    up   to   date \"  )  )  ;", "continue ;", "}", "String   javaContent    =    file . readString (  )  ;", "if    ( contains (  . JNI _ METHOD _ MARKER )  )     {", "ArrayList < JavaMethodParser . JavaSegment >    javaSegments    =    parse ( javaContent )  ;", "if    (  ( size (  )  )     =  =     0  )     {", "System . out . println (  (  (  \" Skipping    '  \"     +    file )     +     \"  '  ,    no   JNI   code   found .  \"  )  )  ;", "continue ;", "}", "System . out . print (  (  (  \" Generating   C / C +  +    for    '  \"     +    file )     +     \"  '  .  .  .  \"  )  )  ;", "generateHFile ( file )  ;", "generateCppFile ( javaSegments ,    hFile ,    cppFile )  ;", "System . out . println (  \" done \"  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processDirectory"], "fileName": "com.badlogic.gdx.jnigen.NativeCodeGenerator"}, {"methodBody": ["METHOD_START", "{", "ArrayList < CMethodParser . CMethod >    methods    =    new   ArrayList < CMethodParser . CMethod >  (  )  ;", "int   index    =    headerFile . indexOf (  . C _ METHOD _ MARKER )  ;", "if    ( index    =  =     (  -  1  )  )", "return   null ;", "while    ( index    >  =     0  )     {", "CMethodParser . CMethod   method    =    parseCMethod ( headerFile ,    index )  ;", "if    ( method    =  =    null )", "throw   new   RuntimeException (  \" Couldn ' t   parse   method \"  )  ;", "methods . add ( method )  ;", "index    =    headerFile . indexOf (  . C _ METHOD _ MARKER ,    method . endIndex )  ;", "}", "return   new   CMethodParser . CMethodParserResult ( methods )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.jnigen.parsing.JniHeaderCMethodParser"}, {"methodBody": ["METHOD_START", "{", "int   headEnd    =    headerFile . indexOf (  '  (  '  ,    start )  ;", "String   head    =    headerFile . substring ( start ,    headEnd )  . trim (  )  ;", "String   returnType    =    head . split (  \"     \"  )  [  1  ]  . trim (  )  ;", "int   argsStart    =    headEnd    +     1  ;", "int   argsEnd    =    headerFile . indexOf (  '  )  '  ,    argsStart )  ;", "String [  ]    args    =    headerFile . substring ( argsStart ,    argsEnd )  . split (  \"  ,  \"  )  ;", "return   new    . CMethod ( returnType ,    head ,    args ,    start ,     ( argsEnd    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["parseCMethod"], "fileName": "com.badlogic.gdx.jnigen.parsing.JniHeaderCMethodParser"}, {"methodBody": ["METHOD_START", "{", "for    ( JavaMethodParser . JavaMethod   method    :    methods )     {", "for    ( JavaMethodParser . JniSection   section    :    methodBodies )     {", "if    (  ( method . getEndIndex (  )  )     =  =     ( section . getStartIndex (  )  )  )     {", "if    ( section . getNativeCode (  )  . startsWith (  . JNI _ MANUAL )  )     {", "section . setNativeCode ( section . getNativeCode (  )  . substring (  . JNI _ MANUAL . length (  )  )  )  ;", "method . setManual ( true )  ;", "}", "method . setNativeCode ( section . getNativeCode (  )  )  ;", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["alignMethodBodies"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "String   className    =    classStack . peek (  )  . getName (  )  ;", "String   name    =    method . getName (  )  ;", "boolean   isStatic    =    ModifierSet . hasModifier ( method . getModifiers (  )  ,    STATIC )  ;", "String   returnType    =    method . getType (  )  . toString (  )  ;", "ArrayList <  . Argument >    arguments    =    new   ArrayList <  . Argument >  (  )  ;", "if    (  ( method . getParameters (  )  )     !  =    null )     {", "for    ( Parameter   parameter    :    method . getParameters (  )  )     {", "arguments . add ( new    . Argument ( getArgumentType ( parameter )  ,    parameter . getId (  )  . getName (  )  )  )  ;", "}", "}", "return   new    . JavaMethod ( className ,    name ,    isStatic ,    returnType ,    null ,    arguments ,    method . getBeginLine (  )  ,    method . getEndLine (  )  )  ;", "}", "METHOD_END"], "methodName": ["createMethod"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "String [  ]    typeTokens    =    parameter . getType (  )  . toString (  )  . split (  \"  \\  \\  .  \"  )  ;", "String   type    =    typeTokens [  (  ( typeTokens . length )     -     1  )  ]  ;", "int   arrayDim    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( type . length (  )  )  ;    i +  +  )     {", "if    (  ( type . charAt ( i )  )     =  =     '  [  '  )", "arrayDim +  +  ;", "}", "type    =    type . replace (  \"  [  \"  ,     \"  \"  )  . replace (  \"  ]  \"  ,     \"  \"  )  ;", "if    ( arrayDim    >  =     1  )     {", "if    ( arrayDim    >     1  )", "return   JavaMethodParser . ArgumentType . ObjectArray ;", "JavaMethodParser . ArgumentType   arrayType    =     . arrayTypes . get ( type )  ;", "if    ( arrayType    =  =    null )     {", "return   JavaMethodParser . ArgumentType . ObjectArray ;", "}", "return   arrayType ;", "}", "if    (  . plainOldDataTypes . containsKey ( type )  )", "return    . plainOldDataTypes . get ( type )  ;", "if    (  . bufferTypes . containsKey ( type )  )", "return    . bufferTypes . get ( type )  ;", "if    (  . otherTypes . containsKey ( type )  )", "return    . otherTypes . get ( type )  ;", "return   JavaMethodParser . ArgumentType . Object ;", "}", "METHOD_END"], "methodName": ["getArgumentType"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "ArrayList < JavaMethodParser . JniSection >    sections    =    new   ArrayList < JavaMethodParser . JniSection >  (  )  ;", "boolean   inComment    =    false ;", "int   start    =     0  ;", "int   startLine    =     0  ;", "int   line    =     1  ;", "for    ( int   i    =     0  ;    i    <     (  ( classFile . length (  )  )     -     2  )  ;    i +  +  )     {", "char   c 1     =    classFile . charAt ( i )  ;", "char   c 2     =    classFile . charAt (  ( i    +     1  )  )  ;", "char   c 3     =    classFile . charAt (  ( i    +     2  )  )  ;", "if    ( c 1     =  =     '  \\ n '  )", "line +  +  ;", "if    (  ! inComment )     {", "if    (  (  ( c 1     =  =     '  /  '  )     &  &     ( c 2     =  =     '  *  '  )  )     &  &     ( c 3     !  =     '  *  '  )  )     {", "inComment    =    true ;", "start    =    i ;", "startLine    =    line ;", "}", "} else    {", "if    (  ( c 1     =  =     '  *  '  )     &  &     ( c 2     =  =     '  /  '  )  )     {", "sections . add ( new   JavaMethodParser . JniSection ( classFile . substring (  ( start    +     2  )  ,    i )  ,    startLine ,    line )  )  ;", "inComment    =    false ;", "}", "}", "}", "return   sections ;", "}", "METHOD_END"], "methodName": ["getComments"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "classStack . push ( type )  ;", "if    (  ( type . getMembers (  )  )     !  =    null )     {", "for    ( BodyDeclaration   member    :    type . getMembers (  )  )     {", "if    (  ( member   instanceof   ClassOrInterfaceDeclaration )     |  |     ( member   instanceof   EnumDeclaration )  )     {", "ges ( methods ,     (  ( TypeDeclaration )     ( member )  )  )  ;", "} else    {", "if    ( member   instanceof   MethodDeclaration )     {", "MethodDeclaration   method    =     (  ( MethodDeclaration )     ( member )  )  ;", "if    (  !  ( ModifierSet . hasModifier (  (  ( MethodDeclaration )     ( member )  )  . getModifiers (  )  ,    NATIVE )  )  )", "continue ;", "methods . add ( createMethod ( method )  )  ;", "}", "}", "}", "}", "classStack . pop (  )  ;", "}", "METHOD_END"], "methodName": ["getJavaMethods"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "ArrayList < JavaMethodParser . JniSection >    sections    =    getComments ( classFile )  ;", "Iterator < JavaMethodParser . JniSection >    iter    =    sections . iterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "JavaMethodParser . JniSection   section    =    iter . next (  )  ;", "if    (  !  ( section . getNativeCode (  )  . startsWith (  \" JNI \"  )  )  )     {", "iter . remove (  )  ;", "} else    {", "section . setNativeCode ( section . getNativeCode (  )  . substring (  3  )  )  ;", "}", "}", "return   sections ;", "}", "METHOD_END"], "methodName": ["getJniSections"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "ArrayList < JavaMethodParser . JniSection >    sections    =    getComments ( classFile )  ;", "Iterator < JavaMethodParser . JniSection >    iter    =    sections . iterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "JavaMethodParser . JniSection   section    =    iter . next (  )  ;", "if    ( section . getNativeCode (  )  . startsWith (  \" JNI \"  )  )", "iter . remove (  )  ;", "if    ( section . getNativeCode (  )  . startsWith (  \"  -  {  \"  )  )", "iter . remove (  )  ;", "if    (  (  !  (  . CustomIgnoreTag . isEmpty (  )  )  )     &  &     ( section . getNativeCode (  )  . startsWith (  . CustomIgnoreTag )  )  )", "iter . remove (  )  ;", "}", "return   sections ;", "}", "METHOD_END"], "methodName": ["getNativeCodeBodies"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "for    ( TypeDeclaration   type    :    unit . getTypes (  )  )     {", "if    (  ( type   instanceof   ClassOrInterfaceDeclaration )     |  |     ( type   instanceof   EnumDeclaration )  )", "return   type ;", "}", "throw   new   RuntimeException (  \" Couldn ' t   find   class ,    is   your   j   file   empty ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["getOuterClass"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "ArrayList < JavaMethodParser . JavaSegment >    segments    =    new   ArrayList < JavaMethodParser . JavaSegment >  (  )  ;", "segments . addAll ( methods )  ;", "segments . addAll ( sections )  ;", "Collections . sort ( segments ,    new   Comparator < JavaMethodParser . JavaSegment >  (  )     {", "@ Override", "public   int   compare ( JavaMethodParser . JavaSegment   o 1  ,    JavaMethodParser . JavaSegment   o 2  )     {", "return    ( o 1  . getStartIndex (  )  )     -     ( o 2  . getStartIndex (  )  )  ;", "}", "}  )  ;", "return   segments ;", "}", "METHOD_END"], "methodName": ["sortMethodsAndSections"], "fileName": "com.badlogic.gdx.jnigen.parsing.RobustJavaMethodParser"}, {"methodBody": ["METHOD_START", "{", "new   NativeCodeGenerator (  )  . generate (  \" src \"  ,     \" bin \"  ,     \" jni \"  ,    new   String [  ]  {     \"  *  *  / MyJniClass . java \"     }  ,    null )  ;", "BuildConfig   buildConfig    =    new   BuildConfig (  \" test \"  )  ;", "BuildTarget   win 3  2     =    BuildTarget . newDefaultTarget ( BuildTarget . TargetOs . Windows ,    false )  ;", "win 3  2  . compilerPrefix    =     \"  \"  ;", "win 3  2  . cppFlags    +  =     \"     - g \"  ;", "BuildTarget   lin 6  4     =    BuildTarget . newDefaultTarget ( BuildTarget . TargetOs . Linux ,    true )  ;", "new   AntScriptGenerator (  )  . generate ( buildConfig ,    win 3  2  ,    lin 6  4  )  ;", "BuildExecutor . executeAnt (  \" jni / build - linux 6  4  . xml \"  ,     \"  - v    - Dhas - compiler = true   clean   postcompile \"  )  ;", "BuildExecutor . executeAnt (  \" jni / build . xml \"  ,     \"  - v   pack - natives \"  )  ;", "new   JniGenSharedLibraryLoader (  \" libs / test - natives . jar \"  )  . load (  \" test \"  )  ;", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  1  )  ;", "buffer . put (  0  ,     (  ( byte )     (  8  )  )  )  ;", "MyJniClass . test ( true ,     (  ( byte )     (  1  )  )  ,     (  ( char )     (  2  )  )  ,     (  ( short )     (  3  )  )  ,     4  ,     5  ,     6  ,     7  ,    buffer ,    new   boolean [  ]  {    false    }  ,    new   char [  ]  {     9     }  ,    new   short [  ]  {     1  0     }  ,    new   int [  ]  {     1  1     }  ,    new   long [  ]  {     1  2     }  ,    new   float [  ]  {     1  3     }  ,    new   double [  ]  {     1  4     }  ,    null ,     \" Hurray \"  ,    MyJniClass . class ,    new   RuntimeException (  )  ,    new   MyJniClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.jnigen.test.MyJniClass"}]