[{"methodBody": ["METHOD_START", "{", "String   packageName    =    ctx . getPackageName (  )  ;", "Vector < String >    ret    =    new   Vector < String >  (  )  ;", "if    ( Environment . getExternalStorageState (  )  . equals ( MEDIA _ MOUNTED )  )     {", "File   root    =    Environment . getExternalStorageDirectory (  )  ;", "File   expPath    =    new   File (  (  (  ( root . toString (  )  )     +     (  . EXP _ PATH )  )     +    packageName )  )  ;", "if    ( expPath . exists (  )  )     {", "if    ( mainVersion    >     0  )     {", "String   strMainPath    =     (  (  (  (  ( expPath    +     ( File . separator )  )     +     \" main .  \"  )     +    mainVersion )     +     \"  .  \"  )     +    packageName )     +     \"  . obb \"  ;", "File   main    =    new   File ( strMainPath )  ;", "if    ( main . isFile (  )  )     {", "ret . add ( strMainPath )  ;", "}", "}", "if    ( patchVersion    >     0  )     {", "String   strPatchPath    =     (  (  (  (  ( expPath    +     ( File . separator )  )     +     \" patch .  \"  )     +    mainVersion )     +     \"  .  \"  )     +    packageName )     +     \"  . obb \"  ;", "File   main    =    new   File ( strPatchPath )  ;", "if    ( main . isFile (  )  )     {", "ret . add ( strPatchPath )  ;", "}", "}", "}", "}", "String [  ]    retArray    =    new   String [ ret . size (  )  ]  ;", "ret . toArray ( retArray )  ;", "return   retArray ;", "}", "METHOD_END"], "methodName": ["getAPKExpansionFiles"], "fileName": "com.badlogic.gdx.backends.android.APKExpansionSupport"}, {"methodBody": ["METHOD_START", "{", "String [  ]    expansionFiles    =    APKExpansionSupport . getAPKExpansionFiles ( ctx ,    mainVersion ,    patchVersion )  ;", "return   APKExpansionSupport . getResourceZipFile ( expansionFiles )  ;", "}", "METHOD_END"], "methodName": ["getAPKExpansionZipFile"], "fileName": "com.badlogic.gdx.backends.android.APKExpansionSupport"}, {"methodBody": ["METHOD_START", "{", "ZipResourceFile   apkExpansionFile    =    null ;", "for    ( String   expansionFilePath    :    expansionFiles )     {", "if    ( null    =  =    apkExpansionFile )     {", "apkExpansionFile    =    new   ZipResourceFile ( expansionFilePath )  ;", "} else    {", "apkExpansionFile . addPatchFile ( expansionFilePath )  ;", "}", "}", "return   apkExpansionFile ;", "}", "METHOD_END"], "methodName": ["getResourceZipFile"], "fileName": "com.badlogic.gdx.backends.android.APKExpansionSupport"}, {"methodBody": ["METHOD_START", "{", "synchronized ( androidEventListeners )     {", "androidEventListeners . add ( listener )  ;", "}", "}", "METHOD_END"], "methodName": ["addAndroidEventListener"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "FrameLayout . LayoutParams   layoutParams    =    new   FrameLayout . LayoutParams ( LayoutParams . MATCH _ PARENT ,    LayoutParams . MATCH _ PARENT )  ;", "layoutParams . gravity    =    Gravity . CENTER ;", "return   layoutParams ;", "}", "METHOD_END"], "methodName": ["createLayoutParams"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "if    ( use )     {", "getWiow (  )  . addFlags ( FLAG _ KEEP _ SCREEN _ ON )  ;", "}", "}", "METHOD_END"], "methodName": ["createWakeLock"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ! hide )     |  |     (  ( getVersion (  )  )     <     1  1  )  )", "return ;", "View   rootView    =    getWindow (  )  . getDecorView (  )  ;", "try    {", "Method   m    =    View . class . getMethod (  \" setSystemUiVisibility \"  ,    int . class )  ;", "if    (  ( getVersion (  )  )     <  =     1  3  )", "m . invoke ( rootView ,     0  )  ;", "m . invoke ( rootView ,     1  )  ;", "}    catch    ( Exception   e )     {", "log (  \"  \"  ,     \" Can ' t   hide   status   bar \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["hideStatusBar"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . getVersion (  )  )     <     ( AndroidApplicationBase . MINIMUM _ SDK )  )     {", "throw   new   GdxRuntimeException (  (  (  \" LibGDX   requires   Android   API   Level    \"     +     ( AndroidApplicationBase . MINIMUM _ SDK )  )     +     \"    or   later .  \"  )  )  ;", "}", "setApplicationLogger ( new   AndroidApplicationLogger (  )  )  ;", "graphics    =    new   AndroidGraphics ( this ,    config ,     (  ( config . resolutionStrategy )     =  =    null    ?    new   FillResolutionStrategy (  )     :    config . resolutionStrategy )  )  ;", "input    =    AndroidInputFactory . newAndroidInput ( this ,    this ,    graphics . view ,    config )  ;", "audio    =    new   AndroidAudio ( this ,    config )  ;", "this . getFilesDir (  )  ;", "files    =    new   AndroidFiles ( this . getAssets (  )  ,    this . getFilesDir (  )  . getAbsolutePath (  )  )  ;", "net    =    new   AndroidNet ( this )  ;", "this . listener    =    listener ;", "this . handler    =    new   Handler (  )  ;", "this . useImmersiveMode    =    config . useImmersiveMode ;", "this . hideStatusBar    =    config . hideStatusBar ;", "this . clipboard    =    new   AndroidClipboard ( this )  ;", "addLifecycleListener ( new   LifecycleListener (  )     {", "@ Override", "public   void   resume (  )     {", "}", "@ Override", "public   void   pause (  )     {", "audio . pause (  )  ;", "}", "@ Override", "public   void   dispose (  )     {", "audio . dispose (  )  ;", "}", "}  )  ;", "Gdx . app    =    this ;", "Gdx . input    =    this . getInput (  )  ;", "Gdx . audio    =    this . getAudio (  )  ;", "Gdx . files    =    this . getFiles (  )  ;", "Gdx . graphics    =    this . getGraphics (  )  ;", "Gdx . net    =    this . getNet (  )  ;", "if    (  ! isForView )     {", "try    {", "requestWindowFeature ( FEATURE _ NO _ TITLE )  ;", "}    catch    ( Exception   ex )     {", "log (  \" AndroidApplication \"  ,     \" Content   already   displayed ,    cannot   request   FEATURE _ NO _ TITLE \"  ,    ex )  ;", "}", "getWindow (  )  . setFlags ( FLAG _ FULLSCREEN ,    FLAG _ FULLSCREEN )  ;", "getWindow (  )  . clearFlags ( FLAG _ FORCE _ NOT _ FULLSCREEN )  ;", "setContentView ( graphics . getView (  )  ,    createLayoutParams (  )  )  ;", "}", "createWakeLock ( config . useWakelock )  ;", "hideStatusBar ( this . hideStatusBar )  ;", "useImmersiveMode ( this . useImmersiveMode )  ;", "if    (  ( this . useImmersiveMode )     &  &     (  ( getVersion (  )  )     >  =     ( VERSION _ CODES . KITKAT )  )  )     {", "try    {", "Class <  ?  >    vlistener    =    Class . forName (  \" VisibilityListener \"  )  ;", "Object   o    =    vlistener . newInstance (  )  ;", "Method   method    =    vlistener . getDeclaredMethod (  \" createListener \"  ,    AndroidApplicationBase . class )  ;", "method . invoke ( o ,    this )  ;", "}    catch    ( Exception   e )     {", "log (  \" AndroidApplication \"  ,     \" Failed   to   create   AndroidVisibilityListener \"  ,    e )  ;", "}", "}", "if    (  ( getResources (  )  . getConfiguration (  )  . keyboard )     !  =     ( Configuration . KEYBOARD _ NOKEYS )  )", "this . getInput (  )  . keyboardAvailable    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "AndroidApplicationConfiguration   config    =    new   AndroidApplicationConfiguration (  )  ;", "initialize ( listener ,    config )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "init ( listener ,    config ,    false )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "AndroidApplicationConfiguration   config    =    new   AndroidApplicationConfiguration (  )  ;", "return   initializeForView ( listener ,    config )  ;", "}", "METHOD_END"], "methodName": ["initializeForView"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "init ( listener ,    config ,    true )  ;", "return   graphics . getView (  )  ;", "}", "METHOD_END"], "methodName": ["initializeForView"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "synchronized ( androidEventListeners )     {", "androidEventListeners . removeValue ( listener ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["removeAndroidEventListener"], "fileName": "com.badlogic.gdx.backends.android.AndroidApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  ( soundPool )     =  =    null )     {", "return ;", "}", "synchronized ( musics )     {", "ArrayList < Music >    musicsCopy    =    new   ArrayList < Music >  ( musics )  ;", "for    ( Music   music    :    musicsCopy )     {", "music . dispose (  )  ;", "}", "}", "soundPool . release (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.android.AndroidAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  ( soundPool )     =  =    null )     {", "throw   new   GdxRuntimeException (  \"    audio   is   not   enabled   by   the   application   config .  \"  )  ;", "}", "MediaPlayer   mediaPlayer    =    new   MediaPlayer (  )  ;", "try    {", "mediaPlayer . setDataSource ( fd )  ;", "mediaPlayer . prepare (  )  ;", "Music   music    =    new   Music ( this ,    mediaPlayer )  ;", "synchronized ( musics )     {", "musics . add ( music )  ;", "}", "return   music ;", "}    catch    ( Exception   ex )     {", "throw   new   GdxRuntimeException (  \" Error   loading   audio   from   FileDescriptor \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newMusic"], "fileName": "com.badlogic.gdx.backends.android.AndroidAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  ( soundPool )     =  =    null )     {", "return ;", "}", "synchronized ( musics )     {", "for    ( Music   music    :    musics )     {", "if    ( music . isPlaying (  )  )     {", "music . pause (  )  ;", "music . wasPlaying    =    true ;", "} else", "music . wasPlaying    =    false ;", "}", "}", "this . soundPool . autoPause (  )  ;", "}", "METHOD_END"], "methodName": ["pause"], "fileName": "com.badlogic.gdx.backends.android.AndroidAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  ( soundPool )     =  =    null )     {", "return ;", "}", "synchronized ( musics )     {", "for    ( int   i    =     0  ;    i    <     ( musics . size (  )  )  ;    i +  +  )     {", "if    ( musics . get ( i )  . wasPlaying )", "musics . get ( i )  . play (  )  ;", "}", "}", "this . soundPool . autoResume (  )  ;", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "com.badlogic.gdx.backends.android.AndroidAudio"}, {"methodBody": ["METHOD_START", "{", "FrameLayout . LayoutParams   layoutParams    =    new   FrameLayout . LayoutParams ( LayoutParams . MATCH _ PARENT ,    LayoutParams . MATCH _ PARENT )  ;", "layoutParams . gravity    =    Gravity . CENTER ;", "return   layoutParams ;", "}", "METHOD_END"], "methodName": ["createLayoutParams"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "if    ( use )     {", "getWindow (  )  . dFlags ( FLAG _ KEEP _ SCREEN _ ON )  ;", "}", "}", "METHOD_END"], "methodName": ["createWakeLock"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( config . hideStatusBar )  )     |  |     (  ( getVersion (  )  )     <     1  1  )  )", "return ;", "View   rootView    =    getWindow (  )  . getDecorView (  )  ;", "try    {", "Method   m    =    View . class . getMethod (  \" setSystemUiVisibility \"  ,    int . class )  ;", "m . invoke ( rootView ,     0  )  ;", "m . invoke ( rootView ,     1  )  ;", "}    catch    ( Exception   e )     {", "log (  \" Application \"  ,     \" Can ' t   hide   status   bar \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["hideStatusBar"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "setApplicationLogger ( new   AndroidApplicationLogger (  )  )  ;", "graphics    =    new   AndroidGraphics ( this ,    config ,     (  ( config . resolutionStrategy )     =  =    null    ?    new   FillResolutionStrategy (  )     :    config . resolutionStrategy )  )  ;", "input    =    AndroidInputFactory . newAndroidInput ( this ,    this ,    graphics . view ,    config )  ;", "audio    =    new   AndroidAudio ( this ,    config )  ;", "this . getFilesDir (  )  ;", "files    =    new   AndroidFiles ( this . getAssets (  )  ,    this . getFilesDir (  )  . getAbsolutePath (  )  )  ;", "net    =    new   AndroidNet ( this )  ;", "this . listener    =    listener ;", "this . handler    =    new   Handler (  )  ;", "this . clipboard    =    new   AndroidClipboard ( this )  ;", "addLifecycleListener ( new   LifecycleListener (  )     {", "@ Override", "public   void   resume (  )     {", "audio . resume (  )  ;", "}", "@ Override", "public   void   pause (  )     {", "audio . pause (  )  ;", "}", "@ Override", "public   void   dispose (  )     {", "audio . dispose (  )  ;", "audio    =    null ;", "}", "}  )  ;", "Gdx . app    =    this ;", "Gdx . input    =    this . getInput (  )  ;", "Gdx . audio    =    this . getAudio (  )  ;", "Gdx . files    =    this . getFiles (  )  ;", "Gdx . graphics    =    this . getGraphics (  )  ;", "Gdx . net    =    this . getNet (  )  ;", "if    (  ! isForView )     {", "setFullscreen ( true )  ;", "setContentView ( graphics . getView (  )  ,    createLayoutParams (  )  )  ;", "}", "createWakeLock ( config . useWakelock )  ;", "hideStatusBar ( config )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "AndroidApplicationConfiguration   config    =    new   AndroidApplicationConfiguration (  )  ;", "initialize ( listener ,    config )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "init ( listener ,    config ,    false )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "AndroidApplicationConfiguration   config    =    new   AndroidApplicationConfiguration (  )  ;", "return   initializeForView ( listener ,    config )  ;", "}", "METHOD_END"], "methodName": ["initializeForView"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "init ( listener ,    config ,    true )  ;", "return   graphics . getView (  )  ;", "}", "METHOD_END"], "methodName": ["initializeForView"], "fileName": "com.badlogic.gdx.backends.android.AndroidDaydream"}, {"methodBody": ["METHOD_START", "{", "name    =    name . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "return   new    ( assets ,    new   File ( name )  ,    type )  ;", "return   new    ( assets ,    new   File ( file ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "String   fileName    =    file . getPath (  )  ;", "try    {", "assets . open ( fileName )  . close (  )  ;", "return   true ;", "}    catch    ( Exception   ex )     {", "try    {", "return    ( assets . list ( fileName )  . length )     >     0  ;", "}    catch    ( Exception   ignored )     {", "}", "return   false ;", "}", "}", "return   super . exists (  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Local )  )", "return   new   File ( Gdx . files . getLocalStoragePath (  )  ,    file . getPath (  )  )  ;", "return   super . file (  )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "return    ( assets )     !  =    null    ?    assets . openFd ( path (  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getAssetFileDescriptor"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "try    {", "return    ( assets . list ( file . getPath (  )  )  . length )     >     0  ;", "}    catch    ( IOException   ex )     {", "return   false ;", "}", "}", "return   super . isDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   super . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "AssetFileDescriptor   fileDescriptor    =    null ;", "try    {", "fileDescriptor    =    assets . openFd ( file . getPath (  )  )  ;", "return   fileDescriptor . getLength (  )  ;", "}    catch    ( IOException   ignored )     {", "}    finally    {", "if    ( fileDescriptor    !  =    null )     {", "try    {", "fileDescriptor . close (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "}", "}", "return   super . length (  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "try    {", "String [  ]    relativePaths    =    assets . list ( file . getPath (  )  )  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "for    ( int   i    =     0  ,    n    =    handles . length ;    i    <    n ;    i +  +  )", "handles [ i ]     =    new    ( assets ,    new   File ( file ,    relativePaths [ i ]  )  ,    type )  ;", "return   handles ;", "}    catch    ( Exception   ex )     {", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  (  (  (  \" Error   listing   children :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "return   super . list (  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "try    {", "String [  ]    relativePaths    =    assets . list ( file . getPath (  )  )  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    handles . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "FileHandle   child    =    new    ( assets ,    new   File ( file ,    path )  ,    type )  ;", "if    (  !  ( filter . accept ( child . file (  )  )  )  )", "continue ;", "handles [ count ]     =    child ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileHandle [  ]    newHandles    =    new   FileHandle [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}    catch    ( Exception   ex )     {", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  (  (  (  \" Error   listing   children :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "return   super . list ( filter )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "try    {", "String [  ]    relativePaths    =    assets . list ( file . getPath (  )  )  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    handles . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "if    (  !  ( filter . accept ( file ,    path )  )  )", "continue ;", "handles [ count ]     =    new    ( assets ,    new   File ( file ,    path )  ,    type )  ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileHandle [  ]    newHandles    =    new   FileHandle [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}    catch    ( Exception   ex )     {", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  (  (  (  \" Error   listing   children :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "return   super . list ( filter )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "try    {", "String [  ]    relativePaths    =    assets . list ( file . getPath (  )  )  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    handles . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "if    (  !  ( path . endsWith ( suffix )  )  )", "continue ;", "handles [ count ]     =    new    ( assets ,    new   File ( file ,    path )  ,    type )  ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileHandle [  ]    newHandles    =    new   FileHandle [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}    catch    ( Exception   ex )     {", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  (  (  (  \" Error   listing   children :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "return   super . list ( suffix )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "File   parent    =    file . getParentFile (  )  ;", "if    ( parent    =  =    null )     {", "if    (  ( type )     =  =     ( FileType . Absolute )  )", "parent    =    new   File (  \"  /  \"  )  ;", "else", "parent    =    new   File (  \"  \"  )  ;", "}", "return   new    ( assets ,    parent ,    type )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Internal )  )     {", "try    {", "return   assets . open ( file . getPath (  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   reading   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "return   super . read (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "name    =    name . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" Cannot   get   the   sibling   of   the   root .  \"  )  ;", "return   files . getFileHandle ( new   File ( file . getParent (  )  ,    name )  . getPath (  )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["sibling"], "fileName": "com.badlogic.gdx.backends.android.AndroidFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   expansionFile ;", "}", "METHOD_END"], "methodName": ["getExpansionFile"], "fileName": "com.badlogic.gdx.backends.android.AndroidFiles"}, {"methodBody": ["METHOD_START", "{", "try    {", "assets . open ( path )  . close (  )  ;", "return   handle ;", "}    catch    ( Exception   ex )     {", "FileHandle   zipHandle    =    new   ZipFileHandle ( path )  ;", "if    (  !  ( zipHandle . isDirectory (  )  )  )", "return   zipHandle ;", "else", "if    ( zipHandle . exists (  )  )", "return   zipHandle ;", "}", "return   handle ;", "}", "METHOD_END"], "methodName": ["getZipFileHandleIfExists"], "fileName": "com.badlogic.gdx.backends.android.AndroidFiles"}, {"methodBody": ["METHOD_START", "{", "try    {", "Context   context ;", "if    (  ( Gdx . app )    instanceof   Activity )     {", "context    =     (  ( Activity )     ( app )  )  . getBaseContext (  )  ;", "} else", "if    (  ( Gdx . app )    instanceof   app . Fragment )     {", "context    =     (  ( app . Fragment )     ( app )  )  . getActivity (  )  . getBaseContext (  )  ;", "} else    {", "throw   new   GdxRuntimeException (  \" APK   expansion   not   supported   for   application   type \"  )  ;", "}", "expansionFile    =    APKExpansionSupport . getAPKExpansionZipFile ( context ,    mainVersion ,    patchVersion )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" APK   expansion   main   version    \"     +    mainVersion )     +     \"    or   patch   version    \"  )     +    patchVersion )     +     \"    couldn ' t   be   opened !  \"  )  )  ;", "}", "return    ( expansionFile )     !  =    null ;", "}", "METHOD_END"], "methodName": ["setAPKExpansion"], "fileName": "com.badlogic.gdx.backends.android.AndroidFiles"}, {"methodBody": ["METHOD_START", "{", "synchronized ( androidEventListeners )     {", "androidEventListeners . add ( listener )  ;", "}", "}", "METHOD_END"], "methodName": ["addAndroidEventListener"], "fileName": "com.badlogic.gdx.backends.android.AndroidFragmentApplication"}, {"methodBody": ["METHOD_START", "{", "FrameLayout . LayoutParams   layoutParams    =    new   FrameLayout . LayoutParams ( LayoutParams . MATCH _ PARENT ,    LayoutParams . MATCH _ PARENT )  ;", "layoutParams . gravity    =    Gravity . CENTER ;", "return   layoutParams ;", "}", "METHOD_END"], "methodName": ["createLayoutParams"], "fileName": "com.badlogic.gdx.backends.android.AndroidFragmentApplication"}, {"methodBody": ["METHOD_START", "{", "if    ( use )     {", "getActivity (  )  . getWindow (  )  . dFlags ( FLAG _ KEEP _ SCREEN _ ON )  ;", "}", "}", "METHOD_END"], "methodName": ["createWakeLock"], "fileName": "com.badlogic.gdx.backends.android.AndroidFragmentApplication"}, {"methodBody": ["METHOD_START", "{", "AndroidApplicationConfiguration   config    =    new   AndroidApplicationConfiguration (  )  ;", "return   initializeForView ( listener ,    config )  ;", "}", "METHOD_END"], "methodName": ["initializeForView"], "fileName": "com.badlogic.gdx.backends.android.AndroidFragmentApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . getVersion (  )  )     <     ( AndroidApplicationBase . MINIMUM _ SDK )  )     {", "throw   new   GdxRuntimeException (  (  (  \" LibGDX   requires   Android   API   Level    \"     +     ( AndroidApplicationBase . MINIMUM _ SDK )  )     +     \"    or   later .  \"  )  )  ;", "}", "setApplicationLogger ( new   AndroidApplicationLogger (  )  )  ;", "graphics    =    new   AndroidGraphics ( this ,    config ,     (  ( config . resolutionStrategy )     =  =    null    ?    new   FillResolutionStrategy (  )     :    config . resolutionStrategy )  )  ;", "input    =    AndroidInputFactory . newAndroidInput ( this ,    getActivity (  )  ,    graphics . view ,    config )  ;", "audio    =    new   AndroidAudio ( getActivity (  )  ,    config )  ;", "files    =    new   AndroidFiles ( getResources (  )  . getAssets (  )  ,    getActivity (  )  . getFilesDir (  )  . getAbsolutePath (  )  )  ;", "net    =    new   AndroidNet ( this )  ;", "this . listener    =    listener ;", "this . handler    =    new   Handler (  )  ;", "this . clipboard    =    new   AndroidClipboard ( getActivity (  )  )  ;", "addLifecycleListener ( new   LifecycleListener (  )     {", "@ Override", "public   void   resume (  )     {", "audio . resume (  )  ;", "}", "@ Override", "public   void   pause (  )     {", "audio . pause (  )  ;", "}", "@ Override", "public   void   dispose (  )     {", "audio . dispose (  )  ;", "}", "}  )  ;", "Gdx . app    =    this ;", "Gdx . input    =    this . getInput (  )  ;", "Gdx . audio    =    this . getAudio (  )  ;", "Gdx . files    =    this . getFiles (  )  ;", "Gdx . graphics    =    this . getGraphics (  )  ;", "Gdx . net    =    this . getNet (  )  ;", "createWakeLock ( config . useWakelock )  ;", "useImmersiveMode ( config . useImmersiveMode )  ;", "if    (  ( config . useImmersiveMode )     &  &     (  ( getVersion (  )  )     >  =     ( VERSION _ CODES . KITKAT )  )  )     {", "try    {", "Class <  ?  >    vlistener    =    Class . forName (  \" VisibilityListener \"  )  ;", "Object   o    =    vlistener . newInstance (  )  ;", "Method   method    =    vlistener . getDeclaredMethod (  \" createListener \"  ,    AndroidApplicationBase . class )  ;", "method . invoke ( o ,    this )  ;", "}    catch    ( Exception   e )     {", "log (  \" AndroidApplication \"  ,     \" Failed   to   create   AndroidVisibilityListener \"  ,    e )  ;", "}", "}", "return   graphics . getView (  )  ;", "}", "METHOD_END"], "methodName": ["initializeForView"], "fileName": "com.badlogic.gdx.backends.android.AndroidFragmentApplication"}, {"methodBody": ["METHOD_START", "{", "Fragment   fragment    =    getParentFragment (  )  ;", "while    ( fragment    !  =    null )     {", "if    ( fragment . isRemoving (  )  )", "return   true ;", "fragment    =    fragment . getParentFragment (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAnyParentFragmentRemoving"], "fileName": "com.badlogic.gdx.backends.android.AndroidFragmentApplication"}, {"methodBody": ["METHOD_START", "{", "synchronized ( androidEventListeners )     {", "androidEventListeners . removeValue ( listener ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["removeAndroidEventListener"], "fileName": "com.badlogic.gdx.backends.android.AndroidFragmentApplication"}, {"methodBody": ["METHOD_START", "{", "EGL 1  0    egl    =     (  ( EGL 1  0  )     ( EGLContext . getEGL (  )  )  )  ;", "EGLDisplay   display    =    egl . eglGetDisplay ( EGL _ DEFAULT _ DISPLAY )  ;", "int [  ]    version    =    new   int [  2  ]  ;", "egl . eglInitialize ( display ,    version )  ;", "int   EGL _ OPENGL _ ES 2  _ BIT    =     4  ;", "int [  ]    configAttribs    =    new   int [  ]  {    EGL 1  0  . EGL _ RED _ SIZE ,     4  ,    EGL 1  0  . EGL _ GREEN _ SIZE ,     4  ,    EGL 1  0  . EGL _ BLUE _ SIZE ,     4  ,    EGL 1  0  . EGL _ RENDERABLE _ TYPE ,    EGL _ OPENGL _ ES 2  _ BIT ,    EGL 1  0  . EGL _ NONE    }  ;", "EGLConfig [  ]    configs    =    new   EGLConfig [  1  0  ]  ;", "int [  ]    num _ config    =    new   int [  1  ]  ;", "egl . eglChooseConfig ( display ,    configAttribs ,    configs ,     1  0  ,    num _ config )  ;", "egl . eglTerminate ( display )  ;", "return    ( num _ config [  0  ]  )     >     0  ;", "}", "METHOD_END"], "methodName": ["checkGL20"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "Mesh . clearAllMeshes ( app )  ;", "Texture . clearAllTextures ( app )  ;", "Cubemap . clearAllCubemaps ( app )  ;", "TextureArray . clearAllTextureArrays ( app )  ;", "ShaderProgram . clearAllShaderPrograms ( app )  ;", "FrameBuffer . clearAllFrameBuffers ( app )  ;", "ManagedCachesStatus (  )  ;", "}", "METHOD_END"], "methodName": ["clearManagedCaches"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( checkGL 2  0  (  )  )  )", "throw   new   utils . GdxRuntimeException (  \" Libgdx   requires   OpenGL   ES    2  .  0  \"  )  ;", "EGLConfigChooser   configChooser    =    getEglConfigChooser (  )  ;", "int   sdkVersion    =    VERSION . SDK _ INT ;", "if    (  ( sdkVersion    <  =     1  0  )     &  &     ( config . useGLSurfaceView 2  0 API 1  8  )  )     {", "GLSurfaceView 2  0 API 1  8    view    =    new   GLSurfaceView 2  0 API 1  8  ( application . getContext (  )  ,    resolutionStrategy )  ;", "if    ( configChooser    !  =    null )", "view . setEGLConfigChooser ( configChooser )  ;", "else", "view . setEGLConfigChooser ( config . r ,    config . g ,    config . b ,    config . a ,    config . depth ,    config . stencil )  ;", "view . setRenderer ( this )  ;", "return   view ;", "} else    {", "GLSurfaceView 2  0    view    =    new   GLSurfaceView 2  0  ( application . getContext (  )  ,    resolutionStrategy ,     ( config . useGL 3  0     ?     3     :     2  )  )  ;", "if    ( configChooser    !  =    null )", "view . setEGLConfigChooser ( configChooser )  ;", "else", "view . setEGLConfigChooser ( config . r ,    config . g ,    config . b ,    config . a ,    config . depth ,    config . stencil )  ;", "view . setRenderer ( this )  ;", "return   view ;", "}", "}", "METHOD_END"], "methodName": ["createGLSurfaceView"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "synchronized ( synch )     {", "running    =    false ;", "destroy    =    true ;", "while    ( destroy )     {", "try    {", "synch . wait (  )  ;", "}    catch    ( InterruptedException   ex )     {", "app . log (  . LOG _ TAG ,     \" waiting   for   destroy   synchronization   failed !  \"  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "if    ( egl . eglGetConfigAttrib ( display ,    config ,    attrib ,    value )  )     {", "return   value [  0  ]  ;", "}", "return   defValue ;", "}", "METHOD_END"], "methodName": ["getAttrib"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "return   new   GdxEglConfigChooser ( config . r ,    config . g ,    config . b ,    config . a ,    config . depth ,    config . stencil ,    config . numSamples )  ;", "}", "METHOD_END"], "methodName": ["getEglConfigChooser"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "return   view ;", "}", "METHOD_END"], "methodName": ["getView"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "EGL 1  0    egl    =     (  ( EGL 1  0  )     ( EGLContext . getEGL (  )  )  )  ;", "EGLDisplay   display    =    egl . eglGetDisplay ( EGL _ DEFAULT _ DISPLAY )  ;", "int   r    =    getAttrib ( egl ,    display ,    config ,    EGL _ RED _ SIZE ,     0  )  ;", "int   g    =    getAttrib ( egl ,    display ,    config ,    EGL _ GREEN _ SIZE ,     0  )  ;", "int   b    =    getAttrib ( egl ,    display ,    config ,    EGL _ BLUE _ SIZE ,     0  )  ;", "int   a    =    getAttrib ( egl ,    display ,    config ,    EGL _ ALPHA _ SIZE ,     0  )  ;", "int   d    =    getAttrib ( egl ,    display ,    config ,    EGL _ DEPTH _ SIZE ,     0  )  ;", "int   s    =    getAttrib ( egl ,    display ,    config ,    EGL _ STENCIL _ SIZE ,     0  )  ;", "int   samples    =    Math . max ( getAttrib ( egl ,    display ,    config ,    EGL _ SAMPLES ,     0  )  ,    getAttrib ( egl ,    display ,    config ,    GdxEglConfigChooser . EGL _ COVERAGE _ SAMPLES _ NV ,     0  )  )  ;", "boolean   coverageSample    =     ( getAttrib ( egl ,    display ,    config ,    GdxEglConfigChooser . EGL _ COVERAGE _ SAMPLES _ NV ,     0  )  )     !  =     0  ;", "app . log (  . LOG _ TAG ,     (  (  (  (  (  (  (  (  \" framebuffer :     (  \"     +    r )     +     \"  ,     \"  )     +    g )     +     \"  ,     \"  )     +    b )     +     \"  ,     \"  )     +    a )     +     \"  )  \"  )  )  ;", "app . log (  . LOG _ TAG ,     (  (  \" depthbuffer :     (  \"     +    d )     +     \"  )  \"  )  )  ;", "app . log (  . LOG _ TAG ,     (  (  \" stencilbuffer :     (  \"     +    s )     +     \"  )  \"  )  )  ;", "app . log (  . LOG _ TAG ,     (  (  \" samples :     (  \"     +    samples )     +     \"  )  \"  )  )  ;", "app . log (  . LOG _ TAG ,     (  (  \" coverage   sampling :     (  \"     +    coverageSample )     +     \"  )  \"  )  )  ;", "bufferFormat    =    new   BufferFormat ( r ,    g ,    b ,    a ,    d ,    s ,    samples ,    coverageSample )  ;", "}", "METHOD_END"], "methodName": ["logConfig"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "app . log ( AndroidGraphics . LOG _ TAG ,    Mesh . getManagedStatus (  )  )  ;", "app . log ( AndroidGraphics . LOG _ TAG ,    Texture . getManagedStatus (  )  )  ;", "app . log ( AndroidGraphics . LOG _ TAG ,    Cubemap . getManagedStatus (  )  )  ;", "app . log ( AndroidGraphics . LOG _ TAG ,    ShaderProgram . getManagedStatus (  )  )  ;", "app . log ( AndroidGraphics . LOG _ TAG ,    FrameBuffer . getManagedStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["logManagedCachesStatus"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "if    (  ( view )     !  =    null )     {", "if    (  ( view )    instanceof   GLSurfeViewAPI 1  8  )", "(  ( GLSurfeViewAPI 1  8  )     ( view )  )  . onPause (  )  ;", "if    (  ( view )    instanceof   GLSurfeView )", "(  ( GLSurfeView )     ( view )  )  . onPause (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onPauseGLSurfaceView"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "if    (  ( view )     !  =    null )     {", "if    (  ( view )    instanceof   GLSurfeViewAPI 1  8  )", "(  ( GLSurfeViewAPI 1  8  )     ( view )  )  . onResume (  )  ;", "if    (  ( view )    instanceof   GLSurfeView )", "(  ( GLSurfeView )     ( view )  )  . onResume (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onResumeGLSurfaceView"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "synchronized ( synch )     {", "if    (  !  ( running )  )", "return ;", "running    =    false ;", "pause    =    true ;", "while    ( pause )     {", "try    {", "synch . wait (  4  0  0  0  )  ;", "if    ( pause )     {", "app . error (  . LOG _ TAG ,     \" waiting   for   pause   synchronization   took   too   long ;    assuming   deadlock   and   killing \"  )  ;", "Process . killProcess ( Process . myPid (  )  )  ;", "}", "}    catch    ( InterruptedException   ignored )     {", "app . log (  . LOG _ TAG ,     \" waiting   for   pause   synchronization   failed !  \"  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["pause"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "int   sdkVersion    =    VERSION . SDK _ INT ;", "if    (  (  ( sdkVersion    >  =     1  1  )     &  &     (  ( view )    instanceof   GLSurfaceView 2  0  )  )     |  |     (  ( view )    instanceof   GLSurfaceView 2  0 API 1  8  )  )     {", "try    {", "view . getClass (  )  . getMethod (  \" setPreserveEGLContextOnPause \"  ,    boolean . class )  . invoke ( view ,    true )  ;", "}    catch    ( Exception   e )     {", "app . log (  . LOG _ TAG ,     \" Method   GLSurfaceView . setPreserveEGLContextOnPause   not   found \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["preserveEGLContextOnPause"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "synchronized ( synch )     {", "running    =    true ;", "resume    =    true ;", "}", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "String   versionString    =    gl . glGetString ( GL _ VERSION )  ;", "String   vendorString    =    gl . glGetString ( GL _ VENDOR )  ;", "String   rendererString    =    gl . glGetString ( GL _ RENDERER )  ;", "glVersion    =    new   graphics . glutils . GLVersion ( ApplicationType . Android ,    versionString ,    vendorString ,    rendererString )  ;", "if    (  ( config . useGL 3  0  )     &  &     (  ( glVersion . getMajorVersion (  )  )     >     2  )  )     {", "if    (  ( gl 3  0  )     !  =    null )", "return ;", "gl 2  0     =    gl 3  0     =    new   AndroidGL 3  0  (  )  ;", "Gdx . gl    =    gl 3  0  ;", "Gdx . gl 2  0     =    gl 3  0  ;", "Gdx . gl 3  0     =    gl 3  0  ;", "} else    {", "if    (  ( gl 2  0  )     !  =    null )", "return ;", "gl 2  0     =    new   AndroidGL 2  0  (  )  ;", "Gdx . gl    =    gl 2  0  ;", "Gdx . gl 2  0     =    gl 2  0  ;", "}", "app . log ( AndroidGraphics . LOG _ TAG ,     (  \" OGL   renderer :     \"     +     ( gl . glGetString ( GL _ RENDERER )  )  )  )  ;", "app . log ( AndroidGraphics . LOG _ TAG ,     (  \" OGL   vendor :     \"     +     ( gl . glGetString ( GL _ VENDOR )  )  )  )  ;", "app . log ( AndroidGraphics . LOG _ TAG ,     (  \" OGL   version :     \"     +     ( gl . glGetString ( GL _ VERSION )  )  )  )  ;", "app . log ( AndroidGraphics . LOG _ TAG ,     (  \" OGL   extensions :     \"     +     ( gl . glGetString ( GL _ EXTENSIONS )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setupGL"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "DisplayMetrics   metrics    =    new   DisplayMetrics (  )  ;", "app . getWindowManager (  )  . getDefaultDisplay (  )  . getMetrics ( metrics )  ;", "ppiX    =    metrics . xdpi ;", "ppiY    =    metrics . ydpi ;", "ppcX    =     ( metrics . xdpi )     /     2  .  5  4 F ;", "ppcY    =     ( metrics . ydpi )     /     2  .  5  4 F ;", "density    =    metrics . density ;", "}", "METHOD_END"], "methodName": ["updatePpi"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphics"}, {"methodBody": ["METHOD_START", "{", "synchronized (  (  ( AndroidLiveWallpaper )     ( app )  )  . service . sync )     {", "return    (  ( AndroidLiveWallpaper )     ( app )  )  . service . getSurfaceHolder (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSurfaceHolder"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( view )     !  =    null )     {", "if    (  (  ( view )    instanceof   GLSurfaceView )     |  |     (  ( view )    instanceof   GLSurfaceViewAPI 1  8  )  )     {", "try    {", "view . getClass (  )  . getMethod (  \" onDestroy \"  )  . invoke ( view )  ;", "if    ( AndroidService . DEBUG )", "Log . d ( AndroidService . TAG ,     \"     >    Android    -    onDestroy (  )    stopped   GLThread   managed   by   GLSurfaceView \"  )  ;", "}    catch    ( Throwable   t )     {", "Log . e ( AndroidService . TAG ,     \" failed   to   destroy   GLSurfaceView ' s   thread !    GLSurfaceView . onDetachedFromWindow   impl   changed   since   API   lvl    1  6  !  \"  )  ;", "t . printStackTrace (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["onDestroyGLSurfaceView"], "fileName": "com.badlogic.gdx.backends.android.AndroidGraphicsLiveWallpaper"}, {"methodBody": ["METHOD_START", "{", "keyListeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addKeyListener"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "int   len    =    realId . length ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "if    (  ( realId [ i ]  )     =  =     (  -  1  )  )", "return   i ;", "}", "realId    =    resize ( realId )  ;", "touchX    =    resize ( touchX )  ;", "touchY    =    resize ( touchY )  ;", "deltaX    =    resize ( deltaX )  ;", "deltaY    =    resize ( deltaY )  ;", "touched    =    resize ( touched )  ;", "button    =    resize ( button )  ;", "return   len ;", "}", "METHOD_END"], "methodName": ["getFreePointerIndex"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "if    ( rotationVectorAvailable )", "hardware . SensorManager . getRotationMatrixFromVector ( matrix ,    rotationVectorValues )  ;", "else", "hardware . SensorManager . getRotationMatrix ( matrix ,    null ,    accelerometerValues ,    magneticFieldValues )  ;", "}", "METHOD_END"], "methodName": ["getRotationMatrix"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "return   touched [ pointer ]  ;", "}", "}", "METHOD_END"], "methodName": ["isTouched"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "int   len    =    realId . length ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "if    (  ( realId [ i ]  )     =  =    pointerId )", "return   i ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "sb . append (  (  (  ( i    +     \"  :  \"  )     +     ( realId [ i ]  )  )     +     \"     \"  )  )  ;", "}", "app . log (  \"  \"  ,     (  (  (  \" Pointer   ID   lookup   failed :     \"     +    pointerId )     +     \"  ,     \"  )     +     ( sb . toString (  )  )  )  )  ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lookUpPointerIndex"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "postTap ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["onDrop"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "unregisterSensorListeners (  )  ;", "Arrays . fill ( realId ,     (  -  1  )  )  ;", "Arrays . fill ( touched ,    false )  ;", "}", "METHOD_END"], "methodName": ["onPause"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "registerSensorListeners (  )  ;", "}", "METHOD_END"], "methodName": ["onResume"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "postTap ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["onTap"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", ". TouchEvent   event    =    usedTouchEvents . obtain (  )  ;", "event . timeStamp    =    System . nanoTime (  )  ;", "event . pointer    =     0  ;", "event . x    =    x ;", "event . y    =    y ;", "event . type    =     . TouchEvent . TOUCH _ DOWN ;", "touchEvents . add ( event )  ;", "event    =    usedTouchEvents . obtain (  )  ;", "event . timeStamp    =    System . nanoTime (  )  ;", "event . pointer    =     0  ;", "event . x    =    x ;", "event . y    =    y ;", "event . type    =     . TouchEvent . TOUCH _ UP ;", "touchEvents . add ( event )  ;", "}", "app . getGraphics (  )  . requestRendering (  )  ;", "}", "METHOD_END"], "methodName": ["postTap"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "justTouched    =    false ;", "if    ( keyJustPressed )     {", "keyJustPressed    =    false ;", "for    ( int   i    =     0  ;    i    <     ( justPressedKeys . length )  ;    i +  +  )     {", "justPressedKeys [ i ]     =    false ;", "}", "}", "if    (  ( processor )     !  =    null )     {", "final   InputProcessor   processor    =    this . processor ;", "int   len    =    keyEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". KeyEvent   e    =    keyEvents . get ( i )  ;", "currentEventTimeStamp    =    e . timeStamp ;", "switch    ( e . type )     {", "case    . KeyEvent . KEY _ DOWN    :", "processor . keyDown ( e . keyCode )  ;", "keyJustPressed    =    true ;", "justPressedKeys [ e . keyCode ]     =    true ;", "break ;", "case    . KeyEvent . KEY _ UP    :", "processor . keyUp ( e . keyCode )  ;", "break ;", "case    . KeyEvent . KEY _ TYPED    :", "processor . keyTyped ( e . keyChar )  ;", "}", "usedKeyEvents . free ( e )  ;", "}", "len    =    touchEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". TouchEvent   e    =    touchEvents . get ( i )  ;", "currentEventTimeStamp    =    e . timeStamp ;", "switch    ( e . type )     {", "case    . TouchEvent . TOUCH _ DOWN    :", "processor . touchDown ( e . x ,    e . y ,    e . pointer ,    e . button )  ;", "justTouched    =    true ;", "break ;", "case    . TouchEvent . TOUCH _ UP    :", "processor . touchUp ( e . x ,    e . y ,    e . pointer ,    e . button )  ;", "break ;", "case    . TouchEvent . TOUCH _ DRAGGED    :", "processor . touchDragged ( e . x ,    e . y ,    e . pointer )  ;", "break ;", "case    . TouchEvent . TOUCH _ MOVED    :", "processor . mouseMoved ( e . x ,    e . y )  ;", "break ;", "case    . TouchEvent . TOUCH _ SCROLLED    :", "processor . scrolled ( e . scrollAmount )  ;", "}", "usedTouchEvents . free ( e )  ;", "}", "} else    {", "int   len    =    touchEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". TouchEvent   e    =    touchEvents . get ( i )  ;", "if    (  ( e . type )     =  =     (  . TouchEvent . TOUCH _ DOWN )  )", "justTouched    =    true ;", "usedTouchEvents . free ( e )  ;", "}", "len    =    keyEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "usedKeyEvents . free ( keyEvents . get ( i )  )  ;", "}", "}", "if    (  ( touchEvents . size (  )  )     =  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( deltaX . length )  ;    i +  +  )     {", "deltaX [  0  ]     =     0  ;", "deltaY [  0  ]     =     0  ;", "}", "}", "keyEvents . clear (  )  ;", "touchEvents . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processEvents"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "if    ( config . useAccelerometer )     {", "manager    =     (  ( SensorManager )     ( context . getSystemService ( SENSOR _ SERVICE )  )  )  ;", "if    (  ( manager . getSensorList ( TYPE _ ACCELEROMETER )  . size (  )  )     =  =     0  )     {", "accelerometerAvailable    =    false ;", "} else    {", "Sensor   accelerometer    =    manager . getSensorList ( TYPE _ ACCELEROMETER )  . get (  0  )  ;", "accelerometerListener    =    new    . SensorListener (  )  ;", "accelerometerAvailable    =    manager . registerListener ( accelerometerListener ,    accelerometer ,    config . sensorDelay )  ;", "}", "} else", "accelerometerAvailable    =    false ;", "if    ( config . useGyroscope )     {", "manager    =     (  ( SensorManager )     ( context . getSystemService ( SENSOR _ SERVICE )  )  )  ;", "if    (  ( manager . getSensorList ( TYPE _ GYROSCOPE )  . size (  )  )     =  =     0  )     {", "gyroscopeAvailable    =    false ;", "} else    {", "Sensor   gyroscope    =    manager . getSensorList ( TYPE _ GYROSCOPE )  . get (  0  )  ;", "gyroscopeListener    =    new    . SensorListener (  )  ;", "gyroscopeAvailable    =    manager . registerListener ( gyroscopeListener ,    gyroscope ,    config . sensorDelay )  ;", "}", "} else", "gyroscopeAvailable    =    false ;", "rotationVectorAvailable    =    false ;", "if    ( config . useRotationVectorSensor )     {", "if    (  ( manager )     =  =    null )", "manager    =     (  ( SensorManager )     ( context . getSystemService ( SENSOR _ SERVICE )  )  )  ;", "List < Sensor >    rotationVectorSensors    =    manager . getSensorList ( TYPE _ ROTATION _ VECTOR )  ;", "if    (  ( rotationVectorSensors . size (  )  )     >     0  )     {", "rotationVectorListener    =    new    . SensorListener (  )  ;", "for    ( Sensor   sensor    :    rotationVectorSensors )     {", "if    (  ( sensor . getVendor (  )  . equals (  \" Google   Inc .  \"  )  )     &  &     (  ( sensor . getVersion (  )  )     =  =     3  )  )     {", "rotationVectorAvailable    =    manager . registerListener ( rotationVectorListener ,    sensor ,    config . sensorDelay )  ;", "break ;", "}", "}", "if    (  !  ( rotationVectorAvailable )  )", "rotationVectorAvailable    =    manager . registerListener ( rotationVectorListener ,    rotationVectorSensors . get (  0  )  ,    config . sensorDelay )  ;", "}", "}", "if    (  ( config . useCompass )     &  &     (  !  ( rotationVectorAvailable )  )  )     {", "if    (  ( manager )     =  =    null )", "manager    =     (  ( SensorManager )     ( context . getSystemService ( SENSOR _ SERVICE )  )  )  ;", "Sensor   sensor    =    manager . getDefaultSensor ( TYPE _ MAGNETIC _ FIELD )  ;", "if    ( sensor    !  =    null )     {", "compassAvailable    =    accelerometerAvailable ;", "if    ( compassAvailable )     {", "compassListener    =    new    . SensorListener (  )  ;", "compassAvailable    =    manager . registerListener ( compassListener ,    sensor ,    config . sensorDelay )  ;", "}", "} else    {", "compassAvailable    =    false ;", "}", "} else", "compassAvailable    =    false ;", "app . log (  \"  \"  ,     \" sensor   listener   setup \"  )  ;", "}", "METHOD_END"], "methodName": ["registerSensorListeners"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    tmp    =    new   boolean [  ( orig . length )     +     2  ]  ;", "System . arraycopy ( orig ,     0  ,    tmp ,     0  ,    orig . length )  ;", "return   tmp ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "int [  ]    tmp    =    new   int [  ( orig . length )     +     2  ]  ;", "System . arraycopy ( orig ,     0  ,    tmp ,     0  ,    orig . length )  ;", "return   tmp ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "this . processor    =    processor ;", "}", "}", "METHOD_END"], "methodName": ["setInputProcessor"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "if    (  ( manager )     !  =    null )     {", "if    (  ( accelerometerListener )     !  =    null )     {", "manager . unregisterListener ( accelerometerListener )  ;", "accelerometerListener    =    null ;", "}", "if    (  ( gyroscopeListener )     !  =    null )     {", "manager . unregisterListener ( gyroscopeListener )  ;", "gyroscopeListener    =    null ;", "}", "if    (  ( rotationVectorListener )     !  =    null )     {", "manager . unregisterListener ( rotationVectorListener )  ;", "rotationVectorListener    =    null ;", "}", "if    (  ( compassListener )     !  =    null )     {", "manager . unregisterListener ( compassListener )  ;", "compassListener    =    null ;", "}", "manager    =    null ;", "}", "app . log (  \"  \"  ,     \" sensor   listener   tear   down \"  )  ;", "}", "METHOD_END"], "methodName": ["unregisterSensorListeners"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "if    ( rotationVectorAvailable )     {", "SensorManager . getRotationMatrixFromVector ( R ,    rotationVectorValues )  ;", "} else", "if    (  !  ( SensorManager . getRotationMatrix ( R ,    null ,    accelerometerValues ,    magneticFieldValues )  )  )     {", "return ;", "}", "SensorManager . getOrientation ( R ,    orientation )  ;", "azimuth    =     (  ( float )     ( Math . toDegrees ( orientation [  0  ]  )  )  )  ;", "pitch    =     (  ( float )     ( Math . toDegrees ( orientation [  1  ]  )  )  )  ;", "roll    =     (  ( float )     ( Math . toDegrees ( orientation [  2  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["updateOrientation"], "fileName": "com.badlogic.gdx.backends.android.AndroidInput"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    clazz    =    null ;", "AndroidInput   input    =    null ;", "int   sdkVersion    =    VERSION . SDK _ INT ;", "if    ( sdkVersion    >  =     1  2  )     {", "clazz    =    Class . forName (  \" ThreePlus \"  )  ;", "} else    {", "clazz    =    Class . forName (  \"  \"  )  ;", "}", "Constructor <  ?  >    constructor    =    clazz . getConstructor ( Application . class ,    Context . class ,    Object . class ,    AndroidApplicationConfiguration . class )  ;", "input    =     (  ( AndroidInput )     ( constructor . newInstance ( activity ,    context ,    view ,    config )  )  )  ;", "return   input ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Couldn ' t   construct   AndroidInput ,    this   should   never   happen \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["newAndroidInput"], "fileName": "com.badlogic.gdx.backends.android.AndroidInputFactory"}, {"methodBody": ["METHOD_START", "{", "genericMotionListeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addGenericMotionListener"], "fileName": "com.badlogic.gdx.backends.android.AndroidInputThreePlus"}, {"methodBody": ["METHOD_START", "{", "return   service ;", "}", "METHOD_END"], "methodName": ["getService"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . getVersion (  )  )     <     ( AndroidApplicationBase . MINIMUM _ SDK )  )     {", "throw   new   GdxRuntimeException (  (  (  \" LibGDX   requires   Android   API   Level    \"     +     ( AndroidApplicationBase . MINIMUM _ SDK )  )     +     \"    or   later .  \"  )  )  ;", "}", "setApplicationLogger ( new   AndroidApplicationLogger (  )  )  ;", "graphics    =    new   AndroidGraphics ( this ,    config ,     (  ( config . resolutionStrategy )     =  =    null    ?    new   FillResolutionStrategy (  )     :    config . resolutionStrategy )  )  ;", "input    =    AndroidInputFactory . newAndroidInput ( this ,    this . getService (  )  ,    graphics . view ,    config )  ;", "audio    =    new   AndroidAudio ( this . getService (  )  ,    config )  ;", "this . getService (  )  . getFilesDir (  )  ;", "files    =    new   AndroidFiles ( this . getService (  )  . getAssets (  )  ,    this . getService (  )  . getFilesDir (  )  . getAbsolutePath (  )  )  ;", "net    =    new   AndroidNet ( this )  ;", "this . listener    =    listener ;", "clipboard    =    new   AndroidClipboard ( this . getService (  )  )  ;", "Gdx . app    =    this ;", "Gdx . input    =    input ;", "Gdx . audio    =    audio ;", "Gdx . files    =    files ;", "Gdx . graphics    =    graphics ;", "Gdx . net    =    net ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( graphics )     !  =    null )     {", "graphics . onDestroyGLSurfaceView (  )  ;", "}", "if    (  ( audio )     !  =    null )     {", "audio . dispose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onDestroy"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaper"}, {"methodBody": ["METHOD_START", "{", "if    ( AndroidLiveWallpaperService . DEBUG )", "android . util . Log . d ( AndroidLiveWallpaperService . TAG ,     \"     >    AndroidLiveWallpaper    -    onPause (  )  \"  )  ;", "audio . pause (  )  ;", "input . onPause (  )  ;", "if    (  ( graphics )     !  =    null )     {", "graphics . onPauseGLSurfaceView (  )  ;", "}", "if    ( AndroidLiveWallpaperService . DEBUG )", "android . util . Log . d ( AndroidLiveWallpaperService . TAG ,     \"     >    AndroidLiveWallpaper    -    onPause (  )    done !  \"  )  ;", "}", "METHOD_END"], "methodName": ["onPause"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaper"}, {"methodBody": ["METHOD_START", "{", "Gdx . app    =    this ;", "Gdx . input    =    input ;", "Gdx . audio    =    audio ;", "Gdx . files    =    files ;", "Gdx . graphics    =    graphics ;", "Gdx . net    =    net ;", "input . onResume (  )  ;", "if    (  ( graphics )     !  =    null )     {", "graphics . onResumeGLSurfaceView (  )  ;", "}", "if    (  !  ( firstResume )  )     {", "audio . resume (  )  ;", "graphics . resume (  )  ;", "} else", "firstResume    =    false ;", "}", "METHOD_END"], "methodName": ["onResume"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaper"}, {"methodBody": ["METHOD_START", "{", "return   app ;", "}", "METHOD_END"], "methodName": ["getLiveWallpaper"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "if    ( AndroidLiveWallpaperService . DEBUG )", "android . util . Log . d ( AndroidLiveWallpaperService . TAG ,     \"     >    AndroidLiveWallpaperService    -    getSurfaceHolder (  )  \"  )  ;", "synchronized ( sync )     {", "if    (  ( linkedEngine )     =  =    null )", "return   null ;", "else", "return   linkedEngine . getSurfaceHolder (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSurfaceHolder"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "return    (  ( WindowManager )     ( getSystemService ( WINDOW _ SERVICE )  )  )  ;", "}", "METHOD_END"], "methodName": ["getWindowManager"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "AndroidApplicationConfiguration   config    =    new   AndroidApplicationConfiguration (  )  ;", "initialize ( listener ,    config )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "if    ( AndroidLiveWallpaperService . DEBUG )", "android . util . Log . d ( AndroidLiveWallpaperService . TAG ,     \"     >    AndroidLiveWallpaperService    -    initialize (  )  \"  )  ;", "app . initialize ( listener ,    config )  ;", "if    (  ( config . getTouchEventsForLiveWallpaper )     &  &     (  ( Integer . parseInt ( SDK )  )     >  =     7  )  )", "linkedEngine . setTouchEventsEnabled ( true )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "if    ( AndroidLiveWallpaperService . DEBUG )", "android . util . Log . d ( AndroidLiveWallpaperService . TAG ,     \"     >    AndroidLiveWallpaperService    -    onCreateApplication (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["onCreateApplication"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "if    ( AndroidLiveWallpaperService . DEBUG )", "android . util . Log . d ( AndroidLiveWallpaperService . TAG ,     \"     >    AndroidLiveWallpaperService    -    onDeepPauseApplication (  )  \"  )  ;", "if    (  ( app )     !  =    null )     {", "app . graphics . clearManagedCaches (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onDeepPauseApplication"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( sync )     {", "this . linkedEngine    =    linkedEngine ;", "}", "}", "METHOD_END"], "methodName": ["setLinkedEngine"], "fileName": "com.badlogic.gdx.backends.android.AndroidLiveWallpaperService"}, {"methodBody": ["METHOD_START", "{", "String   actionStr    =     \"  \"  ;", "if    ( action    =  =     ( MotionEvent . ACTION _ HOVER _ ENTER )  )", "actionStr    =     \" HOVER _ ENTER \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ HOVER _ MOVE )  )", "actionStr    =     \" HOVER _ MOVE \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ HOVER _ EXIT )  )", "actionStr    =     \" HOVER _ EXIT \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ SCROLL )  )", "actionStr    =     \" SCROLL \"  ;", "else", "actionStr    =     (  \" UNKNOWN    (  \"     +    action )     +     \"  )  \"  ;", "app . log (  \"  \"  ,     (  \" action    \"     +    actionStr )  )  ;", "}", "METHOD_END"], "methodName": ["logAction"], "fileName": "com.badlogic.gdx.backends.android.AndroidMouseHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( event . getSource (  )  )     &     ( InputDevice . SOURCE _ CLASS _ POINTER )  )     =  =     0  )", "return   false ;", "final   int   action    =     ( event . getAction (  )  )     &     ( MotionEvent . ACTION _ MASK )  ;", "int   x    =     0  ;", "int   y    =     0  ;", "int   scrollAmount    =     0  ;", "long   timeStamp    =    System . nanoTime (  )  ;", "synchronized ( input )     {", "switch    ( action )     {", "case   MotionEvent . ACTION _ HOVER _ MOVE    :", "x    =     (  ( int )     ( event . getX (  )  )  )  ;", "y    =     (  ( int )     ( event . getY (  )  )  )  ;", "if    (  ( x    !  =     ( deltaX )  )     |  |     ( y    !  =     ( deltaY )  )  )     {", "postTouchEvent ( input ,    Input . TouchEvent . TOUCH _ MOVED ,    x ,    y ,     0  ,    timeStamp )  ;", "deltaX    =    x ;", "deltaY    =    y ;", "}", "break ;", "case   MotionEvent . ACTION _ SCROLL    :", "scrollAmount    =     (  ( int )     (  -  ( Math . signum ( event . getAxisValue ( AXIS _ VSCROLL )  )  )  )  )  ;", "postTouchEvent ( input ,    Input . TouchEvent . TOUCH _ SCROLLED ,     0  ,     0  ,    scrollAmount ,    timeStamp )  ;", "}", "}", "app . getGraphics (  )  . requestRendering (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["onGenericMotion"], "fileName": "com.badlogic.gdx.backends.android.AndroidMouseHandler"}, {"methodBody": ["METHOD_START", "{", "AndroidInput . TouchEvent   event    =    input . usedTouchEvents . obtain (  )  ;", "event . timeStamp    =    timeStamp ;", "event . x    =    x ;", "event . y    =    y ;", "event . type    =    type ;", "event . scrollAmount    =    scrollAmount ;", "input . touchEvents . add ( event )  ;", "}", "METHOD_END"], "methodName": ["postTouchEvent"], "fileName": "com.badlogic.gdx.backends.android.AndroidMouseHandler"}, {"methodBody": ["METHOD_START", "{", "String   actionStr    =     \"  \"  ;", "if    ( action    =  =     ( MotionEvent . ACTION _ DOWN )  )", "actionStr    =     \" DOWN \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ POINTER _ DOWN )  )", "actionStr    =     \" POINTER   DOWN \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ UP )  )", "actionStr    =     \" UP \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ POINTER _ UP )  )", "actionStr    =     \" POINTER   UP \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ OUTSIDE )  )", "actionStr    =     \" OUTSIDE \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ CANCEL )  )", "actionStr    =     \" CANCEL \"  ;", "else", "if    ( action    =  =     ( MotionEvent . ACTION _ MOVE )  )", "actionStr    =     \" MOVE \"  ;", "else", "actionStr    =     (  \" UNKNOWN    (  \"     +    action )     +     \"  )  \"  ;", "app . log (  \"  \"  ,     (  (  (  \" action    \"     +    actionStr )     +     \"  ,    Android   pointer   id :     \"  )     +    pointer )  )  ;", "}", "METHOD_END"], "methodName": ["logAction"], "fileName": "com.badlogic.gdx.backends.android.AndroidMultiTouchHandler"}, {"methodBody": ["METHOD_START", "{", "final   int   action    =     ( event . getAction (  )  )     &     ( MotionEvent . ACTION _ MASK )  ;", "int   pointerIndex    =     (  ( event . getAction (  )  )     &     ( MotionEvent . ACTION _ POINTER _ INDEX _ MASK )  )     >  >     ( MotionEvent . ACTION _ POINTER _ INDEX _ SHIFT )  ;", "int   pointerId    =    event . getPointerId ( pointerIndex )  ;", "int   x    =     0  ;", "int   y    =     0  ;", "int   realPointerIndex    =     0  ;", "int   button    =    Buttons . LEFT ;", "long   timeStamp    =    System . nanoTime (  )  ;", "synchronized ( input )     {", "switch    ( action )     {", "case   MotionEvent . ACTION _ DOWN    :", "case   MotionEvent . ACTION _ POINTER _ DOWN    :", "realPointerIndex    =    input . getFreePointerIndex (  )  ;", "if    ( realPointerIndex    >  =     ( Input . NUM _ TOUCHES )  )", "break ;", "input . realId [ realPointerIndex ]     =    pointerId ;", "x    =     (  ( int )     ( event . getX ( pointerIndex )  )  )  ;", "y    =     (  ( int )     ( event . getY ( pointerIndex )  )  )  ;", "if    (  ( VERSION . SDK _ INT )     >  =     1  4  )", "button    =    toGdxButton ( event . getButtonState (  )  )  ;", "if    ( button    !  =     (  -  1  )  )", "postTouchEvent ( input ,    Input . TouchEvent . TOUCH _ DOWN ,    x ,    y ,    realPointerIndex ,    button ,    timeStamp )  ;", "input . touchX [ realPointerIndex ]     =    x ;", "input . touchY [ realPointerIndex ]     =    y ;", "input . deltaX [ realPointerIndex ]     =     0  ;", "input . deltaY [ realPointerIndex ]     =     0  ;", "input . touched [ realPointerIndex ]     =    button    !  =     (  -  1  )  ;", "input . button [ realPointerIndex ]     =    button ;", "break ;", "case   MotionEvent . ACTION _ UP    :", "case   MotionEvent . ACTION _ POINTER _ UP    :", "case   MotionEvent . ACTION _ OUTSIDE    :", "case   MotionEvent . ACTION _ CANCEL    :", "realPointerIndex    =    input . lookUpPointerIndex ( pointerId )  ;", "if    ( realPointerIndex    =  =     (  -  1  )  )", "break ;", "if    ( realPointerIndex    >  =     ( Input . NUM _ TOUCHES )  )", "break ;", "input . realId [ realPointerIndex ]     =     -  1  ;", "x    =     (  ( int )     ( event . getX ( pointerIndex )  )  )  ;", "y    =     (  ( int )     ( event . getY ( pointerIndex )  )  )  ;", "button    =    input . button [ realPointerIndex ]  ;", "if    ( button    !  =     (  -  1  )  )", "postTouchEvent ( input ,    Input . TouchEvent . TOUCH _ UP ,    x ,    y ,    realPointerIndex ,    button ,    timeStamp )  ;", "input . touchX [ realPointerIndex ]     =    x ;", "input . touchY [ realPointerIndex ]     =    y ;", "input . deltaX [ realPointerIndex ]     =     0  ;", "input . deltaY [ realPointerIndex ]     =     0  ;", "input . touched [ realPointerIndex ]     =    false ;", "input . button [ realPointerIndex ]     =     0  ;", "break ;", "case   MotionEvent . ACTION _ MOVE    :", "int   pointerCount    =    event . getPointerCount (  )  ;", "for    ( int   i    =     0  ;    i    <    pointerCount ;    i +  +  )     {", "pointerIndex    =    i ;", "pointerId    =    event . getPointerId ( pointerIndex )  ;", "x    =     (  ( int )     ( event . getX ( pointerIndex )  )  )  ;", "y    =     (  ( int )     ( event . getY ( pointerIndex )  )  )  ;", "realPointerIndex    =    input . lookUpPointerIndex ( pointerId )  ;", "if    ( realPointerIndex    =  =     (  -  1  )  )", "continue ;", "if    ( realPointerIndex    >  =     ( Input . NUM _ TOUCHES )  )", "break ;", "button    =    input . button [ realPointerIndex ]  ;", "if    ( button    !  =     (  -  1  )  )", "postTouchEvent ( input ,    Input . TouchEvent . TOUCH _ DRAGGED ,    x ,    y ,    realPointerIndex ,    button ,    timeStamp )  ;", "else", "postTouchEvent ( input ,    Input . TouchEvent . TOUCH _ MOVED ,    x ,    y ,    realPointerIndex ,     0  ,    timeStamp )  ;", "input . deltaX [ realPointerIndex ]     =    x    -     ( input . touchX [ realPointerIndex ]  )  ;", "input . deltaY [ realPointerIndex ]     =    y    -     ( input . touchY [ realPointerIndex ]  )  ;", "input . touchX [ realPointerIndex ]     =    x ;", "input . touchY [ realPointerIndex ]     =    y ;", "}", "break ;", "}", "}", "app . getGraphics (  )  . requestRendering (  )  ;", "}", "METHOD_END"], "methodName": ["onTouch"], "fileName": "com.badlogic.gdx.backends.android.AndroidMultiTouchHandler"}, {"methodBody": ["METHOD_START", "{", "AndroidInput . TouchEvent   event    =    input . usedTouchEvents . obtain (  )  ;", "event . timeStamp    =    timeStamp ;", "event . pointer    =    pointer ;", "event . x    =    x ;", "event . y    =    y ;", "event . type    =    type ;", "event . button    =    button ;", "input . touchEvents . add ( event )  ;", "}", "METHOD_END"], "methodName": ["postTouchEvent"], "fileName": "com.badlogic.gdx.backends.android.AndroidMultiTouchHandler"}, {"methodBody": ["METHOD_START", "{", "return   activity . getPackageManager (  )  . hasSystemFeature (  \" android . hardware . touchscreen . multitouch \"  )  ;", "}", "METHOD_END"], "methodName": ["supportsMultitouch"], "fileName": "com.badlogic.gdx.backends.android.AndroidMultiTouchHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( button    =  =     0  )     |  |     ( button    =  =     1  )  )", "return   Input . Buttons . LEFT ;", "if    ( button    =  =     2  )", "return   Input . Buttons . RIGHT ;", "if    ( button    =  =     4  )", "return   Input . Buttons . MIDDLE ;", "if    ( button    =  =     8  )", "return   Input . Buttons . BACK ;", "if    ( button    =  =     1  6  )", "return   Input . Buttons . FORWARD ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["toGdxButton"], "fileName": "com.badlogic.gdx.backends.android.AndroidMultiTouchHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( player )     =  =    null )", "return    0  .  0 F ;", "return    ( playeretDuration (  )  )     /     1  0  0  0  .  0 F ;", "}", "METHOD_END"], "methodName": ["getDuration"], "fileName": "com.badlogic.gdx.backends.android.AndroidMusic"}, {"methodBody": ["METHOD_START", "{", "if    (  ( player )     =  =    null )", "return ;", "try    {", "if    (  !  ( isPrepared )  )     {", "player . prepare (  )  ;", "isPrepared    =    true ;", "}", "player . seekTo (  (  ( int )     ( position    *     1  0  0  0  )  )  )  ;", "}    catch    ( IllegalStateException   e )     {", "e . printStTrace (  )  ;", "}    catch    ( IOException   e )     {", "e . printStTrace (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.backends.android.AndroidMusic"}, {"methodBody": ["METHOD_START", "{", "textView    =    AndroidOnscreenKeyboard . createView ( context )  ;", "textView . setOnKeyListener ( this )  ;", "FrameLayout . LayoutParams   textBoxLayoutParams    =    new   FrameLayout . LayoutParams ( LayoutParams . MATCH _ PARENT ,    LayoutParams . WRAP _ CONTENT ,    Gravity . BOTTOM )  ;", "textView . setLayoutParams ( textBoxLayoutParams )  ;", "textView . setFocusable ( true )  ;", "textView . setFocusableInTouchMode ( true )  ;", "textView . setImeOptions (  (  ( textView . getImeOptions (  )  )     |     ( EditorInfo . IME _ FLAG _ NO _ EXTRACT _ UI )  )  )  ;", "final   FrameLayout   layout    =    new   FrameLayout ( context )  ;", "ViewGroup . LayoutParams   layoutParams    =    new   ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH _ PARENT ,     0  )  ;", "layout . setLayoutParams ( layoutParams )  ;", "layout . addView ( textView )  ;", "layout . setOnTouchListener ( this )  ;", "dialog    =    new   android . app . Dialog ( context ,    style . Theme _ Translucent _ NoTitleBar _ Fullscreen )  ;", "dialog . setContentView ( layout )  ;", "return   dialog ;", "}", "METHOD_END"], "methodName": ["createDialog"], "fileName": "com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard"}, {"methodBody": ["METHOD_START", "{", "final   TextView   view    =    new   TextView ( context )     {", "Editable   editable    =    new    . PassThroughEditable (  )  ;", "@ Override", "protected   boolean   getDefaultEditable (  )     {", "return   true ;", "}", "@ Override", "public   Editable   getEditableText (  )     {", "return   editable ;", "}", "@ Override", "protected   MovementMethod   getDefaultMovementMethod (  )     {", "return   ArrowKeyMovementMethod . getInstance (  )  ;", "}", "@ Override", "public   boolean   onKeyDown ( int   keyCode ,    KeyEvent   event )     {", "Log . d (  \" Test \"  ,     (  \" down   keycode :     \"     +     ( event . getKeyCode (  )  )  )  )  ;", "return   super . onKeyDown ( keyCode ,    event )  ;", "}", "@ Override", "public   boolean   onKeyUp ( int   keyCode ,    KeyEvent   event )     {", "Log . d (  \" Test \"  ,     (  \" up   keycode :     \"     +     ( event . getKeyCode (  )  )  )  )  ;", "return   super . onKeyUp ( keyCode ,    event )  ;", "}", "}  ;", "return   view ;", "}", "METHOD_END"], "methodName": ["createView"], "fileName": "com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard"}, {"methodBody": ["METHOD_START", "{", "if    ( visible    &  &     (  ( dialog )     !  =    null )  )     {", "dialog . dismiss (  )  ;", "dialog    =    null ;", "}", "if    (  ( visible    &  &     (  ( dialog )     =  =    null )  )     &  &     (  !  ( input . isPeripheralAvailable ( Hardware )  )  )  )     {", "handler . post ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "dialog    =    createDialog (  )  ;", "dialog . show (  )  ;", "handler . post ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "dialog . getWindow (  )  . setSoftInputMode ( SOFT _ INPUT _ ADJUST _ PAN )  ;", "InputMethodManager   input    =     (  ( InputMethodManager )     ( context . getSystemService ( INPUT _ METHOD _ SERVICE )  )  )  ;", "if    ( input    !  =    null )", "input . showSoftInput ( textView ,    InputMethodManager . SHOW _ FORCED )  ;", "}", "}  )  ;", "final   View   content    =    dialog . getWindow (  )  . findViewById ( ID _ ANDROID _ CONTENT )  ;", "content . getViewTreeObserver (  )  . addOnPreDrawListener ( new   OnPreDrawListener (  )     {", "int [  ]    screenloc    =    new   int [  2  ]  ;", "private   int   keyboardHeight ;", "private   boolean   keyboardShowing ;", "@ Override", "public   boolean   onPreDraw (  )     {", "content . getLocationOnScreen ( screenloc )  ;", "keyboardHeight    =    Math . abs ( screenloc [  1  ]  )  ;", "if    (  ( keyboardHeight )     >     0  )", "keyboardShowing    =    true ;", "if    (  (  ( keyboardHeight )     =  =     0  )     &  &     ( keyboardShowing )  )     {", "dialog . dismiss (  )  ;", "dialog    =    null ;", "}", "return   true ;", "}", "}  )  ;", "}", "}  )  ;", "} else    {", "if    (  (  ! visible )     &  &     (  ( dialog )     !  =    null )  )     {", "dialog . dismiss (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.backends.android.AndroidOnscreenKeyboard"}, {"methodBody": ["METHOD_START", "{", "if    (  ( editor )     =  =    null )     {", "editor    =    shares . edit (  )  ;", "}", "}", "METHOD_END"], "methodName": ["edit"], "fileName": "com.badlogic.gdx.backends.android.AndroidPreferences"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    streamIds . size ;    i    <    n ;    i +  +  )", "sPool . stop ( streamIds . get ( i )  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.android.AndroidSound"}, {"methodBody": ["METHOD_START", "{", "try    {", "View   rootView    =    application . getApplicationWindow (  )  . getDecorView (  )  ;", "rootView . setOnSystemUiChangeListener ( new   View . OnSystemUiChangeListener (  )     {", "@ Override", "public   void   onSystemUiChange ( int   arg 0  )     {", "application . getHandler (  )  . post ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "application . useImmersiveMode ( true )  ;", "}", "}  )  ;", "}", "}  )  ;", "}    catch    ( Throwable   t )     {", "application . log (  \" AndroidApplication \"  ,     \" Can ' t   create   OnSystemUiChangeListener ,    unable   to   use   immersive   mode .  \"  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["createListener"], "fileName": "com.badlogic.gdx.backends.android.AndroidVisibilityListener"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "com.badlogic.gdx.backends.android.AndroidZipFileHandle"}, {"methodBody": ["METHOD_START", "{", "path    =    file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "expansionFile    =     (  ( Files )     ( files )  )  . getExpansionFile (  )  ;", "assetFd    =    expansionFile . getAssetFileDescriptor ( getPath (  )  )  ;", "if    ( isDirectory (  )  )", "path    +  =     \"  /  \"  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.android.AndroidZipFileHandle"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( zipFileName )  ;", "RandomAccessFile   f    =    new   RandomAccessFile ( file ,     \" r \"  )  ;", "long   fileLength    =    f . length (  )  ;", "if    ( fileLength    <     (  . kEOCDLen )  )     {", "f . close (  )  ;", "throw   new   IOException (  )  ;", "}", "long   readAmount    =     . kMaxEOCDSearch ;", "if    ( readAmount    >    fileLength )", "readAmount    =    fileLength ;", "f . seek (  0  )  ;", "int   header    =     . read 4 LE ( f )  ;", "if    ( header    =  =     (  . kEOCDSignature )  )     {", "Log . i (  . LOG _ TAG ,     \" Found   Zip   archive ,    but   it   looks   empty \"  )  ;", "throw   new   IOException (  )  ;", "} else", "if    ( header    !  =     (  . kLFHSignature )  )     {", "Log . v (  . LOG _ TAG ,     \" Not   a   Zip   archive \"  )  ;", "throw   new   IOException (  )  ;", "}", "long   searchStart    =    fileLength    -    readAmount ;", "f . seek ( searchStart )  ;", "ByteBuffer   bbuf    =    ByteBuffer . allocate (  (  ( int )     ( readAmount )  )  )  ;", "byte [  ]    buffer    =    bbuf . array (  )  ;", "f . readFully ( buffer )  ;", "bbuf . order ( ByteOrder . LITTLE _ ENDIAN )  ;", "int   eocdIdx ;", "for    ( eocdIdx    =     ( buffer . length )     -     (  . kEOCDLen )  ;    eocdIdx    >  =     0  ;    eocdIdx -  -  )     {", "if    (  (  ( buffer [ eocdIdx ]  )     =  =     8  0  )     &  &     (  ( bbuf . getInt ( eocdIdx )  )     =  =     (  . kEOCDSignature )  )  )     {", "if    (  . LOGV )     {", "Log . v (  . LOG _ TAG ,     (  \"  +  +  +    Found   EOCD   at   index :     \"     +    eocdIdx )  )  ;", "}", "break ;", "}", "}", "if    ( eocdIdx    <     0  )     {", "Log . d (  . LOG _ TAG ,     (  (  \" Zip :    EOCD   not   found ,     \"     +    zipFileName )     +     \"    is   not   zip \"  )  )  ;", "}", "int   numEntries    =    bbuf . getShort (  ( eocdIdx    +     (  . kEOCDNumEntries )  )  )  ;", "long   dirSize    =     ( bbuf . getInt (  ( eocdIdx    +     (  . kEOCDSize )  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "long   dirOffset    =     ( bbuf . getInt (  ( eocdIdx    +     (  . kEOCDFileOffset )  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "if    (  ( dirOffset    +    dirSize )     >    fileLength )     {", "Log . w (  . LOG _ TAG ,     (  (  (  (  (  (  \" bad   offsets    ( dir    \"     +    dirOffset )     +     \"  ,    size    \"  )     +    dirSize )     +     \"  ,    eocd    \"  )     +    eocdIdx )     +     \"  )  \"  )  )  ;", "throw   new   IOException (  )  ;", "}", "if    ( numEntries    =  =     0  )     {", "Log . w (  . LOG _ TAG ,     \" empty   archive ?  \"  )  ;", "throw   new   IOException (  )  ;", "}", "if    (  . LOGV )     {", "Log . v (  . LOG _ TAG ,     (  (  (  (  (  \"  +  +  +    numEntries =  \"     +    numEntries )     +     \"    dirSize =  \"  )     +    dirSize )     +     \"    dirOffset =  \"  )     +    dirOffset )  )  ;", "}", "MappedByteBuffer   directoryMap    =    f . getChannel (  )  . map ( FileChannel . MapMode . READ _ ONLY ,    dirOffset ,    dirSize )  ;", "directoryMap . order ( ByteOrder . LITTLE _ ENDIAN )  ;", "byte [  ]    tempBuf    =    new   byte [  6  5  5  3  5  ]  ;", "int   currentOffset    =     0  ;", "ByteBuffer   buf    =    ByteBuffer . allocate (  . kLFHLen )  ;", "buf . order ( ByteOrder . LITTLE _ ENDIAN )  ;", "for    ( int   i    =     0  ;    i    <    numEntries ;    i +  +  )     {", "if    (  ( directoryMap . getInt ( currentOffset )  )     !  =     (  . kCDESignature )  )     {", "Log . w (  . LOG _ TAG ,     (  (  \" Missed   a   central   dir   sig    ( at    \"     +    currentOffset )     +     \"  )  \"  )  )  ;", "throw   new   IOException (  )  ;", "}", "int   fileNameLen    =     ( directoryMap . getShort (  ( currentOffset    +     (  . kCDENameLen )  )  )  )     &     6  5  5  3  5  ;", "int   extraLen    =     ( directoryMap . getShort (  ( currentOffset    +     (  . kCDEExtraLen )  )  )  )     &     6  5  5  3  5  ;", "int   commentLen    =     ( directoryMap . getShort (  ( currentOffset    +     (  . kCDECommentLen )  )  )  )     &     6  5  5  3  5  ;", "directoryMap . position (  ( currentOffset    +     (  . kCDELen )  )  )  ;", "directoryMap . get ( tempBuf ,     0  ,    fileNameLen )  ;", "directoryMap . position (  0  )  ;", "String   str    =    new   String ( tempBuf ,     0  ,    fileNameLen )  ;", "if    (  . LOGV )     {", "Log . v (  . LOG _ TAG ,     (  \" Filename :     \"     +    str )  )  ;", "}", ". ZipEntryRO   ze    =    new    . ZipEntryRO ( zipFileName ,    file ,    str )  ;", "ze . mMethod    =     ( directoryMap . getShort (  ( currentOffset    +     (  . kCDEMethod )  )  )  )     &     6  5  5  3  5  ;", "ze . mWhenModified    =     ( directoryMap . getInt (  ( currentOffset    +     (  . kCDEModWhen )  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "ze . mCRC 3  2     =     ( directoryMap . getLong (  ( currentOffset    +     (  . kCDECRC )  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "ze . mCompressedLength    =     ( directoryMap . getLong (  ( currentOffset    +     (  . kCDECompLen )  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "ze . mUncompressedLength    =     ( directoryMap . getLong (  ( currentOffset    +     (  . kCDEUncompLen )  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "ze . mLocalHdrOffset    =     ( directoryMap . getInt (  ( currentOffset    +     (  . kCDELocalOffset )  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "buf . clear (  )  ;", "ze . setOffsetFromFile ( f ,    buf )  ;", "mHashMap . put ( str ,    ze )  ;", "currentOffset    +  =     (  (  (  . kCDELen )     +    fileNameLen )     +    extraLen )     +    commentLen ;", "}", "if    (  . LOGV )     {", "Log . v (  . LOG _ TAG ,     (  (  \"  +  +  +    zip   good   scan    \"     +    numEntries )     +     \"    entries \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addPatchFile"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "Collection < ZipResourceFile . ZipEntryRO >    values    =    mHashMap . values (  )  ;", "return   values . toArray ( new   ZipResourceFile . ZipEntryRO [ values . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getAllEntries"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "ZipResourceFile . ZipEntryRO   entry    =    mHashMap . get ( assetPath )  ;", "if    ( null    !  =    entry )     {", "return   entry . getAssetFileDescriptor (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAssetFileDescriptor"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "Vector < ZipResourceFile . ZipEntryRO >    zev    =    new   Vector < ZipResourceFile . ZipEntryRO >  (  )  ;", "Collection < ZipResourceFile . ZipEntryRO >    values    =    mHashMap . values (  )  ;", "if    ( null    =  =    path )", "path    =     \"  \"  ;", "int   length    =    path . length (  )  ;", "for    ( ZipResourceFile . ZipEntryRO   ze    :    values )     {", "if    ( ze . mFileName . startsWith ( path )  )     {", "if    (  (  -  1  )     =  =     ( ze . mFileName . indexOf (  '  /  '  ,    length )  )  )     {", "zev . add ( ze )  ;", "}", "}", "}", "ZipResourceFile . ZipEntryRO [  ]    entries    =    new   ZipResourceFile . ZipEntryRO [ zev . size (  )  ]  ;", "return   zev . toArray ( entries )  ;", "}", "METHOD_END"], "methodName": ["getEntriesAt"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "ZipResourceFile . ZipEntryRO   entry    =    mHashMap . get ( assetPath )  ;", "if    ( null    !  =    entry )     {", "if    ( entry . isUncompressed (  )  )     {", "return   entry . getAssetFileDescriptor (  )  . createInputStream (  )  ;", "} else    {", "ZipFile   zf    =    mZipFiles . get ( entry . getZipFile (  )  )  ;", "if    ( null    =  =    zf )     {", "zf    =    new   ZipFile ( entry . getZipFile (  )  ,    ZipFile . OPEN _ READ )  ;", "mZipFiles . put ( entry . getZipFile (  )  ,    zf )  ;", "}", "ZipEntry   zi    =    zf . getEntry ( assetPath )  ;", "if    ( null    !  =    zi )", "return   zf . getInputStream ( zi )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "return   ZipResourceFile . swapEndian ( f . readInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["read4LE"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( i    &     2  5  5  )     <  <     2  4  )     +     (  ( i    &     6  5  2  8  0  )     <  <     8  )  )     +     (  ( i    &     1  6  7  1  1  6  8  0  )     >  >  >     8  )  )     +     (  ( i    >  >  >     2  4  )     &     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["swapEndian"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "return    (  ( i    &     2  5  5  )     <  <     8  )     |     (  ( i    &     6  5  2  8  0  )     >  >  >     8  )  ;", "}", "METHOD_END"], "methodName": ["swapEndian"], "fileName": "com.badlogic.gdx.backends.android.ZipResourceFile"}, {"methodBody": ["METHOD_START", "{", "int   error ;", "boolean   result    =    true ;", "while    (  ( error    =    egl . eglGetError (  )  )     !  =     ( EGL 1  0  . EGL _ SUCCESS )  )     {", "result    =    false ;", "Log . e (  . TAG ,    String . format (  \"  % s :    EGL   error :     0 x % x \"  ,    prompt ,    error )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["checkEglError"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20"}, {"methodBody": ["METHOD_START", "{", "if    ( translucent )     {", "this . getHolder (  )  . setFormat ( TRANSLUCENT )  ;", "}", "setEGLContextFactory ( new    . ContextFactory (  )  )  ;", "setEGLConfigChooser (  ( translucent    ?    new    . ConfigChooser (  8  ,     8  ,     8  ,     8  ,    depth ,    stencil )     :    new    . ConfigChooser (  5  ,     6  ,     5  ,     0  ,    depth ,    stencil )  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20"}, {"methodBody": ["METHOD_START", "{", "int   error ;", "while    (  ( error    =    egl . eglGetError (  )  )     !  =     ( EGL 1  0  . EGL _ SUCCESS )  )     {", "Log . e (  . TAG ,    String . format (  \"  % s :    EGL   error :     0 x % x \"  ,    prompt ,    error )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkEglError"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18"}, {"methodBody": ["METHOD_START", "{", "if    ( translucent )     {", "this . getHolder (  )  . setFormat ( TRANSLUCENT )  ;", "}", "setEGLContextFactory ( new    . ContextFactory (  )  )  ;", "setEGLConfigChooser (  ( translucent    ?    new    . ConfigChooser (  8  ,     8  ,     8  ,     8  ,    depth ,    stencil )     :    new    . ConfigChooser (  5  ,     6  ,     5  ,     0  ,    depth ,    stencil )  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mGLThread )     !  =    null )     {", "throw   new   IllegalStateException (  \" setRerer   has   already   been   called   for   this   instance .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkRenderThreadState"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "return   mDebugFlags ;", "}", "METHOD_END"], "methodName": ["getDebugFlags"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "return   mPreserveEGLContextOnPause ;", "}", "METHOD_END"], "methodName": ["getPreserveEGLContextOnPause"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "return   mGLThread . getRenderMode (  )  ;", "}", "METHOD_END"], "methodName": ["getRenderMode"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "SurfaceHolder   holder    =    getHolder (  )  ;", "holder . addCallback ( this )  ;", "int   sdkVersion    =    VERSION . SDK _ INT ;", "if    ( sdkVersion    <  =     8  )     {", "holder . setFormat ( RGB _  5  6  5  )  ;", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . onPause (  )  ;", "}", "METHOD_END"], "methodName": ["onPause"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . onResume (  )  ;", "}", "METHOD_END"], "methodName": ["onResume"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . queueEvent ( r )  ;", "}", "METHOD_END"], "methodName": ["queueEvent"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . requestRender (  )  ;", "}", "METHOD_END"], "methodName": ["requestRender"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mDebugFlags    =    debugFlags ;", "}", "METHOD_END"], "methodName": ["setDebugFlags"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "checkRenderThreadState (  )  ;", "mEGLConfigChooser    =    configChooser ;", "}", "METHOD_END"], "methodName": ["setEGLConfigChooser"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "setEGLConfigChooser ( new   GLSurfaceViewAPI 1  8  . SimpleEGLConfigChooser ( needDepth )  )  ;", "}", "METHOD_END"], "methodName": ["setEGLConfigChooser"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "setEGLConfigChooser ( new   GLSurfaceViewAPI 1  8  . ComponentSizeChooser ( redSize ,    greenSize ,    blueSize ,    alphaSize ,    depthSize ,    stencilSize )  )  ;", "}", "METHOD_END"], "methodName": ["setEGLConfigChooser"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "checkRenderThreadState (  )  ;", "mEGLContextClientVersion    =    version ;", "}", "METHOD_END"], "methodName": ["setEGLContextClientVersion"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "checkRenderThreadState (  )  ;", "mEGLContextFactory    =    factory ;", "}", "METHOD_END"], "methodName": ["setEGLContextFactory"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "checkRenderThreadState (  )  ;", "mEGLWindowFactory    =    factory ;", "}", "METHOD_END"], "methodName": ["setEGLWindowSurfaceFactory"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLWrapper    =    glWrapper ;", "}", "METHOD_END"], "methodName": ["setGLWrapper"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mPreserveEGLContextOnPause    =    preserveOnPause ;", "}", "METHOD_END"], "methodName": ["setPreserveEGLContextOnPause"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . setRenderMode ( renderMode )  ;", "}", "METHOD_END"], "methodName": ["setRenderMode"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "checkRenderThreadState (  )  ;", "if    (  ( mEGLConfigChooser )     =  =    null )     {", "mEGLConfigChooser    =    new    . SimpleEGLConfigChooser ( true )  ;", "}", "if    (  ( mEGLContextFactory )     =  =    null )     {", "mEGLContextFactory    =    new    . DefaultContextFactory (  )  ;", "}", "if    (  ( mEGLWindowSurfaceFactory )     =  =    null )     {", "mEGLWindowSurfaceFactory    =    new    . DefaultWindowSurfaceFactory (  )  ;", "}", "mRenderer    =    renderer ;", "mGLThread    =    new    . GLThread ( mThisWeakRef )  ;", "mGLThread . start (  )  ;", "}", "METHOD_END"], "methodName": ["setRenderer"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . onWindowResize ( w ,    h )  ;", "}", "METHOD_END"], "methodName": ["surfaceChanged"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . surfaceCreated (  )  ;", "}", "METHOD_END"], "methodName": ["surfaceCreated"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "mGLThread . surfaceDestroyed (  )  ;", "}", "METHOD_END"], "methodName": ["surfaceDestroyed"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18"}, {"methodBody": ["METHOD_START", "{", "int [  ]    num _ config    =    new   int [  1  ]  ;", "egl . eglChoose ( display ,    mAttribs ,    null ,     0  ,    num _ config )  ;", "int   nums    =    num _ config [  0  ]  ;", "if    ( nums    <  =     0  )     {", "throw   new   IllegalArgumentException (  \" No   configs   match   configSpec \"  )  ;", "}", "EGL [  ]    configs    =    new   EGL [ nums ]  ;", "egl . eglChoose ( display ,    mAttribs ,    configs ,    nums ,    num _ config )  ;", "EGL   config    =    choose ( egl ,    display ,    configs )  ;", "return   config ;", "}", "METHOD_END"], "methodName": ["chooseConfig"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser"}, {"methodBody": ["METHOD_START", "{", "EGLConfig   best    =    null ;", "EGLConfig   bestAA    =    null ;", "EGLConfig   safe    =    null ;", "for    ( EGLConfig   config    :    configs )     {", "int   d    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ DEPTH _ SIZE ,     0  )  ;", "int   s    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ STENCIL _ SIZE ,     0  )  ;", "if    (  ( d    <     ( mDepthSize )  )     |  |     ( s    <     ( mStencilSize )  )  )", "continue ;", "int   r    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ RED _ SIZE ,     0  )  ;", "int   g    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ GREEN _ SIZE ,     0  )  ;", "int   b    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ BLUE _ SIZE ,     0  )  ;", "int   a    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ ALPHA _ SIZE ,     0  )  ;", "if    (  (  (  (  ( safe    =  =    null )     &  &     ( r    =  =     5  )  )     &  &     ( g    =  =     6  )  )     &  &     ( b    =  =     5  )  )     &  &     ( a    =  =     0  )  )     {", "safe    =    config ;", "}", "if    (  (  (  (  ( best    =  =    null )     &  &     ( r    =  =     ( mRedSize )  )  )     &  &     ( g    =  =     ( mGreenSize )  )  )     &  &     ( b    =  =     ( mBlueSize )  )  )     &  &     ( a    =  =     ( mAlphaSize )  )  )     {", "best    =    config ;", "if    (  ( mNumSamples )     =  =     0  )     {", "break ;", "}", "}", "int   hasSampleBuffers    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ SAMPLE _ BUFFERS ,     0  )  ;", "int   numSamples    =    findConfigAttrib ( egl ,    display ,    config ,    EGL _ SAMPLES ,     0  )  ;", "if    (  (  (  (  (  (  ( bestAA    =  =    null )     &  &     ( hasSampleBuffers    =  =     1  )  )     &  &     ( numSamples    >  =     ( mNumSamples )  )  )     &  &     ( r    =  =     ( mRedSize )  )  )     &  &     ( g    =  =     ( mGreenSize )  )  )     &  &     ( b    =  =     ( mBlueSize )  )  )     &  &     ( a    =  =     ( mAlphaSize )  )  )     {", "bestAA    =    config ;", "continue ;", "}", "hasSampleBuffers    =    findConfigAttrib ( egl ,    display ,    config ,     . EGL _ COVERAGE _ BUFFERS _ NV ,     0  )  ;", "numSamples    =    findConfigAttrib ( egl ,    display ,    config ,     . EGL _ COVERAGE _ SAMPLES _ NV ,     0  )  ;", "if    (  (  (  (  (  (  ( bestAA    =  =    null )     &  &     ( hasSampleBuffers    =  =     1  )  )     &  &     ( numSamples    >  =     ( mNumSamples )  )  )     &  &     ( r    =  =     ( mRedSize )  )  )     &  &     ( g    =  =     ( mGreenSize )  )  )     &  &     ( b    =  =     ( mBlueSize )  )  )     &  &     ( a    =  =     ( mAlphaSize )  )  )     {", "bestAA    =    config ;", "continue ;", "}", "}", "if    ( bestAA    !  =    null )", "return   bestAA ;", "else", "if    ( best    !  =    null )", "return   best ;", "else", "return   safe ;", "}", "METHOD_END"], "methodName": ["chooseConfig"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser"}, {"methodBody": ["METHOD_START", "{", "if    ( egl . eglGetConfigAttrib ( display ,    config ,    attribute ,    mValue )  )     {", "return   mValue [  0  ]  ;", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["findConfigAttrib"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser"}, {"methodBody": ["METHOD_START", "{", "int [  ]    attributes    =    new   int [  ]  {    EGL 1  0  . EGL _ BUFFER _ SIZE ,    EGL 1  0  . EGL _ ALPHA _ SIZE ,    EGL 1  0  . EGL _ BLUE _ SIZE ,    EGL 1  0  . EGL _ GREEN _ SIZE ,    EGL 1  0  . EGL _ RED _ SIZE ,    EGL 1  0  . EGL _ DEPTH _ SIZE ,    EGL 1  0  . EGL _ STENCIL _ SIZE ,    EGL 1  0  . EGL _ CONFIG _ CAVEAT ,    EGL 1  0  . EGL _ CONFIG _ ID ,    EGL 1  0  . EGL _ LEVEL ,    EGL 1  0  . EGL _ MAX _ PBUFFER _ HEIGHT ,    EGL 1  0  . EGL _ MAX _ PBUFFER _ PIXELS ,    EGL 1  0  . EGL _ MAX _ PBUFFER _ WIDTH ,    EGL 1  0  . EGL _ NATIVE _ RENDERABLE ,    EGL 1  0  . EGL _ NATIVE _ VISUAL _ ID ,    EGL 1  0  . EGL _ NATIVE _ VISUAL _ TYPE ,     1  2  3  3  6  ,    EGL 1  0  . EGL _ SAMPLES ,    EGL 1  0  . EGL _ SAMPLE _ BUFFERS ,    EGL 1  0  . EGL _ SURFACE _ TYPE ,    EGL 1  0  . EGL _ TRANSPARENT _ TYPE ,    EGL 1  0  . EGL _ TRANSPARENT _ RED _ VALUE ,    EGL 1  0  . EGL _ TRANSPARENT _ GREEN _ VALUE ,    EGL 1  0  . EGL _ TRANSPARENT _ BLUE _ VALUE ,     1  2  3  4  5  ,     1  2  3  4  6  ,     1  2  3  4  7  ,     1  2  3  4  8  ,    EGL 1  0  . EGL _ LUMINANCE _ SIZE ,    EGL 1  0  . EGL _ ALPHA _ MASK _ SIZE ,    EGL 1  0  . EGL _ COLOR _ BUFFER _ TYPE ,    EGL 1  0  . EGL _ RENDERABLE _ TYPE ,     1  2  3  5  4  ,    GdxEglConfigChooser . EGL _ COVERAGE _ BUFFERS _ NV ,    GdxEglConfigChooser . EGL _ COVERAGE _ SAMPLES _ NV    }  ;", "String [  ]    names    =    new   String [  ]  {     \" EGL _ BUFFER _ SIZE \"  ,     \" EGL _ ALPHA _ SIZE \"  ,     \" EGL _ BLUE _ SIZE \"  ,     \" EGL _ GREEN _ SIZE \"  ,     \" EGL _ RED _ SIZE \"  ,     \" EGL _ DEPTH _ SIZE \"  ,     \" EGL _ STENCIL _ SIZE \"  ,     \" EGL _ CONFIG _ CAVEAT \"  ,     \" EGL _ CONFIG _ ID \"  ,     \" EGL _ LEVEL \"  ,     \" EGL _ MAX _ PBUFFER _ HEIGHT \"  ,     \" EGL _ MAX _ PBUFFER _ PIXELS \"  ,     \" EGL _ MAX _ PBUFFER _ WIDTH \"  ,     \" EGL _ NATIVE _ RENDERABLE \"  ,     \" EGL _ NATIVE _ VISUAL _ ID \"  ,     \" EGL _ NATIVE _ VISUAL _ TYPE \"  ,     \" EGL _ PRESERVED _ RESOURCES \"  ,     \" EGL _ SAMPLES \"  ,     \" EGL _ SAMPLE _ BUFFERS \"  ,     \" EGL _ SURFACE _ TYPE \"  ,     \" EGL _ TRANSPARENT _ TYPE \"  ,     \" EGL _ TRANSPARENT _ RED _ VALUE \"  ,     \" EGL _ TRANSPARENT _ GREEN _ VALUE \"  ,     \" EGL _ TRANSPARENT _ BLUE _ VALUE \"  ,     \" EGL _ BIND _ TO _ TEXTURE _ RGB \"  ,     \" EGL _ BIND _ TO _ TEXTURE _ RGBA \"  ,     \" EGL _ MIN _ SWAP _ INTERVAL \"  ,     \" EGL _ MAX _ SWAP _ INTERVAL \"  ,     \" EGL _ LUMINANCE _ SIZE \"  ,     \" EGL _ ALPHA _ MASK _ SIZE \"  ,     \" EGL _ COLOR _ BUFFER _ TYPE \"  ,     \" EGL _ RENDERABLE _ TYPE \"  ,     \" EGL _ CONFORMANT \"  ,     \" EGL _ COVERAGE _ BUFFERS _ NV \"  ,     \" EGL _ COVERAGE _ SAMPLES _ NV \"     }  ;", "int [  ]    value    =    new   int [  1  ]  ;", "for    ( int   i    =     0  ;    i    <     ( attributes . length )  ;    i +  +  )     {", "int   attribute    =    attributes [ i ]  ;", "String   name    =    names [ i ]  ;", "if    ( egl . eglGetConfigAttrib ( display ,    config ,    attribute ,    value )  )     {", "Log . w ( GdxEglConfigChooser . TAG ,    String . format (  \"        % s :     % d \\ n \"  ,    name ,    value [  0  ]  )  )  ;", "} else    {", "egl . eglGetError (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printConfig"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser"}, {"methodBody": ["METHOD_START", "{", "int   numConfigs    =    configs . length ;", "Log . w (  . TAG ,    String . format (  \"  % d   configurations \"  ,    numConfigs )  )  ;", "for    ( int   i    =     0  ;    i    <    numConfigs ;    i +  +  )     {", "Log . w (  . TAG ,    String . format (  \" Configuration    % d :  \\ n \"  ,    i )  )  ;", "printConfig ( egl ,    display ,    configs [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["printConfigs"], "fileName": "com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser"}]