[{"methodBody": ["METHOD_START", "{", "jniApplyAngularImpulse ( addr ,    impulse ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyAngularImpulse"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniApplyForce ( addr ,    force . x ,    force . y ,    point . x ,    point . y ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyForce"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniApplyForce ( addr ,    forceX ,    forceY ,    pointX ,    pointY ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyForce"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniApplyForceToCenter ( addr ,    force . x ,    force . y ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyForceToCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniApplyForceToCenter ( addr ,    forceX ,    forceY ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyForceToCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniApplyLinearImpulse ( addr ,    impulse . x ,    impulse . y ,    point . x ,    point . y ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyLinearImpulse"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniApplyLinearImpulse ( addr ,    impulseX ,    impulseY ,    pointX ,    pointY ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyLinearImpulse"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniApplyTorque ( addr ,    torque ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyTorque"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "long   fixtureAddr    =    jniCreateFixture ( addr ,    def . shape . addr ,    def . friction ,    def . restitution ,    def . density ,    def . isSensor ,    def . filter . categoryBits ,    def . filter . maskBits ,    def . filter . groupIndex )  ;", "Fixture   fixture    =    this . world . freeFixtures . obtain (  )  ;", "fixture . reset ( this ,    fixtureAddr )  ;", "this . world . fixtures . put ( fixture . addr ,    fixture )  ;", "this . fixtures . add ( fixture )  ;", "return   fixture ;", "}", "METHOD_END"], "methodName": ["createFixture"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "long   fixtureAddr    =    jniCreateFixture ( addr ,    shape . addr ,    density )  ;", "Fixture   fixture    =    this . world . freeFixtures . obtain (  )  ;", "fixture . reset ( this ,    fixtureAddr )  ;", "this . world . fixtures . put ( fixture . addr ,    fixture )  ;", "this . fixtures . add ( fixture )  ;", "return   fixture ;", "}", "METHOD_END"], "methodName": ["createFixture"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "this . world . destroyFixture ( this ,    fixture )  ;", "fixture . setUserData ( null )  ;", "this . world . fixtures . remove ( fixture . addr )  ;", "this . fixtures . removeValue ( fixture ,    true )  ;", "this . world . freeFixtures . free ( fixture )  ;", "}", "METHOD_END"], "methodName": ["destroyFixture"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniGetAngle ( addr )  ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniGetAngularDamping ( addr )  ;", "}", "METHOD_END"], "methodName": ["getAngularDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniGetAngularVelocity ( addr )  ;", "}", "METHOD_END"], "methodName": ["getAngularVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   fixtures ;", "}", "METHOD_END"], "methodName": ["getFixtureList"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniGetGravityScale ( addr )  ;", "}", "METHOD_END"], "methodName": ["getGravityScale"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniGetInertia ( addr )  ;", "}", "METHOD_END"], "methodName": ["getInertia"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   joints ;", "}", "METHOD_END"], "methodName": ["getJointList"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniGetLinearDamping ( addr )  ;", "}", "METHOD_END"], "methodName": ["getLinearDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetLinearVelocity ( addr ,    tmp )  ;", "linearVelocity . x    =    tmp [  0  ]  ;", "linearVelocity . y    =    tmp [  1  ]  ;", "return   linearVelocity ;", "}", "METHOD_END"], "methodName": ["getLinearVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetLinearVelocityFromLocalPoint ( addr ,    localPoint . x ,    localPoint . y ,    tmp )  ;", "linVelLoc . x    =    tmp [  0  ]  ;", "linVelLoc . y    =    tmp [  1  ]  ;", "return   linVelLoc ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromLocalPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetLinearVelocityFromWorldPoint ( addr ,    worldPoint . x ,    worldPoint . y ,    tmp )  ;", "linVelWorld . x    =    tmp [  0  ]  ;", "linVelWorld . y    =    tmp [  1  ]  ;", "return   linVelWorld ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromWorldPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalCenter ( addr ,    tmp )  ;", "localCenter . x    =    tmp [  0  ]  ;", "localCenter . y    =    tmp [  1  ]  ;", "return   localCenter ;", "}", "METHOD_END"], "methodName": ["getLocalCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalPoint ( addr ,    worldPoint . x ,    worldPoint . y ,    tmp )  ;", "localPoint 2  . x    =    tmp [  0  ]  ;", "localPoint 2  . y    =    tmp [  1  ]  ;", "return   localPoint 2  ;", "}", "METHOD_END"], "methodName": ["getLocalPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalVector ( addr ,    worldVector . x ,    worldVector . y ,    tmp )  ;", "localVector . x    =    tmp [  0  ]  ;", "localVector . y    =    tmp [  1  ]  ;", "return   localVector ;", "}", "METHOD_END"], "methodName": ["getLocalVector"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMass ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMass"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetMassData ( addr ,    tmp )  ;", "massData . mass    =    tmp [  0  ]  ;", "massData . center . x    =    tmp [  1  ]  ;", "massData . center . y    =    tmp [  2  ]  ;", "massData . I    =    tmp [  3  ]  ;", "return   massData ;", "}", "METHOD_END"], "methodName": ["getMassData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetPosition ( addr ,    tmp )  ;", "position . x    =    tmp [  0  ]  ;", "position . y    =    tmp [  1  ]  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetTransform ( addr ,    transform . vals )  ;", "return   transform ;", "}", "METHOD_END"], "methodName": ["getTransform"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "int   type    =    jniGetType ( addr )  ;", "if    ( type    =  =     0  )", "returnDefType . Stati ;", "if    ( type    =  =     1  )", "returnDefType . Kinemati ;", "if    ( type    =  =     2  )", "returnDefType . Dynami ;", "returnDefType . Stati ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   world ;", "}", "METHOD_END"], "methodName": ["getWorld"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetWorldCenter ( addr ,    tmp )  ;", "worldCenter . x    =    tmp [  0  ]  ;", "worldCenter . y    =    tmp [  1  ]  ;", "return   worldCenter ;", "}", "METHOD_END"], "methodName": ["getWorldCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetWorldPoint ( addr ,    localPoint . x ,    localPoint . y ,    tmp )  ;", "this . localPoint . x    =    tmp [  0  ]  ;", "this . localPoint . y    =    tmp [  1  ]  ;", "return   this . localPoint ;", "}", "METHOD_END"], "methodName": ["getWorldPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniGetWorldVector ( addr ,    localVector . x ,    localVector . y ,    tmp )  ;", "worldVector . x    =    tmp [  0  ]  ;", "worldVector . y    =    tmp [  1  ]  ;", "return   worldVector ;", "}", "METHOD_END"], "methodName": ["getWorldVector"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniIsActive ( addr )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniIsAwake ( addr )  ;", "}", "METHOD_END"], "methodName": ["isAwake"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniIsBullet ( addr )  ;", "}", "METHOD_END"], "methodName": ["isBullet"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniIsFixedRotation ( addr )  ;", "}", "METHOD_END"], "methodName": ["isFixedRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   jniIsSleepingAllowed ( addr )  ;", "}", "METHOD_END"], "methodName": ["isSleepingAllowed"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "this . addr    =    addr ;", "this . userData    =    null ;", "for    ( int   i    =     0  ;    i    <     ( fixtures . size )  ;    i +  +  )", "this . world . freeFixtures . free ( fixtures . get ( i )  )  ;", "fixtures . clear (  )  ;", "this . joints . clear (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniResetMassData ( addr )  ;", "}", "METHOD_END"], "methodName": ["resetMassData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "if    ( flag )     {", "jniSetActive ( addr ,    flag )  ;", "} else    {", "this . world . deactivate ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetAngularDamping ( addr ,    angularDamping )  ;", "}", "METHOD_END"], "methodName": ["setAngularDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetAngularVelocity ( addr ,    omega )  ;", "}", "METHOD_END"], "methodName": ["setAngularVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetAwake ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setAwake"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetBullet ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setBullet"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetFixedRotation ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setFixedRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetGravityScale ( addr ,    scale )  ;", "}", "METHOD_END"], "methodName": ["setGravityScale"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetLinearDamping ( addr ,    linearDamping )  ;", "}", "METHOD_END"], "methodName": ["setLinearDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetLinearVelocity ( addr ,    v . x ,    v . y )  ;", "}", "METHOD_END"], "methodName": ["setLinearVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetLinearVelocity ( addr ,    vX ,    vY )  ;", "}", "METHOD_END"], "methodName": ["setLinearVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetMassData ( addr ,    data . mass ,    data . center . x ,    data . center . y ,    data . I )  ;", "}", "METHOD_END"], "methodName": ["setMassData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetSleepingAllowed ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setSleepingAllowed"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetTransform ( addr ,    position . x ,    position . y ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetTransform ( addr ,    x ,    y ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "jniSetType ( addr ,    type . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "new   SharedLibraryLoader (  )  . load (  \" gdx - box 2 d \"  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.physics.box2d.Box2D"}, {"methodBody": ["METHOD_START", "{", "renderer . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Circle )  )     {", "CircleShape   shape    =     (  ( CircleShape )     ( fixture . getShape (  )  )  )  ;", "float   radius    =    shape . getRadius (  )  ;", ". vertices [  0  ]  . set ( shape . getPosition (  )  )  ;", "transform . mul (  . vertices [  0  ]  )  ;", ". lower . set (  (  (  . vertices [  0  ]  . x )     -    radius )  ,     (  (  . vertices [  0  ]  . y )     -    radius )  )  ;", ". upper . set (  (  (  . vertices [  0  ]  . x )     +    radius )  ,     (  (  . vertices [  0  ]  . y )     +    radius )  )  ;", ". vertices [  0  ]  . set (  . lower . x ,     . lower . y )  ;", ". vertices [  1  ]  . set (  . upper . x ,     . lower . y )  ;", ". vertices [  2  ]  . set (  . upper . x ,     . upper . y )  ;", ". vertices [  3  ]  . set (  . lower . x ,     . upper . y )  ;", "drawSolidPolygon (  . vertices ,     4  ,    AABB _ COLOR ,    true )  ;", "} else", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Polygon )  )     {", "PolygonShape   shape    =     (  ( PolygonShape )     ( fixture . getShape (  )  )  )  ;", "int   vertexCount    =    shape . getVertexCount (  )  ;", "shape . getVertex (  0  ,     . vertices [  0  ]  )  ;", ". lower . set ( transform . mul (  . vertices [  0  ]  )  )  ;", ". upper . set (  . lower )  ;", "for    ( int   i    =     1  ;    i    <    vertexCount ;    i +  +  )     {", "shape . getVertex ( i ,     . vertices [ i ]  )  ;", "transform . mul (  . vertices [ i ]  )  ;", ". lower . x    =    Math . min (  . lower . x ,     . vertices [ i ]  . x )  ;", ". lower . y    =    Math . min (  . lower . y ,     . vertices [ i ]  . y )  ;", ". upper . x    =    Math . max (  . upper . x ,     . vertices [ i ]  . x )  ;", ". upper . y    =    Math . max (  . upper . y ,     . vertices [ i ]  . y )  ;", "}", ". vertices [  0  ]  . set (  . lower . x ,     . lower . y )  ;", ". vertices [  1  ]  . set (  . upper . x ,     . lower . y )  ;", ". vertices [  2  ]  . set (  . upper . x ,     . upper . y )  ;", ". vertices [  3  ]  . set (  . lower . x ,     . upper . y )  ;", "drawSolidPolygon (  . vertices ,     4  ,    AABB _ COLOR ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["drawAABB"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "WorldManifold   worldManifold    =    contact . getWorldManifold (  )  ;", "if    (  ( worldManifold . getNumberOfContactPoints (  )  )     =  =     0  )", "return ;", "Vector 2    point    =    worldManifold . getPoints (  )  [  0  ]  ;", "r . setColor ( getColorByBody ( contact . getFixtureA (  )  . getBody (  )  )  )  ;", "r . point ( point . x ,    point . y ,     0  )  ;", "}", "METHOD_END"], "methodName": ["drawContact"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "Body   bodyA    =    joint . getBodyA (  )  ;", "Body   bodyB    =    joint . getBodyB (  )  ;", "Transform   xf 1     =    bodyA . getTransform (  )  ;", "Transform   xf 2     =    bodyB . getTransform (  )  ;", "Vector 2    x 1     =    xf 1  . getPosition (  )  ;", "Vector 2    x 2     =    xf 2  . getPosition (  )  ;", "Vector 2    p 1     =    joint . getAnchorA (  )  ;", "Vector 2    p 2     =    joint . getAnchorB (  )  ;", "if    (  ( joint . getType (  )  )     =  =     ( JointDef . JointType . DistanceJoint )  )     {", "drawSegment ( p 1  ,    p 2  ,    JOINT _ COLOR )  ;", "} else", "if    (  ( joint . getType (  )  )     =  =     ( JointDef . JointType . PulleyJoint )  )     {", "joints . PulleyJoint   pulley    =     (  ( joints . PulleyJoint )     ( joint )  )  ;", "Vector 2    s 1     =    pulley . getGroundAnchorA (  )  ;", "Vector 2    s 2     =    pulley . getGroundAnchorB (  )  ;", "drawSegment ( s 1  ,    p 1  ,    JOINT _ COLOR )  ;", "drawSegment ( s 2  ,    p 2  ,    JOINT _ COLOR )  ;", "drawSegment ( s 1  ,    s 2  ,    JOINT _ COLOR )  ;", "} else", "if    (  ( joint . getType (  )  )     =  =     ( JointDef . JointType . MouseJoint )  )     {", "drawSegment ( joint . getAnchorA (  )  ,    joint . getAnchorB (  )  ,    JOINT _ COLOR )  ;", "} else    {", "drawSegment ( x 1  ,    p 1  ,    JOINT _ COLOR )  ;", "drawSegment ( p 1  ,    p 2  ,    JOINT _ COLOR )  ;", "drawSegment ( x 2  ,    p 2  ,    JOINT _ COLOR )  ;", "}", "}", "METHOD_END"], "methodName": ["drawJoint"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . setColor ( color )  ;", "renderer . line ( x 1  . x ,    x 1  . y ,    x 2  . x ,    x 2  . y )  ;", "}", "METHOD_END"], "methodName": ["drawSegment"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Circle )  )     {", "CircleShape   circle    =     (  ( CircleShape )     ( fixture . getShape (  )  )  )  ;", ". t . set ( circle . getPosition (  )  )  ;", "transform . mul (  . t )  ;", "drawSolidCircle (  . t ,    circle . getRadius (  )  ,     . axis . set ( transform . vals [ Transform . COS ]  ,    transform . vals [ Transform . SIN ]  )  ,    color )  ;", "return ;", "}", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Edge )  )     {", "EdgeShape   edge    =     (  ( EdgeShape )     ( fixture . getShape (  )  )  )  ;", "edge . getVertex 1  (  . vertices [  0  ]  )  ;", "edge . getVertex 2  (  . vertices [  1  ]  )  ;", "transform . mul (  . vertices [  0  ]  )  ;", "transform . mul (  . vertices [  1  ]  )  ;", "drawSolidPolygon (  . vertices ,     2  ,    color ,    true )  ;", "return ;", "}", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Polygon )  )     {", "PolygonShape   chain    =     (  ( PolygonShape )     ( fixture . getShape (  )  )  )  ;", "int   vertexCount    =    chain . getVertexCount (  )  ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )     {", "chain . getVertex ( i ,     . vertices [ i ]  )  ;", "transform . mul (  . vertices [ i ]  )  ;", "}", "drawSolidPolygon (  . vertices ,    vertexCount ,    color ,    true )  ;", "return ;", "}", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Chain )  )     {", "ChainShape   chain    =     (  ( ChainShape )     ( fixture . getShape (  )  )  )  ;", "int   vertexCount    =    chain . getVertexCount (  )  ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )     {", "chain . getVertex ( i ,     . vertices [ i ]  )  ;", "transform . mul (  . vertices [ i ]  )  ;", "}", "drawSolidPolygon (  . vertices ,    vertexCount ,    color ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["drawShape"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "float   angle    =     0  ;", "float   angleInc    =     (  2     *     (  ( float )     ( Math . PI )  )  )     /     2  0  ;", "r . setColor ( color . r ,    color . g ,    color . b ,    color . a )  ;", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +     ,    angle    +  =    angleInc )     {", "v . set (  (  (  (  ( float )     ( Math . cos ( angle )  )  )     *    radius )     +     ( center . x )  )  ,     (  (  (  ( float )     ( Math . sin ( angle )  )  )     *    radius )     +     ( center . y )  )  )  ;", "if    ( i    =  =     0  )     {", "lv . set ( v )  ;", "f . set ( v )  ;", "continue ;", "}", "r . line ( lv . x ,    lv . y ,    v . x ,    v . y )  ;", "lv . set ( v )  ;", "}", "r . line ( f . x ,    f . y ,    lv . x ,    lv . y )  ;", "r . line ( center . x ,    center . y ,     0  ,     (  ( center . x )     +     (  ( axis . x )     *    radius )  )  ,     (  ( center . y )     +     (  ( axis . y )     *    radius )  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["drawSolidCircle"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . setColor ( color . r ,    color . g ,    color . b ,    color . a )  ;", "lv . set ( vertices [  0  ]  )  ;", "f . set ( vertices [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <    vertexCount ;    i +  +  )     {", "Vector 2    v    =    vertices [ i ]  ;", "renderer . line ( lv . x ,    lv . y ,    v . x ,    v . y )  ;", "lv . set ( v )  ;", "}", "if    ( closed )", "renderer . line ( f . x ,    f . y ,    lv . x ,    lv . y )  ;", "}", "METHOD_END"], "methodName": ["drawSolidPolygon"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   Box 2 DDebugRenderer . axis ;", "}", "METHOD_END"], "methodName": ["getAxis"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( body . isActive (  )  )     =  =    false )", "return   SHAPE _ NOT _ ACTIVE ;", "else", "if    (  ( body . getType (  )  )     =  =    dyDefdyType . Statidy )  )", "return   SHAPE _ STATIC ;", "else", "if    (  ( body . getType (  )  )     =  =    dyDefdyType . Kinematidy )  )", "return   SHAPE _ KINEMATIC ;", "else", "if    (  ( body . isAwake (  )  )     =  =    false )", "return   SHAPE _ NOT _ AWAKE ;", "else", "return   SHAPE _ AWAKE ;", "}", "METHOD_END"], "methodName": ["getColorByBody"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawAABBs ;", "}", "METHOD_END"], "methodName": ["isDrawAABBs"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawBodies ;", "}", "METHOD_END"], "methodName": ["isDrawBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawContacts ;", "}", "METHOD_END"], "methodName": ["isDrawContacts"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawInactiveBodies ;", "}", "METHOD_END"], "methodName": ["isDrawInactiveBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawJoints ;", "}", "METHOD_END"], "methodName": ["isDrawJoints"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawVelocities ;", "}", "METHOD_END"], "methodName": ["isDrawVelocities"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . setProjectionMatrix ( projMatrix )  ;", "renderBodies ( world )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . begin ( Line )  ;", "if    (  ( drawBodies )     |  |     ( drawAABBs )  )     {", "world . getBodies (  . bodies )  ;", "for    ( Iterator < Body >    iter    =     . bodies . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Body   body    =    iter . next (  )  ;", "if    (  ( body . isActive (  )  )     |  |     ( drawInactiveBodies )  )", "renderBody ( body )  ;", "}", "}", "if    ( drawJoints )     {", "world . getJoints (  . joints )  ;", "for    ( Iterator < Joint >    iter    =     . joints . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Joint   joint    =    iter . next (  )  ;", "drawJoint ( joint )  ;", "}", "}", "renderer . end (  )  ;", "if    ( drawContacts )     {", "renderer . begin ( Point )  ;", "for    ( Contact   contact    :    world . getContactList (  )  )", "drawContact ( contact )  ;", "renderer . end (  )  ;", "}", "}", "METHOD_END"], "methodName": ["renderBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "Transform   transform    =    body . getTransform (  )  ;", "for    ( Fixture   fixture    :    body . getFixtureList (  )  )     {", "if    ( drawBodies )     {", "drawShape ( fixture ,    transform ,    getColorByBody ( body )  )  ;", "if    ( drawVelocities )     {", "Vector 2    position    =    body . getPosition (  )  ;", "drawSegment ( position ,    body . getLinearVelocity (  )  . add ( position )  ,    VELOCITY _ COLOR )  ;", "}", "}", "if    ( drawAABBs )     {", "drawAABB ( fixture ,    transform )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["renderBody"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "Box 2 DDebugRenderer . axis    =    axis ;", "}", "METHOD_END"], "methodName": ["setAxis"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawAABBs    =    drawAABBs ;", "}", "METHOD_END"], "methodName": ["setDrawAABBs"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawBodies    =    drawBodies ;", "}", "METHOD_END"], "methodName": ["setDrawBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawContacts    =    drawContacts ;", "}", "METHOD_END"], "methodName": ["setDrawContacts"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawInactiveBodies    =    drawInactiveBodies ;", "}", "METHOD_END"], "methodName": ["setDrawInactiveBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawJoints    =    drawJoints ;", "}", "METHOD_END"], "methodName": ["setDrawJoints"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawVelocities    =    drawVelocities ;", "}", "METHOD_END"], "methodName": ["setDrawVelocities"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "float [  ]    verts    =    new   float [  ( vertices . length )     *     2  ]  ;", "for    ( int   i    =     0  ,    j    =     0  ;    i    <     (  ( vertices . length )     *     2  )  ;    i    +  =     2     ,    j +  +  )     {", "verts [ i ]     =    vertices [ j ]  . x ;", "verts [  ( i    +     1  )  ]     =    vertices [ j ]  . y ;", "}", "jniCreate ( addr ,    verts ,     0  ,    vertices . length )  ;", "isLooped    =    false ;", "}", "METHOD_END"], "methodName": ["createChain"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniCreateChain ( addr ,    vertices ,     0  ,     (  ( vertices . length )     /     2  )  )  ;", "isLooped    =    false ;", "}", "METHOD_END"], "methodName": ["createChain"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniCreateChain ( addr ,    vertices ,    offset ,     ( length    /     2  )  )  ;", "isLooped    =    false ;", "}", "METHOD_END"], "methodName": ["createChain"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "float [  ]    verts    =    new   float [  ( vertices . length )     *     2  ]  ;", "for    ( int   i    =     0  ,    j    =     0  ;    i    <     (  ( vertices . length )     *     2  )  ;    i    +  =     2     ,    j +  +  )     {", "verts [ i ]     =    vertices [ j ]  . x ;", "verts [  ( i    +     1  )  ]     =    vertices [ j ]  . y ;", "}", "jniCreateLoop ( addr ,    verts ,     0  ,     (  ( verts . length )     /     2  )  )  ;", "isLooped    =    true ;", "}", "METHOD_END"], "methodName": ["createLoop"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniCreateLoop ( addr ,    vertices ,     0  ,     (  ( vertices . length )     /     2  )  )  ;", "isLooped    =    true ;", "}", "METHOD_END"], "methodName": ["createLoop"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniCreateLoop ( addr ,    vertices ,    offset ,     ( length    /     2  )  )  ;", "isLooped    =    true ;", "}", "METHOD_END"], "methodName": ["createLoop"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniGetVertex ( addr ,    index ,    ChainShape . verts )  ;", "vertex . x    =    ChainShape . verts [  0  ]  ;", "vertex . y    =    ChainShape . verts [  1  ]  ;", "}", "METHOD_END"], "methodName": ["getVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "return   jniGetVertexCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "return   isLooped ;", "}", "METHOD_END"], "methodName": ["isLooped"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "setNextVertex ( nextVertex . x ,    nextVertex . y )  ;", "}", "METHOD_END"], "methodName": ["setNextVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniSetNextVertex ( addr ,    nextVertexX ,    nextVertexY )  ;", "}", "METHOD_END"], "methodName": ["setNextVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "setPrevVertex ( prevVertex . x ,    prevVertex . y )  ;", "}", "METHOD_END"], "methodName": ["setPrevVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniSetPrevVertex ( addr ,    prevVertexX ,    prevVertexY )  ;", "}", "METHOD_END"], "methodName": ["setPrevVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "jniGetPosition ( addr ,    tmp )  ;", "position . x    =    tmp [  0  ]  ;", "position . y    =    tmp [  1  ]  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.physics.box2d.CircleShape"}, {"methodBody": ["METHOD_START", "{", "jniSetPosition ( addr ,    position . x ,    position . y )  ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.physics.box2d.CircleShape"}, {"methodBody": ["METHOD_START", "{", "jniResetRestitution ( addr )  ;", "}", "METHOD_END"], "methodName": ["ResetRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniGetChildIndexA ( addr )  ;", "}", "METHOD_END"], "methodName": ["getChildIndexA"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniGetChildIndexB ( addr )  ;", "}", "METHOD_END"], "methodName": ["getChildIndexB"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   world . fixtures . get ( jniGetFixtureA ( addr )  )  ;", "}", "METHOD_END"], "methodName": ["getFixtureA"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   world . fixtures . get ( jniGetFixtureB ( addr )  )  ;", "}", "METHOD_END"], "methodName": ["getFixtureB"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniGetFriction ( addr )  ;", "}", "METHOD_END"], "methodName": ["getFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniGetRestitution ( addr )  ;", "}", "METHOD_END"], "methodName": ["getRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniGetTangentSpeed ( addr )  ;", "}", "METHOD_END"], "methodName": ["getTangentSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "int   numContactPoints    =    jniGetWorldManifold ( addr ,    tmp )  ;", "worldManifold . numContactPoints    =    numContactPoints ;", "worldManifold . normal . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "for    ( int   i    =     0  ;    i    <    numContactPoints ;    i +  +  )     {", "Vector 2    point    =    worldManifold . points [ i ]  ;", "point . x    =    tmp [  (  2     +     ( i    *     2  )  )  ]  ;", "point . y    =    tmp [  (  (  2     +     ( i    *     2  )  )     +     1  )  ]  ;", "}", "worldManifold . separations [  0  ]     =    tmp [  6  ]  ;", "worldManifold . separations [  1  ]     =    tmp [  7  ]  ;", "return   worldManifold ;", "}", "METHOD_END"], "methodName": ["getWorldManifold"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniIsEnabled ( addr )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniIsTouching ( addr )  ;", "}", "METHOD_END"], "methodName": ["isTouching"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "jniResetFriction ( addr )  ;", "}", "METHOD_END"], "methodName": ["resetFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "jniSetEnabled ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "jniSetFriction ( addr ,    friction )  ;", "}", "METHOD_END"], "methodName": ["setFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "jniSetRestitution ( addr ,    restitution )  ;", "}", "METHOD_END"], "methodName": ["setRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "jniSetTangentSpeed ( addr ,    speed )  ;", "}", "METHOD_END"], "methodName": ["setTangentSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   jniGetCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "com.badlogic.gdx.physics.box2d.ContactImpulse"}, {"methodBody": ["METHOD_START", "{", "jniGetNormalImpulses ( addr ,    normalImpulses )  ;", "return   normalImpulses ;", "}", "METHOD_END"], "methodName": ["getNormalImpulses"], "fileName": "com.badlogic.gdx.physics.box2d.ContactImpulse"}, {"methodBody": ["METHOD_START", "{", "jniGetTangentImpulses ( addr ,    tangentImpulses )  ;", "return   tangentImpulses ;", "}", "METHOD_END"], "methodName": ["getTangentImpulses"], "fileName": "com.badlogic.gdx.physics.box2d.ContactImpulse"}, {"methodBody": ["METHOD_START", "{", "jniGetVertex 0  ( addr ,    EdgeShape . vertex )  ;", "vec . x    =    EdgeShape . vertex [  0  ]  ;", "vec . y    =    EdgeShape . vertex [  1  ]  ;", "}", "METHOD_END"], "methodName": ["getVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniGetVertex 1  ( addr ,    EdgeShape . vertex )  ;", "vec . x    =    EdgeShape . vertex [  0  ]  ;", "vec . y    =    EdgeShape . vertex [  1  ]  ;", "}", "METHOD_END"], "methodName": ["getVertex1"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniGetVertex 2  ( addr ,    EdgeShape . vertex )  ;", "vec . x    =    EdgeShape . vertex [  0  ]  ;", "vec . y    =    EdgeShape . vertex [  1  ]  ;", "}", "METHOD_END"], "methodName": ["getVertex2"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniGetVertex 3  ( addr ,    EdgeShape . vertex )  ;", "vec . x    =    EdgeShape . vertex [  0  ]  ;", "vec . y    =    EdgeShape . vertex [  1  ]  ;", "}", "METHOD_END"], "methodName": ["getVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "return   jniHasVertex 0  ( addr )  ;", "}", "METHOD_END"], "methodName": ["hasVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "return   jniHasVertex 3  ( addr )  ;", "}", "METHOD_END"], "methodName": ["hasVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "set ( v 1  . x ,    v 1  . y ,    v 2  . x ,    v 2  . y )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniSet ( addr ,    v 1 X ,    v 1 Y ,    v 2 X ,    v 2 Y )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniSetHasVertex 0  ( addr ,    hasVertex 0  )  ;", "}", "METHOD_END"], "methodName": ["setHasVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniSetHasVertex 3  ( addr ,    hasVertex 3  )  ;", "}", "METHOD_END"], "methodName": ["setHasVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniSetVertex 0  ( addr ,    vec . x ,    vec . y )  ;", "}", "METHOD_END"], "methodName": ["setVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniSetVertex 0  ( addr ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["setVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniSetVertex 3  ( addr ,    vec . x ,    vec . y )  ;", "}", "METHOD_END"], "methodName": ["setVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "jniSetVertex 3  ( addr ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["setVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "return   body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   jniGetDensity ( addr )  ;", "}", "METHOD_END"], "methodName": ["getDensity"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniGetFilterData ( addr ,    tmp )  ;", "filter . maskBits    =    tmp [  0  ]  ;", "filter . categoryBits    =    tmp [  1  ]  ;", "filter . groupIndex    =    tmp [  2  ]  ;", "ren   filter ;", "}", "METHOD_END"], "methodName": ["getFilterData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   jniGetFriction ( addr )  ;", "}", "METHOD_END"], "methodName": ["getFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   jniGetRestitution ( addr )  ;", "}", "METHOD_END"], "methodName": ["getRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shape )     =  =    null )     {", "long   shapeAddr    =    jniGetShape ( addr )  ;", "if    ( shapeAddr    =  =     0  )", "throw   new   GdxRuntimeException (  \" Null   shape   address !  \"  )  ;", "int   type    =    Shape . jniGetType ( shapeAddr )  ;", "switch    ( type )     {", "case    0     :", "shape    =    new   CircleShape ( shapeAddr )  ;", "break ;", "case    1     :", "shape    =    new   EdgeShape ( shapeAddr )  ;", "break ;", "case    2     :", "shape    =    new   PolygonShape ( shapeAddr )  ;", "break ;", "case    3     :", "shape    =    new   ChainShape ( shapeAddr )  ;", "break ;", "default    :", "throw   new   GdxRuntimeException (  \" Unknown   shape   type !  \"  )  ;", "}", "}", "ren   shape ;", "}", "METHOD_END"], "methodName": ["getShape"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "int   type    =    jniGetType ( addr )  ;", "switch    ( type )     {", "case    0     :", "ren   Shape . Type . Circle ;", "case    1     :", "ren   Shape . Type . Edge ;", "case    2     :", "ren   Shape . Type . Polygon ;", "case    3     :", "ren   Shape . Type . Chain ;", "default    :", "throw   new   GdxRuntimeException (  \" Unknown   shape   type !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   jniIsSensor ( addr )  ;", "}", "METHOD_END"], "methodName": ["isSensor"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniRefilter ( addr )  ;", "}", "METHOD_END"], "methodName": ["refilter"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "this . body    =    body ;", "this . addr    =    addr ;", "this . shape    =    null ;", "this . userData    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniSetDensity ( addr ,    density )  ;", "}", "METHOD_END"], "methodName": ["setDensity"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniSetFilterData ( addr ,    filter . categoryBits ,    filter . maskBits ,    filter . groupIndex )  ;", "}", "METHOD_END"], "methodName": ["setFilterData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniSetFriction ( addr ,    friction )  ;", "}", "METHOD_END"], "methodName": ["setFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniSetRestitution ( addr ,    restitution )  ;", "}", "METHOD_END"], "methodName": ["setRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniSetSensor ( addr ,    sensor )  ;", "}", "METHOD_END"], "methodName": ["setSensor"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   jniTestPoint ( addr ,    p . x ,    p . y )  ;", "}", "METHOD_END"], "methodName": ["testPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   jniTestPoint ( addr ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["testPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "jniGetAnchorA ( addr ,    tmp )  ;", "anchorA . x    =    tmp [  0  ]  ;", "anchorA . y    =    tmp [  1  ]  ;", "return   anchorA ;", "}", "METHOD_END"], "methodName": ["getAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "jniGetAnchorB ( addr ,    tmp )  ;", "anchorB . x    =    tmp [  0  ]  ;", "anchorB . y    =    tmp [  1  ]  ;", "return   anchorB ;", "}", "METHOD_END"], "methodName": ["getAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   world . bodies . get ( jniGetBodyA ( addr )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyA"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   world . bodies . get ( jniGetBodyB ( addr )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyB"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetCollideConnected ( addr )  ;", "}", "METHOD_END"], "methodName": ["getCollideConnected"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "jniGetReactionForce ( addr ,    inv _ dt ,    tmp )  ;", "reactionForce . x    =    tmp [  0  ]  ;", "reactionForce . y    =    tmp [  1  ]  ;", "return   reactionForce ;", "}", "METHOD_END"], "methodName": ["getReactionForce"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetReactionTorque ( addr ,    inv _ dt )  ;", "}", "METHOD_END"], "methodName": ["getReactionTorque"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "int   type    =    jniGetType ( addr )  ;", "if    (  ( type    >     0  )     &  &     ( type    <    DefType . valueTypes . length )  )  )", "returnDefType . valueTypes [ type ]  ;", "else", "returnDefType . Unknown ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   jniIsActive ( addr )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalNormal ( addr ,    tmpFloat )  ;", "localNormal . set ( tmpFloat [  0  ]  ,    tmpFloat [  1  ]  )  ;", "return   localNormal ;", "}", "METHOD_END"], "methodName": ["getLocalNormal"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalPoint ( addr ,    tmpFloat )  ;", "localPoint . set ( tmpFloat [  0  ]  ,    tmpFloat [  1  ]  )  ;", "return   localPoint ;", "}", "METHOD_END"], "methodName": ["getLocalPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "return   jniGetPointCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getPointCount"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "int   count    =    jniGetPointCount ( addr )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "int   contactID    =    jniGetPoint ( addr ,    tmpFloat ,    i )  ;", "ManifolPoint   point    =    points [ i ]  ;", "point . contactID    =    contactID ;", "point . localPoint . set ( tmpFloat [  0  ]  ,    tmpFloat [  1  ]  )  ;", "point . normalImpulse    =    tmpFloat [  2  ]  ;", "point . tangentImpulse    =    tmpFloat [  3  ]  ;", "}", "return   points ;", "}", "METHOD_END"], "methodName": ["getPoints"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "int   type    =    jniGetType ( addr )  ;", "if    ( type    =  =     0  )", "return   ManifolType . Circle ;", "if    ( type    =  =     1  )", "return   ManifolType . FaceA ;", "if    ( type    =  =     2  )", "return   ManifolType . FaceB ;", "return   ManifolType . Circle ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "jniGetVertex ( addr ,    index ,    PolygonShape . verts )  ;", "vertex . x    =    PolygonShape . verts [  0  ]  ;", "vertex . y    =    PolygonShape . verts [  1  ]  ;", "}", "METHOD_END"], "methodName": ["getVertex"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return   jniGetVertexCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "float [  ]    verts    =    new   float [  ( vertices . length )     *     2  ]  ;", "for    ( int   i    =     0  ,    j    =     0  ;    i    <     (  ( vertices . length )     *     2  )  ;    i    +  =     2     ,    j +  +  )     {", "verts [ i ]     =    vertices [ j ]  . x ;", "verts [  ( i    +     1  )  ]     =    vertices [ j ]  . y ;", "}", "jniSet ( addr ,    verts ,     0  ,    verts . length )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "jniSet ( addr ,    vertices ,     0  ,    vertices . length )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "jniSet ( addr ,    vertices ,    offset ,    len )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "jniSetAsBox ( addr ,    hx ,    hy )  ;", "}", "METHOD_END"], "methodName": ["setAsBox"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "jniSetAsBox ( addr ,    hx ,    hy ,    center . x ,    center . y ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setAsBox"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "jniDispose ( addr )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.physics.box2d.Shape"}, {"methodBody": ["METHOD_START", "{", "return   jniGetChildCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getChildCount"], "fileName": "com.badlogic.gdx.physics.box2d.Shape"}, {"methodBody": ["METHOD_START", "{", "return   jniGetRadius ( addr )  ;", "}", "METHOD_END"], "methodName": ["getRadius"], "fileName": "com.badlogic.gdx.physics.box2d.Shape"}, {"methodBody": ["METHOD_START", "{", "jniSetRadius ( addr ,    radius )  ;", "}", "METHOD_END"], "methodName": ["setRadius"], "fileName": "com.badlogic.gdx.physics.box2d.Shape"}, {"methodBody": ["METHOD_START", "{", "return   orientation . set ( vals [ Transform . COS ]  ,    vals [ Transform . SIN ]  )  ;", "}", "METHOD_END"], "methodName": ["getOrientation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "return   position . set ( vals [  0  ]  ,    vals [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . atan 2  ( vals [ Transform . SIN ]  ,    vals [ Transform . COS ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  ( vals [ Transform . POS _ X ]  )     +     (  ( vals [ Transform . COS ]  )     *     ( v . x )  )  )     +     (  (  -  ( vals [ Transform . SIN ]  )  )     *     ( v . y )  )  ;", "float   y    =     (  ( vals [ Transform . POS _ Y ]  )     +     (  ( vals [ Transform . SIN ]  )     *     ( v . x )  )  )     +     (  ( vals [ Transform . COS ]  )     *     ( v . y )  )  ;", "v . x    =    x ;", "v . y    =    y ;", "return   v ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "this . vals [ Transform . COS ]     =    orientation . x ;", "this . vals [ Transform . SIN ]     =    orientation . y ;", "}", "METHOD_END"], "methodName": ["setOrientation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "this . vals [ Transform . POS _ X ]     =    pos . x ;", "this . vals [ Transform . POS _ Y ]     =    pos . y ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "float   c    =     (  ( float )     ( Math . cos ( angle )  )  )  ;", "float   s    =     (  ( float )     ( Math . sin ( angle )  )  )  ;", "vals [  . COS ]     =    c ;", "vals [  . SIN ]     =    s ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "queryCallback    =    callback ;", "jniQueryAABB ( addr ,    lowerX ,    lowerY ,    upperX ,    upperY )  ;", "}", "METHOD_END"], "methodName": ["QueryAABB"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "contact . addr    =    contactAddr ;", "if    (  ( contactListener )     !  =    null )", "contactListener . beginContact ( contact )  ;", "}", "METHOD_END"], "methodName": ["beginContact"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniClearForces ( addr )  ;", "}", "METHOD_END"], "methodName": ["clearForces"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contactFilter )     !  =    null )", "return   contactFilter . shouldCollide ( fixtures . get ( fixtureA )  ,    fixtures . get ( fixtureB )  )  ;", "else    {", "Filter   filterA    =    fixtures . get ( fixtureA )  . getFilterData (  )  ;", "Filter   filterB    =    fixtures . get ( fixtureB )  . getFilterData (  )  ;", "if    (  (  ( filterA . groupIndex )     =  =     ( filterB . groupIndex )  )     &  &     (  ( filterA . groupIndex )     !  =     0  )  )     {", "return    ( filterA . groupIndex )     >     0  ;", "}", "boolean   collide    =     (  (  ( filterA . maskBits )     &     ( filterB . categoryBits )  )     !  =     0  )     &  &     (  (  ( filterA . categoryBits )     &     ( filterB . maskBits )  )     !  =     0  )  ;", "return   collide ;", "}", "}", "METHOD_END"], "methodName": ["contactFilter"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "long   bodyAddr    =    jniCreateBody ( addr ,    def . type . getValue (  )  ,    def . position . x ,    def . position . y ,    def . angle ,    def . linearVelocity . x ,    def . linearVelocity . y ,    def . angularVelocity ,    def . linearDamping ,    def . angularDamping ,    def . allowSleep ,    def . awake ,    def . fixedRotation ,    def . bullet ,    def . active ,    def . gravityScale )  ;", "Body   body    =    freeBodies . obtain (  )  ;", "body . reset ( bodyAddr )  ;", "thidies . put ( body . addr ,    body )  ;", "return   body ;", "}", "METHOD_END"], "methodName": ["createBody"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "long   jointAddr    =    createProperJoint ( def )  ;", "Joint   joint    =    null ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . DistanceJoint )  )", "joint    =    new   joints . DistanceJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . FrictionJoint )  )", "joint    =    new   joints . FrictionJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . GearJoint )  )", "joint    =    new   joints . GearJoint ( this ,    jointAddr ,     (  ( joints . GearJointDef )     ( def )  )  . joint 1  ,     (  ( joints . GearJointDef )     ( def )  )  . joint 2  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . MotorJoint )  )", "joint    =    new   joints . MotorJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . MouseJoint )  )", "joint    =    new   joints . MouseJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . PrismaticJoint )  )", "joint    =    new   joints . PrismaticJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . PulleyJoint )  )", "joint    =    new   joints . PulleyJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . RevoluteJoint )  )", "joint    =    new   joints . RevoluteJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . RopeJoint )  )", "joint    =    new   joints . RopeJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . WeldJoint )  )", "joint    =    new   joints . WeldJoint ( this ,    jointAddr )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . WheelJoint )  )", "joint    =    new   joints . WheelJoint ( this ,    jointAddr )  ;", "if    ( joint    !  =    null )", "joints . put ( joint . addr ,    joint )  ;", "JointEdge   jointEdgeA    =    new   JointEdge ( def . bodyB ,    joint )  ;", "JointEdge   jointEdgeB    =    new   JointEdge ( def . bodyA ,    joint )  ;", "joint . jointEdgeA    =    jointEdgeA ;", "joint . jointEdgeB    =    jointEdgeB ;", "def . bodyA . joints . add ( jointEdgeA )  ;", "def . bodyB . joints . add ( jointEdgeB )  ;", "return   joint ;", "}", "METHOD_END"], "methodName": ["createJoint"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "if    (  ( def . type )     =  =     ( JointDef . JointType . DistanceJoint )  )     {", "DistanceJointDef   d    =     (  ( DistanceJointDef )     ( def )  )  ;", "return   jniCreateDistanceJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . length ,    d . frequencyHz ,    d . dampingRatio )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . FrictionJoint )  )     {", "FrictionJointDef   d    =     (  ( FrictionJointDef )     ( def )  )  ;", "return   jniCreateFrictionJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . maxForce ,    d . maxTorque )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . GearJoint )  )     {", "GearJointDef   d    =     (  ( GearJointDef )     ( def )  )  ;", "return   jniCreateGearJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . joint 1  . addr ,    d . joint 2  . addr ,    d . ratio )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . MotorJoint )  )     {", "MotorJointDef   d    =     (  ( MotorJointDef )     ( def )  )  ;", "return   jniCreateMotorJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . linearOffset . x ,    d . linearOffset . y ,    d . angularOffset ,    d . maxForce ,    d . maxTorque ,    d . correctionFactor )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . MouseJoint )  )     {", "MouseJointDef   d    =     (  ( MouseJointDef )     ( def )  )  ;", "return   jniCreateMouseJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . target . x ,    d . target . y ,    d . maxForce ,    d . frequencyHz ,    d . dampingRatio )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . PrismaticJoint )  )     {", "PrismaticJointDef   d    =     (  ( PrismaticJointDef )     ( def )  )  ;", "return   jniCreatePrismaticJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . localAxisA . x ,    d . localAxisA . y ,    d . referenceAngle ,    d . enableLimit ,    d . lowerTranslation ,    d . upperTranslation ,    d . enableMotor ,    d . maxMotorForce ,    d . motorSpeed )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . PulleyJoint )  )     {", "PulleyJointDef   d    =     (  ( PulleyJointDef )     ( def )  )  ;", "return   jniCreatePulleyJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . groundAnchorA . x ,    d . groundAnchorA . y ,    d . groundAnchorB . x ,    d . groundAnchorB . y ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . lengthA ,    d . lengthB ,    d . ratio )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . RevoluteJoint )  )     {", "RevoluteJointDef   d    =     (  ( RevoluteJointDef )     ( def )  )  ;", "return   jniCreateRevoluteJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . referenceAngle ,    d . enableLimit ,    d . lowerAngle ,    d . upperAngle ,    d . enableMotor ,    d . motorSpeed ,    d . maxMotorTorque )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . RopeJoint )  )     {", "RopeJointDef   d    =     (  ( RopeJointDef )     ( def )  )  ;", "return   jniCreateRopeJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . maxLength )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . WeldJoint )  )     {", "WeldJointDef   d    =     (  ( WeldJointDef )     ( def )  )  ;", "return   jniCreateWeldJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . referenceAngle ,    d . frequencyHz ,    d . dampingRatio )  ;", "}", "if    (  ( def . type )     =  =     ( JointDef . JointType . WheelJoint )  )     {", "WheelJointDef   d    =     (  ( WheelJointDef )     ( def )  )  ;", "return   jniCreateWheelJoint ( addr ,    ddyA . addr ,    ddyB . addr ,    d . collideConnected ,    d . localAnchorA . x ,    d . localAnchorA . y ,    d . localAnchorB . x ,    d . localAnchorB . y ,    d . localAxisA . x ,    d . localAxisA . y ,    d . enableMotor ,    d . maxMotorTorque ,    d . motorSpeed ,    d . frequencyHz ,    d . dampingRatio )  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["createProperJoint"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniDeactivateBody ( addr ,    body . addr )  ;", "}", "METHOD_END"], "methodName": ["deactivateBody"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "Array < JointEdge >    jointList    =    body . getJointList (  )  ;", "while    (  ( jointList . size )     >     0  )", "destroyJoint ( body . getJointList (  )  . get (  0  )  . joint )  ;", "jniDestroyBody ( addr ,    body . addr )  ;", "body . setUserData ( null )  ;", "thidies . remove ( body . addr )  ;", "Array < Fixture >    fixtureList    =    body . getFixtureList (  )  ;", "while    (  ( fixtureList . size )     >     0  )     {", "Fixture   fixtureToDelete    =    fixtureList . removeIndex (  0  )  ;", "this . fixtures . remove ( fixtureToDelete . addr )  . setUserData ( null )  ;", "freeFixtures . free ( fixtureToDelete )  ;", "}", "freeBodies . free ( body )  ;", "}", "METHOD_END"], "methodName": ["destroyBody"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniDestroyFixture ( addr ,    body . addr ,    fixture . addr )  ;", "}", "METHOD_END"], "methodName": ["destroyFixture"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "joint . tUrData ( null )  ;", "jointremove ( joint . addr )  ;", "joint . jointEdgeA . other . jointremoveValue ( joint . jointEdgeB ,    true )  ;", "joint . jointEdgeB . other . jointremoveValue ( joint . jointEdgeA ,    true )  ;", "jniDeroyJoint ( addr ,    joint . addr )  ;", "}", "METHOD_END"], "methodName": ["destroyJoint"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniDispose ( addr )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "contact . addr    =    contactAddr ;", "if    (  ( contactListener )     !  =    null )", "contactListener . endContact ( contact )  ;", "}", "METHOD_END"], "methodName": ["endContact"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   jniGetAutoClearForces ( addr )  ;", "}", "METHOD_END"], "methodName": ["getAutoClearForces"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "bodies . clear (  )  ;", "bodies . ensureCapacity ( thidies . size )  ;", "for    ( Iterator < Body >    iter    =    thidies . values (  )  ;    iter . hasNext (  )  ;  )     {", "bodies . add ( iter . next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getBodies"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   jniGetBodyCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getBodyCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   jniGetContactCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getContactCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "int   numContacts    =    getContactCount (  )  ;", "if    ( numContacts    >     ( ntactAddrs . length )  )     {", "int   newSize    =     2     *    numContacts ;", "ntactAddrs    =    new   long [ newSize ]  ;", "ntacts . ensureCapacity ( newSize )  ;", "freeContacts . ensureCapacity ( newSize )  ;", "}", "if    ( numContacts    >     ( freeContacts . size )  )     {", "int   freeConts    =    freeContacts . size ;", "for    ( int   i    =     0  ;    i    <     ( numContacts    -    freeConts )  ;    i +  +  )", "freeContacts . add ( new   Contact ( this ,     0  )  )  ;", "}", "jniGetContactList ( addr ,    ntactAddrs )  ;", "ntacts . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    numContacts ;    i +  +  )     {", "Contact   ntact    =    freeContacts . get ( i )  ;", "ntact . addr    =    ntactAddrs [ i ]  ;", "ntacts . add ( ntact )  ;", "}", "return   ntacts ;", "}", "METHOD_END"], "methodName": ["getContactList"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   fixtures . size ;", "}", "METHOD_END"], "methodName": ["getFixtureCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "fixtures . clear (  )  ;", "fixtures . ensureCapacity ( this . fixtures . size )  ;", "for    ( Iterator < Fixture >    iter    =    this . fixtures . values (  )  ;    iter . hasNext (  )  ;  )     {", "fixtures . add ( iter . next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFixtures"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniGetGravity ( addr ,    tmpGravity )  ;", "gravity . x    =    tmpGravity [  0  ]  ;", "gravity . y    =    tmpGravity [  1  ]  ;", "return   gravity ;", "}", "METHOD_END"], "methodName": ["getGravity"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   jniGetJointcount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getJointCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "joints . clear (  )  ;", "joints . ensureCapacity ( this . joints . size )  ;", "for    ( Iterator < Joint >    iter    =    this . joints . values (  )  ;    iter . hasNext (  )  ;  )     {", "joints . add ( iter . next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getJoints"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   jniGetProxyCount ( addr )  ;", "}", "METHOD_END"], "methodName": ["getProxyCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   jniIsLocked ( addr )  ;", "}", "METHOD_END"], "methodName": ["isLocked"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "contact . addr    =    contactAddr ;", "impulse . addr    =    impulseAddr ;", "if    (  ( contactListener )     !  =    null )", "contactListener . postSolve ( contact ,    impulse )  ;", "}", "METHOD_END"], "methodName": ["postSolve"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "contact . addr    =    contactAddr ;", "manifold . addr    =    manifoldAddr ;", "if    (  ( contactListener )     !  =    null )", "contactListener . preSolve ( contact ,    manifold )  ;", "}", "METHOD_END"], "methodName": ["preSolve"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "rayCast ( callback ,    point 1  . x ,    point 1  . y ,    point 2  . x ,    point 2  . y )  ;", "}", "METHOD_END"], "methodName": ["rayCast"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "rayCastCallback    =    callback ;", "jniRayCast ( addr ,    point 1 X ,    point 1 Y ,    point 2 X ,    point 2 Y )  ;", "}", "METHOD_END"], "methodName": ["rayCast"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "if    (  ( queryCallback )     !  =    null )", "return   queryCallback . reportFixture ( fixtures . get ( addr )  )  ;", "else", "return   false ;", "}", "METHOD_END"], "methodName": ["reportFixture"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "if    (  ( rayCastCallback )     !  =    null )     {", "rayPoint . x    =    pX ;", "rayPoint . y    =    pY ;", "rayNormal . x    =    nX ;", "rayNormal . y    =    nY ;", "return   rayCastCallback . reportRayFixture ( fixtures . get ( addr )  ,    rayPoint ,    rayNormal ,    fraction )  ;", "} else    {", "return    0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["reportRayFixture"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniSetAutoClearForces ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setAutoClearForces"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "this . contactFilter    =    filter ;", "setUseDefaultContactFilter (  ( filter    =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["setContactFilter"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "this . contactListener    =    listener ;", "}", "METHOD_END"], "methodName": ["setContactListener"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniSetContiousPhysics ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setContinuousPhysics"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniSetGravity ( addr ,    gravity . x ,    gravity . y )  ;", "}", "METHOD_END"], "methodName": ["setGravity"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniSetWarmStarting ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["setWarmStarting"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "jniStep ( addr ,    timeStep ,    velocityIterations ,    positionIterations )  ;", "}", "METHOD_END"], "methodName": ["step"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   normal ;", "}", "METHOD_END"], "methodName": ["getNormal"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   numContactPoints ;", "}", "METHOD_END"], "methodName": ["getNumberOfContactPoints"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   points ;", "}", "METHOD_END"], "methodName": ["getPoints"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   separations ;", "}", "METHOD_END"], "methodName": ["getSeparations"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   jniGetDampingRatio ( addr )  ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetFrequency ( addr )  ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetLength ( addr )  ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorA ( addr ,    tmp )  ;", "localAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorB ( addr ,    tmp )  ;", "localAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetDampingRatio ( addr ,    ratio )  ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetFrequency ( addr ,    hz )  ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetLength ( addr ,    length )  ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "this . localAnchorA . set ( bodyA . getLocalPoint ( anchorA )  )  ;", "this . localAnchorB . set ( bodyB . getLocalPoint ( anchorB )  )  ;", "this . length    =    anchorA . dst ( anchorB )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJointDef"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorA ( addr ,    tmp )  ;", "localAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorB ( addr ,    tmp )  ;", "localAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxForce ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxTorque ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxForce ( addr ,    force )  ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxTorque ( addr ,    torque )  ;", "}", "METHOD_END"], "methodName": ["setMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJointDef"}, {"methodBody": ["METHOD_START", "{", "return   joint 1  ;", "}", "METHOD_END"], "methodName": ["getJoint1"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint 2  ;", "}", "METHOD_END"], "methodName": ["getJoint2"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetRatio ( addr )  ;", "}", "METHOD_END"], "methodName": ["getRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetRatio ( addr ,    ratio )  ;", "}", "METHOD_END"], "methodName": ["setRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetAngularOffset ( addr )  ;", "}", "METHOD_END"], "methodName": ["getAngularOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetCorrectionFactor ( addr )  ;", "}", "METHOD_END"], "methodName": ["getCorrectionFactor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLinearOffset ( addr ,    tmp )  ;", "linearOffset . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   linearOffset ;", "}", "METHOD_END"], "methodName": ["getLinearOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxForce ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxTorque ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetAngularOffset ( addr ,    angularOffset )  ;", "}", "METHOD_END"], "methodName": ["setAngularOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetCorrectionFactor ( addr ,    correctionFactor )  ;", "}", "METHOD_END"], "methodName": ["setCorrectionFactor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetLinearOffset ( addr ,    linearOffset . x ,    linearOffset . y )  ;", "}", "METHOD_END"], "methodName": ["setLinearOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxForce ( addr ,    maxForce )  ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxTorque ( addr ,    maxTorque )  ;", "}", "METHOD_END"], "methodName": ["setMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    body 1  ;", "this . bodyB    =    body 2  ;", "this . linearOffset . set ( bodyA . getLocalPoint ( bodyB . getPosition (  )  )  )  ;", "this . angularOffset    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJointDef"}, {"methodBody": ["METHOD_START", "{", "return   jniGetDampingRatio ( addr )  ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetFrequency ( addr )  ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxForce ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetTarget ( addr ,    tmp )  ;", "target . x    =    tmp [  0  ]  ;", "target . y    =    tmp [  1  ]  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetDampingRatio ( addr ,    ratio )  ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetFrequency ( addr ,    hz )  ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxForce ( addr ,    force )  ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetTarget ( addr ,    target . x ,    target . y )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "jniEnableLimit ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["enableLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "jniEnableMotor ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetJointSpeed ( addr )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetJointTranslation ( addr )  ;", "}", "METHOD_END"], "methodName": ["getJointTranslation"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorA ( addr ,    tmp )  ;", "localAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorB ( addr ,    tmp )  ;", "localAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAxisA ( addr ,    tmp )  ;", "localAxisA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAxisA ;", "}", "METHOD_END"], "methodName": ["getLocalAxisA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetLowerLimit ( addr )  ;", "}", "METHOD_END"], "methodName": ["getLowerLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxMotorForce ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxMotorForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMotorForce ( addr ,    invDt )  ;", "}", "METHOD_END"], "methodName": ["getMotorForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMotorSpeed ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetReferenceAngle ( addr )  ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetUpperLimit ( addr )  ;", "}", "METHOD_END"], "methodName": ["getUpperLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniIsLimitEnabled ( addr )  ;", "}", "METHOD_END"], "methodName": ["isLimitEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniIsMotorEnabled ( addr )  ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetLimits ( addr ,    lower ,    upper )  ;", "}", "METHOD_END"], "methodName": ["setLimits"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxMotorForce ( addr ,    force )  ;", "}", "METHOD_END"], "methodName": ["setMaxMotorForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMotorSpeed ( addr ,    speed )  ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "localAxisA . set ( bodyA . getLocalVector ( axis )  )  ;", "referenceAngle    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJointDef"}, {"methodBody": ["METHOD_START", "{", "jniGetGroundAnchorA ( addr ,    tmp )  ;", "groundAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   groundAnchorA ;", "}", "METHOD_END"], "methodName": ["getGroundAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetGroundAnchorB ( addr ,    tmp )  ;", "groundAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   groundAnchorB ;", "}", "METHOD_END"], "methodName": ["getGroundAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetLength 1  ( addr )  ;", "}", "METHOD_END"], "methodName": ["getLength1"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetLength 2  ( addr )  ;", "}", "METHOD_END"], "methodName": ["getLength2"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetRatio ( addr )  ;", "}", "METHOD_END"], "methodName": ["getRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "this . groundAnchorA . set ( groundAnchorA )  ;", "this . groundAnchorB . set ( groundAnchorB )  ;", "this . localAnchorA . set ( bodyA . getLocalPoint ( anchorA )  )  ;", "this . localAnchorB . set ( bodyB . getLocalPoint ( anchorB )  )  ;", "lengthA    =    anchorA . dst ( groundAnchorA )  ;", "lengthB    =    anchorB . dst ( groundAnchorB )  ;", "this . ratio    =    ratio ;", "float   C    =     ( lengthA )     +     ( ratio    *     ( lengthB )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJointDef"}, {"methodBody": ["METHOD_START", "{", "jniEnableLimit ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["enableLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "jniEnableMotor ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetJointAngle ( addr )  ;", "}", "METHOD_END"], "methodName": ["getJointAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetJointSpeed ( addr )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorA ( addr ,    tmp )  ;", "localAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorB ( addr ,    tmp )  ;", "localAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetLowerLimit ( addr )  ;", "}", "METHOD_END"], "methodName": ["getLowerLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxMotorTorque ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMotorSpeed ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMotorTorque ( addr ,    invDt )  ;", "}", "METHOD_END"], "methodName": ["getMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetReferenceAngle ( addr )  ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetUpperLimit ( addr )  ;", "}", "METHOD_END"], "methodName": ["getUpperLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniIsLimitEnabled ( addr )  ;", "}", "METHOD_END"], "methodName": ["isLimitEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniIsMotorEnabled ( addr )  ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetLimits ( addr ,    lower ,    upper )  ;", "}", "METHOD_END"], "methodName": ["setLimits"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxMotorTorque ( addr ,    torque )  ;", "}", "METHOD_END"], "methodName": ["setMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMotorSpeed ( addr ,    speed )  ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "referenceAngle    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJointDef"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorA ( addr ,    tmp )  ;", "localAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorB ( addr ,    tmp )  ;", "localAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxLength ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxLength ( addr ,    length )  ;", "}", "METHOD_END"], "methodName": ["setMaxLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetDampingRatio ( addr )  ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetFrequency ( addr )  ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorA ( addr ,    tmp )  ;", "localAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorB ( addr ,    tmp )  ;", "localAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetReferenceAngle ( addr )  ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetDampingRatio ( addr ,    ratio )  ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetFrequency ( addr ,    hz )  ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    body 1  ;", "this . bodyB    =    body 2  ;", "this . localAnchorA . set ( body 1  . getLocalPoint ( anchor )  )  ;", "this . localAnchorB . set ( body 2  . getLocalPoint ( anchor )  )  ;", "referenceAngle    =     ( body 2  . getAngle (  )  )     -     ( body 1  . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJointDef"}, {"methodBody": ["METHOD_START", "{", "jniEnableMotor ( addr ,    flag )  ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetJointSpeed ( addr )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetJointTranslation ( addr )  ;", "}", "METHOD_END"], "methodName": ["getJointTranslation"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorA ( addr ,    tmp )  ;", "localAnchorA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAnchorB ( addr ,    tmp )  ;", "localAnchorB . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "jniGetLocalAxisA ( addr ,    tmp )  ;", "localAxisA . set ( tmp [  0  ]  ,    tmp [  1  ]  )  ;", "return   localAxisA ;", "}", "METHOD_END"], "methodName": ["getLocalAxisA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMaxMotorTorque ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMotorSpeed ( addr )  ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetMotorTorque ( addr ,    invDt )  ;", "}", "METHOD_END"], "methodName": ["getMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetSpringDampingRatio ( addr )  ;", "}", "METHOD_END"], "methodName": ["getSpringDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniGetSpringFrequencyHz ( addr )  ;", "}", "METHOD_END"], "methodName": ["getSpringFrequencyHz"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   jniIsMotorEnabled ( addr )  ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMaxMotorTorque ( addr ,    torque )  ;", "}", "METHOD_END"], "methodName": ["setMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetMotorSpeed ( addr ,    speed )  ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetSpringDampingRatio ( addr ,    ratio )  ;", "}", "METHOD_END"], "methodName": ["setSpringDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "jniSetSpringFrequencyHz ( addr ,    hz )  ;", "}", "METHOD_END"], "methodName": ["setSpringFrequencyHz"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "localAxisA . set ( bodyA . getLocalVector ( axis )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJointDef"}, {"methodBody": ["METHOD_START", "{", "BuildTarget   win 3  2     =    BuildTarget . newDefaultTarget ( Windows ,    false )  ;", "BuildTarget   win 6  4     =    BuildTarget . newDefaultTarget ( Windows ,    true )  ;", "BuildTarget   lin 3  2     =    BuildTarget . newDefaultTarget ( Linux ,    false )  ;", "BuildTarget   lin 6  4     =    BuildTarget . newDefaultTarget ( Linux ,    true )  ;", "BuildTarget   android    =    BuildTarget . newDefaultTarget ( Android ,    false )  ;", "BuildTarget   mac 3  2     =    BuildTarget . newDefaultTarget ( MacOsX ,    false )  ;", "BuildTarget   mac 6  4     =    BuildTarget . newDefaultTarget ( MacOsX ,    true )  ;", "BuildTarget   ios    =    BuildTarget . newDefaultTarget ( IOS ,    false )  ;", "new   NativeCodeGenerator (  )  . generate (  \" src \"  ,     (  (  \" bin \"     +     ( File . pathSeparator )  )     +     \"  .  .  /  .  .  /  .  .  / gdx / bin \"  )  ,     \" jni \"  )  ;", "new   AntScriptGenerator (  )  . generate ( new   BuildConfig (  \" gdx - box 2 d \"  )  ,    win 3  2  ,    win 6  4  ,    lin 3  2  ,    lin 6  4  ,    mac 3  2  ,    mac 6  4  ,    android ,    ios )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.physics.box2d.utils.Box2DBuild"}]