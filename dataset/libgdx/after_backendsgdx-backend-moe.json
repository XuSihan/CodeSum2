[{"methodBody": ["METHOD_START", "{", "viewControllerListener    =    listener ;", "}", "METHOD_END"], "methodName": ["addViewControllerListener"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   IOSGraphics . alloc (  )  . init ( scale ,    this ,    config ,    input ,    config . useGL 3  0  )  ;", "}", "METHOD_END"], "methodName": ["createGraphics"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   new   IOSInput ( this )  ;", "}", "METHOD_END"], "methodName": ["createInput"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "app . debug (  \" IOSApplication \"  ,     \" resumed \"  )  ;", "OALAudioSession   audioSession    =    OALAudioSession . sharedInstance (  )  ;", "if    ( audioSession    !  =    null )     {", "audioSession . forceEndInterruption (  )  ;", "}", "if    ( config . allowIpod )     {", "OALSimpleAudio   audio    =    OALSimpleAudio . sharedInstance (  )  ;", "if    ( audio    !  =    null )     {", "audio . setUseHardwareIfAvailable ( false )  ;", "}", "}", "graphics . makeCurrent (  )  ;", "graphics . resume (  )  ;", "}", "METHOD_END"], "methodName": ["didBecomeActive"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "this . uiApp    =    uiApp ;", "init (  )  ;", "this . uiWindow    =    UIWindow . alloc (  )  . initWithFrame ( UIScreen . mainScreen (  )  . bounds (  )  )  ;", "this . uiWindow . setRootViewController ( this . graphics . viewController )  ;", "this . uiWindow . makeKeyAndVisible (  )  ;", "app . debug (  \"  \"  ,     \" created \"  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["didFinishLaunching"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "final   CGRect   screenBounds    =    getOriginalBounds (  )  ;", "final   long   statusBarOrientation    =    getStatusBarOrientation (  )  ;", "double   screenWidth    =    screenBounds . size (  )  . width (  )  ;", "double   screenHeight    =    screenBounds . size (  )  . height (  )  ;", "if    (  ( statusBarOrientation    =  =     ( UIInterfaceOrientation . LandscapeLeft )  )     |  |     ( statusBarOrientation    =  =     ( UIInterfaceOrientation . LandscapeRight )  )  )     {", "if    ( screenHeight    >    screenWidth )     {", "debug (  \"  \"  ,     (  (  (  (  \" Switching   reported   width   and   height    ( w =  \"     +    screenWidth )     +     \"    h =  \"  )     +    screenHeight )     +     \"  )  \"  )  )  ;", "double   tmp    =    screenHeight ;", "screenHeight    =    screenWidth ;", "screenWidth    =    tmp ;", "}", "}", "screenWidth    *  =    displayScaleFactor ;", "screenHeight    *  =    displayScaleFactor ;", "double   statusBarHeight    =    getStatusBarHeight ( screenHeight )  ;", "debug (  \"  \"  ,     (  (  (  \" Total   computed   bounds   are   w =  \"     +    screenWidth )     +     \"    h =  \"  )     +    screenHeight )  )  ;", "return   lastScreenBounds    =    new   CGRect ( new   CGPoint (  0  ,    statusBarHeight )  ,    new   CGSize ( screenWidth ,    screenHeight )  )  ;", "}", "METHOD_END"], "methodName": ["getBounds"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  ( lastScreenBounds )     =  =    null )", "return   getBounds (  )  ;", "else", "return   lastScreenBounds ;", "}", "METHOD_END"], "methodName": ["getCachedBounds"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "String   systemVersion    =    apple . uikit . UIDevice . currentDevice (  )  . systemVersion (  )  ;", "int   version    =    Integer . parseInt ( systemVersion . split (  \"  \\  \\  .  \"  )  [  0  ]  )  ;", "return   version ;", "}", "METHOD_END"], "methodName": ["getIosVersion"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   UIScreen . mainScreen (  )  . bounds (  )  ;", "}", "METHOD_END"], "methodName": ["getOriginalBounds"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "final   CGRect   statusBarFrame    =    uiApp . statusBarFrame (  )  ;", "double   statusBarHeight    =    Math . min ( statusBarFrame . size (  )  . width (  )  ,    statusBarFrame . size (  )  . height (  )  )  ;", "if    ( statusBarHeight    !  =     0  .  0  )     {", "debug (  \"  \"  ,     (  (  \" Status   bar   is   visible    ( height    =     \"     +    statusBarHeight )     +     \"  )  \"  )  )  ;", "statusBarHeight    *  =    displayScaleFactor ;", "screenHeight    -  =    statusBarHeight ;", "} else    {", "debug (  \"  \"  ,     \" Status   bar   is   not   visible \"  )  ;", "}", "return   statusBarHeight ;", "}", "METHOD_END"], "methodName": ["getStatusBarHeight"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   uiApp . statusBarOrientation (  )  ;", "}", "METHOD_END"], "methodName": ["getStatusBarOrientation"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   graphics . viewController ;", "}", "METHOD_END"], "methodName": ["getUIViewController"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   uiWindow ;", "}", "METHOD_END"], "methodName": ["getUIWindow"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "setApplicationLogger ( new   IOSApplicationLogger (  )  )  ;", "Gdx . app    =    this ;", "UIApplication . sharedApplication (  )  . setIdleTimerDisabled ( config . preventScreenDimming )  ;", "app . debug (  \" IOSApplication \"  ,     (  \" iOS   version :     \"     +     ( UIDevice . currentDevice (  )  . systemVersion (  )  )  )  )  ;", "float   scale    =     (  ( float )     (  (  ( getIosVersion (  )  )     >  =     8  )     ?    UIScreen . mainScreen (  )  . nativeScale (  )     :    UIScreen . mainScreen (  )  . nativeScale (  )  )  )  ;", "if    ( scale    >  =     2  .  0 F )     {", "app . debug (  \" IOSApplication \"  ,     (  \" scale :     \"     +    scale )  )  ;", "if    (  ( UIDevice . currentDevice (  )  . userInterfaceIdiom (  )  )     =  =     ( UIUserInterfaceIdiom . Pad )  )     {", "displayScaleFactor    =     ( config . displayScaleLargeScreenIfRetina )     *    scale ;", "} else    {", "displayScaleFactor    =     ( config . displayScaleSmallScreenIfRetina )     *    scale ;", "}", "} else    {", "if    (  ( UIDevice . currentDevice (  )  . userInterfaceIdiom (  )  )     =  =     ( UIUserInterfaceIdiom . Pad )  )     {", "displayScaleFactor    =    config . displayScaleLargeScreenIfNonRetina ;", "} else    {", "displayScaleFactor    =    config . displayScaleSmallScreenIfNonRetina ;", "}", "}", "this . input    =    createInput (  )  ;", "this . graphics    =    createGraphics ( scale )  ;", "Gdx . gl    =    Gdx . gl 2  0     =    graphics . gl 2  0  ;", "Gdx . gl 3  0     =    graphics . gl 3  0  ;", "this . files    =    new   IOSFiles (  )  ;", "this . audio    =    new   IOSAudio ( config )  ;", "this . net    =    new   IOSNet ( this )  ;", "Gdx . files    =    this . files ;", "Gdx . graphics    =    this . graphics ;", "Gdx . audio    =    this . audio ;", "Gdx . input    =    this . input ;", "Gdx . net    =    this . net ;", "this . input . setupPeripherals (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "synchronized ( runnables )     {", "executedRunnables . clear (  )  ;", "executedRunnables . addAll ( runnables )  ;", "runnables . clear (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( executedRunnables . size )  ;    i +  +  )     {", "try    {", "executedRunnables . get ( i )  . run (  )  ;", "}    ch    ( Throwable   t )     {", "t . printStackTrace (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processRunnables"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "OALAudioSession   audioSession    =    OALAudioSession . sharedInstance (  )  ;", "if    ( audioSession    !  =    null )     {", "audioSession . forceEndInterrup (  )  ;", "}", "}", "METHOD_END"], "methodName": ["willEnterForeground"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "app . debug (  \" IOSApplication \"  ,     \" paused \"  )  ;", "graphics . makeCurrent (  )  ;", "graphics . pause (  )  ;", "gl . glFinish (  )  ;", "}", "METHOD_END"], "methodName": ["willResignActive"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "app . debug (  \" IOSApplication \"  ,     \" disposed \"  )  ;", "graphics . makeCurrent (  )  ;", "Array < LifecycleListener >    listeners    =    lifecycleListeners ;", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . pause (  )  ;", "}", "}", "listener . dispose (  )  ;", "gl . glFinish (  )  ;", "}", "METHOD_END"], "methodName": ["willTerminate"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "for    ( IOSDevice   device    :    IOSDevice . values (  )  )     {", "if    ( device . machineString . equalsIgnoreCase ( machineString )  )", "return   device ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDevice"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSDevice"}, {"methodBody": ["METHOD_START", "{", "initWithFrame ( bounds )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGLKView"}, {"methodBody": ["METHOD_START", "{", "this . graphics    =    graphics ;", "}", "METHOD_END"], "methodName": ["setGraphics"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGLKView"}, {"methodBody": ["METHOD_START", "{", "this . view    =    view ;", "init (  )  ;", "this . input . set ( view )  ;", "}", "METHOD_END"], "methodName": ["initializeForView"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGLKViewApplication"}, {"methodBody": ["METHOD_START", "{", "CGRect   bounds    =    app . getBounds (  )  ;", "IOSGLKView   view    =    IOSGLKView . alloc (  )  . init ( new   CGRect ( new   CGPoint (  0  ,     0  )  ,    new   apple . coreg . struct . CGSize ( bounds . size (  )  . width (  )  ,    bounds . size (  )  . height (  )  )  )  )  ;", "return   init ( scale ,    app ,    config ,    input ,    useGLES 3  0  ,    view )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "this . view    =    view ;", "init (  )  ;", "this . config    =    config ;", "final   CGRect   bounds    =    app . getBounds (  )  ;", "width    =     (  ( int )     ( bounds . size (  )  . width (  )  )  )  ;", "height    =     (  ( int )     ( bounds . size (  )  . height (  )  )  )  ;", "if    ( useGLES 3  0  )     {", "context    =    EAGLContext . alloc (  )  . initWithAPI ( GLES 3  )  ;", "if    (  ( context )     !  =    null )", "gl 2  0     =    gl 3  0     =    new   robovm . IOSGLES 3  0  (  )  ;", "else", "Gdx . app . log (  \" IOGraphics \"  ,     \" OpenGL   ES    3  .  0    not   supported ,    falling   back   on    2  .  0  \"  )  ;", "}", "if    (  ( context )     =  =    null )     {", "context    =    EAGLContext . alloc (  )  . initWithAPI ( GLES 2  )  ;", "gl 2  0     =    new   IOSGLES 2  0  (  )  ;", "gl 3  0     =    null ;", "}", "view . setContext ( context )  ;", "view . setGraphics ( this )  ;", "view . setDelegate ( this )  ;", "view . setDrawableColorFormat ( config . colorFormat )  ;", "view . setDrawableDepthFormat ( config . depthFormat )  ;", "view . setDrawableStencilFormat ( config . stencilFormat )  ;", "view . setDrawableMultisample ( config . multisample )  ;", "view . setMultipleTouchEnabled ( true )  ;", "viewController    =    IOSUIViewController . alloc (  )  . init ( app ,    this )  ;", "viewController . setView ( view )  ;", "viewController . setDelegate ( this )  ;", "viewController . setPreferredFramesPerSecond ( config . preferredFramesPerSecond )  ;", "this . app    =    app ;", "this . input    =    input ;", "int   r    =     0  ;", "int   g    =     0  ;", "int   b    =     0  ;", "int   a    =     0  ;", "int   depth    =     0  ;", "int   stencil    =     0  ;", "int   samples    =     0  ;", "if    (  ( config . colorFormat )     =  =     ( GLKViewDrawableColorFormat . RGB 5  6  5  )  )     {", "r    =     5  ;", "g    =     6  ;", "b    =     5  ;", "a    =     0  ;", "} else    {", "r    =    g    =    b    =    a    =     8  ;", "}", "if    (  ( config . depthFormat )     =  =     ( GLKViewDrawableDepthFormat . Format 1  6  )  )     {", "depth    =     1  6  ;", "} else", "if    (  ( config . depthFormat )     =  =     ( GLKViewDrawableDepthFormat . Format 2  4  )  )     {", "depth    =     2  4  ;", "} else    {", "depth    =     0  ;", "}", "if    (  ( config . stencilFormat )     =  =     ( GLKViewDrawableStencilFormat . Format 8  )  )     {", "stencil    =     8  ;", "}", "if    (  ( config . multisample )     =  =     ( GLKViewDrawableMultisample . Multisample 4 X )  )     {", "samples    =     4  ;", "}", "bufferFormat    =    new   BufferFormat ( r ,    g ,    b ,    a ,    depth ,    stencil ,    samples ,    false )  ;", "String   machineString    =    HWMachine . getMachineString (  )  ;", "IOSDevice   device    =    IOSDevice . getDevice ( machineString )  ;", "if    ( device    =  =    null )", "app . error ( IOSGraphics . tag ,     (  (  \" Machine   ID :     \"     +    machineString )     +     \"    not   found ,    please   report   to   LibGDX \"  )  )  ;", "int   ppi    =     ( device    !  =    null )     ?    device . ppi    :     1  6  3  ;", "density    =     ( device    !  =    null )     ?     ( device . ppi )     /     1  6  0  .  0 F    :    scale ;", "ppiX    =    ppi ;", "ppiY    =    ppi ;", "ppcX    =     ( ppiX )     /     2  .  5  4 F ;", "ppcY    =     ( ppiY )     /     2  .  5  4 F ;", "app . debug ( IOSGraphics . tag ,     (  (  (  \" Display :    ppi =  \"     +    ppi )     +     \"  ,    density =  \"  )     +     ( density )  )  )  ;", "lastFrameTime    =    System . nanoTime (  )  ;", "framesStart    =    lastFrameTime ;", "appPaused    =    false ;", "return   this ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "EAGLContext . setCurrentContext ( context )  ;", "}", "METHOD_END"], "methodName": ["makeCurrent"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "if    ( appPaused )", "return ;", "appPaused    =    true ;", "Array < LifecycleListener >    listeners    =    app . lifecycleListeners ;", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . pause (  )  ;", "}", "}", "app . listener . pause (  )  ;", "}", "METHOD_END"], "methodName": ["pause"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( appPaused )  )", "return ;", "appPaused    =    false ;", "Array < LifecycleListener >    listeners    =    app . lifecycleListeners ;", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . resume (  )  ;", "}", "}", "app . listener . resume (  )  ;", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "UIAlertViewDelegate   delegate    =    new   UIAlertViewDelegate (  )     {", "@ Override", "public   void   alertViewClickedButtonAtIndex ( UIAlertView   alertView ,     @ NInt", "long   buttonIndex )     {", "if    ( buttonIndex    =  =     0  )     {", "listener . canceled (  )  ;", "} else", "if    ( buttonIndex    =  =     1  )     {", "UITextField   textField    =    alertView . textFieldAtIndex (  0  )  ;", "listener . input ( textField . text (  )  )  ;", "}", "}", "@ Override", "public   void   alertViewCancel ( UIAlertView   alertView )     {", "listener . canceled (  )  ;", "}", "}  ;", "final   UIAlertView   uiAlertView    =    UIAlertView . alloc (  )  . init (  )  ;", "uiAlertView . setTitle ( title )  ;", "uiAlertView . addButtonWithTitle (  \" Cancel \"  )  ;", "uiAlertView . addButtonWithTitle (  \" Ok \"  )  ;", "uiAlertView . setAlertViewStyle ( PlainText )  ;", "uiAlertView . setDelegate ( delegate )  ;", "UITextField   textField    =    uiAlertView . textFieldAtIndex (  0  )  ;", "textField . setPlaceholder ( placeholder )  ;", "textField . setText ( text )  ;", "return   uiAlertView ;", "}", "METHOD_END"], "methodName": ["buildUIAlertView"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "textfield    =    UITextField . alloc (  )  ;", "textfield . initWithFrame ( new   apple . coregraphics . struct . CGRect ( new   CGPoint (  1  0  ,     1  0  )  ,    new   CGSize (  1  0  0  ,     5  0  )  )  )  ;", "textfield . setKeyboardType ( Default )  ;", "textfield . setReturnKeyType ( Done )  ;", "textfield . setAutocapitalizationType ( None )  ;", "textfield . setAutocorrectionType ( No )  ;", "textfield . setSpellCheckingType ( UITextSpellCheckingType . No )  ;", "textfield . setHidden ( true )  ;", "textfield . setText (  \" x \"  )  ;", "app . getUIViewController (  )  . view (  )  . addSubview ( textfield )  ;", "}", "METHOD_END"], "methodName": ["createDefaultTextField"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "long   ptr    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( touchDown . length )  ;    i +  +  )     {", "if    (  ( touchDown [ i ]  )     =  =    touch )", "return   i ;", "}", "throw   new   GdxRuntimeException (  \" Couldn ' t   find   pointer   id   for   touch   event !  \"  )  ;", "}", "METHOD_END"], "methodName": ["findPointer"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( touchDown . length )  ;    i +  +  )     {", "if    (  ( touchDown [ i ]  )     =  =    null )", "return   i ;", "}", "throw   new   GdxRuntimeException (  \" Couldn ' t   find   free   pointer   id !  \"  )  ;", "}", "METHOD_END"], "methodName": ["getFreePointer"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "if    (  ( textfield )     =  =    null )", "createDefaultTextField (  )  ;", "return   textfield ;", "}", "METHOD_END"], "methodName": ["getKeyboardTextField"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "toTouchEvents ( touches )  ;", "graphics . requestRering (  )  ;", "}", "METHOD_END"], "methodName": ["onTouch"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( touchEvents )     {", "justTouched    =    false ;", "for    (  . TouchEvent   event    :    touchEvents )     {", "currentEvent    =    event ;", "if    (  ( event . phase )     =  =     ( UITouchPhase . Began )  )     {", "if    (  ( inputProcessor )     !  =    null )", "inputProcessor . touchDown ( event . x ,    event . y ,    event . pointer ,    Buttons . LEFT )  ;", "if    (  ( numTouched )     =  =     1  )", "justTouched    =    true ;", "} else", "if    (  (  ( event . phase )     =  =     ( UITouchPhase . Cancelled )  )     |  |     (  ( event . phase )     =  =     ( UITouchPhase . Ended )  )  )     {", "if    (  ( inputProcessor )     !  =    null )", "inputProcessor . touchUp ( event . x ,    event . y ,    event . pointer ,    Buttons . LEFT )  ;", "} else", "if    (  (  ( event . phase )     =  =     ( UITouchPhase . Moved )  )     |  |     (  ( event . phase )     =  =     ( UITouchPhase . Stationary )  )  )     {", "if    (  ( inputProcessor )     !  =    null )", "inputProcessor . touchDragged ( event . x ,    event . y ,    event . pointer )  ;", "}", "}", "touchEventPool . freeAll ( touchEvents )  ;", "touchEvents . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processEvents"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "keyboardCloseOnReturn    =    shouldClose ;", "}", "METHOD_END"], "methodName": ["setKeyboardCloseOnReturnKey"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "this . view    =    view ;", "}", "METHOD_END"], "methodName": ["setView"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "if    ( config . useAccelerometer )     {", "motionManager . setAccelerometerUpdateInterval ( config . accelerometerUpdate )  ;", "CMMotionManager . Block _ startAccelerometerUpdatesToQueueWithHandler   handler    =    new   CMMotionManager . Block _ startAccelerometerUpdatesToQueueWithHandler (  )     {", "@ Override", "public   void   call _ startAccelerometerUpdatesToQueueWithHandler ( CMAccelerometerData   cmAccelerometerData ,    NSError   nsError )     {", "updateAccelerometer ( cmAccelerometerData )  ;", "}", "}  ;", "motionManager . startAccelerometerUpdatesToQueueWithHandler ( NSOperationQueue . alloc (  )  . init (  )  ,    handler )  ;", "}", "}", "METHOD_END"], "methodName": ["setupAccelerometer"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "if    ( config . useCompass )     {", "setupMagnetometer (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setupCompass"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "if    (  ( motionManager . isMagnetometerAvailable (  )  )     &  &     ( config . useCompass )  )", "passSupported    =    true ;", "else", "return ;", "motionManager . setMagnetometerUpdateInterval ( config . magnetometerUpdate )  ;", "CMMotionManager . Block _ startMagnetometerUpdatesToQueueWithHandler   handler    =    new   CMMotionManager . Block _ startMagnetometerUpdatesToQueueWithHandler (  )     {", "@ Override", "public   void   call _ startMagnetometerUpdatesToQueueWithHandler ( CMMagnetometerData   cmMagnetometerData ,    NSError   nsError )     {", "updateRotation ( cmMagnetometerData )  ;", "}", "}  ;", "motionManager . startMagnetometerUpdatesToQueueWithHandler ( NSOperationQueue . alloc (  )  . init (  )  ,    handler )  ;", "}", "METHOD_END"], "methodName": ["setupMagnetometer"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "motionManager    =    CMMotionManager . alloc (  )  . init (  )  ;", "setupAccelerometer (  )  ;", "setupCompass (  )  ;", "UIDevice   device    =    UIDevice . currentDevice (  )  ;", "if    ( device . model (  )  . equalsIgnoreCase (  \" iphone \"  )  )", "hasVibrator    =    true ;", "}", "METHOD_END"], "methodName": ["setupPeripherals"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "for    ( UITouch   touch    :    touches . allObjects (  )  )     {", "final   int   locX ;", "final   int   locY ;", "{", "CGPoint   loc    =     (  ( view )     =  =    null )     ?    loc    =    touch . locationInView ( touch . window (  )  )     :    touch . locationInView ( view )  ;", "final   CGRect   bounds    =    app . getCachedBounds (  )  ;", "locX    =     (  ( int )     (  (  ( loc . x (  )  )     *     ( app . displayScaleFactor )  )     -     ( bounds . origin (  )  . x (  )  )  )  )  ;", "locY    =     (  ( int )     (  (  ( loc . y (  )  )     *     ( app . displayScaleFactor )  )     -     ( bounds . origin (  )  . y (  )  )  )  )  ;", "}", "synchronized ( touchEvents )     {", "long   phase    =    touch . phase (  )  ;", ". TouchEvent   event    =    touchEventPool . obtain (  )  ;", "event . x    =    locX ;", "event . y    =    locY ;", "event . phase    =    phase ;", "event . timestamp    =     (  ( long )     (  ( touch . timestamp (  )  )     *     1  0  0  0  0  0  0  0  0  0  )  )  ;", "touchEvents . add ( event )  ;", "if    ( phase    =  =     ( UITouchPhase . Began )  )     {", "event . pointer    =    getFreePointer (  )  ;", "touchDown [ event . pointer ]     =    touch ;", "touchX [ event . pointer ]     =    event . x ;", "touchY [ event . pointer ]     =    event . y ;", "deltaX [ event . pointer ]     =     0  ;", "deltaY [ event . pointer ]     =     0  ;", "( numTouched )  +  +  ;", "}", "if    (  ( phase    =  =     ( UITouchPhase . Moved )  )     |  |     ( phase    =  =     ( UITouchPhase . Stationary )  )  )     {", "event . pointer    =    findPointer ( touch )  ;", "deltaX [ event . pointer ]     =     ( event . x )     -     ( touchX [ event . pointer ]  )  ;", "deltaY [ event . pointer ]     =     ( event . y )     -     ( touchY [ event . pointer ]  )  ;", "touchX [ event . pointer ]     =    event . x ;", "touchY [ event . pointer ]     =    event . y ;", "}", "if    (  ( phase    =  =     ( UITouchPhase . Cancelled )  )     |  |     ( phase    =  =     ( UITouchPhase . Ended )  )  )     {", "event . pointer    =    findPointer ( touch )  ;", "touchDown [ event . pointer ]     =    null ;", "touchX [ event . pointer ]     =    event . x ;", "touchY [ event . pointer ]     =    event . y ;", "deltaX [ event . pointer ]     =     0  ;", "deltaY [ event . pointer ]     =     0  ;", "( numTouched )  -  -  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["toTouchEvents"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  ( float )     ( data . acceleration (  )  . x (  )  )  )     *     1  0  .  0 F ;", "float   y    =     (  ( float )     ( data . acceleration (  )  . y (  )  )  )     *     1  0  .  0 F ;", "float   z    =     (  ( float )     ( data . acceleration (  )  . z (  )  )  )     *     1  0  .  0 F ;", "acceleration [  0  ]     =     - x ;", "acceleration [  1  ]     =     - y ;", "acceleration [  2  ]     =     - z ;", "}", "METHOD_END"], "methodName": ["updateAccelerometer"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "final   float   eX    =     (  ( float )     ( data . magneticField (  )  . x (  )  )  )  ;", "final   float   eY    =     (  ( float )     ( data . magneticField (  )  . y (  )  )  )  ;", "final   float   eZ    =     (  ( float )     ( data . magneticField (  )  . z (  )  )  )  ;", "float   gX    =    acceleration [  0  ]  ;", "float   gY    =    acceleration [  1  ]  ;", "float   gZ    =    acceleration [  2  ]  ;", "float   cX    =     ( eY    *    gZ )     -     ( eZ    *    gY )  ;", "float   cY    =     ( eZ    *    gX )     -     ( eX    *    gZ )  ;", "float   cZ    =     ( eX    *    gY )     -     ( eY    *    gX )  ;", "final   float   normal    =     (  ( float )     ( Math . sqrt (  (  (  ( cX    *    cX )     +     ( cY    *    cY )  )     +     ( cZ    *    cZ )  )  )  )  )  ;", "final   float   invertC    =     1  .  0 F    /    normal ;", "cX    *  =    invertC ;", "cY    *  =    invertC ;", "cZ    *  =    invertC ;", "final   float   invertG    =     1  .  0 F    /     (  ( float )     ( Math . sqrt (  (  (  ( gX    *    gX )     +     ( gY    *    gY )  )     +     ( gZ    *    gZ )  )  )  )  )  ;", "gX    *  =    invertG ;", "gY    *  =    invertG ;", "gZ    *  =    invertG ;", "final   float   mX    =     ( gY    *    cZ )     -     ( gZ    *    cY )  ;", "final   float   mY    =     ( gZ    *    cX )     -     ( gX    *    cZ )  ;", "final   float   mZ    =     ( gX    *    cY )     -     ( gY    *    cX )  ;", "R [  0  ]     =    cX ;", "R [  1  ]     =    cY ;", "R [  2  ]     =    cZ ;", "R [  3  ]     =    mX ;", "R [  4  ]     =    mY ;", "R [  5  ]     =    mZ ;", "R [  6  ]     =    gX ;", "R [  7  ]     =    gY ;", "R [  8  ]     =    gZ ;", "rotation [  0  ]     =     (  ( float )     ( Math . atan 2  ( R [  1  ]  ,    R [  4  ]  )  )  )     *     ( MathUtils . radDeg )  ;", "rotation [  1  ]     =     (  ( float )     ( Math . asin (  (  -  ( R [  7  ]  )  )  )  )  )     *     ( MathUtils . radDeg )  ;", "rotation [  2  ]     =     (  ( float )     ( Math . atan 2  (  (  -  ( R [  6  ]  )  )  ,    R [  8  ]  )  )  )     *     ( MathUtils . radDeg )  ;", "}", "METHOD_END"], "methodName": ["updateRotation"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSInput"}, {"methodBody": ["METHOD_START", "{", "return   NSString . alloc (  )  . initWithString ( key )  ;", "}", "METHOD_END"], "methodName": ["convertKey"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSPreferences"}, {"methodBody": ["METHOD_START", "{", "for    ( ALSource   source    :    sourcePool )     {", "if    (  ( source . sourceId (  )  )     =  =    sId )", "return   source ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSoundSource"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSSound"}, {"methodBody": ["METHOD_START", "{", "if    (  ( streamIds . size )     =  =     8  )", "streamIds . pop (  )  ;", "ALSource   sSource    =    OALSimpleAudio . sharedInstance (  )  . playBufferVolumePitchPanLoop ( sBuffer ,    volume ,    pitch ,    pan ,    loop )  ;", "if    ( sSource    =  =    null )", "return    -  1  ;", "if    (  ( sSource . sourceId (  )  )     =  =     (  -  1  )  )", "return    -  1  ;", "streamIds . insert (  0  ,    sSource . sourceId (  )  )  ;", "return   sSource . sourceId (  )  ;", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSSound"}, {"methodBody": ["METHOD_START", "{", "init (  )  ;", "thiapp    =    app ;", "thigraphic =    graphic", "return   thi", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.iosmoe.IOSUIViewController"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" hw . machine \"  ;", "BytePtr   namePtr    =    PtrFactory . newByteArray ( name . getBytes (  )  )  ;", "NUIntPtr   sizePtr    =    PtrFactory . newNUIntReference (  )  ;", ". sysctlbyname ( namePtr ,    null ,    sizePtr ,    null ,     0  )  ;", "long   longsize    =    sizePtr . get (  )  ;", "BytePtr   machinePtr    =    PtrFactory . newByteReference (  )  ;", "machinePtr . setValue (  (  ( byte )     ( longsize )  )  )  ;", ". sysctlbyname ( namePtr ,    machinePtr ,    sizePtr ,    null ,     0  )  ;", "return   machinePtr . toUTF 8 String (  )  ;", "}", "METHOD_END"], "methodName": ["getMachineString"], "fileName": "com.badlogic.gdx.backends.iosmoe.custom.HWMachine"}, {"methodBody": ["METHOD_START", "{", "Object    _  _ old    =    audioSessionDelegate (  )  ;", "if    ( value    !  =    null )     {", "ObjCRuntime . associateObjCObject ( this ,    value )  ;", "}", "setDelegate _ unsafe ( value )  ;", "if    (  _  _ old    !  =    null )     {", "ObjCRuntime . dissociateObjCObject ( this ,     _  _ old )  ;", "}", "}", "METHOD_END"], "methodName": ["setAudioSessionDelegate"], "fileName": "com.badlogic.gdx.backends.iosmoe.objectal.OALAudioSession"}, {"methodBody": ["METHOD_START", "{", "Object    _  _ old    =    delegate (  )  ;", "if    ( value    !  =    null )     {", "ObjCRuntime . associateObjCObject ( this ,    value )  ;", "}", "setDelegate _ unsafe ( value )  ;", "if    (  _  _ old    !  =    null )     {", "ObjCRuntime . dissociateObjCObject ( this ,     _  _ old )  ;", "}", "}", "METHOD_END"], "methodName": ["setDelegate"], "fileName": "com.badlogic.gdx.backends.iosmoe.objectal.OALAudioTrack"}, {"methodBody": ["METHOD_START", "{", "IOSGLES 2  0  . x    =    x ;", "IOSGLES 2  0  . y    =    y ;", "IOSGLES 2  0  . width    =    width ;", "IOSGLES 2  0  . height    =    height ;", "glViewportJni ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glViewport"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSGLES20"}]