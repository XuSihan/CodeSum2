[{"methodBody": ["METHOD_START", "{", "if    (  ! condition )", "throw   new   utils . GdxRuntimeException (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.tests.Affine2Test"}, {"methodBody": ["METHOD_START", "{", "if    (  ! condition )", "throw   new   utils . GdxRuntimeException ( msg )  ;", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.tests.Affine2Test"}, {"methodBody": ["METHOD_START", "{", "Affine 2 Test . checkEqual ( new   Matrix 3  (  )  . set ( a )  ,    new   Matrix 3  (  )  . set ( b )  )  ;", "}", "METHOD_END"], "methodName": ["checkEqual"], "fileName": "com.badlogic.gdx.tests.Affine2Test"}, {"methodBody": ["METHOD_START", "{", "Affine 2 Test . checkEqual ( matrix ,    new   Matrix 3  (  )  . set ( affine )  )  ;", "}", "METHOD_END"], "methodName": ["checkEqual"], "fileName": "com.badlogic.gdx.tests.Affine2Test"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     9  ;    i +  +  )", "Affine 2 Test . check ( math . MathUtils . isEqual ( a . val [ i ]  ,    b . val [ i ]  ,    Affine 2 Test . TOLERANCE )  ,     \" matrices   are   not   equal \"  )  ;", "}", "METHOD_END"], "methodName": ["checkEqual"], "fileName": "com.badlogic.gdx.tests.Affine2Test"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     9  ;    i +  +  )", "Affine 2 Test . check ( math . MathUtils . isEqual ( matrix . val [ i ]  ,    vals [ i ]  ,    Affine 2 Test . TOLERANCE )  ,     \" matrices   are   not   equal \"  )  ;", "}", "METHOD_END"], "methodName": ["checkEqual"], "fileName": "com.badlogic.gdx.tests.Affine2Test"}, {"methodBody": ["METHOD_START", "{", "Affine 2 Test . check ( MathUtils . isEqual ( a ,    b ,    Affine 2 Test . TOLERANCE )  )  ;", "}", "METHOD_END"], "methodName": ["checkEqual"], "fileName": "com.badlogic.gdx.tests.Affine2Test"}, {"methodBody": ["METHOD_START", "{", "message    +  =    line    +     \"  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["println"], "fileName": "com.badlogic.gdx.tests.AnnotationTest"}, {"methodBody": ["METHOD_START", "{", "app . setLogLevel ( LOG _ ERROR )  ;", "Resolution [  ]    resolutions    =    new   Resolution [  ]  {    new   Resolution (  3  2  0  ,     4  8  0  ,     \"  .  3  2  0  4  8  0  \"  )  ,    new   Resolution (  4  8  0  ,     8  0  0  ,     \"  .  4  8  0  8  0  0  \"  )  ,    new   Resolution (  4  8  0  ,     8  5  6  ,     \"  .  4  8  0  8  5  4  \"  )     }  ;", "ResolutionFileResolver   resolver    =    new   ResolutionFileResolver ( new   InternalFileHandleResolver (  )  ,    resolutions )  ;", "manager    =    new   AssetManager (  )  ;", "manager . setLoader ( Texture . class ,    new   assets . loaders . TextureLoader ( resolver )  )  ;", "manager . setErrorListener ( this )  ;", "load (  )  ;", "Texture . setAssetManager ( manager )  ;", "batch    =    new   SpriteBatch (  )  ;", "font    =    new   graphics . g 2 d . BitmapFont ( files . internal (  \" data / font . fnt \"  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.AssetManagerTest"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   buffer    =    BufferUtils . newIntBuffer (  1  )  ;", "buffer . put (  0  ,    texture . getTextureObjectHandle (  )  )  ;", "gl . glDeleteTextures (  1  ,    buffer )  ;", "}", "METHOD_END"], "methodName": ["invalidateTexture"], "fileName": "com.badlogic.gdx.tests.AssetManagerTest"}, {"methodBody": ["METHOD_START", "{", "start    =    TimeUtils . nanoTime (  )  ;", "tex 1     =    new   Texture (  \" data / animation . png \"  )  ;", "tex 2     =    new   TextureAtlas ( files . internal (  \" data / pack \"  )  )  ;", "font 2     =    new   BitmapFont ( files . internal (  \" data / verdana 3  9  . fnt \"  )  ,    false )  ;", "shader    =    new   ShaderProgram ( files . internal (  \" data / g 2 d / batchCommon . vert \"  )  . readString (  )  ,    files . internal (  \" data / g 2 d / monochrome . frag \"  )  . readString (  )  )  ;", "System . out . println (  (  \" plain   took :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -     ( start )  )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "m . load (  \" data / animation . png \"  ,    Texture . class )  ;", "m . load (  \" data / pack \"  ,    TextureAtlas . class )  ;", "m . load (  \" data / verdana 3  9  . fnt \"  ,    BitmapFont . class )  ;", "m . load (  \" data / i 1  8 n / message 2  \"  ,    I 1  8 NBundle . class ,    new   I 1  8 NBundleLoader . I 1  8 NBundleParameter (  (  (  ( reloads )     %     2  )     =  =     0     ?    Locale . ITALIAN    :    Locale . ENGLISH )  )  )  ;", "m . load (  \" data / g 2 d / monochrome . frag \"  ,    ShaderProgram . class ,    new   ShaderProgramLoader . ShaderProgramParameter (  )     {", "{", "vertexFile    =     \" data / g 2 d / batchCommon . vert \"  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.tests.AssetManagerTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "boolean   result    =    manager . update (  )  ;", "if    ( result )     {", "if    (  !  ( diagnosed )  )     {", "diagnosed    =    true ;", "System . out . println (  (  \" took :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -     ( start )  )     /     1  .  0 E 9 F )  )  )  ;", "elapsed    =     0  ;", "} else    {", "elapsed    +  =    graphics . getRawDeltaTime (  )  ;", "if    (  ( elapsed )     >     0  .  2 F )     {", "unload (  )  ;", "load (  )  ;", "diagnosed    =    false ;", "( reloads )  +  +  ;", "}", "}", "}", "( frame )  +  +  ;", "if    ( manager . isLoaded (  \" data / g 2 d / monochrome . frag \"  )  )", "batch . setShader ( manager . get (  \" data / g 2 d / monochrome . frag \"  ,    graphics . glutils . ShaderProgram . class )  )  ;", "else", "batch . setShader ( null )  ;", "batch . begin (  )  ;", "if    ( manager . isLoaded (  \" data / animation . png \"  )  )", "batch . draw ( manager . get (  \" data / animation . png \"  ,    graphics . Texture . class )  ,     1  0  0  ,     1  0  0  )  ;", "if    ( manager . isLoaded (  \" data / verdana 3  9  . png \"  )  )", "batch . draw ( manager . get (  \" data / verdana 3  9  . png \"  ,    graphics . Texture . class )  ,     3  0  0  ,     1  0  0  )  ;", "if    ( manager . isLoaded (  \" data / pack \"  )  )", "batch . draw ( manager . get (  \" data / pack \"  ,    graphics . g 2 d . TextureAtlas . class )  . findRegion (  \" particle - star \"  )  ,     1  6  4  ,     1  0  0  )  ;", "if    ( manager . isLoaded (  \" data / verdana 3  9  . fnt \"  )  )", "manager . get (  \" data / verdana 3  9  . fnt \"  ,    graphics . g 2 d . BitmapFont . class )  . draw ( batch ,     \" This   is   a   test \"  ,     1  0  0  ,     8  0  )  ;", "if    ( manager . isLoaded (  \" data / multipagefont . fnt \"  )  )", "manager . get (  \" data / multipagefont . fnt \"  ,    graphics . g 2 d . BitmapFont . class )  . draw ( batch ,     \" This   is   a   test   qpRPN   multi   page !  \"  ,     1  0  0  ,     8  0  )  ;", "if    ( manager . isLoaded (  \" data / i 1  8 n / message 2  \"  )  )", "font . draw ( batch ,    manager . get (  \" data / i 1  8 n / message 2  \"  ,    utils . I 1  8 NBundle . class )  . get (  \" msg \"  )  ,     1  0  0  ,     4  0  0  )  ;", "font . draw ( batch ,     (  (  (  \" loaded :     \"     +     ( manager . getProgress (  )  )  )     +     \"  ,    reloads :     \"  )     +     ( reloads )  )  ,     0  ,     3  0  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.AssetManagerTest"}, {"methodBody": ["METHOD_START", "{", "tex 1  . dispose (  )  ;", "tex 2  . dispose (  )  ;", "font 2  . dispose (  )  ;", "shader . dispose (  )  ;", "m . unload (  \" data / animation . png \"  )  ;", "m . unload (  \" data / pack \"  )  ;", "m . unload (  \" data / verdana 3  9  . fnt \"  )  ;", "m . unload (  \" data / i 1  8 n / message 2  \"  )  ;", "m . unload (  \" data / g 2 d / monochrome . frag \"  )  ;", "}", "METHOD_END"], "methodName": ["unload"], "fileName": "com.badlogic.gdx.tests.AssetManagerTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "batch . setProjectionMatrix ( new   Matrix 4  (  )  . setToOrtho 2 D (  0  ,     0  ,     8  5  5  ,     4  8  0  )  )  ;", "atlas    =    new   graphics . g 2 d . TextureAtlas ( files . internal (  \" data / issue _ pack \"  )  ,    files . internal (  \" data /  \"  )  )  ;", "sprite    =    atlas . createSprite (  \" map \"  )  ;", "font    =    new   graphics . g 2 d . BitmapFont ( files . internal (  \" data / font . fnt \"  )  ,    files . internal (  \" data / font . png \"  )  ,    false )  ;", "gl . glClearColor (  0  ,     1  ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.AtlasIssueTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.AtlasIssueTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "sprite . draw ( batch )  ;", "font . draw ( batch ,     (  \" fps :  \"     +     ( graphics . getFramesPerSecond (  )  )  )  ,     2  6  ,     6  5  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.AtlasIssueTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" Multi \\ nLine \"  ;", "float   x    =    oSprite . getX (  )  ;", "float   y    =    oSprite . getY (  )  ;", "float   width    =    oSprite . getWidth (  )  ;", "float   height    =    oSprite . getHeight (  )  ;", "layout . setText ( font ,    text )  ;", "x    +  =     ( width    /     2  )     -     (  ( layout . width )     /     2  )  ;", "y    +  =     ( height    /     2  )     +     (  ( layout . height )     /     2  )  ;", "font . draw ( spriteBatch ,    text ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["renderMultiLine"], "fileName": "com.badlogic.gdx.tests.BitmapFontAlignmentTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" Multi   Line \\ nCached \"  ;", "int   lines    =     2  ;", "float   x    =    oSprite . getX (  )  ;", "float   y    =    oSprite . getY (  )  ;", "float   width    =    oSprite . getWidth (  )  ;", "float   height    =    oSprite . getHeight (  )  ;", "GlyphLayout   layout    =    cache . setText ( text ,     0  ,     0  )  ;", "x    +  =     ( width    /     2  )     -     (  ( layout . width )     /     2  )  ;", "y    +  =     ( height    /     2  )     +     (  ( layout . height )     /     2  )  ;", "cache . setPosition ( x ,    y )  ;", "cache . draw ( spriteBatch )  ;", "}", "METHOD_END"], "methodName": ["renderMultiLineCached"], "fileName": "com.badlogic.gdx.tests.BitmapFontAlignmentTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" Single   Line \"  ;", "float   x    =    oSprite . getX (  )  ;", "float   y    =    oSprite . getY (  )  ;", "float   width    =    oSprite . getWidth (  )  ;", "float   height    =    oSprite . getHeight (  )  ;", "layout . setText ( font ,    text )  ;", "x    +  =     ( width    /     2  )     -     (  ( layout . width )     /     2  )  ;", "y    +  =     ( height    /     2  )     +     (  ( layout . height )     /     2  )  ;", "font . draw ( spriteBatch ,    text ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["renderSingleLine"], "fileName": "com.badlogic.gdx.tests.BitmapFontAlignmentTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" Single   Line   Cached \"  ;", "float   x    =    oSprite . getX (  )  ;", "float   y    =    oSprite . getY (  )  ;", "float   width    =    oSprite . getWidth (  )  ;", "float   height    =    oSprite . getHeight (  )  ;", "GlyphLayout   layout    =    cache . setText ( text ,     0  ,     0  )  ;", "cache . setColors ( BLUE ,     1  ,     4  )  ;", "x    +  =     ( width    /     2  )     -     (  ( layout . width )     /     2  )  ;", "y    +  =     ( height    /     2  )     +     (  ( layout . height )     /     2  )  ;", "cache . setPosition ( x ,    y )  ;", "cache . draw ( spriteBatch )  ;", "}", "METHOD_END"], "methodName": ["renderSingleLineCached"], "fileName": "com.badlogic.gdx.tests.BitmapFontAlignmentTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" Wrapped   Wrapped   Wrapped   Wrapped \"  ;", "float   x    =    oSprite . getX (  )  ;", "float   y    =    oSprite . getY (  )  ;", "float   width    =    oSprite . getWidth (  )  ;", "float   height    =    oSprite . getHeight (  )  ;", "layout . setText ( font ,    text ,    WHITE ,    width ,    left ,    true )  ;", "x    +  =     ( width    /     2  )     -     (  ( layout . width )     /     2  )  ;", "y    +  =     ( height    /     2  )     +     (  ( layout . height )     /     2  )  ;", "font . draw ( spriteBatch ,    text ,    x ,    y ,    width ,    left ,    true )  ;", "}", "METHOD_END"], "methodName": ["renderWrapped"], "fileName": "com.badlogic.gdx.tests.BitmapFontAlignmentTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" Wrapped   Cached   Wrapped   Cached \"  ;", "float   x    =    oSprite . getX (  )  ;", "float   y    =    oSprite . getY (  )  ;", "float   width    =    oSprite . getWidth (  )  ;", "float   height    =    oSprite . getHeight (  )  ;", "GlyphLayout   layout    =    cache . setText ( text ,     0  ,     0  ,    width ,    left ,    true )  ;", "x    +  =     ( width    /     2  )     -     (  ( layout . width )     /     2  )  ;", "y    +  =     ( height    /     2  )     +     (  ( layout . height )     /     2  )  ;", "cache . setPosition ( x ,    y )  ;", "cache . draw ( spriteBatch )  ;", "}", "METHOD_END"], "methodName": ["renderWrappedCached"], "fileName": "com.badlogic.gdx.tests.BitmapFontAlignmentTest"}, {"methodBody": ["METHOD_START", "{", "int   y    =     1  0  ;", "float   maxWidth    =     0  ;", "spriteBatch . setShader ( null )  ;", "descriptionFont . draw ( spriteBatch ,    description ,    x ,    y )  ;", "spriteBatch . flush (  )  ;", "y    +  =     1  0     +     (  2     *     ( descriptionFont . getLineHeight (  )  )  )  ;", "TextureFilter   minFilter    =     ( linearFiltering )     ?    TextureFilter . MipMapLinearNearest    :    TextureFilter . Nearest ;", "TextureFilter   magFilter    =     ( linearFiltering )     ?    TextureFilter . Linear    :    TextureFilter . Nearest ;", "for    ( int   i    =     0  ;    i    <     ( font . getRegions (  )  . size )  ;    i +  +  )     {", "font . getRegion ( i )  . getTexture (  )  . setFilter ( minFilter ,    magFilter )  ;", "}", "if    ( useShader )     {", "spriteBatch . setShader ( distanceFieldShader )  ;", "} else    {", "spriteBatch . setShader ( null )  ;", "}", "for    ( float   scale    :     . SCALES )     {", "font . getData (  )  . setScale ( scale )  ;", "layout . setText ( font ,     . TEXT )  ;", "maxWidth    =    Math . max ( maxWidth ,    layout . width )  ;", "if    ( useShader )     {", "distanceFieldShader . setSmoothing (  ( smoothing    /    scale )  )  ;", "}", "font . draw ( spriteBatch ,    layout ,    x ,    y )  ;", "y    +  =    font . getLineHeight (  )  ;", "spriteBatch . flush (  )  ;", "}", "return    (  ( int )     ( Math . ceil ( maxWidth )  )  )  ;", "}", "METHOD_END"], "methodName": ["drawFont"], "fileName": "com.badlogic.gdx.tests.BitmapFontDistanceFieldTest"}, {"methodBody": ["METHOD_START", "{", "return   shift ;", "}", "METHOD_END"], "methodName": ["getBaselineShift"], "fileName": "com.badlogic.gdx.tests.BitmapFontDistanceFieldTest"}, {"methodBody": ["METHOD_START", "{", "cache 1  . setText (  (  (  \"  (  \"     +    type )     +     \"  )  \"  )  ,     1  0  ,     (  3  2  0     -     6  6  )  )  ;", "String   text    =     \" Sphinx   of   black   quartz ,  \\ njudge   my   vow .  \"  ;", "cache 2  . setColor ( RED )  ;", "cache 2  . setText ( text ,     5  ,     (  3  2  0     -     3  0  0  )  )  ;", "text    =     \" How   quickly \\ ndaft   jumping   zebras   vex .  \"  ;", "cache 3  . setColor ( BLUE )  ;", "cache 3  . setText ( text ,     5  ,     (  3  2  0     -     2  0  0  )  ,     4  7  0  ,    center ,    false )  ;", "text    =     \" Kerning :    LYA   moo \"  ;", "cache 4  . setText ( text ,     2  1  0  ,     (  3  2  0     -     6  6  )  ,     0  ,     (  ( text . length (  )  )     -     3  )  ,     0  ,    left ,    false )  ;", "text    =     \" Forsaking   monastic   tradition ,    twelve   jovial   friars   gave \\ nup   their   vocation   for   a   quionable   existence   on   the   flying   trapeze .  \"  ;", "cache 5  . setColor ( red )  ;", "cache 5  . setText ( text ,     0  ,     (  3  2  0     -     3  0  0  )  ,     4  8  0  ,    center ,    false )  ;", "}", "METHOD_END"], "methodName": ["createCaches"], "fileName": "com.badlogic.gdx.tests.BitmapFontFlipTest"}, {"methodBody": ["METHOD_START", "{", "cache 5  . setColors ( red )  ;", "cache 5  . draw ( spriteBatch )  ;", "cache 1  . draw ( spriteBatch )  ;", "if    (  ( red . a )     >     0  .  6 F )", "return ;", "cache 2  . draw ( spriteBatch )  ;", "cache 3  . draw ( spriteBatch )  ;", "cache 4  . draw ( spriteBatch )  ;", "}", "METHOD_END"], "methodName": ["renderCached"], "fileName": "com.badlogic.gdx.tests.BitmapFontFlipTest"}, {"methodBody": ["METHOD_START", "{", "cacheScaled 5  . setColors ( red )  ;", "cacheScaled 5  . draw ( spriteBatch )  ;", "cacheScaled 1  . draw ( spriteBatch )  ;", "if    (  ( red . a )     >     0  .  6 F )", "return ;", "cacheScaled 2  . draw ( spriteBatch )  ;", "cacheScaled 3  . draw ( spriteBatch )  ;", "cacheScaled 4  . draw ( spriteBatch )  ;", "}", "METHOD_END"], "methodName": ["renderCachedScaled"], "fileName": "com.badlogic.gdx.tests.BitmapFontFlipTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" Forsaking   monastic   tradition ,    twelve   jovial   friars   gave \\ nup   their   vocation   for   a   questionable   existence   on   the   flying   trapeze .  \"  ;", "font . setColor ( red )  ;", "font . draw ( spriteBatch ,    text ,     0  ,     (  3  2  0     -     3  0  0  )  ,     4  8  0  ,    center ,    false )  ;", "font . setColor ( WHITE )  ;", "font . draw ( spriteBatch ,     (  (  \"  (  \"     +    type )     +     \"  )  \"  )  ,     1  0  ,     (  3  2  0     -     6  6  )  )  ;", "if    (  ( red . a )     >     0  .  6 F )", "return ;", "text    =     \" Sphinx   of   black   quartz ,  \\ njudge   my   vow .  \"  ;", "font . setColor ( RED )  ;", "font . draw ( spriteBatch ,    text ,     5  ,     (  3  2  0     -     3  0  0  )  )  ;", "text    =     \" How   quickly \\ ndaft   jumping   zebras   vex .  \"  ;", "font . setColor ( BLUE )  ;", "font . draw ( spriteBatch ,    text ,     5  ,     (  3  2  0     -     2  0  0  )  ,     4  7  0  ,    right ,    false )  ;", "text    =     \" Kerning :    LYA   moo \"  ;", "font . setColor ( WHITE )  ;", "font . draw ( spriteBatch ,    text ,     2  1  0  ,     (  3  2  0     -     6  6  )  ,     0  ,     (  ( text . length (  )  )     -     3  )  ,     0  ,    left ,    false )  ;", "}", "METHOD_END"], "methodName": ["renderNormal"], "fileName": "com.badlogic.gdx.tests.BitmapFontFlipTest"}, {"methodBody": ["METHOD_START", "{", "spriteBatch . getProjectionMatrix (  )  . setToOrtho 2 D (  0  ,     0  ,    width ,    height )  ;", "renderer . setProjectionMatrix ( spriteBatch . getProjectionMatrix (  )  )  ;", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.BitmapFontTest"}, {"methodBody": ["METHOD_START", "{", "rgb 8  8  8     =    new   Texture (  \" data / bobrgb 8  8  8  -  3  2 x 3  2  . png \"  )  ;", "rgba 8  8  8  8     =    new   Texture (  \" data / bobargb 8  8  8  8  -  3  2 x 3  2  . png \"  )  ;", "psRgb 8  8  8     =    new   Texture (  \" data / alpha . png \"  )  ;", "psRgba 8  8  8  8     =    new   Texture (  \" data / rgb . png \"  )  ;", "batch    =    new   SpriteBatch (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.BlitTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  .  4 F ,     0  .  4 F ,     0  .  4 F ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "batch . draw ( rgb 8  8  8  ,     0  ,     0  )  ;", "batch . draw ( rgba 8  8  8  8  ,     6  0  ,     0  )  ;", "batch . draw ( psRgb 8  8  8  ,     0  ,     6  0  )  ;", "batch . draw ( psRgba 8  8  8  8  ,     (  ( psRgb 8  8  8  . getWidth (  )  )     +     2  0  )  ,     6  0  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.BlitTest"}, {"methodBody": ["METHOD_START", "{", "BodyDef   def    =    new   BodyDef (  )  ;", "def . type    =    type ;", "Body   box    =    world . createBody ( def )  ;", "PolygonShape   poly    =    new   PolygonShape (  )  ;", "poly . setAs ( width ,    height )  ;", "box . createFixture ( poly ,    density )  ;", "poly . dispose (  )  ;", "return   box ;", "}", "METHOD_END"], "methodName": ["createBox"], "fileName": "com.badlogic.gdx.tests.Box2DCharacterControllerTest"}, {"methodBody": ["METHOD_START", "{", "BodyDef   def    =    new   BodyDef (  )  ;", "def . type    =    type ;", "Body   box    =    world . createBody ( def )  ;", "CircleShape   poly    =    new   CircleShape (  )  ;", "poly . setRadius ( radius )  ;", "box . createFixture ( poly ,    density )  ;", "poly . dispose (  )  ;", "return   box ;", "}", "METHOD_END"], "methodName": ["createCircle"], "fileName": "com.badlogic.gdx.tests.Box2DCharacterControllerTest"}, {"methodBody": ["METHOD_START", "{", "BodyDef   def    =    new   BodyDef (  )  ;", "def . type    =    type ;", "Body   box    =    world . createBody ( def )  ;", "EdgeShape   poly    =    new   EdgeShape (  )  ;", "poly . set ( new   Vector 2  (  0  ,     0  )  ,    new   Vector 2  (  ( x 2     -    x 1  )  ,     ( y 2     -    y 1  )  )  )  ;", "box . createFixture ( poly ,    density )  ;", "box . setTransform ( x 1  ,    y 1  ,     0  )  ;", "poly . dispose (  )  ;", "return   box ;", "}", "METHOD_END"], "methodName": ["createEdge"], "fileName": "com.badlogic.gdx.tests.Box2DCharacterControllerTest"}, {"methodBody": ["METHOD_START", "{", "BodyDef   def    =    new   BodyDef (  )  ;", "def . type    =    BodyType . DynamicBody ;", "Body   box    =    world . createBody ( def )  ;", "PolygonShape   poly    =    new   PolygonShape (  )  ;", "poly . setAs (  0  .  4  5 F ,     1  .  4 F )  ;", "playerPhysicsFixture    =    box . createFixture ( poly ,     1  )  ;", "poly . dispose (  )  ;", "CircleShape   circle    =    new   CircleShape (  )  ;", "circle . setRadius (  0  .  4  5 F )  ;", "circle . setPosition ( new   Vector 2  (  0  ,     (  -  1  .  4 F )  )  )  ;", "playerSensorFixture    =    box . createFixture ( circle ,     0  )  ;", "circle . dispose (  )  ;", "box . setBullet ( true )  ;", "return   box ;", "}", "METHOD_END"], "methodName": ["createPlayer"], "fileName": "com.badlogic.gdx.tests.Box2DCharacterControllerTest"}, {"methodBody": ["METHOD_START", "{", "float   y 1     =     1  ;", "float   y 2     =    y 1  ;", "for    ( int   i    =     0  ;    i    <     5  0  ;    i +  +  )     {", "Body   ground    =    createEdge ( StaticBody ,     (  (  -  5  0  )     +     ( i    *     2  )  )  ,    y 1  ,     (  (  (  -  5  0  )     +     ( i    *     2  )  )     +     2  )  ,    y 2  ,     0  )  ;", "y 1     =    y 2  ;", "y 2     =     1  ;", "}", "Body   box    =    createBox ( StaticBody ,     1  ,     1  ,     0  )  ;", "box . setTransform (  3  0  ,     3  ,     0  )  ;", "box    =    createBox ( StaticBody ,     1  .  2 F ,     1  .  2 F ,     0  )  ;", "box . setTransform (  5  ,     2  .  4 F ,     0  )  ;", "player    =    createPlayer (  )  ;", "player . setTransform (  (  -  4  0  .  0 F )  ,     4  .  0 F ,     0  )  ;", "player . setFixedRotation ( true )  ;", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +  )     {", "box    =    createBox ( DynamicBody ,     (  ( float )     ( Math . random (  )  )  )  ,     (  ( float )     ( Math . random (  )  )  )  ,     3  )  ;", "box . setTransform (  (  (  (  ( float )     ( Math . random (  )  )  )     *     1  0  .  0 F )     -     (  (  ( float )     ( Math . random (  )  )  )     *     1  0  .  0 F )  )  ,     (  (  (  ( float )     ( Math . random (  )  )  )     *     1  0  )     +     6  )  ,     (  ( float )     (  (  ( Math . random (  )  )     *     2  )     *     ( Math . PI )  )  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +  )     {", "Body   circle    =    createCircle ( DynamicBody ,     (  (  ( float )     ( Math . random (  )  )  )     *     0  .  5 F )  ,     3  )  ;", "circle . setTransform (  (  (  (  ( float )     ( Math . random (  )  )  )     *     1  0  .  0 F )     -     (  (  ( float )     ( Math . random (  )  )  )     *     1  0  .  0 F )  )  ,     (  (  (  ( float )     ( Math . random (  )  )  )     *     1  0  )     +     6  )  ,     (  ( float )     (  (  ( Math . random (  )  )     *     2  )     *     ( Math . PI )  )  )  )  ;", "}", "platforms . add ( new    . CirclePlatform (  (  -  2  4  )  ,     (  -  5  )  ,     1  0  ,     (  (  ( float )     ( Math . PI )  )     /     4  )  )  )  ;", "platforms . add ( new    . MovingPlatform (  (  -  2  )  ,     3  ,     2  ,     0  .  5 F ,     2  ,     0  ,     (  (  ( float )     ( Math . PI )  )     /     1  0  .  0 F )  ,     4  )  )  ;", "platforms . add ( new    . MovingPlatform (  1  7  ,     2  ,     5  ,     0  .  5 F ,     2  ,     0  ,     0  ,     5  )  )  ;", "platforms . add ( new    . MovingPlatform (  (  -  7  )  ,     5  ,     2  ,     0  .  5 F ,     (  -  2  )  ,     2  ,     0  ,     8  )  )  ;", "}", "METHOD_END"], "methodName": ["createWorld"], "fileName": "com.badlogic.gdx.tests.Box2DCharacterControllerTest"}, {"methodBody": ["METHOD_START", "{", "groundedPlatform    =    null ;", "Array < Contact >    contactList    =    world . getContactList (  )  ;", "for    ( int   i    =     0  ;    i    <     ( contactList . size )  ;    i +  +  )     {", "Contact   contact    =    contactList . get ( i )  ;", "if    (  ( contact . isTouching (  )  )     &  &     (  (  ( contact . getFixtureA (  )  )     =  =     ( playerSensorFixture )  )     |  |     (  ( contact . getFixtureB (  )  )     =  =     ( playerSensorFixture )  )  )  )     {", "Vector 2    pos    =    player . getPosition (  )  ;", "WorldManifold   manifold    =    contact . getWorldManifold (  )  ;", "boolean   below    =    true ;", "for    ( int   j    =     0  ;    j    <     ( manifold . getNumberOfContactPoints (  )  )  ;    j +  +  )     {", "below    &  =     ( manifold . getPoints (  )  [ j ]  . y )     <     (  ( pos . y )     -     1  .  5 F )  ;", "}", "if    ( below )     {", "if    (  (  ( contact . getFixtureA (  )  . getUserData (  )  )     !  =    null )     &  &     ( contact . getFixtureA (  )  . getUserData (  )  . equals (  \" p \"  )  )  )     {", "groundedPlatform    =     (  (  . Platform )     ( contact . getFixtureA (  )  . getBody (  )  . getUserData (  )  )  )  ;", "}", "if    (  (  ( contact . getFixtureB (  )  . getUserData (  )  )     !  =    null )     &  &     ( contact . getFixtureB (  )  . getUserData (  )  . equals (  \" p \"  )  )  )     {", "groundedPlatform    =     (  (  . Platform )     ( contact . getFixtureB (  )  . getBody (  )  . getUserData (  )  )  )  ;", "}", "return   true ;", "}", "return   false ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isPlayerGrounded"], "fileName": "com.badlogic.gdx.tests.Box2DCharacterControllerTest"}, {"methodBody": ["METHOD_START", "{", "PolygonShape   boxPoly    =    new   PolygonShape (  )  ;", "boxPoly . setAs (  1  ,     1  )  ;", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +  )     {", "BodyDef   boxBodyDef    =    new   BodyDef (  )  ;", "boxBodyDef . type    =    BodyType . DynamicBody ;", "boxBodyDef . position . x    =     (  -  2  4  )     +     (  ( float )     (  ( Math . random (  )  )     *     4  8  )  )  ;", "boxBodyDef . position . y    =     1  0     +     (  ( float )     (  ( Math . random (  )  )     *     1  0  0  )  )  ;", "Body   boxBody    =    world . createBody ( boxBodyDef )  ;", "boxBody . createFixture ( boxPoly ,     1  )  ;", "boxes . add ( boxBody )  ;", "}", "boxPoly . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["createBoxes"], "fileName": "com.badlogic.gdx.tests.Box2DTest"}, {"methodBody": ["METHOD_START", "{", "world    =    new   com . badlogic . gdx . physics . box 2 d . World ( new   Vector 2  (  0  ,     (  -  1  0  )  )  ,    true )  ;", "float [  ]    vertices    =    new   float [  ]  {     -  0  .  0  7  4  2  1  8  8  7 F ,     -  0  .  1  6  2  7  6  0  8  5 F ,     -  0  .  1  2  1  0  9  3  7  5 F ,     -  0  .  2  2  7  8  6  5  0  4 F ,     -  0  .  1  5  7  5  5  2 F ,     -  0  .  7  1  2  2  4  0  1 F ,     0  .  0  4  2  9  6  8  7  5 F ,     -  0  .  7  1  2  2  4  0  1 F ,     0  .  1  1  0  6  7  7  0  0  4 F ,     -  0  .  6  4  1  9  2  7  6 F ,     0  .  1  3  1  5  1  0  2  6 F ,     -  0  .  4  9  8  6  9  8  3  5 F ,     0  .  0  8  9  8  4  3  7  5 F ,     -  0  .  3  1  9  0  1  0  9 F    }  ;", "PolygonShape   shape    =    new   PolygonShape (  )  ;", "shape . set ( vertices )  ;", "PolygonShape   groundPoly    =    new   PolygonShape (  )  ;", "groundPoly . setAsBox (  5  0  ,     1  )  ;", "BodyDef   groundBodyDef    =    new   BodyDef (  )  ;", "groundBodyDef . type    =    BodyType . StaticBody ;", "groundBody    =    world . createBody ( groundBodyDef )  ;", "FixtureDef   fixtureDef    =    new   FixtureDef (  )  ;", "fixtureDef . shape    =    groundPoly ;", "fixtureDef . filter . groupIndex    =     0  ;", "groundBody . createFixture ( fixtureDef )  ;", "groundPoly . dispose (  )  ;", "ChainShape   chainShape    =    new   ChainShape (  )  ;", "chainShape . createLoop ( new   Vector 2  [  ]  {    new   Vector 2  (  (  -  1  0  )  ,     1  0  )  ,    new   Vector 2  (  (  -  1  0  )  ,     5  )  ,    new   Vector 2  (  1  0  ,     5  )  ,    new   Vector 2  (  1  0  ,     1  1  )     }  )  ;", "BodyDef   chainBodyDef    =    new   BodyDef (  )  ;", "chainBodyDef . type    =    BodyType . StaticBody ;", "Body   chainBody    =    world . createBody ( chainBodyDef )  ;", "chainBody . createFixture ( chainShape ,     0  )  ;", "chainShape . dispose (  )  ;", "createBoxes (  )  ;", "world . setContactListener ( new   ContactListener (  )     {", "@ Override", "public   void   beginContact ( Contact   contact )     {", "}", "@ Override", "public   void   endContact ( Contact   contact )     {", "}", "@ Override", "public   void   preSolve ( Contact   contact ,    Manifold   oldManifold )     {", "}", "@ Override", "public   void   postSolve ( Contact   contact ,    ContactImpulse   impulse )     {", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createPhysicsWorld"], "fileName": "com.badlogic.gdx.tests.Box2DTest"}, {"methodBody": ["METHOD_START", "{", "Vector 2    pos    =    body . getWorldCenter (  )  ;", "float   angle    =    body . getAngle (  )  ;", "transform . setToTranslation ( pos . x ,    pos . y ,     0  )  ;", "transform . rotate (  0  ,     0  ,     1  ,     (  ( float )     ( Math . toDegrees ( angle )  )  )  )  ;", "renderer . begin ( Line )  ;", "renderer . setTransformMatrix ( transform )  ;", "renderer . setColor (  1  ,     1  ,     1  ,     1  )  ;", "renderer . rect (  (  - halfWidth )  ,     (  - halfHeight )  ,     ( halfWidth    *     2  )  ,     ( halfHeight    *     2  )  )  ;", "renderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderBox"], "fileName": "com.badlogic.gdx.tests.Box2DTest"}, {"methodBody": ["METHOD_START", "{", "benchByte (  )  ;", "benchShort (  )  ;", "benchInt (  )  ;", "benchLong (  )  ;", "benchFloat (  )  ;", "benchDouble (  )  ;", "}", "METHOD_END"], "methodName": ["bench"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   bb    =    BufferUtils . newByteBuffer (  (  1  0  2  4     *     1  0  2  4  )  )  ;", "byte [  ]    bytes    =    new   byte [  1  0  2  4     *     1  0  2  4  ]  ;", "int   len    =    bytes . length ;", "final   int   NUM _ MB    =     5  ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <    NUM _ MB ;    j +  +  )     {", "bb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "bb . put ( bytes [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" ByteBuffer   relative   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <    NUM _ MB ;    j +  +  )     {", "bb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "bb . put ( i ,    bytes [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" ByteBuffer   absolute   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <    NUM _ MB ;    j +  +  )     {", "bb . clear (  )  ;", "bb . put ( bytes )  ;", "}", "app . log (  \"  \"  ,     (  \" ByteBuffer   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <    NUM _ MB ;    j +  +  )     {", "bb . clear (  )  ;", "BufferUtils . copy ( bytes ,     0  ,    bb ,    len )  ;", "}", "app . log (  \"  \"  ,     (  \" ByteBuffer   native   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["benchByte"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "DoubleBuffer   db    =    BufferUtils . newDoubleBuffer (  (  (  1  0  2  4     *     1  0  2  4  )     /     8  )  )  ;", "double [  ]    doubles    =    new   double [  (  1  0  2  4     *     1  0  2  4  )     /     8  ]  ;", "int   len    =    doubles . length ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "db . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "db . put ( doubles [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" DoubleBuffer   relative   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "db . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "db . put ( i ,    doubles [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" DoubleBuffer   absolute   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "db . clear (  )  ;", "db . put ( doubles )  ;", "}", "app . log (  \"  \"  ,     (  \" DoubleBuffer   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "db . clear (  )  ;", "BufferUtils . copy ( doubles ,     0  ,    db ,    len )  ;", "}", "app . log (  \"  \"  ,     (  \" DoubleBuffer   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["benchDouble"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "FloatBuffer   fb    =    BufferUtils . newFloatBuffer (  (  (  1  0  2  4     *     1  0  2  4  )     /     4  )  )  ;", "float [  ]    floats    =    new   float [  (  1  0  2  4     *     1  0  2  4  )     /     4  ]  ;", "int   len    =    floats . length ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "fb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "fb . put ( floats [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" FloatBuffer   relative   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "fb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "fb . put ( i ,    floats [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" FloatBuffer   absolute   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "fb . clear (  )  ;", "fb . put ( floats )  ;", "}", "app . log (  \"  \"  ,     (  \" FloatBuffer   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "fb . clear (  )  ;", "BufferUtils . copy ( floats ,     0  ,    fb ,    len )  ;", "}", "app . log (  \"  \"  ,     (  \" FloatBuffer   native   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["benchFloat"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   ib    =    BufferUtils . newIntBuffer (  (  (  1  0  2  4     *     1  0  2  4  )     /     4  )  )  ;", "int [  ]    ints    =    new   int [  (  1  0  2  4     *     1  0  2  4  )     /     4  ]  ;", "int   len    =    ints . length ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "ib . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "ib . put ( ints [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" IntBuffer   relative   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "ib . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "ib . put ( i ,    ints [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" IntBuffer   absolute   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "ib . clear (  )  ;", "ib . put ( ints )  ;", "}", "app . log (  \"  \"  ,     (  \" IntBuffer   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "ib . clear (  )  ;", "BufferUtils . copy ( ints ,     0  ,    ib ,    len )  ;", "}", "app . log (  \"  \"  ,     (  \" IntBuffer   native   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["benchInt"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "LongBuffer   lb    =    BufferUtils . newLongBuffer (  (  (  1  0  2  4     *     1  0  2  4  )     /     8  )  )  ;", "long [  ]    longs    =    new   long [  (  1  0  2  4     *     1  0  2  4  )     /     8  ]  ;", "int   len    =    longs . length ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "lb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "lb . put ( longs [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" LongBuffer   relative   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "lb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "lb . put ( i ,    longs [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" LongBuffer   absolute   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "lb . clear (  )  ;", "lb . put ( longs )  ;", "}", "app . log (  \"  \"  ,     (  \" LongBuffer   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "lb . clear (  )  ;", "BufferUtils . copy ( longs ,     0  ,    lb ,    len )  ;", "}", "app . log (  \"  \"  ,     (  \" LongBuffer   native   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["benchLong"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "ShortBuffer   sb    =    BufferUtils . newShortBuffer (  (  (  1  0  2  4     *     1  0  2  4  )     /     2  )  )  ;", "short [  ]    shorts    =    new   short [  (  1  0  2  4     *     1  0  2  4  )     /     2  ]  ;", "int   len    =    shorts . length ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "sb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "sb . put ( shorts [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" ShortBuffer   relative   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "sb . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "sb . put ( i ,    shorts [ i ]  )  ;", "}", "app . log (  \"  \"  ,     (  \" ShortBuffer   absolute   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "sb . clear (  )  ;", "sb . put ( shorts )  ;", "}", "app . log (  \"  \"  ,     (  \" ShortBuffer   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   j    =     0  ;    j    <     (  . NUM _ MB )  ;    j +  +  )     {", "sb . clear (  )  ;", "BufferUtils . copy ( shorts ,     0  ,    sb ,    len )  ;", "}", "app . log (  \"  \"  ,     (  \" ShortBuffer   native   bulk   put :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["benchShort"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "if    ( val 1     !  =    val 2  )     {", "app . error (  \"  \"  ,     (  (  (  \" checkFloat   failed :     \"     +    val 1  )     +     \"     !  =     \"  )     +    val 2  )  )  ;", "throw   new   GdxRuntimeException (  \" Error ,    val 1     !  =    val 2  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkFloat"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "if    ( val 1     !  =    val 2  )     {", "app . error (  \"  \"  ,     (  (  (  \" checkInt   failed :     \"     +    val 1  )     +     \"     !  =     \"  )     +    val 2  )  )  ;", "throw   new   GdxRuntimeException (  \" Error ,    val 1     !  =    val 2  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkInt"], "fileName": "com.badlogic.gdx.tests.BufferUtilsTest"}, {"methodBody": ["METHOD_START", "{", "app . log (  \" TestCollection \"  ,     (  (  \" disposing   test    '  \"     +     ( tests [ testIndex ]  . getClass (  )  . getName (  )  )  )     +     \"  '  \"  )  )  ;", "tests [ testIndex ]  . dispose (  )  ;", "System . gc (  )  ;", "( testIndex )  +  +  ;", "if    (  ( testIndex )     >  =     ( tests . length )  )", "testIndex    =     0  ;", "tests [ testIndex ]  . create (  )  ;", "cameraController . camera    =    tests [ testIndex ]  . camera ;", "app . log (  \" TestCollection \"  ,     (  (  \" created   test    '  \"     +     ( tests [ testIndex ]  . getClass (  )  . getName (  )  )  )     +     \"  '  \"  )  )  ;", "titleLabel . setText ( tests [ testIndex ]  . getClass (  )  . getSimpleName (  )  )  ;", "instructLabel . setText ( tests [ testIndex ]  . instructions )  ;", "loading    =     0  ;", "}", "METHOD_END"], "methodName": ["loadnext"], "fileName": "com.badlogic.gdx.tests.BulletTestCollection"}, {"methodBody": ["METHOD_START", "{", "titleLabel . setText (  \" Loading .  .  .  \"  )  ;", "loading    =     1  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.badlogic.gdx.tests.BulletTestCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( a . equals ( b )  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" equals (  )    failed :     \"     +    a )     +     \"     !  =     \"  )     +    b )  )  ;", "if    (  !  ( b . equals ( a )  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" equals (  )    failed    ( not   symmetric )  :     \"     +    b )     +     \"     !  =     \"  )     +    a )  )  ;", "if    (  ( a . hashCode (  )  )     !  =     ( b . hashCode (  )  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" hashCode (  )    failed :     \"     +    a )     +     \"     !  =     \"  )     +    b )  )  ;", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "if    ( a . equals ( b )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  \"  ! equals (  )    failed :     \"     +    a )     +     \"     =  =     \"  )     +    b )  )  ;", "if    ( b . equals ( a )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  \"  ! equals (  )    failed    ( not   symmetric )  :     \"     +    b )     +     \"     =  =     \"  )     +    a )  )  ;", "if    (  ( a . hashCode (  )  )     =  =     ( b . hashCode (  )  )  )", "System . out . println (  (  (  (  \" Warning :    hashCode (  )    may   be   incorrect :     \"     +    a )     +     \"     =  =     \"  )     +    b )  )  ;", "}", "METHOD_END"], "methodName": ["assertNotEquals"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "Constructor   theConstructor    =    null ;", "for    ( Constructor   constructor    :    ClassRef . getConstructors ( object . getClass (  )  )  )     {", "if    (  (  ( constructor . getParameterTypes (  )  . length )     =  =     1  )     &  &     ( ClassRef . isAssignableFrom ( constructor . getParameterTypes (  )  [  0  ]  ,    object . getClass (  )  )  )  )     {", "theConstructor    =    constructor ;", "break ;", "}", "}", "return   theConstructor . newInstance ( object )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   GdxRuntimeException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "testMap ( ArrayMap . class ,    values ,    valuesWithNulls )  ;", "testMap ( IdentityMap . class ,    values ,    valuesWithNulls )  ;", "testMap ( IntFloatMap . class ,    intValues ,    floatValues )  ;", "testMap ( IntIntMap . class ,    intValues ,    intValues )  ;", "testMap ( IntMap . class ,    intValues ,    valuesWithNulls )  ;", "testMap ( LongMap . class ,    longValues ,    valuesWithNulls )  ;", "testMap ( ObjectFloatMap . class ,    values ,    floatValues )  ;", "testMap ( ObjectIntMap . class ,    values ,    intValues )  ;", "testMap ( ObjectMap . class ,    values ,    valuesWithNulls )  ;", "testMap ( OrderedMap . class ,    values ,    valuesWithNulls )  ;", "testArray ( Array . class ,    valuesWithNulls )  ;", "testArray ( BooleanArray . class ,    new   Boolean [  ]  {    true ,    false    }  )  ;", "testArray ( ByteArray . class ,    byteValues )  ;", "testArray ( CharArray . class ,    charValues )  ;", "testArray ( FloatArray . class ,    floatValues )  ;", "testArray ( IntArray . class ,    intValues )  ;", "testArray ( LongArray . class ,    longValues )  ;", "testArray ( ShortArray . class ,    shortValues )  ;", "testArray ( SnapshotArray . class ,    values )  ;", "testSet ( IntSet . class ,    intValues )  ;", "testSet ( ObjectSet . class ,    values )  ;", "testSet ( OrderedSet . class ,    values )  ;", "System . out . println (  \" Success !  \"  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   theMethod    =    null ;", "for    ( Method   method    :    ClassRef . getMethods ( object . getClass (  )  )  )     {", "if    (  ( methodName . equals ( method . getName (  )  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     ( args . length )  )  )     {", "theMethod    =    method ;", "break ;", "}", "}", "theMethod . invoke ( object ,    args )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   GdxRuntimeException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   ClassRef . newInstance ( clazz )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   GdxRuntimeException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "ClassRef . getField ( object . getClass (  )  ,    fieldName )  . set ( object ,    value )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   GdxRuntimeException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( arrayClass )  ;", "Obj   array    =    newInstance ( arrayClass )  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )", "invoke (  \" add \"  ,    array ,    values [ i ]  )  ;", "Obj   otherArray    =    newInstance ( arrayClass )  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )", "invoke (  \" add \"  ,    otherArray ,    values [ i ]  )  ;", "assertEquals ( array ,    otherArray )  ;", "Obj   unorderedArray    =    newInstance ( arrayClass )  ;", "set (  \" ordered \"  ,    unorderedArray ,    false )  ;", "Obj   otherUnorderedArray    =    newInstance ( arrayClass )  ;", "set (  \" ordered \"  ,    otherUnorderedArray ,    false )  ;", "assertEquals ( unorderedArray ,    unorderedArray )  ;", "assertNotEquals ( unorderedArray ,    otherUnorderedArray )  ;", "}", "METHOD_END"], "methodName": ["testArray"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( mapClass )  ;", "Object   map    =    newInstance ( mapClass )  ;", "Object   otherMap    =    newInstance ( mapClass )  ;", "assertEquals ( map ,    map )  ;", "for    ( int   i    =     0  ,    n    =    keys . length ;    i    <    n ;     +  + i )     {", "Object   anotherMap    =    copy ( map )  ;", "assertEquals ( map ,    anotherMap )  ;", "invoke (  \" put \"  ,    map ,    keys [ i ]  ,    values [ i ]  )  ;", "invoke (  \" put \"  ,    otherMap ,    keys [ i ]  ,    values [ i ]  )  ;", "assertEquals ( map ,    otherMap )  ;", "assertNotEquals ( map ,    anotherMap )  ;", "invoke (  \" put \"  ,    anotherMap ,    keys [  (  ( i    +     1  )     %     ( keys . length )  )  ]  ,    values [ i ]  )  ;", "assertNotEquals ( map ,    anotherMap )  ;", "}", "Object   anotherMap    =    copy ( map )  ;", "Iterator   it    =     (  ( Iterable )     ( anotherMap )  )  . iterator (  )  ;", "int   iteraCount    =     0  ;", "while    ( it . hasNext (  )  )     {", "Object   entry    =    it . next (  )  ;", "iteraCount +  +  ;", "}", "assertEquals ( iteraCount ,    keys . length )  ;", "for    ( int   i    =     0  ,    n    =    keys . length ;    i    <    n ;     +  + i )     {", "anotherMap    =    copy ( map )  ;", "it    =     (  ( Iterable )     ( anotherMap )  )  . iterator (  )  ;", "iteraCount    =     0  ;", "while    ( it . hasNext (  )  )     {", "Object   entry    =    it . next (  )  ;", "if    ( iteraCount    =  =    i )     {", "it . remove (  )  ;", "}", "iteraCount +  +  ;", "}", "assertEquals ( iteraCount ,    keys . length )  ;", "}", "}", "METHOD_END"], "methodName": ["testMap"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( setClass )  ;", "Obj   set    =    newInstance ( setClass )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;     +  + i )", "invoke (  \" add \"  ,    set ,    values [ i ]  )  ;", "Obj   otherSet    =    newInstance ( setClass )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;     +  + i )", "invoke (  \" add \"  ,    otherSet ,    values [ i ]  )  ;", "Obj   thirdSet    =    newInstance ( setClass )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )", "invoke (  \" add \"  ,    thirdSet ,    values [  (  ( n    -    i )     -     1  )  ]  )  ;", "assertEquals ( set ,    set )  ;", "assertEquals ( set ,    otherSet )  ;", "assertEquals ( set ,    thirdSet )  ;", "assertEquals ( otherSet ,    set )  ;", "assertEquals ( otherSet ,    otherSet )  ;", "assertEquals ( otherSet ,    thirdSet )  ;", "assertEquals ( thirdSet ,    set )  ;", "assertEquals ( thirdSet ,    otherSet )  ;", "assertEquals ( thirdSet ,    thirdSet )  ;", "}", "METHOD_END"], "methodName": ["testSet"], "fileName": "com.badlogic.gdx.tests.CollectionsTest"}, {"methodBody": ["METHOD_START", "{", "Table   table    =    new   Table (  )  . debug (  )  ;", "table . add ( new   scenes . scene 2 d . ui . Label ( text ,    skin )  )  . fill (  )  . expand (  )  ;", "return   table ;", "}", "METHOD_END"], "methodName": ["label"], "fileName": "com.badlogic.gdx.tests.ContainerTest"}, {"methodBody": ["METHOD_START", "{", "Batch   batch    =    new   CpuSpriteBatch (  )  ;", "stage    =    new   com . badlogic . gdx . scenes . scene 2 d . Stage ( new   ExtendViewport (  5  0  0  ,     5  0  0  )  ,    batch )  ;", "input . setInputProcessor ( stage )  ;", "texture    =    new   Texture (  \" data / bobargb 8  8  8  8  -  3  2 x 3  2  . png \"  )  ;", "texture . setFilter ( Linear ,    Linear )  ;", "TextureRegionDrawable   drawable    =    new   TextureRegionDrawable ( new   com . badlogic . gdx . graphics . g 2 d . TextureRegion ( texture )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . NUM _ GROUPS )  ;    i +  +  )     {", "Group   group    =    createActorGroup ( drawable )  ;", "stage . addActor ( group )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.CpuSpriteBatchTest"}, {"methodBody": ["METHOD_START", "{", "Actor   main    =    new   CpuSpriteBatchTest . DrawableActor ( bob )  ;", "main . setPosition (  0  ,     0  ,    center )  ;", "Actor   hat    =    new   CpuSpriteBatchTest . DrawableActor ( bob )     {", "@ Override", "public   void   act ( float   delta )     {", "rotateBy (  ( delta    *     (  -  3  0  0  )  )  )  ;", "}", "}  ;", "hat . setOrigin ( center )  ;", "hat . setScale (  0  .  5 F )  ;", "hat . setPosition (  0  ,     2  1  ,    center )  ;", "Group   group    =    new   Group (  )     {", "@ Override", "public   void   act ( float   delta )     {", "rotateBy (  ( delta    *     1  2  0  )  )  ;", "setScale (  (  0  .  9 F    +     (  0  .  2 F    *     ( MathUtils . cos (  (  ( MathUtils . degreesToRadians )     *     ( getRotation (  )  )  )  )  )  )  )  )  ;", "super . act ( delta )  ;", "}", "}  ;", "group . addActor ( main )  ;", "group . addActor ( hat )  ;", "float   margin    =     3  5  ;", "float   x    =    MathUtils . random ( margin ,     (  ( stage . getWidth (  )  )     -    margin )  )  ;", "float   y    =    MathUtils . random ( margin ,     (  ( stage . getHeight (  )  )     -    margin )  )  ;", "group . setPosition ( x ,    y )  ;", "group . setRotation ( MathUtils . random (  0  ,     3  6  0  )  )  ;", "return   group ;", "}", "METHOD_END"], "methodName": ["createActorGroup"], "fileName": "com.badlogic.gdx.tests.CpuSpriteBatchTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "texture . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.CpuSpriteBatchTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "long   now    =    TimeUtils . nanoTime (  )  ;", "( sampleFrames )  +  +  ;", "if    (  ( now    -     ( sampleStartTime )  )     >     1  0  0  0  0  0  0  0  0  0  )     {", "if    (  ( sampleStartTime )     !  =     0  )     {", "int   renderCalls    =     (  ( SpriteBatch )     ( stage . getBatch (  )  )  )  . renderCalls ;", "app . log (  \"  \"  ,     (  (  (  \" FPS :     \"     +     ( sampleFrames )  )     +     \"  ,    render   calls :     \"  )     +    renderCalls )  )  ;", "}", "sampleStartTime    =    now ;", "sampleFrames    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.CpuSpriteBatchTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.CpuSpriteBatchTest"}, {"methodBody": ["METHOD_START", "{", "Pixmap   pixmap 1     =    new   Pixmap ( files . internal (  \" data / bobargb 8  8  8  8  -  3  2 x 3  2  . png \"  )  )  ;", "cursor 1     =    graphics . new ( pixmap 1  ,     1  6  ,     1  6  )  ;", "Pixmap   pixmap 2     =    new   Pixmap (  3  2  ,     3  2  ,    Format . RGBA 8  8  8  8  )  ;", "pixmap 2  . setColor ( RED )  ;", "pixmap 2  . fillCircle (  1  6  ,     1  6  ,     8  )  ;", "cursor 2     =    graphics . new ( pixmap 2  ,     1  6  ,     1  6  )  ;", "Pixmap   pixmap 3     =    new   Pixmap (  3  2  ,     3  2  ,    Format . RGBA 8  8  8  8  )  ;", "pixmap 3  . setColor ( BLUE )  ;", "pixmap 3  . fillCircle (  1  6  ,     1  6  ,     8  )  ;", "cursor 3     =    graphics . new ( pixmap 3  ,     1  6  ,     1  6  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.CursorTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  1  ,     1  ,     1  ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "if    ( input . isTouched (  )  )     {", "graphics . set ( cursor 1  )  ;", "} else    {", "cursorActive    =     !  ( cursorActive )  ;", "if    ( cursorActive )     {", "graphics . set ( cursor 2  )  ;", "} else    {", "graphics . set ( cursor 3  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.CursorTest"}, {"methodBody": ["METHOD_START", "{", "Decal   sprite    =    null ;", "switch    (  ( idx )     %     2  )     {", "case    0     :", "sprite    =    Decal . newDecal ( new   graphics . g 2 d . TextureRegion ( egg )  ,    willItBlend _ that _ is _ the _ question )  ;", "break ;", "case    1     :", "sprite    =    Decal . newDecal ( new   graphics . g 2 d . TextureRegion ( wheel )  )  ;", "break ;", "}", "sprite . setPosition (  (  (  (  -  ( w )  )     /     2  )     +     (  (  ( float )     ( Math . random (  )  )  )     *     ( w )  )  )  ,     (  (  ( h )     /     2  )     -     (  (  ( float )     ( Math . random (  )  )  )     *     ( h )  )  )  ,     (  (  ( float )     (  -  ( Math . random (  )  )  )  )     *     1  0  )  )  ;", "( idx )  +  +  ;", "return   sprite ;", "}", "METHOD_END"], "methodName": ["makeDecal"], "fileName": "com.badlogic.gdx.tests.DecalTest"}, {"methodBody": ["METHOD_START", "{", "renderer    =    new   ShapeRenderer (  )  ;", "te (  )  ;", "System . out . println ( seed )  ;", "input . setInputProcessor ( new   InputAdapter (  )     {", "public   boolean   touchDown ( int   screenX ,    int   screenY ,    int   pointer ,    int   button )     {", "seed    =    random . nextLong (  )  ;", "System . out . println ( seed )  ;", "te (  )  ;", "return   true ;", "}", "public   boolean   mouseMoved ( int   screenX ,    int   screenY )     {", "te (  )  ;", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.DelaunayTriangulatorTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "renderer . setColor ( RED )  ;", "renderer . begin ( Filled )  ;", "for    ( int   i    =     0  ;    i    <     ( points . size )  ;    i    +  =     2  )", "renderer . circle ( points . get ( i )  ,    points . get (  ( i    +     1  )  )  ,     4  ,     1  2  )  ;", "renderer . end (  )  ;", "renderer . setColor ( WHITE )  ;", "renderer . begin ( Line )  ;", "for    ( int   i    =     0  ;    i    <     ( tles . size )  ;    i    +  =     3  )     {", "int   p 1     =     ( tles . get ( i )  )     *     2  ;", "int   p 2     =     ( tles . get (  ( i    +     1  )  )  )     *     2  ;", "int   p 3     =     ( tles . get (  ( i    +     2  )  )  )     *     2  ;", "renderer . tle ( points . get ( p 1  )  ,    points . get (  ( p 1     +     1  )  )  ,    points . get ( p 2  )  ,    points . get (  ( p 2     +     1  )  )  ,    points . get ( p 3  )  ,    points . get (  ( p 3     +     1  )  )  )  ;", "}", "renderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.DelaunayTriangulatorTest"}, {"methodBody": ["METHOD_START", "{", "renderer . getProjectionMatrix (  )  . setToOrtho 2 D (  0  ,     0  ,    width ,    height )  ;", "renderer . updateMatrices (  )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.DelaunayTriangulatorTest"}, {"methodBody": ["METHOD_START", "{", "random . setSeed ( seed )  ;", "int   pointCount    =     1  0  0  ;", "points . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    pointCount ;    i +  +  )     {", "float   value ;", "do    {", "value    =    MathUtils . random (  1  0  ,     4  0  0  )  ;", "}    while    ( points . contains ( value )     )  ;", "points . add ( value )  ;", "do    {", "value    =    MathUtils . random (  1  0  ,     4  0  0  )  ;", "}    while    ( points . contains ( value )     )  ;", "points . add ( value )  ;", "}", "points . add ( input . getX (  )  )  ;", "points . add (  (  ( graphics . getHeight (  )  )     -     ( input . getY (  )  )  )  )  ;", "triangles    =    trianglulator . computeles ( points ,    false )  ;", "}", "METHOD_END"], "methodName": ["triangulate"], "fileName": "com.badlogic.gdx.tests.DelaunayTriangulatorTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "final   Skin   skin    =    new   Skin (  )  ;", "skin . add (  \" default \"  ,    new   scenes . scene 2 d . ui . Label . LabelStyle ( new   BitmapFont (  )  ,    Color . WHITE )  )  ;", "skin . add (  \" badlogic \"  ,    new   Texture (  \" data / badlogic . jpg \"  )  )  ;", "Image   sourceImage    =    new   Image ( skin ,     \" badlogic \"  )  ;", "sourceImage . setBounds (  5  0  ,     1  2  5  ,     1  0  0  ,     1  0  0  )  ;", "stage . addActor ( sourceImage )  ;", "Image   validTargetImage    =    new   Image ( skin ,     \" badlogic \"  )  ;", "validTargetImage . setBounds (  2  0  0  ,     5  0  ,     1  0  0  ,     1  0  0  )  ;", "stage . addActor ( validTargetImage )  ;", "Image   invalidTargetImage    =    new   Image ( skin ,     \" badlogic \"  )  ;", "invalidTargetImage . setBounds (  2  0  0  ,     2  0  0  ,     1  0  0  ,     1  0  0  )  ;", "stage . addActor ( invalidTargetImage )  ;", "DragAndDrop   dragAndDrop    =    new   DragAndDrop (  )  ;", "dragAndDrop . addSource ( new   Source ( sourceImage )     {", "public   Payload   dragStart ( InputEvent   event ,    float   x ,    float   y ,    int   pointer )     {", "Payload   payload    =    new   Payload (  )  ;", "payload . setObject (  \" Some   payload !  \"  )  ;", "payload . setDragActor ( new   Label (  \" Some   payload !  \"  ,    skin )  )  ;", "Label   validLabel    =    new   Label (  \" Some   payload !  \"  ,    skin )  ;", "validLabel . setColor (  0  ,     1  ,     0  ,     1  )  ;", "payload . setValidDragActor ( validLabel )  ;", "Label   invalidLabel    =    new   Label (  \" Some   payload !  \"  ,    skin )  ;", "invalidLabel . setColor (  1  ,     0  ,     0  ,     1  )  ;", "payload . setInvalidDragActor ( invalidLabel )  ;", "return   payload ;", "}", "}  )  ;", "dragAndDrop . addTarget ( new   Target ( validTargetImage )     {", "public   boolean   drag ( Source   source ,    Payload   payload ,    float   x ,    float   y ,    int   pointer )     {", "getActor (  )  . setColor ( GREEN )  ;", "return   true ;", "}", "public   void   reset ( Source   source ,    Payload   payload )     {", "getActor (  )  . setColor ( WHITE )  ;", "}", "public   void   drop ( Source   source ,    Payload   payload ,    float   x ,    float   y ,    int   pointer )     {", "System . out . println (  (  (  (  (  (  \" Accepted :     \"     +     ( payload . getObject (  )  )  )     +     \"     \"  )     +    x )     +     \"  ,     \"  )     +    y )  )  ;", "}", "}  )  ;", "dragAndDrop . addTarget ( new   Target ( invalidTargetImage )     {", "public   boolean   drag ( Source   source ,    Payload   payload ,    float   x ,    float   y ,    int   pointer )     {", "getActor (  )  . setColor ( RED )  ;", "return   false ;", "}", "public   void   reset ( Source   source ,    Payload   payload )     {", "getActor (  )  . setColor ( WHITE )  ;", "}", "public   void   drop ( Source   source ,    Payload   payload ,    float   x ,    float   y ,    int   pointer )     {", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.DragAndDropTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.DragAndDropTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.DragAndDropTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.DragAndDropTest"}, {"methodBody": ["METHOD_START", "{", "int   idx    =     0  ;", "for    ( int   y    =     -  1  ;    y    <  =     1  ;    y +  +  )     {", "for    ( int   x    =     -  1  ;    x    <  =     1  ;    x +  +  )     {", "offsets [  ( idx +  +  )  ]     =    x    /     (  ( float )     ( graphics . getWidth (  )  )  )  ;", "offsets [  ( idx +  +  )  ]     =    y    /     (  ( float )     ( graphics . getHeight (  )  )  )  ;", "}", "}", "System . out . println ( Arrays . toString ( offsets )  )  ;", "}", "METHOD_END"], "methodName": ["calculateOffsets"], "fileName": "com.badlogic.gdx.tests.EdgeDetectionTest"}, {"methodBody": ["METHOD_START", "{", "ShaderProgram . pedantic    =    false ;", "batchShader    =    new   ShaderProgram ( files . internal (  \" data / shaders / batch . vert \"  )  . readString (  )  ,    files . internal (  \" data / shaders / convolution . frag \"  )  . readString (  )  )  ;", "if    (  !  ( batchShader . isCompiled (  )  )  )     {", "app . log (  \"  \"  ,     (  \" couldn ' t   compile   post - processing   shader :     \"     +     ( batchShader . getLog (  )  )  )  )  ;", "}", "ObjLoader   objLoader    =    new   ObjLoader (  )  ;", "scene    =    objLoader . loadModel ( files . internal (  \" data / scene . obj \"  )  )  ;", "sceneInstance    =    new   com . badlogic . gdx . graphics . g 3 d . ModelInstance ( scene )  ;", "modelBatch    =    new   ModelBatch (  )  ;", "fbo    =    new   com . badlogic . gdx . graphics . glutils . FrameBuffer ( Format . RGB 5  6  5  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  ,    true )  ;", "cam    =    new   PerspectiveCamera (  6  7  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "cam . position . set (  0  ,     0  ,     1  0  )  ;", "cam . lookAt (  0  ,     0  ,     0  )  ;", "cam . far    =     3  0  ;", "batch    =    new   SpriteBatch (  )  ;", "batch . setShader ( batchShader )  ;", "fboRegion    =    new   com . badlogic . gdx . graphics . g 2 d . TextureRegion ( fbo . getColorBufferTexture (  )  )  ;", "fboRegion . flip ( false ,    true )  ;", "logger    =    new   FPSLogger (  )  ;", "calculateOffsets (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.EdgeDetectionTest"}, {"methodBody": ["METHOD_START", "{", "angle    +  =     4  5     *     ( graphics . getDeltaTime (  )  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "cam . update (  )  ;", "matrix . setToRota (  0  ,     1  ,     0  ,    angle )  ;", "cam . combined . mul ( matrix )  ;", "fbo . begin (  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "gl . glEnable ( GL _ DEPTH _ TEST )  ;", "modelBatch . begin ( cam )  ;", "modelBatch . render ( sceneInstance )  ;", "modelBatch . end (  )  ;", "fbo . end (  )  ;", "batch . begin (  )  ;", "batch . disableBlending (  )  ;", "batchShader . setUniformi (  \" u _ filterSize \"  ,    filter . length )  ;", "batchShader . setUniform 1 fv (  \" u _ filter \"  ,    filter ,     0  ,    filter . length )  ;", "batchShader . setUniform 2 fv (  \" u _ offsets \"  ,    offsets ,     0  ,    offsets . length )  ;", "batch . draw ( fboRegion ,     0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "batch . end (  )  ;", "logger . log (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.EdgeDetectionTest"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  )  ;", "}", "METHOD_END"], "methodName": ["fail"], "fileName": "com.badlogic.gdx.tests.FilesTest"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException ( msg )  ;", "}", "METHOD_END"], "methodName": ["fail"], "fileName": "com.badlogic.gdx.tests.FilesTest"}, {"methodBody": ["METHOD_START", "{", "String   path    =    new   File ( files . getExternalStoragePath (  )  ,     \" meow \"  )  . getAbsolutePath (  )  ;", "FileHandle   handle    =    files . absolute ( path )  ;", "handle . delete (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "if    ( handle . delete (  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "if    ( handle . child (  \" meow \"  )  . exists (  )  )", "fail (  )  ;", "if    (  !  ( handle . parent (  )  . exists (  )  )  )", "fail (  )  ;", "try    {", "handle . read (  )  . close (  )  ;", "fail (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "handle . mkdirs (  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  )  ;", "if    (  !  ( handle . isDirectory (  )  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "handle . child (  \" meow \"  )  . mkdirs (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     1  )", "fail (  )  ;", "FileHandle   child    =    handle . list (  )  [  0  ]  ;", "if    (  !  ( child . name (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( child . parent (  )  . exists (  )  )  )", "fail (  )  ;", "if    (  !  ( handle . deleteDirectory (  )  )  )", "fail (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "OutputStream   output    =    handle . write ( false )  ;", "output . write (  \" moo \"  . getBytes (  )  )  ;", "output . close (  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  )  ;", "if    (  ( handle . length (  )  )     !  =     3  )", "fail (  )  ;", "FileHandle   copy    =    files . absolute (  ( path    +     \"  - copy \"  )  )  ;", "copy . delete (  )  ;", "if    ( copy . exists (  )  )", "fail (  )  ;", "handle . copyTo ( copy )  ;", "if    (  !  ( copy . exists (  )  )  )", "fail (  )  ;", "if    (  ( copy . length (  )  )     !  =     3  )", "fail (  )  ;", "FileHandle   move    =    files . absolute (  ( path    +     \"  - move \"  )  )  ;", "move . delete (  )  ;", "if    ( move . exists (  )  )", "fail (  )  ;", "copy . moveTo ( move )  ;", "if    (  !  ( move . exists (  )  )  )", "fail (  )  ;", "if    (  ( move . length (  )  )     !  =     3  )", "fail (  )  ;", "move . deleteDirectory (  )  ;", "if    ( move . exists (  )  )", "fail (  )  ;", "InputStream   input    =    handle . read (  )  ;", "byte [  ]    bytes    =    new   byte [  6  ]  ;", "if    (  ( input . read ( bytes )  )     !  =     3  )", "fail (  )  ;", "input . close (  )  ;", "if    (  !  ( new   String ( bytes ,     0  ,     3  )  . equals (  \" moo \"  )  )  )", "fail (  )  ;", "output    =    handle . write ( true )  ;", "output . write (  \" cow \"  . getBytes (  )  )  ;", "output . close (  )  ;", "if    (  ( handle . length (  )  )     !  =     6  )", "fail (  )  ;", "input    =    handle . read (  )  ;", "if    (  ( input . read ( bytes )  )     !  =     6  )", "fail (  )  ;", "input . close (  )  ;", "if    (  !  ( new   String ( bytes ,     0  ,     6  )  . equals (  \" moocow \"  )  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "if    (  !  ( handle . name (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( handle . nameWithoutExtension (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( handle . extension (  )  . equals (  \"  \"  )  )  )", "fail (  )  ;", "handle . deleteDirectory (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "handle . delete (  )  ;", "handle . deleteDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["testAbsolute"], "fileName": "com.badlogic.gdx.tests.FilesTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( app . getType (  )  )     =  =     ( ApplicationType . iOS )  )", "return ;", "FileHandle   handle    =    files . classpath (  \" com /  / gdx / utils / arial -  1  5  . png \"  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "try    {", "handle . delete (  )  ;", "fail (  )  ;", "}    catch    ( Exception   expected )     {", "}", "try    {", "handle . list (  )  ;", "fail (  )  ;", "}    catch    ( Exception   expected )     {", "}", "try    {", "handle . read (  )  . close (  )  ;", "fail (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "FileHandle   dir    =    files . classpath (  \" com /  / gdx / utils \"  )  ;", "if    ( dir . isDirectory (  )  )", "fail (  )  ;", "FileHandle   child    =    dir . child (  \" arial -  1  5  . fnt \"  )  ;", "if    (  !  ( child . name (  )  . equals (  \" arial -  1  5  . fnt \"  )  )  )", "fail (  )  ;", "if    (  !  ( child . nameWithoutExtension (  )  . equals (  \" arial -  1  5  \"  )  )  )", "fail (  )  ;", "if    (  !  ( child . extension (  )  . equals (  \" fnt \"  )  )  )", "fail (  )  ;", "handle . read (  )  . close (  )  ;", "if    (  ( handle . readBytes (  )  . length )     !  =     ( handle . length (  )  )  )", "fail (  )  ;", "}", "METHOD_END"], "methodName": ["testClasspath"], "fileName": "com.badlogic.gdx.tests.FilesTest"}, {"methodBody": ["METHOD_START", "{", "String   path    =     \" meow \"  ;", "Handle   handle    =    files . external ( path )  ;", "handle . delete (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "if    ( handle . delete (  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "if    ( handle . child (  \" meow \"  )  . exists (  )  )", "fail (  )  ;", "if    (  !  ( handle . parent (  )  . exists (  )  )  )", "fail (  )  ;", "try    {", "handle . read (  )  . close (  )  ;", "fail (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "handle . mkdirs (  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  )  ;", "if    (  !  ( handle . isDirectory (  )  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "handle . child (  \" meow \"  )  . mkdirs (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     1  )", "fail (  )  ;", "Handle   child    =    handle . list (  )  [  0  ]  ;", "if    (  !  ( child . name (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( child . parent (  )  . exists (  )  )  )", "fail (  )  ;", "if    (  !  ( handle . deleteDirectory (  )  )  )", "fail (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "OutputStream   output    =    handle . write ( false )  ;", "output . write (  \" moo \"  . getBytes (  )  )  ;", "output . close (  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  )  ;", "if    (  ( handle . length (  )  )     !  =     3  )", "fail (  )  ;", "Handle   copy    =    files . external (  ( path    +     \"  - copy \"  )  )  ;", "copy . delete (  )  ;", "if    ( copy . exists (  )  )", "fail (  )  ;", "handle . copyTo ( copy )  ;", "if    (  !  ( copy . exists (  )  )  )", "fail (  )  ;", "if    (  ( copy . length (  )  )     !  =     3  )", "fail (  )  ;", "Handle   move    =    files . external (  ( path    +     \"  - move \"  )  )  ;", "move . delete (  )  ;", "if    ( move . exists (  )  )", "fail (  )  ;", "copy . moveTo ( move )  ;", "if    (  !  ( move . exists (  )  )  )", "fail (  )  ;", "if    (  ( move . length (  )  )     !  =     3  )", "fail (  )  ;", "move . deleteDirectory (  )  ;", "if    ( move . exists (  )  )", "fail (  )  ;", "InputStream   input    =    handle . read (  )  ;", "byte [  ]    bytes    =    new   byte [  6  ]  ;", "if    (  ( input . read ( bytes )  )     !  =     3  )", "fail (  )  ;", "input . close (  )  ;", "if    (  !  ( new   String ( bytes ,     0  ,     3  )  . equals (  \" moo \"  )  )  )", "fail (  )  ;", "output    =    handle . write ( true )  ;", "output . write (  \" cow \"  . getBytes (  )  )  ;", "output . close (  )  ;", "if    (  ( handle . length (  )  )     !  =     6  )", "fail (  )  ;", "input    =    handle . read (  )  ;", "if    (  ( input . read ( bytes )  )     !  =     6  )", "fail (  )  ;", "input . close (  )  ;", "if    (  !  ( new   String ( bytes ,     0  ,     6  )  . equals (  \" moocow \"  )  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "if    (  !  ( handle . name (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( handle . nameWithoutExtension (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( handle . extension (  )  . equals (  \"  \"  )  )  )", "fail (  )  ;", "handle . deleteDirectory (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "handle . delete (  )  ;", "handle . deleteDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["testExternal"], "fileName": "com.badlogic.gdx.tests.FilesTest"}, {"methodBody": ["METHOD_START", "{", "FileHandle   handle    =    files . internal (  \" data / badlogic . jpg \"  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  \" Couldn ' t   find   internal   file \"  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  \" Internal   file   shouldn ' t   be   a   directory \"  )  ;", "try    {", "handle . delete (  )  ;", "fail (  \" Shouldn ' t   be   able   to   delete   internal   file \"  )  ;", "}    catch    ( Exception   expected )     {", "}", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  \" File   length   shouldn ' t   be    0  \"  )  ;", "if    (  ( app . getType (  )  )     !  =     ( ApplicationType . Android )  )     {", "if    (  !  ( handle . parent (  )  . exists (  )  )  )", "fail (  \" Parent   doesn ' t   exist \"  )  ;", "}", "try    {", "handle . read (  )  . close (  )  ;", "fail (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "FileHandle   dir    =    files . internal (  \" data \"  )  ;", "if    (  ( app . getType (  )  )     !  =     ( ApplicationType . Android )  )     {", "if    (  !  ( dir . exists (  )  )  )", "fail (  )  ;", "}", "if    (  !  ( dir . isDirectory (  )  )  )", "fail (  )  ;", "if    (  ( dir . list (  )  . length )     =  =     0  )", "fail (  )  ;", "FileHandle   child    =    dir . child (  \" badlogic . jpg \"  )  ;", "if    (  !  ( child . name (  )  . equals (  \" badlogic . jpg \"  )  )  )", "fail (  )  ;", "if    (  !  ( child . nameWithoutExtension (  )  . equals (  \" badlogic \"  )  )  )", "fail (  )  ;", "if    (  !  ( child . extension (  )  . equals (  \" jpg \"  )  )  )", "fail (  )  ;", "if    (  ( app . getType (  )  )     !  =     ( ApplicationType . Android )  )     {", "if    (  !  ( child . parent (  )  . exists (  )  )  )", "fail (  )  ;", "}", "FileHandle   copy    =    files . external (  \" badlogic . jpg - copy \"  )  ;", "copy . delete (  )  ;", "if    ( copy . exists (  )  )", "fail (  )  ;", "handle . copyTo ( copy )  ;", "if    (  !  ( copy . exists (  )  )  )", "fail (  )  ;", "if    (  ( copy . length (  )  )     !  =     6  8  4  6  5  )", "fail (  )  ;", "copy . delete (  )  ;", "if    ( copy . exists (  )  )", "fail (  )  ;", "handle . read (  )  . close (  )  ;", "if    (  ( handle . readBytes (  )  . length )     !  =     ( handle . length (  )  )  )", "fail (  )  ;", "}", "METHOD_END"], "methodName": ["testInternal"], "fileName": "com.badlogic.gdx.tests.FilesTest"}, {"methodBody": ["METHOD_START", "{", "String   path    =     \" meow \"  ;", "Handle   handle    =    files . local ( path )  ;", "handle . delete (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "if    ( handle . delete (  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "if    ( handle . child (  \" meow \"  )  . exists (  )  )", "fail (  )  ;", "if    (  !  ( handle . parent (  )  . exists (  )  )  )", "fail (  )  ;", "try    {", "handle . read (  )  . close (  )  ;", "fail (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "handle . mkdirs (  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  )  ;", "if    (  !  ( handle . isDirectory (  )  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "handle . child (  \" meow \"  )  . mkdirs (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     1  )", "fail (  )  ;", "Handle   child    =    handle . list (  )  [  0  ]  ;", "if    (  !  ( child . name (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( child . parent (  )  . exists (  )  )  )", "fail (  )  ;", "if    (  !  ( handle . deleteDirectory (  )  )  )", "fail (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "OutputStream   output    =    handle . write ( false )  ;", "output . write (  \" moo \"  . getBytes (  )  )  ;", "output . close (  )  ;", "if    (  !  ( handle . exists (  )  )  )", "fail (  )  ;", "if    (  ( handle . length (  )  )     !  =     3  )", "fail (  )  ;", "Handle   copy    =    files . local (  ( path    +     \"  - copy \"  )  )  ;", "copy . delete (  )  ;", "if    ( copy . exists (  )  )", "fail (  )  ;", "handle . copyTo ( copy )  ;", "if    (  !  ( copy . exists (  )  )  )", "fail (  )  ;", "if    (  ( copy . length (  )  )     !  =     3  )", "fail (  )  ;", "Handle   move    =    files . local (  ( path    +     \"  - move \"  )  )  ;", "move . delete (  )  ;", "if    ( move . exists (  )  )", "fail (  )  ;", "copy . moveTo ( move )  ;", "if    (  !  ( move . exists (  )  )  )", "fail (  )  ;", "if    (  ( move . length (  )  )     !  =     3  )", "fail (  )  ;", "move . deleteDirectory (  )  ;", "if    ( move . exists (  )  )", "fail (  )  ;", "InputStream   input    =    handle . read (  )  ;", "byte [  ]    bytes    =    new   byte [  6  ]  ;", "if    (  ( input . read ( bytes )  )     !  =     3  )", "fail (  )  ;", "input . close (  )  ;", "if    (  !  ( new   String ( bytes ,     0  ,     3  )  . equals (  \" moo \"  )  )  )", "fail (  )  ;", "output    =    handle . write ( true )  ;", "output . write (  \" cow \"  . getBytes (  )  )  ;", "output . close (  )  ;", "if    (  ( handle . length (  )  )     !  =     6  )", "fail (  )  ;", "input    =    handle . read (  )  ;", "if    (  ( input . read ( bytes )  )     !  =     6  )", "fail (  )  ;", "input . close (  )  ;", "if    (  !  ( new   String ( bytes ,     0  ,     6  )  . equals (  \" moocow \"  )  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "if    (  ( handle . list (  )  . length )     !  =     0  )", "fail (  )  ;", "if    (  !  ( handle . name (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( handle . nameWithoutExtension (  )  . equals (  \" meow \"  )  )  )", "fail (  )  ;", "if    (  !  ( handle . extension (  )  . equals (  \"  \"  )  )  )", "fail (  )  ;", "handle . deleteDirectory (  )  ;", "if    ( handle . exists (  )  )", "fail (  )  ;", "if    ( handle . isDirectory (  )  )", "fail (  )  ;", "handle . delete (  )  ;", "handle . deleteDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["testLocal"], "fileName": "com.badlogic.gdx.tests.FilesTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "sceneMatrix    =    new   Matrix 4  (  )  . setToOrtho 2 D (  0  ,     0  ,     4  8  0  ,     3  2  0  )  ;", "textMatrix    =    new   Matrix 4  (  )  . setToOrtho 2 D (  0  ,     0  ,     4  8  0  ,     3  2  0  )  ;", "atlas    =    new   graphics . g 2 d . TextureAtlas ( files . internal (  \" data / issue _ pack \"  )  ,    files . internal (  \" data /  \"  )  )  ;", "texture    =    new   graphics . Texture ( files . internal (  \" data / resource 1  . jpg \"  )  ,    true )  ;", "texture . setFilter ( MipMap ,    Nearest )  ;", "setTextureFilter (  0  )  ;", "setModeString (  )  ;", "sprite    =    atlas . createSprite (  \" map \"  )  ;", "sprite 2     =    new   graphics . g 2 d . Sprite ( texture ,     0  ,     0  ,     8  5  5  ,     4  8  0  )  ;", "font    =    new   graphics . g 2 d . BitmapFont ( files . internal (  \" data / font . fnt \"  )  ,    files . internal (  \" data / font . png \"  )  ,    false )  ;", "input . setInputProcessor ( new   InputAdapter (  )     {", "public   boolean   touchDown ( int   x ,    int   y ,    int   pointer ,    int   newParam )     {", "( mode )  +  +  ;", "if    (  ( mode )     =  =     (  ( filters . length )     *     2  )  )", "mode    =     0  ;", "setTextureFilter (  (  ( mode )     /     2  )  )  ;", "setModeString (  )  ;", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.FilterPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . setProjectionMatrix ( sceneMatrix )  ;", "batch . begin (  )  ;", "renderSprite (  )  ;", "batch . end (  )  ;", "batch . setProjectionMatrix ( textMatrix )  ;", "batch . begin (  )  ;", "font . draw ( batch ,     (  (  ( modeString )     +     \"    fps :  \"  )     +     ( graphics . getFramesSecond (  )  )  )  ,     2  6  ,     6  5  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.FilterPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "batch . disableBlending (  )  ;", "if    (  (  ( mode )     %     2  )     =  =     0  )", "sprite 2  . draw ( batch )  ;", "else", "sprite . draw ( batch )  ;", "batch . enableBlending (  )  ;", "}", "METHOD_END"], "methodName": ["renderSprite"], "fileName": "com.badlogic.gdx.tests.FilterPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "modeString    =     (  (  (  ( mode )     %     2  )     =  =     0     ?     \" Sprite \"     :     \" Atlas \"  )     +     \"     \"  )     +     ( filterNames [  (  ( mode )     /     2  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["setModeString"], "fileName": "com.badlogic.gdx.tests.FilterPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "atlas . findRegion (  \" map \"  )  . getTexture (  )  . bind (  )  ;", "gl . glTexParameterf ( GL _ TEXTURE _  2 D ,    GL _ TEXTURE _ MIN _ FILTER ,    fs [ f ]  )  ;", "texture . bind (  )  ;", "gl . glTexParameterf ( GL _ TEXTURE _  2 D ,    GL _ TEXTURE _ MIN _ FILTER ,    fs [ f ]  )  ;", "}", "METHOD_END"], "methodName": ["setTextureFilter"], "fileName": "com.badlogic.gdx.tests.FilterPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( quad )     !  =    null )", "return ;", "quad    =    new   Mesh ( true ,     4  ,     6  ,    new   graphics . VertexAttribute ( Usage . Position ,     3  ,     \" a _ position \"  )  ,    new   graphics . VertexAttribute ( Usage . ColorUnpacked ,     4  ,     \" a _ color \"  )  ,    new   graphics . VertexAttribute ( Usage . TextureCoordinates ,     2  ,     \" a _ texCoords \"  )  )  ;", "quad . setVertices ( new   float [  ]  {     -  1  ,     -  1  ,     0  ,     1  ,     1  ,     1  ,     1  ,     0  ,     1  ,     1  ,     -  1  ,     0  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     0  ,     1  ,     1  ,     1  ,     1  ,     1  ,     0  ,     -  1  ,     1  ,     0  ,     1  ,     1  ,     1  ,     1  ,     0  ,     0     }  )  ;", "quad . setIndices ( new   short [  ]  {     0  ,     1  ,     2  ,     2  ,     3  ,     0     }  )  ;", "}", "METHOD_END"], "methodName": ["createQuad"], "fileName": "com.badlogic.gdx.tests.FloatTextureTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( screenQuad )     !  =    null )", "return ;", "screenQuad    =    new   Mesh ( true ,     4  ,     6  ,    new   graphics . VertexAttribute ( Usage . Position ,     3  ,     \" a _ position \"  )  ,    new   graphics . VertexAttribute ( Usage . ColorUnpacked ,     4  ,     \" a _ color \"  )  ,    new   graphics . VertexAttribute ( Usage . TextureCoordinates ,     2  ,     \" a _ texCoords \"  )  )  ;", "Vector 3    vec 0     =    new   Vector 3  (  0  ,     0  ,     0  )  ;", "screenCamera . unproject ( vec 0  )  ;", "Vector 3    vec 1     =    new   Vector 3  ( graphics . getWidth (  )  ,    graphics . getHeight (  )  ,     0  )  ;", "screenCamera . unproject ( vec 1  )  ;", "screenQuad . setVertices ( new   float [  ]  {    vec 0  . x ,    vec 0  . y ,     0  ,     1  ,     1  ,     1  ,     1  ,     0  ,     1  ,    vec 1  . x ,    vec 0  . y ,     0  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,    vec 1  . x ,    vec 1  . y ,     0  ,     1  ,     1  ,     1  ,     1  ,     1  ,     0  ,    vec 0  . x ,    vec 1  . y ,     0  ,     1  ,     1  ,     1  ,     1  ,     0  ,     0     }  )  ;", "screenQuad . setIndices ( new   short [  ]  {     0  ,     1  ,     2  ,     2  ,     3  ,     0     }  )  ;", "}", "METHOD_END"], "methodName": ["createScreenQuad"], "fileName": "com.badlogic.gdx.tests.FloatTextureTest"}, {"methodBody": ["METHOD_START", "{", "gl 2  0  . glViewport (  0  ,     0  ,    graphics . getBackBufferWidth (  )  ,    graphics . getBackBufferHeight (  )  )  ;", "gl 2  0  . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "fb . begin (  )  ;", "fbshader . begin (  )  ;", "fbshader . setUniformf (  \" u _ viewport \"  ,    fb . getWidth (  )  ,    fb . getHeight (  )  )  ;", "fbshader . setUniformf (  \" u _ color \"  ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F )  ;", "quad . render ( fbshader ,    GL _ TRIANGLES )  ;", "fbshader . end (  )  ;", "fb . end (  )  ;", "ffb . begin (  )  ;", "fbshader . begin (  )  ;", "fbshader . setUniformf (  \" u _ viewport \"  ,    ffb . getWidth (  )  ,    ffb . getHeight (  )  )  ;", "fbshader . setUniformf (  \" u _ color \"  ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F )  ;", "quad . render ( fbshader ,    GL _ TRIANGLES )  ;", "fbshader . end (  )  ;", "ffb . end (  )  ;", "shader . begin (  )  ;", "fb . getColorBuffer (  )  . bind (  0  )  ;", "ffb . getColorBuffer (  )  . bind (  1  )  ;", "shader . setUniformMatrix (  \" u _ worldView \"  ,    screenCamera . combined )  ;", "shader . setUniformi (  \" u _ fbtex \"  ,     0  )  ;", "shader . setUniformi (  \" u _ ffbtex \"  ,     1  )  ;", "screenQuad . render ( shader ,    GL _ TRIANGLES )  ;", "shader . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.FloatTextureTest"}, {"methodBody": ["METHOD_START", "{", "String   vertexShader    =     \" attribute   vec 4    a _ Position ;              \\ n \"     +     (  (  (  (  (  (  (  (  (  \" attribute   vec 4    a _ Color ;  \\ n \"     +     \" attribute   vec 2    a _ texCoords ;  \\ n \"  )     +     \" varying   vec 4    v _ Color ;  \"  )     +     \" varying   vec 2    v _ texCoords ;     \\ n \"  )     +     \" void   main (  )                                                        \\ n \"  )     +     \"  {                                                                                      \\ n \"  )     +     \"          v _ Color    =    a _ Color ;  \"  )     +     \"          v _ texCoords    =    a _ texCoords ;  \\ n \"  )     +     \"          gl _ Position    =          a _ Position ;        \\ n \"  )     +     \"  }                                                                                      \\ n \"  )  ;", "String   fragmentShader    =     \"  # ifdef   GL _ ES \\ n \"     +     (  (  (  (  (  (  (  (  \" precision   mediump   float ;  \\ n \"     +     \"  # endif \\ n \"  )     +     \" varying   vec 4    v _ Color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;     \\ n \"  )     +     \" uniform   sampler 2 D   u _ texture ;  \\ n \"  )     +     \" void   main (  )                                                                                                        \\ n \"  )     +     \"  {                                                                                                                                      \\ n \"  )     +     \"       gl _ gColor    =    v _ Color    *    texture 2 D ( u _ texture ,    v _ texCoords )  ;  \\ n \"  )     +     \"  }  \"  )  ;", "meshShader    =    new   ShaderProgram ( vertexShader ,    fragmentShader )  ;", "if    (  ( meshShader . isCompiled (  )  )     =  =    false )", "throw   new   IllegalStateException ( meshShader . getLog (  )  )  ;", "}", "METHOD_END"], "methodName": ["createShader"], "fileName": "com.badlogic.gdx.tests.FrameBufferTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "FileTextureData   data    =    new   FileTextureData ( files . internal (  \" data / premultiplied _ alpha _ test . png \"  )  ,    null ,    null ,    false )  ;", "goodTexture    =    new   graphics . Texture ( data )  ;", "Pixmap   pixmap    =    new   Pixmap ( files . internal (  \" data / premultiplied _ alpha _ test . png \"  )  )  ;", "pixmap . getPixel (  0  ,     0  )  ;", "FileTextureData   data 1     =    new   FileTextureData ( null ,    pixmap ,    null ,    false )  ;", "badTexture    =    new   graphics . Texture ( data 1  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.GWTLossyPremultipliedAlphaTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.GWTLossyPremultipliedAlphaTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  ,     0  ,     0  ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "batch . setBlendFunction ( GL _ ONE ,    GL _ ONE _ MINUS _ SRC _ ALPHA )  ;", "batch . draw ( Texture ,     0  ,    graphics . getHeight (  )  ,     (  ( graphics . getWidth (  )  )     *     0  .  5 F )  ,     (  -  ( graphics . getHeight (  )  )  )  )  ;", "batch . draw ( goodTexture ,     (  ( graphics . getWidth (  )  )     *     0  .  5 F )  ,    graphics . getHeight (  )  ,     (  ( graphics . getWidth (  )  )     *     0  .  5 F )  ,     (  -  ( graphics . getHeight (  )  )  )  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.GWTLossyPremultipliedAlphaTest"}, {"methodBody": ["METHOD_START", "{", "pixmap . clear ( Color . rgba 8  8  8  8  (  1  ,     0  ,     0  ,     0  .  1 F )  )  ;", "pixmap . setPixel (  1  6  ,     1  6  ,    Color . rgba 8  8  8  8  (  0  ,     0  ,     1  ,     1  )  )  ;", "int   clearColor    =     0  ;", "int   pixelColor    =     0  ;", "switch    ( pixmap . getFormat (  )  )     {", "case   Pixmap . GDX 2 D _ FORMAT _ ALPHA    :", "clearColor    =    Color . rgba 8  8  8  8  (  1  ,     1  ,     1  ,     0  .  1 F )  ;", "pixelColor    =    Color . rgba 8  8  8  8  (  1  ,     1  ,     1  ,     1  )  ;", "break ;", "case   Pixmap . GDX 2 D _ FORMAT _ LUMINANCE _ ALPHA    :", "clearColor    =     9  0  9  5  2  2  4  5  7  ;", "pixelColor    =     -  2  3  8  ;", "break ;", "case   Pixmap . GDX 2 D _ FORMAT _ RGB 5  6  5     :", "clearColor    =    Color . rgba 8  8  8  8  (  1  ,     0  ,     0  ,     1  )  ;", "pixelColor    =    Color . rgba 8  8  8  8  (  0  ,     0  ,     1  ,     1  )  ;", "break ;", "case   Pixmap . GDX 2 D _ FORMAT _ RGB 8  8  8     :", "clearColor    =    Color . rgba 8  8  8  8  (  1  ,     0  ,     0  ,     1  )  ;", "pixelColor    =    Color . rgba 8  8  8  8  (  0  ,     0  ,     1  ,     1  )  ;", "break ;", "case   Pixmap . GDX 2 D _ FORMAT _ RGBA 4  4  4  4     :", "clearColor    =     -  1  6  7  7  7  1  9  9  ;", "pixelColor    =    Color . rgba 8  8  8  8  (  0  ,     0  ,     1  ,     1  )  ;", "break ;", "case   Pixmap . GDX 2 D _ FORMAT _ RGBA 8  8  8  8     :", "clearColor    =    Color . rgba 8  8  8  8  (  1  ,     0  ,     0  ,     0  .  1 F )  ;", "pixelColor    =    Color . rgba 8  8  8  8  (  0  ,     0  ,     1  ,     1  )  ;", "}", "if    (  ( pixmap . getPixel (  1  5  ,     1  6  )  )     !  =    clearColor )", "throw   new   RuntimeException (  (  \" error   clear :     \"     +     ( pixmap . getFormatString (  )  )  )  )  ;", "if    (  ( pixmap . getPixel (  1  6  ,     1  6  )  )     !  =    pixelColor )", "throw   new   RuntimeException (  (  \" error   pixel :     \"     +     ( pixmap . getFormatString (  )  )  )  )  ;", "pixmap . drawLine (  0  ,     0  ,     3  1  ,     3  1  ,    Color . rgba 8  8  8  8  (  1  ,     1  ,     1  ,     1  )  )  ;", "pixmap . drawRect (  1  0  ,     1  0  ,     5  ,     7  ,    Color . rgba 8  8  8  8  (  1  ,     1  ,     0  ,     0  .  5 F )  )  ;", "pixmap . fillRect (  2  0  ,     1  0  ,     5  ,     7  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     0  .  5 F )  )  ;", "pixmap . drawCircle (  1  6  ,     1  6  ,     1  0  ,    Color . rgba 8  8  8  8  (  1  ,     0  ,     1  ,     1  )  )  ;", "pixmap . fillCircle (  1  6  ,     1  6  ,     6  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     0  ,     0  .  5 F )  )  ;", "pixmap . fillTriangle (  1  6  ,     1  6  ,     1  8  ,     1  8  ,     2  0  ,     1  4  ,    Color . rgba 8  8  8  8  (  0  ,     0  .  5 F ,     0  ,     0  .  5 F )  )  ;", "pixmap . drawLine (  0  ,     (  -  1  )  ,     0  ,     0  ,    Color . rgba 8  8  8  8  (  1  ,     1  ,     0  ,     1  )  )  ;", "pixmap . drawLine (  4  1  ,     (  -  1  0  )  ,     3  1  ,     0  ,    Color . rgba 8  8  8  8  (  1  ,     1  ,     0  ,     1  )  )  ;", "pixmap . drawLine (  1  0  ,     4  1  ,     0  ,     3  1  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     1  )  )  ;", "pixmap . drawLine (  4  1  ,     4  1  ,     3  1  ,     3  1  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     1  )  )  ;", "pixmap . drawRect (  (  -  1  0  )  ,     (  -  1  0  )  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     1  )  )  ;", "pixmap . drawRect (  2  1  ,     (  -  1  0  )  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     1  )  )  ;", "pixmap . drawRect (  (  -  1  0  )  ,     2  1  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     1  )  )  ;", "pixmap . drawRect (  2  1  ,     2  1  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     1  )  )  ;", "pixmap . fillRect (  (  -  1  0  )  ,     (  -  1  0  )  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     0  .  5 F )  )  ;", "pixmap . fillRect (  2  1  ,     (  -  1  0  )  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     0  .  5 F )  )  ;", "pixmap . fillRect (  (  -  1  0  )  ,     2  1  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     0  .  5 F )  )  ;", "pixmap . fillRect (  2  1  ,     2  1  ,     2  0  ,     2  0  ,    Color . rgba 8  8  8  8  (  0  ,     1  ,     1  ,     0  .  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["drawToPixmap"], "fileName": "com.badlogic.gdx.tests.Gdx2DTest"}, {"methodBody": ["METHOD_START", "{", "int [  ]    formats    =    new   int [  ]  {    Gdx 2 DPixmap . GDX 2 D _ FORMAT _ ALPHA ,    Gdx 2 DPixmap . GDX 2 D _ FORMAT _ LUMINANCE _ ALPHA ,    Gdx 2 DPixmap . GDX 2 D _ FORMAT _ RGB 5  6  5  ,    Gdx 2 DPixmap . GDX 2 D _ FORMAT _ RGB 8  8  8  ,    Gdx 2 DPixmap . GDX 2 D _ FORMAT _ RGBA 4  4  4  4  ,    Gdx 2 DPixmap . GDX 2 D _ FORMAT _ RGBA 8  8  8  8     }  ;", "Gdx 2 DPixmap [  ]    pixmaps    =    new   Gdx 2 DPixmap [ formats . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( pixmaps . length )  ;    i +  +  )     {", "Gdx 2 DPixmap   pixmap    =    new   Gdx 2 DPixmap (  6  4  ,     3  2  ,    formats [ i ]  )  ;", "drawToPixmap ( pixmap )  ;", "pixmaps [ i ]     =    pixmap ;", "}", "return   pixmaps ;", "}", "METHOD_END"], "methodName": ["testPixmaps"], "fileName": "com.badlogic.gdx.tests.Gdx2DTest"}, {"methodBody": ["METHOD_START", "{", "Texture   texture    =    new   Texture ( pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    Format . RGB 5  6  5  )  ;", "texture . bind (  )  ;", "gl . glTexImage 2 D ( GL _ TEXTURE _  2 D ,     0  ,    pixmap . getGLInternalFormat (  )  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,     0  ,    pixmap . getGLFormat (  )  ,    pixmap . getGLType (  )  ,    pixmap . getPixels (  )  )  ;", "return   texture ;", "}", "METHOD_END"], "methodName": ["textureFromPixmap"], "fileName": "com.badlogic.gdx.tests.Gdx2DTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "root    =    new   Table (  )  ;", "root . setFillParent ( true )  ;", "stage . addActor ( root )  ;", "skin    =    new   scenes . scene 2 d . ui . Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "Table   labels    =    new   Table (  )  ;", "root . add ( new   scenes . scene 2 d . ui . ScrollPane ( labels ,    skin )  )  . expand (  )  . fill (  )  ;", "root . row (  )  ;", "root . add (  ( drawnLabel    =    new   Label (  \"  \"  ,    skin )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( GroupCullingTest . count )  ;    i +  +  )     {", "labels . add ( new   Label (  (  \" Label :     \"     +    i )  ,    skin )     {", "public   void   draw ( Batch   batch ,    float   parentAlpha )     {", "super . draw ( batch ,    parentAlpha )  ;", "( drawn )  +  +  ;", "}", "}  )  ;", "labels . row (  )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.GroupCullingTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.GroupCullingTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "drawn    =     0  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "drawnLabel . setText (  (  (  (  \" Drawn :     \"     +     ( drawn )  )     +     \"  /  \"  )     +     (  . count )  )  )  ;", "drawnLabel . invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.GroupCullingTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "root . invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.GroupCullingTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "font    =    new   BitmapFont (  )  ;", "renderer    =    new   ShapeRenderer (  )  ;", "stage    =    new   scenes . scene 2 d . Stage ( new   ScreenViewport (  )  )  ;", "input . setInputProcessor ( stage )  ;", "region    =    new   TextureRegion ( new   Texture ( files . internal (  \" data / group - debug . png \"  )  )  )  ;", "group 2     =    new   GroupTest . TestGroup (  \" group 2  \"  )  ;", "group 2  . setTransform ( true )  ;", "stage . addActor ( group 2  )  ;", "group 1     =    new   GroupTest . TestGroup (  \" group 1  \"  )  ;", "group 1  . setTransform ( true )  ;", "group 2  . addActor ( group 1  )  ;", "LabelStyle   style    =    new   LabelStyle (  )  ;", "style . font    =    new   BitmapFont (  )  ;", "Texture   texture    =    new   Texture ( files . internal (  \" data / badlogic . jpg \"  )  )  ;", "horiz    =    new   HorizontalGroup (  )  . pad (  1  0  ,     2  0  ,     3  0  ,     4  0  )  . top (  )  . space (  5  )  . reverse (  )  ;", "for    ( int   i    =     1  ;    i    <  =     1  5  ;    i +  +  )     {", "horiz . addActor ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"  ,  \"  )  ,    style )  )  ;", "if    ( i    =  =     7  )", "horiz . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . size (  1  0  )  )  ;", "}", "horiz . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . fill (  )  . prefSize (  3  0  )  )  ;", "horiz . debug (  )  ;", "horiz . setPosition (  1  0  ,     1  0  )  ;", "horiz . pack (  )  ;", "stage . addActor ( horiz )  ;", "horizWrap    =    new   HorizontalGroup (  )  . wrap (  )  . pad (  1  0  ,     2  0  ,     3  0  ,     4  0  )  . right (  )  . rowBottom (  )  . space (  5  )  . wrapSpace (  1  5  )  . reverse (  )  ;", "for    ( int   i    =     1  ;    i    <  =     1  5  ;    i +  +  )     {", "horizWrap . addActor ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"  ,  \"  )  ,    style )  )  ;", "if    ( i    =  =     7  )", "horizWrap . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . prefSize (  1  0  )  . fill (  )  )  ;", "}", "horizWrap . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . prefSize (  3  0  )  )  ;", "horizWrap . debug (  )  ;", "horizWrap . setBounds (  1  0  ,     8  5  ,     1  5  0  ,     4  0  )  ;", "stage . addActor ( horizWrap )  ;", "vert    =    new   VerticalGroup (  )  . pad (  1  0  ,     2  0  ,     3  0  ,     4  0  )  . top (  )  . space (  5  )  . reverse (  )  ;", "for    ( int   i    =     1  ;    i    <  =     8  ;    i +  +  )     {", "vert . addActor ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"  ,  \"  )  ,    style )  )  ;", "if    ( i    =  =     4  )", "vert . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . size (  1  0  )  )  ;", "}", "vert . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . size (  3  0  )  )  ;", "vert . debug (  )  ;", "vert . setPosition (  5  1  5  ,     1  0  )  ;", "vert . pack (  )  ;", "stage . addActor ( vert )  ;", "vertWrap    =    new   VerticalGroup (  )  . wrap (  )  . pad (  1  0  ,     2  0  ,     3  0  ,     4  0  )  . bottom (  )  . columnRight (  )  . space (  5  )  . wrapSpace (  1  5  )  . reverse (  )  ;", "for    ( int   i    =     1  ;    i    <  =     8  ;    i +  +  )     {", "vertWrap . addActor ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"  ,  \"  )  ,    style )  )  ;", "if    ( i    =  =     4  )", "vertWrap . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . prefSize (  1  0  )  . fill (  )  )  ;", "}", "vertWrap . addActor ( new   Container ( new   scenes . scene 2 d . ui . Image ( texture )  )  . prefSize (  3  0  )  )  ;", "vertWrap . debug (  )  ;", "vertWrap . setBounds (  6  1  0  ,     1  0  ,     1  5  0  ,     4  0  )  ;", "stage . addActor ( vertWrap )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.GroupTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.GroupTest"}, {"methodBody": ["METHOD_START", "{", "horiz . setVisible ( true )  ;", "horiz . setWidth (  (  ( input . getX (  )  )     -     ( horiz . getX (  )  )  )  )  ;", "horiz . setHeight (  1  0  0  )  ;", "horiz . fill (  )  ;", "horiz . expand (  )  ;", "horiz . invalidate (  )  ;", "horizWrap . setVisible ( true )  ;", "horizWrap . fill (  )  ;", "horizWrap . expand (  )  ;", "horizWrap . setWidth (  (  ( input . getX (  )  )     -     ( horizWrap . getX (  )  )  )  )  ;", "horizWrap . setHeight (  2  0  0  )  ;", "vert . setHeight (  (  (  ( graphics . getHeight (  )  )     -     ( input . getY (  )  )  )     -     ( vert . getY (  )  )  )  )  ;", "vertWrap . setHeight (  (  (  ( graphics . getHeight (  )  )     -     ( input . getY (  )  )  )     -     ( vertWrap . getY (  )  )  )  )  ;", "vertWrap . setWidth (  2  0  0  )  ;", "g 2  . setBounds (  1  5  0  ,     1  5  0  ,     1  5  0  ,     1  5  0  )  ;", "g 2  . setRotation (  4  5  )  ;", "g 2  . setOrigin (  1  5  0  ,     1  5  0  )  ;", "g 2  . setScale (  1  .  2  5 F )  ;", "g 1  . setBounds (  1  5  0  ,     1  5  0  ,     5  0  ,     5  0  )  ;", "g 1  . setRotation (  4  5  )  ;", "g 1  . setOrigin (  2  5  ,     2  5  )  ;", "g 1  . setScale (  1  .  3 F )  ;", "gl . glClearColor (  0  ,     0  ,     0  ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . draw (  )  ;", "renderer . setProjectionMatrix ( batch . getProjectionMatrix (  )  )  ;", "renderer . begin ( Filled )  ;", "if    ( MathUtils . randomBoolean (  )  )     {", "renderer . setColor ( GREEN )  ;", "renderer . circle ( g 1  . toScreenCoordinates . x ,     (  ( graphics . getHeight (  )  )     -     ( g 1  . toScreenCoordinates . y )  )  ,     5  )  ;", "renderer . setColor ( RED )  ;", "renderer . circle ( g 1  . localToParentCoordinates . x ,     (  ( graphics . getHeight (  )  )     -     ( g 1  . localToParentCoordinates . y )  )  ,     5  )  ;", "} else    {", "renderer . setColor ( RED )  ;", "renderer . circle ( g 1  . localToParentCoordinates . x ,     (  ( graphics . getHeight (  )  )     -     ( g 1  . localToParentCoordinates . y )  )  ,     5  )  ;", "renderer . setColor ( GREEN )  ;", "renderer . circle ( g 1  . toScreenCoordinates . x ,     (  ( graphics . getHeight (  )  )     -     ( g 1  . toScreenCoordinates . y )  )  ,     5  )  ;", "}", "renderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.GroupTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.GroupTest"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  ( header    +     \"     -  >    locale :     \"  )     +     ( rb . getLocale (  )  )  )     +     \"  ,    msg :     \\  \"  \"  )     +     ( rb . format (  \" msg \"  )  )  )     +     \"  \\  \"  ,    rootMsg :     \\  \"  \"  )     +     ( rb . format (  \" rootMsg \"  )  )  )     +     \"  \\  \"  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "com.badlogic.gdx.tests.I18NMessageTest"}, {"methodBody": ["METHOD_START", "{", "return    ( header    +     \"     -  >     \"  )     +     ( rb . format (  \" msgWithArgs \"  ,     \" LibGDX \"  ,    PI ,    now )  )  ;", "}", "METHOD_END"], "methodName": ["getParametricMessage"], "fileName": "com.badlogic.gdx.tests.I18NMessageTest"}, {"methodBody": ["METHOD_START", "{", "message    +  =    line    +     \"  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["println"], "fileName": "com.badlogic.gdx.tests.I18NMessageTest"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  ( header    +     \"     -  >    locale :     \"  )     +     ( rb . getLocale (  )  )  )     +     \"  ,    msg :     \\  \"  \"  )     +     ( rb . format (  \" msg \"  )  )  )     +     \"  \\  \"  ,    rootMsg :     \\  \"  \"  )     +     ( rb . format (  \" rootMsg \"  )  )  )     +     \"  \\  \"  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "com.badlogic.gdx.tests.I18NSimpleMessageTest"}, {"methodBody": ["METHOD_START", "{", "return    ( header    +     \"     -  >     \"  )     +     ( rb . format (  \" msgWithArgs \"  ,     \" LibGDX \"  ,    PI ,    now )  )  ;", "}", "METHOD_END"], "methodName": ["getParametricMessage"], "fileName": "com.badlogic.gdx.tests.I18NSimpleMessageTest"}, {"methodBody": ["METHOD_START", "{", "message    +  =    line    +     \"  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["println"], "fileName": "com.badlogic.gdx.tests.I18NSimpleMessageTest"}, {"methodBody": ["METHOD_START", "{", "NSAutoreleasePool   pool    =    new   NSAutoreleasePool (  )  ;", "UIApplication . main ( argv ,    null ,     . class )  ;", "pool . close (  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.IOSRobovmTests"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "texture    =    new   Texture (  \" data / group - debug . png \"  )  ;", "image    =    new    ( texture )  ;", "image . setScaling ( fit )  ;", "image . setBounds (  1  0  0  ,     1  0  0  ,     4  0  0  ,     2  0  0  )  ;", "stage . addActor ( image )  ;", "image 2     =    new    ( texture )  ;", "image 2  . setScaling ( fit )  ;", "image . setBounds (  1  0  0  ,     1  0  0  ,     4  0  0  ,     2  0  0  )  ;", "image 2  . setOrigin (  2  0  0  ,     1  0  0  )  ;", "image 2  . setScale (  0  .  5 F )  ;", "stage . addActor ( image 2  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ImageScaleTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  ,     0  ,     0  ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "st . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ImageScaleTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.ImageScaleTest"}, {"methodBody": ["METHOD_START", "{", "if    ( button    =  =     ( Buttons . LEFT )  )", "return    \" left \"  ;", "if    ( button    =  =     ( Buttons . RIGHT )  )", "return    \" right \"  ;", "if    ( button    =  =     ( Buttons . MIDDLE )  )", "return    \" middle \"  ;", "if    ( button    =  =     ( Buttons . BACK )  )", "return    \" back \"  ;", "if    ( button    =  =     ( Buttons . FORWARD )  )", "return    \" forward \"  ;", "return    \" unknown \"  ;", "}", "METHOD_END"], "methodName": ["getButtonString"], "fileName": "com.badlogic.gdx.tests.InputTest"}, {"methodBody": ["METHOD_START", "{", "TextureAtlas   textureAtlas    =    new   TextureAtlas (  \" data / pack \"  )  ;", "font    =    new   graphics . g 2 d . BitmapFont ( files . internal (  \" data / verdana 3  9  . fnt \"  )  ,    textureAtlas . findRegion (  \" verdana 3  9  \"  )  ,    false )  ;", "singleLineCache    =    new   graphics . g 2 d . BitmapFontCache ( font ,    true )  ;", "multiLineCache    =    new   graphics . g 2 d . BitmapFontCache ( font ,    true )  ;", "singleLineCacheNonInteger    =    new   graphics . g 2 d . BitmapFontCache ( font ,    false )  ;", "multiLineCacheNonInteger    =    new   graphics . g 2 d . BitmapFontCache ( font ,    false )  ;", "batch    =    new   SpriteBatch (  )  ;", "fillCaches (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.IntegerBitmapFontTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" This   is   a   TEST \\ nxahsdhwekjhasd 2  3  \\ ufffd \\ ufffd \\ ufffd $  %  $  %  /  %  &  \"  ;", "f . draw ( batch ,    text ,     1  0  .  2 F ,     3  0  .  5 F )  ;", "f . draw ( batch ,    text ,     1  0  .  5 F ,     1  2  0  .  5 F )  ;", "f . draw ( batch ,    text ,     1  0  .  5 F ,     1  8  0  .  5 F ,     2  0  0  ,    center ,    false )  ;", "}", "METHOD_END"], "methodName": ["drawTexts"], "fileName": "com.badlogic.gdx.tests.IntegerBitmapFontTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" This   is   a   TEST \\ nxahsdhwekjhasd 2  3  \\ ufffd \\ ufffd \\ ufffd $  %  $  %  /  %  &  \"  ;", "singleLineCache . setColor (  0  ,     0  ,     1  ,     1  )  ;", "singleLineCache . setText ( text ,     1  0  .  2 F ,     3  0  .  5 F )  ;", "multiLineCache . setColor (  0  ,     0  ,     1  ,     1  )  ;", "multiLineCache . setText ( text ,     1  0  .  5 F ,     1  8  0  .  5 F ,     2  0  0  ,    center ,    false )  ;", "singleLineCacheNon . setColor (  0  ,     1  ,     0  ,     1  )  ;", "singleLineCacheNon . setText ( text ,     1  0  .  2 F ,     3  0  .  5 F )  ;", "multiLineCacheNon . setColor (  0  ,     1  ,     0  ,     1  )  ;", "multiLineCacheNon . setText ( text ,     1  0  .  5 F ,     1  8  0  .  5 F ,     2  0  0  ,    center ,    false )  ;", "}", "METHOD_END"], "methodName": ["fillCaches"], "fileName": "com.badlogic.gdx.tests.IntegerBitmapFontTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "font . setUsePositions ( false )  ;", "font . setColor (  1  ,     0  ,     0  ,     1  )  ;", "singleLineCacheNon . draw ( batch )  ;", "multiLineCacheNon . draw ( batch )  ;", "drawTexts (  )  ;", "font . setUsePositions ( true )  ;", "font . setColor (  1  ,     1  ,     1  ,     1  )  ;", "singleLineCache . draw ( batch )  ;", "multiLineCache . draw ( batch )  ;", "drawTexts (  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.IntegerBitmapFontTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "skin . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.InterpolationTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  (  )     ( ClassReflection . getField (  . class ,    name )  . get ( null )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getInterpolation"], "fileName": "com.badlogic.gdx.tests.InterpolationTest"}, {"methodBody": ["METHOD_START", "{", "position . set ( targetPosition )  ;", "position . sub ( startPosition )  ;", "position . scl ( get ( selected )  . apply (  ( time    /     ( duration )  )  )  )  ;", "position . add ( startPosition )  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.tests.InterpolationTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "float   bottomLeftX    =     (  ( graphics . getWidth (  )  )     /     2  )     -     (  ( graphSize )     /     2  )  ;", "float   bottomLeftY    =     (  ( graphics . getHeight (  )  )     /     2  )     -     (  ( graphSize )     /     2  )  ;", "String   text    =    String . valueOf ( duration )  ;", "if    (  ( text . length (  )  )     >     4  )", "text    =    text . substring (  0  ,     (  ( text . lastIndexOf (  '  .  '  )  )     +     3  )  )  ;", "text    =     (  \" duration :     \"     +    text )     +     \"    s    ( ctrl    +    scroll   to   change )  \"  ;", "stage . getBatch (  )  . begin (  )  ;", "list . getStyle (  )  . font . draw ( stage . getBatch (  )  ,    text ,     ( bottomLeftX    +     (  ( graphSize )     /     2  )  )  ,     (  ( bottomLeftY    +     ( graphSize )  )     +     ( list . getStyle (  )  . font . getLineHeight (  )  )  )  ,     0  ,    center ,    false )  ;", "stage . getBatch (  )  . end (  )  ;", "renderer . begin ( Line )  ;", "renderer . rect ( bottomLeftX ,    bottomLeftY ,    graphSize ,    graphSize )  ;", "float   lastX    =    bottomLeftX ;", "float   lastY    =    bottomLeftY ;", "for    ( float   step    =     0  ;    step    <  =     ( steps )  ;    step +  +  )     {", "interpolation    =    get ( selected )  ;", "float   percent    =    step    /     ( steps )  ;", "float   x    =    bottomLeftX    +     (  ( graphSize )     *    percent )  ;", "float   y    =    bottomLeftY    +     (  ( graphSize )     *     ( interpolation . apply ( percent )  )  )  ;", "renderer . line ( lastX ,    lastY ,    x ,    y )  ;", "lastX    =    x ;", "lastY    =    y ;", "}", "time    +  =    graphics . getDeltaTime (  )  ;", "if    (  ( time )     >     ( duration )  )     {", "time    =    Float . NaN ;", "startPosition . set ( targetPosition )  ;", "}", "renderer . line (  ( bottomLeftX    +     (  (  ( graphSize )     *     ( time )  )     /     ( duration )  )  )  ,    bottomLeftY ,     ( bottomLeftX    +     (  (  ( graphSize )     *     ( time )  )     /     ( duration )  )  )  ,     ( bottomLeftY    +     ( graphSize )  )  )  ;", "renderer . setColor ( GRAY )  ;", "renderer . line ( startPosition ,    targetPosition )  ;", "renderer . setColor ( WHITE )  ;", "renderer . end (  )  ;", "renderer . begin ( Filled )  ;", "if    (  !  ( Float . isNaN ( time )  )  )", "getPosition ( time )  ;", "renderer . circle ( position . x ,    position . y ,     7  )  ;", "renderer . end (  )  ;", "stage . act (  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.InterpolationTest"}, {"methodBody": ["METHOD_START", "{", "startPosition . set (  (  ( stage . getWidth (  )  )     -     (  ( stage . getWidth (  )  )     /     5  .  0 F )  )  ,     (  ( stage . getHeight (  )  )     -     (  ( stage . getHeight (  )  )     /     5  .  0 F )  )  )  ;", "targetPosition . set ( startPosition . x ,     (  ( stage . getHeight (  )  )     /     5  .  0 F )  )  ;", "}", "METHOD_END"], "methodName": ["resetPositions"], "fileName": "com.badlogic.gdx.tests.InterpolationTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "table . invalidateHierarchy (  )  ;", "renderer . setProjecMatrix ( stage . getViewport (  )  . getCamera (  )  . combined )  ;", "graphSize    =     0  .  7  5 F    *     ( Math . min ( stage . getViewport (  )  . getWorldWidth (  )  ,    stage . getViewport (  )  . getWorldHeight (  )  )  )  ;", "steps    =     ( graphSize )     *     0  .  5 F ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.InterpolationTest"}, {"methodBody": ["METHOD_START", "{", "renderer . begin ( Line )  ;", "renderer . setColor (  0  ,     1  ,     0  ,     1  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( bones . length )     -     1  )  ;    i +  +  )     {", "renderer . line ( bones [ i ]  . position . x ,    bones [ i ]  . position . y ,    bones [  ( i    +     1  )  ]  . position . x ,    bones [  ( i    +     1  )  ]  . position . y )  ;", "}", "renderer . end (  )  ;", "renderer . begin ( Point )  ;", "renderer . setColor (  1  ,     0  ,     0  ,     1  )  ;", "for    ( int   i    =     0  ;    i    <     ( bones . length )  ;    i +  +  )     {", "renderer . point ( bones [ i ]  . position . x ,    bones [ i ]  . position . y ,     0  )  ;", "}", "renderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderBones"], "fileName": "com.badlogic.gdx.tests.InverseKinematicsTest"}, {"methodBody": ["METHOD_START", "{", "float   gravity    =     ( graphics . getDeltaTime (  )  )     *     ( InverseKinematicsTest . GRAVITY )  ;", "endPoint . set ( target )  ;", "bones [  0  ]  . position . set ( endPoint )  ;", "for    ( int   i    =     0  ;    i    <     (  ( bones . length )     -     1  )  ;    i +  +  )     {", "InverseKinematicsTest . Bone   bone    =    bones [ i ]  ;", "endPoint . set ( bone . position )  ;", "diff . set ( endPoint . x ,    endPoint . y )  . sub ( bones [  ( i    +     1  )  ]  . position . x ,    bones [  ( i    +     1  )  ]  . position . y )  ;", "diff . add (  0  ,    gravity )  ;", "diff . add ( bones [  ( i    +     1  )  ]  . inertia . x ,    bones [  ( i    +     1  )  ]  . inertia . y )  ;", "diff . nor (  )  . scl ( bones [  ( i    +     1  )  ]  . len )  ;", "float   x    =     ( endPoint . x )     -     ( diff . x )  ;", "float   y    =     ( endPoint . y )     -     ( diff . y )  ;", "float   delta    =    graphics . getDeltaTime (  )  ;", "bones [  ( i    +     1  )  ]  . inertia . add (  (  (  ( bones [  ( i    +     1  )  ]  . position . x )     -    x )     *    delta )  ,     (  (  ( bones [  ( i    +     1  )  ]  . position . y )     -    y )     *    delta )  ,     0  )  . scl (  0  .  9  9 F )  ;", "bones [  ( i    +     1  )  ]  . position . set ( x ,    y ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["solveFakeIK"], "fileName": "com.badlogic.gdx.tests.InverseKinematicsTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( array    =  =    null )     |  |     (  !  ( array . getClass (  )  . isArray (  )  )  )  )", "return   array ;", "ArrayList   list    =    new   ArrayList ( ArrayReflection . getLength ( array )  )  ;", "for    ( int   i    =     0  ,    n    =    ArrayReflection . getLength ( array )  ;    i    <    n ;    i +  +  )", "list . add (  . arrayToList ( ArrayReflection . get ( array ,    i )  )  )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["arrayToList"], "fileName": "com.badlogic.gdx.tests.JsonTest"}, {"methodBody": ["METHOD_START", "{", "Object   object 2     =    json . fromJson ( object . getClass (  )  ,    text )  ;", "equals ( object ,    object 2  )  ;", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.tests.JsonTest"}, {"methodBody": ["METHOD_START", "{", "json    =    new   Json (  )  ;", ". Test 1    test    =    new    . Test 1  (  )  ;", "test . booleanField    =    true ;", "test . byteField    =     1  2  3  ;", "test . charField    =     ' Z '  ;", "test . shortField    =     1  2  3  4  5  ;", "test . intField    =     1  2  3  4  5  6  ;", "test . longField    =     1  2  3  4  5  6  7  8  9  ;", "test . floatField    =     1  2  3  .  4  5  6 F ;", "test . doubleField    =     1  .  2  3  4  5  6  ;", "test . BooleanField    =    true ;", "test . ByteField    =     -  1  2  ;", "test . CharacterField    =     ' X '  ;", "test . ShortField    =     -  1  2  3  4  5  ;", "test . IntegerField    =     -  1  2  3  4  5  6  ;", "test . LongField    =     -  1  2  3  4  5  6  7  8  9 L ;", "test . FloatField    =     -  1  2  3  .  3 F ;", "test . DoubleField    =     -  0  .  1  2  1  2  3  1  ;", "test . stringField    =     \" stringvalue \"  ;", "test . byteArrayField    =    new   byte [  ]  {     2  ,     1  ,     0  ,     -  1  ,     -  2     }  ;", "test . map    =    new   ObjectMap (  )  ;", "test . map . put (  \" one \"  ,     1  )  ;", "test . map . put (  \" two \"  ,     2  )  ;", "test . map . put (  \" nine \"  ,     9  )  ;", "test . stringArray    =    new   Array (  )  ;", "test . stringArray . add (  \" meow \"  )  ;", "test . stringArray . add (  \" moo \"  )  ;", "test . objectArray    =    new   Array (  )  ;", "test . objectArray . add (  \" meow \"  )  ;", "test . objectArray . add ( new    . Test 1  (  )  )  ;", "test . someEnum    =     . SomeEnum . b ;", "roundTrip ( test )  ;", "test . someEnum    =    null ;", "roundTrip ( test )  ;", "test    =    new    . Test 1  (  )  ;", "roundTrip ( test )  ;", "test . stringArray    =    new   Array (  )  ;", "roundTrip ( test )  ;", "test . stringArray . add (  \" meow \"  )  ;", "roundTrip ( test )  ;", "test . stringArray . add (  \" moo \"  )  ;", "roundTrip ( test )  ;", ". TestMapGraph   objectGraph    =    new    . TestMapGraph (  )  ;", "testObjectGraph ( objectGraph ,     \" exoticTypeName \"  )  ;", "test    =    new    . Test 1  (  )  ;", "test . map    =    new   ObjectMap (  )  ;", "roundTrip ( test )  ;", "test . map . put (  \" one \"  ,     1  )  ;", "roundTrip ( test )  ;", "test . map . put (  \" two \"  ,     2  )  ;", "test . map . put (  \" nine \"  ,     9  )  ;", "roundTrip ( test )  ;", "test . map . put (  \"  \\ nst \\ nuff \\ n \"  ,     9  )  ;", "test . map . put (  \"  \\ r \\ nst \\ r \\ nuff \\ r \\ n \"  ,     9  )  ;", "roundTrip ( test )  ;", "equals ( json . toJson (  \" meow \"  )  ,     \" meow \"  )  ;", "equals ( json . toJson (  \" meow    \"  )  ,     \"  \\  \" meow    \\  \"  \"  )  ;", "equals ( json . toJson (  \"    meow \"  )  ,     \"  \\  \"    meow \\  \"  \"  )  ;", "equals ( json . toJson (  \"    meow    \"  )  ,     \"  \\  \"    meow    \\  \"  \"  )  ;", "equals ( json . toJson (  \"  \\ nmeow \\ n \"  )  ,     \"  \\  \\ nmeow \\  \\ n \"  )  ;", "equals ( json . toJson ( Array . with (  1  ,     2  ,     3  )  ,    null ,    int . class )  ,     \"  [  1  ,  2  ,  3  ]  \"  )  ;", "equals ( json . toJson ( Array . with (  \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  )  ,    null ,    String . class )  ,     \"  [  1  ,  2  ,  3  ]  \"  )  ;", "equals ( json . toJson ( Array . with (  \"     1  \"  ,     \"  2     \"  ,     \"     3     \"  )  ,    null ,    String . class )  ,     \"  [  \\  \"     1  \\  \"  ,  \\  \"  2     \\  \"  ,  \\  \"     3     \\  \"  ]  \"  )  ;", "equals ( json . toJson ( Array . with (  \"  1  \"  ,     \"  \"  ,     \"  3  \"  )  ,    null ,    String . class )  ,     \"  [  1  ,  \\  \"  \\  \"  ,  3  ]  \"  )  ;", "System . out . println (  )  ;", "System . out . println (  \" Success !  \"  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.JsonTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( a . equals ( b )  )  )", "throw   new   RuntimeExcepti (  (  (  (  \" Fail !  \\ n \"     +    a )     +     \"  \\ n !  =  \\ n \"  )     +    b )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.tests.JsonTest"}, {"methodBody": ["METHOD_START", "{", "String   text    =    json . toJson ( object )  ;", "System . out . println ( text )  ;", "test ( text ,    object )  ;", "text    =    json . prettyPrint ( object ,     1  3  0  )  ;", "test ( text ,    object )  ;", "return   text ;", "}", "METHOD_END"], "methodName": ["roundTrip"], "fileName": "com.badlogic.gdx.tests.JsonTest"}, {"methodBody": ["METHOD_START", "{", "check ( text ,    object )  ;", "text    =    text . replace (  \"  {  \"  ,     \"  /  * moo *  /  {  /  * moo *  /  \"  )  ;", "check ( text ,    object )  ;", "text    =    text . replace (  \"  }  \"  ,     \"  /  * moo *  /  }  /  * moo *  /  \"  )  ;", "text    =    text . replace (  \"  [  \"  ,     \"  /  * moo *  /  [  /  * moo *  /  \"  )  ;", "text    =    text . replace (  \"  ]  \"  ,     \"  /  * moo *  /  ]  /  * moo *  /  \"  )  ;", "text    =    text . replace (  \"  :  \"  ,     \"  /  * moo *  /  :  /  * moo *  /  \"  )  ;", "text    =    text . replace (  \"  ,  \"  ,     \"  /  * moo *  /  ,  /  * moo *  /  \"  )  ;", "check ( text ,    object )  ;", "text    =    text . replace (  \"  /  * moo *  /  \"  ,     \"     /  * moo *  /     \"  )  ;", "check ( text ,    object )  ;", "text    =    text . replace (  \"  /  * moo *  /  \"  ,     \"  /  /    moo \\ n \"  )  ;", "check ( text ,    object )  ;", "text    =    text . replace (  \"  \\ n \"  ,     \"  \\ r \\ n \"  )  ;", "check ( text ,    object )  ;", "text    =    text . replace (  \"  ,  \"  ,     \"  \\ n \"  )  ;", "check ( text ,    object )  ;", "text    =    text . replace (  \"  \\ n \"  ,     \"  \\ r \\ n \"  )  ;", "check ( text ,    object )  ;", "text    =    text . replace (  \"  \\ r \\ n \"  ,     \"  \\ r \\ n \\ r \\ n \"  )  ;", "check ( text ,    object )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.badlogic.gdx.tests.JsonTest"}, {"methodBody": ["METHOD_START", "{", "Json   json    =    new   Json (  )  ;", "json . setTypeName ( typeName )  ;", "json . setUsePrototypes ( false )  ;", "json . setIgnoreUnknownFields ( true )  ;", "json . setOutputType ( json )  ;", "String   text    =    json . prettyPrint ( object )  ;", ". TestMapGraph   object 2     =    json . fromJson (  . TestMapGraph . class ,    text )  ;", "if    (  ( object 2  . map . size (  )  )     !  =     ( object . map . size (  )  )  )     {", "throw   new   RuntimeException (  \" Too   many   items   in   deserialized   json   map .  \"  )  ;", "}", "if    (  ( object 2  . objectMap . size )     !  =     ( object . objectMap . size )  )     {", "throw   new   RuntimeException (  \" Too   many   items   in   deserialized   json   object   map .  \"  )  ;", "}", "if    (  ( object 2  . arrayMap . size )     !  =     ( object . arrayMap . size )  )     {", "throw   new   RuntimeException (  \" Too   many   items   in   deserialized   json   map .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testObjectGraph"], "fileName": "com.badlogic.gdx.tests.JsonTest"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.KTXTest"}, {"methodBody": ["METHOD_START", "{", "cam    =    new   OrthographicCamera (  4  8  ,     3  2  )  ;", "cam . position . set (  0  ,     1  5  ,     0  )  ;", "renderer    =    new   Box 2 DDebugRenderer (  )  ;", "world    =    new   physics . box 2 d . World ( new   Vector 2  (  0  ,     (  -  1  0  )  )  ,    true )  ;", "Body   body    =    world . createBody ( new   BodyDef (  )  )  ;", "CircleShape   shape    =    new   CircleShape (  )  ;", "shape . setRadius (  1  .  0 F )  ;", "MassData   mass    =    new   MassData (  )  ;", "mass . mass    =     1  .  0 F ;", "body . setMassData ( mass )  ;", "body . setFixedRotation ( true )  ;", "body . setType ( KinematicBody )  ;", "body . createFixture ( shape ,     1  )  ;", "body . setBullet ( true )  ;", "body . setTransform ( new   Vector 2  (  0  ,     0  )  ,    body . getAngle (  )  )  ;", "body . setLinearVelocity ( new   Vector 2  (  5  0  .  0 F ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.KinematicBodyTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "world . step ( Math . min (  0  .  0  3  2 F ,    graphics . getDeltaTime (  )  )  ,     3  ,     4  )  ;", "cam . update (  )  ;", "renderer . render ( world ,    cam . bined )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.KinematicBodyTest"}, {"methodBody": ["METHOD_START", "{", "renderer . setProjectionMatrix ( batch . getProjectionMatrix (  )  )  ;", "renderer . begin ( Line )  ;", "renderer . line ( x 1  ,    y 1  ,    x 2  ,    y 2  )  ;", "renderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["drawLine"], "fileName": "com.badlogic.gdx.tests.LabelTest"}, {"methodBody": ["METHOD_START", "{", "Matrix 4    mata    =    new   Matrix 4  (  )  ;", "Matrix 4    matb    =    new   Matrix 4  (  )  ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "mata . mul ( matb )  ;", "}", "app . log (  \"  \"  ,     (  \" java   matrix    *    matrix   took :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "Matrix 4  . mul ( mata . val ,    matb . val )  ;", "}", "app . log (  \"  \"  ,     (  \" jni   matrix    *    matrix   took :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "Vector 3    vec    =    new   Vector 3  (  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     5  0  0  0  0  0  ;    i +  +  )     {", "vec . mul ( mata )  ;", "}", "app . log (  \"  \"  ,     (  \" java   vecs    *    matrix   took :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "float [  ]    fvec    =    new   float [  3  ]  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     5  0  0  0  0  0  ;    i +  +  )     {", "Matrix 4  . mulVec ( mata . val ,    fvec )  ;", "}", "app . log (  \"  \"  ,     (  \" jni   vecs    *    matrix   took :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "float [  ]    fvecs    =    new   float [  3     *     5  0  0  0  0  0  ]  ;", "start    =    TimeUtils . nanoTime (  )  ;", "Matrix 4  . mulVec ( mata . val ,    fvecs ,     0  ,     5  0  0  0  0  0  ,     3  )  ;", "app . log (  \"  \"  ,     (  \" jni   bulk   vecs    *    matrix   took :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "mata . inv (  )  ;", "}", "app . log (  \"  \"  ,     (  \" java   inv ( matrix )  :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "Matrix 4  . inv ( mata . val )  ;", "}", "app . log (  \"  \"  ,     (  \" jni   inv ( matrix )  :     \"     +     (  (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["bench"], "fileName": "com.badlogic.gdx.tests.MatrixJNITest"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  6  ;    i +  +  )     {", "if    (  ( mat 1  . val [ i ]  )     !  =     ( mat 2  . val [ i ]  )  )", "throw   new   utils . GdxRuntimeException (  \" matrices   not   equal \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.tests.MatrixJNITest"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( vec . x )     !  =     ( fvec [  0  ]  )  )     |  |     (  ( vec . y )     !  =     ( fvec [  1  ]  )  )  )     |  |     (  ( vec . z )     !  =     ( fvec [  2  ]  )  )  )", "throw   new   utils . GdxRuntimeException (  \" vectors   are   not   equal \"  )  ;", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.tests.MatrixJNITest"}, {"methodBody": ["METHOD_START", "{", "int   offset    =     0  ;", "for    ( int   i    =     0  ;    i    <    numVecs ;    i +  +  )     {", "if    (  (  (  ( vec . x )     !  =     ( fvec [  0  ]  )  )     |  |     (  ( vec . y )     !  =     ( fvec [  1  ]  )  )  )     |  |     (  ( vec . z )     !  =     ( fvec [  2  ]  )  )  )", "throw   new   utils . GdxRuntimeException (  \" vectors   are   not   equal \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.tests.MatrixJNITest"}, {"methodBody": ["METHOD_START", "{", "int   vu    =     (  (  ( int )     ( v    *     6  5  5  3  5  )  )     <  <     1  6  )     |     (  ( int )     ( u    *     6  5  5  3  5  )  )  ;", "return   NumberUtils . intToFatCor ( vu )  ;", "}", "METHOD_END"], "methodName": ["toSingleFloat"], "fileName": "com.badlogic.gdx.tests.MeshShaderTest"}, {"methodBody": ["METHOD_START", "{", "skin    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "ui    =    new   Stage (  )  ;", "String [  ]    filters    =    new   String [ TextureFilter . values (  )  . length ]  ;", "int   idx    =     0  ;", "for    ( TextureFilter   filter    :    TextureFilter . values (  )  )     {", "filters [  ( idx +  +  )  ]     =    filter . toString (  )  ;", "}", "hwMipMap    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . CheckBox (  \" Hardware   Mips \"  ,    skin )  ;", "minFilter    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . SelectBox ( skin )  ;", "minFilter . setItems ( filters )  ;", "magFilter    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . SelectBox ( skin . get ( SelectBoxStyle . class )  )  ;", "magFilter . setItems (  \" Nearest \"  ,     \" Linear \"  )  ;", "Table   table    =    new   Table (  )  ;", "table . setSize ( ui . getWidth (  )  ,     3  0  )  ;", "table . setY (  (  ( ui . getHeight (  )  )     -     3  0  )  )  ;", "table . add ( hwMipMap )  . spaceRight (  5  )  ;", "table . add ( new   com . badlogic . gdx . scenes . scene 2 d . ui . Label (  \" Min   Filter \"  ,    skin )  )  . spaceRight (  5  )  ;", "table . add ( minFilter )  . spaceRight (  5  )  ;", "table . add ( new   com . badlogic . gdx . scenes . scene 2 d . ui . Label (  \" Mag   Filter \"  ,    skin )  )  . spaceRight (  5  )  ;", "table . add ( magFilter )  ;", "ui . addActor ( table )  ;", "}", "METHOD_END"], "methodName": ["createUI"], "fileName": "com.badlogic.gdx.tests.MipMapTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( music )     !  =    null )     {", "music . dispose (  )  ;", "}", "switch    ( song )     {", "default    :", "case   MP 3     :", "music    =    audio . new ( files . internal (  \" data /  8  .  1  2  . mp 3  \"  )  )  ;", "songDuration    =     1  8  3  ;", "break ;", "case   OGG    :", "music    =    audio . new ( files . internal (  \" data / cloudconnected . ogg \"  )  )  ;", "songDuration    =     2  2  ;", "break ;", "case   WAV    :", "music    =    audio . new ( files . internal (  \" data /  8  .  1  2  . loop . wav \"  )  )  ;", "songDuration    =     4  ;", "break ;", "}", "music . setLooping ( true )  ;", "music . play (  )  ;", "}", "METHOD_END"], "methodName": ["setSong"], "fileName": "com.badlogic.gdx.tests.MusicTest"}, {"methodBody": ["METHOD_START", "{", "final   int   patchSize    =     8  ;", "final   int   pixmapSize    =    patchSize    *     3  ;", "TextureRegion   tr    =    NinePatchTest . newPatchPix ( patchSize ,    pixmapSize )  ;", "return   new   graphics . g 2 d . NinePatch ( tr )  ;", "}", "METHOD_END"], "methodName": ["newDegenerateNinePatch"], "fileName": "com.badlogic.gdx.tests.NinePatchTest"}, {"methodBody": ["METHOD_START", "{", "final   int   patchSize    =     8  ;", "final   int   fullPatchHeight    =    patchSize    *     2  ;", "final   int   fullPatchWidth    =    patchSize    *     3  ;", "final   int   pixmapDim    =    MathUtils . nextPowerOfTwo ( Math . max ( fullPatchWidth ,    fullPatchHeight )  )  ;", "Pixmap   testPatch    =    new   Pixmap ( pixmapDim ,    pixmapDim ,    Format . RGBA 8  8  8  8  )  ;", "testPatch . setColor (  1  ,     1  ,     1  ,     0  )  ;", "testPatch . fill (  )  ;", "for    ( int   x    =     0  ;    x    <    fullPatchWidth ;    x    +  =    patchSize )     {", "for    ( int   y    =     0  ;    y    <    fullPatchHeight ;    y    +  =    patchSize )     {", "testPatch . setColor (  ( x    /     (  ( float )     ( fullPatchWidth )  )  )  ,     ( y    /     (  ( float )     ( fullPatchHeight )  )  )  ,     1  .  0 F ,     1  .  0 F )  ;", "testPatch . fillRectangle ( x ,    y ,    patchSize ,    patchSize )  ;", "}", "}", "return   new   graphics . g 2 d . NinePatch ( new   TextureRegion ( new   graphics . Texture ( testPatch )  ,    fullPatchWidth ,    fullPatchHeight )  ,    patchSize ,    patchSize ,    patchSize ,    patchSize )  ;", "}", "METHOD_END"], "methodName": ["newMidlessPatch"], "fileName": "com.badlogic.gdx.tests.NinePatchTest"}, {"methodBody": ["METHOD_START", "{", "final   int   patchSize    =     8  ;", "final   int   pixmapSize    =    patchSize    *     3  ;", "TextureRegion   tr    =    NinePatchTest . newPatchPix ( patchSize ,    pixmapSize )  ;", "return   new   graphics . g 2 d . NinePatch ( tr ,    patchSize ,    patchSize ,    patchSize ,    patchSize )  ;", "}", "METHOD_END"], "methodName": ["newNinePatch"], "fileName": "com.badlogic.gdx.tests.NinePatchTest"}, {"methodBody": ["METHOD_START", "{", "final   int   pixmapDim    =    MathUtils . nextPowerOfTwo ( pixmapSize )  ;", "Pixmap   p    =    new   Pixmap ( pixmapDim ,    pixmapDim ,    Format . RGBA 8  8  8  8  )  ;", "p . setColor (  1  ,     1  ,     1  ,     0  )  ;", "p . fill (  )  ;", "for    ( int   x    =     0  ;    x    <    pixmapSize ;    x    +  =    patchSize )     {", "for    ( int   y    =     0  ;    y    <    pixmapSize ;    y    +  =    patchSize )     {", "p . setColor (  ( x    /     (  ( float )     ( pixmapSize )  )  )  ,     ( y    /     (  ( float )     ( pixmapSize )  )  )  ,     1  .  0 F ,     1  .  0 F )  ;", "p . fillRectangle ( x ,    y ,    patchSize ,    patchSize )  ;", "}", "}", "return   new   TextureRegion ( new   graphics . Texture ( p )  ,    pixmapSize ,    pixmapSize )  ;", "}", "METHOD_END"], "methodName": ["newPatchPix"], "fileName": "com.badlogic.gdx.tests.NinePatchTest"}, {"methodBody": ["METHOD_START", "{", "final   int   patchSize    =     8  ;", "final   int   pixmapSize    =    patchSize    *     2  ;", "TextureRegion   tr    =    NinePatchTest . newPatchPix ( patchSize ,    pixmapSize )  ;", "return   new   graphics . g 2 d . NinePatch ( tr ,    patchSize ,     0  ,    patchSize ,     0  )  ;", "}", "METHOD_END"], "methodName": ["newULQuadPatch"], "fileName": "com.badlogic.gdx.tests.NinePatchTest"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "colorCycle    =     (  ( colorCycle )     +     1  )     %     3  ;", "}", "}", "METHOD_END"], "methodName": ["nextColor"], "fileName": "com.badlogic.gdx.tests.NoncontinuousRenderingTest"}, {"methodBody": ["METHOD_START", "{", "Table   root    =    new   Table (  )  ;", "stage . addActor ( root )  ;", "root . setFillParent ( true )  ;", "root . pad (  5  )  ;", "root . defaults (  )  . left (  )  . space (  5  )  ;", "Button   button 0     =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton (  \" Toggle   continuous   rendering \"  ,    skin ,     \" toggle \"  )  ;", "button 0  . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "boolean   continuous    =    graphics . isC (  )  ;", "graphics . setC (  (  ! continuous )  )  ;", "}", "}  )  ;", "root . add ( button 0  )  . row (  )  ;", "final   String   str 1     =     \"  2 s   sleep    -  >    Application . postRunnable (  )  \"  ;", "Button   button 1     =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton ( str 1  ,    skin )  ;", "button 1  . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "new   Thread ( new   Runnable (  )     {", "public   void   run (  )     {", "try    {", "Thread . sleep (  2  0  0  0  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "nextColor (  )  ;", "app . postRunnable ( new   Runnable (  )     {", "public   void   run (  )     {", "app . log ( str 1  ,     \" Posted   runnable   to   Gdx . app \"  )  ;", "}", "}  )  ;", "}", "}  )  . start (  )  ;", "}", "}  )  ;", "root . add ( button 1  )  . row (  )  ;", "final   String   str 2     =     \"  2 s   sleep    -  >    Graphics . requestRendering (  )  \"  ;", "Button   button 2     =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton ( str 2  ,    skin )  ;", "button 2  . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "final   Graphics   graphics    =    Gdx . graphics ;", "new   Thread ( new   Runnable (  )     {", "public   void   run (  )     {", "try    {", "Thread . sleep (  2  0  0  0  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "nextColor (  )  ;", "graphics . requestRendering (  )  ;", "app . log ( str 2  ,     \" Called   Gdx . graphics . requestRendering (  )  \"  )  ;", "}", "}  )  . start (  )  ;", "}", "}  )  ;", "root . add ( button 2  )  . row (  )  ;", "final   String   str 3     =     \"  2 s   Timer    -  >    Application . postRunnable (  )  \"  ;", "Button   button 3     =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton ( str 3  ,    skin )  ;", "button 3  . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "Timer . schedule ( new   Task (  )     {", "public   void   run (  )     {", "nextColor (  )  ;", "app . postRunnable ( new   Runnable (  )     {", "public   void   run (  )     {", "app . log ( str 3  ,     \" Posted   runnable   to   Gdx . app \"  )  ;", "}", "}  )  ;", "}", "}  ,     2  .  0 F )  ;", "}", "}  )  ;", "root . add ( button 3  )  . row (  )  ;", "final   String   str 4     =     \"  2 s   DelayAction \"  ;", "Button   button 4     =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton ( str 4  ,    skin )  ;", "button 4  . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "stage . addAction ( Actions . sequence ( Actions . delay (  2  )  ,    Actions . run ( new   Runnable (  )     {", "public   void   run (  )     {", "nextColor (  )  ;", "app . log ( str 4  ,     \" RunnableAction   executed \"  )  ;", "}", "}  )  )  )  ;", "}", "}  )  ;", "root . add ( button 4  )  . row (  )  ;", "final   String   str 5     =     \"  (  2 s   sleep    -  >    toggle   continuous )     2 X \"  ;", "Button   button 5     =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton ( str 5  ,    skin )  ;", "button 5  . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "final   Graphics   graphics    =    Gdx . graphics ;", "new   Thread ( new   Runnable (  )     {", "public   void   run (  )     {", "for    ( int   i    =     0  ;    i    <     2  ;    i +  +  )     {", "try    {", "Thread . sleep (  2  0  0  0  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "nextColor (  )  ;", "boolean   continuous    =    graphics . isC (  )  ;", "graphics . setC (  (  ! continuous )  )  ;", "app . log ( str 5  ,     \" Toggled   continuous \"  )  ;", "}", "}", "}  )  . start (  )  ;", "}", "}  )  ;", "root . add ( button 5  )  . row (  )  ;", "final   CheckBox   actionsRequestRendering    =    new   CheckBox (  \" ActionsRequestRendering \"  ,    skin )  ;", "actionsRequestRendering . setChecked ( true )  ;", "actionsRequestRendering . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "stage . setActionsRequestRendering ( actionsRequestRendering . isChecked (  )  )  ;", "}", "}  )  ;", "root . add ( actionsRequestRendering )  . row (  )  ;", "Drawable   knobDown    =    skin . newDrawable (  \" default - slider - knob \"  ,    GRAY )  ;", "SliderStyle   sliderStyle    =    skin . get (  \" default - horizontal \"  ,    SliderStyle . class )  ;", "sliderStyle . knobDown    =    knobDown ;", "Slider   slider    =    new   Slider (  0  ,     1  0  0  ,     1  ,    false ,    sliderStyle )  ;", "root . add ( slider )  . row (  )  ;", "SelectBox < Pixmap . Format >    selectBox    =    new   SelectBox ( skin )  ;", "selectBox . setItems ( Format . values (  )  )  ;", "root . add ( selectBox )  . row (  )  ;", "root . add (  )  ;", "root . add (  )  . grow (  )  ;", "}", "METHOD_END"], "methodName": ["populateTable"], "fileName": "com.badlogic.gdx.tests.NoncontinuousRenderingTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "font    =    new   BitmapFont (  )  ;", "text    =     \"  \"  ;", "input . setInputProcessor ( this )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.OnscreenKeyboardTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "font . draw ( batch ,     (  \" input :     \"     +     ( text )  )  ,     0  ,    graphics . getHeight (  )  )  ;", "batch . end (  )  ;", "if    ( input . justTouched (  )  )", "input . setVisible ( true )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.OnscreenKeyboardTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.ParticleEmitterChangeSpriteTest"}, {"methodBody": ["METHOD_START", "{", "spriteBatch . getProjectionMatrix (  )  . setToOrtho 2 D (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "float   delta    =    graphics . getDeltaTime (  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "spriteBatch . begin (  )  ;", "effect . draw ( spriteBatch ,    delta )  ;", "spriteBatch . end (  )  ;", "fpsCounter    +  =    delta ;", "if    (  ( fpsCounter )     >     3  )     {", "fpsCounter    =     0  ;", "app . log (  \" libgdx \"  ,     (  (  (  \" current   sprite :     \"     +     ( current )  )     +     \"  ,    FPS :     \"  )     +     ( graphics . getFramesPerSecond (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ParticleEmitterChangeSpriteTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.ParticleEmitterTest"}, {"methodBody": ["METHOD_START", "{", "spriteBatch . getProjectionMatrix (  )  . setToOrtho 2 D (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "float   delta    =    graphics . getDeltaTime (  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "spriteBatch . begin (  )  ;", "effect . draw ( spriteBatch ,    delta )  ;", "spriteBatch . end (  )  ;", "fpsCounter    +  =    delta ;", "if    (  ( fpsCounter )     >     3  )     {", "fpsCounter    =     0  ;", "int   activeCount    =    emitters . get ( emitterIndex )  . getActiveCount (  )  ;", "app . log (  \" libgdx \"  ,     (  (  (  ( activeCount    +     \"  /  \"  )     +     ( pCount )  )     +     \"    ps ,    FPS :     \"  )     +     ( graphics . getFramesPerSecond (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ParticleEmitterTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.ParticleEmittersTest"}, {"methodBody": ["METHOD_START", "{", "ui . act (  )  ;", "spriteBatch . getProjectionMatrix (  )  . setToOrtho 2 D (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "float   delta    =    graphics . getDeltaTime (  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "spriteBatch . begin (  )  ;", "for    ( ffect   e    :    effects )", "e . draw ( spriteBatch ,    delta )  ;", "spriteBatch . end (  )  ;", "fpsCounter    +  =    delta ;", "if    (  ( fpsCounter )     >     3  )     {", "fpsCounter    =     0  ;", "String   log    =     (  (  (  ( effects . size )     +     \"    particle   effects ,    FPS :     \"  )     +     ( graphics . getFramesPerSecond (  )  )  )     +     \"  ,    Render   calls :     \"  )     +     ( spriteBatch . renderCalls )  ;", "app . log (  \" libgdx \"  ,    log )  ;", "logLabel . setText ( log )  ;", "}", "ui . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ParticleEmittersTest"}, {"methodBody": ["METHOD_START", "{", "ui    =    new   com . badlogic . gdx . scenes . scene 2 d . Stage ( new   ExtendViewport (  6  4  0  ,     4  8  0  )  )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "skipCleanup    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . CheckBox (  \" Skip   blend   function   clean - up \"  ,    skin )  ;", "skipCleanup . addListener ( listener )  ;", "logLabel    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . Label (  \"  \"  ,    skin . get ( LabelStyle . class )  )  ;", "clearEmitters    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton (  \" Clear   screen \"  ,    skin )  ;", "clearEmitters . addListener ( listener )  ;", "scaleEffects    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . TextButton (  \" Scale   existing   effects \"  ,    skin )  ;", "scaleEffects . addListener ( listener )  ;", "Table   table    =    new   Table (  )  ;", "table . setTransform ( false )  ;", "table . setFillParent ( true )  ;", "table . defaults (  )  . padTop (  5  )  . left (  )  ;", "table . top (  )  . left (  )  . padLeft (  5  )  ;", "table . add ( skipCleanup )  . colspan (  2  )  . row (  )  ;", "table . add ( clearEmitters )  . spaceRight (  1  0  )  ;", "table . add ( scaleEffects )  . row (  )  ;", "table . add ( logLabel )  . colspan (  2  )  ;", "ui . addActor ( table )  ;", "}", "METHOD_END"], "methodName": ["setupUI"], "fileName": "com.badlogic.gdx.tests.ParticleEmittersTest"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleEffect   eff    :    effects )     {", "for    (    e    :    eff . getEmitters (  )  )", "e . setCleansUpBlendFunction (  (  !  ( skipCleanup . isChecked (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateSkipCleanupState"], "fileName": "com.badlogic.gdx.tests.ParticleEmittersTest"}, {"methodBody": ["METHOD_START", "{", "t    =    paths . get ( currentPath )  . locate ( tmpV . set ( x ,     (  ( graphics . getHeight (  )  )     -    y )  )  )  ;", "paths . get ( currentPath )  . valueAt ( tmpV ,    t )  ;", "obj . setPosition ( tmpV . x ,    tmpV . y )  ;", "wait    =     0  .  2 F ;", "}", "METHOD_END"], "methodName": ["touch"], "fileName": "com.badlogic.gdx.tests.PathTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "float   width    =     (  ( int )     (  ( graphics . getPpcX (  )  )     *     2  )  )  ;", "float   height    =     (  ( int )     (  ( graphics . getPpcY (  )  )     *     1  )  )  ;", "batch . draw ( texture ,     1  0  ,     1  0  0  ,    width ,    height ,     0  ,     0  ,     6  4  ,     3  2  ,    false ,    false )  ;", "font . draw ( batch ,     (  (  (  (  (  (  (  (  (  (  (  (  \" button   is    2 x 1    cm    (  \"     +    width )     +     \" x \"  )     +    height )     +     \" px )  ,    ppi :     (  \"  )     +     ( graphics . getPpiX (  )  )  )     +     \"  ,  \"  )     +     ( graphics . getPpiY (  )  )  )     +     \"  )  ,    ppc :     (  \"  )     +     ( graphics . getPpcX (  )  )  )     +     \"  ,  \"  )     +     ( graphics . getPpcY (  )  )  )     +     \"  )  \"  )  ,     1  0  ,     5  0  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.PixelsPerInchTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.PixmapBlendingTest"}, {"methodBody": ["METHOD_START", "{", "pixmap    =    new   Pixmap (  8  0  0  ,     4  8  0  ,    Format . RGBA 8  8  8  8  )  ;", "texture    =    new   graphics . Texture (  1  0  2  4  ,     1  0  2  4  ,    Format . RGBA 8  8  8  8  )  ;", "texture . setFilter ( Nearest ,    Linear )  ;", "texture . setWrap ( ClampToEdge ,    ClampToEdge )  ;", "pixmap . setColor (  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F )  ;", "pixmap . drawLine (  0  ,     0  ,     1  0  0  ,     1  0  0  )  ;", "pixmap . setColor (  0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     1  .  0 F )  ;", "pixmap . drawLine (  1  0  0  ,     1  0  0  ,     2  0  0  ,     0  )  ;", "pixmap . setColor (  0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     1  .  0 F )  ;", "pixmap . drawLine (  1  0  0  ,     0  ,     1  0  0  ,     1  0  0  )  ;", "pixmap . setColor (  1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F )  ;", "pixmap . drawCircle (  4  0  0  ,     3  0  0  ,     1  0  0  )  ;", "texture . draw ( pixmap ,     0  ,     0  )  ;", "region    =    new   graphics . g 2 d . TextureRegion ( texture ,     0  ,     0  ,     8  0  0  ,     4  8  0  )  ;", "batch    =    new   SpriteBatch (  )  ;", "Pixmap   pixmap    =    new   Pixmap (  5  1  2  ,     1  0  2  4  ,    Format . RGBA 8  8  8  8  )  ;", "for    ( int   y    =     0  ;    y    <     ( pixmap . getHeight (  )  )  ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <     ( pixmap . getWidth (  )  )  ;    x +  +  )     {", "pixmap . getPixel ( x ,    y )  ;", "}", "}", "pixmap . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.PixmapTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  .  6 F ,     0  .  6 F ,     0  .  6 F ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "batch . draw ( region ,     0  ,     0  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.PixmapTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "badlogic    =    new   graphics . Texture ( files . internal (  \" data / badlogic . jpg \"  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.PngTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "if    (  ( screenshot )     =  =    null )     {", "int   width    =    graphics . getWidth (  )  ;", "int   height    =    graphics . getHeight (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )", "batch . draw ( badlogic ,    math . MathUtils . random ( width )  ,    math . MathUtils . random ( height )  )  ;", "batch . flush (  )  ;", "FileHandle   file    =    FileHandle . tempFile (  \" screenshot -  \"  )  ;", "System . out . println ( file . file (  )  . getAbsolutePath (  )  )  ;", "Pixmap   pixmap    =    ScreenUtils . getFrameBufferPixmap (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "try    {", "PNG   writer    =    new   PNG (  (  ( int )     (  (  ( pixmap . getWidth (  )  )     *     ( pixmap . getHeight (  )  )  )     *     1  .  5 F )  )  )  ;", "writer . write ( file ,    pixmap )  ;", "writer . write ( file ,    pixmap )  ;", "writer . dispose (  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "screenshot    =    new   graphics . Texture ( file )  ;", "}", "batch . draw ( screenshot ,     0  ,     0  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.PngTest"}, {"methodBody": ["METHOD_START", "{", "Preferences   prefs    =    app . getPreferences (  \"  . test \"  )  ;", "if    ( prefs . contains (  \" bool \"  )  )     {", "if    (  ( prefs . getBoolean (  \" bool \"  )  )     !  =    true )", "throw   new   utils . GdxRuntimeException (  \" bool   failed \"  )  ;", "if    (  ( prefs . getInteger (  \" int \"  )  )     !  =     1  2  3  4  )", "throw   new   utils . GdxRuntimeException (  \" int   failed \"  )  ;", "if    (  ( prefs . getLong (  \" long \"  )  )     !  =     ( Long . MAX _ VALUE )  )", "throw   new   utils . GdxRuntimeException (  \" long   failed \"  )  ;", "if    (  ( prefs . getFloat (  \" float \"  )  )     !  =     1  .  2  3  4  5 F )", "throw   new   utils . GdxRuntimeException (  \" float   failed \"  )  ;", "if    (  !  ( prefs . getString (  \" string \"  )  . equals (  \" test !  \"  )  )  )", "throw   new   utils . GdxRuntimeException (  \" string   failed \"  )  ;", "}", "prefs . clear (  )  ;", "prefs . putBoolean (  \" bool \"  ,    true )  ;", "prefs . putInteger (  \" int \"  ,     1  2  3  4  )  ;", "prefs . putLong (  \" long \"  ,    Long . MAX _ VALUE )  ;", "prefs . putFloat (  \" float \"  ,     1  .  2  3  4  5 F )  ;", "prefs . putString (  \" string \"  ,     \" test !  \"  )  ;", "prefs . flush (  )  ;", "if    (  ( prefs . getBoolean (  \" bool \"  )  )     !  =    true )", "throw   new   utils . GdxRuntimeException (  \" bool   failed \"  )  ;", "if    (  ( prefs . getInteger (  \" int \"  )  )     !  =     1  2  3  4  )", "throw   new   utils . GdxRuntimeException (  \" int   failed \"  )  ;", "if    (  ( prefs . getLong (  \" long \"  )  )     !  =     ( Long . MAX _ VALUE )  )", "throw   new   utils . GdxRuntimeException (  \" long   failed \"  )  ;", "if    (  ( prefs . getFloat (  \" float \"  )  )     !  =     1  .  2  3  4  5 F )", "throw   new   utils . GdxRuntimeException (  \" float   failed \"  )  ;", "if    (  !  ( prefs . getString (  \" string \"  )  . equals (  \" test !  \"  )  )  )", "throw   new   utils . GdxRuntimeException (  \" string   failed \"  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.PreferencesTest"}, {"methodBody": ["METHOD_START", "{", "position . set ( this . projector . position )  ;", "modelNormal . set ( model )  . toNormalMatrix (  )  ;", "shader . setUniformMatrix (  \" u _ camera \"  ,    cam )  ;", "shader . setUniformMatrix (  \" u _ projector \"  ,    projector )  ;", "shader . setUniformf (  \" u _ projectorPos \"  ,    position . x ,    position . y ,    position . z )  ;", "shader . setUniformMatrix (  \" u _ model \"  ,    model )  ;", "shader . setUniformMatrix (  \" u _ modelNormal \"  ,    modelNormal )  ;", "shader . setUniformf (  \" u _ color \"  ,    color . r ,    color . g ,    color . b )  ;", "shader . setUniformi (  \" u _ texture \"  ,     0  )  ;", "mesh . render ( shader ,    GL _ TRIANGLES )  ;", "}", "METHOD_END"], "methodName": ["renderMesh"], "fileName": "com.badlogic.gdx.tests.ProjectiveTextureTest"}, {"methodBody": ["METHOD_START", "{", "plane    =    new   Mesh ( true ,     4  ,     6  ,    new   com . badlogic . gdx . graphics . VertexAttribute ( Usage . Position ,     3  ,    ShaderProgram . POSITION _ ATTRIBUTE )  ,    new   com . badlogic . gdx . graphics . VertexAttribute ( Usage . Normal ,     3  ,    ShaderProgram . NORMAL _ ATTRIBUTE )  )  ;", "plane . setVertices ( new   float [  ]  {     -  1  0  ,     -  1  ,     1  0  ,     0  ,     1  ,     0  ,     1  0  ,     -  1  ,     1  0  ,     0  ,     1  ,     0  ,     1  0  ,     -  1  ,     -  1  0  ,     0  ,     1  ,     0  ,     -  1  0  ,     -  1  ,     -  1  0  ,     0  ,     1  ,     0     }  )  ;", "plane . setIndices ( new   short [  ]  {     3  ,     2  ,     1  ,     1  ,     0  ,     3     }  )  ;", "texture    =    new   com . badlogic . gdx . graphics . Texture ( files . internal (  \" data / badlogic . jpg \"  )  ,    Format . RGB 5  6  5  ,    true )  ;", "texture . setFilter ( MipMap ,    Nearest )  ;", "cam    =    new   PerspectiveCamera (  6  7  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "cam . position . set (  0  ,     5  ,     1  0  )  ;", "cam . lookAt (  0  ,     0  ,     0  )  ;", "cam . update (  )  ;", "controller    =    new   PerspectiveCamController ( cam )  ;", "projector    =    new   PerspectiveCamera (  6  7  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "projector . position . set (  2  ,     3  ,     2  )  ;", "projector . lookAt (  0  ,     0  ,     0  )  ;", "projector . normalizeUp (  )  ;", "projector . update (  )  ;", "}", "METHOD_END"], "methodName": ["setupScene"], "fileName": "com.badlogic.gdx.tests.ProjectiveTextureTest"}, {"methodBody": ["METHOD_START", "{", "ShaderProgram . pedantic    =    false ;", "projTexShader    =    new   ShaderProgram ( files . internal (  \" data / shaders / projtex - vert . glsl \"  )  . readString (  )  ,    files . internal (  \" data / shaders / projtex - frag . glsl \"  )  . readString (  )  )  ;", "if    (  !  ( projTexShader . isCompiled (  )  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Couldn ' t   compile   shader :     \"     +     ( projTexShader . getLog (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setupShaders"], "fileName": "com.badlogic.gdx.tests.ProjectiveTextureTest"}, {"methodBody": ["METHOD_START", "{", "ui    =    new   Stage (  )  ;", "skin    =    new   scenes . scene 2 d . ui . Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "TextButton   reload    =    new   TextButton (  \" Reload   Shaders \"  ,    skin . get ( TextButtonStyle . class )  )  ;", "camera    =    new   scenes . scene 2 d . ui . SelectBox ( skin . get ( SelectBoxStyle . class )  )  ;", "camera . setItems (  \" Camera \"  ,     \" Light \"  )  ;", "fps    =    new   scenes . scene 2 d . ui . Label (  \" fps :     \"  ,    skin . get ( LabelStyle . class )  )  ;", "Table   table    =    new   Table (  )  ;", "table . setFillParent ( true )  ;", "table . top (  )  . padTop (  1  5  )  ;", "table . add ( reload )  . spaceRight (  5  )  ;", "table . add ( camera )  . spaceRight (  5  )  ;", "table . add ( fps )  ;", "ui . addActor ( table )  ;", "reload . addListener ( new   ClickListener (  )     {", "public   void   clicked ( InputEvent   event ,    float   x ,    float   y )     {", "ShaderProgram   prog    =    new   ShaderProgram ( files . internal (  \" data / shaders / projtex - vert . glsl \"  )  . readString (  )  ,    files . internal (  \" data / shaders / projtex - frag . glsl \"  )  . readString (  )  )  ;", "if    (  ( prog . isCompiled (  )  )     =  =    false )     {", "app . log (  \" GLSL   ERROR \"  ,     (  \" Couldn \\  ' t   reload   shaders :  \\ n \"     +     ( prog . getLog (  )  )  )  )  ;", "} else    {", "projTexShader . dispose (  )  ;", "projTexShader    =    prog ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setupUI"], "fileName": "com.badlogic.gdx.tests.ProjectiveTextureTest"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["AbstractAnnotationStatic"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["AbstractInterfaceStatic"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["StaticEnum"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "testIntClass (  )  ;", "testIntArrayClass (  )  ;", "testJavaLangIntegerClass (  )  ;", "testJavaLangStringClass (  )  ;", "testJavaLangStringArrayClass (  )  ;", "testCustomInterfaceClass (  )  ;", "testCustomInterfaceArrayClass (  )  ;", "testCustomAnnotalass (  )  ;", "testCustomAnnotationArrayClass (  )  ;", "testCustomEnumClass (  )  ;", "testCustomEnumArrayClass (  )  ;", "testScene 2 DTouchableEnum (  )  ;", "testScene 2 DTouchableArrayEnum (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "app . log (  \" ClassReflectionTest \"  ,     (  \" Name   of   class :     \"     +     ( c . getName (  )  )  )  )  ;", "boolean   isArray    =    ClassReflection . isArray ( c )  ;", "expectResult ( e . isArray ,    isArray ,     \" value   of   is   Array \"  )  ;", "boolean   isEnum    =    ClassReflection . isEnum ( c )  ;", "expectResult ( e . isEnum ,    isEnum ,     \" value   of   is   Enum \"  )  ;", "boolean   isInterface    =    ClassReflection . isInterface ( c )  ;", "expectResult ( e . isInterface ,    isInterface ,     \" value   of   is   Interface \"  )  ;", "boolean   isPrimitive    =    ClassReflection . isPrimitive ( c )  ;", "expectResult ( e . isPrimitive ,    isPrimitive ,     \" value   of   is   Primitive \"  )  ;", "boolean   isAnnotation    =    ClassReflection . isAnnotation ( c )  ;", "expectResult ( e . isAnnotation ,    isAnnotation ,     \" value   of   is   Annotation \"  )  ;", "boolean   isStaticClass    =    ClassReflection . isStaticClass ( c )  ;", "expectResult ( e . isStatic ,    isStaticClass ,     \" value   of   is   Static   Class \"  )  ;", "boolean   isAbstract    =    ClassReflection . isAbstract ( c )  ;", "expectResult ( e . isAbstract ,    isAbstract ,     \" value   of   is   Abstract   Class \"  )  ;", "Class   componentType    =    ClassReflection . getComponentType ( c )  ;", "expectResult ( e . componentType ,    componentType ,     \" component   type   of   Array \"  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "if    ( expected    !  =    actual )     {", "throw   new   AsserError (  (  (  (  (  (  \" Expected   that    \"     +    message )     +     \"    is    \"  )     +    expected )     +     \"    but   is    \"  )     +    actual )  )  ;", "}", "}", "METHOD_END"], "methodName": ["expectResult"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "if    ( expected    !  =    actual )     {", "throw   new   AsserError (  (  (  (  (  (  \" Expected   that    \"     +    message )     +     \"    is    \"  )     +    expected )     +     \"    but   is    \"  )     +    actual )  )  ;", "}", "}", "METHOD_END"], "methodName": ["expectResult"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    ReflectionCorrectnessTest . AbstractAnnotationStatic [  ]  . class ;", "Class   componentClazz    =    ReflectionCorrectnessTest . AbstractAnnotationStatic . class ;", "ReflectionCorrectnessTest . Expectation   e    =    new   ReflectionCorrectnessTest . Expectation (  )  . mArray (  )  . mCompType ( componentClazz )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationArrayClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    ReflectionCorrectnessTest . AbstractAnnotationStatic . class ;", "ReflectionCorrectnessTest . Expectation   e    =    new   ReflectionCorrectnessTest . Expectation (  )  . mInterface (  )  . mAnnot (  )  . mStatic (  )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    ReflectionCorrectnessTest . StaticEnum [  ]  . class ;", "Class   componentClazz    =    ReflectionCorrectnessTest . StaticEnum . class ;", "ReflectionCorrectnessTest . Expectation   e    =    new   ReflectionCorrectnessTest . Expectation (  )  . mArray (  )  . mCompType ( componentClazz )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumArrayClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    ReflectionCorrectnessTest . StaticEnum . class ;", "ReflectionCorrectnessTest . Expectation   e    =    new   ReflectionCorrectnessTest . Expectation (  )  . mEnum (  )  . mStatic (  )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    ReflectionCorrectnessTest . AbstractInterfaceStatic [  ]  . class ;", "Class   componentClazz    =    ReflectionCorrectnessTest . AbstractInterfaceStatic . class ;", "ReflectionCorrectnessTest . Expectation   e    =    new   ReflectionCorrectnessTest . Expectation (  )  . mArray (  )  . mCompType ( componentClazz )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testCustomInterfaceArrayClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    ReflectionCorrectnessTest . AbstractInterfaceStatic . class ;", "ReflectionCorrectnessTest . Expectation   e    =    new   ReflectionCorrectnessTest . Expectation (  )  . mInterface (  )  . mStatic (  )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testCustomInterfaceClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    int [  ]  . class ;", "Class   componentClazz    =    int . class ;", ". Expectation   e    =    new    . Expectation (  )  . mArray (  )  . mCompType ( componentClazz )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testIntArrayClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    int . class ;", ". Expectation   e    =    new    . Expectation (  )  . mPrim (  )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testIntClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    Integer . class ;", ". Expectation   e    =    new    . Expectation (  )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testJavaLangIntegerClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    String [  ]  . class ;", "Class   componentClazz    =    String . class ;", ". Expectation   e    =    new    . Expectation (  )  . mArray (  )  . mCompType ( componentClazz )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testJavaLangStringArrayClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    String . class ;", ". Expectation   e    =    new    . Expectation (  )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testJavaLangStringClass"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    Touchable [  ]  . class ;", "Class   componentClazz    =    Touchable . class ;", ". Expectation   e    =    new    . Expectation (  )  . mArray (  )  . mCompType ( componentClazz )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testScene2DTouchableArrayEnum"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    Touchable . class ;", ". Expectation   e    =    new    . Expectation (  )  . mEnum (  )  ;", "doTest ( clazz ,    e )  ;", "}", "METHOD_END"], "methodName": ["testScene2DTouchableEnum"], "fileName": "com.badlogic.gdx.tests.ReflectionCorrectnessTest"}, {"methodBody": ["METHOD_START", "{", "message    +  =    line    +     \"  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["println"], "fileName": "com.badlogic.gdx.tests.ReflectionTest"}, {"methodBody": ["METHOD_START", "{", "Thread . setDefaultUncaughtExceptionHandler ( RunnablePostTest . exHandler )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.RunnablePostTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "final   TextureRegion   region    =    new   TextureRegion ( new   Texture (  \" data / badlogic . jpg \"  )  )  ;", "final   Actor   actor    =    new   Actor (  )     {", "public   void   draw ( Batch   batch ,    float   parentAlpha )     {", "Color   color    =    getColor (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,    parentAlpha )  ;", "batch . draw ( region ,    getX (  )  ,    getY (  )  ,    getOriginX (  )  ,    getOriginY (  )  ,    getWidth (  )  ,    getHeight (  )  ,    getScaleX (  )  ,    getScaleY (  )  ,    getRotation (  )  )  ;", "}", "}  ;", "actor . setBounds (  1  5  ,     1  5  ,     1  0  0  ,     1  0  0  )  ;", "actor . setOrigin (  5  0  ,     5  0  )  ;", "stage . addActor ( actor )  ;", "actor . addListener ( new   InputListener (  )     {", "public   boolean   touchDown ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "System . out . println (  \" down \"  )  ;", "return   true ;", "}", "public   void   touchUp ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "System . out . println (  (  \" up    \"     +     ( event . getTarget (  )  )  )  )  ;", "}", "}  )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "VerticalGroup   g    =    new   VerticalGroup (  )  . space (  5  )  . reverse (  )  . pad (  5  )  . fill (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )", "g . addActor ( new   TextButton (  (  \" button    \"     +    i )  ,    skin )  )  ;", "g . addActor ( new   TextButton (  \" longer   button \"  ,    skin )  )  ;", "Table   table    =    new   Table (  )  . debug (  )  ;", "table . add ( g )  ;", "table . pack (  )  ;", "table . setPosition (  5  ,     1  0  0  )  ;", "stage . addActor ( table )  ;", "HorizontalGroup   h    =    new   HorizontalGroup (  )  . space (  5  )  . reverse (  )  . pad (  5  )  . fill (  )  ;", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )", "h . addActor ( new   TextButton (  (  \" button    \"     +    i )  ,    skin )  )  ;", "h . addActor ( new   TextButton (  \" some   taller \\ nbutton \"  ,    skin )  )  ;", "table    =    new   Table (  )  . debug (  )  ;", "table . add ( h )  ;", "table . pack (  )  ;", "table . setPosition (  1  3  0  ,     1  0  0  )  ;", "stage . addActor ( table )  ;", "table . toFront (  )  ;", "final   TextButton   button    =    new   TextButton (  \" Fancy   Background \"  ,    skin )  ;", "button . addListener ( new   ActorGestureListener (  )     {", "public   boolean   longPress ( Actor   actor ,    float   x ,    float   y )     {", "System . out . println (  (  (  (  \" long   press    \"     +    x )     +     \"  ,     \"  )     +    y )  )  ;", "return   true ;", "}", "public   void   fling ( InputEvent   event ,    float   velocityX ,    float   velocityY ,    int   button )     {", "System . out . println (  (  (  (  \" fling    \"     +    velocityX )     +     \"  ,     \"  )     +    velocityY )  )  ;", "}", "public   void   zoom ( InputEvent   event ,    float   initialDistance ,    float   distance )     {", "System . out . println (  (  (  (  \" zoom    \"     +    initialDistance )     +     \"  ,     \"  )     +    distance )  )  ;", "}", "public   void   pan ( InputEvent   event ,    float   x ,    float   y ,    float   deltaX ,    float   deltaY )     {", "event . getListenerActor (  )  . moveBy ( deltaX ,    deltaY )  ;", "if    ( deltaX    <     0  )", "System . out . println (  (  (  (  (  (  \" panning    \"     +    deltaX )     +     \"  ,     \"  )     +    deltaY )     +     \"     \"  )     +     ( event . getTarget (  )  )  )  )  ;", "}", "}  )  ;", "button . setPosition (  5  0  ,     5  0  )  ;", "stage . addActor ( button )  ;", "meow . setDuration (  2  )  ;", "actor . addAction ( forever ( sequence ( moveBy (  5  0  ,     0  ,     2  )  ,    moveBy (  (  -  5  0  )  ,     0  ,     2  )  ,    run ( new   Runnable (  )     {", "public   void   run (  )     {", "actor . setZIndex (  0  )  ;", "}", "}  )  )  )  )  ;", "patch    =    new   scenes . scene 2 d . utils . TiledDrawable ( skin . getRegion (  \" default - round \"  )  )  ;", "Window   window    =    new   Window (  \" Moo \"  ,    skin )  ;", "Label   lbl    =    new   Label (  \" ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJ \"  ,    skin )  ;", "lbl . setWrap ( true )  ;", "window . row (  )  ;", "window . add ( lbl )  . width (  4  0  0  )  ;", "window . pack (  )  ;", "window . pack (  )  ;", "stage . addActor ( window )  ;", "ImageTextButtonStyle   style    =    new   ImageTextButtonStyle ( skin . get (  \" default \"  ,    TextButtonStyle . class )  )  ;", "style . imageUp    =    skin . getDrawable (  \" default - round \"  )  ;", "ImageTextButton   buttonLeft    =    new   ImageTextButton (  \" HI   IM   LEFT \"  ,    style )  ;", "ImageTextButton   buttonRight    =    new   ImageTextButton (  \" HI   IM   RIGHT \"  ,    style )     {", "{", "clearChildren (  )  ;", "add ( getLabel (  )  )  ;", "add ( getImage (  )  )  ;", "}", "}  ;", "CheckBox   checkBoxLeft    =    new   CheckBox (  \" HI   IM   LEFT \"  ,    skin ,     \" default \"  )  ;", "CheckBox   checkBoxRight    =    new   CheckBox (  \" HI   IM   RIGHT \"  ,    skin ,     \" default \"  )     {", "{", "clearChildren (  )  ;", "add ( getLabel (  )  )  ;", "add ( getImage (  )  )  ;", "}", "}  ;", "buttonLeft . setPosition (  3  0  0  ,     4  0  0  )  ;", "buttonRight . setPosition (  3  0  0  ,     3  7  0  )  ;", "checkBoxLeft . setPosition (  1  5  0  ,     4  0  0  )  ;", "checkBoxRight . setPosition (  1  5  0  ,     3  7  0  )  ;", "stage . addActor ( buttonLeft )  ;", "stage . addActor ( buttonRight )  ;", "stage . addActor ( checkBoxLeft )  ;", "stage . addActor ( checkBoxRight )  ;", "buttonLeft . debug (  )  ;", "buttonRight . debug (  )  ;", "checkBoxLeft . debug (  )  ;", "checkBoxRight . debug (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.Scene2dTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.Scene2dTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "stage . getBatch (  )  . begin (  )  ;", "patch . draw ( stage . getBatch (  )  ,     3  0  0  ,     1  0  0  ,     1  2  6  ,     1  2  6  )  ;", "stage . getBatch (  )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.Scene2dTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.Scene2dTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "skin    =    new   scenes . scene 2 d . ui . Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "ScrollPane   pane 2     =    new   ScrollPane ( new   scenes . scene 2 d . ui . Image ( new   Texture (  \" data / group - debug . png \"  )  )  ,    skin )  ;", "pane 2  . setScrollingDisabled ( false ,    true )  ;", "pane 2  . addListener ( new   InputListener (  )     {", "public   boolean   touchDown ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "event . stop (  )  ;", "return   true ;", "}", "}  )  ;", "Table   mytable    =    new   Table (  )  ;", "mytable . debug (  )  ;", "mytable . add ( new   scenes . scene 2 d . ui . Image ( new   Texture (  \" data / group - debug . png \"  )  )  )  ;", "mytable . row (  )  ;", "mytable . add ( new   scenes . scene 2 d . ui . Image ( new   Texture (  \" data / group - debug . png \"  )  )  )  ;", "mytable . row (  )  ;", "mytable . add ( pane 2  )  . size (  1  0  0  )  ;", "mytable . row (  )  ;", "mytable . add ( new   scenes . scene 2 d . ui . Image ( new   Texture (  \" data / group - debug . png \"  )  )  )  ;", "mytable . row (  )  ;", "mytable . add ( new   scenes . scene 2 d . ui . Image ( new   Texture (  \" data / group - debug . png \"  )  )  )  ;", "ScrollPane   pane    =    new   ScrollPane ( mytable ,    skin )  ;", "pane . setScrollingDisabled ( true ,    false )  ;", "if    ( false )     {", "pane . pack (  )  ;", "pane . setHeight ( graphics . getHeight (  )  )  ;", "} else    {", "pane . setWidth (  3  0  0  )  ;", "pane . setHeight ( graphics . getHeight (  )  )  ;", "}", "stage . addActor ( pane )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ScrollPane2Test"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  ,     0  ,     0  ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ScrollPane2Test"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.ScrollPane2Test"}, {"methodBody": ["METHOD_START", "{", "float   width    =    graphics . getWidth (  )  ;", "float   height    =    graphics . getHeight (  )  ;", "float   btnWidth    =     2  0  0  ;", "float   btnHeight    =     4  0  ;", "stage    =    new   Stage (  )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "input . setInputProcessor ( stage )  ;", "final   TextButton   fadeBtn    =    new   TextButton (  (  \" Fade :     \"     +     ( doFade )  )  ,    skin )  ;", "fadeBtn . setSize ( btnWidth ,    btnHeight )  ;", "fadeBtn . setPosition (  0  ,     ( height    -     ( fadeBtn . getHeight (  )  )  )  )  ;", "stage . addActor ( fadeBtn )  ;", "fadeBtn . addListener ( new   ChangeListener (  )     {", "@ Override", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "doFade    =     !  ( doFade )  ;", "fadeBtn . setText (  (  \" Fade :     \"     +     ( doFade )  )  )  ;", "for    ( ScrollPane   pane    :    scrollPanes )     {", "pane . setFadeScrollBars ( doFade )  ;", "}", "}", "}  )  ;", "final   TextButton   onTopBtn    =    new   TextButton (  (  \" ScrollbarsOnTop :     \"     +     ( doOnTop )  )  ,    skin )  ;", "onTopBtn . setSize ( btnWidth ,    btnHeight )  ;", "onTopBtn . setPosition (  (  (  0     +     ( fadeBtn . getWidth (  )  )  )     +     2  0  )  ,     ( height    -     ( onTopBtn . getHeight (  )  )  )  )  ;", "stage . addActor ( onTopBtn )  ;", "onTopBtn . addListener ( new   ChangeListener (  )     {", "@ Override", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "doOnTop    =     !  ( doOnTop )  ;", "onTopBtn . setText (  (  \" ScrollbarOnTop :     \"     +     ( doOnTop )  )  )  ;", "onTopBtn . invalidate (  )  ;", "for    ( ScrollPane   pane    :    scrollPanes )     {", "pane . setScrollbarsOnTop ( doOnTop )  ;", "}", "}", "}  )  ;", "float   gap    =     8  ;", "float   x    =    gap ;", "float   y    =    gap ;", "float   contWidth    =     ( width    /     2  )     -     ( gap    *     1  .  5 F )  ;", "float   contHeight    =     ( height    /     4  .  5 F )     -     ( gap    *     1  .  2  5 F )  ;", "bottomLeft    =    new   Table (  )  ;", "bottomLeft . setPosition ( x ,    y )  ;", "bottomLeft . setSize ( contWidth ,    contHeight )  ;", "stage . addActor ( bottomLeft )  ;", "bottomRight    =    new   Table (  )  ;", "bottomRight . setSize ( contWidth ,    contHeight )  ;", "x    =     (  ( bottomLeft . getX (  )  )     +     ( bottomLeft . getWidth (  )  )  )     +    gap ;", "bottomRight . setPosition ( x ,    y )  ;", "stage . addActor ( bottomRight )  ;", "topLeft    =    new   Table (  )  ;", "topLeft . setSize ( contWidth ,    contHeight )  ;", "x    =    bottomLeft . getX (  )  ;", "y    =     (  ( bottomLeft . getY (  )  )     +     ( bottomLeft . getHeight (  )  )  )     +    gap ;", "topLeft . setPosition ( x ,    y )  ;", "stage . addActor ( topLeft )  ;", "topRight    =    new   Table (  )  ;", "topRight . setSize ( contWidth ,    contHeight )  ;", "x    =    bottomRight . getX (  )  ;", "y    =    topLeft . getY (  )  ;", "topRight . setPosition ( x ,    y )  ;", "stage . addActor ( topRight )  ;", "horizOnlyTop    =    new   Table (  )  ;", "horizOnlyTop . setSize ( contWidth ,    contHeight )  ;", "x    =    topRight . getX (  )  ;", "y    =     (  ( topRight . getY (  )  )     +     ( topRight . getHeight (  )  )  )     +    gap ;", "horizOnlyTop . setPosition ( x ,    y )  ;", "stage . addActor ( horizOnlyTop )  ;", "horizOnlyBottom    =    new   Table (  )  ;", "horizOnlyBottom . setSize ( contWidth ,    contHeight )  ;", "x    =    topLeft . getX (  )  ;", "y    =     (  ( topLeft . getY (  )  )     +     ( topLeft . getHeight (  )  )  )     +    gap ;", "horizOnlyBottom . setPosition ( x ,    y )  ;", "stage . addActor ( horizOnlyBottom )  ;", "vertOnlyLeft    =    new   Table (  )  ;", "vertOnlyLeft . setSize ( contWidth ,    contHeight )  ;", "x    =    horizOnlyBottom . getX (  )  ;", "y    =     (  ( horizOnlyBottom . getY (  )  )     +     ( horizOnlyBottom . getHeight (  )  )  )     +    gap ;", "vertOnlyLeft . setPosition ( x ,    y )  ;", "stage . addActor ( vertOnlyLeft )  ;", "vertOnlyRight    =    new   Table (  )  ;", "vertOnlyRight . setSize ( contWidth ,    contHeight )  ;", "x    =    horizOnlyTop . getX (  )  ;", "y    =     (  ( horizOnlyTop . getY (  )  )     +     ( horizOnlyTop . getHeight (  )  )  )     +    gap ;", "vertOnlyRight . setPosition ( x ,    y )  ;", "stage . addActor ( vertOnlyRight )  ;", "Table   bottomLeftTable    =    new   Table (  )  ;", "Table   bottomRightTable    =    new   Table (  )  ;", "Table   topLeftTable    =    new   Table (  )  ;", "Table   topRightTable    =    new   Table (  )  ;", "Table   horizOnlyTopTable    =    new   Table (  )  ;", "Table   horizOnlyBottomTable    =    new   Table (  )  ;", "Table   vertOnlyLeftTable    =    new   Table (  )  ;", "Table   vertOnlyRightTable    =    new   Table (  )  ;", "final   ScrollPane   bottomLeftScroll    =    new   ScrollPane ( bottomLeftTable ,    skin )  ;", "bottomLeftScroll . setScrollBarPositions ( true ,    false )  ;", "final   ScrollPane   bottomRightScroll    =    new   ScrollPane ( bottomRightTable ,    skin )  ;", "bottomRightScroll . setScrollBarPositions ( true ,    true )  ;", "final   ScrollPane   topLeftScroll    =    new   ScrollPane ( topLeftTable ,    skin )  ;", "topLeftScroll . setScrollBarPositions ( false ,    false )  ;", "final   ScrollPane   topRightScroll    =    new   ScrollPane ( topRightTable ,    skin )  ;", "topRightScroll . setScrollBarPositions ( false ,    true )  ;", "final   ScrollPane   horizOnlyTopScroll    =    new   ScrollPane ( horizOnlyTopTable ,    skin )  ;", "horizOnlyTopScroll . setScrollBarPositions ( false ,    true )  ;", "final   ScrollPane   horizOnlyBottomScroll    =    new   ScrollPane ( horizOnlyBottomTable ,    skin )  ;", "horizOnlyBottomScroll . setScrollBarPositions ( true ,    true )  ;", "final   ScrollPane   vertOnlyLeftScroll    =    new   ScrollPane ( vertOnlyLeftTable ,    skin )  ;", "vertOnlyLeftScroll . setScrollBarPositions ( true ,    false )  ;", "final   ScrollPane   vertOnlyRightScroll    =    new   ScrollPane ( vertOnlyRightTable ,    skin )  ;", "vertOnlyRightScroll . setScrollBarPositions ( true ,    true )  ;", "ScrollPane [  ]    panes    =    new   ScrollPane [  ]  {    bottomLeftScroll ,    bottomRightScroll ,    topLeftScroll ,    topRightScroll ,    horizOnlyTopScroll ,    horizOnlyBottomScroll ,    vertOnlyLeftScroll ,    vertOnlyRightScroll    }  ;", "for    ( ScrollPane   pane    :    panes )     {", "scrollPanes . add ( pane )  ;", "}", "Table [  ]    tables    =    new   Table [  ]  {    bottomLeftTable ,    bottomRightTable ,    topLeftTable ,    topRightTable ,    horizOnlyTopTable ,    horizOnlyBottomTable ,    vertOnlyLeftTable ,    vertOnlyRightTable    }  ;", "for    ( Table   t    :    tables )", "t . defaults (  )  . expandX (  )  . fillX (  )  ;", "horizOnlyTopTable . add ( new   scenes . scene 2 d . ui . Label (  \" HORIZONTAL - ONLY - TOP   verify   HORIZONTAL   scroll   bar   is   on   the   TOP   and   properly   aligned \"  ,    skin )  )  . row (  )  ;", "horizOnlyTopTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "horizOnlyBottomTable . add ( new   scenes . scene 2 d . ui . Label (  \" HORIZONTAL - ONLY - BOTTOM   verify   HORIZONTAL   scroll   bar   is   on   the   BOTTOM   and   properly   aligned \"  ,    skin )  )  . row (  )  ;", "horizOnlyBottomTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "for    ( int   i    =     0  ;    i    <     1  2  ;    i +  +  )     {", "bottomLeftTable . add ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"    BOTTOM - LEFT   verify   scroll   bars   are   on   the   BOTTOM   and   the   LEFT ,    and   are   properly   aligned \"  )  ,    skin )  )  . row (  )  ;", "bottomLeftTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "bottomRightTable . add ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"    BOTTOM - RIGHT   verify   scroll   bars   are   on   the   BOTTOM   and   the   RIGHT ,    and   are   properly   aligned \"  )  ,    skin )  )  . row (  )  ;", "bottomRightTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "topLeftTable . add ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"    TOP - LEFT   verify   scroll   bars   are   on   the   TOP   and   the   LEFT ,    and   are   properly   aligned \"  )  ,    skin )  )  . row (  )  ;", "topLeftTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "topRightTable . add ( new   scenes . scene 2 d . ui . Label (  ( i    +     \"    TOP - RIGHT   verify   scroll   bars   are   on   the   TOP   and   the   RIGHT ,    and   are   properly   aligned \"  )  ,    skin )  )  . row (  )  ;", "topRightTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "vertOnlyLeftTable . add ( new   scenes . scene 2 d . ui . Label (  \" VERT - ONLY - LEFT \"  ,    skin )  )  . row (  )  ;", "vertOnlyLeftTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "vertOnlyRightTable . add ( new   scenes . scene 2 d . ui . Label (  \" VERT - ONLY - RIGHT \"  ,    skin )  )  . row (  )  ;", "vertOnlyRightTable . add ( new   scenes . scene 2 d . ui . Image ( skin . getDrawable (  \" default - rect \"  )  )  )  . height (  2  0  )  . row (  )  ;", "}", "bottomLeft . add ( bottomLeftScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "bottomRight . add ( bottomRightScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "topLeft . add ( topLeftScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "topRight . add ( topRightScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "horizOnlyTop . add ( horizOnlyTopScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "horizOnlyBottom . add ( horizOnlyBottomScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "vertOnlyLeft . add ( vertOnlyLeftScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "vertOnlyRight . add ( vertOnlyRightScroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "for    ( ScrollPane   pane    :    scrollPanes )     {", "pane . setFadeScrollBars ( doFade )  ;", "pane . setScrollbarsOnTop ( doOnTop )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ScrollPaneScrollBarsTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.ScrollPaneScrollBarsTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ScrollPaneScrollBarsTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.ScrollPaneScrollBarsTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "input . setInputProcessor ( stage )  ;", "container    =    new   Table (  )  ;", "stage . addActor ( container )  ;", "container . setFillParent ( true )  ;", "Table   table    =    new   Table (  )  ;", "final   ScrollPane   scroll    =    new   ScrollPane ( table ,    skin )  ;", "InputListener   stopTouchDown    =    new   InputListener (  )     {", "public   boolean   touchDown ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "event . stop (  )  ;", "return   false ;", "}", "}  ;", "table . pad (  1  0  )  . defaults (  )  . expandX (  )  . space (  4  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "table . row (  )  ;", "table . add ( new   scenes . scene 2 d . ui . Label (  ( i    +     \" uno \"  )  ,    skin )  )  . expandX (  )  . fillX (  )  ;", "TextButton   button    =    new   TextButton (  ( i    +     \" dos \"  )  ,    skin )  ;", "table . add ( button )  ;", "button . addListener ( new   ClickListener (  )     {", "public   void   clicked ( InputEvent   event ,    float   x ,    float   y )     {", "System . out . println (  (  (  (  \" click    \"     +    x )     +     \"  ,     \"  )     +    y )  )  ;", "}", "}  )  ;", "Slider   slider    =    new   Slider (  0  ,     1  0  0  ,     1  ,    false ,    skin )  ;", "slider . addListener ( stopTouchDown )  ;", "table . add ( slider )  ;", "table . add ( new   scenes . scene 2 d . ui . Label (  ( i    +     \" tres   long 0    long 1    long 2    long 3    long 4    long 5    long 6    long 7    long 8    long 9    long 1  0    long 1  1    long 1  2  \"  )  ,    skin )  )  ;", "}", "final   TextButton   flickButton    =    new   TextButton (  \" Flick   Scroll \"  ,    skin . get (  \" toggle \"  ,    TextButtonStyle . class )  )  ;", "flickButton . setChecked ( true )  ;", "flickButton . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "scroll . setFlickScroll ( flickButton . isChecked (  )  )  ;", "}", "}  )  ;", "final   TextButton   fadeButton    =    new   TextButton (  \" Fade   Scrollbars \"  ,    skin . get (  \" toggle \"  ,    TextButtonStyle . class )  )  ;", "fadeButton . setChecked ( true )  ;", "fadeButton . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "scroll . setFadeScrollBars ( fadeButton . isChecked (  )  )  ;", "}", "}  )  ;", "final   TextButton   smoothButton    =    new   TextButton (  \" Smooth   Scrolling \"  ,    skin . get (  \" toggle \"  ,    TextButtonStyle . class )  )  ;", "smoothButton . setChecked ( true )  ;", "smoothButton . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "scroll . setSmoothScrolling ( smoothButton . isChecked (  )  )  ;", "}", "}  )  ;", "final   TextButton   onTopButton    =    new   TextButton (  \" Scrollbars   On   Top \"  ,    skin . get (  \" toggle \"  ,    TextButtonStyle . class )  )  ;", "onTopButton . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "scroll . setScrollbarsOnTop ( onTopButton . isChecked (  )  )  ;", "}", "}  )  ;", "container . add ( scroll )  . expand (  )  . fill (  )  . colspan (  4  )  ;", "container . row (  )  . space (  1  0  )  . padBottom (  1  0  )  ;", "container . add ( flickButton )  . right (  )  . expandX (  )  ;", "container . add ( onTopButton )  ;", "container . add ( smoothButton )  ;", "container . add ( fadeButton )  . left (  )  . expandX (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ScrollPaneTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.ScrollPaneTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.ScrollPaneTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ScrollPaneTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.ScrollPaneTest"}, {"methodBody": ["METHOD_START", "{", "for    ( SelectTest . Dummy   d    :    SelectTest . player )     {", "d . setRandomPos (  )  ;", "}", "for    ( SelectTest . Dummy   d    :    SelectTest . enemy )     {", "d . setRandomPos (  )  ;", "}", "}", "METHOD_END"], "methodName": ["allRandom"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "SelectTest . verify    =    false ;", "SelectTest . Dummy   test    =    SelectTest . player . get (  0  )  ;", "SelectTest . Dummy   lastFound    =    null ;", "SelectTest . allRandom (  )  ;", "for    ( int   i    =     0  ;    i    <    runs ;    i +  +  )     {", "SelectTest . Dummy   found    =    test . getKthNearestEnemy ( k )  ;", "if    ( lastFound    =  =    null )     {", "lastFound    =    found ;", "} else    {", "if    (  !  ( lastFound . equals ( found )  )  )     {", "SelectTest . print (  \" CONSISTENCY   TEST   FAILED \"  )  ;", "SelectTest . print (  (  \" lastFound :     \"     +    lastFound )  )  ;", "SelectTest . print (  (  \" justFound :     \"     +    found )  )  ;", "throw   new   GdxRuntimeException (  \" test   failed \"  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["consistencyTest"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    String . format (  \"  [  % d   runs   with    % dx % d   dummy   game   units ]     -     \"  ,    runs ,    SelectTest . player . size ,    SelectTest . enemy . size )  ;", "SelectTest . verify    =    true ;", "SelectTest . test ( runs ,    k )  ;", "SelectTest . print (  ( msg    +     \" VERIFIED \"  )  )  ;", "}", "METHOD_END"], "methodName": ["correctnessTest"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "float   variance    =     2  0  ;", "Array <  . Dummy >    dummies    =    new   Array <  . Dummy >  (  )  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", ". Dummy   d    =    new    . Dummy (  )  ;", "dummies . add ( d )  ;", "d . pos    =    new   Vector 2  (  )  ;", "d . id    =     (  . nextID )  +  +  ;", "}", "return   dummies ;", "}", "METHOD_END"], "methodName": ["createDummies"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "SelectTest . Dummy   kthDummy    =    null ;", "SelectTest . perf . reset (  )  ;", "SelectTest . allPerf . start (  )  ;", "for    ( SelectTest . Dummy   d    :    SelectTest . player )     {", "SelectTest . Dummy   found    =    d . getKthNearestEnemy ( k )  ;", "}", "SelectTest . allPerf . stop (  )  ;", "SelectTest . allPerf . tick (  )  ;", "if    ( silent )", "return ;", "SelectTest . print ( String . format (  \" found   nearest .    min :     %  .  4 f ,    max :     %  .  4 f ,    avg :     %  .  4 f ,    total :     %  .  3 f   ms \"  ,     (  ( SelectTest . perf . time . min )     *     1  0  0  0  )  ,     (  ( SelectTest . perf . time . max )     *     1  0  0  0  )  ,     (  ( SelectTest . perf . time . average )     *     1  0  0  0  )  ,     (  ( SelectTest . perf . time . total )     *     1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getKthNearestEnemy"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "SelectTest . verify    =    false ;", "SelectTest . test ( runs ,    k )  ;", "String   msg    =    String . format (  \"  [  % d   runs   with    % dx % d   dummy   game   units ]     -     \"  ,    runs ,    SelectTest . player . size ,    SelectTest . enemy . size )  ;", "SelectTest . print (  ( msg    +     ( String . format (  \" avg :     %  .  5 f ,    min / max :     %  .  4 f /  %  .  4 f ,    total   time :     %  .  3 f    ( ms )  ,    made    % d   comparisons \"  ,    SelectTest . allPerf . time . min ,    SelectTest . allPerf . time . max ,     (  ( SelectTest . allPerf . time . average )     *     1  0  0  0  )  ,     (  ( SelectTest . allPerf . time . total )     *     1  0  0  0  )  ,    SelectTest . comparisonsMade )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["performanceTest"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   o    :    objs )     {", "System . out . print ( o )  ;", "}", "System . out . println (  )  ;", "}", "METHOD_END"], "methodName": ["print"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "SelectTest . comparisonsMade    =     0  ;", "SelectTest . perf . reset (  )  ;", "SelectTest . allPerf . reset (  )  ;", "SelectTest . allRandom (  )  ;", "SelectTest . enemy . shuffle (  )  ;", "SelectTest . player . shuffle (  )  ;", "for    ( int   i    =     0  ;    i    <    runs ;    i +  +  )     {", "SelectTest . getKthNearestEnemy ( SelectTest . quiet ,    k )  ;", "}", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "SelectTest . verify    =    false ;", "for    ( int   i    =     0  ;    i    <    runs ;    i +  +  )     {", "SelectTest . allRandom (  )  ;", "SelectTest . player . shuffle (  )  ;", "SelectTest . enemy . shuffle (  )  ;", "SelectTest . originDummy    =    SelectTest . player . random (  )  ;", "int   idx    =    SelectTest . enemy . selectRankedIndex ( SelectTest . distComp ,    k )  ;", "SelectTest . Dummy   indexDummy    =    SelectTest . enemy . get ( idx )  ;", "SelectTest . Dummy   valueDummy    =    SelectTest . enemy . selectRanked ( SelectTest . distComp ,    k )  ;", "if    (  !  ( indexDummy . equals ( valueDummy )  )  )     {", "throw   new   GdxRuntimeException (  (  (  (  (  (  \" results   of   selectRankedIndex   and   selectRanked   do   not   return   the   same   object \\ n \"     +     \" selectRankedIndex    -  >     \"  )     +    indexDummy )     +     \"  \\ n \"  )     +     \" selectRanked                   -  >     \"  )     +    valueDummy )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testValueMatchesIndex"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "SelectTest . enemy . sort ( SelectTest . distComp )  ;", "int   idx    =    SelectTest . enemy . indexOf ( d ,    true )  ;", "if    (  ( SelectTest . enemy . get ( idx )  )     !  =     ( SelectTest . enemy . get (  ( k    -     1  )  )  )  )     {", "System . out . println (  (  \" origin   dummy :     \"     +     ( SelectTest . originDummy )  )  )  ;", "System . out . println (  (  (  (  (  \" TEST   FAILURE :     \"     +     \" idx :     \"  )     +    idx )     +     \"    does   not   equal    ( k    -     1  )  :     \"  )     +     ( k    -     1  )  )  )  ;", "throw   new   GdxRuntimeException (  \" test   failed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["verifyCorrectness"], "fileName": "com.badlogic.gdx.tests.SelectTest"}, {"methodBody": ["METHOD_START", "{", "Pixmap   pixmap    =    new   Pixmap (  2  5  6  ,     2  5  6  ,    Format . RGBA 8  8  8  8  )  ;", "pixmap . setColor (  1  ,     1  ,     1  ,     1  )  ;", "pixmap . fill (  )  ;", "pixmap . setColor (  0  ,     0  ,     0  ,     1  )  ;", "pixmap . drawLine (  0  ,     0  ,     2  5  6  ,     2  5  6  )  ;", "pixmap . drawLine (  2  5  6  ,     0  ,     0  ,     2  5  6  )  ;", "texture    =    new   graphics . Texture ( pixmap )  ;", "pixmap . dispose (  )  ;", "pixmap    =    new   Pixmap (  2  5  6  ,     2  5  6  ,    Format . RGBA 8  8  8  8  )  ;", "pixmap . setColor (  1  ,     1  ,     1  ,     1  )  ;", "pixmap . fill (  )  ;", "pixmap . setColor (  0  ,     0  ,     0  ,     1  )  ;", "pixmap . drawLine (  1  2  8  ,     0  ,     1  2  8  ,     2  5  6  )  ;", "texture 2     =    new   graphics . Texture ( pixmap )  ;", "pixmap . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["createTexture"], "fileName": "com.badlogic.gdx.tests.ShaderMultitextureTest"}, {"methodBody": ["METHOD_START", "{", "gl 2  0  . glViewport (  0  ,     0  ,    graphics . getBackBufferWidth (  )  ,    graphics . getBackBufferHeight (  )  )  ;", "gl 2  0  . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "gl 2  0  . glActiveTexture ( GL _ TEXTURE 0  )  ;", ". bind (  )  ;", "gl 2  0  . glActiveTexture ( GL _ TEXTURE 1  )  ;", "2  . bind (  )  ;", "shader . begin (  )  ;", "shader . setUniformi (  \" s _  \"  ,     0  )  ;", "shader . setUniformi (  \" s _  2  \"  ,     1  )  ;", "mesh . render ( shader ,    GL _ TRIANGLES )  ;", "shader . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ShaderMultitextureTest"}, {"methodBody": ["METHOD_START", "{", "createTexture (  )  ;", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "com.badlogic.gdx.tests.ShaderMultitextureTest"}, {"methodBody": ["METHOD_START", "{", "renderer    =    new   ShapeRenderer (  )  ;", "cam    =    new   PerspectiveCamera (  4  7  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "cam . position . set (  0  ,     0  ,     2  )  ;", "cam . near    =     0  .  1 F ;", "controller    =    new   PerspectiveCamController ( cam )  ;", "input . setInputProcessor ( controller )  ;", "batch    =    new   SpriteBatch (  )  ;", "font    =    new   graphics . g 2 d . BitmapFont ( files . internal (  \" data / arial -  1  5  . fnt \"  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ShapeRendererTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "gl . glEnable ( GL _ DEPTH _ TEST )  ;", "cam . update (  )  ;", "renderer . setProjectionMatrix ( cam . combined )  ;", "renderer . identity (  )  ;", "renderer . rotate (  0  ,     1  ,     0  ,     2  0  )  ;", "renderer . translate (  (  -  0  .  5 F )  ,     (  -  0  .  5 F )  ,     0  )  ;", "random . setSeed (  0  )  ;", "renderer . begin ( Point )  ;", "renderer . setColor ( PINK )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )", "renderer . point ( math . MathUtils . random (  0  .  0 F ,     1  .  0 F )  ,    math . MathUtils . random (  0  .  0 F ,     1  .  0 F )  ,     0  )  ;", "renderer . end (  )  ;", "if    ( input . isKeyPressed ( F )  )     {", "renderer . begin ( Filled )  ;", "renderer . setColor ( RED )  ;", "renderer . rect (  0  ,     0  ,     1  ,     1  )  ;", "renderer . setColor ( BLUE )  ;", "renderer . circle (  0  .  2 F ,     0  .  2 F ,     0  .  5 F ,     4  0  )  ;", "renderer . setColor ( WHITE )  ;", "renderer . box (  0  .  1 F ,     0  .  1 F ,     0  .  1 F ,     0  .  3 F ,     0  .  2  5 F ,     0  .  1 F )  ;", "renderer . setColor ( GREEN )  ;", "renderer . cone (  0  .  6 F ,     0  .  6 F ,     0  ,     0  .  3 F ,     0  .  7  5 F ,     2  0  )  ;", "renderer . setColor ( MAGENTA )  ;", "renderer . triangle (  (  -  0  .  1 F )  ,     0  .  1 F ,     (  -  0  .  6 F )  ,     (  -  0  .  1 F )  ,     (  -  0  .  3 F )  ,     0  .  5 F )  ;", "renderer . setColor ( GOLD )  ;", "renderer . ellipse (  0  .  7 F ,     (  -  0  .  1 F )  ,     0  .  3 F ,     0  .  1 F ,     4  5  .  0 F ,     4  0  )  ;", "renderer . ellipse (  0  .  7 F ,     (  -  0  .  1 F )  ,     0  .  3 F ,     0  .  1 F ,     1  3  5  .  0 F )  ;", "renderer . end (  )  ;", "} else    {", "renderer . begin ( Line )  ;", "renderer . setColor ( RED )  ;", "renderer . rect (  0  ,     0  ,     1  ,     1  )  ;", "renderer . setColor ( BLUE )  ;", "renderer . circle (  0  .  2 F ,     0  .  2 F ,     0  .  5 F ,     4  0  )  ;", "renderer . setColor ( YELLOW )  ;", "renderer . line (  0  ,     0  ,     1  ,     1  )  ;", "renderer . setColor ( WHITE )  ;", "renderer . box (  0  .  1 F ,     0  .  1 F ,     0  .  1 F ,     0  .  3 F ,     0  .  2  5 F ,     0  .  1 F )  ;", "renderer . setColor ( GREEN )  ;", "renderer . cone (  0  .  6 F ,     0  .  6 F ,     0  ,     0  .  3 F ,     0  .  7  5 F ,     2  0  )  ;", "renderer . setColor ( MAGENTA )  ;", "renderer . triangle (  (  -  0  .  1 F )  ,     0  .  1 F ,     (  -  0  .  6 F )  ,     (  -  0  .  1 F )  ,     (  -  0  .  3 F )  ,     0  .  5 F )  ;", "renderer . setColor ( CYAN )  ;", "renderer . curve (  0  .  0 F ,     0  .  2  5 F ,     0  .  2 F ,     0  .  3 F ,     0  .  3 F ,     0  .  6 F ,     0  .  1 F ,     0  .  5 F ,     3  0  )  ;", "renderer . setColor ( GOLD )  ;", "renderer . ellipse (  0  .  7 F ,     (  -  0  .  1 F )  ,     0  .  3 F ,     0  .  1 F ,     4  5  .  0 F ,     4  0  )  ;", "renderer . ellipse (  0  .  7 F ,     (  -  0  .  1 F )  ,     0  .  3 F ,     0  .  1 F ,     1  3  5  .  0 F )  ;", "renderer . end (  )  ;", "}", "batch . begin (  )  ;", "font . draw ( batch ,     (  \" fps :     \"     +     ( graphics . getFramesPerSecond (  )  )  )  ,     0  ,     2  0  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ShapeRendererTest"}, {"methodBody": ["METHOD_START", "{", "float   width    =    graphics . getWidth (  )  ;", "float   height    =    graphics . getHeight (  )  ;", "camera    =    new   PerspectiveCamera (  4  5  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "camera . near    =     1  ;", "camera . far    =     3  0  0  ;", "camera . position . set (  0  ,     0  ,     5  )  ;", "controller    =    new   PerspectiveCamController ( camera )  ;", "input . setInputProcessor ( controller )  ;", "batch    =    new   DecalBatch ( new   graphics . g 3 d . decals . CameraGroupStrategy ( camera )  )  ;", "TextureRegion [  ]    textures    =    new   TextureRegion [  ]  {    new   TextureRegion ( new   graphics . Texture ( files . internal (  \" data / egg . png \"  )  )  )  ,    new   TextureRegion ( new   graphics . Texture ( files . internal (  \" data / wheel . png \"  )  )  )  ,    new   TextureRegion ( new   graphics . Texture ( files . internal (  \" data / badlogic . jpg \"  )  )  )     }  ;", "Decal   decal    =    Decal . newDecal (  1  ,     1  ,    textures [  1  ]  )  ;", "decal . setPosition (  0  ,     0  ,     0  )  ;", "decals . add ( decal )  ;", "decal    =    Decal . newDecal (  1  ,     1  ,    textures [  0  ]  ,    true )  ;", "decal . setPosition (  0  .  5 F ,     0  .  5 F ,     1  )  ;", "decals . add ( decal )  ;", "decal    =    Decal . newDecal (  1  ,     1  ,    textures [  0  ]  ,    true )  ;", "decal . setPosition (  1  ,     1  ,     (  -  1  )  )  ;", "decals . add ( decal )  ;", "decal    =    Decal . newDecal (  1  ,     1  ,    textures [  2  ]  )  ;", "decal . setPosition (  1  .  5 F ,     1  .  5 F ,     (  -  2  )  )  ;", "decals . add ( decal )  ;", "decal    =    Decal . newDecal (  1  ,     1  ,    textures [  1  ]  )  ;", "decal . setPosition (  2  ,     2  ,     (  -  1  .  5 F )  )  ;", "decals . add ( decal )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.SimpleDecalTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "gl . glEnable ( GL _ DEPTH _ TEST )  ;", "camera . update (  )  ;", "for    ( int   i    =     0  ;    i    <     ( decals . size )  ;    i +  +  )     {", "decal    =    decals . get ( i )  ;", "if    ( billboard )     {", "decal . lookAt ( camera . position ,    camera . up )  ;", "}", "batch . add ( decal )  ;", "}", "batch . flush (  )  ;", "logger . log (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.SimpleDecalTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . draw (  )  ;", "Array < Actor >    actors    =    stage . getActors (  )  ;", "int   numVisible    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( actors . size )  ;    i +  +  )     {", "numVisible    +  =     (  (  (  . CullableActor )     ( actors . get ( i )  )  )  . visible )     ?     1     :     0  ;", "}", "batch . begin (  )  ;", "font . draw ( batch ,     (  (  (  \" Visible :     \"     +    numVisible )     +     \"  ,    fps :     \"  )     +     ( graphics . getFramesPerSecond (  )  )  )  ,     2  0  ,     3  0  )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.SimpleStageCullingTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  .  7 F ,     0  .  7 F ,     0  .  7 F ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "float   begin    =     0  ;", "float   end    =     0  ;", "float   draw 1     =     0  ;", "float   draw 2     =     0  ;", "float   drawText    =     0  ;", "angle    +  =     ( ROTATION _ SPEED )     *     ( graphics . getDeltaTime (  )  )  ;", "scale    +  =     ( SCALE _ SPEED )     *     ( graphics . getDeltaTime (  )  )  ;", "if    (  ( scale )     <     0  .  5 F )     {", "scale    =     0  .  5 F ;", "SCALE _ SPEED    =     1  ;", "}", "if    (  ( scale )     >     1  .  0 F )     {", "scale    =     1  .  0 F ;", "SCALE _ SPEED    =     -  1  ;", "}", "long   start    =    TimeUtils . nanoTime (  )  ;", "spriteBatch . begin (  )  ;", "begin    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     ( sprites . length )  ;    i    +  =     6  )", "spriteBatch . draw ( texture ,    sprites [ i ]  ,    sprites [  ( i    +     1  )  ]  ,     1  6  ,     1  6  ,     3  2  ,     3  2  ,    scale ,    scale ,    angle ,     0  ,     0  ,     3  2  ,     3  2  ,    false ,    false )  ;", "draw 1     =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     ( sprites 2  . length )  ;    i    +  =     6  )", "spriteBatch . draw ( texture 2  ,    sprites 2  [ i ]  ,    sprites 2  [  ( i    +     1  )  ]  ,     1  6  ,     1  6  ,     3  2  ,     3  2  ,    scale ,    scale ,    angle ,     0  ,     0  ,     3  2  ,     3  2  ,    false ,    false )  ;", "draw 2     =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "drawText    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "spriteBatch . end (  )  ;", "end    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "if    (  (  ( TimeUtils . nanoTime (  )  )     -     ( startTime )  )     >     1  0  0  0  0  0  0  0  0  0  )     {", "app . log (  \"  \"  ,     (  (  (  (  (  (  (  (  (  (  (  (  (  \" fps :     \"     +     ( frames )  )     +     \"  ,    render   calls :     \"  )     +     ( spriteBatch . renderCalls )  )     +     \"  ,     \"  )     +    begin )     +     \"  ,     \"  )     +    draw 1  )     +     \"  ,     \"  )     +    draw 2  )     +     \"  ,     \"  )     +    drawText )     +     \"  ,     \"  )     +    end )  )  ;", "frames    =     0  ;", "startTime    =    TimeUtils . nanoTime (  )  ;", "}", "( frames )  +  +  ;", "}", "METHOD_END"], "methodName": ["renderNormal"], "fileName": "com.badlogic.gdx.tests.SpriteBatchTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  .  7 F ,     0  .  7 F ,     0  .  7 F ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "float   begin    =     0  ;", "float   end    =     0  ;", "float   draw 1     =     0  ;", "float   draw 2     =     0  ;", "float   drawText    =     0  ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "spriteBatch . begin (  )  ;", "begin    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "float   angleInc    =     ( ROTATION _ SPEED )     *     ( graphics . getDeltaTime (  )  )  ;", "scale    +  =     ( SCALE _ SPEED )     *     ( graphics . getDeltaTime (  )  )  ;", "if    (  ( scale )     <     0  .  5 F )     {", "scale    =     0  .  5 F ;", "SCALE _ SPEED    =     1  ;", "}", "if    (  ( scale )     >     1  .  0 F )     {", "scale    =     1  .  0 F ;", "SCALE _ SPEED    =     -  1  ;", "}", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =     0  ;    i    <     ( SPRITES )  ;    i +  +  )     {", "if    ( angleInc    !  =     0  )", "sprites 3  [ i ]  . rotate ( angleInc )  ;", "if    (  ( scale )     !  =     1  )", "sprites 3  [ i ]  . setScale ( scale )  ;", "sprites 3  [ i ]  . draw ( spriteBatch )  ;", "}", "draw 1     =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "for    ( int   i    =    SPRITES ;    i    <     (  ( SPRITES )     <  <     1  )  ;    i +  +  )     {", "if    ( angleInc    !  =     0  )", "sprites 3  [ i ]  . rotate ( angleInc )  ;", "if    (  ( scale )     !  =     1  )", "sprites 3  [ i ]  . setScale ( scale )  ;", "sprites 3  [ i ]  . draw ( spriteBatch )  ;", "}", "draw 2     =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "drawText    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "spriteBatch . end (  )  ;", "end    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "if    (  (  ( TimeUtils . nanoTime (  )  )     -     ( startTime )  )     >     1  0  0  0  0  0  0  0  0  0  )     {", "app . log (  \"  \"  ,     (  (  (  (  (  (  (  (  (  (  (  (  (  \" fps :     \"     +     ( frames )  )     +     \"  ,    render   calls :     \"  )     +     ( spriteBatch . renderCalls )  )     +     \"  ,     \"  )     +    begin )     +     \"  ,     \"  )     +    draw 1  )     +     \"  ,     \"  )     +    draw 2  )     +     \"  ,     \"  )     +    drawText )     +     \"  ,     \"  )     +    end )  )  ;", "frames    =     0  ;", "startTime    =    TimeUtils . nanoTime (  )  ;", "}", "( frames )  +  +  ;", "}", "METHOD_END"], "methodName": ["renderSprites"], "fileName": "com.badlogic.gdx.tests.SpriteBatchTest"}, {"methodBody": ["METHOD_START", "{", "texture    =    new   com . badlogic . gdx . graphics . Texture ( files . internal (  \" data / badlogicsmall . jpg \"  )  )  ;", "Sprite   sprite    =    new   Sprite ( texture )  ;", "sprite . setSize ( tileSize ,    tileSize )  ;", "cache    =    new   SpriteCache (  1  0  0  0  ,    false )  ;", "for    ( int   y    =     0  ;    y    <     ( tileMapHeight )  ;    y +  +  )     {", "cache . beginCache (  )  ;", "for    ( int   x    =     0  ;    x    <     ( tileMapWidth )  ;    x +  +  )     {", "sprite . setPosition (  ( x    *     ( tileSize )  )  ,     ( y    *     ( tileSize )  )  )  ;", "cache . add ( sprite )  ;", "}", "cache . endCache (  )  ;", "sprite . rotate 9  0  ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.SpriteCacheOffsetTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "c . begin (  )  ;", "for    ( int   y    =     1  ;    y    <     (  ( tileMapHeight )     -     1  )  ;    y +  +  )", "c . draw ( y ,     1  ,     (  ( tileMapWidth )     -     2  )  )  ;", "c . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.SpriteCacheOffsetTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  .  7 F ,     0  .  7 F ,     0  .  7 F ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "float   begin    =     0  ;", "float   end    =     0  ;", "float   draw 1     =     0  ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "s . begin (  )  ;", "begin    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "s . draw ( normalCacheID )  ;", "draw 1     =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "s . end (  )  ;", "end    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "if    (  (  ( TimeUtils . nanoTime (  )  )     -     ( startTime )  )     >     1  0  0  0  0  0  0  0  0  0  )     {", "frames    =     0  ;", "startTime    =    TimeUtils . nanoTime (  )  ;", "}", "( frames )  +  +  ;", "}", "METHOD_END"], "methodName": ["renderNormal"], "fileName": "com.badlogic.gdx.tests.SpriteCacheTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  .  7 F ,     0  .  7 F ,     0  .  7 F ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "float   begin    =     0  ;", "float   end    =     0  ;", "float   draw 1     =     0  ;", "float   draw 2     =     0  ;", "float   drawText    =     0  ;", "long   start    =    TimeUtils . nanoTime (  )  ;", "s . begin (  )  ;", "begin    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "s . draw ( sID )  ;", "draw 1     =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "start    =    TimeUtils . nanoTime (  )  ;", "s . end (  )  ;", "end    =     (  ( TimeUtils . nanoTime (  )  )     -    start )     /     1  .  0 E 9 F ;", "if    (  (  ( TimeUtils . nanoTime (  )  )     -     ( startTime )  )     >     1  0  0  0  0  0  0  0  0  0  )     {", "frames    =     0  ;", "startTime    =    TimeUtils . nanoTime (  )  ;", "}", "( frames )  +  +  ;", "}", "METHOD_END"], "methodName": ["renderSprites"], "fileName": "com.badlogic.gdx.tests.SpriteCacheTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stage )     !  =     ( stage 2  )  )     {", "stage    =    stage 2  ;", "} else    {", "stage    =    stage 1  ;", "}", "}", "METHOD_END"], "methodName": ["switchStage"], "fileName": "com.badlogic.gdx.tests.StageDebugTest"}, {"methodBody": ["METHOD_START", "{", "float   advance    =     3  2     +     ( StageTest . SPACING )  ;", "for    ( int   y    =     0  ;    y    <     (  ( StageTest . NUM _ SPRITES )     *    advance )  ;    y    +  =    advance )", "for    ( int   x    =     0  ;    x    <     (  ( StageTest . NUM _ SPRITES )     *    advance )  ;    x    +  =    advance )     {", "scenes . scene 2 d . ui . Image   img    =    new   scenes . scene 2 d . ui . Image ( new   graphics . g 2 d . TextureRegion ( texture )  )  ;", "img . setAlign ( Align . center )  ;", "img . setScaling ( Scaling . none )  ;", "img . setBounds ( x ,    y ,     3  2  ,     3  2  )  ;", "img . setOrigin (  1  6  ,     1  6  )  ;", "group . addActor ( img )  ;", "sprites . add ( img )  ;", "}", "}", "METHOD_END"], "methodName": ["fillGroup"], "fileName": "com.badlogic.gdx.tests.StageTest"}, {"methodBody": ["METHOD_START", "{", "ui . getViewport (  )  . update ( width ,    height ,    true )  ;", "s . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.StageTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "Label   nameLabel    =    new   Label (  \" Name :  \"  ,    skin )  ;", "TextField   nameText    =    new   TextField (  \"  \"  ,    skin )  ;", "Label   addressLabel    =    new   Label (  \" Address :  \"  ,    skin )  ;", "TextField   addressText    =    new   TextField (  \"  \"  ,    skin )  ;", "table    =    new    (  )  ;", "stage . addActor ( table )  ;", "table . setSize (  2  6  0  ,     1  9  5  )  ;", "table . setPosition (  1  9  0  ,     1  4  2  )  ;", "table . debug (  )  ;", "TextureRegion   upRegion    =    skin . getRegion (  \" default - slider - knob \"  )  ;", "TextureRegion   downRegion    =    skin . getRegion (  \" default - slider - knob \"  )  ;", "BitmapFont   buttonFont    =    skin . getFont (  \" default - font \"  )  ;", "TextButton   button    =    new   TextButton (  \" Button    1  \"  ,    skin )  ;", "button . addListener ( new   InputListener (  )     {", "public   boolean   touchDown ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "System . out . println (  \" touchDown    1  \"  )  ;", "return   false ;", "}", "}  )  ;", "table . add ( button )  ;", "table 2     =    new    (  )  ;", "stage . addActor ( table 2  )  ;", "table 2  . setFillParent ( true )  ;", "table 2  . bottom (  )  ;", "TextButton   button 2     =    new   TextButton (  \" Button    2  \"  ,    skin )  ;", "button 2  . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "System . out . println (  \"  2  !  \"  )  ;", "}", "}  )  ;", "button 2  . addListener ( new   InputListener (  )     {", "public   boolean   touchDown ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "System . out . println (  \" touchDown    2  \"  )  ;", "return   false ;", "}", "}  )  ;", "table 2  . add ( button 2  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.TableLayoutTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.TableLayoutTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.TableLayoutTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.TableLayoutTest"}, {"methodBody": ["METHOD_START", "{", "message    =     \" Touch   screen   for   dialog \"  ;", "batch    =    new   SpriteBatch (  )  ;", "font    =    new   BitmapFont (  )  ;", "input . get ( new   Listener (  )     {", "@ Override", "public   void   input ( String   text )     {", "message    =     (  \" message :     \"     +    text )     +     \"  ,    touch   screen   for   new   dialog \"  ;", "}", "@ Override", "public   void   canceled (  )     {", "message    =     \" cancled   by   user \"  ;", "}", "}  ,     \" enter   something   funny \"  ,     \" funny \"  ,     \" something   funny \"  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.TextInputDialogTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "font . draw ( batch ,    message ,     1  0  ,     4  0  )  ;", "batch . end (  )  ;", "if    ( i . justTouched (  )  )     {", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.TextInputDialogTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "renderer    =    new   ShapeRenderer (  )  ;", "atlas    =    new   graphics . g 2 d . TextureAtlas ( files . internal (  \" data / pack \"  )  )  ;", "jumpAtlas    =    new   graphics . g 2 d . TextureAtlas ( files . internal (  \" data / jump . txt \"  )  )  ;", "jumpAnimation    =    new   graphics . g 2 d . Animation < graphics . g 2 d . TextureRegion >  (  0  .  2  5 F ,    jumpAtlas . findRegions (  \" ALIEN _ JUMP _  \"  )  )  ;", "badlogic    =    atlas . createSprite (  \" badlogicslice \"  )  ;", "badlogic . setPosition (  5  0  ,     5  0  )  ;", "badlogicSmall    =    atlas . createSprite (  \" badlogicsmall - rotated \"  )  ;", "badlogicSmall . setPosition (  1  0  ,     1  0  )  ;", "AtlasRegion   region    =    atlas . findRegion (  \" badlogicsmall \"  )  ;", "System . out . println (  (  (  (  \" badlogicSmall   original   size :     \"     +     ( region . originalWidth )  )     +     \"  ,     \"  )     +     ( region . originalHeight )  )  )  ;", "System . out . println (  (  (  (  \" badlogicSmall   packed   size :     \"     +     ( region . packedWidth )  )     +     \"  ,     \"  )     +     ( region . packedHeight )  )  )  ;", "star    =    atlas . createSprite (  \" particle - star \"  )  ;", "star . setPosition (  1  0  ,     7  0  )  ;", "font    =    new   graphics . g 2 d . BitmapFont ( files . internal (  \" data / font . fnt \"  )  ,    atlas . findRegion (  \" font \"  )  ,    false )  ;", "gl . glClearColor (  0  ,     1  ,     0  ,     1  )  ;", "input . setInputProcessor ( new   InputAdapter (  )     {", "public   boolean   keyUp ( int   keycode )     {", "if    ( keycode    =  =     ( Keys . UP )  )     {", "badlogicSmall . flip ( false ,    true )  ;", "} else", "if    ( keycode    =  =     ( Keys . RIGHT )  )     {", "badlogicSmall . flip ( true ,    false )  ;", "} else", "if    ( keycode    =  =     ( Keys . LEFT )  )     {", "badlogicSmall . setSize (  5  1  2  ,     5  1  2  )  ;", "} else", "if    ( keycode    =  =     ( Keys . DOWN )  )     {", "badlogicSmall . rotate 9  0  ( true )  ;", "}", "return   super . keyUp ( keycode )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.TextureAtlasTest"}, {"methodBody": ["METHOD_START", "{", "atlas . dispose (  )  ;", "jump . dispose (  )  ;", "batch . dispose (  )  ;", "font . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.TextureAtlasTest"}, {"methodBody": ["METHOD_START", "{", "time    +  =    graphics . getDeltaTime (  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "renderer . begin ( Line )  ;", "renderer . rect (  1  0  ,     1  0  ,     2  5  6  ,     2  5  6  )  ;", "renderer . end (  )  ;", "batch . begin (  )  ;", "Small . draw ( batch )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.TextureAtlasTest"}, {"methodBody": ["METHOD_START", "{", "spriteBatch    =    new   SpriteBatch (  )  ;", "texture    =    new   Texture ( new   graphics . glutils . FileTextureData ( files . internal (  \" data / t 8  8  9  0  . png \"  )  ,    null ,    null ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.TextureDataTest"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.TextureDataTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "spriteBatch . begin (  )  ;", "spriteBatch . draw ( t ,     1  0  0  ,     1  0  0  )  ;", "spriteBatch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.TextureDataTest"}, {"methodBody": ["METHOD_START", "{", "boolean   isValid    =     (  (  (  ( mapLayer . isVisible (  )  )     =  =    visibleState )     &  &     ( opacity    =  =     ( mapLayer . getOpacity (  )  )  )  )     &  &     ( offsetX    =  =     ( mapLayer . getOffsetX (  )  )  )  )     &  &     (  ( mapLayer . getOffsetY (  )  )     =  =     ( mapLayer . getOffsetY (  )  )  )  ;", "boolean   groupInstance    =    mapLayer   instanceof   MapGroupLayer ;", "if    ( isGroup    &  &     (  ! groupInstance )  )     {", "isValid    =    false ;", "}", "if    (  (  ! isGroup )     &  &    groupInstance )     {", "isValid    =    false ;", "}", "if    (  ! isValid )", "throw   new   utils . GdxRuntimeException (  (  (  \" Map   layer    \"     +     ( mapLayer . getName (  )  )  )     +     \"    is   not   valid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapProperty"], "fileName": "com.badlogic.gdx.tests.TiledMapGroupLayerTest"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  (  (  \" Compare    \"     +    a )     +     \"    to    \"  )     +    b )  )  ;", "if    ( a    !  =    b )     {", "failTest (  ( Name    +     \"     -    NOT   EQUAL \"  )  )  ;", "} else    {", "System . out . println (  (  \" TEST   PASSED :     \"     +    Name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertAbsoluteEqual"], "fileName": "com.badlogic.gdx.tests.TimeUtilsTest"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  (  (  \" Compare    \"     +    a )     +     \"    to    \"  )     +    b )  )  ;", "if    (  ( Math . abs (  ( a    -    b )  )  )     >     ( oneMilliInNanos )  )     {", "failTest (  ( Name    +     \"     -    NOT   EQUAL \"  )  )  ;", "} else    {", "System . out . println (  (  \" TEST   PASSED :     \"     +    Name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertEpsilonEqual"], "fileName": "com.badlogic.gdx.tests.TimeUtilsTest"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  (  (  \" FAILED   TEST :     [  \"     +    testName )     +     \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["failTest"], "fileName": "com.badlogic.gdx.tests.TimeUtilsTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "touchpad    =    new   scenes . scene 2 d . ui . Touchpad (  2  0  ,    skin )  ;", "touchpad . setBounds (  1  5  ,     1  5  ,     1  0  0  ,     1  0  0  )  ;", "stage . addActor ( touchpad )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.TouchpadTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.TouchpadTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.TouchpadTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.TouchpadTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "input . setInputProcessor ( stage )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "Table   table    =    new   Table (  )  ;", "table . setFillParent ( true )  ;", "stage . addActor ( table )  ;", "final   Tree   tree    =    new   Tree ( skin )  ;", "final   Node   moo 1     =    new   Node ( new   scenes . scene 2 d . ui . TextButton (  \" moo 1  \"  ,    skin )  )  ;", "final   Node   moo 2     =    new   Node ( new   scenes . scene 2 d . ui . TextButton (  \" moo 2  \"  ,    skin )  )  ;", "final   Node   moo 3     =    new   Node ( new   scenes . scene 2 d . ui . TextButton (  \" moo 3  \"  ,    skin )  )  ;", "final   Node   moo 4     =    new   Node ( new   scenes . scene 2 d . ui . TextButton (  \" moo 4  \"  ,    skin )  )  ;", "final   Node   moo 5     =    new   Node ( new   scenes . scene 2 d . ui . TextButton (  \" moo 5  \"  ,    skin )  )  ;", "tree . add ( moo 1  )  ;", "tree . add ( moo 2  )  ;", "moo 2  . add ( moo 3  )  ;", "moo 3  . add ( moo 4  )  ;", "tree . add ( moo 5  )  ;", "moo 5  . getActor (  )  . addListener ( new   ClickListener (  )     {", "public   void   clicked ( InputEvent   event ,    float   x ,    float   y )     {", "tree . remove ( moo 4  )  ;", "}", "}  )  ;", "table . add ( tree )  . fill (  )  . expand (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.TreeTest"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.TreeTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . act ( graphics . getDeltaTime (  )  )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.TreeTest"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.TreeTest"}, {"methodBody": ["METHOD_START", "{", "app . log (  \" UBJsonTest \"  ,     \"  -  -  -    performanceTest    -  -  -  \"  )  ;", "long   start    =    System . currentTimeMillis (  )  ;", "UBJsonWriter   uw    =    new   UBJsonWriter ( files . external ( UBJsonTest . fn )  . write ( false ,     8  1  9  2  )  )  ;", "uw . object (  )  ;", "uw . set (  \"  0 floats \"  ,    new   float [  ]  {        }  )  ;", "uw . set (  \"  3 floats \"  ,    new   float [  ]  {     1  ,     2  ,     3  .  4  5  6  7  8  9 F    }  )  ;", "uw . set (  \" xfloats \"  ,    new   float [  ]  {    Float . MIN _ VALUE ,    Float . MAX _ VALUE ,    Float . NaN ,    Float . NEGATIVE _ INFINITY    }  )  ;", "uw . set (  \" double \"  ,     1  .  0 E -  2  1  )  ;", "uw . set (  \" long \"  ,    Long . MAX _ VALUE )  ;", "uw . array (  \" arr \"  )  ;", "uw . object (  )  . pop (  )  ;", "for    ( int   i    =     0  ;    i    <     5  0  0  0  0  ;    i +  +  )     {", "uw . value ( true )  . value ( false )  . value ( true )  ;", "uw . value (  (  ( byte )     (  2  5  4  )  )  )  ;", "uw . value (  (  ( byte )     (  -  2  )  )  )  ;", "uw . value (  (  ( short )     (  -  3  2  0  0  0  )  )  )  ;", "uw . value (  (  ( int )     (  -  1  2  3  4  5  6  )  )  )  ;", "uw . value (  (  ( long )     (  -  (  (  1     <  <     6  3  )     -     1  )  )  )  )  ;", "uw . value ( UBJsonTest . longString )  ;", "}", "uw . pop (  )  ;", "uw . pop (  )  ;", "uw . close (  )  ;", "app . log (  \" UBJsonTest \"  ,     (  (  \" Writing   the   test   file   took    \"     +     (  ( System . currentTimeMillis (  )  )     -    start )  )     +     \" ms \"  )  )  ;", "app . log (  \" UBJsonTest \"  ,     (  \" File   size   is    \"     +     ( files . external ( UBJsonTest . fn )  . length (  )  )  )  )  ;", "UBJsonReader   ur    =    new   UBJsonReader (  )  ;", "ur . oldFormat    =    false ;", "start    =    System . currentTimeMillis (  )  ;", "ur . parse ( files . external ( UBJsonTest . fn )  )  ;", "app . log (  \" UBJsonTest \"  ,     (  (  \" Parsing   the   test   file   took    \"     +     (  ( System . currentTimeMillis (  )  )     -    start )  )     +     \" ms \"  )  )  ;", "}", "METHOD_END"], "methodName": ["performanceTest"], "fileName": "com.badlogic.gdx.tests.UBJsonTest"}, {"methodBody": ["METHOD_START", "{", "float   width    =    MathUtils . random (  0  .  0  5 F ,     0  .  2 F )  ;", "float   height    =    MathUtils . random (  0  .  0  5 F ,     0  .  2 F )  ;", "float   x    =    MathUtils . random (  (  -  1  .  0 F )  ,     1  .  0 F )  ;", "float   y    =    MathUtils . random (  (  -  1  .  0 F )  ,     1  .  0 F )  ;", "float   r    =    MathUtils . random (  )  ;", "float   g    =    MathUtils . random (  )  ;", "float   b    =    MathUtils . random (  )  ;", "float   a    =    MathUtils . random (  )  ;", "vertArray [  ( currentIndex +  +  )  ]     =    x ;", "vertArray [  ( currentIndex +  +  )  ]     =    y ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    r ;", "vertArray [  ( currentIndex +  +  )  ]     =    g ;", "vertArray [  ( currentIndex +  +  )  ]     =    b ;", "vertArray [  ( currentIndex +  +  )  ]     =    a ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =     1  ;", "vertArray [  ( currentIndex +  +  )  ]     =    x    +    width ;", "vertArray [  ( currentIndex +  +  )  ]     =    y ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    r ;", "vertArray [  ( currentIndex +  +  )  ]     =    g ;", "vertArray [  ( currentIndex +  +  )  ]     =    b ;", "vertArray [  ( currentIndex +  +  )  ]     =    a ;", "vertArray [  ( currentIndex +  +  )  ]     =     1  ;", "vertArray [  ( currentIndex +  +  )  ]     =     1  ;", "vertArray [  ( currentIndex +  +  )  ]     =    x    +    width ;", "vertArray [  ( currentIndex +  +  )  ]     =    y    +    height ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    r ;", "vertArray [  ( currentIndex +  +  )  ]     =    g ;", "vertArray [  ( currentIndex +  +  )  ]     =    b ;", "vertArray [  ( currentIndex +  +  )  ]     =    a ;", "vertArray [  ( currentIndex +  +  )  ]     =     1  ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    x    +    width ;", "vertArray [  ( currentIndex +  +  )  ]     =    y    +    height ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    r ;", "vertArray [  ( currentIndex +  +  )  ]     =    g ;", "vertArray [  ( currentIndex +  +  )  ]     =    b ;", "vertArray [  ( currentIndex +  +  )  ]     =    a ;", "vertArray [  ( currentIndex +  +  )  ]     =     1  ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    x ;", "vertArray [  ( currentIndex +  +  )  ]     =    y    +    height ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    r ;", "vertArray [  ( currentIndex +  +  )  ]     =    g ;", "vertArray [  ( currentIndex +  +  )  ]     =    b ;", "vertArray [  ( currentIndex +  +  )  ]     =    a ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    x ;", "vertArray [  ( currentIndex +  +  )  ]     =    y ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =    r ;", "vertArray [  ( currentIndex +  +  )  ]     =    g ;", "vertArray [  ( currentIndex +  +  )  ]     =    b ;", "vertArray [  ( currentIndex +  +  )  ]     =    a ;", "vertArray [  ( currentIndex +  +  )  ]     =     0  ;", "vertArray [  ( currentIndex +  +  )  ]     =     1  ;", "}", "METHOD_END"], "methodName": ["addRandomSprite"], "fileName": "com.badlogic.gdx.tests.VBOWithVAOPerformanceTest"}, {"methodBody": ["METHOD_START", "{", "renderer . line ( x ,    y ,     ( x    +     ( v . x )  )  ,     ( y    +     ( v . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["renderVectorAt"], "fileName": "com.badlogic.gdx.tests.Vector2dTest"}, {"methodBody": ["METHOD_START", "{", "stage    =    new   Stage (  )  ;", "Skin   skin    =    new   Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "label    =    new   scenes . scene 2 d . ui . Label (  \"  \"  ,    skin )  ;", "Table   root    =    new   Table ( skin )  ;", "root . setFillParent ( true )  ;", "root . setBackground ( skin . getDrawable (  \" default - pane \"  )  )  ;", "root . debug (  )  . defaults (  )  . space (  6  )  ;", "root . add ( new   scenes . scene 2 d . ui . TextButton (  \" Button    1  \"  ,    skin )  )  ;", "root . add ( new   scenes . scene 2 d . ui . TextButton (  \" Button    2  \"  ,    skin )  )  . row (  )  ;", "root . add (  \" Press   spacebar   to   change   the   viewport :  \"  )  . colspan (  2  )  . row (  )  ;", "root . add ( label )  . colspan (  2  )  ;", "stage . addActor ( root )  ;", "viewports    =    ViewportTest 1  . getViewports ( stage . getCamera (  )  )  ;", "names    =    ViewportTest 1  . getViewportNames (  )  ;", "stage . setViewport ( viewports . first (  )  )  ;", "label . setText ( names . first (  )  )  ;", "input . setInputProcessor ( new   InputMultiplexer ( new   InputAdapter (  )     {", "public   boolean   keyDown ( int   keycode )     {", "if    ( keycode    =  =     ( Keys . SPACE )  )     {", "int   index    =     (  ( viewports . indexOf ( stage . getViewport (  )  ,    true )  )     +     1  )     %     ( viewports . size )  ;", "label . setText ( names . get ( index )  )  ;", "Viewport   viewport    =    viewports . get ( index )  ;", "stage . setViewport ( viewport )  ;", "resize ( graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "}", "return   false ;", "}", "}  ,    stage )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ViewportTest1"}, {"methodBody": ["METHOD_START", "{", "stage . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.ViewportTest1"}, {"methodBody": ["METHOD_START", "{", "Array < String >    names    =    new   Array (  )  ;", "names . add (  \" Stretch \"  )  ;", "names . add (  \" Fill \"  )  ;", "names . add (  \" Fit \"  )  ;", "names . add (  \" Extend :    no   max \"  )  ;", "names . add (  \" Extend :    max \"  )  ;", "names . add (  \" Screen :     1  :  1  \"  )  ;", "names . add (  \" Screen :     0  .  7  5  :  1  \"  )  ;", "names . add (  \" Scaling :    none \"  )  ;", "return   names ;", "}", "METHOD_END"], "methodName": ["getViewportNames"], "fileName": "com.badlogic.gdx.tests.ViewportTest1"}, {"methodBody": ["METHOD_START", "{", "int   minWorldWidth    =     6  4  0  ;", "int   minWorldHeight    =     4  8  0  ;", "int   maxWorldWidth    =     8  0  0  ;", "int   maxWorldHeight    =     4  8  0  ;", "Array < Viewport >    viewports    =    new   Array (  )  ;", "viewports . add ( new   utils . viewport . StretchViewport ( minWorldWidth ,    minWorldHeight ,    camera )  )  ;", "viewports . add ( new   utils . viewport . FillViewport ( minWorldWidth ,    minWorldHeight ,    camera )  )  ;", "viewports . add ( new   utils . viewport . FitViewport ( minWorldWidth ,    minWorldHeight ,    camera )  )  ;", "viewports . add ( new   utils . viewport . ExtendViewport ( minWorldWidth ,    minWorldHeight ,    camera )  )  ;", "viewports . add ( new   utils . viewport . ExtendViewport ( minWorldWidth ,    minWorldHeight ,    maxWorldWidth ,    maxWorldHeight ,    camera )  )  ;", "viewports . add ( new   ScreenViewport ( camera )  )  ;", "ScreenViewport   screenViewport    =    new   ScreenViewport ( camera )  ;", "screenViewport . setUnitsPerPixel (  0  .  7  5 F )  ;", "viewports . add ( screenViewport )  ;", "viewports . add ( new   utils . viewport . ScalingViewport ( Scaling . none ,    minWorldWidth ,    minWorldHeight ,    camera )  )  ;", "return   viewports ;", "}", "METHOD_END"], "methodName": ["getViewports"], "fileName": "com.badlogic.gdx.tests.ViewportTest1"}, {"methodBody": ["METHOD_START", "{", "stage . act (  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "stage . draw (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ViewportTest1"}, {"methodBody": ["METHOD_START", "{", "stage . getViewport (  )  . update ( width ,    height ,    true )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.ViewportTest1"}, {"methodBody": ["METHOD_START", "{", "font    =    new   BitmapFont (  )  ;", "font . setColor (  0  ,     0  ,     0  ,     1  )  ;", "Pixmap   pixmap    =    new   Pixmap (  1  6  ,     1  6  ,    Format . RGBA 8  8  8  8  )  ;", "pixmap . setColor (  1  ,     1  ,     1  ,     1  )  ;", "pixmap . fill (  )  ;", "texture    =    new   graphics . Texture ( pixmap )  ;", "batch    =    new   SpriteBatch (  )  ;", "camera    =    new   OrthographicCamera (  )  ;", "camera . position . set (  1  0  0  ,     1  0  0  ,     0  )  ;", "camera . update (  )  ;", "viewports    =    ViewportTest 1  . getViewports ( camera )  ;", "viewport    =    viewports . first (  )  ;", "names    =    ViewportTest 1  . getViewportNames (  )  ;", "name    =    names . first (  )  ;", "input . setInputProcessor ( new   InputAdapter (  )     {", "public   boolean   keyDown ( int   keycode )     {", "if    ( keycode    =  =     ( Keys . SPACE )  )     {", "int   index    =     (  ( viewports . indexOf ( viewport ,    true )  )     +     1  )     %     ( viewports . size )  ;", "name    =    names . get ( index )  ;", "viewport    =    viewports . get ( index )  ;", "resize ( graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "}", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ViewportTest2"}, {"methodBody": ["METHOD_START", "{", "texture . dispose (  )  ;", "batch . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tests.ViewportTest2"}, {"methodBody": ["METHOD_START", "{", "batch . setProjectionMatrix ( camera . projection )  ;", "batch . setTransformMatrix ( camera . view )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "batch . setColor (  1  ,     1  ,     1  ,     1  )  ;", "batch . draw ( texture ,     (  -  4  0  9  6  )  ,     (  -  4  0  9  6  )  ,     4  0  9  6  ,     4  0  9  6  ,     8  1  9  2  ,     8  1  9  2  ,     1  ,     1  ,     0  ,     0  ,     0  ,     1  6  ,     1  6  ,    false ,    false )  ;", "batch . setColor (  1  ,     0  ,     0  ,     1  )  ;", "batch . draw ( texture ,     1  5  0  ,     1  0  0  ,     1  6  ,     1  6  ,     3  2  ,     3  2  ,     1  ,     1  ,     4  5  ,     0  ,     0  ,     1  6  ,     1  6  ,    false ,    false )  ;", "font . draw ( batch ,    viewport . getClass (  )  . getSimpleName (  )  ,     1  5  0  ,     1  0  0  )  ;", "batch . end (  )  ;", "if    (  ( viewport )    instanceof   Scaling )     {", "Scaling   scaling    =     (  ( Scaling )     ( viewport )  )  ;", "int   screenWidth    =    graphics . getWidth (  )  ;", "int   screenHeight    =    graphics . getHeight (  )  ;", "HdpiUtils . gl (  0  ,     0  ,    screenWidth ,    screenHeight )  ;", "batch . getProjectionMatrix (  )  . idt (  )  . setToOrtho 2 D (  0  ,     0  ,    screenWidth ,    screenHeight )  ;", "batch . getTransformMatrix (  )  . idt (  )  ;", "batch . begin (  )  ;", "float   leftGutterWidth    =    scaling . getLeftGutterWidth (  )  ;", "if    ( leftGutterWidth    >     0  )     {", "batch . draw ( texture ,     0  ,     0  ,    leftGutterWidth ,    screenHeight )  ;", "batch . draw ( texture ,    scaling . getRightGutterX (  )  ,     0  ,    scaling . getRightGutterWidth (  )  ,    screenHeight )  ;", "}", "float   bottomGutterHeight    =    scaling . getBottomGutterHeight (  )  ;", "if    ( bottomGutterHeight    >     0  )     {", "batch . draw ( texture ,     0  ,     0  ,    screenWidth ,    bottomGutterHeight )  ;", "batch . draw ( texture ,     0  ,    scaling . getTopGutterY (  )  ,    screenWidth ,    scaling . getTopGutterHeight (  )  )  ;", "}", "batch . end (  )  ;", "viewport . update ( screenWidth ,    screenHeight ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ViewportTest2"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( name )  ;", "v . update ( width ,    height )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.ViewportTest2"}, {"methodBody": ["METHOD_START", "{", "modelBatch    =    new   ModelBatch (  )  ;", "modelBuilder    =    new   ModelBuilder (  )  ;", "environment    =    new   Environment (  )  ;", "environment . set ( new   ColorAttribute ( ColorAttribute . AmbientLight ,     0  .  3 F ,     0  .  3 F ,     0  .  3 F ,     1  .  0 F )  )  ;", "shadowLight    =    new   DirectionalLight (  )  ;", "shadowLight . set (  0  .  8 F ,     0  .  8 F ,     0  .  8 F ,     (  -  0  .  5 F )  ,     (  -  1  .  0 F )  ,     0  .  7 F )  ;", "environment . add ( shadowLight )  ;", "modelBatch    =    new   ModelBatch (  )  ;", "camera    =    new   PerspectiveCamera (  )  ;", "camera . fieldOfView    =     6  7  ;", "camera . near    =     0  .  1 F ;", "camera . far    =     3  0  0  .  0 F ;", "camera . position . set (  0  ,     0  ,     1  0  0  )  ;", "camera . lookAt (  0  ,     0  ,     0  )  ;", "viewports    =    ViewportTest 1  . getViewports ( camera )  ;", "viewport    =    viewports . first (  )  ;", "names    =    ViewportTest 1  . getViewportNames (  )  ;", "name    =    names . first (  )  ;", "ModelBuilder   modelBuilder    =    new   ModelBuilder (  )  ;", "Model   boxModel    =    modelBuilder . createBox (  5  0  .  0 F ,     5  0  .  0 F ,     5  0  .  0 F ,    new   graphics . g 3 d . Material ( ColorAttribute . createDiffuse ( GREEN )  )  ,     (  ( Usage . Position )     |     ( Usage . Normal )  )  )  ;", "boxInstance    =    new   ModelInstance ( boxModel )  ;", "boxInstance . transform . rotate (  1  ,     0  ,     0  ,     3  0  )  ;", "boxInstance . transform . rotate (  0  ,     1  ,     0  ,     3  0  )  ;", "input . setInputProcessor ( new   InputAdapter (  )     {", "public   boolean   keyDown ( int   keycode )     {", "if    ( keycode    =  =     ( Keys . SPACE )  )     {", "int   index    =     (  ( viewports . indexOf ( viewport ,    true )  )     +     1  )     %     ( viewports . size )  ;", "name    =    names . get ( index )  ;", "viewport    =    viewports . get ( index )  ;", "resize ( graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "}", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.ViewportTest3"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  ,     0  ,     0  ,     1  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "modelBatch . begin ( camera )  ;", "modelBatch . render ( boxInstance ,    environment )  ;", "modelBatch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.ViewportTest3"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( name )  ;", "v . update ( width ,    height )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.ViewportTest3"}, {"methodBody": ["METHOD_START", "{", "FreeTypeFontLoaderParameter   param    =    new   FreeTypeFontLoaderParameter (  )  ;", "param . fontFileName    =    fontName ;", "param . fontParameters . size    =     1  2  ;", "param . fontParameters . genMipMaps    =    true ;", "param . fontParameters . minFilter    =    TextureFilter . MipMapLinearLinear ;", "param . fontParameters . magFilter    =    TextureFilter . Linear ;", "assetManager . load (  (  (  ( fontName    +     \" size \"  )     +    size )     +     \"  . ttf \"  )  ,    BitmapFont . class ,    param )  ;", "}", "METHOD_END"], "methodName": ["loadFont"], "fileName": "com.badlogic.gdx.tests.android.APKExpansionTest"}, {"methodBody": ["METHOD_START", "{", "super . onListItemClick ( listView ,    view ,    position ,    id )  ;", "Editor   editor    =    prefs . edit (  )  ;", "editor . putInt (  \" index \"  ,    listView . getFirstVisiblePosition (  )  )  ;", "editor . putInt (  \" top \"  ,     (  ( listView . getChildAt (  0  )  )     =  =    null    ?     0     :    listView . getChildAt (  0  )  . getTop (  )  )  )  ;", "editor . commit (  )  ;", "Object   o    =    this . getListAdapter (  )  . getItem ( position )  ;", "String   Name    =    o . toString (  )  ;", "Bundle   bundle    =    new   Bundle (  )  ;", "bundle . putString (  \"  \"  ,    Name )  ;", "Intent   intent    =    new   Intent ( this ,    GdxTestActivity . class )  ;", "intent . putExtras ( bundle )  ;", "startActivity ( intent )  ;", "}", "METHOD_END"], "methodName": ["onListItemClick"], "fileName": "com.badlogic.gdx.tests.android.AndroidTestStarter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( view )     !  =    null )     {", "getSupportFragmentManager (  )  . beginTransaction (  )  . replace ( viewlayout ,     . TestViewFragment . newInstance ( testName )  )  . commit (  )  ;", "} else    {", "startActivity ( new   Intent ( this ,    GdxTestActivity . class )  . putExtra (  \" test \"  ,    testName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["onTestSelected"], "fileName": "com.badlogic.gdx.tests.android.FragmentTestStarter"}, {"methodBody": ["METHOD_START", "{", "super . onCreate ( bundle )  ;", "Bundle   extras    =    getIntent (  )  . getExtras (  )  ;", "String   testName    =     (  ( String )     ( extras . get (  \" test \"  )  )  )  ;", "test    =    s . newTest ( testName )  ;", "AndroidApplicationConfiguration   config    =    new   AndroidApplicationConfiguration (  )  ;", "config . useImmersiveMode    =    true ;", "config . useRotationVectorSensor    =    true ;", "initialize ( test ,    config )  ;", "}", "METHOD_END"], "methodName": ["onCreate"], "fileName": "com.badlogic.gdx.tests.android.GdxTestActivity"}, {"methodBody": ["METHOD_START", "{", "super . onCreate ( bundle )  ;", "tv    =    new   TextView ( this )  ;", "sv    =    new   ScrollView ( this )  ;", "sv . addView ( tv )  ;", "setContentView ( sv )  ;", "Thread . start (  )  ;", "}", "METHOD_END"], "methodName": ["onCreate"], "fileName": "com.badlogic.gdx.tests.android.MicroBenchmarks"}, {"methodBody": ["METHOD_START", "{", "start    =    System . nanoTime (  )  ;", "}", "METHOD_END"], "methodName": ["tic"], "fileName": "com.badlogic.gdx.tests.android.MicroBenchmarks"}, {"methodBody": ["METHOD_START", "{", "final   float   time    =     (  ( System . nanoTime (  )  )     -     ( start )  )     /     1  .  0 E 9 F ;", "tv . post ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "StringBuilder   buff    =    new   StringBuilder ( tv . getText (  )  )  ;", "buff . append ( info )  . append (  \"  ,     \"  )  . append ( time )  . append (  \"    secs \\ n \"  )  ;", "tv . setText ( buff . toString (  )  )  ;", "}", "}  )  ;", "Log . d (  \"  \"  ,     (  ( info    +     \"  ,     \"  )     +    time )  )  ;", "}", "METHOD_END"], "methodName": ["toc"], "fileName": "com.badlogic.gdx.tests.android.MicroBenchmarks"}, {"methodBody": ["METHOD_START", "{", "super . onCreate ( bundle )  ;", "Button   b 1     =    new   Button ( this )  ;", "b 1  . setText (  \" Change   Color \"  )  ;", "b 1  . setLayoutParams ( new   LinearLayout . LayoutParams ( LayoutParams . FILL _ PARENT ,    LayoutParams . WRAP _ CONTENT )  )  ;", "Button   b 2     =    new   Button ( this )  ;", "b 2  . setText (  \" New   Window \"  )  ;", "b 2  . setLayoutParams ( new   LinearLayout . LayoutParams ( LayoutParams . FILL _ PARENT ,    LayoutParams . WRAP _ CONTENT )  )  ;", "View   view    =    initializeForView ( this )  ;", "LinearLayout   layout    =    new   LinearLayout ( this )  ;", "layout . setOrientation ( VERTICAL )  ;", "layout . addView ( b 1  )  ;", "layout . addView ( b 2  )  ;", "layout . addView ( view ,    new   LinearLayout . LayoutParams ( LayoutParams . FILL _ PARENT ,    LayoutParams . FILL _ PARENT )  )  ;", "setContentView ( layout )  ;", "b 1  . setOnClickListener ( new   OnClickListener (  )     {", "@ Override", "public   void   onClick ( View   arg 0  )     {", "color . set (  (  ( float )     ( Math . random (  )  )  )  ,     (  ( float )     ( Math . random (  )  )  )  ,     (  ( float )     ( Math . random (  )  )  )  ,     1  )  ;", "}", "}  )  ;", "b 2  . setOnClickListener ( new   OnClickListener (  )     {", "@ Override", "public   void   onClick ( View   v )     {", "Intent   intent    =    new   Intent (  . this ,     . class )  ;", ". this . startActivity ( intent )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["onCreate"], "fileName": "com.badlogic.gdx.tests.android.WindowedTest"}, {"methodBody": ["METHOD_START", "{", "super . onPause (  )  ;", "}", "METHOD_END"], "methodName": ["onPause"], "fileName": "com.badlogic.gdx.tests.android.WindowedTest"}, {"methodBody": ["METHOD_START", "{", "if    ( keyCode    =  =     ( Keys . W )  )     {", "Vector 2    f    =    m _ body . getWorldVector ( tmp . set (  0  ,     (  -  2  0  0  )  )  )  ;", "Vector 2    p    =    m _ body . getWorldPoint ( tmp . set (  0  ,     2  )  )  ;", "m _ body . a ( f ,    p ,    true )  ;", "}", "if    ( keyCode    =  =     ( Keys . A )  )", "m _ body . applyTorque (  5  0  ,    true )  ;", "if    ( keyCode    =  =     ( Keys . D )  )", "m _ body . applyTorque (  (  -  5  0  )  ,    true )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyDown"], "fileName": "com.badlogic.gdx.tests.box2d.ApplyForce"}, {"methodBody": ["METHOD_START", "{", "try    {", "Field   addrField    =    c . getClass (  )  . getDeclaredField (  \" addr \"  )  ;", "addrField . setAccessible ( true )  ;", "return   addrField . getLong ( c )  ;", "}    catch    ( Exception   e )     {", "e . printStackTrace (  )  ;", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getContactAddr"], "fileName": "com.badlogic.gdx.tests.box2d.ContactListenerTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "long   addr    =    getAddr ( contact )  ;", "Method   getFixtureA    =    contact . getClass (  )  . getDeclaredMethod (  \" jniGetFixtureA \"  ,    long . class )  ;", "getFixtureA . setAccessible ( true )  ;", "return    (  ( Long )     ( getFixtureA . invoke ( contact ,    addr )  )  )  ;", "}    catch    ( Exception   e )     {", "e . printStackTrace (  )  ;", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getFixtureAddrA"], "fileName": "com.badlogic.gdx.tests.box2d.ContactListenerTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "long   addr    =    getAddr ( contact )  ;", "Method   getFixtureB    =    contact . getClass (  )  . getDeclaredMethod (  \" jniGetFixtureB \"  ,    long . class )  ;", "getFixtureB . setAccessible ( true )  ;", "return    (  ( Long )     ( getFixtureB . invoke ( contact ,    addr )  )  )  ;", "}    catch    ( Exception   e )     {", "e . printStackTrace (  )  ;", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getFixtureAddrB"], "fileName": "com.badlogic.gdx.tests.box2d.ContactListenerTest"}, {"methodBody": ["METHOD_START", "{", "m _ body . setTransform ( new   Vector 2  (  0  ,     2  0  )  ,     0  )  ;", "m _ angularVelocity    =     (  (  ( float )     ( Math . random (  )  )  )     *     1  0  0  )     -     5  0  ;", "m _ body . setLinearVelocity ( new   Vector 2  (  0  ,     (  -  1  0  0  )  )  )  ;", "m _ body . setAngularVelocity ( m _ angularVelocity )  ;", "}", "METHOD_END"], "methodName": ["launch"], "fileName": "com.badlogic.gdx.tests.box2d.ContinuousTest"}, {"methodBody": ["METHOD_START", "{", "super . render (  )  ;", "( m _ epCount )  +  +  ;", "if    (  (  ( m _ epCount )     %     6  0  )     =  =     0  )", "launch (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.box2d.ContinuousTest"}, {"methodBody": ["METHOD_START", "{", "Fixture   fixtureA    =    contact . getFixtureA (  )  ;", "Fixture   fixtureB    =    contact . getFixtureB (  )  ;", "if    (  ( fixtureA    =  =     ( m _ platform )  )     |  |     ( fixtureB    =  =     ( m _ platform )  )  )     {", "contact . setTangentSpeed (  5  .  0 F )  ;", "}", "}", "METHOD_END"], "methodName": ["preSolve"], "fileName": "com.badlogic.gdx.tests.box2d.ConveyorBelt"}, {"methodBody": ["METHOD_START", "{", "if    ( keyCode    =  =     ( Keys . L )  )", "m _ joint . enableLimit (  (  !  ( m _ joint . isLimitEnabled (  )  )  )  )  ;", "if    ( keyCode    =  =     ( Keys . M )  )", "m _ joint . enableMotor (  (  !  ( m _ joint . isMotorEnabled (  )  )  )  )  ;", "if    ( keyCode    =  =     ( Keys . S )  )", "m _ joint . setMotorSpeed (  (  -  ( m _ joint . getMotorSpeed (  )  )  )  )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyDown"], "fileName": "com.badlogic.gdx.tests.box2d.Prismatic"}, {"methodBody": ["METHOD_START", "{", "super . render (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.box2d.Prismatic"}, {"methodBody": ["METHOD_START", "{", "super . render (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.box2d.VerticalStack"}, {"methodBody": ["METHOD_START", "{", "gl . glViewport (  0  ,     0  ,    graphics . getBackBufferWidth (  )  ,    graphics . getBackBufferHeight (  )  )  ;", "gl . glClearColor (  0  ,     0  ,     0  ,     0  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "camera . update (  )  ;", "}", "METHOD_END"], "methodName": ["beginRender"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "return   new   BulletWorld (  )  ;", "}", "METHOD_END"], "methodName": ["createWorld"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "if    ( BaseBulletTest . initialized )", "return ;", "if    (  (  ( app . getType (  )  )     =  =     ( ApplicationType . Desktop )  )     &  &     (  ( BaseBulletTest . customDesktopLib )     !  =    null )  )     {", "System . load ( BaseBulletTest . customDesktopLib )  ;", "} else", "physics . bullet . Bullet . init (  )  ;", "app . log (  \" Bullet \"  ,     (  \" Version    =     \"     +     ( LinearMath . btGetVersion (  )  )  )  )  ;", "BaseBulletTest . initialized    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "fpsCounter . put ( graphics . getFramesPerSecond (  )  )  ;", "if    ( update )", "update (  )  ;", "beginRender ( true )  ;", "renderWorld (  )  ;", "gl . glDisable ( GL _ DEPTH _ TEST )  ;", "if    (  ( debugMode )     !  =     ( DebugDrawModes . DBG _ NoDebug )  )", "world . setDebugMode ( debugMode )  ;", "gl . glEnable ( GL _ DEPTH _ TEST )  ;", "performance . setLength (  0  )  ;", "performance . append (  \" FPS :     \"  )  . append ( fpsCounter . value )  . append (  \"  ,     :     \"  )  . append (  (  ( int )     (  ( performanceCounter . load . value )     *     1  0  0  .  0 F )  )  )  . append (  \"  %  \"  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "if    ( BaseBulletTest . shadows )     {", "(  ( DirectionalShadowLight )     ( light )  )  . begin ( Zero ,    camera . direction )  ;", "shadowBatch . begin (  (  ( DirectionalShadowLight )     ( light )  )  . getCamera (  )  )  ;", "world . render ( shadowBatch ,    null )  ;", "shadowBatch . end (  )  ;", "(  ( DirectionalShadowLight )     ( light )  )  . end (  )  ;", "}", "modelBatch . begin ( camera )  ;", "world . render ( modelBatch ,    environment )  ;", "modelBatch . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderWorld"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "world . setDebugMode (  ( debugMode    =    mode )  )  ;", "}", "METHOD_END"], "methodName": ["setDebugMode"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "return   shoot ( x ,    y ,     3  0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["shoot"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "return   shoot (  \" box \"  ,    x ,    y ,    impulse )  ;", "}", "METHOD_END"], "methodName": ["shoot"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "Ray   ray    =    camera . getPickRay ( x ,    y )  ;", "Entity   entity    =    world . add ( what ,    ray . origin . x ,    ray . origin . y ,    ray . origin . z )  ;", "entity . setColor (  (  0  .  5 F    +     (  0  .  5 F    *     (  ( float )     ( Math . random (  )  )  )  )  )  ,     (  0  .  5 F    +     (  0  .  5 F    *     (  ( float )     ( Math . random (  )  )  )  )  )  ,     (  0  .  5 F    +     (  0  .  5 F    *     (  ( float )     ( Math . random (  )  )  )  )  )  ,     1  .  0 F )  ;", "(  ( btRigidBody )     ( entity . body )  )  . applyCentralImpulse ( ray . direction . scl ( impulse )  )  ;", "return   entity ;", "}", "METHOD_END"], "methodName": ["shoot"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( world . getDebugMode (  )  )     =  =     ( DebugDrawModes . DBG _ NoDebug )  )", "setDebugMode (  (  (  (  ( DebugDrawModes . DBG _ DrawWireframe )     |     ( DebugDrawModes . DBG _ DrawFeaturesText )  )     |     ( DebugDrawModes . DBG _ DrawText )  )     |     ( DebugDrawModes . DBG _ DrawContactPoints )  )  )  ;", "else", "if    ( world . renderMeshes )", "world . renderMeshes    =    false ;", "else    {", "world . renderMeshes    =    true ;", "setDebugMode ( DebugDrawModes . DBG _ NoDebug )  ;", "}", "}", "METHOD_END"], "methodName": ["toggleDebugMode"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "world . update (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.tests.bullet.BaseBulletTest"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.tests.bullet.BaseEntity"}, {"methodBody": ["METHOD_START", "{", "setColor ( color . r ,    color . g ,    color . b ,    color . a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tests.bullet.BaseEntity"}, {"methodBody": ["METHOD_START", "{", "color . set ( r ,    g ,    b ,    a )  ;", "if    (  ( modelInstance )     !  =    n )     {", "for    ( Material   m    :    modelInstance . materials )     {", "ColorAttribute   ca    =     (  ( ColorAttribute )     ( m . get ( Diffuse )  )  )  ;", "if    ( ca    !  =    n )", "ca . color . set ( r ,    g ,    b ,    a )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tests.bullet.BaseEntity"}, {"methodBody": ["METHOD_START", "{", "entities . add ( entity )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "final   T   entity    =    constructors . get ( type )  . construct ( transform )  ;", "add ( entity )  ;", "return   entity ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "final   T   entity    =    constructors . get ( type )  . construct ( x ,    y ,    z )  ;", "add ( entity )  ;", "return   entity ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "constructors . put ( name ,    constructor )  ;", "if    (  (  ( constructor . model )     !  =    n )     &  &     (  !  ( models . contains ( constructor . model ,    true )  )  )  )", "models . add ( constructor . model )  ;", "}", "METHOD_END"], "methodName": ["addConstructor"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "return   constructors . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "render ( batch ,    lights ,    entities )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "batch . render ( entity . modelInstance ,    lights )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "for    ( final   T   e    :    entities )     {", "batch . render ( e . modelInstance ,    lights )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.bullet.BaseWorld"}, {"methodBody": ["METHOD_START", "{", "this . model    =    model ;", "this . shape    =    shape ;", "if    (  ( shape    !  =    null )     &  &     ( mass    >  =     0  )  )     {", "Vector 3    localInertia ;", "if    ( mass    =  =     0  )", "localInertia    =    Vector 3  . Zero ;", "else    {", "shape . calculateLocalInertia ( mass ,     . tmpV )  ;", "localInertia    =     . tmpV ;", "}", "bodyInfo    =    new   com . badlogic . gdx . physics . bullet . dynamics . btRigidBody . btRigidBodyConstructionInfo ( mass ,    null ,    shape ,    localInertia )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.bullet.BulletConstructor"}, {"methodBody": ["METHOD_START", "{", "create ( model ,    mass ,    new   com . badlogic . gdx . physics . bullet . collision . btBoxShape ( BulletConstructor . tmpV . set (  ( width    *     0  .  5 F )  ,     ( height    *     0  .  5 F )  ,     ( depth    *     0  .  5 F )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.bullet.BulletConstructor"}, {"methodBody": ["METHOD_START", "{", "return    ( debugDrawer )     =  =    null    ?     0     :    debugDrawer . getDebugMode (  )  ;", "}", "METHOD_END"], "methodName": ["getDebugMode"], "fileName": "com.badlogic.gdx.tests.bullet.BulletWorld"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mode    =  =     ( DebugDrawModes . DBG _ NoDebug )  )     &  &     (  ( debugDrawer )     =  =    null )  )", "return ;", "if    (  ( debugDrawer )     =  =    null )", "collisionWorld . setDebugDrawer (  ( debugDrawer    =    new   physics . bullet . DebugDrawer (  )  )  )  ;", "debugDrawer . setDebugMode ( mode )  ;", "}", "METHOD_END"], "methodName": ["setDebugMode"], "fileName": "com.badlogic.gdx.tests.bullet.BulletWorld"}, {"methodBody": ["METHOD_START", "{", "Color   color    =    null ;", "update (  )  ;", "hits . clear (  )  ;", "contacts . clear (  )  ;", "if    (  ( projectile )     !  =    null )     {", "color    =    projectile . getColor (  )  ;", "projectile . setColor ( RED )  ;", "world . cWorld . contactTest ( projectile . body ,    contactCB )  ;", "}", "updateContactInfo (  )  ;", "if    (  ( hits . size )     >     0  )     {", "for    ( int   i    =     0  ;    i    <     ( hits . size )  ;    i +  +  )     {", "colors . add ( colorPool . obtain (  )  . set ( hits . get ( i )  . getColor (  )  )  )  ;", "hits . get ( i )  . setColor ( RED )  ;", "}", "}", "if    (  ( contacts . size )     >     0  )     {", "for    ( int   i    =     0  ;    i    <     ( contacts . size )  ;    i +  +  )     {", "colors . add ( colorPool . obtain (  )  . set ( contacts . get ( i )  . getColor (  )  )  )  ;", "contacts . get ( i )  . setColor ( BLUE )  ;", "}", "}", "render ( false )  ;", "if    (  ( projectile )     !  =    null )", "projectile . setColor ( color )  ;", "for    ( int   i    =     0  ;    i    <     ( hits . size )  ;    i +  +  )", "hits . get ( i )  . setColor ( colors . get ( i )  )  ;", "for    ( int   i    =     0  ;    i    <     ( contacts . size )  ;    i +  +  )", "contacts . get ( i )  . setColor ( colors . get (  (  ( hits . size )     +    i )  )  )  ;", "colorPool . freeAll ( colors )  ;", "colors . clear (  )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tests.bullet.CollisionTest"}, {"methodBody": ["METHOD_START", "{", "int   n    =    world . dispatcher . getNumManifolds (  )  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "btPersistentManifold   manifold    =    world . dispatcher . getManifoldByIndexInternal ( i )  ;", "btObject   objA    =    manifold . getBody 0  (  )  ;", "btObject   objB    =    manifold . getBody 1  (  )  ;", "if    (  ( objA    !  =     ( ground . body )  )     &  &     ( objB    !  =     ( ground . body )  )  )     {", "if    (  (  ( objA . userData )     !  =    null )     &  &     (  ( objA . userData )    instanceof   BulletEntity )  )     {", "BulletEntity   ent    =     (  ( BulletEntity )     ( objA . userData )  )  ;", "if    (  (  ( ent    !  =     ( projectile )  )     &  &     (  !  ( contacts . contains ( ent ,    true )  )  )  )     &  &     (  !  ( hits . contains ( ent ,    true )  )  )  )", "contacts . add ( ent )  ;", "}", "if    (  (  ( objB . userData )     !  =    null )     &  &     (  ( objB . userData )    instanceof   BulletEntity )  )     {", "BulletEntity   ent    =     (  ( BulletEntity )     ( objB . userData )  )  ;", "if    (  (  ( ent    !  =     ( projectile )  )     &  &     (  !  ( contacts . contains ( ent ,    true )  )  )  )     &  &     (  !  ( hits . contains ( ent ,    true )  )  )  )", "contacts . add ( ent )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["updateContactInfo"], "fileName": "com.badlogic.gdx.tests.bullet.CollisionTest"}, {"methodBody": ["METHOD_START", "{", "final   Mesh   mesh    =    model . meshes . get (  0  )  ;", "final   btShape   shape    =    new   btShape ( mesh . getVerticesBuffer (  )  ,    mesh . getNumVertices (  )  ,    mesh . getVertexSize (  )  )  ;", "if    (  ! optimize )", "return   shape ;", "final   btShapeHull   hull    =    new   btShapeHull ( shape )  ;", "hull . buildHull ( shape . getMargin (  )  )  ;", "final   btShape   result    =    new   btShape ( hull )  ;", "shape . dispose (  )  ;", "hull . dispose (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createConvexHullShape"], "fileName": "com.badlogic.gdx.tests.bullet.ConvexHullDistanceTest"}, {"methodBody": ["METHOD_START", "{", "final   Mesh   mesh    =    model . meshes . get (  0  )  ;", "final   btShape   shape    =    new   btShape ( mesh . getVerticesBuffer (  )  ,    mesh . getNumVertices (  )  ,    mesh . getVertexSize (  )  )  ;", "if    (  ! optimize )", "return   shape ;", "final   btShapeHull   hull    =    new   btShapeHull ( shape )  ;", "hull . buildHull ( shape . getMargin (  )  )  ;", "final   btShape   result    =    new   btShape ( hull )  ;", "shape . dispose (  )  ;", "hull . dispose (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createConvexHullShape"], "fileName": "com.badlogic.gdx.tests.bullet.ConvexHullTest"}, {"methodBody": ["METHOD_START", "{", "ModelBuilder   builder    =    new   ModelBuilder (  )  ;", "builder . begin (  )  ;", "MeshPartBuilder   mpb    =    builder . part (  \"  \"  ,    GL _ LINES ,     (  ( Usage . Position )     |     ( Usage . Normal )  )  ,    new   Material ( new   ColorAttribute ( ColorAttribute . Diffuse ,    Color . WHITE )  )  )  ;", "mpb . vertex ( p [  0  ]  . x ,    p [  0  ]  . y ,    p [  0  ]  . z ,     0  ,     0  ,     1  ,    p [  1  ]  . x ,    p [  1  ]  . y ,    p [  1  ]  . z ,     0  ,     0  ,     1  ,    p [  2  ]  . x ,    p [  2  ]  . y ,    p [  2  ]  . z ,     0  ,     0  ,     1  ,    p [  3  ]  . x ,    p [  3  ]  . y ,    p [  3  ]  . z ,     0  ,     0  ,     1  ,    p [  4  ]  . x ,    p [  4  ]  . y ,    p [  4  ]  . z ,     0  ,     0  ,     (  -  1  )  ,    p [  5  ]  . x ,    p [  5  ]  . y ,    p [  5  ]  . z ,     0  ,     0  ,     (  -  1  )  ,    p [  6  ]  . x ,    p [  6  ]  . y ,    p [  6  ]  . z ,     0  ,     0  ,     (  -  1  )  ,    p [  7  ]  . x ,    p [  7  ]  . y ,    p [  7  ]  . z ,     0  ,     0  ,     (  -  1  )  )  ;", "mpb . index (  (  ( short )     (  0  )  )  ,     (  ( short )     (  1  )  )  ,     (  ( short )     (  1  )  )  ,     (  ( short )     (  2  )  )  ,     (  ( short )     (  2  )  )  ,     (  ( short )     (  3  )  )  ,     (  ( short )     (  3  )  )  ,     (  ( short )     (  0  )  )  )  ;", "mpb . index (  (  ( short )     (  4  )  )  ,     (  ( short )     (  5  )  )  ,     (  ( short )     (  5  )  )  ,     (  ( short )     (  6  )  )  ,     (  ( short )     (  6  )  )  ,     (  ( short )     (  7  )  )  ,     (  ( short )     (  7  )  )  ,     (  ( short )     (  4  )  )  )  ;", "mpb . index (  (  ( short )     (  0  )  )  ,     (  ( short )     (  4  )  )  ,     (  ( short )     (  1  )  )  ,     (  ( short )     (  5  )  )  ,     (  ( short )     (  2  )  )  ,     (  ( short )     (  6  )  )  ,     (  ( short )     (  3  )  )  ,     (  ( short )     (  7  )  )  )  ;", "return   builder . end (  )  ;", "}", "METHOD_END"], "methodName": ["createFrustumModel"], "fileName": "com.badlogic.gdx.tests.bullet.FrustumCullingTest"}, {"methodBody": ["METHOD_START", "{", "final   btPairCachingGhostObject   result    =    new   FrustumCullingTest . TestPairCachingGhostObject (  )  ;", "final   boolean   USE _ COMPOUND    =    true ;", "if    ( USE _ COMPOUND )     {", "final   Vector 3    centerNear    =    new   Vector 3  ( points [  2  ]  )  . sub ( points [  0  ]  )  . scl (  0  .  5 F )  . add ( points [  0  ]  )  ;", "final   Vector 3    centerFar    =    new   Vector 3  ( points [  6  ]  )  . sub ( points [  4  ]  )  . scl (  0  .  5 F )  . add ( points [  4  ]  )  ;", "final   Vector 3    center    =    new   Vector 3  ( centerFar )  . sub ( centerNear )  . scl (  0  .  5 F )  . add ( centerNear )  ;", "final   btConvexHullShape   hullShape    =    new   btConvexHullShape (  )  ;", "for    ( int   i    =     0  ;    i    <     ( points . length )  ;    i +  +  )", "hullShape . addPoint ( FrustumCullingTest . tmpV . set ( points [ i ]  )  . sub ( center )  )  ;", "final   btCompoundShape   shape    =    new   btCompoundShape (  )  ;", "shape . addChildShape ( FrustumCullingTest . tmpM . setToTranslation ( center )  ,    hullShape )  ;", "result . setCollisionShape ( shape )  ;", "} else    {", "final   btConvexHullShape   shape    =    new   btConvexHullShape (  )  ;", "for    ( int   i    =     0  ;    i    <     ( points . length )  ;    i +  +  )", "shape . addPoint ( points [ i ]  )  ;", "result . setCollisionShape ( shape )  ;", "}", "result . setCollisionFlags ( CF _ NO _ CONTACT _ RESPONSE )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createFrustumObject"], "fileName": "com.badlogic.gdx.tests.bullet.FrustumCullingTest"}, {"methodBody": ["METHOD_START", "{", "btBroadphasePairArray   arr    =    world . broadphase . getOverlappingPairCache (  )  . getOverlappingPairArray (  )  ;", "final   int   n    =    arr . getCollisionObjectsValue (  . ptrs ,    object )  ;", "out . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "out . add ( world . entities . get (  . ptrs [ i ]  )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getEntitiesCollidingWithObject"], "fileName": "com.badlogic.gdx.tests.bullet.FrustumCullingTest"}, {"methodBody": ["METHOD_START", "{", "buffer . clear (  )  ;", "while    (  ( buffer . position (  )  )     <     ( buffer . capacity (  )  )  )", "buffer . put (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "int   numVerts    =    verticesIn . length ;", "int   numVertsBehind    =     0  ;", "float [  ]    s    =    new   float [  4  ]  ;", "for    ( int   i    =     0  ;    i    <    numVerts ;    i +  +  )     {", "s [ i ]     =     ( verticesIn [ i ]  . z )     +     ( verticesIn [ i ]  . w )  ;", "if    (  ( s [ i ]  )     <     0  )", "numVertsBehind +  +  ;", "}", "if    ( numVertsBehind    =  =    numVerts )     {", "return    0  ;", "} else", "if    ( numVertsBehind    >     0  )     {", "int   newNumVerts    =     0  ;", "for    ( int   i    =    numVerts    -     1  ,    j    =     0  ;    j    <    numVerts ;    i    =    j +  +  )     {", ". Quaternion   a    =    tmpQ 1  . set ( verticesIn [ i ]  )  ;", ". Quaternion   b    =    tmpQ 2  . set ( verticesIn [ j ]  )  ;", "float   t    =     ( s [ i ]  )     /     (  (  (  ( a . w )     +     ( a . z )  )     -     ( b . w )  )     -     ( b . z )  )  ;", "if    (  ( t    >     0  )     &  &     ( t    <     1  )  )", "verticesOut [  ( newNumVerts +  +  )  ]  . set ( a )  . mulAdd ( b . sub ( a )  ,    t )  ;", "if    (  ( s [ j ]  )     >     0  )", "verticesOut [  ( newNumVerts +  +  )  ]  . set ( verticesIn [ j ]  )  ;", "}", "return   newNumVerts ;", "} else    {", "for    ( int   i    =     0  ;    i    <    numVerts ;    i +  +  )", "verticesOut [ i ]  . set ( verticesIn [ i ]  )  ;", "return   numVerts ;", "}", "}", "METHOD_END"], "methodName": ["clipQuad"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "OcclusionBuffer . setAABBVertices ( center ,    halfExt ,    box )  ;", "drawBox ( box ,    OcclusionBuffer . Policy . DRAW )  ;", "}", "METHOD_END"], "methodName": ["drawAABB"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "Vector 3    center    =    tmpV 1  . setZero (  )  ;", ". setAABBVertices ( center ,    halfExt ,    box )  ;", "worldTransform . getTranslation ( center )  ;", "for    ( Vector 3    vertex    :    box )     {", "vertex . rot ( worldTransform )  ;", "vertex . add ( center )  ;", "}", "drawBox ( box ,     . Policy . DRAW )  ;", "}", "METHOD_END"], "methodName": ["drawBB"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     8  ;    i +  +  )     {", "Vector 3    v    =    vertices [ i ]  ;", "tmpVertices [ i ]  . set ( v . x ,    v . y ,    v . z ,     1  )  . mul ( projectionMatrix )  ;", "}", "if    ( policy . evaluate ( tmpVertices )  )", "return   true ;", "for    ( int   i    =     0  ;    i    <     (  . WINDING . length )  ;  )     {", "quad [  0  ]  . set ( tmpVertices [  . WINDING [  ( i +  +  )  ]  ]  )  ;", "quad [  1  ]  . set ( tmpVertices [  . WINDING [  ( i +  +  )  ]  ]  )  ;", "quad [  2  ]  . set ( tmpVertices [  . WINDING [  ( i +  +  )  ]  ]  )  ;", "quad [  3  ]  . set ( tmpVertices [  . WINDING [  ( i +  +  )  ]  ]  )  ;", "int   numVertices    =    clipQuad ( quad ,    clippedQuad )  ;", "for    ( int   j    =     0  ;    j    <    numVertices ;    j +  +  )     {", ". Quaternion   q    =    clippedQuad [ j ]  ;", "q . z    =     1     /     ( q . w )  ;", "vertices [ j ]  . set (  (  ( q . x )     *     ( q . z )  )  ,     (  ( q . y )     *     ( q . z )  )  ,    q . z )  ;", "}", "for    ( int   j    =     2  ;    j    <    numVertices ;    j +  +  )     {", "if    ( drawTriangle ( vertices [  0  ]  ,    vertices [  ( j    -     1  )  ]  ,    vertices [ j ]  ,    policy )  )", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["drawBox"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( debugPixmap )     =  =    null )     {", "debugPixmap    =    new   graphics . Pixmap ( bufferWidth ,    bufferHeight ,    Format . RGBA 8  8  8  8  )  ;", "debugTexture    =    new   graphics . Texture ( debugPixmap )  ;", "debugTextureRegion    =    new   graphics . g 2 d . TextureRegion ( debugTexture )  ;", "debugTextureRegion . flip ( false ,    true )  ;", "}", "debugPixmap . setColor ( BLACK )  ;", "debugPixmap . fill (  )  ;", "float   minDepth    =    Float . POSITIVE _ INFINITY ;", "float   maxDepth    =    Float . NEGATIVE _ INFINITY ;", "buffer . clear (  )  ;", "while    (  ( buffer . position (  )  )     <     ( buffer . capacity (  )  )  )     {", "float   depth    =    MathUtils . clamp ( buffer . get (  )  ,     0  ,    Float . POSITIVE _ INFINITY )  ;", "minDepth    =    Math . min ( depth ,    minDepth )  ;", "maxDepth    =    Math . max ( depth ,    maxDepth )  ;", "}", "float   extent    =     1     /     ( maxDepth    -    minDepth )  ;", "buffer . clear (  )  ;", "for    ( int   x    =     0  ;    x    <     ( bufferWidth )  ;    x +  +  )     {", "for    ( int   y    =     0  ;    y    <     ( bufferHeight )  ;    y +  +  )     {", "float   depth    =    MathUtils . clamp ( buffer . get (  ( x    +     ( y    *     ( bufferWidth )  )  )  )  ,     0  ,    Float . POSITIVE _ INFINITY )  ;", "float   c    =    depth    *    extent ;", "debugPixmap . drawPixel ( x ,    y ,    Color . rgba 8  8  8  8  ( c ,    c ,    c ,     1  )  )  ;", "}", "}", "debugTexture . draw ( debugPixmap ,     0  ,     0  )  ;", "return   debugTextureRegion ;", "}", "METHOD_END"], "methodName": ["drawDebugTexture"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tmpV 1  . set ( b )  . sub ( a )  . crs ( tmpV 2  . set ( c )  . sub ( a )  )  . z )     <  =     0  )", "return   false ;", "triX . set (  (  ( int )     (  (  ( a . x )     *     ( bHalfExt . x )  )     +     ( bOffset . x )  )  )  ,     (  ( int )     (  (  ( b . x )     *     ( bHalfExt . x )  )     +     ( bOffset . x )  )  )  ,     (  ( int )     (  (  ( c . x )     *     ( bHalfExt . x )  )     +     ( bOffset . x )  )  )  )  ;", "triY . set (  (  ( int )     (  (  ( a . y )     *     ( bHalfExt . y )  )     +     ( bOffset . y )  )  )  ,     (  ( int )     (  (  ( b . y )     *     ( bHalfExt . y )  )     +     ( bOffset . y )  )  )  ,     (  ( int )     (  (  ( c . y )     *     ( bHalfExt . y )  )     +     ( bOffset . y )  )  )  )  ;", "int   xMin    =    Math . max (  0  ,    Math . min ( triX . x ,    Math . min ( triX . y ,    triX . z )  )  )  ;", "int   xMax    =    Math . min ( bWidth ,     (  1     +     ( Math . max ( triX . x ,    Math . max ( triX . y ,    triX . z )  )  )  )  )  ;", "int   yMin    =    Math . max (  0  ,    Math . min ( triY . x ,    Math . min ( triY . y ,    triY . z )  )  )  ;", "int   yMax    =    Math . min ( bWidth ,     (  1     +     ( Math . max ( triY . x ,    Math . max ( triY . y ,    triY . z )  )  )  )  )  ;", "int   width    =    xMax    -    xMin ;", "int   height    =    yMax    -    yMin ;", "if    (  ( width    *    height )     <  =     0  )", "return   false ;", "triDX . set (  (  ( triY . x )     -     ( triY . y )  )  ,     (  ( triY . y )     -     ( triY . z )  )  ,     (  ( triY . z )     -     ( triY . x )  )  )  ;", "triDY . set (  (  (  ( triX . y )     -     ( triX . x )  )     -     (  ( triDX . x )     *    width )  )  ,     (  (  ( triX . z )     -     ( triX . y )  )     -     (  ( triDX . y )     *    width )  )  ,     (  (  ( triX . x )     -     ( triX . z )  )     -     (  ( triDX . z )     *    width )  )  )  ;", "cursor . set (  (  (  (  ( yMin    *     (  ( triX . y )     -     ( triX . x )  )  )     +     ( xMin    *     (  ( triY . x )     -     ( triY . y )  )  )  )     +     (  ( triX . x )     *     ( triY . y )  )  )     -     (  ( triX . y )     *     ( triY . x )  )  )  ,     (  (  (  ( yMin    *     (  ( triX . z )     -     ( triX . y )  )  )     +     ( xMin    *     (  ( triY . y )     -     ( triY . z )  )  )  )     +     (  ( triX . y )     *     ( triY . z )  )  )     -     (  ( triX . z )     *     ( triY . y )  )  )  ,     (  (  (  ( yMin    *     (  ( triX . x )     -     ( triX . z )  )  )     +     ( xMin    *     (  ( triY . z )     -     ( triY . x )  )  )  )     +     (  ( triX . z )     *     ( triY . x )  )  )     -     (  ( triX . x )     *     ( triY . z )  )  )  )  ;", "float   ia    =     1  .  0 F    /     (  ( float )     (  (  (  (  (  (  ( triX . x )     *     ( triY . y )  )     -     (  ( triX . y )     *     ( triY . x )  )  )     +     (  ( triX . z )     *     ( triY . x )  )  )     -     (  ( triX . x )     *     ( triY . z )  )  )     +     (  ( triX . y )     *     ( triY . z )  )  )     -     (  ( triX . z )     *     ( triY . y )  )  )  )  ;", "float   dzx    =    ia    *     (  (  (  ( triY . x )     *     (  ( c . z )     -     ( b . z )  )  )     +     (  ( triY . y )     *     (  ( a . z )     -     ( c . z )  )  )  )     +     (  ( triY . z )     *     (  ( b . z )     -     ( a . z )  )  )  )  ;", "float   dzy    =     ( ia    *     (  (  (  ( triX . x )     *     (  ( b . z )     -     ( c . z )  )  )     +     (  ( triX . y )     *     (  ( c . z )     -     ( a . z )  )  )  )     +     (  ( triX . z )     *     (  ( a . z )     -     ( b . z )  )  )  )  )     -     ( dzx    *    width )  ;", "float   drawDepth    =    ia    *     (  (  (  ( a . z )     *     ( cursor . y )  )     +     (  ( b . z )     *     ( cursor . z )  )  )     +     (  ( c . z )     *     ( cursor . x )  )  )  ;", "int   bRow    =    yMin    *     ( bHeight )  ;", "for    ( int   iy    =    yMin ;    iy    <    yMax ;    iy +  +  )     {", "for    ( int   ix    =    xMin ;    ix    <    xMax ;    ix +  +  )     {", "int   bIndex    =    bRow    +    ix ;", "if    (  (  (  (  ( cursor . x )     >  =     0  )     &  &     (  ( cursor . y )     >  =     0  )  )     &  &     (  ( cursor . z )     >  =     0  )  )     &  &     ( policy . process ( b ,    bIndex ,    drawDepth )  )  )", "return   true ;", "cursor . add ( triDX )  ;", "drawDepth    +  =    dzx ;", "}", "cursor . add ( triDY )  ;", "drawDepth    +  =    dzy ;", "bRow    +  =    bWidth ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["drawTriangle"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "OcclusionBuffer . setAABBVertices ( center ,    halfExt ,    box )  ;", "return   drawBox ( box ,    OcclusionBuffer . Policy . QUERY )  ;", "}", "METHOD_END"], "methodName": ["queryAABB"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "vertices [  0  ]  . set (  (  ( center . x )     -     ( halfExt . x )  )  ,     (  ( center . y )     -     ( halfExt . y )  )  ,     (  ( center . z )     -     ( halfExt . z )  )  )  ;", "vertices [  1  ]  . set (  (  ( center . x )     +     ( halfExt . x )  )  ,     (  ( center . y )     -     ( halfExt . y )  )  ,     (  ( center . z )     -     ( halfExt . z )  )  )  ;", "vertices [  2  ]  . set (  (  ( center . x )     +     ( halfExt . x )  )  ,     (  ( center . y )     +     ( halfExt . y )  )  ,     (  ( center . z )     -     ( halfExt . z )  )  )  ;", "vertices [  3  ]  . set (  (  ( center . x )     -     ( halfExt . x )  )  ,     (  ( center . y )     +     ( halfExt . y )  )  ,     (  ( center . z )     -     ( halfExt . z )  )  )  ;", "vertices [  4  ]  . set (  (  ( center . x )     -     ( halfExt . x )  )  ,     (  ( center . y )     -     ( halfExt . y )  )  ,     (  ( center . z )     +     ( halfExt . z )  )  )  ;", "vertices [  5  ]  . set (  (  ( center . x )     +     ( halfExt . x )  )  ,     (  ( center . y )     -     ( halfExt . y )  )  ,     (  ( center . z )     +     ( halfExt . z )  )  )  ;", "vertices [  6  ]  . set (  (  ( center . x )     +     ( halfExt . x )  )  ,     (  ( center . y )     +     ( halfExt . y )  )  ,     (  ( center . z )     +     ( halfExt . z )  )  )  ;", "vertices [  7  ]  . set (  (  ( center . x )     -     ( halfExt . x )  )  ,     (  ( center . y )     +     ( halfExt . y )  )  ,     (  ( center . z )     +     ( halfExt . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["setAABBVertices"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "projectionMatrix . set ( matrix )  ;", "}", "METHOD_END"], "methodName": ["setProjectionMatrix"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionBuffer"}, {"methodBody": ["METHOD_START", "{", "setFrustumPlanes ( camera . frustum )  ;", "btDbvt . collideKDOP ( broadphase . getSet 1  (  )  . getRoot (  )  ,    frustumNormals ,    frustumOffsets ,     . NUM _ PLANES ,    collider )  ;", "btDbvt . collideKDOP ( broadphase . getSet 0  (  )  . getRoot (  )  ,    frustumNormals ,    frustumOffsets ,     . NUM _ PLANES ,    collider )  ;", "}", "METHOD_END"], "methodName": ["performKDOPCulling"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCuller"}, {"methodBody": ["METHOD_START", "{", "this . oclBuffer    =    oclBuffer ;", "oclBuffer . setProjectionMatrix ( camera . combined )  ;", "setFrustumPlanes ( camera . frustum )  ;", "btDbvt . collideOCL ( broadphase . getSet 1  (  )  . getRoot (  )  ,    frustumNormals ,    frustumOffsets ,    camera . direction ,     . NUM _ PLANES ,    collider )  ;", "btDbvt . collideOCL ( broadphase . getSet 0  (  )  . getRoot (  )  ,    frustumNormals ,    frustumOffsets ,    camera . direction ,     . NUM _ PLANES ,    collider )  ;", "}", "METHOD_END"], "methodName": ["performOcclusionCulling"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCuller"}, {"methodBody": ["METHOD_START", "{", "frustumNormals . clear (  )  ;", "frustumOffseclear (  )  ;", "for    ( int   i    =     1  ;    i    <     6  ;    i +  +  )     {", "Plane   plane    =    frustum . planes [ i ]  ;", "frustumNormals . put ( plane . normal . x )  ;", "frustumNormals . put ( plane . normal . y )  ;", "frustumNormals . put ( plane . normal . z )  ;", "frustumNormals . put (  0  )  ;", "frustumOffseput ( plane . d )  ;", "}", "}", "METHOD_END"], "methodName": ["setFrustumPlanes"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCuller"}, {"methodBody": ["METHOD_START", "{", "BulletEntity   e    =    world . add ( type ,     0  ,     0  ,     0  )  ;", "e . body . setWorldTransform ( e . transform . setToRotation ( Y ,    rotationY )  . setTranslation ( position )  )  ;", "e . body . setCollisionFlags (  (  ( e . body . getCollisionFlags (  )  )     |     (  . CF _ OCCLUDER _ OBJECT )  )  )  ;", "e . setColor ( RED )  ;", "return   e ;", "}", "METHOD_END"], "methodName": ["addOccluder"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCullingTest"}, {"methodBody": ["METHOD_START", "{", "BulletEntity   entity    =    world . add ( getRandomOccludeeType ( dynamic )  ,     0  ,     0  ,     0  )  ;", "entity . setColor ( WHITE )  ;", "float   rotationY    =     ( rng . nextFloat (  )  )     *     3  6  0  .  0 F ;", "Vector 3    position    =    BaseBulletTest . tmpV 1  ;", "int   maxDstX    =     (  ( int )     (  (  . GROUND _ DIM . x )     *     0  .  4  9 F )  )  ;", "position . x    =     ( rng . nextInt ( maxDstX )  )     *     ( rng . nextBoolean (  )     ?     1     :     -  1  )  ;", "position . z    =     ( rng . nextInt ( maxDstX )  )     *     ( rng . nextBoolean (  )     ?     1     :     -  1  )  ;", "position . y    =     ( entity . boundingBox . getDimensions ( BaseBulletTest . tmpV 2  )  . y )     *     0  .  5 F ;", "entity . modelInstance . transform . setToRotation ( Y ,    rotationY )  . setTranslation ( position )  ;", "entity . body . setWorldTransform ( entity . modelInstance . transform )  ;", "return   entity ;", "}", "METHOD_END"], "methodName": ["addRandomOccludee"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCullingTest"}, {"methodBody": ["METHOD_START", "{", "entity . modelInstance . transform . getTranslation ( BaseBulletTest . tmpV 1  )  ;", "return   frustumCam . frustum . sphereInFrustum ( BaseBulletTest . tmpV 1  . add ( entity . boundingBox . getCenter ( BaseBulletTest . tmpV 2  )  )  ,    entity . boundingBoxRadius )  ;", "}", "METHOD_END"], "methodName": ["entityInFrustum"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCullingTest"}, {"methodBody": ["METHOD_START", "{", "int   i    =    rng . nextInt ( OcclusionCullingTest . OCCLUDEE _ PATHS _ STATIC . length )  ;", "return   dynamic    ?    OcclusionCullingTest . OCCLUDEE _ PATHS _ DYNAMIC [ i ]     :    OcclusionCullingTest . OCCLUDEE _ PATHS _ STATIC [ i ]  ;", "}", "METHOD_END"], "methodName": ["getRandomOccludeeType"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCullingTest"}, {"methodBody": ["METHOD_START", "{", "TextureRegion   oclDebugTexture    =    oclBuffer . drawDebugTexture (  )  ;", "spriteBatch . begin (  )  ;", "spriteBatch . draw ( oclDebugTexture ,     0  ,     0  )  ;", "spriteBatch . end (  )  ;", "shapeRenderer . begin ( Line )  ;", "shapeRenderer . setColor ( DARK _ GRAY )  ;", "shapeRenderer . rect (  0  ,     0  ,    oclDebugTexture . getRegionWidth (  )  ,    oclDebugTexture . getRegionHeight (  )  )  ;", "shapeRenderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderOclDebugImage"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCullingTest"}, {"methodBody": ["METHOD_START", "{", "(  ( DirectionalShadowLight )     ( light )  )  . begin ( Zero ,    camera . direction )  ;", "shadowBatch . begin (  (  ( DirectionalShadowLight )     ( light )  )  . getCamera (  )  )  ;", "world . render ( shadowBatch ,    null ,    visibleEntities )  ;", "shadowBatch . end (  )  ;", "(  ( DirectionalShadowLight )     ( light )  )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderShadows"], "fileName": "com.badlogic.gdx.tests.bullet.OcclusionCullingTest"}, {"methodBody": ["METHOD_START", "{", "final   Matrix 4    tmpM    =    new   Matrix 4  (  )  ;", "btRigidBody   pelvis    =     (  ( btRigidBody )     ( world . add (  \" pelvis \"  ,    x ,     ( y    +     1  )  ,    z )  . body )  )  ;", "btRigidBody   spine    =     (  ( btRigidBody )     ( world . add (  \" spine \"  ,    x ,     ( y    +     1  .  2 F )  ,    z )  . body )  )  ;", "btRigidBody   head    =     (  ( btRigidBody )     ( world . add (  \" head \"  ,    x ,     ( y    +     1  .  6 F )  ,    z )  . body )  )  ;", "btRigidBody   leftupperleg    =     (  ( btRigidBody )     ( world . add (  \" upperleg \"  ,     ( x    -     0  .  1  8 F )  ,     ( y    +     0  .  6  5 F )  ,    z )  . body )  )  ;", "btRigidBody   leftlowerleg    =     (  ( btRigidBody )     ( world . add (  \" lowerleg \"  ,     ( x    -     0  .  1  8 F )  ,     ( y    +     0  .  2 F )  ,    z )  . body )  )  ;", "btRigidBody   rightupperleg    =     (  ( btRigidBody )     ( world . add (  \" upperleg \"  ,     ( x    +     0  .  1  8 F )  ,     ( y    +     0  .  6  5 F )  ,    z )  . body )  )  ;", "btRigidBody   rightlowerleg    =     (  ( btRigidBody )     ( world . add (  \" lowerleg \"  ,     ( x    +     0  .  1  8 F )  ,     ( y    +     0  .  2 F )  ,    z )  . body )  )  ;", "btRigidBody   leftupperarm    =     (  ( btRigidBody )     ( world . add (  \" upperarm \"  ,    tmpM . setFromEulerAnglesRad (  . PI 2  ,     0  ,     0  )  . trn (  ( x    -     0  .  3  5 F )  ,     ( y    +     1  .  4  5 F )  ,    z )  )  . body )  )  ;", "btRigidBody   leftlowerarm    =     (  ( btRigidBody )     ( world . add (  \" lowerarm \"  ,    tmpM . setFromEulerAnglesRad (  . PI 2  ,     0  ,     0  )  . trn (  ( x    -     0  .  7 F )  ,     ( y    +     1  .  4  5 F )  ,    z )  )  . body )  )  ;", "btRigidBody   rightupperarm    =     (  ( btRigidBody )     ( world . add (  \" upperarm \"  ,    tmpM . setFromEulerAnglesRad (  (  -  (  . PI 2  )  )  ,     0  ,     0  )  . trn (  ( x    +     0  .  3  5 F )  ,     ( y    +     1  .  4  5 F )  ,    z )  )  . body )  )  ;", "btRigidBody   rightlowerarm    =     (  ( btRigidBody )     ( world . add (  \" lowerarm \"  ,    tmpM . setFromEulerAnglesRad (  (  -  (  . PI 2  )  )  ,     0  ,     0  )  . trn (  ( x    +     0  .  7 F )  ,     ( y    +     1  .  4  5 F )  ,    z )  )  . body )  )  ;", "final   Matrix 4    localA    =    new   Matrix 4  (  )  ;", "final   Matrix 4    localB    =    new   Matrix 4  (  )  ;", "btHingeConstraint   hingeC    =    null ;", "btConeTwistConstraint   coneC    =    null ;", "localA . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     0  .  1  5 F ,     0  )  ;", "localB . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     (  -  0  .  1  5 F )  ,     0  )  ;", "constraints . add (  ( hingeC    =    new   btHingeConstraint ( pelvis ,    spine ,    localA ,    localB )  )  )  ;", "hingeC . setLimit (  (  -  (  . PI 4  )  )  ,     . PI 2  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( hingeC ,    true )  ;", "localA . setFromEulerAnglesRad (  . PI 2  ,     0  ,     0  )  . trn (  0  ,     0  .  3 F ,     0  )  ;", "localB . setFromEulerAnglesRad (  . PI 2  ,     0  ,     0  )  . trn (  0  ,     (  -  0  .  1  4 F )  ,     0  )  ;", "constraints . add (  ( coneC    =    new   btConeTwistConstraint ( spine ,    head ,    localA ,    localB )  )  )  ;", "coneC . setLimit (  . PI 4  ,     . PI 4  ,     . PI 2  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( coneC ,    true )  ;", "localA . setFromEulerAnglesRad (  (  (  -  (  . PI 4  )  )     *     5  .  0 F )  ,     0  ,     0  )  . trn (  (  -  0  .  1  8 F )  ,     (  -  0  .  1 F )  ,     0  )  ;", "localB . setFromEulerAnglesRad (  (  (  -  (  . PI 4  )  )     *     5  .  0 F )  ,     0  ,     0  )  . trn (  0  ,     0  .  2  2  5 F ,     0  )  ;", "constraints . add (  ( coneC    =    new   btConeTwistConstraint ( pelvis ,    leftupperleg ,    localA ,    localB )  )  )  ;", "coneC . setLimit (  . PI 4  ,     . PI 4  ,     0  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( coneC ,    true )  ;", "localA . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     (  -  0  .  2  2  5 F )  ,     0  )  ;", "localB . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     0  .  1  8  5 F ,     0  )  ;", "constraints . add (  ( hingeC    =    new   btHingeConstraint ( leftupperleg ,    leftlowerleg ,    localA ,    localB )  )  )  ;", "hingeC . setLimit (  0  ,     . PI 2  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( hingeC ,    true )  ;", "localA . setFromEulerAnglesRad (  (  (  -  (  . PI 4  )  )     *     5  .  0 F )  ,     0  ,     0  )  . trn (  0  .  1  8 F ,     (  -  0  .  1 F )  ,     0  )  ;", "localB . setFromEulerAnglesRad (  (  (  -  (  . PI 4  )  )     *     5  .  0 F )  ,     0  ,     0  )  . trn (  0  ,     0  .  2  2  5 F ,     0  )  ;", "constraints . add (  ( coneC    =    new   btConeTwistConstraint ( pelvis ,    rightupperleg ,    localA ,    localB )  )  )  ;", "coneC . setLimit (  . PI 4  ,     . PI 4  ,     0  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( coneC ,    true )  ;", "localA . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     (  -  0  .  2  2  5 F )  ,     0  )  ;", "localB . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     0  .  1  8  5 F ,     0  )  ;", "constraints . add (  ( hingeC    =    new   btHingeConstraint ( rightupperleg ,    rightlowerleg ,    localA ,    localB )  )  )  ;", "hingeC . setLimit (  0  ,     . PI 2  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( hingeC ,    true )  ;", "localA . setFromEulerAnglesRad (  . PI ,     0  ,     0  )  . trn (  (  -  0  .  2 F )  ,     0  .  1  5 F ,     0  )  ;", "localB . setFromEulerAnglesRad (  . PI 2  ,     0  ,     0  )  . trn (  0  ,     (  -  0  .  1  8 F )  ,     0  )  ;", "constraints . add (  ( coneC    =    new   btConeTwistConstraint ( pelvis ,    leftupperarm ,    localA ,    localB )  )  )  ;", "coneC . setLimit (  . PI 2  ,     . PI 2  ,     0  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( coneC ,    true )  ;", "localA . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     0  .  1  8 F ,     0  )  ;", "localB . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     (  -  0  .  1  4 F )  ,     0  )  ;", "constraints . add (  ( hingeC    =    new   btHingeConstraint ( leftupperarm ,    leftlowerarm ,    localA ,    localB )  )  )  ;", "hingeC . setLimit (  0  ,     . PI 2  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( hingeC ,    true )  ;", "localA . setFromEulerAnglesRad (  . PI ,     0  ,     0  )  . trn (  0  .  2 F ,     0  .  1  5 F ,     0  )  ;", "localB . setFromEulerAnglesRad (  . PI 2  ,     0  ,     0  )  . trn (  0  ,     (  -  0  .  1  8 F )  ,     0  )  ;", "constraints . add (  ( coneC    =    new   btConeTwistConstraint ( pelvis ,    rightupperarm ,    localA ,    localB )  )  )  ;", "coneC . setLimit (  . PI 2  ,     . PI 2  ,     0  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( coneC ,    true )  ;", "localA . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     0  .  1  8 F ,     0  )  ;", "localB . setFromEulerAnglesRad (  0  ,     . PI 2  ,     0  )  . trn (  0  ,     (  -  0  .  1  4 F )  ,     0  )  ;", "constraints . add (  ( hingeC    =    new   btHingeConstraint ( rightupperarm ,    rightlowerarm ,    localA ,    localB )  )  )  ;", "hingeC . setLimit (  0  ,     . PI 2  )  ;", "(  ( btDynamicsWorld )     ( world . collisionWorld )  )  . addConstraint ( hingeC ,    true )  ;", "}", "METHOD_END"], "methodName": ["addRagdoll"], "fileName": "com.badlogic.gdx.tests.bullet.RayPickRagdollTest"}, {"methodBody": ["METHOD_START", "{", "final   Model   result    =    modelBuilder . createCapsule ( radius ,     ( height    +     ( radius    *     2  .  0 F )  )  ,     1  6  ,    new   com . badlogic . gdx . graphics . g 3 d . Material ( ColorAttribute . createDiffuse ( WHITE )  ,    ColorAttribute . createSpecular ( WHITE )  )  ,     (  ( Usage . Position )     |     ( Usage . Normal )  )  )  ;", "disposables . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createCapsuleModel"], "fileName": "com.badlogic.gdx.tests.bullet.RayPickRagdollTest"}, {"methodBody": ["METHOD_START", "{", "return   new   com . badlogic . gdx . physics . bullet . dynamics . btDefaultVehicleRaycaster (  (  ( btDynamicsWorld )     ( world . collisionWorld )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRaycaster"], "fileName": "com.badlogic.gdx.tests.bullet.VehicleTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isDisplayModeEqual ( a ,    b )  )  )     {", "throw   new   AssertionError (  (  ( a    +     \"    isn ' t   equal   to    \"  )     +    b )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertDisplayModeEquals"], "fileName": "com.badlogic.gdx.tests.conformance.DisplayModeTest"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( a . length )     =  =     0  )     |  |     (  ( b . length )     =  =     0  )  )", "throw   new   AssertionError (  \" Argument   a   or   b   can ' t   be   a   zero   length   array \"  )  ;", "if    (  ( a . length )     !  =     ( b . length )  )     {", "throw   new   AssertionError (  (  (  (  \" Display   modes    \"     +     ( Arrays . toString ( a )  )  )     +     \"    aren ' t   equal   to   display   modes    \"  )     +     ( Arrays . toString ( b )  )  )  )  ;", "}", "boolean   equal    =    true ;", "for    ( int   i    =     0  ;    i    <     ( a . length )  ;    i +  +  )     {", "equal    =    equal    &  &     ( isEqual ( a [ i ]  ,    b [ i ]  )  )  ;", "}", "if    (  ! equal )     {", "throw   new   AssertionError (  (  (  (  \" Display   modes    \"     +     ( Arrays . toString ( a )  )  )     +     \"    aren ' t   equal   to   display   modes    \"  )     +     ( Arrays . toString ( b )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertDisplayModesEquals"], "fileName": "com.badlogic.gdx.tests.conformance.DisplayModeTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( a    =  =    null )     |  |        =  =    null )  )", "return   false ;", "oolean   equal    =     (  (  (  ( aitsPerPixel )     =  =    itsPerPixel )  )     &  &     (  ( a . height )     =  =     . height )  )  )     &  &     (  ( a . refreshRate )     =  =     . refreshRate )  )  )     &  &     (  ( a . width )     =  =     . width )  )  ;", "return   equal ;", "}", "METHOD_END"], "methodName": ["isDisplayModeEqual"], "fileName": "com.badlogic.gdx.tests.conformance.DisplayModeTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "texture    =    new   graphics . Texture ( files . internal (  \" data / bobargb 8  8  8  8  -  3  2 x 3  2  . png \"  )  )  ;", "camera    =    new   OrthographicCamera (  )  ;", "camera . setToOrtho ( false )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.examples.MoveSpriteExample"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  1  ,     1  ,     1  ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "batch . begin (  )  ;", "batch . draw ( texture ,    sPosition . x ,    sPosition . y )  ;", "batch . end (  )  ;", "if    ( input . isTouched (  )  )     {", "camera . unproject ( sPosition . set ( input . getX (  )  ,    input . getY (  )  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.examples.MoveSpriteExample"}, {"methodBody": ["METHOD_START", "{", "console . setItems ( new   String [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.tests.extensions.ControllersTest"}, {"methodBody": ["METHOD_START", "{", "if    ( initialized )", "return ;", "print (  (  \"  :     \"     +     (  . get (  )  . size )  )  )  ;", "int   i    =     0  ;", "for    ( Controller   controller    :     . get (  )  )     {", "print (  (  (  (  \"  #  \"     +     ( i +  +  )  )     +     \"  :     \"  )     +     ( controller . getName (  )  )  )  )  ;", "}", "if    (  (  . get (  )  . size )     =  =     0  )", "print (  \" No   controllers   attached \"  )  ;", ". addListener ( new   ControllerListener (  )     {", "public   int   indexOf ( Controller   controller )     {", "return    . get (  )  . indexOf ( controller ,    true )  ;", "}", "@ Override", "public   void   connected ( Controller   controller )     {", "print (  (  \" connected    \"     +     ( controller . getName (  )  )  )  )  ;", "int   i    =     0  ;", "for    ( Controller   c    :     . get (  )  )     {", "print (  (  (  (  \"  #  \"     +     ( i +  +  )  )     +     \"  :     \"  )     +     ( c . getName (  )  )  )  )  ;", "}", "}", "@ Override", "public   void   disconnected ( Controller   controller )     {", "print (  (  \" disconnected    \"     +     ( controller . getName (  )  )  )  )  ;", "int   i    =     0  ;", "for    ( Controller   c    :     . get (  )  )     {", "print (  (  (  (  \"  #  \"     +     ( i +  +  )  )     +     \"  :     \"  )     +     ( c . getName (  )  )  )  )  ;", "}", "if    (  (  . get (  )  . size )     =  =     0  )", "print (  \" No   controllers   attached \"  )  ;", "}", "@ Override", "public   boolean   buttonDown ( Controller   controller ,    int   buttonIndex )     {", "print (  (  (  (  (  \"  #  \"     +     ( indexOf ( controller )  )  )     +     \"  ,    button    \"  )     +    buttonIndex )     +     \"    down \"  )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   buttonUp ( Controller   controller ,    int   buttonIndex )     {", "print (  (  (  (  (  \"  #  \"     +     ( indexOf ( controller )  )  )     +     \"  ,    button    \"  )     +    buttonIndex )     +     \"    up \"  )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   axisMoved ( Controller   controller ,    int   axisIndex ,    float   value )     {", "print (  (  (  (  (  (  \"  #  \"     +     ( indexOf ( controller )  )  )     +     \"  ,    axis    \"  )     +    axisIndex )     +     \"  :     \"  )     +    value )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   povMoved ( Controller   controller ,    int   povIndex ,    PovDirection   value )     {", "print (  (  (  (  (  (  \"  #  \"     +     ( indexOf ( controller )  )  )     +     \"  ,    pov    \"  )     +    povIndex )     +     \"  :     \"  )     +    value )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   xSliderMoved ( Controller   controller ,    int   sliderIndex ,    boolean   value )     {", "print (  (  (  (  (  (  \"  #  \"     +     ( indexOf ( controller )  )  )     +     \"  ,    x   slider    \"  )     +    sliderIndex )     +     \"  :     \"  )     +    value )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   ySliderMoved ( Controller   controller ,    int   sliderIndex ,    boolean   value )     {", "print (  (  (  (  (  (  \"  #  \"     +     ( indexOf ( controller )  )  )     +     \"  ,    y   slider    \"  )     +    sliderIndex )     +     \"  :     \"  )     +    value )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   accelerometerMoved ( Controller   controller ,    int   accelerometerIndex ,    Vector 3    value )     {", "return   false ;", "}", "}  )  ;", "initialized    =    true ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.tests.extensions.ControllersTest"}, {"methodBody": ["METHOD_START", "{", "String [  ]    lines    =    console . getItems (  )  . toArray ( String . class )  ;", "String [  ]    newLines    =    new   String [  ( lines . length )     +     1  ]  ;", "System . arraycopy ( lines ,     0  ,    newLines ,     0  ,    lines . length )  ;", "newLines [  (  ( newLines . length )     -     1  )  ]     =    message ;", "console . setItems ( newLines )  ;", "scPane . invalidate (  )  ;", "scPane . validate (  )  ;", "scPane . setScPercentY (  1  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["print"], "fileName": "com.badlogic.gdx.tests.extensions.ControllersTest"}, {"methodBody": ["METHOD_START", "{", "skin    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "stage    =    new   Stage (  )  ;", "ui    =    new   Table (  )  ;", "ui . setSize ( graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "console    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . List ( skin )  ;", "scrollPane    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . ScrollPane ( console )  ;", "scrollPane . setScrollbarsOnTop ( true )  ;", "TextButton   clear    =    new   TextButton (  \" Clear \"  ,    skin )  ;", "ui . add ( scrollPane )  . expand ( true ,    true )  . fill (  )  ;", "ui . row (  )  ;", "ui . add ( clear )  . expand ( true ,    false )  . fill (  )  ;", "stage . addActor ( ui )  ;", "clear . addListener ( new   ClickListener (  )     {", "@ Override", "public   void   clicked ( InputEvent   event ,    float   x ,    float   y )     {", "clear (  )  ;", "}", "}  )  ;", "input . setInputProcessor ( stage )  ;", "}", "METHOD_END"], "methodName": ["setupUi"], "fileName": "com.badlogic.gdx.tests.extensions.ControllersTest"}, {"methodBody": ["METHOD_START", "{", "packer    =    new   com . badlogic . gdx . graphics . g 2 d . PixmapPacker ( FreeTypeAtlasTest . FONT _ ATLAS _ WIDTH ,    FreeTypeAtlasTest . FONT _ ATLAS _ HEIGHT ,    Format . RGBA 8  8  8  8  ,     2  ,    false )  ;", "fontMap    =    new   FreeTypeAtlasTest . FontMap < BitmapFont >  (  )  ;", "int   fontCount    =     0  ;", "for    ( FreeTypeAtlasTest . FontStyle   style    :    FreeTypeAtlasTest . FontStyle . values (  )  )     {", "FreeTypeFontGenerator   gen    =    new   FreeTypeFontGenerator ( files . internal ( style . path )  )  ;", "for    ( FreeTypeAtlasTest . FontSize   size    :    FreeTypeAtlasTest . FontSize . values (  )  )     {", "FreeTypeFontGenerator . FreeTypeFontParameter   fontParameter    =    new   FreeTypeFontGenerator . FreeTypeFontParameter (  )  ;", "fontParameter . size    =    size . size ;", "fontParameter . packer    =    packer ;", "fontParameter . characters    =    FreeTypeAtlasTest . CHARACTERS ;", "BitmapFont   bmFont    =    gen . generateFont ( fontParameter )  ;", "fontMap . get ( style )  . put ( size ,    bmFont )  ;", "fontCount +  +  ;", "}", "gen . dispose (  )  ;", "}", "return   fontCount    *     ( FreeTypeAtlasTest . CHARACTERS . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["createFonts"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypeAtlasTest"}, {"methodBody": ["METHOD_START", "{", "return   fontMap . get ( style )  . get ( size )  ;", "}", "METHOD_END"], "methodName": ["getFont"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypeAtlasTest"}, {"methodBody": ["METHOD_START", "{", "if    ( input . justTouched (  )  )     {", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "if    (  ( font )     !  =    null )     {", "font . dispose (  )  ;", "}", "FileHandle   fontFile    =    files . internal (  \" data / arial . ttf \"  )  ;", "FreeTypeFontGenerator   generator    =    new   FreeTypeFontGenerator ( fontFile )  ;", "FreeTypeFontParameter   parameter    =    new   FreeTypeFontParameter (  )  ;", "parameter . size    =     1  5  ;", "font    =    generator . generateFont ( parameter )  ;", "generator . dispose (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )", "System . gc (  )  ;", "app . log (  \"  \"  ,     \" generated    1  0    fonts \"  )  ;", "app . log (  \"  \"  ,     (  (  ( app . getJavaHeap (  )  )     +     \"  ,     \"  )     +     ( app . getNativeHeap (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypeDisposeTest"}, {"methodBody": ["METHOD_START", "{", "batch    =    new   SpriteBatch (  )  ;", "shapes    =    new   ShapeRenderer (  )  ;", "shapes . setColor ( RED )  ;", "FreeTypeFontGenerator . setMaxTextureSize (  1  2  8  )  ;", "generator    =    new   FreeTypeFontGenerator ( files . internal (  \" data / arial . ttf \"  )  )  ;", "FreeTypeFontParameter   param    =    new   FreeTypeFontParameter (  )  ;", "param . incremental    =    true ;", "param . size    =     2  4  ;", "param . characters    =     \" howdY \\ u 0  0  0  0  \"  ;", "FreeTypeBitmapFontData   data    =    new   FreeTypeBitmapFontData (  )     {", "public   int   getWrapIndex ( Array < Glyph >    glyphs ,    int   start )     {", "return    . SimplifiedChinese . getWrapIndex ( glyphs ,    start )  ;", "}", "}  ;", "data . xChars    =    new   char [  ]  {     '  \u00b6\u00af  '     }  ;", "data . capChars    =    new   char [  ]  {     '  \u00b6\u00af  '     }  ;", "font    =    generator . generateFont ( param ,    data )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypeIncrementalTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "shapes . begin ( Line )  ;", "float   x    =     0  ;", "float   y    =     (  ( graphics . getHeight (  )  )     -     ( font . getRegion (  )  . getRegionHeight (  )  )  )     -     1  ;", "for    ( int   i    =     0  ,    n    =    font . getReg (  )  . size ;    i    <    n ;    i +  +  )     {", "TextureRegion   region    =    font . getReg (  )  . get ( i )  ;", "shapes . rect ( x ,    y ,    region . getRegionWidth (  )  ,    region . getRegionHeight (  )  )  ;", "x    +  =     ( region . getRegionWidth (  )  )     +     2  ;", "}", "shapes . rect (  1  0  ,     2  5  0  ,     (  ( graphics . getWidth (  )  )     -     2  0  )  ,     (  -  2  4  0  )  )  ;", "shapes . end (  )  ;", "batch . begin (  )  ;", "x    =     0  ;", "for    ( int   i    =     0  ,    n    =    font . getReg (  )  . size ;    i    <    n ;    i +  +  )     {", "TextureRegion   region    =    font . getReg (  )  . get ( i )  ;", "batch . draw ( region ,    x ,    y )  ;", "x    +  =     ( region . getRegionWidth (  )  )     +     2  ;", "}", "font . draw ( batch ,     \" LYA \"  ,     1  0  ,     3  0  0  )  ;", "font . draw ( batch ,     \" hello   world \"  ,     1  0  0  ,     3  0  0  )  ;", "font . draw ( batch ,     (  \"  \u00b6\u00af  \u00bb\u00ad  \u00c4\u00dc  \u00b8\u00f8  \u00d3\u00ce  \u00cf\u00b7  \u00b4\u00f8  \u00c0\u00b4  \u00c9\u00fa  \u00bb\u00fa  \u00ba\u00cd  \u00c1\u00e9  \u00c6\u00f8  \u00a1\u00a3  \u00ce\u00d2  \u00c3\u00c7  \u00cf\u00e0  \u00d0\u00c5  \u00b4\u00b4  \u00d7\u00f7  \u00d2\u00bb  \u00b6\u00ce  \u00c3\u00c0  \u00c3\u00ee  \u00b5\u00c4  \u00b6\u00af  \u00bb\u00ad  \u00a3\u00ac  \u00b2\u00bb  \u00bd\u00f6  \u00d0\u00e8  \u00d2\u00aa  \u00c7\u00bf  \u00b4\u00f3  \u00b5\u00c4  \u00c8\u00ed  \u00bc\u00fe  \u00b9\u00a4  \u00be\u00df  \u00a3\u00ac  \u00b8\u00fc  \u00d0\u00e8  \u00d2\u00aa  \u00d2\u00bb  \u00cc\u00d7  \u00c5\u00a3    B    \u00b5\u00c4  \u00b9\u00a4  \u00d7\u00f7  \u00c1\u00f7  \u00b3\u00cc  \u00a1\u00a3  \"     +     \" Spine \u00d7\u00a8  \u00d7\u00a2  \u00d3\u00da  \u00b4\u00cb  \u00a3\u00ac  \u00ce\u00aa  \u00c4\u00fa  \u00b4\u00b4  \u00bd\u00a8  \u00be\u00aa  \u00d1\u00de  \u00b5\u00c4  \u00b9\u00c7  \u00f7\u00c0  \u00b6\u00af  \u00bb\u00ad  \u00a3\u00ac  \u00b2\u00a2  \u00bd\u00ab  \u00c6\u00e4  \u00d5\u00fb  \u00ba\u00cf  \u00b5\u00bd  \u00d3\u00ce  \u00cf\u00b7  \u00b5\u00b1  \u00d6\u00d0  \u00a3\u00ac  \u00cc\u00e1  \u00b9\u00a9  \u00c1\u00cb  \u00d2\u00bb  \u00cc\u00d7  \u00b8\u00df  \u00d0\u00a7  \u00b5\u00c4  \u00b9\u00a4  \u00d7\u00f7  \u00c1\u00f7  \u00b3\u00cc  \u00a1\u00a3  \"  )  ,     1  0  ,     2  5  0  ,     (  ( graphics . getWidth (  )  )     -     2  0  )  ,    left ,    true )  ;", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypeIncrementalTest"}, {"methodBody": ["METHOD_START", "{", "batch . getProjectionMatrix (  )  . setToOrtho 2 D (  0  ,     0  ,    width ,    height )  ;", "shapes . setProjectionMatrix ( batch . getProjectionMatrix (  )  )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypeIncrementalTest"}, {"methodBody": ["METHOD_START", "{", "PixmapPacker   packer    =    new   PixmapPacker ( FreeTypePackTest . FONT _ ATLAS _ WIDTH ,    FreeTypePackTest . FONT _ ATLAS _ HEIGHT ,    Format . RGBA 8  8  8  8  ,     2  ,    false )  ;", "FreeTypePackTest . FontMap < BitmapFontData >    dataMap    =    new   FreeTypePackTest . FontMap < BitmapFontData >  (  )  ;", "for    ( FreeTypePackTest . FontStyle   style    :    FreeTypePackTest . FontStyle . values (  )  )     {", "FreeTypeFontGenerator   gen    =    new   FreeTypeFontGenerator ( files . internal ( style . path )  )  ;", "for    ( FreeTypePackTest . FontSize   size    :    FreeTypePackTest . FontSize . values (  )  )     {", "FreeTypeFontGenerator . FreeTypeFontParameter   fontParameter    =    new   FreeTypeFontGenerator . FreeTypeFontParameter (  )  ;", "fontParameter . size    =    size . size ;", "fontParameter . packer    =    packer ;", "fontParameter . characters    =    FreeTypePackTest . CHARACTERS ;", "BitmapFontData   data    =    gen . generateData ( fontParameter )  ;", "dataMap . get ( style )  . put ( size ,    data )  ;", "}", "gen . dispose (  )  ;", "}", "regions    =    new   utils . Array < graphics . g 2 d . TextureRegion >  (  )  ;", "packer . updateTextureRegions ( regions ,    Nearest ,    Nearest ,    false )  ;", "packer . dispose (  )  ;", "fontMap    =    new   FreeTypePackTest . FontMap < BitmapFont >  (  )  ;", "int   fontCount    =     0  ;", "for    ( FreeTypePackTest . FontStyle   style    :    FreeTypePackTest . FontStyle . values (  )  )     {", "for    ( FreeTypePackTest . FontSize   size    :    FreeTypePackTest . FontSize . values (  )  )     {", "BitmapFontData   data    =    dataMap . get ( style )  . get ( size )  ;", "BitmapFont   bmFont    =    new   BitmapFont ( data ,    regions ,    FreeTypePackTest . INTEGER )  ;", "fontMap . get ( style )  . put ( size ,    bmFont )  ;", "fontCount +  +  ;", "}", "}", "return   fontCount    *     ( FreeTypePackTest . CHARACTERS . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["createFonts"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypePackTest"}, {"methodBody": ["METHOD_START", "{", "return   fontMap . get ( style )  . get ( size )  ;", "}", "METHOD_END"], "methodName": ["getFont"], "fileName": "com.badlogic.gdx.tests.extensions.FreeTypePackTest"}, {"methodBody": ["METHOD_START", "{", "BaseG 3 dHudTest . CollapsableWindow   window    =    new   BaseG 3 dHudTest . CollapsableWindow ( title ,    skin )  ;", "window . row (  )  ;", "ScrollPane   pane    =    new   ScrollPane ( list ,    skin )  ;", "pane . setFadeScrollBars ( false )  ;", "window . add ( pane )  ;", "window . pack (  )  ;", "window . pack (  )  ;", "if    (  ( window . getHeight (  )  )     >     ( hudHeight )  )     {", "window . setHeight ( hudHeight )  ;", "}", "window . setX (  ( x    <     0     ?     ( hudWidth )     -     (  ( window . getWidth (  )  )     -     ( x    +     1  )  )     :    x )  )  ;", "window . setY (  ( y    <     0     ?     ( hudHeight )     -     (  ( window . getHeight (  )  )     -     ( y    +     1  )  )     :    y )  )  ;", "window . layout (  )  ;", "window . collapse (  )  ;", "hud . addActor ( window )  ;", "pane . setScrollX (  0  )  ;", "pane . setScrollY (  0  )  ;", "return   window ;", "}", "METHOD_END"], "methodName": ["addListWindow"], "fileName": "com.badlogic.gdx.tests.g3d.BaseG3dHudTest"}, {"methodBody": ["METHOD_START", "{", "hud    =    new   Stage ( new   com . badlogic . gdx . utils . viewport . ScalingViewport ( Scaling . fit ,    BaseG 3 dHudTest . PREF _ HUDWIDTH ,    BaseG 3 dHudTest . PREF _ HUDHEIGHT )  )  ;", "hudWidth    =    hud . getWidth (  )  ;", "hudHeight    =    hud . getHeight (  )  ;", "skin    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . Skin ( files . internal (  \" data / uiskin . json \"  )  )  ;", "final   List < String >    modelsList    =    new   List ( skin )  ;", "modelsList . setItems ( models )  ;", "modelsList . addListener ( new   ClickListener (  )     {", "@ Override", "public   void   clicked ( InputEvent   event ,    float   x ,    float   y )     {", "if    (  (  !  ( modelsWindow . isCollapsed (  )  )  )     &  &     (  ( getTapCount (  )  )     =  =     2  )  )     {", "onModelClicked ( modelsList . getSelected (  )  )  ;", "modelsWindow . collapse (  )  ;", "}", "}", "}  )  ;", "modelsWindow    =    addListWindow (  \" Models \"  ,    modelsList ,     0  ,     (  -  1  )  )  ;", "fpsLabel    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . Label (  \" FPS :     9  9  9  \"  ,    skin )  ;", "hud . addActor ( fpsLabel )  ;", "gridCheckBox    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . CheckBox (  \" Show   grid \"  ,    skin )  ;", "gridCheckBox . setChecked ( showAxes )  ;", "gridCheckBox . addListener ( new   ChangeListener (  )     {", "@ Override", "public   void   changed ( ChangeEvent   event ,    Actor   actor )     {", "showAxes    =    gridCheckBox . isChecked (  )  ;", "}", "}  )  ;", "gridCheckBox . setPosition (  (  ( hudWidth )     -     ( gridCheckBox . getWidth (  )  )  )  ,     0  )  ;", "hud . addActor ( gridCheckBox )  ;", "rotateCheckBox    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . CheckBox (  \" Rotate \"  ,    skin )  ;", "rotateCheckBox . setChecked ( true )  ;", "rotateCheckBox . setPosition (  (  ( hudWidth )     -     ( rotateCheckBox . getWidth (  )  )  )  ,    gridCheckBox . getHeight (  )  )  ;", "hud . addActor ( rotateCheckBox )  ;", "moveCheckBox    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . CheckBox (  \" Move \"  ,    skin )  ;", "moveCheckBox . setChecked ( false )  ;", "moveCheckBox . setPosition (  (  ( hudWidth )     -     ( moveCheckBox . getWidth (  )  )  )  ,    rotateCheckBox . getTop (  )  )  ;", "hud . addActor ( moveCheckBox )  ;", "}", "METHOD_END"], "methodName": ["createHUD"], "fileName": "com.badlogic.gdx.tests.g3d.BaseG3dHudTest"}, {"methodBody": ["METHOD_START", "{", "stringBuilder . append (  \" FPS :     \"  )  . append ( graphics . getFramesPerSecond (  )  )  ;", "if    ( loading )", "stringBuilder . append (  \"    loading .  .  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "com.badlogic.gdx.tests.g3d.BaseG3dHudTest"}, {"methodBody": ["METHOD_START", "{", "ModelBuilder   modelBuilder    =    new   ModelBuilder (  )  ;", "modelBuilder . begin (  )  ;", "MeshPartBuilder   builder    =    modelBuilder . part (  \" grid \"  ,    GL _ LINES ,     (  ( Usage . Position )     |     ( Usage . ColorUnpacked )  )  ,    new   Material (  )  )  ;", "builder . setColor ( LIGHT _ GRAY )  ;", "for    ( float   t    =    GRID _ MIN ;    t    <  =     ( GRID _ MAX )  ;    t    +  =    GRID _ STEP )     {", "builder . line ( t ,     0  ,    GRID _ MIN ,    t ,     0  ,    GRID _ MAX )  ;", "builder . line ( GRID _ MIN ,     0  ,    t ,    GRID _ MAX ,     0  ,    t )  ;", "}", "builder    =    modelBuilder . part (  \" axes \"  ,    GL _ LINES ,     (  ( Usage . Position )     |     ( Usage . ColorUnpacked )  )  ,    new   Material (  )  )  ;", "builder . setColor ( RED )  ;", "builder . line (  0  ,     0  ,     0  ,     1  0  0  ,     0  ,     0  )  ;", "builder . setColor ( GREEN )  ;", "builder . line (  0  ,     0  ,     0  ,     0  ,     1  0  0  ,     0  )  ;", "builder . setColor ( BLUE )  ;", "builder . line (  0  ,     0  ,     0  ,     0  ,     0  ,     1  0  0  )  ;", "axesModel    =    modelBuilder . end (  )  ;", "axesInstance    =    new   graphics . g 3 d . ModelInstance ( axesModel )  ;", "}", "METHOD_END"], "methodName": ["createAxes"], "fileName": "com.badlogic.gdx.tests.g3d.BaseG3dTest"}, {"methodBody": ["METHOD_START", "{", "modelBatch . begin ( cam )  ;", "if    ( showAxes )", "modelBatch . render ( axesInstance )  ;", "if    ( instances    !  =    null )", "render ( modelBatch ,    instances )  ;", "modelBatch . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.g3d.BaseG3dTest"}, {"methodBody": ["METHOD_START", "{", "Model   model    =    assets . get (  \" data / g 3 d / invaders . g 3 dj \"  ,    Model . class )  ;", "for    ( int   i    =     0  ;    i    <     ( model . nodes . size )  ;    i +  +  )     {", "String   id    =    model . nodes . get ( i )  . id ;", "ModelInstance   instance    =    new   ModelInstance ( model ,    id )  ;", "Node   node    =    instance . getNode ( id )  ;", "instance . transform . set ( node . globalTransform )  ;", "node . translation . set (  0  ,     0  ,     0  )  ;", "node . scale . set (  1  ,     1  ,     1  )  ;", "node . rotation . idt (  )  ;", "instance . calculateTransforms (  )  ;", "if    ( id . equals (  \" space \"  )  )     {", "space    =    instance ;", "continue ;", "}", "instances . add ( instance )  ;", "if    ( id . equals (  \" ship \"  )  )", "ship    =    instance ;", "else", "if    ( id . startsWith (  \" block \"  )  )", "blocks . add ( instance )  ;", "else", "if    ( id . startsWith (  \" invader \"  )  )", "invaders . add ( instance )  ;", "}", "loading    =    false ;", "}", "METHOD_END"], "methodName": ["doneLoading"], "fileName": "com.badlogic.gdx.tests.g3d.Basic3DSceneTest"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.g3d.Basic3DTest"}, {"methodBody": ["METHOD_START", "{", "stringBuilder . setLength (  0  )  ;", "stringBuilder . append (  \" GL   calls :     \"  )  ;", "stringBuilder . append ( glProfiler . getCalls (  )  )  ;", "glCallsLabel . setText ( stringBuilder )  ;", "stringBuilder . setLength (  0  )  ;", "stringBuilder . append (  \" Draw   calls :     \"  )  ;", "stringBuilder . append ( glProfiler . getDrawCalls (  )  )  ;", "drawCallsLabel . setText ( stringBuilder )  ;", "stringBuilder . setLength (  0  )  ;", "stringBuilder . append (  \" Shader   switches :     \"  )  ;", "stringBuilder . append ( glProfiler . getShaderSwitches (  )  )  ;", "shaderSwitchesLabel . setText ( stringBuilder )  ;", "stringBuilder . setLength (  0  )  ;", "stringBuilder . append (  \" Texture   bindings :     \"  )  ;", "stringBuilder . append ( glProfiler . getTextureBindings (  )  )  ;", "textureBindsLabel . setText ( stringBuilder )  ;", "stringBuilder . setLength (  0  )  ;", "stringBuilder . append (  \" Vertices :     \"  )  ;", "stringBuilder . append ( glProfiler . getVertexCount (  )  . total )  ;", "vertexCountLabel . setText ( stringBuilder )  ;", "DirectionalLighttribute   dirLigh =     (  ( DirectionalLighttribute )     ( environment . get ( Type )  )  )  ;", "PointLighttribute   pointLigh =     (  ( PointLighttribute )     ( environment . get ( PointLighttribute . Type )  )  )  ;", "stringBuilder . setLength (  0  )  ;", "stringBuilder . append (  \" Ligh    \"  )  ;", "stringBuilder . append (  (  ( dirLigh =  =    null    ?     0     :    dirLighlighsize )     +     ( pointLigh =  =    null    ?     0     :    pointLighlighsize )  )  )  ;", "stringBuilder . append (  \"  ,    Directional :     \"  )  ;", "stringBuilder . append (  ( dirLigh =  =    null    ?     0     :    dirLighlighsize )  )  ;", "stringBuilder . append (  \"  ,    Point :     \"  )  ;", "stringBuilder . append (  ( pointLigh =  =    null    ?     0     :    pointLighlighsize )  )  ;", "lighabel . setText ( stringBuilder )  ;", "glProfiler . reset (  )  ;", "stringBuilder . setLength (  0  )  ;", "super . getStatus ( stringBuilder )  ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "com.badlogic.gdx.tests.g3d.Benchmark3DTest"}, {"methodBody": ["METHOD_START", "{", "return   new   com . badlogic . gdx . graphics . Color ( MathUtils . random (  1  .  0 F )  ,    MathUtils . random (  1  .  0 F )  ,    MathUtils . random (  1  .  0 F )  ,    MathUtils . random (  1  .  0 F )  )  ;", "}", "METHOD_END"], "methodName": ["randomColor"], "fileName": "com.badlogic.gdx.tests.g3d.Benchmark3DTest"}, {"methodBody": ["METHOD_START", "{", "return   new   com . badlogic . gdx . math . Vector 3  ( MathUtils . random (  (  -  1  0  .  0 F )  ,     1  0  .  0 F )  ,    MathUtils . random (  (  -  1  0  .  0 F )  ,     1  0  .  0 F )  ,    MathUtils . random (  (  -  1  0  .  0 F )  ,     1  0  .  0 F )  )  ;", "}", "METHOD_END"], "methodName": ["randomPosition"], "fileName": "com.badlogic.gdx.tests.g3d.Benchmark3DTest"}, {"methodBody": ["METHOD_START", "{", "int   pointLights    =    MathUtils . random (  5  )  ;", "int   directionalLights    =    MathUtils . random (  5  )  ;", "DefaultShader . Config   config    =    new   Config (  )  ;", "config . numDirectionalLights    =    directionalLights ;", "config . numPointLights    =    pointLights ;", "config . numSpotLights    =     0  ;", "modelBatch . dispose (  )  ;", "modelBatch    =    new   ModelBatch ( new   graphics . g 3 d . utils . DefaultShaderProvider ( config )  )  ;", "environment    =    new   Environment (  )  ;", "environment . set ( new   ColorAttribute ( ColorAttribute . AmbientLight ,     0  .  4 F ,     0  .  4 F ,     0  .  4 F ,     1  .  0 F )  )  ;", "for    ( int   i    =     0  ;    i    <    pointLights ;    i +  +  )     {", "environment . add ( new   PointLight (  )  . set ( randomColor (  )  ,    randomPosition (  )  ,    MathUtils . random (  1  0  .  0 F )  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    directionalLights ;    i +  +  )     {", "environment . add ( new   DirectionalLight (  )  . set ( randomColor (  )  ,    randomPosition (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["randomizeLights"], "fileName": "com.badlogic.gdx.tests.g3d.Benchmark3DTest"}, {"methodBody": ["METHOD_START", "{", "delta    =    graphics . getDeltaTime (  )  ;", "instance . transform . val [  1  4  ]     +  =     (  ( delta )     *     4  )     *     ( dir )  ;", "if    (  ( Math . abs ( instance . transform . val [  1  4  ]  )  )     >     5  )     {", "dir    *  =     -  1  ;", "}", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.tests.g3d.FogTest"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.g3d.FogTest"}, {"methodBody": ["METHOD_START", "{", "int   w    =    graphics . getBackBufferWidth (  )  ;", "int   h    =    graphics . getBackBufferHeight (  )  ;", "int   x    =     (  ( int )     ( w    -     ( w    *     0  .  5 F )  )  )  ;", "int   y    =     (  ( int )     ( h    -     ( h    *     0  .  5 F )  )  )  ;", "w    *  =     0  .  5 F ;", "h    *  =     0  .  5 F ;", "gl . glViewport ( x ,    y ,    w ,    h )  ;", "gl . glEnable ( GL _ SCISSOR _ TEST )  ;", "gl . glScissor ( x ,    y ,    w ,    h )  ;", "gl . glClearColor (  1  ,     1  ,     1  ,     1  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "pitch    +  =     2  5     *     ( graphics . getDeltaTime (  )  )  ;", "yaw    +  =     4  5     *     ( graphics . getDeltaTime (  )  )  ;", "cubeInstance . transform . setFromEulerAngles ( yaw ,    pitch ,    roll )  ;", "cubeBatch . begin ( camCube )  ;", "cubeBatch . render ( cubeInstance )  ;", "cubeBatch . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderCube"], "fileName": "com.badlogic.gdx.tests.g3d.FrameBufferCubemapTest"}, {"methodBody": ["METHOD_START", "{", "gl . glViewport (  0  ,     0  ,    graphics . getBackBufferWidth (  )  ,    graphics . getBackBufferHeight (  )  )  ;", "gl . glDisable ( GL _ SCISSOR _ TEST )  ;", "super . render (  )  ;", "camFb . position . set ( cam . position )  ;", "camFb . near    =    cam . near ;", "camFb . far    =    cam . far ;", "fb . begin (  )  ;", "while    ( fb . nextSide (  )  )     {", "fb . getSide (  )  . getUp ( camFb . up )  ;", "fb . getSide (  )  . getDirection ( camFb . direction )  ;", "camFb . update (  )  ;", "gl . glClearColor (  1  ,     1  ,     1  ,     1  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "modelBatch . begin ( camFb )  ;", "for    ( ModelInstance   instance    :    instances )", "modelBatch . render ( instance ,    lights )  ;", "if    (  ( space )     !  =    null )", "modelBatch . render ( space )  ;", "modelBatch . end (  )  ;", "}", "fb . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderScene"], "fileName": "com.badlogic.gdx.tests.g3d.FrameBufferCubemapTest"}, {"methodBody": ["METHOD_START", "{", "final   float   dx    =     (  ( float )     ( x )  )     /     (  ( float )     (  ( width )     -     1  )  )  ;", "final   float   dy    =     (  ( float )     ( y )  )     /     (  ( float )     (  ( h )     -     1  )  )  ;", "final   float   a    =    data [  (  ( y    *     ( width )  )     +    x )  ]  ;", "out . set ( corner 0  0  )  . lerp ( corner 1  0  ,    dx )  . lerp ( tmpV 1  . set ( corner 0  1  )  . lerp ( corner 1  1  ,    dx )  ,    dy )  ;", "out . add ( tmpV 1  . set ( magnitude )  . scl ( a )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getPositionAt"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "final   float   dx    =     (  ( float )     ( x )  )     /     (  ( float )     (  ( width )     -     1  )  )  ;", "final   float   dy    =     (  ( float )     ( y )  )     /     (  ( float )     (  ( h )     -     1  )  )  ;", "final   float   a    =    data [  (  ( y    *     ( width )  )     +    x )  ]  ;", "out . position . set ( corner 0  0  )  . lerp ( corner 1  0  ,    dx )  . lerp ( tmpV 1  . set ( corner 0  1  )  . lerp ( corner 1  1  ,    dx )  ,    dy )  ;", "out . position . add ( tmpV 1  . set ( magnitude )  . scl ( a )  )  ;", "out . color . set ( color 0  0  )  . lerp ( color 1  0  ,    dx )  . lerp ( tmpC . set ( color 0  1  )  . lerp ( color 1  1  ,    dx )  ,    dy )  ;", "out . uv . set ( dx ,    dy )  . scl ( uvScale )  . add ( uvOffset )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getVertexAt"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "int   faces    =     0  ;", "out . set (  0  ,     0  ,     0  )  ;", "Vector 3    center    =    getPositionAt ( tmpV 2  ,    x ,    y )  ;", "Vector 3    left    =     ( x    >     0  )     ?    getPositionAt ( tmpV 3  ,     ( x    -     1  )  ,    y )     :    null ;", "Vector 3    right    =     ( x    <     (  ( width )     -     1  )  )     ?    getPositionAt ( tmpV 4  ,     ( x    +     1  )  ,    y )     :    null ;", "Vector 3    bottom    =     ( y    >     0  )     ?    getPositionAt ( tmpV 5  ,    x ,     ( y    -     1  )  )     :    null ;", "Vector 3    top    =     ( y    <     (  ( h )     -     1  )  )     ?    getPositionAt ( tmpV 6  ,    x ,     ( y    +     1  )  )     :    null ;", "if    (  ( top    !  =    null )     &  &     ( left    !  =    null )  )     {", "out . add ( tmpV 7  . set ( top )  . sub ( center )  . nor (  )  . crs ( tmpV 8  . set ( center )  . sub ( left )  . nor (  )  )  . nor (  )  )  ;", "faces +  +  ;", "}", "if    (  ( left    !  =    null )     &  &     ( bottom    !  =    null )  )     {", "out . add ( tmpV 7  . set ( left )  . sub ( center )  . nor (  )  . crs ( tmpV 8  . set ( center )  . sub ( bottom )  . nor (  )  )  . nor (  )  )  ;", "faces +  +  ;", "}", "if    (  ( bottom    !  =    null )     &  &     ( right    !  =    null )  )     {", "out . add ( tmpV 7  . set ( bottom )  . sub ( center )  . nor (  )  . crs ( tmpV 8  . set ( center )  . sub ( right )  . nor (  )  )  . nor (  )  )  ;", "faces +  +  ;", "}", "if    (  ( right    !  =    null )     &  &     ( top    !  =    null )  )     {", "out . add ( tmpV 7  . set ( right )  . sub ( center )  . nor (  )  . crs ( tmpV 8  . set ( center )  . sub ( top )  . nor (  )  )  . nor (  )  )  ;", "faces +  +  ;", "}", "if    ( faces    !  =     0  )", "out . scl (  (  1  .  0 F    /     (  ( float )     ( faces )  )  )  )  ;", "else", "out . set ( magnitude )  . nor (  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getWeightedNormalAt"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "final   int   bytesPerColor    =     ( format    =  =     ( Format . RGB 8  8  8  )  )     ?     3     :    format    =  =     ( Format . RGBA 8  8  8  8  )     ?     4     :     0  ;", "if    ( bytesPerColor    =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" Unsupported   format ,    should   be   either   RGB 8    or   RGBA 8  \"  )  ;", "if    (  ( data . remaining (  )  )     <     (  ( width    *    height )     *    bytesPerColor )  )", "throw   new   utils . GdxRuntimeException (  \" Incorrect   map   size \"  )  ;", "final   int   startPos    =    data . position (  )  ;", "byte [  ]    source    =    null ;", "int   sourceOffset    =     0  ;", "if    (  ( data . hasArray (  )  )     &  &     (  !  ( data . isReadOnly (  )  )  )  )     {", "source    =    data . array (  )  ;", "sourceOffset    =     ( data . arrayOffset (  )  )     +    startPos ;", "} else    {", "source    =    new   byte [  ( width    *    height )     *    bytesPerColor ]  ;", "data . get ( source )  ;", "data . position ( startPos )  ;", "}", "float [  ]    dest    =    new   float [ width    *    height ]  ;", "for    ( int   i    =     0  ;    i    <     ( dest . length )  ;     +  + i )     {", "int   v    =    source [  ( sourceOffset    +     ( i    *    bytesPerColor )  )  ]  ;", "v    =     ( v    <     0  )     ?     2  5  6     +    v    :    v ;", "dest [ i ]     =     (  ( float )     ( v )  )     /     2  5  5  .  0 F ;", "}", "return   dest ;", "}", "METHOD_END"], "methodName": ["heightColorsToMap"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( map . getWidth (  )  )     !  =     ( width )  )     |  |     (  ( map . getHeight (  )  )     !  =     ( height )  )  )", "throw   new   utils . GdxRuntimeException (  \" Incorrect   map   size \"  )  ;", "set ( map . getPixels (  )  ,    map . getFormat (  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "set ( data ,     0  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . data . length )     >     (  ( data . length )     -    offset )  )", "throw   new   utils . GdxRuntimeException (  \" Incorrect   data   size \"  )  ;", "System . arraycopy ( data ,    offset ,    this . data ,     0  ,    this . data . length )  ;", "update (  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "set ( HeightField . heightColorsToMap ( colorData ,    format ,    width ,    height )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "final   int   w    =     ( width )     -     1  ;", "final   int   h    =     ( h )     -     1  ;", "short [  ]    indices    =    new   short [  ( w    *    h )     *     6  ]  ;", "int   i    =     -  1  ;", "for    ( int   y    =     0  ;    y    <    h ;     +  + y )     {", "for    ( int   x    =     0  ;    x    <    w ;     +  + x )     {", "final   int   c 0  0     =     ( smooth )     ?     ( y    *     ( width )  )     +    x    :     (  ( y    *     2  )     *    w )     +     ( x    *     2  )  ;", "final   int   c 1  0     =    c 0  0     +     1  ;", "final   int   c 0  1     =    c 0  0     +     ( smooth    ?    width    :    w    *     2  )  ;", "final   int   c 1  1     =    c 1  0     +     ( smooth    ?    width    :    w    *     2  )  ;", "indices [  (  +  + i )  ]     =     (  ( short )     ( c 1  1  )  )  ;", "indices [  (  +  + i )  ]     =     (  ( short )     ( c 1  0  )  )  ;", "indices [  (  +  + i )  ]     =     (  ( short )     ( c 0  0  )  )  ;", "indices [  (  +  + i )  ]     =     (  ( short )     ( c 0  0  )  )  ;", "indices [  (  +  + i )  ]     =     (  ( short )     ( c 0  1  )  )  ;", "indices [  (  +  + i )  ]     =     (  ( short )     ( c 1  1  )  )  ;", "}", "}", "mesh . setIndices ( indices )  ;", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "index    *  =    stride ;", "if    (  ( posPos )     >  =     0  )     {", "vertices [  (  ( index    +     ( posPos )  )     +     0  )  ]     =    info . position . x ;", "vertices [  (  ( index    +     ( posPos )  )     +     1  )  ]     =    info . position . y ;", "vertices [  (  ( index    +     ( posPos )  )     +     2  )  ]     =    info . position . z ;", "}", "if    (  ( norPos )     >  =     0  )     {", "vertices [  (  ( index    +     ( norPos )  )     +     0  )  ]     =    info . normal . x ;", "vertices [  (  ( index    +     ( norPos )  )     +     1  )  ]     =    info . normal . y ;", "vertices [  (  ( index    +     ( norPos )  )     +     2  )  ]     =    info . normal . z ;", "}", "if    (  ( uvPos )     >  =     0  )     {", "vertices [  (  ( index    +     ( uvPos )  )     +     0  )  ]     =    info . uv . x ;", "vertices [  (  ( index    +     ( uvPos )  )     +     1  )  ]     =    info . uv . y ;", "}", "if    (  ( colPos )     >  =     0  )     {", "vertices [  (  ( index    +     ( colPos )  )     +     0  )  ]     =    info . color . r ;", "vertices [  (  ( index    +     ( colPos )  )     +     1  )  ]     =    info . color . g ;", "vertices [  (  ( index    +     ( colPos )  )     +     2  )  ]     =    info . color . b ;", "vertices [  (  ( index    +     ( colPos )  )     +     3  )  ]     =    info . color . a ;", "}", "}", "METHOD_END"], "methodName": ["setVertex"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "if    ( smooth )     {", "if    (  ( norPos )     <     0  )", "updaSimple (  )  ;", "else", "updaSmooth (  )  ;", "} else", "updaSharp (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "final   int   w    =     ( width )     -     1  ;", "final   int   h    =     ( h )     -     1  ;", "for    ( int   y    =     0  ;    y    <    h ;     +  + y )     {", "for    ( int   x    =     0  ;    x    <    w ;     +  + x )     {", "final   int   c 0  0     =     (  ( y    *     2  )     *    w )     +     ( x    *     2  )  ;", "final   int   c 1  0     =    c 0  0     +     1  ;", "final   int   c 0  1     =    c 0  0     +     ( w    *     2  )  ;", "final   int   c 1  1     =    c 1  0     +     ( w    *     2  )  ;", "VertexInfo   v 0  0     =    getVertexAt ( vertex 0  0  ,    x ,    y )  ;", "VertexInfo   v 1  0     =    getVertexAt ( vertex 1  0  ,     ( x    +     1  )  ,    y )  ;", "VertexInfo   v 0  1     =    getVertexAt ( vertex 0  1  ,    x ,     ( y    +     1  )  )  ;", "VertexInfo   v 1  1     =    getVertexAt ( vertex 1  1  ,     ( x    +     1  )  ,     ( y    +     1  )  )  ;", "v 0  1  . normal . set ( v 0  1  . position )  . sub ( v 0  0  . position )  . nor (  )  . crs ( tmpV 1  . set ( v 1  1  . position )  . sub ( v 0  1  . position )  . nor (  )  )  ;", "v 1  0  . normal . set ( v 1  0  . position )  . sub ( v 1  1  . position )  . nor (  )  . crs ( tmpV 1  . set ( v 0  0  . position )  . sub ( v 1  0  . position )  . nor (  )  )  ;", "v 0  0  . normal . set ( v 0  1  . normal )  . lerp ( v 1  0  . normal ,     0  .  5 F )  ;", "v 1  1  . normal . set ( v 0  0  . normal )  ;", "setVertex ( c 0  0  ,    v 0  0  )  ;", "setVertex ( c 1  0  ,    v 1  0  )  ;", "setVertex ( c 0  1  ,    v 0  1  )  ;", "setVertex ( c 1  1  ,    v 1  1  )  ;", "}", "}", "mesh . setVertices ( vertices )  ;", "}", "METHOD_END"], "methodName": ["updateSharp"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "for    ( int   x    =     0  ;    x    <     ( width )  ;     +  + x )     {", "for    ( int   y    =     0  ;    y    <     ( h )  ;     +  + y )     {", "setVertex (  (  ( y    *     ( width )  )     +    x )  ,    getVertexAt ( vertex 0  0  ,    x ,    y )  )  ;", "}", "}", "mesh . setVertices ( vertices )  ;", "}", "METHOD_END"], "methodName": ["updateSimple"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "for    ( int   x    =     0  ;    x    <     ( width )  ;     +  + x )     {", "for    ( int   y    =     0  ;    y    <     ( h )  ;     +  + y )     {", "VertexInfo   v    =    getVertexAt ( vertex 0  0  ,    x ,    y )  ;", "getWedNormalAt ( v . normal ,    x ,    y )  ;", "setVertex (  (  ( y    *     ( width )  )     +    x )  ,    v )  ;", "}", "}", "mesh . setVertices ( vertices )  ;", "}", "METHOD_END"], "methodName": ["updateSmooth"], "fileName": "com.badlogic.gdx.tests.g3d.HeightField"}, {"methodBody": ["METHOD_START", "{", "instance    =    new   com . badlogic . gdx . graphics . g 3 d . ModelInstance ( assets . get (  \" data / g 3 d / cube . g 3 dj \"  ,    Model . class )  )  ;", "}", "METHOD_END"], "methodName": ["doneLoading"], "fileName": "com.badlogic.gdx.tests.g3d.ModelLoaderTest"}, {"methodBody": ["METHOD_START", "{", "for    ( Entry < ModelInstance ,    AnimationController >    e    :    animationControllers . entries (  )  )     {", "int   animIndex    =     0  ;", "if    (  ( e . value . current )     !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( e . key . animations . size )  ;    i +  +  )     {", "final   Animation   animation    =    e . key . animations . get ( i )  ;", "if    (  ( e . value . current . animation )     =  =    animation )     {", "animIndex    =    i ;", "break ;", "}", "}", "}", "animIndex    =     ( animIndex    +     1  )     %     (  ( e . key . animations . size )     +     1  )  ;", "e . value . animate (  ( animIndex    =  =     ( e . key . animations . size )     ?    null    :    e . key . animations . get ( animIndex )  . id )  ,     (  -  1  )  ,     1  .  0 F ,    null ,     0  .  2 F )  ;", "}", "}", "METHOD_END"], "methodName": ["switchAnimation"], "fileName": "com.badlogic.gdx.tests.g3d.ModelTest"}, {"methodBody": ["METHOD_START", "{", "float [  ]    verts    =    new   float [  2  0  ]  ;", "int   i    =     0  ;", "verts [  ( i +  +  )  ]     =     -  1  ;", "verts [  ( i +  +  )  ]     =     -  1  ;", "verts [  ( i +  +  )  ]     =     0  ;", "verts [  ( i +  +  )  ]     =     0  .  0 F ;", "verts [  ( i +  +  )  ]     =     0  .  0 F ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "verts [  ( i +  +  )  ]     =     -  1  ;", "verts [  ( i +  +  )  ]     =     0  ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "verts [  ( i +  +  )  ]     =     0  .  0 F ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "verts [  ( i +  +  )  ]     =     0  ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "verts [  ( i +  +  )  ]     =     -  1  ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "verts [  ( i +  +  )  ]     =     0  ;", "verts [  ( i +  +  )  ]     =     0  .  0 F ;", "verts [  ( i +  +  )  ]     =     1  .  0 F ;", "Mesh   mesh    =    new   Mesh ( true ,     4  ,     0  ,    new   graphics . VertexAttribute ( Usage . Position ,     3  ,    ShaderProgram . POSITION _ ATTRIBUTE )  ,    new   graphics . VertexAttribute ( Usage . TextureCoordinates ,     2  ,     (  ( ShaderProgram . TEXCOORD _ ATTRIBUTE )     +     \"  0  \"  )  )  )  ;", "mesh . setVertices ( verts )  ;", "return   mesh ;", "}", "METHOD_END"], "methodName": ["createFullScreenQuad"], "fileName": "com.badlogic.gdx.tests.g3d.MultipleRenderTargetTest"}, {"methodBody": ["METHOD_START", "{", "ParticleController   controller    =    createBillboardController ( colors ,    particleTexture )  ;", "controller . init (  )  ;", "controller . start (  )  ;", "emitters . add ( controller )  ;", "controller . translate ( translation )  ;", "ui . addAction ( new    . RotationAction ( controller ,    actionAxis ,    actionRotation )  )  ;", "}", "METHOD_END"], "methodName": ["addEmitter"], "fileName": "com.badlogic.gdx.tests.g3d.ParticleControllerTest"}, {"methodBody": ["METHOD_START", "{", "RegularEmitter   emitter    =    new   RegularEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  3  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  2  9  0  0  )  ;", "emitter . getLife (  )  . setHigh (  1  0  0  0  )  ;", "emitter . setMaxParticleCount (  3  0  0  0  )  ;", "PointSpawnShapeValue   pointSpawnShapeValue    =    new   PointSpawnShapeValue (  )  ;", "pointSpawnShapeValue . xOffsetValue . setLow (  0  ,     1  .  0 F )  ;", "pointSpawnShapeValue . xOffsetValue . setActive ( true )  ;", "pointSpawnShapeValue . yOffsetValue . setLow (  0  ,     1  .  0 F )  ;", "pointSpawnShapeValue . yOffsetValue . setActive ( true )  ;", "pointSpawnShapeValue . zOffsetValue . setLow (  0  ,     1  .  0 F )  ;", "pointSpawnShapeValue . zOffsetValue . setActive ( true )  ;", "SpawnInfluencer   spawnSource    =    new   SpawnInfluencer ( pointSpawnShapeValue )  ;", "ScaleInfluencer   scaleInfluencer    =    new   ScaleInfluencer (  )  ;", "scaleInfluencer . value . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "scaleInfluencer . value . setScaling ( new   float [  ]  {     1  ,     0     }  )  ;", "scaleInfluencer . value . setLow (  0  )  ;", "scaleInfluencer . value . setHigh (  1  )  ;", "ColorInfluencer . Single   colorInfluencer    =    new   ColorInfluencer . Single (  )  ;", "colorInfluencer . colorValue . setColors ( new   float [  ]  {    colors [  0  ]  ,    colors [  1  ]  ,    colors [  2  ]  ,     0  ,     0  ,     0     }  )  ;", "colorInfluencer . colorValue . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "colorInfluencer . alphaValue . setHigh (  1  )  ;", "colorInfluencer . alphaValue . setTimeline ( new   float [  ]  {     0  ,     0  .  5 F ,     0  .  8 F ,     1     }  )  ;", "colorInfluencer . alphaValue . setScaling ( new   float [  ]  {     0  ,     0  .  1  5 F ,     0  .  5 F ,     0     }  )  ;", "DynamicsInfluencer   dynamicsInfluencer    =    new   DynamicsInfluencer (  )  ;", "BrownianAcceleration   modifier    =    new   BrownianAcceleration (  )  ;", "modifier . strengthValue . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "modifier . strengthValue . setScaling ( new   float [  ]  {     0  ,     1     }  )  ;", "modifier . strengthValue . setHigh (  8  0  )  ;", "modifier . strengthValue . setLow (  1  ,     5  )  ;", "dynamicsInfluencer . velocities . add ( modifier )  ;", "return   new   com . badlogic . gdx . graphics . g 3 d . particles (  \" Billboard   Controller \"  ,    emitter ,    new   com . badlogic . gdx . graphics . g 3 d . particles . renderers . BillboardRenderer ( billboardParticleBatch )  ,    new   com . badlogic . gdx . graphics . g 3 d . particles . influencers . RegionInfluencer . Single ( particleTexture )  ,    spawnSource ,    scaleInfluencer ,    colorInfluencer ,    dynamicsInfluencer )  ;", "}", "METHOD_END"], "methodName": ["createBillboardController"], "fileName": "com.badlogic.gdx.tests.g3d.ParticleControllerTest"}, {"methodBody": ["METHOD_START", "{", "Skin   skin    =    assets . get ( ParticleControllerTest . DEFAULT _ SKIN )  ;", "Table   table    =    new   Table (  )  ;", "table . setFillParent ( true )  ;", "table . top (  )  . left (  )  . add ( new   com . badlogic . gdx . scenes . scene 2 d . ui . Label (  \" FPS    \"  ,    skin )  )  . left (  )  ;", "table . add (  ( fpsLabel    =    new   com . badlogic . gdx . scenes . scene 2 d . ui . Label (  \"  \"  ,    skin )  )  )  . left (  )  . expandX (  )  . row (  )  ;", "ui . addActor ( table )  ;", "}", "METHOD_END"], "methodName": ["setupUI"], "fileName": "com.badlogic.gdx.tests.g3d.ParticleControllerTest"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )", "return ;", "if    (  ( cubemap )     !  =    null )     {", "cubemap . dispose (  )  ;", "cubemap    =    null ;", "}", "if    ( name . equals (  \"  < none >  \"  )  )     {", "if    ( environment . has ( EnvironmentMap )  )     {", "environment . remove ( EnvironmentMap )  ;", "shaderProvider . clear (  )  ;", "}", "} else    {", "FileHandle   root    =    files . internal (  \" data / g 3 d / environment \"  )  ;", "FacedCubemapData   faces    =    new   FacedCubemapData ( root . child (  ( name    +     \"  _ PX . png \"  )  )  ,    root . child (  ( name    +     \"  _ NX . png \"  )  )  ,    root . child (  ( name    +     \"  _ PY . png \"  )  )  ,    root . child (  ( name    +     \"  _ NY . png \"  )  )  ,    root . child (  ( name    +     \"  _ PZ . png \"  )  )  ,    root . child (  ( name    +     \"  _ NZ . png \"  )  )  ,    false )  ;", "cubemap    =    new   graphics . Cubemap ( faces )  ;", "faces . load ( NegativeX ,    root . child (  ( name    +     \"  _ NX . png \"  )  )  )  ;", "cubemap . load ( faces )  ;", "if    (  !  ( environment . has ( EnvironmentMap )  )  )", "shaderProvider . clear (  )  ;", "environment . set ( new   CubemapAttribute ( CubemapAttribute . EnvironmentMap ,    cubemap )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderCollectionTest"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )", "return ;", "if    (  ( currentlyLoading )     !  =    null )     {", "app . error (  \" ModelTest \"  ,     \" Wait   for   the   current   model / material   to   be   loaded .  \"  )  ;", "return ;", "}", "currentlyLoading    =     (  \" data / g 3 d / materials /  \"     +    name )     +     \"  . g 3 dj \"  ;", "loadingMaterial    =    true ;", "if    (  !  ( name . equals ( currentMaterial )  )  )", "assets . load ( currentlyLoading ,    graphics . g 3 d . Model . class )  ;", "loading    =    true ;", "}", "METHOD_END"], "methodName": ["setMaterial"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderCollectionTest"}, {"methodBody": ["METHOD_START", "{", "shaderProvider . error    =    false ;", "if    ( name . equals (  \"  < default >  \"  )  )     {", "shaderProvider . config . vertex    =    null ;", "shaderProvider . config . fragment    =    null ;", "shaderProvider . name    =     \" default \"  ;", "} else    {", "Loader   loader    =    new   Loader ( shaderRoot )  ;", "shaderProvider . config . vertex    =    loader . load (  ( name    +     \"  . glsl : VS \"  )  )  ;", "shaderProvider . config . fragment    =    loader . load (  ( name    +     \"  . glsl : FS \"  )  )  ;", "shaderProvider . name    =    name ;", "}", "shaderProvider . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setShader"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderCollectionTest"}, {"methodBody": ["METHOD_START", "{", "for    ( Entry < ModelInstance ,    AnimationController >    e    :    animationControllers . entries (  )  )     {", "int   animIndex    =     0  ;", "if    (  ( e . value . current )     !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( e . key . animations . size )  ;    i +  +  )     {", "final   Animation   animation    =    e . key . animations . get ( i )  ;", "if    (  ( e . value . current . animation )     =  =    animation )     {", "animIndex    =    i ;", "break ;", "}", "}", "}", "animIndex    =     ( animIndex    +     1  )     %     ( e . key . animations . size )  ;", "e . value . animate ( e . key . animations . get ( animIndex )  . id ,     (  -  1  )  ,     1  .  0 F ,    null ,     0  .  2 F )  ;", "}", "}", "METHOD_END"], "methodName": ["switchAnimation"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderCollectionTest"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   out    =    new   StringBuilder (  )  ;", "load ( out ,    name )  ;", "includes . clear (  )  ;", "return   out . toString (  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderLoader"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   out    =    new   StringBuilder (  )  ;", "load ( out ,    vertex )  ;", "vertex    =    out . toString (  )  ;", "includes . clear (  )  ;", "out . setLength (  0  )  ;", "load ( out ,    fragment )  ;", "fragment    =    out . toString (  )  ;", "includes . clear (  )  ;", "return   new   Program ( vertex ,    fragment )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderLoader"}, {"methodBody": ["METHOD_START", "{", "final   int   idx    =    name . lastIndexOf (  '  :  '  )  ;", "final   String   fileName    =     ( idx    <     0  )     ?    name    :    name . substring (  0  ,    idx )  ;", "final   String   snipName    =     (  ( idx    <     0  )     |  |     ( idx    >  =     (  ( name . length (  )  )     -     1  )  )  )     ?     \"  \"     :    name . substring (  ( idx    +     1  )  )  ;", "ObjectMap < String ,    String >    snips    =    snippets . get ( fileName ,    null )  ;", "if    ( snips    =  =    null )     {", "snips    =    parse ( root . child ( fileName )  )  ;", "snippets . put ( fileName ,    snips )  ;", "}", "String   result    =    snips . get ( snipName ,    null )  ;", "if    ( result    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" No   snippet    [  \"     +    snipName )     +     \"  ]    in   file    \"  )     +     ( root . child ( fileName )  . path (  )  )  )  )  ;", "parse ( out ,    fileName ,    result )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderLoader"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    String >    result    =    new   ObjectMap < String ,    String >  (  )  ;", "BufferedReader   reader    =    file . reader (  1  0  2  4  )  ;", "String   line ;", "String   snipName    =     \"  \"  ;", ". stringBuilder . setLength (  0  )  ;", "int   idx ;", "try    {", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "if    (  (  (  ( line . length (  )  )     >     3  )     &  &     (  ( line . charAt (  0  )  )     =  =     '  [  '  )  )     &  &     (  ( idx    =    line . indexOf (  '  ]  '  )  )     >     1  )  )     {", "if    (  (  ( snipName . length (  )  )     >     0  )     |  |     (  (  . stringBuilder . length (  )  )     >     0  )  )", "result . put ( snipName ,     . stringBuilder . toString (  )  )  ;", ". stringBuilder . setLength (  0  )  ;", "snipName    =    line . substring (  1  ,    idx )  ;", "} else", ". stringBuilder . append ( line . trim (  )  )  . append (  \"  \\ r \\ n \"  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   GdxRuntimeException ( e )  ;", "}", "if    (  (  ( snipName . length (  )  )     >     0  )     |  |     (  (  . stringBuilder . length (  )  )     >     0  )  )", "result . put ( snipName ,     . stringBuilder . toString (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderLoader"}, {"methodBody": ["METHOD_START", "{", "String [  ]    lines    =    code . split (  \"  \\ n \"  )  ;", "int   idx ;", "int   jdx ;", "for    ( final   String   line    :    lines )     {", "if    (  (  (  ( idx    =    line . indexOf (  \"  # include \"  )  )     =  =     0  )     &  &     (  ( idx    =    line . indexOf (  \"  \\  \"  \"  ,    idx )  )     >     0  )  )     &  &     (  ( jdx    =    line . indexOf (  \"  \\  \"  \"  ,     (  +  + idx )  )  )     >    idx )  )     {", "String   name    =    line . substring ( idx ,    jdx )  ;", "if    (  ( name . length (  )  )     >     0  )     {", "if    (  ( name . charAt (  0  )  )     =  =     '  :  '  )", "name    =    currentFile    +    name ;", "if    (  !  ( includes . contains ( name ,    false )  )  )     {", "includes . add ( name )  ;", "l ( out ,    name )  ;", "}", "}", "} else", "out . append ( line . trim (  )  )  . append (  \"  \\ r \\ n \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.tests.g3d.ShaderLoader"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.g3d.ShadowMappingTest"}, {"methodBody": ["METHOD_START", "{", "shapeRenderer . setProjectionMatrix ( cam . combined )  ;", "shapeRenderer . begin ( Line )  ;", "for    ( Node   node    :    instance . nodes )     {", "shapeRenderer . setColor (  ( node . isAnimated    ?    Color . RED    :    Color . YELLOW )  )  ;", "node . globalTransform . getTranslation (  . tmpV )  ;", "shapeRenderer . box (  . tmpV . x ,     . tmpV . y ,     . tmpV . z ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F )  ;", "for    ( Node   child    :    node . getChildren (  )  )", "renderSkeleton (  . tmpV ,    child )  ;", "}", "shapeRenderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderSkeleton"], "fileName": "com.badlogic.gdx.tests.g3d.SkeletonTest"}, {"methodBody": ["METHOD_START", "{", "final   Vector 3    pos    =    SkeletonTest . vectorPool . obtain (  )  ;", "node . globalTransform . getTranslation ( pos )  ;", "shapeRenderer . setColor (  ( node . isAnimated    ?    Color . RED    :    Color . YELLOW )  )  ;", "shapeRenderer . box ( pos . x ,    pos . y ,    pos . z ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F )  ;", "shapeRenderer . setColor ( WHITE )  ;", "shapeRenderer . line ( from . x ,    from . y ,    from . z ,    pos . x ,    pos . y ,    pos . z )  ;", "for    ( Node   child    :    node . getChildren (  )  )", "renderSkeleton ( pos ,    child )  ;", "SkeletonTest . vectorPool . free ( pos )  ;", "}", "METHOD_END"], "methodName": ["renderSkeleton"], "fileName": "com.badlogic.gdx.tests.g3d.SkeletonTest"}, {"methodBody": ["METHOD_START", "{", "for    ( Entry < ModelInstance ,    AnimationController >    e    :    animationControllers . entries (  )  )     {", "int   animIndex    =     0  ;", "if    (  ( e . value . current )     !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( e . key . animations . size )  ;    i +  +  )     {", "final   Animation   animation    =    e . key . animationet ( i )  ;", "if    (  ( e . value . current . animation )     =  =    animation )     {", "animIndex    =    i ;", "break ;", "}", "}", "}", "animIndex    =     ( animIndex    +     1  )     %     ( e . key . animations . size )  ;", "e . value . animate ( e . key . animationet ( animIndex )  . id ,     (  -  1  )  ,     1  .  0 F ,    null ,     0  .  2 F )  ;", "}", "}", "METHOD_END"], "methodName": ["switchAnimation"], "fileName": "com.badlogic.gdx.tests.g3d.SkeletonTest"}, {"methodBody": ["METHOD_START", "{", "int   pixel    =    heightmap . getPixel (  (  ( int )     (  ( i    /     1  0  0  .  0 F )     *     ( heightmap . getWidth (  )  )  )  )  ,     (  ( int )     (  ( j    /     1  0  0  .  0 F )     *     ( heightmap . getHeight (  )  )  )  )  )  ;", "tmpColor . set ( pixel )  ;", "vertsOut [  ( idx +  +  )  ]     =    i    /     5  .  0 F ;", "vertsOut [  ( idx +  +  )  ]     =     (  ( tmpColor . r )     *     2  5  .  0 F )     /     5  .  0 F ;", "vertsOut [  ( idx +  +  )  ]     =    j    /     5  .  0 F ;", "vertsOut [  ( idx +  +  )  ]     =    i    /     2  0  .  0 F ;", "vertsOut [  ( idx +  +  )  ]     =    j    /     2  0  .  0 F ;", "vertsOut [  ( idx +  +  )  ]     =     (  ( tmpColor . r )     *     3  .  0 F )     -     0  .  5 F ;", "ren   idx ;", "}", "METHOD_END"], "methodName": ["addVertex"], "fileName": "com.badlogic.gdx.tests.g3d.TextureArrayTest"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.g3d.TextureRegion3DTest"}, {"methodBody": ["METHOD_START", "{", "frameBuffers [ n ]  . begin (  )  ;", "}", "METHOD_END"], "methodName": ["beginPass"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "frameBuffers [ n ]  . end (  )  ;", "}", "METHOD_END"], "methodName": ["endPass"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   currentLight ;", "}", "METHOD_END"], "methodName": ["getCurrentLight"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   currentLightProperties ;", "}", "METHOD_END"], "methodName": ["getCurrentLightProperties"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   currentPass ;", "}", "METHOD_END"], "methodName": ["getCurrentPass"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   dirCameras ;", "}", "METHOD_END"], "methodName": ["getDirectionalCameras"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   pointCameras ;", "}", "METHOD_END"], "methodName": ["getPointCameras"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   spotCameras ;", "}", "METHOD_END"], "methodName": ["getSpotCameras"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "if    ( n    >  =     ( getPassQuantity (  )  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Can ' t   get   texture    \"     +    n )  )  ;", "return   frameBuffers [ n ]  . getColorBufferTexture (  )  ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   lp . camera ;", "}", "METHOD_END"], "methodName": ["interceptCamera"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dirCameraIterator . hasNext (  )  )  )", "return   null ;", "Entry < DirectionalLight ,     . LightProperties >    e    =    dirCameraIterator . next (  )  ;", "currentLight    =    e . key ;", "currentLightProperties    =    e . value ;", ". LightProperties   lp    =    e . value ;", "processViewport ( lp ,    false )  ;", "return   lp ;", "}", "METHOD_END"], "methodName": ["nextDirectional"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( pointCameraIterator . hasNext (  )  )  )     &  &     (  ( currentPointSide )     >     5  )  )", "return   null ;", "if    (  ( currentPointSide )     >     5  )", "currentPointSide    =     0  ;", "if    (  ( currentPointSide )     =  =     0  )     {", "Entry < PointLight ,     . PointLightProperties >    e    =    pointCameraIterator . next (  )  ;", "currentLight    =    e . key ;", "currentPointProperties    =    e . value ;", "}", "if    ( currentPointProperties . properties . containsKey ( CubemapSide . values (  )  [ currentPointSide ]  )  )     {", ". LightProperties   lp    =    currentPointProperties . properties . get ( CubemapSide . values (  )  [ currentPointSide ]  )  ;", "currentLightProperties    =    lp ;", "currentPointSide    +  =     1  ;", "if    (  !  ( lightFilter . filter ( pointCameras . findKey ( currentPointProperties ,    true )  ,    lp . camera ,    this . camera )  )  )     {", "return   nextPoint (  )  ;", "}", "processViewport ( lp ,    true )  ;", "return   lp ;", "}", "currentPointSide    +  =     1  ;", "return   nextPoint (  )  ;", "}", "METHOD_END"], "methodName": ["nextPoint"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( spotCameraIterator . hasNext (  )  )  )", "return   null ;", "Entry < SpotLight ,     . LightProperties >    e    =    spotCameraIterator . next (  )  ;", "currentLight    =    e . key ;", "currentLightProperties    =    e . value ;", ". LightProperties   lp    =    e . value ;", "if    (  !  ( lightFilter . filter ( spotCameras . findKey ( lp ,    true )  ,    lp . camera ,    this . camera )  )  )     {", "return   nextSpot (  )  ;", "}", "processViewport ( lp ,    true )  ;", "return   lp ;", "}", "METHOD_END"], "methodName": ["nextSpot"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "Camera   camera    =    lp . camera ;", "MapAllocator . MapRegion   r    =    allocator . nextResult ( currentLight )  ;", "if    ( r    =  =    null )", "return ;", "TextureRegion   region    =    lp . region ;", "region . setTexture ( frameBuffers [ currentPass ]  . getColorBufferTexture (  )  )  ;", "gl . glViewport ( r . x ,    r . y ,    r . width ,    r . height )  ;", "gl . glScissor (  (  ( r . x )     +     1  )  ,     (  ( r . y )     +     1  )  ,     (  ( r . width )     -     2  )  ,     (  ( r . height )     -     2  )  )  ;", "region . setRegion ( r . x ,    r . y ,    r . width ,    r . height )  ;", "if    ( cameraViewport )     {", "camera . viewportHeight    =    r . height ;", "camera . viewportWidth    =    r . width ;", "camera . update (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processViewport"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.BaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "allocator . begin (  )  ;", "gl . glClearColor (  1  ,     1  ,     1  ,     1  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "gl . glEnable ( GL _ SCISSOR _ TEST )  ;", "}", "METHOD_END"], "methodName": ["beginPass1"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.FirstPassBaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "allocator . end (  )  ;", "gl . glDisable ( GL _ SCISSOR _ TEST )  ;", "}", "METHOD_END"], "methodName": ["endPass1"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.FirstPassBaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "frameBuffers [ FirstPassBaseShadowSystem . FIRST _ PASS ]     =    new   com . badlogic . gdx . graphics . glutils . FrameBuffer ( Format . RGBA 8  8  8  8  ,    allocator . getWidth (  )  ,    allocator . getHeight (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["init1"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.FirstPassBaseShadowSystem"}, {"methodBody": ["METHOD_START", "{", "gl . glClearColor (  0  ,     0  ,     0  ,     0  )  ;", "gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "firstCallP 2     =    true ;", "nbCall    =     0  ;", "}", "METHOD_END"], "methodName": ["beginPass2"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.ClassicalShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   getTexture ( ClassicalShadowSystem . SECOND _ PASS )  ;", "}", "METHOD_END"], "methodName": ["getMainTexture"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.ClassicalShadowSystem"}, {"methodBody": ["METHOD_START", "{", "frameBuffers [ ClassicalShadowSystem . SECOND _ PASS ]     =    new   com . badlogic . gdx . graphics . glutils . FrameBuffer ( Format . RGBA 8  8  8  8  ,    graphics . getBackBufferWidth (  )  ,    graphics . getBackBufferHeight (  )  ,    true )  ;", "passShaderProviders [ ClassicalShadowSystem . SECOND _ PASS ]     =    new   Pass 2 ShaderProvider ( new   Pass 2 Shader . Config ( this )  )  ;", "}", "METHOD_END"], "methodName": ["init2"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.ClassicalShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   firstCallPass 2  ;", "}", "METHOD_END"], "methodName": ["isFirstCallPass2"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.ClassicalShadowSystem"}, {"methodBody": ["METHOD_START", "{", "return   DefaultShader . createPrefix ( renderable ,    config )  ;", "}", "METHOD_END"], "methodName": ["createPrefix"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.MainShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( MainShader . defaultFragmentShader )     =  =    null )", "MainShader . defaultFragmentShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / classical / main . fragment . glsl \"  )  . readString (  )  ;", "return   MainShader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.MainShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( MainShader . defaultVertexShader )     =  =    null )", "MainShader . defaultVertexShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / classical / main . vertex . glsl \"  )  . readString (  )  ;", "return   MainShader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.MainShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Pass 1 Shader . defaultFragmentShader )     =  =    null )", "Pass 1 Shader . defaultFragmentShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / classical / pass 1  . fragment . glsl \"  )  . readString (  )  ;", "return   Pass 1 Shader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.Pass1Shader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Pass 1 Shader . defaultVertexShader )     =  =    null )", "Pass 1 Shader . defaultVertexShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / classical / pass 1  . vertex . glsl \"  )  . readString (  )  ;", "return   Pass 1 Shader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.Pass1Shader"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =    DefaultShader . createPrefix ( renderable ,    config )  ;", "boolean   dir    =     ( configSystem . getCurrentLight (  )  )    instanceof   DirectionalLight ;", "if    ( dir )", "prefix    +  =     \"  # define   directionalLight \\ n \"  ;", "else", "prefix    +  =     \"  # define   spotLight \\ n \"  ;", "return   prefix ;", "}", "METHOD_END"], "methodName": ["createPrefix"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.Pass2Shader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Pass 2 Shader . defaultFragmentShader )     =  =    null )", "Pass 2 Shader . defaultFragmentShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / classical / pass 2  . fragment . glsl \"  )  . readString (  )  ;", "return   Pass 2 Shader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.Pass2Shader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Pass 2 Shader . defaultVertexShader )     =  =    null )", "Pass 2 Shader . defaultVertexShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / classical / pass 2  . vertex . glsl \"  )  . readString (  )  ;", "return   Pass 2 Shader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.classical.Pass2Shader"}, {"methodBody": ["METHOD_START", "{", "final   DirectionalLightsAttribute   dla    =    attributes . get ( DirectionalLightsAttribute . class ,    Type )  ;", "final   Array < DirectionalLight >    dirs    =     ( dla    =  =    null )     ?    null    :    dla . lights ;", "if    (  ( dirLightsLoc )     >  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( directionalLights . length )  ;    i +  +  )     {", "if    (  ( dirs    =  =    null )     |  |     (  ( dirs . size )     <  =    i )  )     {", "continue ;", "}", "int   idx    =     ( dirSLoc )     +     ( i    *     ( dirSSize )  )  ;", "ObjectMap < DirectionalLight ,    BaseShadowSystem . LightProperties >    dirCameras    =    shadowSystem . getDirectionalCameras (  )  ;", "DirectionalLight   dl    =    dirs . get ( i )  ;", "if    ( shadowSystem . hasLight ( dl )  )     {", "final   TextureRegion   tr    =    dirCameras . get ( dl )  . region ;", "Camera   cam    =    dirCameras . get ( dl )  . camera ;", "if    ( cam    !  =    null )     {", "program . setUniformf (  ( idx    +     ( dirSUvTransformOffset )  )  ,    tr . getU (  )  ,    tr . getV (  )  ,     (  ( tr . getU 2  (  )  )     -     ( tr . getU (  )  )  )  ,     (  ( tr . getV 2  (  )  )     -     ( tr . getV (  )  )  )  )  ;", "idx    =     ( dirShadowMapProjViewTransLoc )     +     ( i    *     ( dirShadowMapProjViewTransSize )  )  ;", "program . setUniformMatrix ( idx ,    dirCameras . get ( dl )  . camera . combined )  ;", "}", "}", "if    (  ( dirLightsSize )     <  =     0  )", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["bindDirectionalShadows"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.MainShader"}, {"methodBody": ["METHOD_START", "{", "final   SpotLightsAttribute   sla    =    attributes . get ( SpotLightsAttribute . class ,    Type )  ;", "final   Array < SpotLight >    spots    =     ( sla    =  =    null )     ?    null    :    sla . lights ;", "if    (  ( spotLightsLoc )     >  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( spotLights . length )  ;    i +  +  )     {", "if    (  ( spots    =  =    null )     |  |     (  ( spots . size )     <  =    i )  )     {", "continue ;", "}", "int   idx    =     ( spotSLoc )     +     ( i    *     ( spotSSize )  )  ;", "ObjectMap < SpotLight ,    BaseShadowSystem . LightProperties >    spotCameras    =    shadowSystem . getSpotCameras (  )  ;", "SpotLight   sl    =    spots . get ( i )  ;", "if    ( shadowSystem . hasLight ( sl )  )     {", "final   TextureRegion   tr    =    spotCameras . get ( sl )  . region ;", "Camera   cam    =    spotCameras . get ( sl )  . camera ;", "if    ( cam    !  =    null )     {", "program . setUniformf (  ( idx    +     ( spotSUvTransformOffset )  )  ,    tr . getU (  )  ,    tr . getV (  )  ,     (  ( tr . getU 2  (  )  )     -     ( tr . getU (  )  )  )  ,     (  ( tr . getV 2  (  )  )     -     ( tr . getV (  )  )  )  )  ;", "idx    =     ( spotShadowMapProjViewTransLoc )     +     ( i    *     ( spotShadowMapProjViewTransSize )  )  ;", "program . setUniformMatrix ( idx ,    spotCameras . get ( sl )  . camera . combined )  ;", "}", "}", "if    (  ( spotLightsSize )     <  =     0  )", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["bindSpotShadows"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.MainShader"}, {"methodBody": ["METHOD_START", "{", "return   DefaultShader . createPrefix ( renderable ,    config )  ;", "}", "METHOD_END"], "methodName": ["createPrefix"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.MainShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( MainShader . defaultFragmentShader )     =  =    null )", "MainShader . defaultFragmentShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / realistic / main . fragment . glsl \"  )  . readString (  )  ;", "return   MainShader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.MainShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( MainShader . defaultVertexShader )     =  =    null )", "MainShader . defaultVertexShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / realistic / main . vertex . glsl \"  )  . readString (  )  ;", "return   MainShader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.MainShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Pass 1 Shader . defaultFragmentShader )     =  =    null )", "Pass 1 Shader . defaultFragmentShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / realistic / pass 1  . fragment . glsl \"  )  . readString (  )  ;", "return   Pass 1 Shader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.Pass1Shader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Pass 1 Shader . defaultVertexShader )     =  =    null )", "Pass 1 Shader . defaultVertexShader    =    Gdx . files . classpath (  \" com / badlogic / gdx / tests / g 3 d / shadows / system / realistic / pass 1  . vertex . glsl \"  )  . readString (  )  ;", "return   Pass 1 Shader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.Pass1Shader"}, {"methodBody": ["METHOD_START", "{", "return   this . getTexture ( FirstPassBaseShadowSystem . FIRST _ PASS )  ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.system.realistic.RealisticShadowSystem"}, {"methodBody": ["METHOD_START", "{", "float   radius    =     ( bb 1  . getDimensions ( tmpV )  . len (  )  )     *     0  .  5 F ;", "bb 1  . getCenter ( tmpV )  ;", "float   distance    =    tmpV . dst ( camera . position )  ;", "float   near    =    distance    -    radius ;", "float   far    =    distance    +    radius ;", "if    ( near    <  =     0  )", "near    =     . CAMERA _ NEAR ;", "if    ( far    <  =     0  )", "far    =     . CAMERA _ FAR ;", "camera . near    =    near ;", "camera . far    =    far ;", "camera . update (  )  ;", "}", "METHOD_END"], "methodName": ["computeResult"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.utils.AABBNearFarAnalyzer"}, {"methodBody": ["METHOD_START", "{", "for    ( RenderableProvider   renderableProvider    :    renderableProviders )     {", "renderableProvider . getRenderables ( renderables ,    renderablesPool )  ;", "}", "}", "METHOD_END"], "methodName": ["getRenderables"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.utils.AABBNearFarAnalyzer"}, {"methodBody": ["METHOD_START", "{", "camera . near    =    AABBNearFarAnalyzer . CAMERA _ NEAR ;", "camera . far    =    AABBNearFarAnalyzer . CAMERA _ FAR ;", "camera . update (  )  ;", "}", "METHOD_END"], "methodName": ["prepareCamera"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.utils.AABBNearFarAnalyzer"}, {"methodBody": ["METHOD_START", "{", "return   mapQuantity ;", "}", "METHOD_END"], "methodName": ["getMapQuantity"], "fileName": "com.badlogic.gdx.tests.g3d.shadows.utils.FixedShadowMapAllocator"}, {"methodBody": ["METHOD_START", "{", "float [  ]  [  ]    baseNoise    =    PerlinNoiseGenerator . generateWhiteNoise ( width ,    height )  ;", "float [  ]  [  ]    noise    =    PerlinNoiseGenerator . generatePerlinNoise ( baseNoise ,    octaveCount )  ;", "byte [  ]    bytes    =    new   byte [  ( baseNoise . length )     *     ( baseNoise [  0  ]  . length )  ]  ;", "int   idx    =     0  ;", "int   range    =    max    -    min ;", "for    ( int   y    =     0  ;    y    <    height ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <    width ;    x +  +  )     {", "bytes [  ( idx +  +  )  ]     =     (  ( byte )     (  (  ( noise [ x ]  [ y ]  )     *    range )     +    min )  )  ;", "}", "}", "return   bytes ;", "}", "METHOD_END"], "methodName": ["generateHeightMap"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "int   width    =    baseNoise . length ;", "int   height    =    baseNoise [  0  ]  . length ;", "float [  ]  [  ]  [  ]    smoothNoise    =    new   float [ octaveCount ]  [  ]  [  ]  ;", "float   persistance    =     0  .  7 F ;", "for    ( int   i    =     0  ;    i    <    octaveCount ;    i +  +  )     {", "smoothNoise [ i ]     =     . generateSmoothNoise ( baseNoise ,    i )  ;", "}", "float [  ]  [  ]    perlinNoise    =    new   float [ width ]  [ height ]  ;", "float   amplitude    =     1  .  0 F ;", "float   totalAmplitude    =     0  .  0 F ;", "for    ( int   octave    =    octaveCount    -     1  ;    octave    >  =     0  ;    octave -  -  )     {", "amplitude    *  =    persistance ;", "totalAmplitude    +  =    amplitude ;", "for    ( int   i    =     0  ;    i    <    width ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    height ;    j +  +  )     {", "perlinNoise [ i ]  [ j ]     +  =     ( smoothNoise [ octave ]  [ i ]  [ j ]  )     *    amplitude ;", "}", "}", "}", "for    ( int   i    =     0  ;    i    <    width ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    height ;    j +  +  )     {", "perlinNoise [ i ]  [ j ]     /  =    totalAmplitude ;", "}", "}", "return   perlinNoise ;", "}", "METHOD_END"], "methodName": ["generatePerlinNoise"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "float [  ]  [  ]    baseNoise    =    PerlinNoiseGenerator . generateWhiteNoise ( width ,    height )  ;", "return   PerlinNoiseGenerator . generatePerlinNoise ( baseNoise ,    octaveCount )  ;", "}", "METHOD_END"], "methodName": ["generatePerlinNoise"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    PerlinNoiseGenerator . generateHeightMap ( width ,    height ,    min ,    max ,    octaveCount )  ;", "Pixmap   pixmap    =    new   Pixmap ( width ,    height ,    Format . RGBA 8  8  8  8  )  ;", "for    ( int   i    =     0  ,    idx    =     0  ;    i    <     ( bytes . length )  ;    i +  +  )     {", "byte   val    =    bytes [ i ]  ;", "pixmap . getPixels (  )  . put (  ( idx +  +  )  ,    val )  ;", "pixmap . getPixels (  )  . put (  ( idx +  +  )  ,    val )  ;", "pixmap . getPixels (  )  . put (  ( idx +  +  )  ,    val )  ;", "pixmap . getPixels (  )  . put (  ( idx +  +  )  ,     (  ( byte )     (  2  5  5  )  )  )  ;", "}", "return   pixmap ;", "}", "METHOD_END"], "methodName": ["generatePixmap"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "int   width    =    baseNoise . length ;", "int   height    =    baseNoise [  0  ]  . length ;", "float [  ]  [  ]    smoothNoise    =    new   float [ width ]  [ height ]  ;", "int   samplePeriod    =     1     <  <    octave ;", "float   sampleFrequency    =     1  .  0 F    /    samplePeriod ;", "for    ( int   i    =     0  ;    i    <    width ;    i +  +  )     {", "int   sample _ i 0     =     ( i    /    samplePeriod )     *    samplePeriod ;", "int   sample _ i 1     =     ( sample _ i 0     +    samplePeriod )     %    width ;", "float   horizontal _ blend    =     ( i    -    sample _ i 0  )     *    sampleFrequency ;", "for    ( int   j    =     0  ;    j    <    height ;    j +  +  )     {", "int   sample _ j 0     =     ( j    /    samplePeriod )     *    samplePeriod ;", "int   sample _ j 1     =     ( sample _ j 0     +    samplePeriod )     %    height ;", "float   vertical _ blend    =     ( j    -    sample _ j 0  )     *    sampleFrequency ;", "float   top    =     . interpolate ( baseNoise [ sample _ i 0  ]  [ sample _ j 0  ]  ,    baseNoise [ sample _ i 1  ]  [ sample _ j 0  ]  ,    horizontal _ blend )  ;", "float   bottom    =     . interpolate ( baseNoise [ sample _ i 0  ]  [ sample _ j 1  ]  ,    baseNoise [ sample _ i 1  ]  [ sample _ j 1  ]  ,    horizontal _ blend )  ;", "smoothNoise [ i ]  [ j ]     =     . interpolate ( top ,    bottom ,    vertical _ blend )  ;", "}", "}", "return   smoothNoise ;", "}", "METHOD_END"], "methodName": ["generateSmoothNoise"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    heightMap    =    PerlinNoiseGenerator . generateHeightMap ( voxelWorld . voxelsX ,    voxelWorld . voxelsZ ,    min ,    max ,    octaveCount )  ;", "int   idx    =     0  ;", "for    ( int   z    =     0  ;    z    <     ( voxelWorld . voxelsZ )  ;    z +  +  )     {", "for    ( int   x    =     0  ;    x    <     ( voxelWorld . voxelsX )  ;    x +  +  )     {", "voxelWorld . setColumn ( x ,    heightMap [  ( idx +  +  )  ]  ,    z ,     (  ( byte )     (  1  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["generateVoxels"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "float [  ]  [  ]    noise    =    new   float [ width ]  [ height ]  ;", "for    ( int   y    =     0  ;    y    <    height ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <    width ;    x +  +  )     {", "noise [ x ]  [ y ]     =    MathUtils . random (  )  ;", "}", "}", "return   noise ;", "}", "METHOD_END"], "methodName": ["generateWhiteNoise"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "return    ( x 0     *     (  1     -    alpha )  )     +     ( alpha    *    x 1  )  ;", "}", "METHOD_END"], "methodName": ["interpolate"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.PerlinNoiseGenerator"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   vertexOffset    =     0  ;", "for    ( int   y    =     0  ;    y    <     ( height )  ;    y +  +  )     {", "for    ( int   z    =     0  ;    z    <     ( depth )  ;    z +  +  )     {", "for    ( int   x    =     0  ;    x    <     ( width )  ;    x +  +     ,    i +  +  )     {", "byte   voxel    =    voxels [ i ]  ;", "if    ( voxel    =  =     0  )", "continue ;", "if    ( y    <     (  ( height )     -     1  )  )     {", "if    (  ( voxels [  ( i    +     ( topOffset )  )  ]  )     =  =     0  )", "vertexOffset    =     . createTop ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "} else    {", "vertexOffset    =     . createTop ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "}", "if    ( y    >     0  )     {", "if    (  ( voxels [  ( i    +     ( bottomOffset )  )  ]  )     =  =     0  )", "vertexOffset    =     . createBottom ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "} else    {", "vertexOffset    =     . createBottom ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "}", "if    ( x    >     0  )     {", "if    (  ( voxels [  ( i    +     ( leftOffset )  )  ]  )     =  =     0  )", "vertexOffset    =     . createLeft ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "} else    {", "vertexOffset    =     . createLeft ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "}", "if    ( x    <     (  ( width )     -     1  )  )     {", "if    (  ( voxels [  ( i    +     ( rightOffset )  )  ]  )     =  =     0  )", "vertexOffset    =     . createRight ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "} else    {", "vertexOffset    =     . createRight ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "}", "if    ( z    >     0  )     {", "if    (  ( voxels [  ( i    +     ( frontOffset )  )  ]  )     =  =     0  )", "vertexOffset    =     . createFront ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "} else    {", "vertexOffset    =     . createFront ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "}", "if    ( z    <     (  ( depth )     -     1  )  )     {", "if    (  ( voxels [  ( i    +     ( backOffset )  )  ]  )     =  =     0  )", "vertexOffset    =     . createBack ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "} else    {", "vertexOffset    =     . createBack ( offset ,    x ,    y ,    z ,    vertices ,    vertexOffset )  ;", "}", "}", "}", "}", "return   vertexOffset    /     (  . VERTEX _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["calculateVertices"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "return   vertexOffset ;", "}", "METHOD_END"], "methodName": ["createBack"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "return   vertexOffset ;", "}", "METHOD_END"], "methodName": ["createBottom"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "return   vertexOffset ;", "}", "METHOD_END"], "methodName": ["createFront"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     -  1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "return   vertexOffset ;", "}", "METHOD_END"], "methodName": ["createLeft"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . y )     +    y ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "return   vertexOffset ;", "}", "METHOD_END"], "methodName": ["createRight"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . z )     +    z ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . x )     +    x )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     ( offset . x )     +    x ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . y )     +    y )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     (  ( offset . z )     +    z )     +     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "vertices [  ( vertexOffset +  +  )  ]     =     1  ;", "vertices [  ( vertexOffset +  +  )  ]     =     0  ;", "return   vertexOffset ;", "}", "METHOD_END"], "methodName": ["createTop"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "if    (  ( x    <     0  )     |  |     ( x    >  =     ( width )  )  )", "return    0  ;", "if    (  ( y    <     0  )     |  |     ( y    >  =     ( height )  )  )", "return    0  ;", "if    (  ( z    <     0  )     |  |     ( z    >  =     ( depth )  )  )", "return    0  ;", "return   getFa ( x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "return   voxels [  (  ( x    +     ( z    *     ( width )  )  )     +     ( y    *     ( widthTimesHeight )  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["getFast"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "if    (  ( x    <     0  )     |  |     ( x    >  =     ( width )  )  )", "return ;", "if    (  ( y    <     0  )     |  |     ( y    >  =     ( height )  )  )", "return ;", "if    (  ( z    <     0  )     |  |     ( z    >  =     ( depth )  )  )", "return ;", "setFast ( x ,    y ,    z ,     )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "voxels [  (  ( x    +     ( z    *     ( width )  )  )     +     ( y    *     ( widthTimesHeight )  )  )  ]     =    voxel ;", "}", "METHOD_END"], "methodName": ["setFast"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelChunk"}, {"methodBody": ["METHOD_START", "{", "int   ix    =     (  ( int )     ( x )  )  ;", "int   iy    =     (  ( int )     ( y )  )  ;", "int   iz    =     (  ( int )     ( z )  )  ;", "int   chunkX    =    ix    /     (  . CHUNK _ SIZE _ X )  ;", "if    (  ( chunkX    <     0  )     |  |     ( chunkX    >  =     ( chunksX )  )  )", "return    0  ;", "int   chunkY    =    iy    /     (  . CHUNK _ SIZE _ Y )  ;", "if    (  ( chunkY    <     0  )     |  |     ( chunkY    >  =     ( chunksY )  )  )", "return    0  ;", "int   chunkZ    =    iz    /     (  . CHUNK _ SIZE _ Z )  ;", "if    (  ( chunkZ    <     0  )     |  |     ( chunkZ    >  =     ( chunksZ )  )  )", "return    0  ;", "return   chunks [  (  ( chunkX    +     ( chunkZ    *     ( chunksX )  )  )     +     (  ( chunkY    *     ( chunksX )  )     *     ( chunksZ )  )  )  ]  . get (  ( ix    %     (  . CHUNK _ SIZE _ X )  )  ,     ( iy    %     (  . CHUNK _ SIZE _ Y )  )  ,     ( iz    %     (  . CHUNK _ SIZE _ Z )  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelWorld"}, {"methodBody": ["METHOD_START", "{", "int   ix    =     (  ( int )     ( x )  )  ;", "int   iz    =     (  ( int )     ( z )  )  ;", "if    (  ( ix    <     0  )     |  |     ( ix    >  =     ( sX )  )  )", "return    0  ;", "if    (  ( iz    <     0  )     |  |     ( iz    >  =     ( sZ )  )  )", "return    0  ;", "for    ( int   y    =     ( sY )     -     1  ;    y    >     0  ;    y -  -  )     {", "if    (  ( get ( ix ,    y ,    iz )  )     >     0  )", "return   y    +     1  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["getHighest"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelWorld"}, {"methodBody": ["METHOD_START", "{", "int   ix    =     (  ( int )     ( x )  )  ;", "int   iy    =     (  ( int )     ( y )  )  ;", "int   iz    =     (  ( int )     ( z )  )  ;", "int   chunkX    =    ix    /     (  . CHUNK _ SIZE _ X )  ;", "if    (  ( chunkX    <     0  )     |  |     ( chunkX    >  =     ( chunksX )  )  )", "return ;", "int   chunkY    =    iy    /     (  . CHUNK _ SIZE _ Y )  ;", "if    (  ( chunkY    <     0  )     |  |     ( chunkY    >  =     ( chunksY )  )  )", "return ;", "int   chunkZ    =    iz    /     (  . CHUNK _ SIZE _ Z )  ;", "if    (  ( chunkZ    <     0  )     |  |     ( chunkZ    >  =     ( chunksZ )  )  )", "return ;", "chunks [  (  ( chunkX    +     ( chunkZ    *     ( chunksX )  )  )     +     (  ( chunkY    *     ( chunksX )  )     *     ( chunksZ )  )  )  ]  . set (  ( ix    %     (  . CHUNK _ SIZE _ X )  )  ,     ( iy    %     (  . CHUNK _ SIZE _ Y )  )  ,     ( iz    %     (  . CHUNK _ SIZE _ Z )  )  ,    voxel )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelWorld"}, {"methodBody": ["METHOD_START", "{", "int   ix    =     (  ( int )     ( x )  )  ;", "int   iy    =     (  ( int )     ( y )  )  ;", "int   iz    =     (  ( int )     ( z )  )  ;", "if    (  ( ix    <     0  )     |  |     ( ix    >  =     ( sX )  )  )", "return ;", "if    (  ( iy    <     0  )     |  |     ( iy    >  =     ( sY )  )  )", "return ;", "if    (  ( iz    <     0  )     |  |     ( iz    >  =     ( sZ )  )  )", "return ;", "for    (  ;    iy    >     0  ;    iy -  -  )     {", "set ( ix ,    iy ,    iz ,     )  ;", "}", "}", "METHOD_END"], "methodName": ["setColumn"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelWorld"}, {"methodBody": ["METHOD_START", "{", "int   ix    =     (  ( int )     ( x )  )  ;", "int   iy    =     (  ( int )     ( y )  )  ;", "int   iz    =     (  ( int )     ( z )  )  ;", "int   iwidth    =     (  ( int )     ( width )  )  ;", "int   iheight    =     (  ( int )     ( height )  )  ;", "int   idepth    =     (  ( int )     ( depth )  )  ;", "int   startX    =    Math . max ( ix ,     0  )  ;", "int   endX    =    Math . min ( sX ,     ( ix    +    iwidth )  )  ;", "int   startY    =    Math . max ( iy ,     0  )  ;", "int   endY    =    Math . min ( sY ,     ( iy    +    iheight )  )  ;", "int   startZ    =    Math . max ( iz ,     0  )  ;", "int   endZ    =    Math . min ( sZ ,     ( iz    +    idepth )  )  ;", "for    ( iy    =    startY ;    iy    <    endY ;    iy +  +  )     {", "for    ( iz    =    startZ ;    iz    <    endZ ;    iz +  +  )     {", "for    ( ix    =    startX ;    ix    <    endX ;    ix +  +  )     {", "set ( ix ,    iy ,    iz ,     )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setCube"], "fileName": "com.badlogic.gdx.tests.g3d.voxel.VoxelWorld"}, {"methodBody": ["METHOD_START", "{", "Pixmap   pixmap    =    new   Pixmap (  2  5  6  ,     2  5  6  ,    Format . RGB 5  6  5  )  ;", "boolean   useRed    =    true ;", "for    ( int   y    =     0  ;    y    <     2  5  6  ;    y    +  =     8  )     {", "for    ( int   x    =     0  ;    x    <     2  5  6  ;    x    +  =     8  )     {", "pixmap . setColor (  ( useRed    ?     1     :     0  )  ,     0  ,     ( useRed    ?     0     :     1  )  ,     1  )  ;", "pixmap . fillRectangle ( x ,    y ,     8  ,     8  )  ;", "useRed    =     ! useRed ;", "}", "useRed    =     ! useRed ;", "}", "texture    =    new   graphics . Texture ( pixmap ,    true )  ;", "texture . setFilter ( MipMapLinearLinear ,    Linear )  ;", "}", "METHOD_END"], "methodName": ["createTexture"], "fileName": "com.badlogic.gdx.tests.gles2.MipMap2D"}, {"methodBody": ["METHOD_START", "{", "gl 2  0  . glViewport (  0  ,     0  ,    graphics . getBackBufferWidth (  )  ,    graphics . getBackBufferHeight (  )  )  ;", "gl 2  0  . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "gl 2  0  . glActiveTexture ( GL _ TEXTURE 0  )  ;", "texture . bind (  )  ;", "shader . begin (  )  ;", "shader . setUniformf (  \" s _ texture \"  ,     0  )  ;", "gl 2  0  . glTexParameteri ( GL _ TEXTURE _  2 D ,    GL _ TEXTURE _ MIN _ FILTER ,    GL _ NEAREST )  ;", "shader . setUniformf (  \" u _ offset \"  ,     (  -  0  .  6 F )  )  ;", "mesh . render ( shader ,    GL _ TRIANGLES )  ;", "gl 2  0  . glTexParameteri ( GL _ TEXTURE _  2 D ,    GL _ TEXTURE _ MIN _ FILTER ,    GL _ LINEAR _ MIPMAP _ LINEAR )  ;", "shader . setUniformf (  \" u _ offset \"  ,     0  .  6 F )  ;", "mesh . render ( shader ,    GL _ TRIANGLES )  ;", "shader . end (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.gles2.MipMap2D"}, {"methodBody": ["METHOD_START", "{", "createTexture (  )  ;", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "com.badlogic.gdx.tests.gles2.MipMap2D"}, {"methodBody": ["METHOD_START", "{", "Mesh   mesh    =    new   Mesh ( true ,     2  4  ,     3  6  ,    new   com . badlogic . gdx . graphics . VertexAttribute ( Usage . Position ,     3  ,     \" a _ position \"  )  ,    new   com . badlogic . gdx . graphics . VertexAttribute ( Usage . Normal ,     3  ,     \" a _ normal \"  )  ,    new   com . badlogic . gdx . graphics . VertexAttribute ( Usage . TextureCoordinates ,     2  ,     \" a _ texcoords \"  )  )  ;", "float [  ]    cubeVerts    =    new   float [  ]  {     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     -  0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     0  .  5 F ,     -  0  .  5 F    }  ;", "float [  ]    cubeNormals    =    new   float [  ]  {     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     -  1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F    }  ;", "float [  ]    cubeTex    =    new   float [  ]  {     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     1  .  0 F ,     1  .  0 F ,     0  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     1  .  0 F ,     0  .  0 F    }  ;", "float [  ]    vertices    =    new   float [  2  4     *     8  ]  ;", "int   pIdx    =     0  ;", "int   nIdx    =     0  ;", "int   tIdx    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( vertices . length )  ;  )     {", "vertices [  ( i +  +  )  ]     =    cubeVerts [  ( pIdx +  +  )  ]  ;", "vertices [  ( i +  +  )  ]     =    cubeVerts [  ( pIdx +  +  )  ]  ;", "vertices [  ( i +  +  )  ]     =    cubeVerts [  ( pIdx +  +  )  ]  ;", "vertices [  ( i +  +  )  ]     =    cubeNormals [  ( nIdx +  +  )  ]  ;", "vertices [  ( i +  +  )  ]     =    cubeNormals [  ( nIdx +  +  )  ]  ;", "vertices [  ( i +  +  )  ]     =    cubeNormals [  ( nIdx +  +  )  ]  ;", "vertices [  ( i +  +  )  ]     =    cubeTex [  ( tIdx +  +  )  ]  ;", "vertices [  ( i +  +  )  ]     =    cubeTex [  ( tIdx +  +  )  ]  ;", "}", "short [  ]    indices    =    new   short [  ]  {     0  ,     2  ,     1  ,     0  ,     3  ,     2  ,     4  ,     5  ,     6  ,     4  ,     6  ,     7  ,     8  ,     9  ,     1  0  ,     8  ,     1  0  ,     1  1  ,     1  2  ,     1  5  ,     1  4  ,     1  2  ,     1  4  ,     1  3  ,     1  6  ,     1  7  ,     1  8  ,     1  6  ,     1  8  ,     1  9  ,     2  0  ,     2  3  ,     2  2  ,     2  0  ,     2  2  ,     2  1     }  ;", "mesh . setVertices ( vertices )  ;", "mesh . setIndices ( indices )  ;", "return   mesh ;", "}", "METHOD_END"], "methodName": ["genCube"], "fileName": "com.badlogic.gdx.tests.gles2.Shapes"}, {"methodBody": ["METHOD_START", "{", "if    (  ( test )     =  =    null )     {", "gl . glViewport (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "gl . glClearColor (  0  ,     0  ,     0  ,     0  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "ui . act ( graphics . getDeltaTime (  )  )  ;", "ui . draw (  )  ;", "} else    {", "if    ( dispose )     {", "test . pause (  )  ;", "test . dispose (  )  ;", "test    =    null ;", "graphics . setVSync ( true )  ;", ". InputWrapper   wrapper    =     (  (  . InputWrapper )     ( Gdx . input )  )  ;", "wrapper . multiplexer . addProcessor ( ui )  ;", "wrapper . multiplexer . removeProcessor ( wrapper . lastProcessor )  ;", "wrapper . lastProcessor    =    null ;", "dispose    =    false ;", "} else    {", "test . render (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tests.gwt.GwtTestWrapper"}, {"methodBody": ["METHOD_START", "{", "ui . getViewport (  )  . update ( width ,    height ,    true )  ;", "container . setSize ( width ,    height )  ;", "if    (  (  )     !  =    null )     {", ". resize ( width ,    height )  ;", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tests.gwt.GwtTestWrapper"}, {"methodBody": ["METHOD_START", "{", "SwingUtilities . invokeLater ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "new    (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl.LwjglCanvasTest"}, {"methodBody": ["METHOD_START", "{", "GdxTest   test    =    new   GroupTest (  )  ;", "LwjglApplicationConfiguration   config    =    new   LwjglApplicationConfiguration (  )  ;", "config . r    =    config . g    =    config . b    =    config . a    =     8  ;", "config . width    =     9  6  0  ;", "config . height    =     6  0  0  ;", "new   backends . lwjgl . LwjglApplication ( test ,    config )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl.LwjglDebugStarter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( argv . length )     >     0  )     {", "if    (  . runTest ( argv [  0  ]  )  )     {", "return ;", "}", "}", "UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName (  )  )  ;", "new    (  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl.LwjglTestStarter"}, {"methodBody": ["METHOD_START", "{", "boolean   useGL 3  0     =    false ;", "GdxTest   test    =    GdxTests . newTest ( testName )  ;", "if    ( test    =  =    null )     {", "return   false ;", "}", "LwjglApplicationConfiguration   config    =    new   LwjglApplicationConfiguration (  )  ;", "config . width    =     6  4  0  ;", "config . height    =     4  8  0  ;", "config . title    =    testName ;", "config . forceExit    =    false ;", "if    ( useGL 3  0  )     {", "config . useGL 3  0     =    true ;", "ShaderProgram . prependVertexCode    =     \"  # version    1  4  0  \\ n # define   varying   out \\ n # define   attribute   in \\ n \"  ;", "ShaderProgram . prependFragmentCode    =     \"  # version    1  4  0  \\ n # define   varying   in \\ n # define   texture 2 D   texture \\ n # define   gl _ FragColor   fragColor \\ nout   vec 4    fragColor ;  \\ n \"  ;", "} else    {", "config . useGL 3  0     =    false ;", "ShaderProgram . prependVertexCode    =     \"  \"  ;", "ShaderProgram . prependFragmentCode    =     \"  \"  ;", "}", "new   backends . lwjgl . LwjglApplication ( test ,    config )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["runTest"], "fileName": "com.badlogic.gdx.tests.lwjgl.LwjglTestStarter"}, {"methodBody": ["METHOD_START", "{", "SwingUtilities . invokeLater ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "new    (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl.SwingLwjglTest"}, {"methodBody": ["METHOD_START", "{", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "Toolkit . getDefaultToolkit (  )  ;", "new   BufferedImage (  1  0  0  ,     1  0  0  ,    BufferedImage . TYPE _ INT _ ARGB )  ;", "if    (  !  ( glfwInit (  )  )  )     {", "System . out . println (  \" Couldn ' t   initialize   GLFW \"  )  ;", "System . exit (  (  -  1  )  )  ;", "}", "final   long   window    =    glfwCreateWindow (  6  4  0  ,     4  8  0  ,     \" Test \"  ,     0  ,     0  )  ;", "if    ( window    =  =     0  )     {", "throw   new   RuntimeException (  \" Couldn ' t   create   window \"  )  ;", "}", "glfwMakeContextCurrent ( window )  ;", "glfwSwapInterval (  0  )  ;", "glfwSetMouseButtonCallback ( window ,     . callback )  ;", "new   Runnable (  )     {", "public   void   run (  )     {", "if    ( glfwWindowShouldClose ( window )  )     {", "glfwDestroyWindow ( window )  ;", "glfwTerminate (  )  ;", "return ;", "}", "GL . createCapabilities (  )  ;", "GL 1  1  . glViewport (  0  ,     0  ,     6  4  0  ,     4  8  0  )  ;", "GL 1  1  . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "GL 1  1  . glRotatef (  0  .  1 F ,     0  ,     0  ,     1  )  ;", "GL 1  1  . glBegin ( GL _ TRIANGLES )  ;", "GL 1  1  . glVertex 2 f (  (  -  0  .  5 F )  ,     (  -  0  .  5 F )  )  ;", "GL 1  1  . glVertex 2 f (  0  .  5 F ,     (  -  0  .  5 F )  )  ;", "GL 1  1  . glVertex 2 f (  0  ,     0  .  5 F )  ;", "GL 1  1  . glEnd (  )  ;", "glfwPollEvents (  )  ;", "glfwSwapBuffers ( window )  ;", "EventQueue . invokeLater ( this )  ;", "}", "}  . run (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl3.AwtTestLWJGL"}, {"methodBody": ["METHOD_START", "{", "for    ( String   file    :    files )     {", "root . add ( new   scenes . scene 2 d . ui . Label ( file ,    skin )  )  . left (  )  . row (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addFiles"], "fileName": "com.badlogic.gdx.tests.lwjgl3.DragNDropTest"}, {"methodBody": ["METHOD_START", "{", "final   DragNDropTest   test    =    new   DragNDropTest (  )  ;", "Lwjgl 3 ApplicationConfiguration   config    =    new   Lwjgl 3 ApplicationConfiguration (  )  ;", "config . setWindowedMode (  6  4  0  ,     4  8  0  )  ;", "config . setTitle (  \" Drag   files   in   this   window \"  )  ;", "config . setWindowListener ( new   Lwjgl 3 WindowAdapter (  )     {", "@ Override", "public   void   filesDropped ( String [  ]    files )     {", "for    ( String   file    :    files )     {", "app . log (  \" GLWF   Drop \"  ,    file )  ;", "}", "test . addFiles ( files )  ;", "}", "}  )  ;", "new   backends . lwjgl 3  . Lwjgl 3 Application ( test ,    config )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl3.DragNDropTest"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwSetErrorCallback ( GlfwTest . errorCallback )  ;", "if    (  !  ( glfwInit (  )  )  )     {", "System . out . println (  \" Couldn ' t   initialize   GLFW \"  )  ;", "System . exit (  (  -  1  )  )  ;", "}", "glfwDefaultWindowHints (  )  ;", "glfwWindowHint ( GLFW _ VISIBLE ,    GLFW _ FALSE )  ;", "Buffer   modes    =    glfwGetVideoModes ( glfwGetPrimaryMonitor (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( modes . limit (  )  )  ;    i +  +  )     {", "System . out . println (  (  (  ( modes . get ( i )  . width (  )  )     +     \" x \"  )     +     ( modes . get ( i )  . height (  )  )  )  )  ;", "}", "GLFWVidMode   mode    =    modes . get (  7  )  ;", "System . out . println (  (  (  (  \" Mode :     \"     +     ( mode . width (  )  )  )     +     \" x \"  )     +     ( mode . height (  )  )  )  )  ;", "GlfwTest . windowHandle    =    glfwCreateWindow ( mode . width (  )  ,    mode . height (  )  ,     \" Test \"  ,    glfwGetPrimaryMonitor (  )  ,     0  )  ;", "if    (  ( GlfwTest . windowHandle )     =  =     0  )     {", "throw   new   RuntimeException (  \" Couldn ' t   create   window \"  )  ;", "}", "glfwMakeContextCurrent ( GlfwTest . windowHandle )  ;", "GL . createCapabilities (  )  ;", "glfwSwapInterval (  1  )  ;", "glfwShowWindow ( GlfwTest . windowHandle )  ;", "IntBuffer   tmp    =    BufferUtils . createIntBuffer (  1  )  ;", "IntBuffer   tmp 2     =    BufferUtils . createIntBuffer (  1  )  ;", "int   fbWidth    =     0  ;", "int   fbHeight    =     0  ;", "while    (  !  ( glfwWindowShouldClose ( GlfwTest . windowHandle )  )  )     {", "glfwGetFramebufferSize ( GlfwTest . windowHandle ,    tmp ,    tmp 2  )  ;", "if    (  ( fbWidth    !  =     ( tmp . get (  0  )  )  )     |  |     ( fbHeight    !  =     ( tmp 2  . get (  0  )  )  )  )     {", "fbWidth    =    tmp . get (  0  )  ;", "fbHeight    =    tmp 2  . get (  0  )  ;", "System . out . println (  (  (  (  \" Framebuffer :     \"     +     ( tmp . get (  0  )  )  )     +     \" x \"  )     +     ( tmp 2  . get (  0  )  )  )  )  ;", "}", "GL 1  1  . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "GL 1  1  . glBegin ( GL _ TRIANGLES )  ;", "GL 1  1  . glVertex 2 f (  (  -  1  .  0 F )  ,     (  -  1  .  0 F )  )  ;", "GL 1  1  . glVertex 2 f (  1  .  0 F ,     (  -  1  .  0 F )  )  ;", "GL 1  1  . glVertex 2 f (  0  ,     1  .  0 F )  ;", "GL 1  1  . glEnd (  )  ;", "glfwSwapBuffers ( GlfwTest . windowHandle )  ;", "glfwPollEvents (  )  ;", "}", "glfwDestroyWindow ( GlfwTest . windowHandle )  ;", "glfwTerminate (  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl3.GlfwTest"}, {"methodBody": ["METHOD_START", "{", "GdxTest   test    =    new   GdxTest (  )     {", "float   r    =     0  ;", "SpriteBatch   batch ;", "BitmapFont   font ;", "FPSLogger   fps    =    new   FPSLogger (  )  ;", "Texture   texture ;", "@ Override", "public   void   create (  )     {", "BufferedImage   image    =    new   BufferedImage (  1  0  ,     1  0  ,    BufferedImage . TYPE _  4 BYTE _ ABGR )  ;", "texture    =    new   Texture (  \" data / badlogic . jpg \"  )  ;", "batch    =    new   SpriteBatch (  )  ;", "font    =    new   BitmapFont (  )  ;", "input . setInputProcessor ( new   InputAdapter (  )     {", "@ Override", "public   boolean   keyDown ( int   keycode )     {", "System . out . println (  (  \" Key   down :     \"     +     ( Keys . toString ( keycode )  )  )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   keyUp ( int   keycode )     {", "System . out . println (  (  \" Key   up :     \"     +     ( Keys . toString ( keycode )  )  )  )  ;", "return   false ;", "}", "@ Override", "public   boolean   keyTyped ( char   character )     {", "System . out . println (  (  (  (  \" Key   typed :     '  \"     +    character )     +     \"  '  ,     \"  )     +     (  ( int )     ( character )  )  )  )  ;", "if    ( character    =  =     ' f '  )     {", "graphics . setFullscreenMode ( graphics . getDisplayMode (  )  )  ;", "}", "if    ( character    =  =     ' w '  )     {", "graphics . setWindowedMode ( MathUtils . random (  4  0  0  ,     8  0  0  )  ,    MathUtils . random (  4  0  0  ,     8  0  0  )  )  ;", "}", "if    ( character    =  =     ' e '  )     {", "throw   new   GdxRuntimeException (  \" derp \"  )  ;", "}", "if    ( character    =  =     ' c '  )     {", "input . setCursorCatched (  (  !  ( input . isCursorCatched (  )  )  )  )  ;", "}", "Lwjgl 3 Window   window    =     (  ( Lwjgl 3 Graphics )     ( graphics )  )  . getWindow (  )  ;", "if    ( character    =  =     ' v '  )     {", "window . setVisible ( false )  ;", "}", "if    ( character    =  =     ' s '  )     {", "window . setVisible ( true )  ;", "}", "if    ( character    =  =     ' q '  )     {", "window . closeWindow (  )  ;", "}", "if    ( character    =  =     ' i '  )     {", "window . iconifyWindow (  )  ;", "}", "if    ( character    =  =     ' m '  )     {", "window . maximizeWindow (  )  ;", "}", "if    ( character    =  =     ' r '  )     {", "window . restoreWindow (  )  ;", "}", "if    ( character    =  =     ' u '  )     {", "net . openURI (  \" https :  /  / google . com \"  )  ;", "}", "return   false ;", "}", "}  )  ;", "}", "long   start    =    System . nanoTime (  )  ;", "@ Override", "public   void   render (  )     {", "gl . glClearColor (  1  ,     0  ,     0  ,     1  )  ;", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "HdpiUtils . glViewport (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "batch . getProjectionMatrix (  )  . setToOrtho 2 D (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "batch . begin (  )  ;", "font . draw ( batch ,     (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( graphics . getWidth (  )  )     +     \" x \"  )     +     ( graphics . getHeight (  )  )  )     +     \"  ,     \"  )     +     ( graphics . getBackBufferWidth (  )  )  )     +     \" x \"  )     +     ( graphics . getBackBufferHeight (  )  )  )     +     \"  ,     \"  )     +     ( input . getX (  )  )  )     +     \"  ,     \"  )     +     ( input . getY (  )  )  )     +     \"  ,     \"  )     +     ( input . getDeltaX (  )  )  )     +     \"  ,     \"  )     +     ( input . getDeltaY (  )  )  )  ,     0  ,     2  0  )  ;", "batch . draw ( texture ,    input . getX (  )  ,     (  ( graphics . getHeight (  )  )     -     ( input . getY (  )  )  )  )  ;", "batch . end (  )  ;", "fps . log (  )  ;", "}", "@ Override", "public   void   resize ( int   width ,    int   height )     {", "app . log (  \" Test \"  ,     (  (  (  \" Resized    \"     +    width )     +     \" x \"  )     +    height )  )  ;", "}", "@ Override", "public   void   resume (  )     {", "app . log (  \" Test \"  ,     \" resuming \"  )  ;", "}", "@ Override", "public   void   pause (  )     {", "app . log (  \" Test \"  ,     \" pausing \"  )  ;", "}", "@ Override", "public   void   dispose (  )     {", "app . log (  \" Test \"  ,     \" disposing \"  )  ;", "}", "}  ;", "Lwjgl 3 ApplicationConfiguration   config    =    new   Lwjgl 3 ApplicationConfiguration (  )  ;", "config . setWindowedMode (  6  4  0  ,     4  8  0  )  ;", "config . setWindowListener ( new   Lwjgl 3 WindowListener (  )     {", "@ Override", "public   void   created ( Lwjgl 3 Window   window )     {", "app . log (  \" Window \"  ,     \" created \"  )  ;", "}", "@ Override", "public   void   iconified ( boolean   isIconified )     {", "app . log (  \" Window \"  ,     (  \" iconified :     \"     +     ( isIconified    ?     \" true \"     :     \" false \"  )  )  )  ;", "}", "@ Override", "public   void   maximized ( boolean   isMaximized )     {", "app . log (  \" Window \"  ,     (  \" maximized :     \"     +     ( isMaximized    ?     \" true \"     :     \" false \"  )  )  )  ;", "}", "@ Override", "public   void   focusLost (  )     {", "app . log (  \" Window \"  ,     \" focus   lost \"  )  ;", "}", "@ Override", "public   void   focusGained (  )     {", "app . log (  \" Window \"  ,     \" focus   gained \"  )  ;", "}", "@ Override", "public   boolean   closeRequested (  )     {", "app . log (  \" Window \"  ,     \" closing \"  )  ;", "return   false ;", "}", "@ Override", "public   void   filesDropped ( String [  ]    files )     {", "for    ( String   file    :    files )     {", "app . log (  \" Window \"  ,     (  \" File   dropped :     \"     +    file )  )  ;", "}", "}", "@ Override", "public   void   refreshRequested (  )     {", "app . log (  \" Window \"  ,     \" refreshRequested \"  )  ;", "}", "}  )  ;", "for    ( DisplayMode   mode    :    Lwjgl 3 ApplicationConfiguration . getDisplayModes (  )  )     {", "System . out . println (  (  (  ( mode . width )     +     \" x \"  )     +     ( mode . height )  )  )  ;", "}", "System . setProperty (  \" headless \"  ,     \" true \"  )  ;", "new   backends . lwjgl 3  . Lwjgl 3 Application ( test ,    config )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl3.Lwjgl3DebugStarter"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" headless \"  ,     \" true \"  )  ;", "Lwjgl 3 ApplicationConfiguration   config    =    new   Lwjgl 3 ApplicationConfiguration (  )  ;", "config . setWindowedMode (  6  4  0  ,     4  8  0  )  ;", "new   backends . lwjgl 3  . Lwjgl 3 Application ( new   Lwjgl 3 TestStarter . TestChooser (  )  ,    config )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl3.Lwjgl3TestStarter"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 ApplicationConfiguration   config    =    new   Lwjgl 3 ApplicationConfiguration (  )  ;", "config . setTitle (  \" Multi - window   test   with   cursors \"  )  ;", "new   Lwjgl 3 Application ( new    . MainWindow (  )  ,    config )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl3.MultiWindowCursorTest"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 ApplicationConfiguration   config    =    new   Lwjgl 3 ApplicationConfiguration (  )  ;", "config . setTitle (  \" Multi - window   test \"  )  ;", "new   backends . lwjgl 3  . Lwjgl 3 Application ( new   MultiWindowTest . MainWindow (  )  ,    config )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.lwjgl3.MultiWindowTest"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["needsGL20"], "fileName": "com.badlogic.gdx.tests.net.NetAPITest"}, {"methodBody": ["METHOD_START", "{", "Touchable   t    =     ( disabled )     ?    Touchable . disabled    :    Touchable . enabled ;", "btnDownloImage . setDisabled ( disabled )  ;", "btnDownloImage . setTouchable ( t )  ;", "btnDownloText . setDisabled ( disabled )  ;", "btnDownloText . setTouchable ( t )  ;", "btnDownloError . setDisabled ( disabled )  ;", "btnDownloError . setTouchable ( t )  ;", "btnPost . setDisabled ( disabled )  ;", "btnPost . setTouchable ( t )  ;", "}", "METHOD_END"], "methodName": ["setButtonDisabled"], "fileName": "com.badlogic.gdx.tests.net.NetAPITest"}, {"methodBody": ["METHOD_START", "{", "final   String   newText    =    httpResponse . getResultAsString (  )  ;", "app . postRunnable ( new   Runnable (  )     {", "public   void   run (  )     {", "text    =    newText ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.tests.net.NetAPITest"}, {"methodBody": ["METHOD_START", "{", "TiledMapTileLayer   layer    =     (  ( TiledMapTileLayer )     ( map . getLayers (  )  . get (  \" walls \"  )  )  )  ;", "rectPool . freeAll ( tiles )  ;", "tiles . clear (  )  ;", "for    ( int   y    =    startY ;    y    <  =    endY ;    y +  +  )     {", "for    ( int   x    =    startX ;    x    <  =    endX ;    x +  +  )     {", "Cell   cell    =    layer . getCell ( x ,    y )  ;", "if    ( cell    !  =    null )     {", "Rectangle   rect    =    rectPool . obtain (  )  ;", "rect . set ( x ,    y ,     1  ,     1  )  ;", "tiles . add ( rect )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["getTiles"], "fileName": "com.badlogic.gdx.tests.superkoalio.SuperKoalio"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     2  ;    i +  +  )     {", "fat   x    =     ( input . getX ( i )  )     /     (  ( fat )     ( graphics . getWidth (  )  )  )  ;", "if    (  ( input . isTouched ( i )  )     &  &     (  ( x    >  =    startX )     &  &     ( x    <  =    endX )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTouched"], "fileName": "com.badlogic.gdx.tests.superkoalio.SuperKoalio"}, {"methodBody": ["METHOD_START", "{", "debugRenderer . setProjectionMatrix ( camera . combined )  ;", "debugRenderer . begin ( Line )  ;", "debugRenderer . setColor ( RED )  ;", "debugRenderer . rect ( koala . position . x ,    koala . position . y ,     . Koala . WIDTH ,     . Koala . HEIGHT )  ;", "debugRenderer . setColor ( YELLOW )  ;", "TiledMapTileLayer   layer    =     (  ( TiledMapTileLayer )     ( map . getLayers (  )  . get (  \" walls \"  )  )  )  ;", "for    ( int   y    =     0  ;    y    <  =     ( layer . getHeight (  )  )  ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <  =     ( layer . getWidth (  )  )  ;    x +  +  )     {", "Cell   cell    =    layer . getCell ( x ,    y )  ;", "if    ( cell    !  =    null )     {", "if    ( camera . frustum . boundsInFrustum (  ( x    +     0  .  5 F )  ,     ( y    +     0  .  5 F )  ,     0  ,     1  ,     1  ,     0  )  )", "debugRenderer . rect ( x ,    y ,     1  ,     1  )  ;", "}", "}", "}", "debugRenderer . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderDebug"], "fileName": "com.badlogic.gdx.tests.superkoalio.SuperKoalio"}, {"methodBody": ["METHOD_START", "{", "TextureRegion   frame    =    null ;", "switch    ( koala . state )     {", "case   Standing    :", "frame    =    stand . getKeyFrame ( koala . stateTime )  ;", "break ;", "case   Walking    :", "frame    =    walk . getKeyFrame ( koala . stateTime )  ;", "break ;", "case   Jumping    :", "frame    =    jump . getKeyFrame ( koala . stateTime )  ;", "break ;", "}", "Batch   batch    =    renderer . getBatch (  )  ;", "batch . begin (  )  ;", "if    ( koala . facesRight )     {", "batch . draw ( frame ,    koala . position . x ,    koala . position . y ,     . Koala . WIDTH ,     . Koala . HEIGHT )  ;", "} else    {", "batch . draw ( frame ,     (  ( koala . position . x )     +     (  . Koala . WIDTH )  )  ,    koala . position . y ,     (  -  (  . Koala . WIDTH )  )  ,     . Koala . HEIGHT )  ;", "}", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["renderKoala"], "fileName": "com.badlogic.gdx.tests.superkoalio.SuperKoalio"}, {"methodBody": ["METHOD_START", "{", "if    ( deltaTime    =  =     0  )", "return ;", "if    ( deltaTime    >     0  .  1 F )", "deltaTime    =     0  .  1 F ;", "koala . stateTime    +  =    deltaTime ;", "if    (  (  ( input . isKeyPressed ( SPACE )  )     |  |     ( isTouched (  0  .  5 F ,     1  )  )  )     &  &     ( koala . grounded )  )     {", "koala . velocity . y    +  =     . Koala . JUMP _ VELOCITY ;", "koala . state    =     . Koala . State . Jumping ;", "koala . grounded    =    false ;", "}", "if    (  (  ( input . isKeyPressed ( LEFT )  )     |  |     ( input . isKeyPressed ( A )  )  )     |  |     ( isTouched (  0  ,     0  .  2  5 F )  )  )     {", "koala . velocity . x    =     -  (  . Koala . MAX _ VELOCITY )  ;", "if    ( koala . grounded )", "koala . state    =     . Koala . State . Walking ;", "koala . facesRight    =    false ;", "}", "if    (  (  ( input . isKeyPressed ( RIGHT )  )     |  |     ( input . isKeyPressed ( D )  )  )     |  |     ( isTouched (  0  .  2  5 F ,     0  .  5 F )  )  )     {", "koala . velocity . x    =     . Koala . MAX _ VELOCITY ;", "if    ( koala . grounded )", "koala . state    =     . Koala . State . Walking ;", "koala . facesRight    =    true ;", "}", "if    ( input . isKeyJustPressed ( B )  )", "debug    =     !  ( debug )  ;", "koala . velocity . add (  0  ,     . GRAVITY )  ;", "koala . velocity . x    =    MathUtils . clamp ( koala . velocity . x ,     (  -  (  . Koala . MAX _ VELOCITY )  )  ,     . Koala . MAX _ VELOCITY )  ;", "if    (  ( Math . abs ( koala . velocity . x )  )     <     1  )     {", "koala . velocity . x    =     0  ;", "if    ( koala . grounded )", "koala . state    =     . Koala . State . Standing ;", "}", "koala . velocity . scl ( deltaTime )  ;", "Rectangle   koalaRect    =    rectPool . obtain (  )  ;", "koalaRect . set ( koala . position . x ,    koala . position . y ,     . Koala . WIDTH ,     . Koala . HEIGHT )  ;", "int   startX ;", "int   startY ;", "int   endX ;", "int   endY ;", "if    (  ( koala . velocity . x )     >     0  )     {", "startX    =    endX    =     (  ( int )     (  (  ( koala . position . x )     +     (  . Koala . WIDTH )  )     +     ( koala . velocity . x )  )  )  ;", "} else    {", "startX    =    endX    =     (  ( int )     (  ( koala . position . x )     +     ( koala . velocity . x )  )  )  ;", "}", "startY    =     (  ( int )     ( koala . position . y )  )  ;", "endY    =     (  ( int )     (  ( koala . position . y )     +     (  . Koala . HEIGHT )  )  )  ;", "getTiles ( startX ,    startY ,    endX ,    endY ,    tiles )  ;", "koalaRect . x    +  =    koala . velocity . x ;", "for    ( Rectangle   tile    :    tiles )     {", "if    ( koalaRect . overlaps ( tile )  )     {", "koala . velocity . x    =     0  ;", "break ;", "}", "}", "koalaRect . x    =    koala . position . x ;", "if    (  ( koala . velocity . y )     >     0  )     {", "startY    =    endY    =     (  ( int )     (  (  ( koala . position . y )     +     (  . Koala . HEIGHT )  )     +     ( koala . velocity . y )  )  )  ;", "} else    {", "startY    =    endY    =     (  ( int )     (  ( koala . position . y )     +     ( koala . velocity . y )  )  )  ;", "}", "startX    =     (  ( int )     ( koala . position . x )  )  ;", "endX    =     (  ( int )     (  ( koala . position . x )     +     (  . Koala . WIDTH )  )  )  ;", "getTiles ( startX ,    startY ,    endX ,    endY ,    tiles )  ;", "koalaRect . y    +  =    koala . velocity . y ;", "for    ( Rectangle   tile    :    tiles )     {", "if    ( koalaRect . overlaps ( tile )  )     {", "if    (  ( koala . velocity . y )     >     0  )     {", "koala . position . y    =     ( tile . y )     -     (  . Koala . HEIGHT )  ;", "TiledMapTileLayer   layer    =     (  ( TiledMapTileLayer )     ( map . getLayers (  )  . get (  \" walls \"  )  )  )  ;", "layer . setCell (  (  ( int )     ( tile . x )  )  ,     (  ( int )     ( tile . y )  )  ,    null )  ;", "} else    {", "koala . position . y    =     ( tile . y )     +     ( tile . height )  ;", "koala . grounded    =    true ;", "}", "koala . velocity . y    =     0  ;", "break ;", "}", "}", "rectPool . free ( koalaRect )  ;", "koala . position . add ( koala . velocity )  ;", "koala . velocity . scl (  (  1     /    deltaTime )  )  ;", "koala . velocity . x    *  =     . Koala . DAMPING ;", "}", "METHOD_END"], "methodName": ["updateKoala"], "fileName": "com.badlogic.gdx.tests.superkoalio.SuperKoalio"}, {"methodBody": ["METHOD_START", "{", "FileHandle   file    =    new   FileHandle ( args [  0  ]  )  ;", "StringBuffer   list    =    new   StringBuffer (  )  ;", "args [  0  ]     =    args [  0  ]  . replace (  \"  \\  \\  \"  ,     \"  /  \"  )  ;", "if    (  !  ( args [  0  ]  . endsWith (  \"  /  \"  )  )  )", "args [  0  ]     =     ( args [  0  ]  )     +     \"  /  \"  ;", ". traverse ( file ,    args [  0  ]  ,    list )  ;", "new   FileHandle (  (  ( args [  0  ]  )     +     \"  / assets . txt \"  )  )  . writeString ( list . toString (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tests.utils.AssetsFileGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( directory . name (  )  . equals (  \"  . svn \"  )  )", "return ;", "String   dirName    =     ( directory . toString (  )  . replace (  \"  \\  \\  \"  ,     \"  /  \"  )  . replace ( base ,     \"  \"  )  )     +     \"  /  \"  ;", "System . out . println ( dirName )  ;", "for    ( FileHandle   file    :    directory . list (  )  )     {", "if    ( file . isDirectory (  )  )     {", ". traverse ( file ,    base ,    list )  ;", "} else    {", "String   fileName    =    file . toString (  )  . replace (  \"  \\  \\  \"  ,     \"  /  \"  )  . replace ( base ,     \"  \"  )  ;", "if    (  (  ( fileName . endsWith (  \"  . png \"  )  )     |  |     ( fileName . endsWith (  \"  . jpg \"  )  )  )     |  |     ( fileName . endsWith (  \"  . jpeg \"  )  )  )     {", "list . append (  (  (  \" i :  \"     +    fileName )     +     \"  \\ n \"  )  )  ;", "System . out . println ( fileName )  ;", "} else", "if    (  (  (  (  (  ( fileName . endsWith (  \"  . glsl \"  )  )     |  |     ( fileName . endsWith (  \"  . fnt \"  )  )  )     |  |     ( fileName . endsWith (  \"  . pack \"  )  )  )     |  |     ( fileName . endsWith (  \"  . obj \"  )  )  )     |  |     ( file . extension (  )  . equals (  \"  \"  )  )  )     |  |     ( fileName . endsWith (  \" txt \"  )  )  )     {", "list . append (  (  (  \" t :  \"     +    fileName )     +     \"  \\ n \"  )  )  ;", "System . out . println ( fileName )  ;", "} else    {", "if    (  (  ( fileName . endsWith (  \"  . mp 3  \"  )  )     |  |     ( fileName . endsWith (  \"  . ogg \"  )  )  )     |  |     ( fileName . endsWith (  \"  . wav \"  )  )  )", "continue ;", "list . append (  (  (  \" b :  \"     +    fileName )     +     \"  \\ n \"  )  )  ;", "System . out . println ( fileName )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["traverse"], "fileName": "com.badlogic.gdx.tests.utils.AssetsFileGenerator"}, {"methodBody": ["METHOD_START", "{", "name    =    GdxTests . originalToObfuscated . get ( name ,    name )  ;", "for    ( Class   clazz    :    GdxTests . tests )", "if    ( clazz . getSimpleName (  )  . equals ( name )  )", "return   clazz ;", "return   null ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "com.badlogic.gdx.tests.utils.GdxTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    new   ArrayList < String >  ( GdxTests . tests . size (  )  )  ;", "for    ( Class   clazz    :    GdxTests . tests )", "names . add ( GdxTests . obfuscatedToOriginal . get ( clazz . getSimpleName (  )  ,    clazz . getSimpleName (  )  )  )  ;", "Collections . sort ( names )  ;", "return   names ;", "}", "METHOD_END"], "methodName": ["getNames"], "fileName": "com.badlogic.gdx.tests.utils.GdxTests"}, {"methodBody": ["METHOD_START", "{", "testName    =    GdxTests . originalToObfuscated . get ( testName ,    testName )  ;", "try    {", "return   GdxTests . forName ( testName )  . newInstance (  )  ;", "}    catch    ( InstantiationException   e )     {", "e . printStackTrace (  )  ;", "}    catch    ( IllegalAccessException   e )     {", "e . printStackTrace (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["newTest"], "fileName": "com.badlogic.gdx.tests.utils.GdxTests"}, {"methodBody": ["METHOD_START", "{", "UIKit . UIApplicationMain (  0  ,    null ,    null ,    IOSTests . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogicgames.gdx.tests.IOSTests"}]