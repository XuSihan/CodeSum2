[{"methodBody": ["METHOD_START", "{", "Lwjgl 3 Cursor . disposeSystemCursors (  )  ;", "if    (  ( audio )    instanceof   OpenALAudio )     {", "(  ( OpenALAudio )     ( audio )  )  . dispose (  )  ;", "}", ". errorCallback . free (  )  ;", ". errorCallback    =    null ;", "if    (  (  . glDebugCallback )     !  =    null )     {", ". glDebugCallback . free (  )  ;", ". glDebugCallback    =    null ;", "}", "GLFW . glfwTerminate (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lifecycleListeners )     {", "for    ( LifecycleListener   lifecycleListener    :    lifecycleListeners )     {", "lifecycleListener . pause (  )  ;", "lifecycleListener . dispose (  )  ;", "}", "}", "for    ( Window   window    :    windows )     {", "window . dispose (  )  ;", "}", "windows . clear (  )  ;", "}", "METHOD_END"], "methodName": ["cleanupWindows"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwDefaultWindowHints (  )  ;", "GLFW . glfwWindowHint ( GLFW _ VISIBLE ,    GLFW _ FALSE )  ;", "GLFW . glfwWindowHint ( GLFW _ RESIZABLE ,     ( config . windowResizable    ?    GLFW . GLFW _ TRUE    :    GLFW . GLFW _ FALSE )  )  ;", "GLFW . glfwWindowHint ( GLFW _ MAXIMIZED ,     ( config . windowMaximized    ?    GLFW . GLFW _ TRUE    :    GLFW . GLFW _ FALSE )  )  ;", "GLFW . glfwWindowHint ( GLFW _ AUTO _ ICONIFY ,     ( config . autoIconify    ?    GLFW . GLFW _ TRUE    :    GLFW . GLFW _ FALSE )  )  ;", "if    ( sharedContextWindow    =  =     0  )     {", "GLFW . glfwWindowHint ( GLFW _ RED _ BITS ,    config . r )  ;", "GLFW . glfwWindowHint ( GLFW _ GREEN _ BITS ,    config . g )  ;", "GLFW . glfwWindowHint ( GLFW _ BLUE _ BITS ,    config . b )  ;", "GLFW . glfwWindowHint ( GLFW _ ALPHA _ BITS ,    config . a )  ;", "GLFW . glfwWindowHint ( GLFW _ STENCIL _ BITS ,    config . stencil )  ;", "GLFW . glfwWindowHint ( GLFW _ DEPTH _ BITS ,    config . depth )  ;", "GLFW . glfwWindowHint ( GLFW _ SAMPLES ,    config . samples )  ;", "}", "if    ( config . useGL 3  0  )     {", "GLFW . glfwWindowHint ( GLFW _ CONTEXT _ VERSION _ MAJOR ,    config . gles 3  0 ContextMajorVersion )  ;", "GLFW . glfwWindowHint ( GLFW _ CONTEXT _ VERSION _ MINOR ,    config . gles 3  0 ContextMinorVersion )  ;", "if    ( SharedLibraryLoader . isMac )     {", "GLFW . glfwWindowHint ( GLFW _ OPENGL _ FORWARD _ COMPAT ,    GLFW _ TRUE )  ;", "GLFW . glfwWindowHint ( GLFW _ OPENGL _ PROFILE ,    GLFW _ OPENGL _ CORE _ PROFILE )  ;", "}", "}", "if    ( config . debug )     {", "GLFW . glfwWindowHint ( GLFW _ OPENGL _ DEBUG _ CONTEXT ,    GLFW _ TRUE )  ;", "}", "long   windowHandle    =     0  ;", "if    (  ( config . fullscreenMode )     !  =    null )     {", "windowHandle    =    GLFW . glfwCreateWindow ( config . fullscreenMode . width ,    config . fullscreenMode . height ,    config . title ,    config . fullscreenMode . getMonitor (  )  ,    sharedContextWindow )  ;", "} else    {", "GLFW . glfwWindowHint ( GLFW _ DECORATED ,     ( config . windowDecorated    ?    GLFW . GLFW _ TRUE    :    GLFW . GLFW _ FALSE )  )  ;", "windowHandle    =    GLFW . glfwCreateWindow ( config . windowWidth ,    config . windowHeight ,    config . title ,     0  ,    sharedContextWindow )  ;", "}", "if    ( windowHandle    =  =     0  )     {", "throw   new   GdxRuntimeException (  \" Couldn ' t   create   window \"  )  ;", "}", "Lwjgl 3 Window . setSizeLimits ( windowHandle ,    config . windowMinWidth ,    config . windowMinHeight ,    config . windowMaxWidth ,    config . windowMaxHeight )  ;", "if    (  (  ( config . fullscreenMode )     =  =    null )     &  &     (  !  ( config . windowMaximized )  )  )     {", "if    (  (  ( config . windowX )     =  =     (  -  1  )  )     &  &     (  ( config . windowY )     =  =     (  -  1  )  )  )     {", "int   windowWidth    =    Math . max ( config . windowWidth ,    config . windowMinWidth )  ;", "int   windowHeight    =    Math . max ( config . windowHeight ,    config . windowMinHeight )  ;", "if    (  ( config . windowMaxWidth )     >     (  -  1  )  )", "windowWidth    =    Math . min ( windowWidth ,    config . windowMaxWidth )  ;", "if    (  ( config . windowMaxHeight )     >     (  -  1  )  )", "windowHeight    =    Math . min ( windowHeight ,    config . windowMaxHeight )  ;", "GLFWVidMode   vidMode    =    GLFW . glfwGetVideoMode ( GLFW . glfwGetPrimaryMonitor (  )  )  ;", "GLFW . glfwSetWindowPos ( windowHandle ,     (  (  ( vidMode . width (  )  )     /     2  )     -     ( windowWidth    /     2  )  )  ,     (  (  ( vidMode . height (  )  )     /     2  )     -     ( windowHeight    /     2  )  )  )  ;", "} else    {", "GLFW . glfwSetWindowPos ( windowHandle ,    config . windowX ,    config . windowY )  ;", "}", "}", "if    (  ( config . windowIconPaths )     !  =    null )     {", "Lwjgl 3 Window . setIcon ( windowHandle ,    config . windowIconPaths ,    config . windowIconFileType )  ;", "}", "GLFW . glfwMakeContextCurrent ( windowHandle )  ;", "GLFW . glfwSwapInterval (  ( config . vSyncEnabled    ?     1     :     0  )  )  ;", "GL . createCapabilities (  )  ;", ". initiateGL (  )  ;", "if    (  !  (  . glVersion . isVersionEqualToOrHigher (  2  ,     0  )  )  )", "throw   new   GdxRuntimeException (  (  (  (  \" OpenGL    2  .  0    or   higher   with   the   FBO   extension   is   required .    OpenGL   version :     \"     +     ( GL 1  1  . glGetString ( GL _ VERSION )  )  )     +     \"  \\ n \"  )     +     (  . glVersion . getDebugVersionString (  )  )  )  )  ;", "if    (  !  (  . supportsFBO (  )  )  )     {", "throw   new   GdxRuntimeException (  (  (  (  \" OpenGL    2  .  0    or   higher   with   the   FBO   extension   is   required .    OpenGL   version :     \"     +     ( GL 1  1  . glGetString ( GL _ VERSION )  )  )     +     \"  ,    FBO   extension :    false \\ n \"  )     +     (  . glVersion . getDebugVersionString (  )  )  )  )  ;", "}", "if    ( config . debug )     {", ". glDebugCallback    =    GLUtil . setupDebugMessageCallback ( config . debugStream )  ;", ". setGLDebugMessageControl (  . GLDebugMessageSeverity . NOTIFICATION ,    false )  ;", "}", "return   windowHandle ;", "}", "METHOD_END"], "methodName": ["createGlfwWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Window   window    =    new   Lwjgl 3 Window ( listener ,    config )  ;", "if    ( sharedContext    =  =     0  )     {", "createWindow ( window ,    config ,    sharedContext )  ;", "} else    {", "postRunnable (  (  )     -  >     {", "createWindow ( window ,    config ,    sharedContext )  ;", "windows . add ( window )  ;", "}  )  ;", "}", "return   window ;", "}", "METHOD_END"], "methodName": ["createWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "long   windowHandle    =    Lwjgl 3 Application . createGlfwWindow ( config ,    sharedContext )  ;", "window . create ( windowHandle )  ;", "window . setVisible ( config . initialVisible )  ;", "for    ( int   i    =     0  ;    i    <     2  ;    i +  +  )     {", "GL 1  1  . glClearColor ( config . initialBackgroundColor . r ,    config . initialBackgroundColor . g ,    config . initialBackgroundColor . b ,    config . initialBackgroundColor . a )  ;", "GL 1  1  . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", "GLFW . glfwSwapBuffers ( windowHandle )  ;", "}", "}", "METHOD_END"], "methodName": ["createWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Lwjgl 3 Application . errorCallback )     =  =    null )     {", "Lwjgl 3 NativesLoader . load (  )  ;", "Lwjgl 3 Application . errorCallback    =    GLFWErrorCallback . createPrint ( System . err )  ;", "GLFW . glfwSetErrorCallback ( Lwjgl 3 Application . errorCallback )  ;", "GLFW . glfwInitHint ( GLFW _ JOYSTICK _ HAT _ BUTTONS ,    GLFW _ FALSE )  ;", "if    (  !  ( GLFW . glfwInit (  )  )  )     {", "throw   new   GdxRuntimeException (  \" Unable   to   initialize   GLFW \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initializeGlfw"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "String   versionString    =    GL 1  1  . glGetString ( GL _ VERSION )  ;", "String   vendorString    =    GL 1  1  . glGetString ( GL _ VENDOR )  ;", "String   rendererString    =    GL 1  1  . glGetString ( GL _ RENDERER )  ;", "Lwjgl 3 Application . glVersion    =    new   graphics . glutils . GLVersion ( ApplicationType . Desktop ,    versionString ,    vendorString ,    rendererString )  ;", "}", "METHOD_END"], "methodName": ["initiateGL"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "Array < Lwjgl 3 Window >    closedWindows    =    new   Array < Lwjgl 3 Window >  (  )  ;", "while    (  ( running )     &  &     (  ( windows . size )     >     0  )  )     {", "if    (  ( audio )    instanceof   OpenALAudio )     {", "(  ( OpenALAudio )     ( audio )  )  . update (  )  ;", "}", "boolean   haveWindowsRendered    =    false ;", "closedWindows . clear (  )  ;", "for    ( Lwjgl 3 Window   window    :    windows )     {", "window . makeCurrent (  )  ;", "currentWindow    =    window ;", "synchronized ( lifecycleListeners )     {", "haveWindowsRendered    |  =    window . update (  )  ;", "}", "if    ( window . shouldClose (  )  )     {", "closedWindows . add ( window )  ;", "}", "}", "GLFW . glfwPollEvents (  )  ;", "boolean   shouldRequestRendering ;", "synchronized ( runnables )     {", "shouldRequestRendering    =     ( runnables . size )     >     0  ;", "executedRunnables . clear (  )  ;", "executedRunnables . addAll ( runnables )  ;", "runnables . clear (  )  ;", "}", "for    ( Runnable   runnable    :    executedRunnables )     {", "runnable . run (  )  ;", "}", "if    ( shouldRequestRendering )     {", "for    ( Lwjgl 3 Window   window    :    windows )     {", "if    (  !  ( window . getGraphics (  )  . isContinuousRendering (  )  )  )", "window . requestRendering (  )  ;", "}", "}", "for    ( Lwjgl 3 Window   closedWindow    :    closedWindows )     {", "if    (  ( windows . size )     =  =     1  )     {", "for    ( int   i    =     ( lifecycleListeners . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "LifecycleListener   l    =    lifecycleListeners . get ( i )  ;", "l . pause (  )  ;", "l . dispose (  )  ;", "}", "lifecycleListeners . clear (  )  ;", "}", "closedWindow . dispose (  )  ;", "windows . removeValue ( closedWindow ,    false )  ;", "}", "if    (  ! haveWindowsRendered )     {", "try    {", "Thread . sleep (  (  1  0  0  0     /     ( config . idleFPS )  )  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["loop"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 ApplicationConfiguration   appConfig    =    Lwjgl 3 ApplicationConfiguration . copy ( this . config )  ;", "appConfig . setWindowConfiguration ( config )  ;", "return   createWindow ( appConfig ,    listener ,    windows . get (  0  )  . getWindowHandle (  )  )  ;", "}", "METHOD_END"], "methodName": ["newWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "GLCapabilities   caps    =    GL . getCapabilities (  )  ;", "final   int   GL _ DONT _ CARE    =     4  3  5  2  ;", "if    ( caps . OpenGL 4  3  )     {", "GL 4  3  . glDebugMessageControl ( GL _ DONT _ CARE ,    GL _ DONT _ CARE ,    severity . gl 4  3  ,     (  ( IntBuffer )     ( null )  )  ,    enabled )  ;", "return   true ;", "}", "if    ( caps . GL _ KHR _ debug )     {", "KHRDebug . glDebugMessageControl ( GL _ DONT _ CARE ,    GL _ DONT _ CARE ,    severity . khr ,     (  ( IntBuffer )     ( null )  )  ,    enabled )  ;", "return   true ;", "}", "if    (  ( caps . GL _ ARB _ debug _ output )     &  &     (  ( severity . arb )     !  =     (  -  1  )  )  )     {", "ARBDebugOutput . glDebugMessageControlARB ( GL _ DONT _ CARE ,    GL _ DONT _ CARE ,    severity . arb ,     (  ( IntBuffer )     ( null )  )  ,    enabled )  ;", "return   true ;", "}", "if    (  ( caps . GL _ AMD _ debug _ output )     &  &     (  ( severity . amd )     !  =     (  -  1  )  )  )     {", "AMDDebugOutput . glDebugMessageEnableAMD ( GL _ DONT _ CARE ,    severity . amd ,     (  ( IntBuffer )     ( null )  )  ,    enabled )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["setGLDebugMessageControl"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Lwjgl 3 Application . glVersion . isVersionEqualToOrHigher (  3  ,     0  )  )     |  |     ( GLFW . glfwExtensionSupported (  \" GL _ EXT _ framebuffer _ object \"  )  )  )     |  |     ( GLFW . glfwExtensionSupported (  \" GL _ ARB _ framebuffer _ object \"  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsFBO"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 ApplicationConfiguration   copy    =    new   Lwjgl 3 ApplicationConfiguration (  )  ;", "copy . set ( config )  ;", "return   copy ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . disableAudio    =    disableAudio ;", "}", "METHOD_END"], "methodName": ["disableAudio"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "debug    =    enable ;", "debugStream    =    debugOutputStream ;", "}", "METHOD_END"], "methodName": ["enableGLDebugOutput"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Application . initializeGlfw (  )  ;", "GLFWVidMode   videoMode    =    GLFW . glfwGetVideoMode ( GLFW . glfwGetPrimaryMonitor (  )  )  ;", "return   new   Lwjgl 3 Graphics . Lwjgl 3 DisplayMode ( GLFW . glfwGetPrimaryMonitor (  )  ,    videoMode . width (  )  ,    videoMode . height (  )  ,    videoMode . refreshRate (  )  ,     (  (  ( videoMode . redBits (  )  )     +     ( videoMode . greenBits (  )  )  )     +     ( videoMode . blueBits (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayMode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Application . initializeGlfw (  )  ;", "GLFWVidMode   videoMode    =    GLFW . glfwGetVideoMode (  (  ( Lwjgl 3 Graphics . Lwjgl 3 Monitor )     ( monitor )  )  . monitorHandle )  ;", "return   new   Lwjgl 3 Graphics . Lwjgl 3 DisplayMode (  (  ( Lwjgl 3 Graphics . Lwjgl 3 Monitor )     ( monitor )  )  . monitorHandle ,    videoMode . width (  )  ,    videoMode . height (  )  ,    videoMode . refreshRate (  )  ,     (  (  ( videoMode . redBits (  )  )     +     ( videoMode . greenBits (  )  )  )     +     ( videoMode . blueBits (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayMode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Application . initializeGlfw (  )  ;", "Buffer   videoModes    =    GLFW . glfwGetVideoModes ( GLFW . glfwGetPrimaryMonitor (  )  )  ;", "DisplayMode [  ]    result    =    new   DisplayMode [ videoModes . limit (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( result . length )  ;    i +  +  )     {", "GLFWVidMode   videoMode    =    videoModes . get ( i )  ;", "result [ i ]     =    new   Lwjgl 3 Graphics . Lwjgl 3 DisplayMode ( GLFW . glfwGetPrimaryMonitor (  )  ,    videoMode . width (  )  ,    videoMode . height (  )  ,    videoMode . refreshRate (  )  ,     (  (  ( videoMode . redBits (  )  )     +     ( videoMode . greenBits (  )  )  )     +     ( videoMode . blueBits (  )  )  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDisplayModes"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Application . initializeGlfw (  )  ;", "Buffer   videoModes    =    GLFW . glfwGetVideoModes (  (  ( Lwjgl 3 Graphics . Lwjgl 3 Monitor )     ( monitor )  )  . monitorHandle )  ;", "DisplayMode [  ]    result    =    new   DisplayMode [ videoModes . limit (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( result . length )  ;    i +  +  )     {", "GLFWVidMode   videoMode    =    videoModes . get ( i )  ;", "result [ i ]     =    new   Lwjgl 3 Graphics . Lwjgl 3 DisplayMode (  (  ( Lwjgl 3 Graphics . Lwjgl 3 Monitor )     ( monitor )  )  . monitorHandle ,    videoMode . width (  )  ,    videoMode . height (  )  ,    videoMode . refreshRate (  )  ,     (  (  ( videoMode . redBits (  )  )     +     ( videoMode . greenBits (  )  )  )     +     ( videoMode . blueBits (  )  )  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDisplayModes"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Application . initializeGlfw (  )  ;", "PointerBuffer   glfwMonitors    =    GLFW . glfwGetMonitors (  )  ;", "Monitor [  ]    monitors    =    new   Monitor [ glfwMonitors . limit (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( glfwMonitors . limit (  )  )  ;    i +  +  )     {", "monitors [ i ]     =     . toLwjgl 3 Monitor ( glfwMonitors . get ( i )  )  ;", "}", "return   monitors ;", "}", "METHOD_END"], "methodName": ["getMonitors"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Application . initializeGlfw (  )  ;", "return    . toLwjgl 3 Monitor ( GLFW . glfwGetPrimaryMonitor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrimaryMonitor"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "super . setWindowConfiguration ( config )  ;", "disableAudio    =    config . disableAudio ;", "audioDeviceSimultaneousSources    =    config . audioDeviceSimultaneousSources ;", "audioDeviceBufferSize    =    config . audioDeviceBufferSize ;", "audioDeviceBufferCount    =    config . audioDeviceBufferCount ;", "useGL 3  0     =    config . useGL 3  0  ;", "gles 3  0 ContextMajorVersion    =    config . gles 3  0 ContextMajorVersion ;", "gles 3  0 ContextMinorVersion    =    config . gles 3  0 ContextMinorVersion ;", "r    =    config . r ;", "g    =    config . g ;", "b    =    config . b ;", "a    =    config . a ;", "depth    =    config . depth ;", "stencil    =    config . stencil ;", "samples    =    config . samples ;", "vSyncEnabled    =    config . vSyncEnabled ;", "idleFPS    =    config . idleFPS ;", "preferencesDirectory    =    config . preferencesDirectory ;", "preferencesFileType    =    config . preferencesFileType ;", "hdpiMode    =    config . hdpiMode ;", "debug    =    config . debug ;", "debugStream    =    config . debugStream ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . audioDeviceSimultaneousSources    =    simultaniousSources ;", "this . audioDeviceBufferSize    =    bufferSize ;", "this . audioDeviceBufferCount    =    bufferCount ;", "}", "METHOD_END"], "methodName": ["setAudioConfig"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . r    =    r ;", "this . g    =    g ;", "this . b    =    b ;", "this . a    =    a ;", "this . depth    =    depth ;", "this . stencil    =    stencil ;", "this . samples    =    samples ;", "}", "METHOD_END"], "methodName": ["setBackBufferConfig"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . hdpiMode    =    mode ;", "}", "METHOD_END"], "methodName": ["setHdpiMode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . idleFPS    =    fps ;", "}", "METHOD_END"], "methodName": ["setIdleFPS"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . initialVisible    =    visibility ;", "}", "METHOD_END"], "methodName": ["setInitialVisible"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . preferencesDirectory    =    preferencesDirectory ;", "this . preferencesFileType    =    preferencesFileType ;", "}", "METHOD_END"], "methodName": ["setPreferencesConfig"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   tmp    =    BufferUtils . createIntBuffer (  1  )  ;", "IntBuffer   tmp 2     =    BufferUtils . createIntBuffer (  1  )  ;", "GLFW . glfwGetMonitorPos ( glfwMonitor ,    tmp ,    tmp 2  )  ;", "int   virtualX    =    tmp . get (  0  )  ;", "int   virtualY    =    tmp 2  . get (  0  )  ;", "String   name    =    GLFW . glfwGetMonitorName ( glfwMonitor )  ;", "return   newGraphicsMonitor ( glfwMonitor ,    virtualX ,    virtualY ,    name )  ;", "}", "METHOD_END"], "methodName": ["toLwjgl3Monitor"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . useGL 3  0     =    useGL 3  0  ;", "this . gles 3  0 textMajorVersion    =    gles 3 MajorVersion ;", "this . gles 3  0 textMinorVersion    =    gles 3 MinorVersion ;", "}", "METHOD_END"], "methodName": ["useOpenGL3"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . vSyncEnabled    =    vsync ;", "}", "METHOD_END"], "methodName": ["useVsync"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( Lwjgl 3 Cursor . cursors . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "Lwjgl 3 Cursor   cursor    =    Lwjgl 3 Cursor . cursors . get ( i )  ;", "if    ( cursor . window . equals ( window )  )     {", "Lwjgl 3 Cursor . cursors . removeIndex ( i )  . dispose (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Cursor"}, {"methodBody": ["METHOD_START", "{", "for    ( long   systemCursor    :    Lwjgl 3 Cursor . systemCursors . values (  )  )     {", "GLFW . glfwDestroyCursor ( systemCursor )  ;", "}", "Lwjgl 3 Cursor . systemCursors . clear (  )  ;", "}", "METHOD_END"], "methodName": ["disposeSystemCursors"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Cursor"}, {"methodBody": ["METHOD_START", "{", "Long   glfwCursor    =    Lwjgl 3 Cursor . systemCursors . get ( systemCursor )  ;", "if    ( glfwCursor    =  =    null )     {", "long   handle    =     0  ;", "if    ( systemCursor    =  =     ( SystemCursor . Arrow )  )     {", "handle    =    GLFW . glfwCreateStandardCursor ( GLFW _ ARROW _ CURSOR )  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . Crosshair )  )     {", "handle    =    GLFW . glfwCreateStandardCursor ( GLFW . GLFW _ CROSSHAIR _ CURSOR )  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . Hand )  )     {", "handle    =    GLFW . glfwCreateStandardCursor ( GLFW . GLFW _ HAND _ CURSOR )  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . HorizontalResize )  )     {", "handle    =    GLFW . glfwCreateStandardCursor ( GLFW . GLFW _ HRESIZE _ CURSOR )  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . VerticalResize )  )     {", "handle    =    GLFW . glfwCreateStandardCursor ( GLFW . GLFW _ VRESIZE _ CURSOR )  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . Ibeam )  )     {", "handle    =    GLFW . glfwCreateStandardCursor ( GLFW . GLFW _ IBEAM _ CURSOR )  ;", "} else    {", "throw   new   utils . GdxRuntimeException (  (  \" Unknown   system   cursor    \"     +    systemCursor )  )  ;", "}", "if    ( handle    =  =     0  )     {", "return ;", "}", "glfwCursor    =    handle ;", "Lwjgl 3 Cursor . systemCursors . put ( systemCursor ,    glfwCursor )  ;", "}", "GLFW . glfwSetCursor ( windowHandle ,    glfwCursor )  ;", "}", "METHOD_END"], "methodName": ["setSystemCursor"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Cursor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "return   new    ( new   File ( name )  ,    type )  ;", "return   new    ( new   File ( file ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . External )  )", "return   new   File ( s . externalPath ,    file . getPath (  )  )  ;", "if    (  ( type )     =  =     ( FileType . Local )  )", "return   new   File ( s . localPath ,    file . getPath (  )  )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3FileHandle"}, {"methodBody": ["METHOD_START", "{", "File   parent    =    file . getParentFile (  )  ;", "if    ( parent    =  =    null )     {", "if    (  ( type )     =  =     ( FileType . Absolute )  )", "parent    =    new   File (  \"  /  \"  )  ;", "else", "parent    =    new   File (  \"  \"  )  ;", "}", "return   new    ( parent ,    type )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" Cannot   get   the   sibling   of   the   root .  \"  )  ;", "return   new   Lwjgl 3 FileHandle ( new   File ( file . getParent (  )  ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["sibling"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( buffer )     =  =    null )     |  |     (  ( buffer . capacity (  )  )     <    numBytes )  )     {", "buffer    =    BufferUtils . newByteBuffer ( numBytes )  ;", "floatBuffer    =    buffer . asFloatBuffer (  )  ;", "intBuffer    =    buffer . asIntBuffer (  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureBufferCapacity"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  3  . glActiveTexture ( texture )  ;", "}", "METHOD_END"], "methodName": ["glActiveTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glAttachShader ( program ,    shader )  ;", "}", "METHOD_END"], "methodName": ["glAttachShader"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glBindAttribLocation ( program ,    index ,    name )  ;", "}", "METHOD_END"], "methodName": ["glBindAttribLocation"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glBindBuffer ( target ,    buffer )  ;", "}", "METHOD_END"], "methodName": ["glBindBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glBindFramebufferEXT ( target ,    framebuffer )  ;", "}", "METHOD_END"], "methodName": ["glBindFramebuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glBindRenderbufferEXT ( target ,    renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glBindRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glBindTexture ( target ,    texture )  ;", "}", "METHOD_END"], "methodName": ["glBindTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  4  . glBlendColor ( red ,    green ,    blue ,    alpha )  ;", "}", "METHOD_END"], "methodName": ["glBlendColor"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  4  . glBlendEquation ( mode )  ;", "}", "METHOD_END"], "methodName": ["glBlendEquation"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glBlendEquationSeparate ( modeRGB ,    modeAlpha )  ;", "}", "METHOD_END"], "methodName": ["glBlendEquationSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glBlendFunc ( sfactor ,    dfactor )  ;", "}", "METHOD_END"], "methodName": ["glBlendFunc"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  4  . glBlendFuncSeparate ( srcRGB ,    dstRGB ,    srcAlpha ,    dstAlpha )  ;", "}", "METHOD_END"], "methodName": ["glBlendFuncSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    ( data    =  =    null )", "glBufferData ( target ,    size ,    usage )  ;", "else", "if    ( data   instanceof   ByteBuffer )", "glBufferData ( target ,     (  ( ByteBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   IntBuffer )", "glBufferData ( target ,     (  ( IntBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   FloatBuffer )", "glBufferData ( target ,     (  ( FloatBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   DoubleBuffer )", "glBufferData ( target ,     (  ( DoubleBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   ShortBuffer )", "glBufferData ( target ,     (  ( ShortBuffer )     ( data )  )  ,    usage )  ;", "}", "METHOD_END"], "methodName": ["glBufferData"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    ( data    =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Using   null   for   the   data   not   possible ,    blame   LWJGL \"  )  ;", "else", "if    ( data   instanceof   ByteBuffer )", "glBufferSubData ( target ,    offset ,     (  ( ByteBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   IntBuffer )", "glBufferSubData ( target ,    offset ,     (  ( IntBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   FloatBuffer )", "glBufferSubData ( target ,    offset ,     (  ( FloatBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   DoubleBuffer )", "glBufferSubData ( target ,    offset ,     (  ( DoubleBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   ShortBuffer )", "glBufferSubData ( target ,    offset ,     (  ( ShortBuffer )     ( data )  )  )  ;", "}", "METHOD_END"], "methodName": ["glBufferSubData"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glCheckFramebufferStatusEXT ( target )  ;", "}", "METHOD_END"], "methodName": ["glCheckFramebufferStatus"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClear ( mask )  ;", "}", "METHOD_END"], "methodName": ["glClear"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClearColor ( red ,    green ,    blue ,    alpha )  ;", "}", "METHOD_END"], "methodName": ["glClearColor"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClearDepth ( depth )  ;", "}", "METHOD_END"], "methodName": ["glClearDepthf"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClearStencil ( s )  ;", "}", "METHOD_END"], "methodName": ["glClearStencil"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glColorMask ( red ,    green ,    blue ,    alpha )  ;", "}", "METHOD_END"], "methodName": ["glColorMask"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glCompileShader ( shader )  ;", "}", "METHOD_END"], "methodName": ["glCompileShader"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    ( data   instanceof   ByteBuffer )     {", "GL 1  3  . glCpressedTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,     (  ( ByteBuffer )     ( data )  )  )  ;", "} else    {", "throw   new   GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( data . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer   instead .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["glCompressedTexImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" not   implemented \"  )  ;", "}", "METHOD_END"], "methodName": ["glCompressedTexSubImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glCopyTexImage 2 D ( target ,    level ,    internalformat ,    x ,    y ,    width ,    height ,    border )  ;", "}", "METHOD_END"], "methodName": ["glCopyTexImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glCopyTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glCopyTexSubImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glCreateProgram (  )  ;", "}", "METHOD_END"], "methodName": ["glCreateProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glCreateShader ( type )  ;", "}", "METHOD_END"], "methodName": ["glCreateShader"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glCullFace ( mode )  ;", "}", "METHOD_END"], "methodName": ["glCullFace"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glDeleteBuffers ( buffers )  ;", "}", "METHOD_END"], "methodName": ["glDeleteBuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glDeleteFramebuffersEXT ( framebuffers )  ;", "}", "METHOD_END"], "methodName": ["glDeleteFramebuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDeleteProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glDeleteProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glDeleteRenderbuffersEXT ( renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glDeleteRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glDeleteRenderbuffersEXT ( renderbuffers )  ;", "}", "METHOD_END"], "methodName": ["glDeleteRenderbuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDeleteShader ( shader )  ;", "}", "METHOD_END"], "methodName": ["glDeleteShader"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDeleteTextures ( textures )  ;", "}", "METHOD_END"], "methodName": ["glDeleteTextures"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDepthFunc ( func )  ;", "}", "METHOD_END"], "methodName": ["glDepthFunc"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDepthMask ( flag )  ;", "}", "METHOD_END"], "methodName": ["glDepthMask"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDepthRange ( zNear ,    zFar )  ;", "}", "METHOD_END"], "methodName": ["glDepthRangef"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDetachShader ( program ,    shader )  ;", "}", "METHOD_END"], "methodName": ["glDetachShader"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDisable ( cap )  ;", "}", "METHOD_END"], "methodName": ["glDisable"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDisableVertexAttribArray ( index )  ;", "}", "METHOD_END"], "methodName": ["glDisableVertexAttribArray"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDrawArrays ( mode ,    first ,    count )  ;", "}", "METHOD_END"], "methodName": ["glDrawArrays"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDrawElements ( mode ,    count ,    type ,    indices )  ;", "}", "METHOD_END"], "methodName": ["glDrawElements"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    (  ( indices   instanceof   ShortBuffer )     &  &     ( type    =  =    com . badlogic . gdx . graphics . GL 2  0  )  )", "glDrawElements ( mode ,     (  ( ShortBuffer )     ( indices )  )  )  ;", "else", "if    (  ( indices   instanceof   ByteBuffer )     &  &     ( type    =  =    com . badlogic . gdx . graphics . GL 2  0  )  )", "glDrawElements ( mode ,     (  ( ByteBuffer )     ( indices )  )  . asShortBuffer (  )  )  ;", "else", "if    (  ( indices   instanceof   ByteBuffer )     &  &     ( type    =  =    com . badlogic . gdx . graphics . GL 2  0  )  )", "glDrawElements ( mode ,     (  ( ByteBuffer )     ( indices )  )  )  ;", "else", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( indices . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ShortBuffer   or   ByteBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glDrawElements"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glEnable ( cap )  ;", "}", "METHOD_END"], "methodName": ["glEnable"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glEnableVertexAttribArray ( index )  ;", "}", "METHOD_END"], "methodName": ["glEnableVertexAttribArray"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glFinish (  )  ;", "}", "METHOD_END"], "methodName": ["glFinish"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glFlush (  )  ;", "}", "METHOD_END"], "methodName": ["glFlush"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glFramebufferRenderbufferEXT ( target ,    attachment ,    renderbuffertarget ,    renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glFramebufferRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glFramebufferTexture 2 DEXT ( target ,    attachment ,    textarget ,    texture ,    level )  ;", "}", "METHOD_END"], "methodName": ["glFramebufferTexture2D"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glFrontFace ( mode )  ;", "}", "METHOD_END"], "methodName": ["glFrontFace"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  5  . glGenBuffers (  )  ;", "}", "METHOD_END"], "methodName": ["glGenBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glGenBuffers ( buffers )  ;", "}", "METHOD_END"], "methodName": ["glGenBuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glGenFramebuffersEXT (  )  ;", "}", "METHOD_END"], "methodName": ["glGenFramebuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGenFramebuffersEXT ( framebuffers )  ;", "}", "METHOD_END"], "methodName": ["glGenFramebuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glGenRenderbuffersEXT (  )  ;", "}", "METHOD_END"], "methodName": ["glGenRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGenRenderbuffersEXT ( renderbuffers )  ;", "}", "METHOD_END"], "methodName": ["glGenRenderbuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glGenTextures (  )  ;", "}", "METHOD_END"], "methodName": ["glGenTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGenTextures ( textures )  ;", "}", "METHOD_END"], "methodName": ["glGenTextures"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGenerateMipmapEXT ( target )  ;", "}", "METHOD_END"], "methodName": ["glGenerateMipmap"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   typeTmp    =    BufferUtils . createIntBuffer (  2  )  ;", "String   name    =     . glGetActiveAttrib ( program ,    index ,     2  5  6  ,    size ,    typeTmp )  ;", "size . put ( typeTmp . get (  0  )  )  ;", "if    ( type   instanceof   IntBuffer )", "(  ( IntBuffer )     ( type )  )  . put ( typeTmp . get (  1  )  )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["glGetActiveAttrib"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   typeTmp    =    BufferUtils . createIntBuffer (  2  )  ;", "String   name    =     . glGetActiveUniform ( program ,    index ,     2  5  6  ,    size ,    typeTmp )  ;", "size . put ( typeTmp . get (  0  )  )  ;", "if    ( type   instanceof   IntBuffer )", "(  ( IntBuffer )     ( type )  )  . put ( typeTmp . get (  1  )  )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["glGetActiveUniform"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetAttachedShaders ( program ,     (  ( IntBuffer )     ( count )  )  ,    shaders )  ;", "}", "METHOD_END"], "methodName": ["glGetAttachedShaders"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glGetAttribLocation ( program ,    name )  ;", "}", "METHOD_END"], "methodName": ["glGetAttribLocation"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetBooleanv ( pname ,     (  ( ByteBuffer )     ( params )  )  )  ;", "}", "METHOD_END"], "methodName": ["glGetBooleanv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glGetBufferParameteriv ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetBufferParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glGetError (  )  ;", "}", "METHOD_END"], "methodName": ["glGetError"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetFloatv ( pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetFloatv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGetFramebufferAttachmentParameterivEXT ( target ,    attachment ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetFramebufferAttachmentParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetIntegerv ( pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetIntegerv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  (  1  0  2  4     *     1  0  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "ByteBuffer   tmp    =    ByteBuffer . allocateDirect (  4  )  ;", "tmp . order ( ByteOrder . nativeOrder (  )  )  ;", "IntBuffer   intBuffer    =    tmp . asIntBuffer (  )  ;", ". glGetProgramInfoLog ( program ,    intBuffer ,    buffer )  ;", "int   numBytes    =    intBuffer . get (  0  )  ;", "byte [  ]    bytes    =    new   byte [ numBytes ]  ;", "buffer . get ( bytes )  ;", "return   new   String ( bytes )  ;", "}", "METHOD_END"], "methodName": ["glGetProgramInfoLog"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetProgramiv ( program ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetProgramiv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGetRenderbufferParameterivEXT ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetRenderbufferParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  (  1  0  2  4     *     1  0  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "ByteBuffer   tmp    =    ByteBuffer . allocateDirect (  4  )  ;", "tmp . order ( ByteOrder . nativeOrder (  )  )  ;", "IntBuffer   intBuffer    =    tmp . asIntBuffer (  )  ;", ". glGetShaderInfoLog ( shader ,    intBuffer ,    buffer )  ;", "int   numBytes    =    intBuffer . get (  0  )  ;", "byte [  ]    bytes    =    new   byte [ numBytes ]  ;", "buffer . get ( bytes )  ;", "return   new   String ( bytes )  ;", "}", "METHOD_END"], "methodName": ["glGetShaderInfoLog"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" unsupported ,    won ' t   implement \"  )  ;", "}", "METHOD_END"], "methodName": ["glGetShaderPrecisionFormat"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetShaderiv ( shader ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetShaderiv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glGetString ( name )  ;", "}", "METHOD_END"], "methodName": ["glGetString"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetTexParameterfv ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetTexParameterfv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetTexParameteriv ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetTexParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glGetUniformLocation ( program ,    name )  ;", "}", "METHOD_END"], "methodName": ["glGetUniformLocation"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetUniformfv ( program ,    location ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetUniformfv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetUniformiv ( program ,    location ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetUniformiv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" unsupported ,    won ' t   implement \"  )  ;", "}", "METHOD_END"], "methodName": ["glGetVertexAttribPointerv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetVertexAttribfv ( index ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetVertexAttribfv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetVertexAttribiv ( index ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetVertexAttribiv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glHint ( target ,    mode )  ;", "}", "METHOD_END"], "methodName": ["glHint"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  5  . glIsBuffer ( buffer )  ;", "}", "METHOD_END"], "methodName": ["glIsBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glIsEnabled ( cap )  ;", "}", "METHOD_END"], "methodName": ["glIsEnabled"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glIsFramebufferEXT ( framebuffer )  ;", "}", "METHOD_END"], "methodName": ["glIsFramebuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glIsProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glIsProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glIsRenderbufferEXT ( renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glIsRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glIsShader ( shader )  ;", "}", "METHOD_END"], "methodName": ["glIsShader"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glIsTexture ( texture )  ;", "}", "METHOD_END"], "methodName": ["glIsTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glLineWidth ( width )  ;", "}", "METHOD_END"], "methodName": ["glLineWidth"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glLinkProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glLinkProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glPixelStorei ( pname ,    param )  ;", "}", "METHOD_END"], "methodName": ["glPixelStorei"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glPolygonOffset ( factor ,    units )  ;", "}", "METHOD_END"], "methodName": ["glPolygonOffset"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    ( pixels   instanceof   ByteBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( ByteBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   ShortBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( ShortBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   IntBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( IntBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   FloatBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( FloatBuffer )     ( pixels )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( pixels . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer ,    ShortBuffer ,    IntBuffer   or   FloatBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glReadPixels"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glRenderbufferStorageEXT ( target ,    internalformat ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glRenderbufferStorage"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  3  . glSampleCoverage ( value ,    invert )  ;", "}", "METHOD_END"], "methodName": ["glSampleCoverage"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glScissor ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glScissor"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" unsupported ,    won ' t   implement \"  )  ;", "}", "METHOD_END"], "methodName": ["glShaderBinary"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glShaderSource ( shader ,    string )  ;", "}", "METHOD_END"], "methodName": ["glShaderSource"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glStencilFunc ( func ,    ref ,    mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilFunc"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glStencilFuncSeparate ( face ,    func ,    ref ,    mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilFuncSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glStencilMask ( mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilMask"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glStencilMaskSeparate ( face ,    mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilMaskSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glStencilOp ( fail ,    zfail ,    zpass )  ;", "}", "METHOD_END"], "methodName": ["glStencilOp"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glStencilOpSeparate ( face ,    fail ,    zfail ,    zpass )  ;", "}", "METHOD_END"], "methodName": ["glStencilOpSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    ( pixels    =  =    null )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( ByteBuffer )     ( null )  )  )  ;", "else", "if    ( pixels   instanceof   ByteBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( ByteBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   ShortBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( ShortBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   IntBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( IntBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   FloatBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( FloatBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   DoubleBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( DoubleBuffer )     ( pixels )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( pixels . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer ,    ShortBuffer ,    IntBuffer ,    FloatBuffer   or   DoubleBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glTexImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameterf ( target ,    pname ,    param )  ;", "}", "METHOD_END"], "methodName": ["glTexParameterf"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameterfv ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glTexParameterfv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameteri ( target ,    pname ,    param )  ;", "}", "METHOD_END"], "methodName": ["glTexParameteri"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameteriv ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glTexParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    ( pixels   instanceof   ByteBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( ByteBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   ShortBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( ShortBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   IntBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( IntBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   FloatBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( FloatBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   DoubleBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( DoubleBuffer )     ( pixels )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( pixels . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer ,    ShortBuffer ,    IntBuffer ,    FloatBuffer   or   DoubleBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glTexSubImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1 f ( location ,    x )  ;", "}", "METHOD_END"], "methodName": ["glUniform1f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1 fv ( location ,    toFloatBuffer ( v ,    offset ,    count )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform1fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1 fv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform1fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1 i ( location ,    x )  ;", "}", "METHOD_END"], "methodName": ["glUniform1i"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1 iv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform1iv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 f ( location ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["glUniform2f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 fv ( location ,    toFloatBuffer ( v ,    offset ,     ( count    <  <     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 fv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 i ( location ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["glUniform2i"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 iv ( location ,    toIntBuffer ( v ,    offset ,     ( count    <  <     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform2iv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 iv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform2iv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 f ( location ,    x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["glUniform3f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 fv ( location ,    toFloatBuffer ( v ,    offset ,     ( count    *     3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 fv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 i ( location ,    x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["glUniform3i"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 iv ( location ,    toIntBuffer ( v ,    offset ,     ( count    *     3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform3iv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 iv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform3iv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 f ( location ,    x ,    y ,    z ,    w )  ;", "}", "METHOD_END"], "methodName": ["glUniform4f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 fv ( location ,    toFloatBuffer ( v ,    offset ,     ( count    <  <     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 fv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 i ( location ,    x ,    y ,    z ,    w )  ;", "}", "METHOD_END"], "methodName": ["glUniform4i"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 iv ( location ,    toIntBuffer ( v ,    offset ,     ( count    <  <     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform4iv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 iv ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform4iv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 2 fv ( location ,    transpose ,    toFloatBuffer ( value ,    offset ,     ( count    <  <     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 2 fv ( location ,    transpose ,    value )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 3 fv ( location ,    transpose ,    toFloatBuffer ( value ,    offset ,     ( count    *     9  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 3 fv ( location ,    transpose ,    value )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 4 fv ( location ,    transpose ,    toFloatBuffer ( value ,    offset ,     ( count    <  <     4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 4 fv ( location ,    transpose ,    value )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUseProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glUseProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glValidateProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glValidateProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 1 f ( indx ,    x )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib1f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 1 f ( indx ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib1fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 2 f ( indx ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib2f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 2 f ( indx ,    values . get (  )  ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 3 f ( indx ,    x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib3f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 3 f ( indx ,    values . get (  )  ,    values . get (  )  ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 4 f ( indx ,    x ,    y ,    z ,    w )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib4f"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 4 f ( indx ,    values . get (  )  ,    values . get (  )  ,    values . get (  )  ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,    ptr )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttribPointer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "if    ( buffer   instanceof   ByteBuffer )     {", "if    ( type    =  =     ( GL _ BYTE )  )", "glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  )  ;", "else", "if    ( type    =  =     ( GL _ UNSIGNED _ BYTE )  )", "glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  )  ;", "else", "if    ( type    =  =     ( GL _ SHORT )  )", "glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  . asShortBuffer (  )  )  ;", "else", "if    ( type    =  =     ( GL _ UNSIGNED _ SHORT )  )", "glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  . asShortBuffer (  )  )  ;", "else", "if    ( type    =  =     ( GL _ FLOAT )  )", "glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  . asFloatBuffer (  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Can ' t   use    \"     +     ( buffer . getClass (  )  . getName (  )  )  )     +     \"    with   type    \"  )     +    type )     +     \"    with   this   method .    Use   ByteBuffer   and   one   of   GL _ BYTE ,    GL _ UNSIGNED _ BYTE ,    GL _ SHORT ,    GL _ UNSIGNED _ SHORT   or   GL _ FLOAT   for   type .    Blame   LWJGL \"  )  )  ;", "} else", "if    ( buffer   instanceof   FloatBuffer )     {", "if    ( type    =  =     ( GL _ FLOAT )  )", "glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,     (  ( FloatBuffer )     ( buffer )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Can ' t   use    \"     +     ( buffer . getClass (  )  . getName (  )  )  )     +     \"    with   type    \"  )     +    type )     +     \"    with   this   method .  \"  )  )  ;", "} else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( buffer . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttribPointer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glViewport ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glViewport"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "ensureBufferCapacity (  ( count    <  <     2  )  )  ;", "floatBuffer . clear (  )  ;", "floatBuffer . limit ( count )  ;", "floatBuffer . put ( v ,    offset ,    count )  ;", "floatBuffer . position (  0  )  ;", "return   floatBuffer ;", "}", "METHOD_END"], "methodName": ["toFloatBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "ensureBufferCapacity (  ( count    <  <     2  )  )  ;", "intBuffer . clear (  )  ;", "intBuffer . limit ( count )  ;", "intBuffer . put ( v ,    offset ,    count )  ;", "intBuffer . position (  0  )  ;", "return   intBuffer ;", "}", "METHOD_END"], "methodName": ["toIntBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3GL20"}, {"methodBody": ["METHOD_START", "{", "return   logicalHeight ;", "}", "METHOD_END"], "methodName": ["getLogicalHeight"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics"}, {"methodBody": ["METHOD_START", "{", "return   logicalWidth ;", "}", "METHOD_END"], "methodName": ["getLogicalWidth"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics"}, {"methodBody": ["METHOD_START", "{", "return   window ;", "}", "METHOD_END"], "methodName": ["getWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics"}, {"methodBody": ["METHOD_START", "{", "String   versionString    =    gl 2  0  . glGetString ( GL _ VERSION )  ;", "String   vendorString    =    gl 2  0  . glGetString ( GL _ VENDOR )  ;", "String   rendererString    =    gl 2  0  . glGetString ( GL _ RENDERER )  ;", "glVersion    =    new   graphics . glutils . GLVersion ( ApplicationType . Desktop ,    versionString ,    vendorString ,    rendererString )  ;", "}", "METHOD_END"], "methodName": ["initiateGL"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics"}, {"methodBody": ["METHOD_START", "{", "windowPosXBeforeFullscreen    =    window . getPositionX (  )  ;", "windowPosYBeforeFullscreen    =    window . getPositionY (  )  ;", "displayModeBeforeFullscreen    =    getDisplayMode (  )  ;", "}", "METHOD_END"], "methodName": ["storeCurrentWindowPositionAndDisplayMode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics"}, {"methodBody": ["METHOD_START", "{", "long   time    =    System . nanoTime (  )  ;", "if    (  ( lastFrameTime )     =  =     (  -  1  )  )", "lastFrameTime    =    time ;", "deltaTime    =     ( time    -     ( lastFrameTime )  )     /     1  .  0 E 9 F ;", "lastFrameTime    =    time ;", "if    (  ( time    -     ( frameCounterStart )  )     >  =     1  0  0  0  0  0  0  0  0  0  )     {", "fps    =    frames ;", "frames    =     0  ;", "frameCounterStart    =    time ;", "}", "( frames )  +  +  ;", "( frameId )  +  +  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwGetFramebufferSize ( window . getWindowHandle (  )  ,    tmpBuffer ,    tmpBuffer 2  )  ;", "this . backBufferWidth    =    tmpBuffer . get (  0  )  ;", "this . backBufferHeight    =    tmpBuffer 2  . get (  0  )  ;", "GLFW . glfwGetWindowSize ( window . getWindowHandle (  )  ,    tmpBuffer ,    tmpBuffer 2  )  ;", "this . logicalWidth    =    tmpBuffer . get (  0  )  ;", "this . logicalHeight    =    tmpBuffer 2  . get (  0  )  ;", "ApplicationConfiguration   config    =    window . getConfig (  )  ;", "bufferFormat    =    new   BufferFormat ( config . r ,    config . g ,    config . b ,    config . a ,    config . depth ,    config . stencil ,    config . samples ,    false )  ;", "}", "METHOD_END"], "methodName": ["updateFramebufferInfo"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics"}, {"methodBody": ["METHOD_START", "{", "switch    ( key )     {", "case   Keys . BACKSPACE    :", "return    8  ;", "case   Keys . TAB    :", "return    '  \\ t '  ;", "case   Keys . FORWARD _ DEL    :", "return    1  2  7  ;", "case   Keys . ENTER    :", "return    '  \\ n '  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["characterForKeyCode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Input"}, {"methodBody": ["METHOD_START", "{", "switch    ( lwjglKeyCode )     {", "case   GLFW . GLFW _ KEY _ SPACE    :", "return   Keys . SPACE ;", "case   GLFW . GLFW _ KEY _ APOSTROPHE    :", "return   Keys . APOSTROPHE ;", "case   GLFW . GLFW _ KEY _ COMMA    :", "return   Keys . COMMA ;", "case   GLFW . GLFW _ KEY _ MINUS    :", "return   Keys . MINUS ;", "case   GLFW . GLFW _ KEY _ PERIOD    :", "return   Keys . PERIOD ;", "case   GLFW . GLFW _ KEY _ SLASH    :", "return   Keys . SLASH ;", "case   GLFW . GLFW _ KEY _  0     :", "return   Keys . NUM _  0  ;", "case   GLFW . GLFW _ KEY _  1     :", "return   Keys . NUM _  1  ;", "case   GLFW . GLFW _ KEY _  2     :", "return   Keys . NUM _  2  ;", "case   GLFW . GLFW _ KEY _  3     :", "return   Keys . NUM _  3  ;", "case   GLFW . GLFW _ KEY _  4     :", "return   Keys . NUM _  4  ;", "case   GLFW . GLFW _ KEY _  5     :", "return   Keys . NUM _  5  ;", "case   GLFW . GLFW _ KEY _  6     :", "return   Keys . NUM _  6  ;", "case   GLFW . GLFW _ KEY _  7     :", "return   Keys . NUM _  7  ;", "case   GLFW . GLFW _ KEY _  8     :", "return   Keys . NUM _  8  ;", "case   GLFW . GLFW _ KEY _  9     :", "return   Keys . NUM _  9  ;", "case   GLFW . GLFW _ KEY _ SEMICOLON    :", "return   Keys . SEMICOLON ;", "case   GLFW . GLFW _ KEY _ EQUAL    :", "return   Keys . EQUALS ;", "case   GLFW . GLFW _ KEY _ A    :", "return   Keys . A ;", "case   GLFW . GLFW _ KEY _ B    :", "return   Keys . B ;", "case   GLFW . GLFW _ KEY _ C    :", "return   Keys . C ;", "case   GLFW . GLFW _ KEY _ D    :", "return   Keys . D ;", "case   GLFW . GLFW _ KEY _ E    :", "return   Keys . E ;", "case   GLFW . GLFW _ KEY _ F    :", "return   Keys . F ;", "case   GLFW . GLFW _ KEY _ G    :", "return   Keys . G ;", "case   GLFW . GLFW _ KEY _ H    :", "return   Keys . H ;", "case   GLFW . GLFW _ KEY _ I    :", "return   Keys . I ;", "case   GLFW . GLFW _ KEY _ J    :", "return   Keys . J ;", "case   GLFW . GLFW _ KEY _ K    :", "return   Keys . K ;", "case   GLFW . GLFW _ KEY _ L    :", "return   Keys . L ;", "case   GLFW . GLFW _ KEY _ M    :", "return   Keys . M ;", "case   GLFW . GLFW _ KEY _ N    :", "return   Keys . N ;", "case   GLFW . GLFW _ KEY _ O    :", "return   Keys . O ;", "case   GLFW . GLFW _ KEY _ P    :", "return   Keys . P ;", "case   GLFW . GLFW _ KEY _ Q    :", "return   Keys . Q ;", "case   GLFW . GLFW _ KEY _ R    :", "return   Keys . R ;", "case   GLFW . GLFW _ KEY _ S    :", "return   Keys . S ;", "case   GLFW . GLFW _ KEY _ T    :", "return   Keys . T ;", "case   GLFW . GLFW _ KEY _ U    :", "return   Keys . U ;", "case   GLFW . GLFW _ KEY _ V    :", "return   Keys . V ;", "case   GLFW . GLFW _ KEY _ W    :", "return   Keys . W ;", "case   GLFW . GLFW _ KEY _ X    :", "return   Keys . X ;", "case   GLFW . GLFW _ KEY _ Y    :", "return   Keys . Y ;", "case   GLFW . GLFW _ KEY _ Z    :", "return   Keys . Z ;", "case   GLFW . GLFW _ KEY _ LEFT _ BRACKET    :", "return   Keys . LEFT _ BRACKET ;", "case   GLFW . GLFW _ KEY _ BACKSLASH    :", "return   Keys . BACKSLASH ;", "case   GLFW . GLFW _ KEY _ RIGHT _ BRACKET    :", "return   Keys . RIGHT _ BRACKET ;", "case   GLFW . GLFW _ KEY _ GRAVE _ ACCENT    :", "return   Keys . GRAVE ;", "case   GLFW . GLFW _ KEY _ WORLD _  1     :", "case   GLFW . GLFW _ KEY _ WORLD _  2     :", "return   Keys . UNKNOWN ;", "case   GLFW . GLFW _ KEY _ ESCAPE    :", "return   Keys . ESCAPE ;", "case   GLFW . GLFW _ KEY _ ENTER    :", "return   Keys . ENTER ;", "case   GLFW . GLFW _ KEY _ TAB    :", "return   Keys . TAB ;", "case   GLFW . GLFW _ KEY _ BACKSPACE    :", "return   Keys . BACKSPACE ;", "case   GLFW . GLFW _ KEY _ INSERT    :", "return   Keys . INSERT ;", "case   GLFW . GLFW _ KEY _ DELETE    :", "return   Keys . FORWARD _ DEL ;", "case   GLFW . GLFW _ KEY _ RIGHT    :", "return   Keys . RIGHT ;", "case   GLFW . GLFW _ KEY _ LEFT    :", "return   Keys . LEFT ;", "case   GLFW . GLFW _ KEY _ DOWN    :", "return   Keys . DOWN ;", "case   GLFW . GLFW _ KEY _ UP    :", "return   Keys . UP ;", "case   GLFW . GLFW _ KEY _ PAGE _ UP    :", "return   Keys . PAGE _ UP ;", "case   GLFW . GLFW _ KEY _ PAGE _ DOWN    :", "return   Keys . PAGE _ DOWN ;", "case   GLFW . GLFW _ KEY _ HOME    :", "return   Keys . HOME ;", "case   GLFW . GLFW _ KEY _ END    :", "return   Keys . END ;", "case   GLFW . GLFW _ KEY _ CAPS _ LOCK    :", "case   GLFW . GLFW _ KEY _ SCROLL _ LOCK    :", "case   GLFW . GLFW _ KEY _ NUM _ LOCK    :", "case   GLFW . GLFW _ KEY _ PRINT _ SCREEN    :", "case   GLFW . GLFW _ KEY _ PAUSE    :", "return   Keys . UNKNOWN ;", "case   GLFW . GLFW _ KEY _ F 1     :", "return   Keys . F 1  ;", "case   GLFW . GLFW _ KEY _ F 2     :", "return   Keys . F 2  ;", "case   GLFW . GLFW _ KEY _ F 3     :", "return   Keys . F 3  ;", "case   GLFW . GLFW _ KEY _ F 4     :", "return   Keys . F 4  ;", "case   GLFW . GLFW _ KEY _ F 5     :", "return   Keys . F 5  ;", "case   GLFW . GLFW _ KEY _ F 6     :", "return   Keys . F 6  ;", "case   GLFW . GLFW _ KEY _ F 7     :", "return   Keys . F 7  ;", "case   GLFW . GLFW _ KEY _ F 8     :", "return   Keys . F 8  ;", "case   GLFW . GLFW _ KEY _ F 9     :", "return   Keys . F 9  ;", "case   GLFW . GLFW _ KEY _ F 1  0     :", "return   Keys . F 1  0  ;", "case   GLFW . GLFW _ KEY _ F 1  1     :", "return   Keys . F 1  1  ;", "case   GLFW . GLFW _ KEY _ F 1  2     :", "return   Keys . F 1  2  ;", "case   GLFW . GLFW _ KEY _ F 1  3     :", "case   GLFW . GLFW _ KEY _ F 1  4     :", "case   GLFW . GLFW _ KEY _ F 1  5     :", "case   GLFW . GLFW _ KEY _ F 1  6     :", "case   GLFW . GLFW _ KEY _ F 1  7     :", "case   GLFW . GLFW _ KEY _ F 1  8     :", "case   GLFW . GLFW _ KEY _ F 1  9     :", "case   GLFW . GLFW _ KEY _ F 2  0     :", "case   GLFW . GLFW _ KEY _ F 2  1     :", "case   GLFW . GLFW _ KEY _ F 2  2     :", "case   GLFW . GLFW _ KEY _ F 2  3     :", "case   GLFW . GLFW _ KEY _ F 2  4     :", "case   GLFW . GLFW _ KEY _ F 2  5     :", "return   Keys . UNKNOWN ;", "case   GLFW . GLFW _ KEY _ KP _  0     :", "return   Keys . NUMPAD _  0  ;", "case   GLFW . GLFW _ KEY _ KP _  1     :", "return   Keys . NUMPAD _  1  ;", "case   GLFW . GLFW _ KEY _ KP _  2     :", "return   Keys . NUMPAD _  2  ;", "case   GLFW . GLFW _ KEY _ KP _  3     :", "return   Keys . NUMPAD _  3  ;", "case   GLFW . GLFW _ KEY _ KP _  4     :", "return   Keys . NUMPAD _  4  ;", "case   GLFW . GLFW _ KEY _ KP _  5     :", "return   Keys . NUMPAD _  5  ;", "case   GLFW . GLFW _ KEY _ KP _  6     :", "return   Keys . NUMPAD _  6  ;", "case   GLFW . GLFW _ KEY _ KP _  7     :", "return   Keys . NUMPAD _  7  ;", "case   GLFW . GLFW _ KEY _ KP _  8     :", "return   Keys . NUMPAD _  8  ;", "case   GLFW . GLFW _ KEY _ KP _  9     :", "return   Keys . NUMPAD _  9  ;", "case   GLFW . GLFW _ KEY _ KP _ DECIMAL    :", "return   Keys . PERIOD ;", "case   GLFW . GLFW _ KEY _ KP _ DIVIDE    :", "return   Keys . SLASH ;", "case   GLFW . GLFW _ KEY _ KP _ MULTIPLY    :", "return   Keys . STAR ;", "case   GLFW . GLFW _ KEY _ KP _ SUBTRACT    :", "return   Keys . MINUS ;", "case   GLFW . GLFW _ KEY _ KP _ ADD    :", "return   Keys . PLUS ;", "case   GLFW . GLFW _ KEY _ KP _ ENTER    :", "return   Keys . ENTER ;", "case   GLFW . GLFW _ KEY _ KP _ EQUAL    :", "return   Keys . EQUALS ;", "case   GLFW . GLFW _ KEY _ LEFT _ SHIFT    :", "return   Keys . SHIFT _ LEFT ;", "case   GLFW . GLFW _ KEY _ LEFT _ CONTROL    :", "return   Keys . CONTROL _ LEFT ;", "case   GLFW . GLFW _ KEY _ LEFT _ ALT    :", "return   Keys . ALT _ LEFT ;", "case   GLFW . GLFW _ KEY _ LEFT _ SUPER    :", "return   Keys . SYM ;", "case   GLFW . GLFW _ KEY _ RIGHT _ SHIFT    :", "return   Keys . SHIFT _ RIGHT ;", "case   GLFW . GLFW _ KEY _ RIGHT _ CONTROL    :", "return   Keys . CONTROL _ RIGHT ;", "case   GLFW . GLFW _ KEY _ RIGHT _ ALT    :", "return   Keys . ALT _ RIGHT ;", "case   GLFW . GLFW _ KEY _ RIGHT _ SUPER    :", "return   Keys . SYM ;", "case   GLFW . GLFW _ KEY _ MENU    :", "return   Keys . MENU ;", "default    :", "return   Keys . UNKNOWN ;", "}", "}", "METHOD_END"], "methodName": ["getGdxKeyCode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Input"}, {"methodBody": ["METHOD_START", "{", "switch    ( gdxKeyCode )     {", "case   Keys . SPACE    :", "return   GLFW . GLFW _ KEY _ SPACE ;", "case   Keys . APOSTROPHE    :", "return   GLFW . GLFW _ KEY _ APOSTROPHE ;", "case   Keys . COMMA    :", "return   GLFW . GLFW _ KEY _ COMMA ;", "case   Keys . PERIOD    :", "return   GLFW . GLFW _ KEY _ PERIOD ;", "case   Keys . NUM _  0     :", "return   GLFW . GLFW _ KEY _  0  ;", "case   Keys . NUM _  1     :", "return   GLFW . GLFW _ KEY _  1  ;", "case   Keys . NUM _  2     :", "return   GLFW . GLFW _ KEY _  2  ;", "case   Keys . NUM _  3     :", "return   GLFW . GLFW _ KEY _  3  ;", "case   Keys . NUM _  4     :", "return   GLFW . GLFW _ KEY _  4  ;", "case   Keys . NUM _  5     :", "return   GLFW . GLFW _ KEY _  5  ;", "case   Keys . NUM _  6     :", "return   GLFW . GLFW _ KEY _  6  ;", "case   Keys . NUM _  7     :", "return   GLFW . GLFW _ KEY _  7  ;", "case   Keys . NUM _  8     :", "return   GLFW . GLFW _ KEY _  8  ;", "case   Keys . NUM _  9     :", "return   GLFW . GLFW _ KEY _  9  ;", "case   Keys . SEMICOLON    :", "return   GLFW . GLFW _ KEY _ SEMICOLON ;", "case   Keys . EQUALS    :", "return   GLFW . GLFW _ KEY _ EQUAL ;", "case   Keys . A    :", "return   GLFW . GLFW _ KEY _ A ;", "case   Keys . B    :", "return   GLFW . GLFW _ KEY _ B ;", "case   Keys . C    :", "return   GLFW . GLFW _ KEY _ C ;", "case   Keys . D    :", "return   GLFW . GLFW _ KEY _ D ;", "case   Keys . E    :", "return   GLFW . GLFW _ KEY _ E ;", "case   Keys . F    :", "return   GLFW . GLFW _ KEY _ F ;", "case   Keys . G    :", "return   GLFW . GLFW _ KEY _ G ;", "case   Keys . H    :", "return   GLFW . GLFW _ KEY _ H ;", "case   Keys . I    :", "return   GLFW . GLFW _ KEY _ I ;", "case   Keys . J    :", "return   GLFW . GLFW _ KEY _ J ;", "case   Keys . K    :", "return   GLFW . GLFW _ KEY _ K ;", "case   Keys . L    :", "return   GLFW . GLFW _ KEY _ L ;", "case   Keys . M    :", "return   GLFW . GLFW _ KEY _ M ;", "case   Keys . N    :", "return   GLFW . GLFW _ KEY _ N ;", "case   Keys . O    :", "return   GLFW . GLFW _ KEY _ O ;", "case   Keys . P    :", "return   GLFW . GLFW _ KEY _ P ;", "case   Keys . Q    :", "return   GLFW . GLFW _ KEY _ Q ;", "case   Keys . R    :", "return   GLFW . GLFW _ KEY _ R ;", "case   Keys . S    :", "return   GLFW . GLFW _ KEY _ S ;", "case   Keys . T    :", "return   GLFW . GLFW _ KEY _ T ;", "case   Keys . U    :", "return   GLFW . GLFW _ KEY _ U ;", "case   Keys . V    :", "return   GLFW . GLFW _ KEY _ V ;", "case   Keys . W    :", "return   GLFW . GLFW _ KEY _ W ;", "case   Keys . X    :", "return   GLFW . GLFW _ KEY _ X ;", "case   Keys . Y    :", "return   GLFW . GLFW _ KEY _ Y ;", "case   Keys . Z    :", "return   GLFW . GLFW _ KEY _ Z ;", "case   Keys . LEFT _ BRACKET    :", "return   GLFW . GLFW _ KEY _ LEFT _ BRACKET ;", "case   Keys . BACKSLASH    :", "return   GLFW . GLFW _ KEY _ BACKSLASH ;", "case   Keys . RIGHT _ BRACKET    :", "return   GLFW . GLFW _ KEY _ RIGHT _ BRACKET ;", "case   Keys . GRAVE    :", "return   GLFW . GLFW _ KEY _ GRAVE _ ACCENT ;", "case   Keys . ESCAPE    :", "return   GLFW . GLFW _ KEY _ ESCAPE ;", "case   Keys . ENTER    :", "return   GLFW . GLFW _ KEY _ ENTER ;", "case   Keys . TAB    :", "return   GLFW . GLFW _ KEY _ TAB ;", "case   Keys . BACKSPACE    :", "return   GLFW . GLFW _ KEY _ BACKSPACE ;", "case   Keys . INSERT    :", "return   GLFW . GLFW _ KEY _ INSERT ;", "case   Keys . FORWARD _ DEL    :", "return   GLFW . GLFW _ KEY _ DELETE ;", "case   Keys . RIGHT    :", "return   GLFW . GLFW _ KEY _ RIGHT ;", "case   Keys . LEFT    :", "return   GLFW . GLFW _ KEY _ LEFT ;", "case   Keys . DOWN    :", "return   GLFW . GLFW _ KEY _ DOWN ;", "case   Keys . UP    :", "return   GLFW . GLFW _ KEY _ UP ;", "case   Keys . PAGE _ UP    :", "return   GLFW . GLFW _ KEY _ PAGE _ UP ;", "case   Keys . PAGE _ DOWN    :", "return   GLFW . GLFW _ KEY _ PAGE _ DOWN ;", "case   Keys . HOME    :", "return   GLFW . GLFW _ KEY _ HOME ;", "case   Keys . END    :", "return   GLFW . GLFW _ KEY _ END ;", "case   Keys . F 1     :", "return   GLFW . GLFW _ KEY _ F 1  ;", "case   Keys . F 2     :", "return   GLFW . GLFW _ KEY _ F 2  ;", "case   Keys . F 3     :", "return   GLFW . GLFW _ KEY _ F 3  ;", "case   Keys . F 4     :", "return   GLFW . GLFW _ KEY _ F 4  ;", "case   Keys . F 5     :", "return   GLFW . GLFW _ KEY _ F 5  ;", "case   Keys . F 6     :", "return   GLFW . GLFW _ KEY _ F 6  ;", "case   Keys . F 7     :", "return   GLFW . GLFW _ KEY _ F 7  ;", "case   Keys . F 8     :", "return   GLFW . GLFW _ KEY _ F 8  ;", "case   Keys . F 9     :", "return   GLFW . GLFW _ KEY _ F 9  ;", "case   Keys . F 1  0     :", "return   GLFW . GLFW _ KEY _ F 1  0  ;", "case   Keys . F 1  1     :", "return   GLFW . GLFW _ KEY _ F 1  1  ;", "case   Keys . F 1  2     :", "return   GLFW . GLFW _ KEY _ F 1  2  ;", "case   Keys . NUMPAD _  0     :", "return   GLFW . GLFW _ KEY _ KP _  0  ;", "case   Keys . NUMPAD _  1     :", "return   GLFW . GLFW _ KEY _ KP _  1  ;", "case   Keys . NUMPAD _  2     :", "return   GLFW . GLFW _ KEY _ KP _  2  ;", "case   Keys . NUMPAD _  3     :", "return   GLFW . GLFW _ KEY _ KP _  3  ;", "case   Keys . NUMPAD _  4     :", "return   GLFW . GLFW _ KEY _ KP _  4  ;", "case   Keys . NUMPAD _  5     :", "return   GLFW . GLFW _ KEY _ KP _  5  ;", "case   Keys . NUMPAD _  6     :", "return   GLFW . GLFW _ KEY _ KP _  6  ;", "case   Keys . NUMPAD _  7     :", "return   GLFW . GLFW _ KEY _ KP _  7  ;", "case   Keys . NUMPAD _  8     :", "return   GLFW . GLFW _ KEY _ KP _  8  ;", "case   Keys . NUMPAD _  9     :", "return   GLFW . GLFW _ KEY _ KP _  9  ;", "case   Keys . SLASH    :", "return   GLFW . GLFW _ KEY _ KP _ DIVIDE ;", "case   Keys . STAR    :", "return   GLFW . GLFW _ KEY _ KP _ MULTIPLY ;", "case   Keys . MINUS    :", "return   GLFW . GLFW _ KEY _ KP _ SUBTRACT ;", "case   Keys . PLUS    :", "return   GLFW . GLFW _ KEY _ KP _ ADD ;", "case   Keys . SHIFT _ LEFT    :", "return   GLFW . GLFW _ KEY _ LEFT _ SHIFT ;", "case   Keys . CONTROL _ LEFT    :", "return   GLFW . GLFW _ KEY _ LEFT _ CONTROL ;", "case   Keys . ALT _ LEFT    :", "return   GLFW . GLFW _ KEY _ LEFT _ ALT ;", "case   Keys . SYM    :", "return   GLFW . GLFW _ KEY _ LEFT _ SUPER ;", "case   Keys . SHIFT _ RIGHT    :", "return   GLFW . GLFW _ KEY _ RIGHT _ SHIFT ;", "case   Keys . CONTROL _ RIGHT    :", "return   GLFW . GLFW _ KEY _ RIGHT _ CONTROL ;", "case   Keys . ALT _ RIGHT    :", "return   GLFW . GLFW _ KEY _ RIGHT _ ALT ;", "case   Keys . MENU    :", "return   GLFW . GLFW _ KEY _ MENU ;", "default    :", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getGlfwKeyCode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Input"}, {"methodBody": ["METHOD_START", "{", "justTouched    =    false ;", "if    ( keyJustPressed )     {", "keyJustPressed    =    false ;", "for    ( int   i    =     0  ;    i    <     ( justPressedKeyength )  ;    i +  +  )     {", "justPressedKeys [ i ]     =    false ;", "}", "}", "deltaX    =     0  ;", "deltaY    =     0  ;", "}", "METHOD_END"], "methodName": ["prepareNext"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Input"}, {"methodBody": ["METHOD_START", "{", "justTouched    =    false ;", "keyJustPressed    =    false ;", "for    ( int   i    =     0  ;    i    <     ( justPressedKeyength )  ;    i +  +  )     {", "justPressedKeys [ i ]     =    false ;", "}", "eventQueue . setProcessor ( null )  ;", "eventQueue . drain (  )  ;", "}", "METHOD_END"], "methodName": ["resetPollingStates"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Input"}, {"methodBody": ["METHOD_START", "{", "eventQueue . setProcessor ( inputProcessor )  ;", "eventQueue . drain (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Input"}, {"methodBody": ["METHOD_START", "{", "resetPollingStates (  )  ;", "GLFW . glfwSetKeyCall ( window . getWindowHandle (  )  ,    keyCall )  ;", "GLFW . glfwSetCharCall ( window . getWindowHandle (  )  ,    charCall )  ;", "GLFW . glfwSetScrollCall ( window . getWindowHandle (  )  ,    scrollCall )  ;", "GLFW . glfwSetCursorPosCall ( window . getWindowHandle (  )  ,    cursorPosCall )  ;", "GLFW . glfwSetMouseButtonCall ( window . getWindowHandle (  )  ,    mouseButtonCall )  ;", "}", "METHOD_END"], "methodName": ["windowHandleChanged"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Input"}, {"methodBody": ["METHOD_START", "{", "GdxNativesLoader . load (  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3NativesLoader"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwSetWindowShouldClose ( windowHandle ,    true )  ;", "}", "METHOD_END"], "methodName": ["closeWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "this . windowHandle    =    windowHandle ;", "this . input    =    new   Input ( this )  ;", "this . graphics    =    new   Graphics ( this )  ;", "GLFW . glfwSetWindowFocusCallback ( windowHandle ,    focusCallback )  ;", "GLFW . glfwSetWindowIconifyCallback ( windowHandle ,    iconifyCallback )  ;", "GLFW . glfwSetWindowMaximizeCallback ( windowHandle ,    maximizeCallback )  ;", "GLFW . glfwSetWindowCloseCallback ( windowHandle ,    closeCallback )  ;", "GLFW . glfwSetDropCallback ( windowHandle ,    dropCallback )  ;", "GLFW . glfwSetWindowRefreshCallback ( windowHandle ,    refreshCallback )  ;", "if    (  ( windowListener )     !  =    null )     {", "windowListener . created ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwFocusWindow ( windowHandle )  ;", "}", "METHOD_END"], "methodName": ["focusWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   config ;", "}", "METHOD_END"], "methodName": ["getConfig"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   graphics ;", "}", "METHOD_END"], "methodName": ["getGraphics"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   input ;", "}", "METHOD_END"], "methodName": ["getInput"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   listener ;", "}", "METHOD_END"], "methodName": ["getListener"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwGetWindowPos ( windowHandle ,    tmpBuffer ,    tmpBuffer 2  )  ;", "return   tmpBuffer . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getPositionX"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwGetWindowPos ( windowHandle ,    tmpBuffer ,    tmpBuffer 2  )  ;", "return   tmpBuffer 2  . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getPositionY"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   windowHandle ;", "}", "METHOD_END"], "methodName": ["getWindowHandle"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   windowListener ;", "}", "METHOD_END"], "methodName": ["getWindowListener"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwIconifyWindow ( windowHandle )  ;", "}", "METHOD_END"], "methodName": ["iconifyWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( listenerInitialized )  )     {", "listener . create (  )  ;", "listener . resize ( graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "listenerInitialized    =    true ;", "}", "}", "METHOD_END"], "methodName": ["initializeListener"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   listenerInitialized ;", "}", "METHOD_END"], "methodName": ["isListenerInitialized"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "Gdx . graphics    =    graphics ;", "Gdx . gl 3  0     =    graphics . getGL 3  0  (  )  ;", "Gdx . gl 2  0     =     (  ( Gdx . gl 3  0  )     !  =    null )     ?    Gdx . gl 3  0     :    graphics . getGL 2  0  (  )  ;", "Gdx . gl    =     (  ( Gdx . gl 3  0  )     !  =    null )     ?    Gdx . gl 3  0     :    Gdx . gl 2  0  ;", "Gdx . input    =    input ;", "GLFW . glfwMakeContextCurrent ( wHandle )  ;", "}", "METHOD_END"], "methodName": ["makeCurrent"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwMaximizeWindow ( windowHandle )  ;", "}", "METHOD_END"], "methodName": ["maximizeWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "nchronized ( runnable    {", "runnableadd ( runnable )  ;", "}", "}", "METHOD_END"], "methodName": ["postRunnable"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "this . requestRering    =    true ;", "}", "}", "METHOD_END"], "methodName": ["requestRendering"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwRestoreWindow ( windowHandle )  ;", "}", "METHOD_END"], "methodName": ["restoreWindow"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Window . setIcon ( windowHandle ,    image )  ;", "}", "METHOD_END"], "methodName": ["setIcon"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "if    ( SharedLibraryLoader . isMac )", "return ;", "GLFWImage . Buffer   buffer    =    GLFWImage . malloc ( images . length )  ;", "Pixmap [  ]    tmpPixmaps    =    new   Pixmap [ images . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( images . length )  ;    i +  +  )     {", "Pixmap   pixmap    =    images [ i ]  ;", "if    (  ( pixmap . getFormat (  )  )     !  =     ( Format . RGBA 8  8  8  8  )  )     {", "Pixmap   rgba    =    new   Pixmap ( pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    Format . RGBA 8  8  8  8  )  ;", "rgba . setBlending ( None )  ;", "rgba . drawPixmap ( pixmap ,     0  ,     0  )  ;", "tmpPixmaps [ i ]     =    rgba ;", "pixmap    =    rgba ;", "}", "GLFWImage   icon    =    GLFWImage . malloc (  )  ;", "icon . set ( pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    pixmap . getPixels (  )  )  ;", "buffer . put ( icon )  ;", "icon . free (  )  ;", "}", "buffer . position (  0  )  ;", "GLFW . glfwSetIcon ( windowHandle ,    buffer )  ;", "buffer . free (  )  ;", "for    ( Pixmap   pixmap    :    tmpPixmaps )     {", "if    ( pixmap    !  =    null )     {", "pixmap . dispose (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setIcon"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "if    ( SharedLibraryLoader . isMac )", "return ;", "Pixmap [  ]    pixmaps    =    new   Pixmap [ imagePaths . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( imagePaths . length )  ;    i +  +  )     {", "pixmaps [ i ]     =    new   Pixmap ( files . getFileHandle ( imagePaths [ i ]  ,    imageFileType )  )  ;", "}", ". setIcon ( windowHandle ,    pixmaps )  ;", "for    ( Pixmap   pixmap    :    pixmaps )     {", "pixmap . dispose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setIcon"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwSetWindowPos ( windowHandle ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "Lwjgl 3 Window . setSizeLimits ( windowHandle ,    minWidth ,    minHeight ,    maxWidth ,    maxHeight )  ;", "}", "METHOD_END"], "methodName": ["setSizeLimits"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwSetWindowSizeLimits ( windowHandle ,     ( minWidth    >     (  -  1  )     ?    minWidth    :    GLFW . GLFW _ DONT _ CARE )  ,     ( minHeight    >     (  -  1  )     ?    minHeight    :    GLFW . GLFW _ DONT _ CARE )  ,     ( maxWidth    >     (  -  1  )     ?    maxWidth    :    GLFW . GLFW _ DONT _ CARE )  ,     ( maxHeight    >     (  -  1  )     ?    maxHeight    :    GLFW . GLFW _ DONT _ CARE )  )  ;", "}", "METHOD_END"], "methodName": ["setSizeLimits"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "GLFW . glfwSetWindowTitle ( windowHandle ,    title )  ;", "}", "METHOD_END"], "methodName": ["setTitle"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "if    ( visible )     {", "GLFW . glfwShow ( windowHandle )  ;", "} else    {", "GLFW . glfwHide ( windowHandle )  ;", "}", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "this . windowListener    =    listener ;", "}", "METHOD_END"], "methodName": ["setWindowListener"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "return   GLFW . glfwWindowShouldClose ( windowHandle )  ;", "}", "METHOD_END"], "methodName": ["shouldClose"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( listenerInitialized )  )     {", "initializeListener (  )  ;", "}", "synchronized ( runnables )     {", "executedRunnables . addAll ( runnables )  ;", "runnables . clear (  )  ;", "}", "for    ( Runnable   runnable    :    executedRunnables )     {", "runnable . run (  )  ;", "}", "boolean   shouldRender    =     (  ( executedRunnables . size )     >     0  )     |  |     ( graphics . isContinuousRendering (  )  )  ;", "executedRunnables . clear (  )  ;", "if    (  !  ( iconified )  )", "input . update (  )  ;", "synchronized ( this )     {", "shouldRender    |  =     ( requestRendering )     &  &     (  !  ( iconified )  )  ;", "requestRendering    =    false ;", "}", "if    ( shouldRender )     {", "graphics . update (  )  ;", "listener . render (  )  ;", "GLFW . glfwSwapBuffers ( wHandle )  ;", "}", "if    (  !  ( iconified )  )", "input . prepareNext (  )  ;", "return   shouldRender ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "this . windowHandle    =    windowHandle ;", "input . windowHandleChanged ( windowHandle )  ;", "}", "METHOD_END"], "methodName": ["windowHandleChanged"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window"}, {"methodBody": ["METHOD_START", "{", "this . autoIconify    =    autoIconify ;", "}", "METHOD_END"], "methodName": ["setAutoIconify"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . windowDecorated    =    decorated ;", "}", "METHOD_END"], "methodName": ["setDecorated"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . fullscreenMode    =     (  ( Lwjgl 3 Graphics . Lwjgl 3 DisplayMode )     ( mode )  )  ;", "}", "METHOD_END"], "methodName": ["setFullscreenMode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "initialBackgroundColor    =    color ;", "}", "METHOD_END"], "methodName": ["setInitialBackgroundColor"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . initialVisible    =    visibility ;", "}", "METHOD_END"], "methodName": ["setInitialVisible"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . windowMaximized    =    maximized ;", "}", "METHOD_END"], "methodName": ["setMaximized"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . windowResizable    =    resizable ;", "}", "METHOD_END"], "methodName": ["setResizable"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . title    =    title ;", "}", "METHOD_END"], "methodName": ["setTitle"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "windowX    =    config . windowX ;", "windowY    =    config . windowY ;", "windowWidth    =    config . windowWidth ;", "windowHeight    =    config . windowHeight ;", "windowMinWidth    =    config . windowMinWidth ;", "windowMinHeight    =    config . windowMinHeight ;", "windowMaxWidth    =    config . windowMaxWidth ;", "windowMaxHeight    =    config . windowMaxHeight ;", "windowResizable    =    config . windowResizable ;", "windowDecorated    =    config . windowDecorated ;", "windowMaximized    =    config . windowMaximized ;", "autoIconify    =    config . autoIconify ;", "windowIconFileType    =    config . windowIconFileType ;", "if    (  ( config . windowIconPaths )     !  =    null )", "windowIconPaths    =    copyOf ( config . windowIconPaths ,    config . windowIconPaths . length )  ;", "windowListener    =    config . windowListener ;", "fullscreenMode    =    config . fullscreenMode ;", "title    =    config . title ;", "initialBackgroundColor    =    config . initialBackgroundColor ;", "initialVisible    =    config . initialVisible ;", "}", "METHOD_END"], "methodName": ["setWindowConfiguration"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "windowIconFileType    =    fileType ;", "windowIconPaths    =    filePaths ;", "}", "METHOD_END"], "methodName": ["setWindowIcon"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "setWindowIcon ( Internal ,    filePaths )  ;", "}", "METHOD_END"], "methodName": ["setWindowIcon"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . windowListener    =    windowListener ;", "}", "METHOD_END"], "methodName": ["setWindowListener"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "windowX    =    x ;", "windowY    =    y ;", "}", "METHOD_END"], "methodName": ["setWindowPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "windowMinWidth    =    minWidth ;", "windowMinHeight    =    minHeight ;", "windowMaxWidth    =    maxWidth ;", "windowMaxHeight    =    maxHeight ;", "}", "METHOD_END"], "methodName": ["setWindowSizeLimits"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . windowWidth    =    width ;", "this . windowHeight    =    height ;", "}", "METHOD_END"], "methodName": ["setWindowedMode"], "fileName": "com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowConfiguration"}, {"methodBody": ["METHOD_START", "{", "line . close (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.JavaSoundAudioRecorder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffer . length )     <     ( numSamples    *     2  )  )", "buffer    =    new   byte [ numSamples    *     2  ]  ;", "int   tad    =    numSamples    *     2  ;", "int   read    =     0  ;", "while    ( read    !  =    tad )", "read    +  =    line . read ( buffer ,    read ,     ( tad    -    read )  )  ;", "for    ( int   i    =     0  ,    j    =     0  ;    i    <     ( numSamples    *     2  )  ;    i    +  =     2     ,    j +  +  )", "samples [  ( offset    +    j )  ]     =     (  ( short )     (  (  ( buffer [  ( i    +     1  )  ]  )     <  <     8  )     |     (  ( buffer [ i ]  )     &     2  5  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.JavaSoundAudioRecorder"}, {"methodBody": ["METHOD_START", "{", "return    ( endOfStream )     &  &     (  ( readIndex )     >  =     ( pcmBuffer . position (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["atEnd"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   endOfStream    ?     0     :     1  ;", "}", "METHOD_END"], "methodName": ["available"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "StreamUtils . closeQuietly ( input )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   oggInfo . channels ;", "}", "METHOD_END"], "methodName": ["getChannels"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   total ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "int   index    =    syncState . buffer ( OggInputStream . BUFFER _ SIZE )  ;", "if    ( index    =  =     (  -  1  )  )", "return   false ;", "buffer    =    syncState . data ;", "if    (  ( buffer )     =  =    null )     {", "endOfStream    =    true ;", "return   false ;", "}", "try    {", "bytes    =    input . read ( buffer ,    index ,    OggInputStream . BUFFER _ SIZE )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  \" Failure   reading   Vorbis .  \"  ,    e )  ;", "}", "syncState . wrote ( bytes )  ;", "if    (  ( syncState . pageout ( page )  )     !  =     1  )     {", "if    (  ( bytes )     <     ( OggInputStream . BUFFER _ SIZE )  )", "return   false ;", "throw   new   GdxRuntimeException (  \" Input   does   not   appear   to   be   an   Ogg   bitstream .  \"  )  ;", "}", "streamState . init ( page . serialno (  )  )  ;", "oggInfo . init (  )  ;", "comment . init (  )  ;", "if    (  ( streamState . pagein ( page )  )     <     0  )     {", "throw   new   GdxRuntimeException (  \" Error   reading   first   page   of   Ogg   bitstream .  \"  )  ;", "}", "if    (  ( streamState . packetout ( packet )  )     !  =     1  )     {", "throw   new   GdxRuntimeException (  \" Error   reading   initial   header   packet .  \"  )  ;", "}", "if    (  ( oggInfo . synthesis _ headerin ( comment ,    packet )  )     <     0  )     {", "throw   new   GdxRuntimeException (  \" Ogg   bitstream   does   not   contain   Vorbis   audio   data .  \"  )  ;", "}", "int   i    =     0  ;", "while    ( i    <     2  )     {", "while    ( i    <     2  )     {", "int   result    =    syncState . pageout ( page )  ;", "if    ( result    =  =     0  )", "break ;", "if    ( result    =  =     1  )     {", "streamState . pagein ( page )  ;", "while    ( i    <     2  )     {", "result    =    streamState . packetout ( packet )  ;", "if    ( result    =  =     0  )", "break ;", "if    ( result    =  =     (  -  1  )  )     {", "throw   new   GdxRuntimeException (  \" Corrupt   secondary   header .  \"  )  ;", "}", "oggInfo . synthesis _ headerin ( comment ,    packet )  ;", "i +  +  ;", "}", "}", "}", "index    =    syncState . buffer ( OggInputStream . BUFFER _ SIZE )  ;", "if    ( index    =  =     (  -  1  )  )", "return   false ;", "buffer    =    syncState . data ;", "try    {", "bytes    =    input . read ( buffer ,    index ,    OggInputStream . BUFFER _ SIZE )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  \" Failed   to   read   Vorbis .  \"  ,    e )  ;", "}", "if    (  (  ( bytes )     =  =     0  )     &  &     ( i    <     2  )  )     {", "throw   new   GdxRuntimeException (  \" End   of   file   before   finding   all   Vorbis   headers .  \"  )  ;", "}", "syncState . wrote ( bytes )  ;", "}", "convsize    =     ( OggInputStream . BUFFER _ SIZE )     /     ( oggInfo . channels )  ;", "dspState . synthesis _ init ( oggInfo )  ;", "vorbisBlock . init ( dspState )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["getPageAndPacket"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   oggInfo . rate ;", "}", "METHOD_END"], "methodName": ["getSampleRate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "initVorbis (  )  ;", "dPCM (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "syncState . init (  )  ;", "}", "METHOD_END"], "methodName": ["initVorbis"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( readIndex )     >  =     ( pcmBuffer . position (  )  )  )     {", "pcmBuffer . clear (  )  ;", "readPCM (  )  ;", "readIndex    =     0  ;", "}", "if    (  ( readIndex )     >  =     ( pcmBuffer . position (  )  )  )     {", "return    -  1  ;", "}", "int   value    =    pcmBuffer . get ( readIndex )  ;", "if    ( value    <     0  )     {", "value    =     2  5  6     +    value ;", "}", "( readIndex )  +  +  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   read ( b ,     0  ,    b . length )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "int   value    =    d (  )  ;", "if    ( value    >  =     0  )     {", "b [ i ]     =     (  ( byte )     ( value )  )  ;", "} else    {", "if    ( i    =  =     0  )     {", "return    -  1  ;", "} else    {", "return   i ;", "}", "}", "}", "return   len ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "boolean   wrote    =    false ;", "while    ( true )     {", "if    ( endOfBitStream )     {", "if    (  !  ( getPageAndPacket (  )  )  )     {", "break ;", "}", "endOfBitStream    =    false ;", "}", "if    (  !  ( inited )  )     {", "inited    =    true ;", "return ;", "}", "float [  ]  [  ]  [  ]     _ pcm    =    new   float [  1  ]  [  ]  [  ]  ;", "int [  ]     _ index    =    new   int [ oggInfo . channels ]  ;", "while    (  !  ( endOfBitStream )  )     {", "while    (  !  ( endOfBitStream )  )     {", "int   result    =    syncState . pageout ( page )  ;", "if    ( result    =  =     0  )     {", "break ;", "}", "if    ( result    =  =     (  -  1  )  )     {", "app . log (  \" gdx - audio \"  ,     \" Error   reading   OGG :    Corrupt   or   missing   data   in   bitstream .  \"  )  ;", "} else    {", "streamState . pagein ( page )  ;", "while    ( true )     {", "result    =    streamState . packetout ( packet )  ;", "if    ( result    =  =     0  )", "break ;", "if    ( result    =  =     (  -  1  )  )     {", "} else    {", "int   samples ;", "if    (  ( vorbisBlock . synthesis ( packet )  )     =  =     0  )     {", "dspState . synthesis _ blockin ( vorbisBlock )  ;", "}", "while    (  ( samples    =    dspState . synthesis _ pcmout (  _ pcm ,     _ index )  )     >     0  )     {", "float [  ]  [  ]    pcm    =     _ pcm [  0  ]  ;", "int   bout    =     ( samples    <     ( convsize )  )     ?    samples    :    convsize ;", "for    ( int   i    =     0  ;    i    <     ( oggInfo . channels )  ;    i +  +  )     {", "int   ptr    =    i    *     2  ;", "int   mono    =     _ index [ i ]  ;", "for    ( int   j    =     0  ;    j    <    bout ;    j +  +  )     {", "int   val    =     (  ( int )     (  ( pcm [ i ]  [  ( mono    +    j )  ]  )     *     3  2  7  6  7  .  0  )  )  ;", "if    ( val    >     3  2  7  6  7  )     {", "val    =     3  2  7  6  7  ;", "}", "if    ( val    <     (  -  3  2  7  6  8  )  )     {", "val    =     -  3  2  7  6  8  ;", "}", "if    ( val    <     0  )", "val    =    val    |     3  2  7  6  8  ;", "if    ( bigEndian )     {", "convbuffer [ ptr ]     =     (  ( byte )     ( val    >  >  >     8  )  )  ;", "convbuffer [  ( ptr    +     1  )  ]     =     (  ( byte )     ( val )  )  ;", "} else    {", "convbuffer [ ptr ]     =     (  ( byte )     ( val )  )  ;", "convbuffer [  ( ptr    +     1  )  ]     =     (  ( byte )     ( val    >  >  >     8  )  )  ;", "}", "ptr    +  =     2     *     ( oggInfo . channels )  ;", "}", "}", "int   bytesToWrite    =     (  2     *     ( oggInfo . channels )  )     *    bout ;", "if    ( bytesToWrite    >     ( pcmBuffer . remaining (  )  )  )     {", "throw   new   GdxRuntimeException (  (  (  (  \" Ogg   block   too   big   to   be   buffered :     \"     +    bytesToWrite )     +     \"     :  :     \"  )     +     ( pcmBuffer . remaining (  )  )  )  )  ;", "} else    {", "pcmBuffer . put ( convbuffer ,     0  ,    bytesToWrite )  ;", "}", "wrote    =    true ;", "dspState . synthesis _ read ( bout )  ;", "}", "}", "}", "if    (  ( page . eos (  )  )     !  =     0  )     {", "endOfBitStream    =    true ;", "}", "if    (  (  !  ( endOfBitStream )  )     &  &    wrote )     {", "return ;", "}", "}", "}", "if    (  !  ( endOfBitStream )  )     {", "bytes    =     0  ;", "int   index    =    syncState . buffer (  . BUFFER _ SIZE )  ;", "if    ( index    >  =     0  )     {", "buffer    =    syncState . data ;", "try    {", "bytes    =    input . read ( buffer ,    index ,     . BUFFER _ SIZE )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  \" Error   during   Vorbis   decoding .  \"  ,    e )  ;", "}", "} else    {", "bytes    =     0  ;", "}", "syncState . wrote ( bytes )  ;", "if    (  ( bytes )     =  =     0  )     {", "endOfBitStream    =    true ;", "}", "}", "}", "streamState . clear (  )  ;", "vorbisBlock . clear (  )  ;", "dspState . clear (  )  ;", "oggInfo . clear (  )  ;", "}", "syncState . clear (  )  ;", "endOfStream    =    true ;", "}", "METHOD_END"], "methodName": ["readPCM"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    allSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    allSources . get ( i )  ;", "int   state    =    alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  ;", "if    ( state    !  =     ( AL _ STOPPED )  )", "alSourceStop ( sourceID )  ;", "alDeleteSources ( sourceID )  ;", "}", "sourceToSoundId . clear (  )  ;", "soundIdToSource . clear (  )  ;", "alcDestroyContext ( context )  ;", "alcCloseDevice ( device )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( recentSounds . length )  ;    i +  +  )     {", "if    (  ( recentSounds [ i ]  )     =  =    sound )", "recentSounds [ i ]     =    null ;", "}", "}", "METHOD_END"], "methodName": ["forget"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )     {", "if    ( sourceToSoundId . containsKey ( sourceID )  )     {", "long   soundId    =    sourceToSoundId . remove ( sourceID )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "alSourceStop ( sourceID )  ;", "alSourcei ( sourceID ,    AL _ BUFFER ,     0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["freeBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "alSourceStop ( sourceID )  ;", "alSourcei ( sourceID ,    AL _ BUFFER ,     0  )  ;", "if    ( sourceToSoundId . containsKey ( sourceID )  )     {", "long   soundId    =    sourceToSoundId . remove ( sourceID )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "idleSources . add ( sourceID )  ;", "}", "METHOD_END"], "methodName": ["freeSource"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( sourceToSoundId . containsKey ( sourceId )  )  )", "return    -  1  ;", "return   sourceToSoundId . get ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["getSoundId"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return   new   audio . AudioDevice (  )     {", "@ Override", "public   void   writeSamples ( float [  ]    samples ,    int   offset ,    int   numSamples )     {", "}", "@ Override", "public   void   writeSamples ( short [  ]    samples ,    int   offset ,    int   numSamples )     {", "}", "@ Override", "public   void   setVolume ( float   volume )     {", "}", "@ Override", "public   boolean   isMono (  )     {", "return   isMono ;", "}", "@ Override", "public   int   getLatency (  )     {", "return    0  ;", "}", "@ Override", "public   void   dispose (  )     {", "}", "}  ;", "return   new   OpenALAudioDevice ( this ,    sampleRate ,    isMono ,    deviceBufferSize ,    deviceBufferCount )  ;", "}", "METHOD_END"], "methodName": ["newAudioDevice"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return   new   audio . AudioRecorder (  )     {", "@ Override", "public   void   read ( short [  ]    samples ,    int   offset ,    int   numSamples )     {", "}", "@ Override", "public   void   dispose (  )     {", "}", "}  ;", "return   new   JavaSoundAudioRecorder ( samplingRate ,    isMono )  ;", "}", "METHOD_END"], "methodName": ["newAudioRecorder"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )", "throw   new   IllegalArgumentException (  \" file   cannot   be   null .  \"  )  ;", "Class <  ?    extends   OpenALMusic >    musicClass    =    extensionToMusicClass . get ( file . extension (  )  . toLowerCase (  )  )  ;", "if    ( musicClass    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Unknown   file   extension   for   music :     \"     +    file )  )  ;", "try    {", "return   musicClass . getConstructor ( new   Class [  ]  {    OpenALAudio . class ,    FileHandle . class    }  )  . newInstance ( this ,    file )  ;", "}    catch    ( Exception   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  \" Error   creating   music    \"     +     ( musicClass . getName (  )  )  )     +     \"    for   file :     \"  )     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newMusic"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )", "throw   new   IllegalArgumentException (  \" file   cannot   be   null .  \"  )  ;", "Class <  ?    extends   OpenALSound >    soundClass    =    extensionToSoundClass . get ( file . extension (  )  . toLowerCase (  )  )  ;", "if    ( soundClass    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Unknown   file   extension   for   sound :     \"     +    file )  )  ;", "try    {", "return   soundClass . getConstructor ( new   Class [  ]  {    OpenALAudio . class ,    FileHandle . class    }  )  . newInstance ( this ,    file )  ;", "}    catch    ( Exception   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  \" Error   creating   sound    \"     +     ( soundClass . getName (  )  )  )     +     \"    for   file :     \"  )     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newSound"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return    0  ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceId    =    idleSources . get ( i )  ;", "int   state    =    alGetSourcei ( sourceId ,    AL _ SOURCE _ STATE )  ;", "if    (  ( state    !  =     ( AL _ PLAYING )  )     &  &     ( state    !  =     ( AL _ PAUSED )  )  )     {", "if    ( isMusic )     {", "idleSources . removeIndex ( i )  ;", "} else    {", "if    ( sourceToSoundId . containsKey ( sourceId )  )     {", "long   soundId    =    sourceToSoundId . get ( sourceId )  ;", "sourceToSoundId . remove ( sourceId )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "long   soundId    =     ( nextSoundId )  +  +  ;", "sourceToSoundId . put ( sourceId ,    soundId )  ;", "soundIdToSource . put ( soundId ,    sourceId )  ;", "}", "alSourceStop ( sourceId )  ;", "alSourcei ( sourceId ,    AL _ BUFFER ,     0  )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ GAIN ,     1  )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ PITCH ,     1  )  ;", "AL 1  0  . alSource 3 f ( sourceId ,    AL _ POSITION ,     0  ,     0  ,     1  .  0 F )  ;", "return   sourceId ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["obtainSource"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "alSourcePause ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["pauseSound"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )", "alSourcePause ( sourceID )  ;", "}", "}", "METHOD_END"], "methodName": ["pauseSourcesWithBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( extension    =  =    null )", "throw   new   IllegalArgumentException (  \" extension   cannot   be   null .  \"  )  ;", "if    ( musicClass    =  =    null )", "throw   new   IllegalArgumentException (  \" musicClass   cannot   be   null .  \"  )  ;", "extensionToMusicClass . put ( extension ,    musicClass )  ;", "}", "METHOD_END"], "methodName": ["registerMusic"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( extension    =  =    null )", "throw   new   IllegalArgumentException (  \" extension   cannot   be   null .  \"  )  ;", "if    ( soundClass    =  =    null )", "throw   new   IllegalArgumentException (  \" soundClass   cannot   be   null .  \"  )  ;", "extensionToSoundClass . put ( extension ,    soundClass )  ;", "}", "METHOD_END"], "methodName": ["registerSound"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "if    (  ( alGetSourcei ( sourceId ,    AL _ SOURCE _ STATE )  )     =  =     ( AL _ PAUSED )  )", "alSourcePlay ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["resumeSound"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )     {", "if    (  ( alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  )     =  =     ( AL _ PAUSED )  )", "alSourcePlay ( sourceID )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resumeSourcesWithBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "( mostRecetSound )  +  +  ;", "mostRecetSound    %  =    recentSouength ;", "if    ( stop )     {", "if    (  ( recentSounds [ mostRecetSound ]  )     !  =    null )", "recentSounds [ mostRecetSound ]  . stop (  )  ;", "}", "recentSounds [ mostRecetSound ]     =    sound ;", "}", "METHOD_END"], "methodName": ["retain"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setSoundGain"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "alSourcei ( sourceId ,    AL _ LOOPING ,     ( looping    ?    AL 1  0  . AL _ TRUE    :    AL 1  0  . AL _ FALSE )  )  ;", "}", "METHOD_END"], "methodName": ["setSoundLooping"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "AL 1  0  . alSource 3 f ( sourceId ,    AL _ POSITION ,    MathUtils . cos (  (  (  ( pan    -     1  )     *     ( MathUtils . PI )  )     /     2  )  )  ,     0  ,    MathUtils . sin (  (  (  ( pan    +     1  )     *     ( MathUtils . PI )  )     /     2  )  )  )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setSoundPan"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ PITCH ,    pitch )  ;", "}", "METHOD_END"], "methodName": ["setSoundPitch"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "alSourceStop ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["stopSound"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )     {", "if    ( sourceToSoundId . containsKey ( sourceID )  )     {", "long   soundId    =    sourceToSoundId . remove ( sourceID )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "alSourceStop ( sourceID )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stopSourcesWithBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDev )", "return ;", "for    ( int   i    =     0  ;    i    <     ( mussize )  ;    i +  +  )", "musitems [ i ]  . update (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffers )     =  =    null )", "return ;", "if    (  ( sourceID )     !  =     (  -  1  )  )     {", "freeSource ( sourceID )  ;", "sourceID    =     -  1  ;", "}", "alDeleteBuffers ( buffers )  ;", "buffers    =    null ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "int   written    =    Math . min ( bufferSize ,    length )  ;", "outer    :    while    ( true )     {", "int   buffers    =    alGetSourcei ( sourceID ,    AL _ BUFFERS _ PROCESSED )  ;", "while    (  ( buffers -  -  )     >     0  )     {", "int   bufferID    =    alSourceUnqueueBuffers ( sourceID )  ;", "if    ( bufferID    =  =     ( AL _ INVALID _ VALUE )  )", "break ;", "reredSeconds    +  =    secondsPerBuffer ;", "tempBuffer . clear (  )  ;", "tempBuffer . put ( data ,    offset ,    written )  . flip (  )  ;", "alBufferData ( bufferID ,    format ,    tempBuffer ,    sampleRate )  ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "break   outer ;", "}", "try    {", "Thread . sleep (  (  ( long )     (  1  0  0  0     *     ( secondsPerBuffer )  )  )  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "}", "if    (  (  !  ( isPlaying )  )     |  |     (  ( alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  )     !  =     ( AL _ PLAYING )  )  )     {", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "return   written ;", "}", "METHOD_END"], "methodName": ["fillBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return    ( format )     =  =     ( AL _ FORMAT _ STEREO 1  6  )     ?     2     :     1  ;", "}", "METHOD_END"], "methodName": ["getChannels"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  (  ( secondsPerBuffer )     *     ( bufferCount )  )     *     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getLatency"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return    0  ;", "return    ( reredSeconds )     +     ( alGetSourcef ( sourceID ,    AL _ SEC _ OFFSET )  )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return   sampleRate ;", "}", "METHOD_END"], "methodName": ["getRate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return    ( channels )     =  =     1  ;", "}", "METHOD_END"], "methodName": ["isMono"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return   false ;", "return   isPlaying ;", "}", "METHOD_END"], "methodName": ["isPlaying"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "renderedSeconds    =    position ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "this . volume    =    volume ;", "if    (  ( sourceID )     !  =     (  -  1  )  )", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setVolume"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "freeSource ( sourceID )  ;", "sourceID    =     -  1  ;", "renderedSeconds    =     0  ;", "isPlaying    =    false ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    ( length    <     0  )", "throw   new   IllegalArgumentException (  \" length   cannot   be    <     0  .  \"  )  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )     {", "sourceID    =    audio . obtainSource ( true )  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "if    (  ( buffers )     =  =    null )     {", "buffers    =    BufferUtils . createIntBuffer ( bufferCount )  ;", "alGenBuffers ( buffers )  ;", "if    (  ( alGetError (  )  )     !  =     ( AL _ NO _ ERROR )  )", "throw   new   utils . GdxRuntimeException (  \" Unabe   to   allocate   audio   buffers .  \"  )  ;", "}", "alSourcei ( sourceID ,    AL _ LOOPING ,    AL _ FALSE )  ;", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "int   queuedBuffers    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "int   written    =    Math . min ( bufferSize ,    length )  ;", "tempBuffer . clear (  )  ;", "tempBuffer . put ( data ,    offset ,    written )  . flip (  )  ;", "alBufferData ( bufferID ,    format ,    tempBuffer ,    sampleRate )  ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "length    -  =    written ;", "offset    +  =    written ;", "queuedBuffers +  +  ;", "}", "tempBuffer . clear (  )  . flip (  )  ;", "for    ( int   i    =    queuedBuffers ;    i    <     ( bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "alBufferData ( bufferID ,    format ,    tempBuffer ,    sampleRate )  ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "}", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "while    ( length    >     0  )     {", "int   written    =    fillBuffer ( data ,    offset ,    length )  ;", "length    -  =    written ;", "offset    +  =    written ;", "}", "}", "METHOD_END"], "methodName": ["writeSamples"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( bytes )     =  =    null )     |  |     (  ( bytes . length )     <     ( numSamples    *     2  )  )  )", "bytes    =    new   byte [ numSamples    *     2  ]  ;", "int   end    =    Math . min (  ( offset    +    numSamples )  ,    samples . length )  ;", "for    ( int   i    =    offset ,    ii    =     0  ;    i    <    end ;    i +  +  )     {", "float   floatSample    =    samples [ i ]  ;", "floatSample    =    MathUtils . clamp ( floatSample ,     (  -  1  .  0 F )  ,     1  .  0 F )  ;", "int   intSample    =     (  ( int )     ( floatSample    *     3  2  7  6  7  )  )  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     ( intSample    &     2  5  5  )  )  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     (  ( intSample    >  >     8  )     &     2  5  5  )  )  ;", "}", "writeSamples ( bytes ,     0  ,     ( numSamples    *     2  )  )  ;", "}", "METHOD_END"], "methodName": ["writeSamples"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( bytes )     =  =    null )     |  |     (  ( bytes . length )     <     ( numSamples    *     2  )  )  )", "bytes    =    new   byte [ numSamples    *     2  ]  ;", "int   end    =    Math . min (  ( offset    +    numSamples )  ,    samples . length )  ;", "for    ( int   i    =    offset ,    ii    =     0  ;    i    <    end ;    i +  +  )     {", "short   sample    =    samples [ i ]  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     ( sample    &     2  5  5  )  )  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     (  ( sample    >  >     8  )     &     2  5  5  )  )  ;", "}", "writeSamples ( bytes ,     0  ,     ( numSamples    *     2  )  )  ;", "}", "METHOD_END"], "methodName": ["writeSamples"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "stop (  )  ;", "if    ( noDevice )", "return ;", "if    (  ( buffers )     =  =    null )", "return ;", "alDeleteBuffers ( buffers )  ;", "buffers    =    null ;", "onCompletionListener    =    null ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "OpenALMusic . tempBuffer . clear (  )  ;", "int   length    =    read ( OpenALMusic . tempBytes )  ;", "if    ( length    <  =     0  )     {", "if    ( isLooping )     {", "loop (  )  ;", "length    =    read ( OpenALMusic . tempBytes )  ;", "if    ( length    <  =     0  )", "return   false ;", "if    (  ( renderedSecondsQueue . size )     >     0  )     {", "renderedSecondsQueue . set (  0  ,     0  )  ;", "}", "} else", "return   false ;", "}", "float   previousLoadedSeconds    =     (  ( renderedSecondsQueue . size )     >     0  )     ?    renderedSecondsQueue . first (  )     :     0  ;", "float   currentBufferSeconds    =     (  ( maxSecondsPerBuffer )     *     (  ( float )     ( length )  )  )     /     (  ( float )     ( OpenALMusic . bufferSize )  )  ;", "renderedSecondsQueue . insert (  0  ,     ( previousLoadedSeconds    +    currentBufferSeconds )  )  ;", "OpenALMusic . tempBuffer . put ( OpenALMusic . tempBytes ,     0  ,    length )  . flip (  )  ;", "alBufferData ( bufferID ,    format ,    OpenALMusic . tempBuffer ,    sampleRate )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return    ( format )     =  =     ( AL _ FORMAT _ STEREO 1  6  )     ?     2     :     1  ;", "}", "METHOD_END"], "methodName": ["getChannels"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return    0  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return    0  ;", "return    ( renderedSeconds )     +     ( alGetSourcef ( sourceID ,    AL _ SEC _ OFFSET )  )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   sampleRate ;", "}", "METHOD_END"], "methodName": ["getRate"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   sourceID ;", "}", "METHOD_END"], "methodName": ["getSourceId"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   this . volume ;", "}", "METHOD_END"], "methodName": ["getVolume"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   isLooping ;", "}", "METHOD_END"], "methodName": ["isLooping"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return   false ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return   false ;", "return   isPlaying ;", "}", "METHOD_END"], "methodName": ["isPlaying"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "reset (  )  ;", "}", "METHOD_END"], "methodName": ["loop"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     !  =     (  -  1  )  )", "alSourcePause ( sourceID )  ;", "isPlaying    =    false ;", "}", "METHOD_END"], "methodName": ["pause"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )     {", "sourceID    =    audio . obtainSource ( true )  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "audio . music . add ( this )  ;", "if    (  ( buffers )     =  =    null )     {", "buffers    =    BufferUtils . createIntBuffer ( OpenALMusic . bufferCount )  ;", "alGenBuffers ( buffers )  ;", "int   errorCode    =    alGetError (  )  ;", "if    ( errorCode    !  =     ( AL _ NO _ ERROR )  )", "throw   new   utils . GdxRuntimeException (  (  \" Unable   to   allocate   audio   buffers .    AL   Error :     \"     +    errorCode )  )  ;", "}", "alSourcei ( sourceID ,    AL _ DIRECT _ CHANNELS _ SOFT ,    AL _ TRUE )  ;", "alSourcei ( sourceID ,    AL _ LOOPING ,    AL _ FALSE )  ;", "setPan ( pan ,    volume )  ;", "boolean   filled    =    false ;", "for    ( int   i    =     0  ;    i    <     ( OpenALMusic . bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "if    (  !  ( fill ( bufferID )  )  )", "break ;", "filled    =    true ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "}", "if    (  (  ! filled )     &  &     (  ( onCompletionListener )     !  =    null )  )", "onCompletionListener . onCompletion ( this )  ;", "if    (  ( alGetError (  )  )     !  =     ( AL _ NO _ ERROR )  )     {", "stop (  )  ;", "return ;", "}", "}", "if    (  !  ( isPlaying )  )     {", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . isLooping    =    isLooping ;", "}", "METHOD_END"], "methodName": ["setLooping"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "onCompletionListener    =    listener ;", "}", "METHOD_END"], "methodName": ["setOnCompletionListener"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . volume    =    volume ;", "this . pan    =    pan ;", "if    ( noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "alSource 3 f ( sourceID ,    AL _ POSITION ,    MathUtils . cos (  (  (  ( pan    -     1  )     *     ( MathUtils . PI )  )     /     2  )  )  ,     0  ,    MathUtils . sin (  (  (  ( pan    +     1  )     *     ( MathUtils . PI )  )     /     2  )  )  )  ;", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setPan"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "boolean   wasPlaying    =    isPlaying ;", "isPlaying    =    false ;", "alSourceStop ( sourceID )  ;", "alSourceUnqueueBuffers ( sourceID ,    buffers )  ;", "while    (  ( renderedSecondsQueue . size )     >     0  )     {", "renderedSeconds    =    renderedSecondsQueue . pop (  )  ;", "}", "if    ( position    <  =     ( renderedSeconds )  )     {", "reset (  )  ;", "renderedSeconds    =     0  ;", "}", "while    (  ( renderedSeconds )     <     ( position    -     ( maxSecondsPerBuffer )  )  )     {", "if    (  ( read (  . tempBytes )  )     <  =     0  )", "break ;", "renderedSeconds    +  =    maxSecondsPerBuffer ;", "}", "renderedSecondsQueue . add ( renderedSeconds )  ;", "boolean   filled    =    false ;", "for    ( int   i    =     0  ;    i    <     (  . bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "if    (  !  ( fill ( bufferID )  )  )", "break ;", "filled    =    true ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "}", "renderedSecondsQueue . pop (  )  ;", "if    (  ! filled )     {", "stop (  )  ;", "if    (  ( onCompletionListener )     !  =    null )", "onCompletionListener . onCompletion ( this )  ;", "}", "alSourcef ( sourceID ,    AL _ SEC _ OFFSET ,     ( position    -     ( renderedSeconds )  )  )  ;", "if    ( wasPlaying )     {", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . volume    =    volume ;", "if    ( noDevice )", "return ;", "if    (  ( sourceID )     !  =     (  -  1  )  )", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setVolume"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . format    =     ( channels    >     1  )     ?    AL _ FORMAT _ STEREO 1  6     :    AL _ FORMAT _ MONO 1  6  ;", "this . sampleRate    =    sampleRate ;", "maxSecondsPerBuffer    =     (  ( float )     (  (  . bufferSize )     -     ( bufferOverhead )  )  )     /     (  (  (  . bytesPerSample )     *    channels )     *    sampleRate )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "audio . music . removeValue ( this ,    true )  ;", "reset (  )  ;", "audio . freeSource ( sourceID )  ;", "sourceID    =     -  1  ;", "renderedSeconds    =     0  ;", "renderedSecondsQueue . clear (  )  ;", "isPlaying    =    false ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "boolean   end    =    false ;", "int   buffers    =    alGetSourcei ( sourceID ,    AL _ BUFFERS _ PROCESSED )  ;", "while    (  ( buffers -  -  )     >     0  )     {", "int   bufferID    =    alSourceUnqueueBuffers ( sourceID )  ;", "if    ( bufferID    =  =     ( AL _ INVALID _ VALUE )  )", "break ;", "renderedSeconds    =    renderedSecondsQueue . pop (  )  ;", "if    ( end )", "continue ;", "if    ( fill ( bufferID )  )", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "else", "end    =    true ;", "}", "if    ( end    &  &     (  ( alGetSourcei ( sourceID ,    AL _ BUFFERS _ QUEUED )  )     =  =     0  )  )     {", "stop (  )  ;", "if    (  ( onCompletionListener )     !  =    null )", "onCompletionListener . onCompletion ( this )  ;", "}", "if    (  ( isPlaying )     &  &     (  ( alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  )     !  =     ( AL _ PLAYING )  )  )", "alSourcePlay ( sourceID )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( bufferID )     =  =     (  -  1  )  )", "return ;", "audio . freeBuffer ( bufferID )  ;", "alDeleteBuffers ( bufferID )  ;", "bufferID    =     -  1  ;", "audio . forget ( this )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "return   duration ;", "}", "METHOD_END"], "methodName": ["duration"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "return   loop (  1  )  ;", "}", "METHOD_END"], "methodName": ["loop"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "return   play (  1  )  ;", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return    0  ;", "int   sourceID    =    audio . obtainSource ( false )  ;", "if    ( sourceID    =  =     (  -  1  )  )     {", "audio . retain ( this ,    true )  ;", "sourceID    =    audio . obtainSource ( false )  ;", "} else", "audio . retain ( this ,    false )  ;", "if    ( sourceID    =  =     (  -  1  )  )", "return    -  1  ;", "long   soundId    =    audio . getSoundId ( sourceID )  ;", "alSourcei ( sourceID ,    AL _ BUFFER ,    bufferID )  ;", "alSourcei ( sourceID ,    AL _ LOOPING ,    AL _ FALSE )  ;", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "alSourcePlay ( sourceID )  ;", "return   soundId ;", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "int   bytes    =     ( pcm . length )     -     (  ( pcm . length )     %     ( channels    >     1     ?     4     :     2  )  )  ;", "int   samples    =    bytes    /     (  2     *    channels )  ;", "duration    =    samples    /     (  ( float )     ( sampleRate )  )  ;", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect ( bytes )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "buffer . put ( pcm ,     0  ,    bytes )  ;", "buffer . flip (  )  ;", "if    (  ( bufferID )     =  =     (  -  1  )  )     {", "bufferID    =    alGenBuffers (  )  ;", "alBufferData ( bufferID ,     ( channels    >     1     ?    AL _ FORMAT _ STEREO 1  6     :    AL _ FORMAT _ MONO 1  6  )  ,    buffer . asShortBuffer (  )  ,    sampleRate )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "audio . stopSourcesWithBuffer ( bufferID )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl3.audio.OpenALSound"}]