[{"methodBody": ["METHOD_START", "{", "return   imageTilePositions . get (  ( tile    -     ( firstgid )  )  )  ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "com.badlogic.gdx.tiledmappacker.TileSetLayout"}, {"methodBody": ["METHOD_START", "{", "return   numCols ;", "}", "METHOD_END"], "methodName": ["getNumCols"], "fileName": "com.badlogic.gdx.tiledmappacker.TileSetLayout"}, {"methodBody": ["METHOD_START", "{", "return   numRows ;", "}", "METHOD_END"], "methodName": ["getNumRows"], "fileName": "com.badlogic.gdx.tiledmappacker.TileSetLayout"}, {"methodBody": ["METHOD_START", "{", "int   tileid    =     ( tile . getId (  )  )     &     (  ~  -  5  3  6  8  7  0  9  1  2  )  ;", "String   tilesetName    =    tilesetNameFromTileId ( map ,    tileid )  ;", "IntArray   usedIds    =    getUsedIdsBucket ( tilesetName ,    bucketSize )  ;", "usedIds . add ( tileid )  ;", "if    (  !  ( tilesetsToPack . containsKey ( tilesetName )  )  )     {", "tilesetsToPack . put ( tilesetName ,    map . getTileSets (  )  . getTileSet ( tilesetName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addTile"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "NodeList   childNodes    =    node . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( childNodes . getLength (  )  )  ;    i +  +  )     {", "if    ( childNodes . item ( i )  . getNodeName (  )  . equals ( childName )  )     {", "NamedNode   attributes    =    childNodes . item ( i )  . getAttributes (  )  ;", "Node   attribute    =    attributes . getNamedItem ( attr )  ;", "if    ( attribute . getNodeValue (  )  . equals ( value )  )", "return   childNodes . item ( i )  ;", "}", "}", "Node   newNode    =    node . getOwnerDocument (  )  . createElement ( childName )  ;", "NamedNode   attributes    =    newNode . getAttributes (  )  ;", "Attr   nodeAttr    =    node . getOwnerDocument (  )  . createAttribute ( attr )  ;", "nodeAttr . setNodeValue ( value )  ;", "attributes . setNamedItem ( nodeAttr )  ;", "if    (  ( childNodes . item (  0  )  )     !  =    null )     {", "return   node . insertBefore ( newNode ,    childNodes . item (  0  )  )  ;", "} else    {", "return   node . appendChild ( newNode )  ;", "}", "}", "METHOD_END"], "methodName": ["getFirstChildByNameAttrValue"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "NodeList   childNodes    =    parent . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( childNodes . getLength (  )  )  ;    i +  +  )     {", "if    ( childNodes . item ( i )  . getNodeName (  )  . equals ( child )  )     {", "return   childNodes . item ( i )  ;", "}", "}", "Node   newNode    =    parent . getOwnerDocument (  )  . createElement ( child )  ;", "if    (  ( childNodes . item (  0  )  )     !  =    null )", "return   parent . insertBefore ( newNode ,    childNodes . item (  0  )  )  ;", "else", "return   parent . endChild ( newNode )  ;", "}", "METHOD_END"], "methodName": ["getFirstChildNodeByName"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "if    ( tilesetUsedIds . containsKey ( tilesetName )  )     {", "return   tilesetUsedIds . get ( tilesetName )  ;", "}", "if    ( size    <  =     0  )     {", "return   null ;", "}", "IntArray   bucket    =    new   IntArray ( size )  ;", "tilesetUsedIds . put ( tilesetName ,    bucket )  ;", "return   bucket ;", "}", "METHOD_END"], "methodName": ["getUsedIdsBucket"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "final   TexturePacker . Settings   texturePackerSettings    =    new   TexturePacker . Settings (  )  ;", "texturePackerSettings . paddingX    =     2  ;", "texturePackerSettings . paddingY    =     2  ;", "texturePackerSettings . edgePadding    =    true ;", "texturePackerSettings . duplicatePadding    =    true ;", "texturePackerSettings . bleed    =    true ;", "texturePackerSettings . alias    =    true ;", "texturePackerSettings . useIndexes    =    true ;", "final   TiledMapPSettings   packerSettings    =    new   TiledMapPSettings (  )  ;", "if    (  ( args . length )     =  =     0  )     {", "TiledMapPacker . printUsage (  )  ;", "System . exit (  0  )  ;", "} else", "if    (  ( args . length )     =  =     1  )     {", "TiledMapPacker . inputDir    =    new   File ( args [  0  ]  )  ;", "TiledMapPacker . outputDir    =    new   File ( TiledMapPacker . inputDir ,     \"  .  .  / output /  \"  )  ;", "} else", "if    (  ( args . length )     =  =     2  )     {", "TiledMapPacker . inputDir    =    new   File ( args [  0  ]  )  ;", "TiledMapPacker . outputDir    =    new   File ( args [  1  ]  )  ;", "} else    {", "TiledMapPacker . inputDir    =    new   File ( args [  0  ]  )  ;", "TiledMapPacker . outputDir    =    new   File ( args [  1  ]  )  ;", "TiledMapPacker . processExtraArgs ( args ,    packerSettings )  ;", "}", "TiledMapPacker   packer    =    new   TiledMapPacker ( packerSettings )  ;", "LwjglApplicationConfiguration   config    =    new   LwjglApplicationConfiguration (  )  ;", "config . forceExit    =    false ;", "config . width    =     1  0  0  ;", "config . height    =     5  0  ;", "config . title    =     \" TiledMapPacker \"  ;", "new   com . badlogic . gdx . backends . lwjgl . LwjglApplication ( new   ApplicationListener (  )     {", "@ Override", "public   void   resume (  )     {", "}", "@ Override", "public   void   resize ( int   width ,    int   height )     {", "}", "@ Override", "public   void   render (  )     {", "}", "@ Override", "public   void   pause (  )     {", "}", "@ Override", "public   void   dispose (  )     {", "}", "@ Override", "public   void   create (  )     {", "TiledMapPacker   packer    =    new   TiledMapPacker ( packerSettings )  ;", "if    (  !  ( TiledMapPacker . inputDir . exists (  )  )  )     {", "System . out . println ( TiledMapPacker . inputDir . getAbsolutePath (  )  )  ;", "throw   new   RuntimeException (  (  \" Input   directory   does   not   exist :     \"     +     ( TiledMapPacker . inputDir )  )  )  ;", "}", "try    {", "packer . processInputDir ( texturePackerSettings )  ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException (  (  \" Error   processing   map :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "System . out . println (  \" Finished   processing .  \"  )  ;", "app . exit (  )  ;", "}", "}  ,    config )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   tile ;", "Vector 2    tileLocation ;", "Graphics   g ;", "packer    =    new   TexturePacker ( texturePackerSettings )  ;", "for    ( TiledMapTileSet   set    :    tilesetsToPack . values (  )  )     {", "String   tilesetName    =    set . getName (  )  ;", "System . out . println (  (  \" Processing   tileset    \"     +    tilesetName )  )  ;", "IntArray   usedIds    =     ( this . settings . stripUnusedTiles )     ?    getUsedIdsBucket ( tilesetName ,     (  -  1  )  )     :    null ;", "int   tileWidth    =    set . getProperties (  )  . get (  \" tilewidth \"  ,    Integer . class )  ;", "int   tileHeight    =    set . getProperties (  )  . get (  \" tileheight \"  ,    Integer . class )  ;", "int   firstgid    =    set . getProperties (  )  . get (  \" firstgid \"  ,    Integer . class )  ;", "String   imageName    =    set . getProperties (  )  . get (  \" imagesource \"  ,    String . class )  ;", "TileSetLayout   layout    =    new   TileSetLayout ( firstgid ,    set ,    inputDirHandle )  ;", "for    ( int   gid    =    layout . firstgid ,    i    =     0  ;    i    <     ( layout . numTiles )  ;    gid +  +     ,    i +  +  )     {", "boolean   verbose    =    this . settings . verbose ;", "if    (  ( usedIds    !  =    null )     &  &     (  !  ( usedIds . contains ( gid )  )  )  )     {", "if    ( verbose )     {", "System . out . println (  (  (  (  (  \" Stripped   id    #  \"     +    gid )     +     \"    from   tileset    \\  \"  \"  )     +    tilesetName )     +     \"  \\  \"  \"  )  )  ;", "}", "continue ;", "}", "tileLocation    =    layout . getLocation ( gid )  ;", "tile    =    new   BufferedImage ( tileWidth ,    tileHeight ,    BufferedImage . TYPE _  4 BYTE _ ABGR )  ;", "g    =    tile . createGraphics (  )  ;", "g . drawImage ( layout . image ,     0  ,     0  ,    tileWidth ,    tileHeight ,     (  ( int )     ( tileLocation . x )  )  ,     (  ( int )     ( tileLocation . y )  )  ,     (  (  ( int )     ( tileLocation . x )  )     +    tileWidth )  ,     (  (  ( int )     ( tileLocation . y )  )     +    tileHeight )  ,    null )  ;", "if    ( verbose )     {", "System . out . println (  (  (  (  (  (  (  (  (  \" Adding    \"     +    tileWidth )     +     \" x \"  )     +    tileHeight )     +     \"     (  \"  )     +     (  ( int )     ( tileLocation . x )  )  )     +     \"  ,     \"  )     +     (  ( int )     ( tileLocation . y )  )  )     +     \"  )  \"  )  )  ;", "}", "int   adjustedGid    =    gid    -     ( layout . firstgid )  ;", "final   String   separator    =     \"  _  \"  ;", "String   regionName    =     ( tilesetName    +    separator )     +    adjustedGid ;", "packer . addImage ( tile ,    regionName )  ;", "}", "}", "String   tilesetOutputDir    =     (  (  . outputDir . toString (  )  )     +     \"  /  \"  )     +     ( this . settings . tilesetOutputDirectory )  ;", "File   relativeTilesetOutputDir    =    new   File ( tilesetOutputDir )  ;", "File   outputDirTilesets    =    new   File ( relativeTilesetOutputDir . getCanonicalPath (  )  )  ;", "outputDirTilesets . mkdirs (  )  ;", "packer . pack ( outputDirTilesets ,     (  ( this . settings . atlasOutputName )     +     \"  . atlas \"  )  )  ;", "}", "METHOD_END"], "methodName": ["packTilesets"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  \" Usage :    INPUTDIR    [ OUTPUTDIR ]     [  -  - strip - unused ]     [  -  - combine - tilesets ]     [  - v ]  \"  )  ;", "System . out . println (  \" Processes   a   directory   of       . tmx   maps .    Unable   to   process   maps   with   XML \"  )  ;", "System . out . println (  \" tile   layer   format .  \"  )  ;", "System . out . println (  \"        -  - strip - unused                                       omits   all   tiles   that   are   not   used .    Speeds   up \"  )  ;", "System . out . println (  \"                                                                                        the   processing .    Smaller   tilesets .  \"  )  ;", "System . out . println (  \"        -  - combine - tilesets                           instead   of   creating   a   tileset   for   each   map ,  \"  )  ;", "System . out . println (  \"                                                                                        this   combines   the   tilesets   into   some   kind \"  )  ;", "System . out . println (  \"                                                                                        of   monster   tileset .    Has   problems   with   tileset \"  )  ;", "System . out . println (  \"                                                                                        location .    Has   problems   with   nested   folders .  \"  )  ;", "System . out . println (  \"                                                                                        Not   recommended .  \"  )  ;", "System . out . println (  \"        - v                                                                           outputs   which   tiles   are   stripped   and   included \"  )  ;", "System . out . println (  )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "String   stripUnused    =     \"  -  - strip - unused \"  ;", "String   combineTilesets    =     \"  -  - combine - tilesets \"  ;", "String   verbose    =     \"  - v \"  ;", "int   length    =     ( args . length )     -     2  ;", "String [  ]    argsNotDir    =    new   String [ length ]  ;", "System . arraycopy ( args ,     2  ,    argsNotDir ,     0  ,    length )  ;", "for    ( String   string    :    argsNotDir )     {", "if    ( stripUnused . equals ( string )  )     {", "packerSettings . stripUnusedTiles    =    true ;", "} else", "if    ( combineTilesets . equals ( string )  )     {", "packerSettings . combineTilesets    =    true ;", "} else", "if    ( verbose . equals ( string )  )     {", "packerSettings . verbose    =    true ;", "} else    {", "System . out . println (  (  (  \"  \\ nOption    \\  \"  \"     +    string )     +     \"  \\  \"    not   recognized .  \\ n \"  )  )  ;", ". printUsage (  )  ;", "System . exit (  0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processExtraArgs"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "FileHandle   inputDirHandle    =    new   FileHandle ( TiledMapPacker . inputDir . getCanonicalPath (  )  )  ;", "File [  ]    mapFilesInCurrentDir    =    TiledMapPacker . inputDir . listFiles ( new   TiledMapPacker . TmxFilter (  )  )  ;", "tilesetsToPack    =    new   utils . ObjectMap < String ,    maps . tiled . TiledMapTileSet >  (  )  ;", "for    ( File   mapFile    :    mapFilesInCurrentDir )     {", "processSingleMap ( mapFile ,    inputDirHandle ,    texturePackerSettings )  ;", "}", "processSubdirectories ( inputDirHandle ,    texturePackerSettings )  ;", "boolean   combineTilesets    =    this . settings . combineTilesets ;", "if    ( combineTilesets    =  =    true )     {", "packTilesets ( inputDirHandle ,    texturePackerSettings )  ;", "}", "}", "METHOD_END"], "methodName": ["processInputDir"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "boolean   combineTilesets    =    this . settings . combineTilesets ;", "if    ( combineTilesets    =  =    false )     {", "tilesetUsedIds    =    new   HashMap < String ,    utils . IntArray >  (  )  ;", "tilesetsToPack    =    new   utils . ObjectMap < String ,    TiledMapTileSet >  (  )  ;", "}", "map    =    mapLoader . load ( mapFile . getCanonicalPath (  )  )  ;", "boolean   stripUnusedTiles    =    this . settings . stripUnusedTiles ;", "if    ( stripUnusedTiles )     {", "stripUnusedTiles (  )  ;", "} else    {", "for    ( TiledMapTileSet   tileset    :    map . getTileSets (  )  )     {", "String   tilesetName    =    tileset . getName (  )  ;", "if    (  !  ( tilesetsToPack . containsKey ( tilesetName )  )  )     {", "tilesetsToPack . put ( tilesetName ,    tileset )  ;", "}", "}", "}", "if    ( combineTilesets    =  =    false )     {", "FileHandle   tmpHandle    =    new   FileHandle ( mapFile . getName (  )  )  ;", "this . settings . atlasOutputName    =    tmpHandle . nameWithoutExtension (  )  ;", "packTilesets ( dirHandle ,    texturePackerSettings )  ;", "}", "FileHandle   tmxFile    =    new   FileHandle ( mapFile . getCanonicalPath (  )  )  ;", "writeUpdatedTMX ( map ,    tmxFile )  ;", "}", "METHOD_END"], "methodName": ["processSingleMap"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "File   parentPath    =    new   File ( currentDir . path (  )  )  ;", "File [  ]    directories    =    parentPath . listFiles ( new    . DirFilter (  )  )  ;", "for    ( File   directory    :    directories )     {", "currentDir    =    new   FileHandle ( directory . getCanonicalPath (  )  )  ;", "File [  ]    mapFilesInCurrentDir    =    directory . listFiles ( new    . TmxFilter (  )  )  ;", "for    ( File   mapFile    :    mapFilesInCurrentDir )     {", "processSingleMap ( mapFile ,    currentDir ,    texturePackerSettings )  ;", "}", "processSubdirectories ( currentDir ,    texturePackerSettings )  ;", "}", "}", "METHOD_END"], "methodName": ["processSubdirectories"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "Node   properties    =    TiledMapPacker . getFirstChildNodeByName ( parent ,     \" properties \"  )  ;", "Node   property    =    TiledMapPacker . getFirstChildByNameAttrValue ( properties ,     \" property \"  ,     \" name \"  ,    name )  ;", "NamedNodeMap   attributes    =    property . getAttributes (  )  ;", "Node   valueNode    =    attributes . getNamedItem (  \" value \"  )  ;", "if    ( valueNode    =  =    null )     {", "valueNode    =    doc . createAttribute (  \" value \"  )  ;", "valueNode . setNodeValue ( value )  ;", "attributes . setNamedItem ( valueNode )  ;", "} else    {", "valueNode . setNodeValue ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "int   mapWidth    =    map . getProperties (  )  . get (  \" width \"  ,    Integer . class )  ;", "int   mapHeight    =    map . getProperties (  )  . get (  \" height \"  ,    Integer . class )  ;", "int   numlayers    =    map . getLayers (  )  . getCount (  )  ;", "int   bucketSize    =     ( mapWidth    *    mapHeight )     *    numlayers ;", "Iterator < MapLayer >    it    =    map . getLayers (  )  . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "MapLayer   layer    =    it . next (  )  ;", "if    ( layer   instanceof   TileLayer )     {", "TileLayer   tlayer    =     (  ( TileLayer )     ( layer )  )  ;", "for    ( int   y    =     0  ;    y    <    mapHeight ;     +  + y )     {", "for    ( int   x    =     0  ;    x    <    mapWidth ;     +  + x )     {", "if    (  ( tlayer . getCell ( x ,    y )  )     !  =    null )     {", "Tile   tile    =    tlayer . getCell ( x ,    y )  . getTile (  )  ;", "if    ( tile   instanceof   AnimatedTile )     {", "AnimatedTile   aTile    =     (  ( AnimatedTile )     ( tile )  )  ;", "for    ( StaticTile   t    :    aTile . getFrameTiles (  )  )     {", "addTile ( t ,    bucketSize )  ;", "}", "}", "addTile ( tile ,    bucketSize )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["stripUnusedTiles"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \"  \"  ;", "if    ( tileid    =  =     0  )     {", "return    \"  \"  ;", "}", "for    ( TileSet   tileset    :    map . getTileSets (  )  )     {", "int   firstgid    =    tileset . getProperties (  )  . get (  \" firstgid \"  ,     (  -  1  )  ,    Integer . class )  ;", "if    ( firstgid    =  =     (  -  1  )  )", "continue ;", "if    ( tileid    >  =    firstgid )     {", "name    =    tileset . getName (  )  ;", "} else    {", "return   name ;", "}", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["tilesetNameFromTileId"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "Document   doc ;", "DocumentBuilder   docBuilder ;", "DocumentBuilderFactory   docFactory    =    DocumentBuilderFactory . newInstance (  )  ;", "try    {", "docBuilder    =    docFactory . newDocumentBuilder (  )  ;", "doc    =    docBuilder . parse ( tmxFileHandle . read (  )  )  ;", "Node   map    =    doc . getFirstChild (  )  ;", "while    (  (  ( map . getNodeType (  )  )     !  =     ( Node . ELEMENT _ NODE )  )     |  |     (  ( map . getNodeName (  )  )     !  =     \" map \"  )  )     {", "if    (  ( map    =    map . getNextSibling (  )  )     =  =    null )     {", "throw   new   GdxRuntimeException (  \" Couldn ' t   find   map   node !  \"  )  ;", "}", "}", ". setProperty ( doc ,    map ,     \" atlas \"  ,     (  (  (  ( settings . tilesetOutputDirectory )     +     \"  /  \"  )     +     ( settings . atlasOutputName )  )     +     \"  . atlas \"  )  )  ;", "TransformerFactory   transformerFactory    =    TransformerFactory . newInstance (  )  ;", "Transformer   transformer    =    transformerFactory . newTransformer (  )  ;", "DOMSource   source    =    new   DOMSource ( doc )  ;", ". outputDir . mkdirs (  )  ;", "StreamResult   result    =    new   StreamResult ( new   File (  . outputDir ,    tmxFileHandle . name (  )  )  )  ;", "transformer . transform ( source ,    result )  ;", "}    catch    ( ParserConfigurationException   e )     {", "throw   new   RuntimeException (  (  \" ParserConfigurationException :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}    catch    ( SAXException   e )     {", "throw   new   RuntimeException (  (  \" SAXException :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}    catch    ( TransformerConfigurationException   e )     {", "throw   new   RuntimeException (  (  \" TransformerConfigurationException :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}    catch    ( TransformerException   e )     {", "throw   new   RuntimeException (  (  \" TransformerException :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeUpdatedTMX"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPacker"}, {"methodBody": ["METHOD_START", "{", "String   path    =     \"  .  .  /  .  .  / tests / gdx - tests - android / assets / data / maps /  \"  ;", "String   input    =    path    +     \" tiled - atlas - src \"  ;", "String   output    =    path    +     \" tiled - atlas - processed / deleteMe \"  ;", "String   verboseOpt    =     \"  - v \"  ;", "String   unused    =     \"  -  - strip - unused \"  ;", "String   combine    =     \"  -  - combine - tilesets \"  ;", "String   badOpt    =     \" bad \"  ;", "File   outputDir    =    new   File ( output )  ;", "if    ( outputDir . exists (  )  )     {", "System . out . println (  \" Please   run   Render   or   delete    \\  \" deleteMe \\  \"    folder   located   in \"  )  ;", "System . out . println (  \" gdx - tests - android :    assets / data / maps / tiled - atlas - processed / deleteMe \"  )  ;", "return ;", "}", ". TestType   testType    =     . TestType . DefaultUsage ;", "String [  ]    noArgs    =    new   String [  ]  {        }  ;", "String [  ]    defaultUsage    =    new   String [  ]  {    input ,    output    }  ;", "String [  ]    verbose    =    new   String [  ]  {    input ,    output ,    verboseOpt    }  ;", "String [  ]    stripUnused    =    new   String [  ]  {    input ,    output ,    unused    }  ;", "String [  ]    combineTilesets    =    new   String [  ]  {    input ,    output ,    combine    }  ;", "String [  ]    unusedAndCombine    =    new   String [  ]  {    input ,    output ,    unused ,    combine    }  ;", "String [  ]    badOption    =    new   String [  ]  {    input ,    output ,    unused ,    verboseOpt ,    combine ,    badOpt    }  ;", "switch    ( testType )     {", "case   NoArgs    :", "TiledMapPacker . main ( noArgs )  ;", "break ;", "case   DefaultUsage    :", "TiledMapPacker . main ( defaultUsage )  ;", "break ;", "case   Verbose    :", "TiledMapPacker . main ( verbose )  ;", "break ;", "case   StripUnused    :", "TiledMapPacker . main ( stripUnused )  ;", "break ;", "case   CombineTilesets    :", "TiledMapPacker . main ( combineTilesets )  ;", "break ;", "case   UnusedAndCombine    :", "TiledMapPacker . main ( unusedAndCombine )  ;", "break ;", "case   BadOption    :", "TiledMapPacker . main ( badOption )  ;", "break ;", "default    :", "break ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPackerTest"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( TiledMapPackerTestRender . MAP _ PATH )  ;", "if    (  !  ( file . exists (  )  )  )     {", "System . out . println (  \" Please   run   TiledMapPackerTest .  \"  )  ;", "return ;", "}", "new   LwjglApplication ( new   TiledMapPackerTestRender (  )  ,     \"  \"  ,     6  4  0  ,     4  8  0  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tiledmappacker.TiledMapPackerTestRender"}, {"methodBody": ["METHOD_START", "{", "for    ( String   regex    :    regexes )", "inputRegex . add ( pile ( regex )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addInputRegex"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( String   suffix    :    suffixes )", "addInputRegex (  (  \"  (  ? i )  .  *  \"     +     ( quote ( suffix )  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addInputSuffix"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "outputFiles . add ( entry )  ;", "}", "METHOD_END"], "methodName": ["addProcessedFile"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( inputFileOrDir . exists (  )  )  )", "throw   new   IllegalArgumentException (  (  \" Input   file   does   not   exist :     \"     +     ( inputFileOrDir . getAbsolutePath (  )  )  )  )  ;", "if    ( inputFileOrDir . isFile (  )  )", "return   p ( new   File [  ]  {    inputFileOrDir    }  ,    outputRoot )  ;", "else", "return   p ( inputFileOrDir . listFiles (  )  ,    outputRoot )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( outputRoot    =  =    null )", "outputRoot    =    new   File (  \"  \"  )  ;", "outputFiles . clear (  )  ;", "LinkedHashMap < File ,    ArrayList <  . Entry >  >    dirToEntries    =    new   LinkedHashMap (  )  ;", "process ( files ,    outputRoot ,    outputRoot ,    dirToEntries ,     0  )  ;", "ArrayList <  . Entry >    allEntries    =    new   ArrayList (  )  ;", "for    ( Map . Entry < File ,    ArrayList <  . Entry >  >    mapEntry    :    dirToEntries . entrySet (  )  )     {", "ArrayList <  . Entry >    dirEntries    =    mapEntry . getValue (  )  ;", "if    (  ( comparator )     !  =    null )", "sort ( dirEntries ,    entryComparator )  ;", "File   inputDir    =    mapEntry . getKey (  )  ;", "File   newOutputDir    =    null ;", "if    ( flattenOutput )", "newOutputDir    =    outputRoot ;", "else", "if    (  !  ( dirEntries . isEmpty (  )  )  )", "newOutputDir    =    dirEntries . get (  0  )  . outputDir ;", "String   outputName    =    inputDir . getName (  )  ;", "if    (  ( outputSuffix )     !  =    null )", "outputName    =     ( outputName . replaceAll (  \"  (  .  *  )  \\  \\  .  .  *  \"  ,     \"  $  1  \"  )  )     +     ( outputSuffix )  ;", ". Entry   entry    =    new    . Entry (  )  ;", "entry . inputFile    =    mapEntry . getKey (  )  ;", "entry . outputDir    =    newOutputDir ;", "if    ( newOutputDir    !  =    null )", "entry . outputFile    =     (  ( newOutputDir . length (  )  )     =  =     0  )     ?    new   File ( outputName )     :    new   File ( newOutputDir ,    outputName )  ;", "try    {", "processDir ( entry ,    dirEntries )  ;", "}    catch    ( Exception   ex )     {", "throw   new   Exception (  (  \" Error   processing   directory :     \"     +     ( entry . inputFile . getAbsolutePath (  )  )  )  ,    ex )  ;", "}", "allEntries . addAll ( dirEntries )  ;", "}", "if    (  ( comparator )     !  =    null )", "sort ( allEntries ,    entryComparator )  ;", "for    (  . Entry   entry    :    allEntries )     {", "try    {", "processFile ( entry )  ;", "}    catch    ( Exception   ex )     {", "throw   new   Exception (  (  \" Error   processing   file :     \"     +     ( entry . inputFile . getAbsolutePath (  )  )  )  ,    ex )  ;", "}", "}", "return   outputFiles ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    files )     {", "File   dir    =    file . getParentFile (  )  ;", "ArrayList <  . Entry >    entries    =    dirToEntries . get ( dir )  ;", "if    ( entries    =  =    null )     {", "entries    =    new   ArrayList (  )  ;", "dirToEntries . put ( dir ,    entries )  ;", "}", "}", "for    ( File   file    :    files )     {", "if    ( file . isFile (  )  )     {", "if    (  ( inputRegex . size )     >     0  )     {", "boolean   found    =    false ;", "for    ( Pattern   pattern    :    inputRegex )     {", "if    ( pattern . matcher ( file . getName (  )  )  . matches (  )  )     {", "found    =    true ;", "continue ;", "}", "}", "if    (  ! found )", "continue ;", "}", "File   dir    =    file . getParentFile (  )  ;", "if    (  (  ( inputFilter )     !  =    null )     &  &     (  !  ( inputFilter . accept ( dir ,    file . getName (  )  )  )  )  )", "continue ;", "String   outputName    =    file . getName (  )  ;", "if    (  ( outputSuffix )     !  =    null )", "outputName    =     ( outputName . replaceAll (  \"  (  .  *  )  \\  \\  .  .  *  \"  ,     \"  $  1  \"  )  )     +     ( outputSuffix )  ;", ". Entry   entry    =    new    . Entry (  )  ;", "entry . depth    =    depth ;", "entry . inputFile    =    file ;", "entry . outputDir    =    outputDir ;", "if    ( flattenOutput )     {", "entry . outputFile    =    new   File ( outputRoot ,    outputName )  ;", "} else    {", "entry . outputFile    =    new   File ( outputDir ,    outputName )  ;", "}", "dirToEntries . get ( dir )  . add ( entry )  ;", "}", "if    (  ( recursive )     &  &     ( file . isDirectory (  )  )  )     {", "File   subdir    =     (  ( outputDir . getPath (  )  . length (  )  )     =  =     0  )     ?    new   File ( file . getName (  )  )     :    new   File ( outputDir ,    file . getName (  )  )  ;", "process ( file . listFiles ( inputFilter )  ,    outputRoot ,    subdir ,    dirToEntries ,     ( depth    +     1  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "return   process ( new   File ( inputFileOrDir )  ,     ( outputRoot    =  =    null    ?    null    :    new   File ( outputRoot )  )  )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "this . comparator    =    comparator ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setComparator"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "this . flattenOutput    =    flattenOutput ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFlattenOutput"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "this . inputFilter    =    inputFilter ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setInputFilter"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "this . outputSuffix    =    outputSuffix ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOutputSuffix"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "this . recursive    =    recursive ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRecursive"], "fileName": "com.badlogic.gdx.tools.FileProcessor"}, {"methodBody": ["METHOD_START", "{", "return   BitmapFontWriter . format ;", "}", "METHOD_END"], "methodName": ["getOutputFormat"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "return   BitmapFontWriter . quote ( params ,    false )  ;", "}", "METHOD_END"], "methodName": ["quote"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( BitmapFontWriter . getOutputFormat (  )  )     =  =     ( BitmapFontWriter . OutputFormat . XML )  )", "return    (  (  \"  \\  \"  \"     +     ( params . toString (  )  . trim (  )  )  )     +     \"  \\  \"  \"  )     +     ( spaceAfter    ?     \"     \"     :     \"  \"  )  ;", "else", "return   params . toString (  )  ;", "}", "METHOD_END"], "methodName": ["quote"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( fmt    =  =    null )", "throw   new   NullPointerException (  \" format   cannot   be   null \"  )  ;", ". format    =    fmt ;", "}", "METHOD_END"], "methodName": ["setOutputFormat"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "String [  ]    pageRefs    =    BitmapFontWriter . writePixmaps ( pages ,    outFntFile . parent (  )  ,    outFntFile . nameWithoutExtension (  )  )  ;", "BitmapFontWriter . writeFont ( fontData ,    pageRefs ,    outFntFile ,    info ,    pages [  0  ]  . getWidth (  )  ,    pages [  0  ]  . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeFont"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( info    =  =    null )     {", "info    =    new    . FontInfo (  )  ;", "info . face    =    outFntFile . nameWithoutExtension (  )  ;", "}", "int   lineHeight    =     (  ( int )     ( fontData . lineHeight )  )  ;", "int   pages    =    pageRefs . length ;", "int   packed    =     0  ;", "int   base    =     (  ( int )     (  ( fontData . capHeight )     +     ( fontData . flipped    ?     -  ( fontData . ascent )     :    fontData . ascent )  )  )  ;", ". OutputFormat   fmt    =     . getOutputFormat (  )  ;", "boolean   xml    =    fmt    =  =     (  . OutputFormat . XML )  ;", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "if    ( xml )     {", "buf . append (  \"  < font >  \\ n \"  )  ;", "}", "String   xmlOpen    =     ( xml )     ?     \"  \\ t <  \"     :     \"  \"  ;", "String   xmlCloseSelf    =     ( xml )     ?     \"  /  >  \"     :     \"  \"  ;", "String   xmlTab    =     ( xml )     ?     \"  \\ t \"     :     \"  \"  ;", "String   xmlClose    =     ( xml )     ?     \"  >  \"     :     \"  \"  ;", "String   xmlQuote    =     ( xml )     ?     \"  \\  \"  \"     :     \"  \"  ;", "String   alphaChnlParams    =     ( xml )     ?     \"    alphaChnl =  \\  \"  0  \\  \"    redChnl =  \\  \"  0  \\  \"    greenChnl =  \\  \"  0  \\  \"    blueChnl =  \\  \"  0  \\  \"  \"     :     \"    alphaChnl =  0    redChnl =  0    greenChnl =  0    blueChnl =  0  \"  ;", "buf . append ( xmlOpen )  . append (  \" info   face =  \\  \"  \"  )  . append (  (  ( info . face )     =  =    null    ?     \"  \"     :    info . face . replaceAll (  \"  \\  \"  \"  ,     \"  '  \"  )  )  )  . append (  \"  \\  \"    size =  \"  )  . append (  . quote ( info . size )  )  . append (  \"    bold =  \"  )  . append (  . quote (  ( info . bold    ?     1     :     0  )  )  )  . append (  \"    italic =  \"  )  . append (  . quote (  ( info . italic    ?     1     :     0  )  )  )  . append (  \"    charset =  \\  \"  \"  )  . append (  (  ( info . charset )     =  =    null    ?     \"  \"     :    info . charset )  )  . append (  \"  \\  \"    unicode =  \"  )  . append (  . quote (  ( info . unicode    ?     1     :     0  )  )  )  . append (  \"    stretchH =  \"  )  . append (  . quote ( info . stretchH )  )  . append (  \"    smooth =  \"  )  . append (  . quote (  ( info . smooth    ?     1     :     0  )  )  )  . append (  \"    aa =  \"  )  . append (  . quote ( info . aa )  )  . append (  \"    padding =  \"  )  . append ( xmlQuote )  . append ( info . padding . up )  . append (  \"  ,  \"  )  . append ( info . padding . right )  . append (  \"  ,  \"  )  . append ( info . padding . down )  . append (  \"  ,  \"  )  . append ( info . padding . left )  . append ( xmlQuote )  . append (  \"    spacing =  \"  )  . append ( xmlQuote )  . append ( info . spacing . horizontal )  . append (  \"  ,  \"  )  . append ( info . spacing . vertical )  . append ( xmlQuote )  . append ( xmlCloseSelf )  . append (  \"  \\ n \"  )  ;", "buf . append ( xmlOpen )  . append (  \" common   lineHeight =  \"  )  . append (  . quote ( lineHeight )  )  . append (  \"    base =  \"  )  . append (  . quote ( base )  )  . append (  \"    scaleW =  \"  )  . append (  . quote ( scaleW )  )  . append (  \"    scaleH =  \"  )  . append (  . quote ( scaleH )  )  . append (  \"    pages =  \"  )  . append (  . quote ( pages )  )  . append (  \"    packed =  \"  )  . append (  . quote ( packed )  )  . append ( alphaChnlParams )  . append ( xmlCloseSelf )  . append (  \"  \\ n \"  )  ;", "if    ( xml )", "buf . append (  \"  \\ t < pages >  \\ n \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( pageRefs . length )  ;    i +  +  )     {", "buf . append ( xmlTab )  . append ( xmlOpen )  . append (  \" page   id =  \"  )  . append (  . quote ( i )  )  . append (  \"    file =  \\  \"  \"  )  . append ( pageRefs [ i ]  )  . append (  \"  \\  \"  \"  )  . append ( xmlCloseSelf )  . append (  \"  \\ n \"  )  ;", "}", "if    ( xml )", "buf . append (  \"  \\ t <  / pages >  \\ n \"  )  ;", "Array < Glyph >    glyphs    =    new   Array < Glyph >  (  2  5  6  )  ;", "for    ( int   i    =     0  ;    i    <     ( fontData . glyphs . length )  ;    i +  +  )     {", "if    (  ( fontData . glyphs [ i ]  )     =  =    null )", "continue ;", "for    ( int   j    =     0  ;    j    <     ( fontData . glyphs [ i ]  . length )  ;    j +  +  )     {", "if    (  ( fontData . glyphs [ i ]  [ j ]  )     !  =    null )     {", "glyphs . add ( fontData . glyphs [ i ]  [ j ]  )  ;", "}", "}", "}", "buf . append ( xmlOpen )  . append (  \" chars   count =  \"  )  . append (  . quote ( glyphs . size )  )  . append ( xmlClose )  . append (  \"  \\ n \"  )  ;", "int   padLeft    =     0  ;", "int   padRight    =     0  ;", "int   padTop    =     0  ;", "int   padX    =     0  ;", "int   padY    =     0  ;", "if    ( info    !  =    null )     {", "padTop    =    info . padding . up ;", "padLeft    =    info . padding . left ;", "padRight    =    info . padding . right ;", "padX    =    padLeft    +    padRight ;", "padY    =     ( info . padding . up )     +     ( info . padding . down )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( glyphs . size )  ;    i +  +  )     {", "Glyph   g    =    glyphs . get ( i )  ;", "boolean   empty    =     (  ( g . width )     =  =     0  )     |  |     (  ( g . height )     =  =     0  )  ;", "buf . append ( xmlTab )  . append ( xmlOpen )  . append (  \" char   id =  \"  )  . append (  . quote ( String . format (  \"  %  -  6 s \"  ,    g . id )  ,    true )  )  . append (  \" x =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,     ( empty    ?     0     :     ( g . srcX )     -    padLeft )  )  ,    true )  )  . append (  \" y =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,     ( empty    ?     0     :     ( g . srcY )     -    padRight )  )  ,    true )  )  . append (  \" width =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,     ( empty    ?     0     :     ( g . width )     +    padX )  )  ,    true )  )  . append (  \" height =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,     ( empty    ?     0     :     ( g . height )     +    padY )  )  ,    true )  )  . append (  \" xoffset =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,     (  ( g . xoffset )     -    padLeft )  )  ,    true )  )  . append (  \" yoffset =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,     ( fontData . flipped    ?     ( g . yoffset )     +    padTop    :     -  (  ( g . height )     +     (  ( g . yoffset )     +    padTop )  )  )  )  ,    true )  )  . append (  \" xadvance =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,    g . xadvance )  ,    true )  )  . append (  \" page =  \"  )  . append (  . quote ( String . format (  \"  %  -  5 s \"  ,    g . page )  ,    true )  )  . append (  \" chnl =  \"  )  . append (  . quote (  0  ,    true )  )  . append ( xmlCloseSelf )  . append (  \"  \\ n \"  )  ;", "}", "if    ( xml )", "buf . append (  \"  \\ t <  / chars >  \\ n \"  )  ;", "int   kernCount    =     0  ;", "StringBuilder   kernBuf    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( glyphs . size )  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <     ( glyphs . size )  ;    j +  +  )     {", "Glyph   first    =    glyphs . get ( i )  ;", "Glyph   second    =    glyphs . get ( j )  ;", "int   kern    =    first . getKerning (  (  ( char )     ( second . id )  )  )  ;", "if    ( kern    !  =     0  )     {", "kernCount +  +  ;", "kernBuf . append ( xmlTab )  . append ( xmlOpen )  . append (  \" kerning   first =  \"  )  . append (  . quote ( first . id )  )  . append (  \"    second =  \"  )  . append (  . quote ( second . id )  )  . append (  \"    amount =  \"  )  . append (  . quote ( kern ,    true )  )  . append ( xmlCloseSelf )  . append (  \"  \\ n \"  )  ;", "}", "}", "}", "buf . append ( xmlOpen )  . append (  \" kernings   count =  \"  )  . append (  . quote ( kernCount )  )  . append ( xmlClose )  . append (  \"  \\ n \"  )  ;", "buf . append ( kernBuf )  ;", "if    ( xml )     {", "buf . append (  \"  \\ t <  / kernings >  \\ n \"  )  ;", "buf . append (  \"  <  / font >  \"  )  ;", "}", "String   charset    =    info . charset ;", "if    (  ( charset    !  =    null )     &  &     (  ( charset . length (  )  )     =  =     0  )  )", "charset    =    null ;", "outFntFile . writeString ( buf . toString (  )  ,    false ,    charset )  ;", "}", "METHOD_END"], "methodName": ["writeFont"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pages    =  =    null )     |  |     (  ( pages . length )     =  =     0  )  )", "throw   new   IllegalArgumentException (  \" no   pixmaps   supplied   to    . write \"  )  ;", "String [  ]    pageRefs    =    new   String [ pages . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( pages . length )  ;    i +  +  )     {", "String   ref    =     (  ( pages . length )     =  =     1  )     ?    fileName    +     \"  . png \"     :     (  ( fileName    +     \"  _  \"  )     +    i )     +     \"  . png \"  ;", "pageRefs [ i ]     =    ref ;", "PixmapIO . writePNG ( outputDir . child ( ref )  ,    pages [ i ]  )  ;", "}", "return   pageRefs ;", "}", "METHOD_END"], "methodName": ["writePixmaps"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "Pixmap [  ]    pix    =    new   Pixmap [ pages . size ]  ;", "for    ( int   i    =     0  ;    i    <     ( pages . size )  ;    i +  +  )     {", "pix [ i ]     =    pages . get ( i )  . getPixmap (  )  ;", "}", "return    . writePixmaps ( pix ,    outputDir ,    fileName )  ;", "}", "METHOD_END"], "methodName": ["writePixmaps"], "fileName": "com.badlogic.gdx.tools.bmfont.BitmapFontWriter"}, {"methodBody": ["METHOD_START", "{", "float   alpha    =     0  .  5 F    +     (  0  .  5 F    *     ( signedDistance    /     ( spread )  )  )  ;", "alpha    =    Math . min (  1  ,    Math . max (  0  ,    alpha )  )  ;", "int   alphaByte    =     (  ( int )     ( alpha    *     2  5  5  )  )  ;", "return    ( alphaByte    <  <     2  4  )     |     (  ( color . getRGB (  )  )     &     1  6  7  7  7  2  1  5  )  ;", "}", "METHOD_END"], "methodName": ["distanceToRGB"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "final   int   width    =    bitmap [  0  ]  . length ;", "final   int   height    =    bitmap . length ;", "final   boolean   base    =    bitmap [ centerY ]  [ centerX ]  ;", "final   int   delta    =     (  ( int )     ( Math . ceil ( spread )  )  )  ;", "final   int   startX    =    Math . max (  0  ,     ( centerX    -    delta )  )  ;", "final   int   endX    =    Math . min (  ( width    -     1  )  ,     ( centerX    +    delta )  )  ;", "final   int   startY    =    Math . max (  0  ,     ( centerY    -    delta )  )  ;", "final   int   endY    =    Math . min (  ( height    -     1  )  ,     ( centerY    +    delta )  )  ;", "int   closestSquareDist    =    delta    *    delta ;", "for    ( int   y    =    startY ;    y    <  =    endY ;     +  + y )     {", "for    ( int   x    =    startX ;    x    <  =    endX ;     +  + x )     {", "if    ( base    !  =     ( bitmap [ y ]  [ x ]  )  )     {", "final   int   squareDist    =     . squareDist ( centerX ,    centerY ,    x ,    y )  ;", "if    ( squareDist    <    closestSquareDist )     {", "closestSquareDist    =    squareDist ;", "}", "}", "}", "}", "float   closestDist    =     (  ( float )     ( Math . sqrt ( closestSquareDist )  )  )  ;", "return    ( base    ?     1     :     -  1  )     *     ( Math . min ( closestDist ,    spread )  )  ;", "}", "METHOD_END"], "methodName": ["findSignedDistance"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "final   int   inWidth    =    inImage . getWidth (  )  ;", "final   int   inHeight    =    inImage . getHeight (  )  ;", "final   int   outWidth    =    inWidth    /     ( downscale )  ;", "final   int   outHeight    =    inHeight    /     ( downscale )  ;", "final   BufferedImage   outImage    =    new   BufferedImage ( outWidth ,    outHeight ,    BufferedImage . TYPE _  4 BYTE _ ABGR )  ;", "final   boolean [  ]  [  ]    bitmap    =    new   boolean [ inHeight ]  [ inWidth ]  ;", "for    ( int   y    =     0  ;    y    <    inHeight ;     +  + y )     {", "for    ( int   x    =     0  ;    x    <    inWidth ;     +  + x )     {", "bitmap [ y ]  [ x ]     =    isInside ( inImage . getRGB ( x ,    y )  )  ;", "}", "}", "for    ( int   y    =     0  ;    y    <    outHeight ;     +  + y )     {", "for    ( int   x    =     0  ;    x    <    outWidth ;     +  + x )     {", "int   centerX    =     ( x    *     ( downscale )  )     +     (  ( downscale )     /     2  )  ;", "int   centerY    =     ( y    *     ( downscale )  )     +     (  ( downscale )     /     2  )  ;", "float   signed    =    findSigned ( centerX ,    centerY ,    bitmap )  ;", "outImage . setRGB ( x ,    y ,    distanceToRGB ( signed )  )  ;", "}", "}", "return   outImage ;", "}", "METHOD_END"], "methodName": ["generateDistanceField"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "return   downscale ;", "}", "METHOD_END"], "methodName": ["getDownscale"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "return   spread ;", "}", "METHOD_END"], "methodName": ["getSpread"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( rgb    &     8  4  2  1  5  0  4  )     !  =     0  )     &  &     (  ( rgb    &     -  2  1  4  7  4  8  3  6  4  8  )     !  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isInside"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "try    {", ". run ( args )  ;", "}    catch    (  . CommandLineArgumentException   e )     {", "System . err . println (  (  (  \" Error :     \"     +     ( e . getMessage (  )  )  )     +     \"  \\ n \"  )  )  ;", ". usage (  )  ;", "System . exit (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "DistanceFieldGenerator   generator    =    new   DistanceFieldGenerator (  )  ;", "String   inputFile    =    null ;", "String   outputFile    =    null ;", "int   i    =     0  ;", "try    {", "for    (  ;    i    <     ( args . length )  ;     +  + i )     {", "String   arg    =    args [ i ]  ;", "if    ( arg . startsWith (  \"  -  \"  )  )     {", "if    (  \"  -  - help \"  . equals ( arg )  )     {", "DistanceFieldGenerator . usage (  )  ;", "System . exit (  0  )  ;", "} else", "if    (  \"  -  - color \"  . equals ( arg )  )     {", "+  + i ;", "generator . setColor ( new   Color ( Integer . parseInt ( args [ i ]  ,     1  6  )  )  )  ;", "} else", "if    (  \"  -  - downscale \"  . equals ( arg )  )     {", "+  + i ;", "generator . setDownscale ( Integer . parseInt ( args [ i ]  )  )  ;", "} else", "if    (  \"  -  - spread \"  . equals ( arg )  )     {", "+  + i ;", "generator . setSpread ( Float . parseFloat ( args [ i ]  )  )  ;", "} else    {", "throw   new   DistanceFieldGenerator . CommandLineArgumentException (  (  \" unknown   option    \"     +    arg )  )  ;", "}", "} else    {", "if    ( inputFile    =  =    null )     {", "inputFile    =    arg ;", "} else", "if    ( outputFile    =  =    null )     {", "outputFile    =    arg ;", "} else    {", "throw   new   DistanceFieldGenerator . CommandLineArgumentException (  \" exactly   two   file   names   are   expected \"  )  ;", "}", "}", "}", "}    catch    ( IndexOutOfBoundsException   e )     {", "throw   new   DistanceFieldGenerator . CommandLineArgumentException (  (  (  \" option    \"     +     ( args [  (  ( args . length )     -     1  )  ]  )  )     +     \"    requires   an   argument \"  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "throw   new   DistanceFieldGenerator . CommandLineArgumentException (  (  ( args [ i ]  )     +     \"    is   not   a   number \"  )  )  ;", "}", "if    ( inputFile    =  =    null )     {", "throw   new   DistanceFieldGenerator . CommandLineArgumentException (  \" no   input   file   specified \"  )  ;", "}", "if    ( outputFile    =  =    null )     {", "throw   new   DistanceFieldGenerator . CommandLineArgumentException (  \" no   output   file   specified \"  )  ;", "}", "String   outputFormat    =    outputFile . substring (  (  ( outputFile . lastIndexOf (  '  .  '  )  )     +     1  )  )  ;", "boolean   exists ;", "if    (  !  ( ImageIO . getImageWritersByFormatName ( outputFormat )  . hasNext (  )  )  )     {", "throw   new   RuntimeException (  (  (  \" No   image   writers   found   that   can   handle   the   format    '  \"     +    outputFormat )     +     \"  '  \"  )  )  ;", "}", "BufferedImage   input    =    null ;", "try    {", "input    =    ImageIO . read ( new   File ( inputFile )  )  ;", "}    catch    ( IOException   e )     {", "System . err . println (  (  \" Failed   to   load   image :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "BufferedImage   output    =    generator . generateDistanceField ( input )  ;", "try    {", "ImageIO . write ( output ,    outputFormat ,    new   File ( outputFile )  )  ;", "}    catch    ( IOException   e )     {", "System . err . println (  (  \" Failed   to   write   output   image :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( downscale    <  =     0  )", "throw   new   IllegalArgumentException (  \" downscale   must   be   positive \"  )  ;", "thiownscale    =    downscale ;", "}", "METHOD_END"], "methodName": ["setDownscale"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( spread    <  =     0  )", "throw   new   IllegalArgumentException (  \" spread   must   be   positive \"  )  ;", "this . spread    =    spread ;", "}", "METHOD_END"], "methodName": ["setSpread"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "final   int   dx    =    x 1     -    x 2  ;", "final   int   dy    =    y 1     -    y 2  ;", "return    ( dx    *    dx )     +     ( dy    *    dy )  ;", "}", "METHOD_END"], "methodName": ["squareDist"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  \" Generates   a   distance   field   image   from   a   black   and   white   input   image .  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \" The   distance   field   image   contains   a   solid   color   and   stores   the   distance \\ n \"     +     \" in   the   alpha   channel .  \\ n \"  )     +     \"  \\ n \"  )     +     \" The   output   file   format   is   inferred   from   the   file   name .  \\ n \"  )     +     \"  \\ n \"  )     +     \" Command   line   arguments :    INFILE   OUTFILE    [ OPTION .  .  .  ]  \\ n \"  )     +     \"  \\ n \"  )     +     \" Possible   options :  \\ n \"  )     +     \"        -  - color   rrggbb            color   of   output   image    ( default :    ffffff )  \\ n \"  )     +     \"        -  - downscale   n               downscale   by   factor   of   n    ( default :     1  )  \\ n \"  )     +     \"        -  - spread   n                        edge   scan   distance    ( default :     1  )  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usage"], "fileName": "com.badlogic.gdx.tools.distancefield.DistanceFieldGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     !  =     2  )     {", "System . out . println (  \"     < input - dir >     < output - dir >  \"  )  ;", "System . exit (  (  -  1  )  )  ;", "}", ". process ( args [  0  ]  ,    args [  1  ]  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.etc1.ETC1Compressor"}, {"methodBody": ["METHOD_START", "{", "GdxNativesLoader . load (  )  ;", ". ETC 1 FileProcessor   processor    =    new    . ETC 1 FileProcessor (  )  ;", "processor . setRecursive ( recursive )  ;", "processor . setFlattenOutput ( flatten )  ;", "processor . process ( new   File ( inputDirectory )  ,    new   File ( outputDirectory )  )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.etc1.ETC1Compressor"}, {"methodBody": ["METHOD_START", "{", "return   magnitudePanel ;", "}", "METHOD_END"], "methodName": ["getMagnitudePanel"], "fileName": "com.badlogic.gdx.tools.flame.AngularVelocityPanel"}, {"methodBody": ["METHOD_START", "{", "return   phiPanel ;", "}", "METHOD_END"], "methodName": ["getPhiPanel"], "fileName": "com.badlogic.gdx.tools.flame.AngularVelocityPanel"}, {"methodBody": ["METHOD_START", "{", "return   thetaPanel ;", "}", "METHOD_END"], "methodName": ["getThetaPanel"], "fileName": "com.badlogic.gdx.tools.flame.AngularVelocityPanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "JPanel   panel    =    new   JPanel (  )  ;", "panel . add ( new   JLabel (  \" Global \"  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "panel . add (  ( isGlobalCheckBox    =    new   JCheckBox (  )  )  ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "contentPanel . add ( panel ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "contentPanel . add (  ( magnitudePanel    =    new   ScaledNumericPanel ( editor ,     ( aValue    =  =    null    ?    null    :    aValue . strengthValue )  ,    charTitle ,     \" Strength \"  ,     \" In   world   units   per   second .  \"  ,    true )  )  ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "contentPanel . add (  ( phiPanel    =    new   ScaledNumericPanel ( editor ,     ( aValue    =  =    null    ?    null    :    aValue . phiValue )  ,    charTitle ,     \" Azimuth \"  ,     \" Rotation   starting   on   Y \"  ,    true )  )  ,    new   GridBagConstraints (  0  ,     4  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "contentPanel . add (  ( thetaPanel    =    new   ScaledNumericPanel ( editor ,     ( aValue    =  =    null    ?    null    :    aValue . thetaValue )  ,    charTitle ,     \" Polar   angle \"  ,     \" around   Y   axis   on   XZ   plane \"  ,    true )  )  ,    new   GridBagConstraints (  0  ,     3  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "JPanel   spacer    =    new   JPanel (  )  ;", "spacer . setPreferredSize ( new   Dimension (  )  )  ;", "contentPanel . add ( spacer ,    new   GridBagConstraints (  6  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "magnitudePanel . setIsAlwayShown ( true )  ;", "phiPanel . setIsAlwayShown ( true )  ;", "thetaPanel . setIsAlwayShown ( true )  ;", "isGlobalCheckBox . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   e )     {", ". this . value . isGlobal    =    isGlobalCheckBox . isSelected (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.AngularVelocityPanel"}, {"methodBody": ["METHOD_START", "{", "for    ( BillboardBatchPanel . AlignModeWrapper   wrapper    :    BillboardBatchPanel . AlignModeWrapper . values (  )  )     {", "if    (  ( wrapper . mode )     =  =    alignMode )", "return   wrapper ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAlignModeWrapper"], "fileName": "com.badlogic.gdx.tools.flame.BillboardBatchPanel"}, {"methodBody": ["METHOD_START", "{", "Class   type    =    sorter . getClass (  )  ;", "for    (  . SortMode   wrapper    :     . SortMode . values (  )  )     {", "if    (  ( wrapper . sorter . getClass (  )  )     =  =    type )", "return   wrapper ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSortMode"], "fileName": "com.badlogic.gdx.tools.flame.BillboardBatchPanel"}, {"methodBody": ["METHOD_START", "{", "alignCombo    =    new   JComboBox (  )  ;", "alignCombo . setModel ( new   DefaultComboBoxModel (  . AlignModeWrapper . values (  )  )  )  ;", "alignCombo . setSelectedItem ( getAlignModeWrapper ( renderer . getAlignMode (  )  )  )  ;", "alignCombo . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", ". AlignModeWrapper   align    =     (  (  . AlignModeWrapper )     ( alignCombo . getSelectedItem (  )  )  )  ;", "editor . getBillboardBatch (  )  . setAlignMode ( align . mode )  ;", "}", "}  )  ;", "useGPUBox    =    new   JCheckBox (  )  ;", "useGPUBox . setSelected ( renderer . isUseGPU (  )  )  ;", "useGPUBox . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", "editor . getBillboardBatch (  )  . setUseGpu ( useGPUBox . isSelected (  )  )  ;", "}", "}  )  ;", "sortCombo    =    new   JComboBox (  )  ;", "sortCombo . setModel ( new   DefaultComboBoxModel (  . SortMode . values (  )  )  )  ;", "sortCombo . setSelectedItem ( getSortMode ( renderer . getSorter (  )  )  )  ;", "sortCombo . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", ". SortMode   mode    =     (  (  . SortMode )     ( sortCombo . getSelectedItem (  )  )  )  ;", "editor . getBillboardBatch (  )  . setSorter ( mode . sorter )  ;", "}", "}  )  ;", "int   i    =     0  ;", "contentPanel . add ( new   JLabel (  \" Align \"  )  ,    new   GridBagConstraints (  0  ,    i ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "contentPanel . add ( alignCombo ,    new   GridBagConstraints (  1  ,     ( i +  +  )  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "contentPanel . add ( new   JLabel (  \" Use   GPU \"  )  ,    new   GridBagConstraints (  0  ,    i ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "contentPanel . add ( useGPUBox ,    new   GridBagConstraints (  1  ,     ( i +  +  )  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "contentPanel . add ( new   JLabel (  \" Sort \"  )  ,    new   GridBagConstraints (  0  ,    i ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "contentPanel . add ( sortCombo ,    new   GridBagConstraints (  1  ,    i ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.BillboardBatchPanel"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "addContent (  ( i +  +  )  ,     0  ,     ( tint    =    new   Gradient ( editor ,    emitter . colorValue ,     \" Tint \"  ,     \"  \"  ,    false )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( alpha    =    new   Percentage ( editor ,    emitter . alphaValue ,     \" Life \"  ,     \" Transparency \"  ,     \"  \"  )  )  )  ;", "tint . showContent ( true )  ;", "alpha . showContent ( true )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.ColorInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "minSlider    =    new   Slider (  0  ,     0  ,     9  9  9  9  9  9  ,     1  )  ;", "minSlider . setValue ( min )  ;", "minSlider . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", "ParticleController   controller    =    editor . getEmitter (  )  ;", "controller . emitter . minParticleCount    =     (  ( int )     ( minSlider . getValue (  )  )  )  ;", "editor . restart (  )  ;", "}", "}  )  ;", "maxSlider    =    new   Slider (  0  ,     0  ,     9  9  9  9  9  9  ,     1  )  ;", "maxSlider . setValue ( max )  ;", "maxSlider . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", "ParticleController   controller    =    editor . getEmitter (  )  ;", "controller . emitter . maxParticleCount    =     (  ( int )     ( maxSlider . getValue (  )  )  )  ;", "editor . restart (  )  ;", "}", "}  )  ;", "int   i    =     0  ;", "conte . add ( new   JLabel (  \" Min \"  )  ,    new   GridBagConstraints (  0  ,    i ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "conte . add ( minSlider ,    new   GridBagConstraints (  1  ,     ( i +  +  )  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "conte . add ( new   JLabel (  \" Max \"  )  ,    new   GridBagConstraints (  0  ,    i ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "conte . add ( maxSlider ,    new   GridBagConstraints (  1  ,     ( i +  +  )  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.CountPanel"}, {"methodBody": ["METHOD_START", "{", "Component [  ]    c    =    container . getComponents (  )  ;", "int   i    =     0  ;", "int   j    =    c . length ;", "while    ( i    <    j )     {", "if    ( c [ i ]  . isVisible (  )  )     {", "return    (  ( K )     ( c [ i ]  )  )  ;", "} else", "i +  +  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCurrentCard"], "fileName": "com.badlogic.gdx.tools.flame.CustomCardLayout"}, {"methodBody": ["METHOD_START", "{", "ParticleController   controller    =    editor . getEmitter (  )  ;", "DynamicsInfluencer   influencer    =     (  ( DynamicsInfluencer )     ( controller . findInfluencer ( DynamicsInfluencer . class )  )  )  ;", ". VelocityWrapper   wrapper    =    new    . VelocityWrapper ( createVelocityValue ( selectedItem )  ,    true )  ;", "velocities . add ( wrapper )  ;", "influencer . velocities . add ( wrapper . velocityValue )  ;", "int   index    =     ( velocities . size )     -     1  ;", "velocityTableModel . addRow ( new   Object [  ]  {     \" Velocity    \"     +    index ,    true    }  )  ;", "editor . restart (  )  ;", "velocityTable . getSelectionModel (  )  . setSelectionInterval ( index ,    index )  ;", "revalidate (  )  ;", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["createVelocity"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "DynamicsModifier   velocityValue    =    null ;", "if    ( selectedItem    =  =     (  . VEL _ TYPE _ ROTATIONAL _  2 D )  )", "velocityValue    =    new   DynamicsModifier . Rotational 2 D (  )  ;", "else", "if    ( selectedItem    =  =     (  . VEL _ TYPE _ ROTATIONAL _  3 D )  )", "velocityValue    =    new   DynamicsModifier . Rotational 3 D (  )  ;", "else", "if    ( selectedItem    =  =     (  . VEL _ TYPE _ CENTRIPETAL )  )", "velocityValue    =    new   DynamicsModifier . CentripetalAcceleration (  )  ;", "else", "if    ( selectedItem    =  =     (  . VEL _ TYPE _ TANGENTIAL )  )", "velocityValue    =    new   DynamicsModifier . TangentialAcceleration (  )  ;", "else", "if    ( selectedItem    =  =     (  . VEL _ TYPE _ POLAR )  )", "velocityValue    =    new   DynamicsModifier . PolarAcceleration (  )  ;", "else", "if    ( selectedItem    =  =     (  . VEL _ TYPE _ BROWNIAN )  )", "velocityValue    =    new   DynamicsModifier . BrownianAcceleration (  )  ;", "else", "if    ( selectedItem    =  =     (  . VEL _ TYPE _ FACE )  )", "velocityValue    =    new   DynamicsModifier . FaceDirection (  )  ;", "return   velocityValue ;", "}", "METHOD_END"], "methodName": ["createVelocityValue"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "int   row    =    velocityTable . getSelectedRow (  )  ;", "if    ( row    =  =     (  -  1  )  )", "return ;", "ParticleController   controller    =    editor . getEmitter (  )  ;", "influencer    =     (  (  )     ( controller . findInfluencer (  . class )  )  )  ;", "influencer . velocities . removeValue ( velocities . removeIndex ( row )  . velocityValue ,    true )  ;", "velocityTableModel . removeRow ( row )  ;", "editor . restart (  )  ;", "selectedVelocityPanel . setVisible ( false )  ;", "selectedVelocityPanel    =    null ;", "}", "METHOD_END"], "methodName": ["deleteVelocity"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type    =  =     ( FlameMain . ControllerType . Billboard )  )     |  |     ( type    =  =     ( FlameMain . ControllerType . PointSprite )  )  )     {", "return   new   String [  ]  {     . VEL _ TYPE _ ROTATIONAL _  2 D ,     . VEL _ TYPE _ CENTRIPETAL ,     . VEL _ TYPE _ TANGENTIAL ,     . VEL _ TYPE _ POLAR ,     . VEL _ TYPE _ BROWNIAN    }  ;", "} else", "if    (  ( type    =  =     ( FlameMain . ControllerType . ModelInstance )  )     |  |     ( type    =  =     ( FlameMain . ControllerType . ParticleController )  )  )     {", "return   new   String [  ]  {     . VEL _ TYPE _ ROTATIONAL _  3 D ,     . VEL _ TYPE _ CENTRIPETAL ,     . VEL _ TYPE _ TANGENTIAL ,     . VEL _ TYPE _ POLAR ,     . VEL _ TYPE _ BROWNIAN ,     . VEL _ TYPE _ FACE    }  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAvailableVelocities"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "EditorPanel   panel    =    null ;", "if    ( velocityValue   instanceof   DynamicsModifier . Rotational 2 D )     {", "strengthVelocityPanel . setValue (  (  ( DynamicsModifier . Strength )     ( velocityValue )  )  )  ;", "strengthVelocityPanel . setName (  \" Angular   Velocity \"  )  ;", "strengthVelocityPanel . setDescription (  \" The   angular   speed   around   the   billboard   facing   direction ,    in   degrees / sec    .  \"  )  ;", "panel    =    strengthVelocityPanel ;", "} else", "if    ( velocityValue   instanceof   graphics . g 3 d . particles . influencers . DynamicsModifier . CentripetalAcceleration )     {", "strengthVelocityPanel . setValue (  (  ( DynamicsModifier . CentripetalAcceleration )     ( velocityValue )  )  )  ;", "strengthVelocityPanel . setName (  \" Centripetal   Acceleration \"  )  ;", "strengthVelocityPanel . setDescription (  \" A   directional   acceleration ,    the   direction   is   towards   the   origin    ( global )  ,    or   towards   the   emitter   position    ( local )  ,    in   world   units / sec 2     .  \"  )  ;", "panel    =    strengthVelocityPanel ;", "} else", "if    ( velocityValue   instanceof   graphics . g 3 d . particles . influencers . DynamicsModifier . TangentialAcceleration )     {", "angularVelocityPanel . setValue (  (  ( DynamicsModifier . Angular )     ( velocityValue )  )  )  ;", "angularVelocityPanel . setName (  \" Tangetial   Velocity \"  )  ;", "angularVelocityPanel . setDescription (  \" A   directional   acceleration    ( axis   and   magnitude )  ,    the   final   direction   is   the   cross   product   between   particle   position   and   the   axis ,    in   world   units / sec 2     .  \"  )  ;", "panel    =    angularVelocityPanel ;", "} else", "if    ( velocityValue   instanceof   graphics . g 3 d . particles . influencers . DynamicsModifier . PolarAcceleration )     {", "angularVelocityPanel . setValue (  (  ( DynamicsModifier . Angular )     ( velocityValue )  )  )  ;", "angularVelocityPanel . setName (  \" Polar   Velocity \"  )  ;", "angularVelocityPanel . setDescription (  \" A   directional   acceleration    ( axis   and   magnitude )  ,    in   world   units / sec 2     .  \"  )  ;", "panel    =    angularVelocityPanel ;", "} else", "if    ( velocityValue   instanceof   graphics . g 3 d . particles . influencers . DynamicsModifier . BrownianAcceleration )     {", "strengthVelocityPanel . setValue (  (  ( DynamicsModifier . Strength )     ( velocityValue )  )  )  ;", "strengthVelocityPanel . setName (  \" Brownian   Velocity \"  )  ;", "strengthVelocityPanel . setDescription (  \" A   directional   acceleration   which   has   random   direction   at   each   update ,    in   world   units / sec 2  .  \"  )  ;", "panel    =    strengthVelocityPanel ;", "} else", "if    ( velocityValue   instanceof   graphics . g 3 d . particles . influencers . DynamicsModifier . Rotational 3 D )     {", "angularVelocityPanel . setValue (  (  ( DynamicsModifier . Angular )     ( velocityValue )  )  )  ;", "angularVelocityPanel . setName (  \" Angular   Velocity \"  )  ;", "angularVelocityPanel . setDescription (  \" An   angular   velocity    ( axis   and   magnitude )  ,    in   degree / sec 2  .  \"  )  ;", "panel    =    angularVelocityPanel ;", "} else", "if    ( velocityValue   instanceof   graphics . g 3 d . particles . influencers . DynamicsModifier . FaceDirection )     {", "emptyPanel . setName (  \" Face \"  )  ;", "emptyPanel . setDescription (  \" Rotates   the   model   to   face   its   current   velocity    ( Do   not   add   any   other   angular   velocity   when   using   this )  .  \"  )  ;", "panel    =    emptyPanel ;", "}", "return   panel ;", "}", "METHOD_END"], "methodName": ["getVelocityPanel"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "super . initializeComponents (  )  ;", "J   velocities    =    new   J (  )  ;", "velocities . setLayout ( new   GridBagLayout (  )  )  ;", "{", "J   sideButtons    =    new   J ( new   GridBagLayout (  )  )  ;", "velocities . add ( sideButtons ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "{", "sideButtons . add (  ( velocityBox    =    new   JComboBox ( new   DefaultComboBoxModel (  )  )  )  ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JButton   newButton    =    new   JButton (  \" New \"  )  ;", "sideButtons . add ( newButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "newButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "createVelocity ( velocityBox . getSelectedItem (  )  )  ;", "}", "}  )  ;", "}", "{", "JButton   deleteButton    =    new   JButton (  \" Delete \"  )  ;", "sideButtons . add ( deleteButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "deleteButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "deleteVelocity (  )  ;", "}", "}  )  ;", "}", "}", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "velocities . add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "velocityTable    =    new   JTable (  )     {", "public   Class   getColumnClass ( int   column )     {", "return   column    =  =     1     ?    Boolean . class    :    super . getColumnClass ( column )  ;", "}", "@ Override", "public   Dimension   getPreferredScrollableViewportSize (  )     {", "Dimension   dim    =    super . getPreferredScrollableViewportSize (  )  ;", "dim . height    =    getPreferredSize (  )  . height ;", "return   dim ;", "}", "}  ;", "velocityTable . getTableHeader (  )  . setReorderingAllowed ( false )  ;", "velocityTable . setSelectionMode ( ListSelectionModel . SINGLE _ SELECTION )  ;", "scroll . setViewportView ( velocityTable )  ;", "velocityTableModel    =    new   DefaultTableModel ( new   String [  0  ]  [  0  ]  ,    new   String [  ]  {     \" Velocity \"  ,     \" Active \"     }  )  ;", "velocityTable . setModel ( velocityTableModel )  ;", "velocityTable . getSelectionModel (  )  . addListSelectionListener ( new   ListSelectionListener (  )     {", "public   void   valueChanged ( ListSelectionEvent   event )     {", "if    ( event . getValueIsAdjusting (  )  )", "return ;", "velocitySelected (  )  ;", "}", "}  )  ;", "velocityTableModel . addTableModelListener ( new   TableModelListener (  )     {", "public   void   tableChanged ( TableModelEvent   event )     {", "if    (  ( event . getColumn (  )  )     !  =     1  )", "return ;", "velocityChecked ( event . getFirstRow (  )  ,     (  ( Boolean )     ( velocityTable . getValueAt ( event . getFirstRow (  )  ,     1  )  )  )  )  ;", "}", "}  )  ;", "empty    =    new   ParticleValue ( editor ,     \"  \"  ,     \"  \"  ,    true ,    false )  ;", "strengthVelocity    =    new   StrengthVelocity ( editor ,    null ,     \" Life \"  ,     \"  \"  ,     \"  \"  )  ;", "angularVelocity    =    new   AngularVelocity ( editor ,    null ,     \" Life \"  ,     \"  \"  ,     \"  \"  )  ;", "strengthVelocity . setVisible ( false )  ;", "angularVelocity . setVisible ( false )  ;", "empty . setVisible ( false )  ;", "strengthVelocity . setIsAlwayShown ( true )  ;", "angularVelocity . setIsAlwayShown ( true )  ;", "empty . setIsAlwayShown ( true )  ;", "empty . setValue ( null )  ;", "int   i    =     0  ;", "addContent (  ( i +  +  )  ,     0  ,    velocities )  ;", "addContent (  ( i +  +  )  ,     0  ,    strengthVelocity )  ;", "addContent (  ( i +  +  )  ,     0  ,    angularVelocity )  ;", "addContent (  ( i +  +  )  ,     0  ,    empty )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( velocityTableModel . getRowCount (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "velocityTableModel . removeRow ( i )  ;", "}", "velocities . clear (  )  ;", "for    ( int   i    =     0  ,    c    =    influencer . velocities . size ;    i    <    c ;     +  + i )     {", "velocities . add ( new    . VelocityWrapper (  (  ( DynamicsModifier )     ( influencer . velocities . items [ i ]  )  )  ,    true )  )  ;", "velocityTableModel . addRow ( new   Object [  ]  {     \" Velocity    \"     +    i ,    true    }  )  ;", "}", "DefaultComboBoxModel   model    =     (  ( DefaultComboBoxModel )     ( velocityBox . getModel (  )  )  )  ;", "model . removeAllElements (  )  ;", "for    ( Object   velocityObject    :    getAvailableVelocities ( editor . getControllerType (  )  )  )     {", "model . addElement ( velocityObject )  ;", "}", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "ParticleController   controller    =    editor . getEmitter (  )  ;", "DynamicsInfluencer   influencer    =     (  ( DynamicsInfluencer )     ( controller . findInfluencer ( DynamicsInfluencer . class )  )  )  ;", "influencer . velocities . clear (  )  ;", "velocities . get ( index )  . isActive    =    isChecked ;", "for    (  . VelocityWrapper   wrapper    :    velocities )     {", "if    ( wrapper . isActive )", "influencer . velocities . add ( wrapper . velocityValue )  ;", "}", "editor . restart (  )  ;", "}", "METHOD_END"], "methodName": ["velocityChecked"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "int   index    =    velocityTable . getSelectedRow (  )  ;", "if    ( index    =  =     (  -  1  )  )", "return ;", "Modifier   velocityValue    =    velocities . get ( index )  . velocityValue ;", "EditorPanel   velocityPanel    =    getVelocityPanel ( velocityValue )  ;", "if    (  (  ( selectedVelocityPanel )     !  =    null )     &  &     (  ( selectedVelocityPanel )     !  =    velocityPanel )  )", "selectedVelocityPanel . setVisible ( false )  ;", "velocityPanel . setVisible ( true )  ;", "velocityPanel . showContent ( true )  ;", "selectedVelocityPanel    =    velocityPanel ;", "}", "METHOD_END"], "methodName": ["velocitySelected"], "fileName": "com.badlogic.gdx.tools.flame.DynamicsInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "addContent ( row ,    column ,    component ,    true ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH )  ;", "}", "METHOD_END"], "methodName": ["addContent"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "addContent ( row ,    column ,    component ,    addBorder ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH )  ;", "}", "METHOD_END"], "methodName": ["addContent"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "addContent ( row ,    column ,    component ,    addBorders ,    anchor ,    fill ,     1  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["addContent"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "EditorPanel . addContent ( contentPanel ,    row ,    column ,    component ,    addBorders ,    anchor ,    fill ,    wx ,    wy )  ;", "}", "METHOD_END"], "methodName": ["addContent"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "addContent ( row ,    column ,    component ,    true ,    anchor ,    fill )  ;", "}", "METHOD_END"], "methodName": ["addContent"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "if    ( addBorders )", "component . setBorder ( createMatteBorder (  0  ,     0  ,     1  ,     0  ,    black )  )  ;", "p . add ( component ,    new   GridBagConstraints ( column ,    row ,     1  ,     1  ,    wx ,    wy ,    anchor ,    fill ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["addContent"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "return   advancedPanel ;", "}", "METHOD_END"], "methodName": ["getAdvancedPanel"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "return   contentPanel ;", "}", "METHOD_END"], "methodName": ["getContentPanel"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "setLayout ( new   GridBagLayout (  )  )  ;", "{", "title    =    new   J ( new   GridBagLayout (  )  )  ;", "add ( title ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  3  ,     0  ,     3  ,     0  )  ,     0  ,     0  )  )  ;", "title . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND _ CURSOR )  )  ;", "{", "nameLabel    =    new   JLabel ( name )  ;", "title . add ( nameLabel ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  3  ,     6  ,     3  ,     6  )  ,     0  ,     0  )  )  ;", "nameLabel . setFont ( nameLabel . getFont (  )  . deriveFont ( Font . BOLD )  )  ;", "}", "{", "descriptionLabel    =    new   JLabel ( description )  ;", "title . add ( descriptionLabel ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  3  ,     6  ,     3  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "advancedButton    =    new   JToggleButton (  \" Advanced \"  )  ;", "title . add ( advancedButton ,    new   GridBagConstraints (  2  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "advancedButton . setVisible ( false )  ;", "}", "{", "activeButton    =    new   JToggleButton (  \" Active \"  )  ;", "title . add ( activeButton ,    new   GridBagConstraints (  3  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "removeButton    =    new   JButton (  \" X \"  )  ;", "title . add ( removeButton ,    new   GridBagConstraints (  4  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "content    =    new   J ( new   GridBagLayout (  )  )  ;", "add ( content ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     6  ,     6  ,     6  )  ,     0  ,     0  )  )  ;", "content . setVisible ( false )  ;", "}", "{", "advanced    =    new   J ( new   GridBagLayout (  )  )  ;", "add ( advanced ,    new   GridBagConstraints (  1  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     6  ,     6  ,     6  )  ,     0  ,     0  )  )  ;", "advanced . setVisible ( false )  ;", "}", "title . addMouseListener ( new   MouseAdapter (  )     {", "public   void   mouseClicked ( MouseEvent   event )     {", "if    (  !  ( isAlwaysShown )  )", "showContent (  (  !  ( content . isVisible (  )  )  )  )  ;", "}", "}  )  ;", "activeButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "activate (  )  ;", "}", "}  )  ;", "advancedButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "advanced . setVisible ( advancedButton . isSelected (  )  )  ;", "}", "}  )  ;", "removeButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "remove (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "Container   parent    =    this . getParent (  )  ;", "parent . remove ( this )  ;", "parent . validate (  )  ;", "parent . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["removePanel"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "description    =    desc ;", "descriptionLab . setText ( desc )  ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "GridBagLayout   layout    =     (  ( GridBagLayout )     ( getLayout (  )  )  )  ;", "GridBagConstraints   constraints    =    layout . getConstraints ( content )  ;", "constraints . insets    =    new   Insets (  0  ,     0  ,     0  ,     0  )  ;", "layout . setConstraints ( content ,    constraints )  ;", "title . setVisible ( false )  ;", "}", "METHOD_END"], "methodName": ["setEmbedded"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "this . hasAdvanced    =    hasAdvanced ;", "advancedButton . setVisible ( hasAdvanced )  ;", "}", "METHOD_END"], "methodName": ["setHasAdvanced"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "showContent ( isAlwaysShown )  ;", "this . isAlwaysShown    =    isAlwaysShown ;", "title . setCursor ( null )  ;", "}", "METHOD_END"], "methodName": ["setIsAlwayShown"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "nameLabel . setText ( name )  ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "activeButton . setVisible (  ( value    =  =    null    ?    false    :     !  ( isAlwaysActive )  )  )  ;", "removeButton . setVisible ( isRemovable )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "ChangeListener [  ]    listeners    =    slider . spinner . getChangeListeners (  )  ;", "ChangeListener   listener    =    null ;", "if    (  ( listeners    !  =    null )     &  &     (  ( listeners . length )     >     0  )  )     {", "listener    =    listeners [  0  ]  ;", "slider . spinner . removeChangeListener ( listener )  ;", "}", "slider . setValue ( value )  ;", "if    ( listener    !  =    null )", "slider . spinner . addChangeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "ActionListener [  ]    listeners    =    checkBox . getActionListeners (  )  ;", "ActionListener   listener    =    null ;", "if    (  ( listeners    !  =    null )     &  &     (  ( listeners . length )     >     0  )  )     {", "listener    =    listeners [  0  ]  ;", "checkBox . removeActionListener ( listener )  ;", "}", "checkBox . setSelected ( isSelected )  ;", "if    ( listener    !  =    null )", "checkBox . addActionListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "ChangeListener [  ]    listeners    =    spinner . getChangeListeners (  )  ;", "ChangeListener   listener    =    null ;", "if    (  ( listeners    !  =    null )     &  &     (  ( listeners . length )     >     0  )  )     {", "listener    =    listeners [  0  ]  ;", "spinner . removeChangeListener ( listener )  ;", "}", "spinner . setValue ( object )  ;", "if    ( listener    !  =    null )", "spinner . addChangeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "TableModelListener [  ]    listeners    =    tableModel . getTableModelListeners (  )  ;", "TableModelListener   listener    =    null ;", "if    (  ( listeners    !  =    null )     &  &     (  ( listeners . length )     >     0  )  )     {", "listener    =    listeners [  0  ]  ;", "tableModel . removeTableModelListener ( listener )  ;", "}", "tableModel . setValueAt ( value ,    row ,    column )  ;", "if    ( listener    !  =    null )", "tableModel . addTableModelListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "contentPanel . setVisible ( visible )  ;", "advancedPanel . setVisible (  ( visible    &  &     ( advancedButton . isSelected (  )  )  )  )  ;", "advancedButton . setVisible (  ( visible    &  &     ( hasAdvanced )  )  )  ;", "descriptionLabel . setText (  ( visible    ?    description    :     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["showContent"], "fileName": "com.badlogic.gdx.tools.flame.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "editor . addEmitter ( emitter )  ;", "emitterTableModel . addRow ( new   Object [  ]  {    emitter . n ,    true    }  )  ;", "int   row    =     ( emitterTableModel . getRowCount (  )  )     -     1  ;", "emitterChecked ( row ,    true )  ;", "if    ( select )     {", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( row ,    row )  ;", "}", "}", "METHOD_END"], "methodName": ["addEmitter"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "int   row    =    emitterTable . getSelectedRow (  )  ;", "if    ( row    =  =     (  -  1  )  )", "return ;", "ParticleController   controller    =    editor . controllersData . get ( row )  . controller . copy (  )  ;", "controller . init (  )  ;", "controller . name    +  =     \"    Clone \"  ;", "addEmitter ( controller ,    true )  ;", "}", "METHOD_END"], "methodName": ["cloneEmitter"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "RegularEmitter   emitter    =    new   RegularEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  3  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  2  5  0  )  ;", "emitter . getLife (  )  . setHigh (  5  0  0  ,     1  0  0  0  )  ;", "emitter . getLife (  )  . setTimeline ( new   float [  ]  {     0  ,     0  .  6  6 F ,     1     }  )  ;", "emitter . getLife (  )  . setScaling ( new   float [  ]  {     1  ,     1  ,     0  .  3 F    }  )  ;", "emitter . setMaxParticleCount (  2  0  0  )  ;", "PointSpawnShapeValue   pointSpawnShapeValue    =    new   PointSpawnShapeValue (  )  ;", "SpawnInfluencer   spawnSource    =    new   SpawnInfluencer ( pointSpawnShapeValue )  ;", "ColorInfluencer . Single   colorInfluencer    =    new   ColorInfluencer . Single (  )  ;", "colorInfluencer . colorValue . setColors ( new   float [  ]  {     1  ,     0  .  1  2  1  5  6  8  6  3 F ,     0  .  0  4  7  0  5  8  8  2  4 F ,     0  ,     0  ,     0     }  )  ;", "colorInfluencer . colorValue . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "colorInfluencer . alphaValue . setHigh (  1  )  ;", "colorInfluencer . alphaValue . setTimeline ( new   float [  ]  {     0  ,     0  .  5 F ,     0  .  8 F ,     1     }  )  ;", "colorInfluencer . alphaValue . setScaling ( new   float [  ]  {     0  ,     0  .  1  5 F ,     0  .  5 F ,     0     }  )  ;", "DynamicsInfluencer   velocityInfluencer    =    new   DynamicsInfluencer (  )  ;", "DynamicsModifier . PolarAcceleration   velocityValue    =    new   DynamicsModifier . PolarAcceleration (  )  ;", "velocityValue . phiValue . setHigh (  (  -  3  5  )  ,     3  5  )  ;", "velocityValue . phiValue . setActive ( true )  ;", "velocityValue . phiValue . setTimeline ( new   float [  ]  {     0  ,     0  .  5 F ,     1     }  )  ;", "velocityValue . phiValue . setScaling ( new   float [  ]  {     1  ,     0  ,     0     }  )  ;", "velocityValue . thetaValue . setHigh (  0  ,     3  6  0  )  ;", "velocityValue . strengthValue . setHigh (  5  ,     1  0  )  ;", "velocityInfluencer . velocities . add ( velocityValue )  ;", "return   new   graphics . g 3 d . particles . ParticleController (  \" Billboard   Controller \"  ,    emitter ,    new   graphics . g 3 d . particles . renderers . BillboardRenderer ( editor . getBillboardBatch (  )  )  ,    new   graphics . g 3 d . particles . influencers . RegionInfluencer . Single ( editor . getTexture (  )  )  ,    spawnSource ,    colorInfluencer ,    velocityInfluencer )  ;", "}", "METHOD_END"], "methodName": ["createDefaultBillboardController"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "T   controller    =    null ;", "if    ( type    =  =     ( FMain . ControllerType . Billboard )  )     {", "controller    =     (  ( T )     ( createDefaultBillboardController (  )  )  )  ;", "} else", "if    ( type    =  =     ( FMain . ControllerType . ModelInstance )  )     {", "controller    =     (  ( T )     ( createDefaultModelInstanceController (  )  )  )  ;", "} else", "if    ( type    =  =     ( FMain . ControllerType . PointSprite )  )     {", "controller    =     (  ( T )     ( createDefaultPointController (  )  )  )  ;", "} else", "if    ( type    =  =     ( FMain . ControllerType . ParticleController )  )     {", "controller    =     (  ( T )     ( createDefaultParticleController (  )  )  )  ;", "}", "if    ( add )     {", "controller . init (  )  ;", "addEmitter ( controller ,    select )  ;", "}", "return   controller ;", "}", "METHOD_END"], "methodName": ["createDefaultEmitter"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "RegularEmitter   emitter    =    new   RegularEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  3  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  8  0  )  ;", "emitter . getLife (  )  . setHigh (  5  0  0  ,     1  0  0  0  )  ;", "emitter . getLife (  )  . setTimeline ( new   float [  ]  {     0  ,     0  .  6  6 F ,     1     }  )  ;", "emitter . getLife (  )  . setScaling ( new   float [  ]  {     1  ,     1  ,     0  .  3 F    }  )  ;", "emitter . setMaxParticleCount (  1  0  0  )  ;", "ColorInfluencer . Random   colorInfluencer    =    new   ColorInfluencer . Random (  )  ;", "EllipseSpawnShapeValue   spawnShapeValue    =    new   EllipseSpawnShapeValue (  )  ;", "spawnShapeValue . setDimensions (  1  ,     1  ,     1  )  ;", "SpawnInfluencer   spawnSource    =    new   SpawnInfluencer ( spawnShapeValue )  ;", "DynamicsInfluencer   velocityInfluencer    =    new   DynamicsInfluencer (  )  ;", "DynamicsModifier . CentripetalAcceleration   velocityValue    =    new   DynamicsModifier . CentripetalAcceleration (  )  ;", "velocityValue . strengthValue . setHigh (  5  ,     1  1  )  ;", "velocityValue . strengthValue . setActive ( true )  ;", "velocityInfluencer . velocities . add ( velocityValue )  ;", "return   new   graphics . g 3 d . particles . ParticleController (  \" ModelInstance   Controller \"  ,    emitter ,    new   graphics . g 3 d . particles . renderers . ModelInstanceRenderer ( editor . getModelInstanceParticleBatch (  )  )  ,    new   ModelInfluencer . Single (  (  ( Model )     ( editor . assetManager . get ( FlameMain . DEFAULT _ MODEL _ PARTICLE )  )  )  )  ,    spawnSource ,    colorInfluencer ,    velocityInfluencer )  ;", "}", "METHOD_END"], "methodName": ["createDefaultModelInstanceController"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "RegularEmitter   emitter    =    new   RegularEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  3  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  9  0  )  ;", "emitter . getLife (  )  . setHigh (  3  0  0  0  )  ;", "emitter . setMaxParticleCount (  1  0  0  )  ;", "EllipseSpawnShapeValue   pointSpawnShapeValue    =    new   EllipseSpawnShapeValue (  )  ;", "pointSpawnShapeValue . setDimensions (  1  ,     1  ,     1  )  ;", "pointSpawnShapeValue . setSide ( top )  ;", "SpawnInfluencer   spawnSource    =    new   SpawnInfluencer ( pointSpawnShapeValue )  ;", "ScaleInfluencer   scaleInfluencer    =    new   ScaleInfluencer (  )  ;", "scaleInfluencer . value . setHigh (  1  )  ;", "scaleInfluencer . value . setLow (  0  )  ;", "scaleInfluencer . value . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "scaleInfluencer . value . setScaling ( new   float [  ]  {     1  ,     0     }  )  ;", "DynamicsInfluencer   velocityInfluencer    =    new   DynamicsInfluencer (  )  ;", "DynamicsModifier . CentripetalAcceleration   velocityValue    =    new   DynamicsModifier . CentripetalAcceleration (  )  ;", "velocityValue . strengthValue . setHigh (  5  ,     1  0  )  ;", "velocityValue . strengthValue . setActive ( true )  ;", "velocityInfluencer . velocities . add ( velocityValue )  ;", "return   new   graphics . g 3 d . particles . ParticleController (  \" ParticleController   Controller \"  ,    emitter ,    new   ParticleControllerControllerRenderer (  )  ,    new   graphics . g 3 d . particles . influencers . ParticleControllerInfluencer . Single ( editor . assetManager . get ( FlameMain . DEFAULT _ TEMPLATE _ PFX ,    ParticleEffect . class )  . getControllers (  )  . get (  0  )  )  ,    spawnSource ,    scaleInfluencer ,    velocityInfluencer ,    new   ParticleControllerFinalizerInfluencer (  )  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultParticleController"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "RegularEmitter   emitter    =    new   RegularEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  3  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  2  5  0  )  ;", "emitter . getLife (  )  . setHigh (  5  0  0  ,     1  0  0  0  )  ;", "emitter . getLife (  )  . setTimeline ( new   float [  ]  {     0  ,     0  .  6  6 F ,     1     }  )  ;", "emitter . getLife (  )  . setScaling ( new   float [  ]  {     1  ,     1  ,     0  .  3 F    }  )  ;", "emitter . setMaxParticleCount (  2  0  0  )  ;", "ScaleInfluencer   scaleInfluencer    =    new   ScaleInfluencer (  )  ;", "scaleInfluencer . value . setHigh (  1  )  ;", "ColorInfluencer . Single   colorInfluencer    =    new   ColorInfluencer . Single (  )  ;", "colorInfluencer . colorValue . setColors ( new   float [  ]  {     0  .  1  2  1  5  6  8  6  3 F ,     0  .  0  4  7  0  5  8  8  2  4 F ,     1  ,     0  ,     0  ,     0     }  )  ;", "colorInfluencer . colorValue . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "colorInfluencer . alphaValue . setHigh (  1  )  ;", "colorInfluencer . alphaValue . setTimeline ( new   float [  ]  {     0  ,     0  .  5 F ,     0  .  8 F ,     1     }  )  ;", "colorInfluencer . alphaValue . setScaling ( new   float [  ]  {     0  ,     0  .  1  5 F ,     0  .  5 F ,     0     }  )  ;", "PointSpawnShapeValue   pointSpawnShapeValue    =    new   PointSpawnShapeValue (  )  ;", "SpawnInfluencer   spawnSource    =    new   SpawnInfluencer ( pointSpawnShapeValue )  ;", "DynamicsInfluencer   velocityInfluencer    =    new   DynamicsInfluencer (  )  ;", "DynamicsModifier . PolarAcceleration   velocityValue    =    new   DynamicsModifier . PolarAcceleration (  )  ;", "velocityValue . phiValue . setHigh (  (  -  3  5  )  ,     3  5  )  ;", "velocityValue . phiValue . setActive ( true )  ;", "velocityValue . phiValue . setTimeline ( new   float [  ]  {     0  ,     0  .  5 F ,     1     }  )  ;", "velocityValue . phiValue . setScaling ( new   float [  ]  {     1  ,     0  ,     0     }  )  ;", "velocityValue . thetaValue . setHigh (  0  ,     3  6  0  )  ;", "velocityValue . strengthValue . setHigh (  5  ,     1  0  )  ;", "return   new   graphics . g 3 d . particles . ParticleController (  \" PointSprite   Controller \"  ,    emitter ,    new   graphics . g 3 d . particles . renderers . PointSpriteRenderer ( editor . getPointSpriteBatch (  )  )  ,    new   RegionInfluencer . Single (  (  ( Texture )     ( editor . assetManager . get ( FlameMain . DEFAULT _ BILLBOARD _ PARTICLE )  )  )  )  ,    spawnSource ,    scaleInfluencer ,    colorInfluencer ,    velocityInfluencer )  ;", "}", "METHOD_END"], "methodName": ["createDefaultPointController"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "RegularEmitter   emitter    =    new   RegularEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  3  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  9  0  )  ;", "emitter . getLife (  )  . setHigh (  1  0  0  0  )  ;", "emitter . getLife (  )  . setTimeline ( new   float [  ]  {     0  ,     0  .  6  6 F ,     1     }  )  ;", "emitter . getLife (  )  . setScaling ( new   float [  ]  {     1  ,     1  ,     0  .  3 F    }  )  ;", "emitter . setMaxParticleCount (  1  0  0  )  ;", "PointSpawnShapeValue   pointSpawnShapeValue    =    new   PointSpawnShapeValue (  )  ;", "pointSpawnShapeValue . xOffsetValue . setLow (  0  ,     1  .  0 F )  ;", "pointSpawnShapeValue . xOffsetValue . setActive ( true )  ;", "pointSpawnShapeValue . yOffsetValue . setLow (  0  ,     1  .  0 F )  ;", "pointSpawnShapeValue . yOffsetValue . setActive ( true )  ;", "pointSpawnShapeValue . zOffsetValue . setLow (  0  ,     1  .  0 F )  ;", "pointSpawnShapeValue . zOffsetValue . setActive ( true )  ;", "SpawnInfluencer   spawnSource    =    new   SpawnInfluencer ( pointSpawnShapeValue )  ;", "ScaleInfluencer   scaleInfluencer    =    new   ScaleInfluencer (  )  ;", "scaleInfluencer . value . setHigh (  1  .  0 F )  ;", "ColorInfluencer . Single   colorInfluencer    =    new   ColorInfluencer . Single (  )  ;", "colorInfluencer . colorValue . setColors ( new   float [  ]  {     1  ,     0  .  1  2  1  5  6  8  6  3 F ,     0  .  0  4  7  0  5  8  8  2  4 F ,     0  ,     0  ,     0     }  )  ;", "colorInfluencer . colorValue . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "colorInfluencer . alphaValue . setHigh (  1  )  ;", "colorInfluencer . alphaValue . setTimeline ( new   float [  ]  {     0  ,     0  .  5 F ,     0  .  8 F ,     1     }  )  ;", "colorInfluencer . alphaValue . setScaling ( new   float [  ]  {     0  ,     0  .  1  5 F ,     0  .  5 F ,     0     }  )  ;", "return   new   graphics . g 3 d . particles . ParticleController (  \" Billboard   Controller \"  ,    emitter ,    new   graphics . g 3 d . particles . renderers . BillboardRenderer ( editor . getBillboardBatch (  )  )  ,    new   graphics . g 3 d . particles . influencers . RegionInfluencer . Single ( editor . getTexture (  )  )  ,    spawnSource ,    scaleInfluencer ,    colorInfluencer )  ;", "}", "METHOD_END"], "methodName": ["createDefaultTemplateController"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "int   row    =    emitterTable . getSelectedRow (  )  ;", "if    ( row    =  =     (  -  1  )  )", "return ;", "int   newIndex    =    Math . min ( editIndex ,     (  ( emitterTableModel . getRowCount (  )  )     -     2  )  )  ;", "editor . removeEmitter ( row )  ;", "emitterTableModel . removeRow ( row )  ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( newIndex ,    newIndex )  ;", "}", "METHOD_END"], "methodName": ["deleteEmitter"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "editor . setEnabled ( index ,    checked )  ;", "}", "METHOD_END"], "methodName": ["emitterChecked"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "int   row    =    emitterTable . getSelectedRow (  )  ;", "if    ( row    =  =     ( editIndex )  )", "return ;", "editIndex    =    row ;", "editor . reloadRows (  )  ;", "}", "METHOD_END"], "methodName": ["emitterSelected"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "File   file    =    editor . showFileLoadDialog (  )  ;", "if    ( file    !  =    null )     {", "Particle   effect ;", "if    (  ( effect    =    editor . open ( file ,    false )  )     !  =    null )     {", "for    ( ParticleController   controller    :    effect . getControllers (  )  )", "addEmitter ( controller ,    false )  ;", "editIndex    =     0  ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( editIndex ,    editIndex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["importEffect"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "setLayout ( new   GridBagLayout (  )  )  ;", "{", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "{", "emitterTable    =    new   JTable (  )     {", "public   Class   getColumnClass ( int   column )     {", "return   column    =  =     1     ?    Boolean . class    :    super . getColumnClass ( column )  ;", "}", "@ Override", "public   Dimension   getPreferredScrollableViewportSize (  )     {", "Dimension   dim    =    super . getPreferredScrollableViewportSize (  )  ;", "dim . height    =    getPreferredSize (  )  . height ;", "return   dim ;", "}", "}  ;", "emitterTable . getTableHeader (  )  . setReorderingAllowed ( false )  ;", "emitterTable . setSelectionMode ( ListSelectionModel . SINGLE _ SELECTION )  ;", "scroll . setViewportView ( emitterTable )  ;", "emitterTableModel    =    new   DefaultTableModel ( new   String [  0  ]  [  0  ]  ,    new   String [  ]  {     \" Emitter \"  ,     \"  \"     }  )  ;", "emitterTable . setModel ( emitterTableModel )  ;", "emitterTable . getSelectionModel (  )  . addListSelectionListener ( new   ListSelectionListener (  )     {", "public   void   valueChanged ( ListSelectionEvent   event )     {", "if    ( event . getValueIsAdjusting (  )  )", "return ;", "emitterSelected (  )  ;", "}", "}  )  ;", "emitterTableModel . addTableModelListener ( new   TableModelListener (  )     {", "public   void   tableChanged ( TableModelEvent   event )     {", "if    (  ( event . getColumn (  )  )     !  =     1  )", "return ;", "emitterChecked ( event . getFirstRow (  )  ,     (  ( Boolean )     ( emitterTable . getValueAt ( event . getFirstRow (  )  ,     1  )  )  )  )  ;", "}", "}  )  ;", "}", "}", "{", "JPanel   sideButtons    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "add ( sideButtons ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "{", "controllerTypeCombo    =    new   JComboBox (  )  ;", "controllerTypeCombo . setModel ( new   DefaultComboBoxModel ( FlameMain . ControllerType . values (  )  )  )  ;", "sideButtons . add ( controllerTypeCombo ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JButton   newButton    =    new   JButton (  \" New \"  )  ;", "sideButtons . add ( newButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "newButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "FlameMain . ControllerType   item    =     (  ( FlameMain . ControllerType )     ( controllerTypeCombo . getSelectedItem (  )  )  )  ;", "createDefaultEmitter ( item ,    true ,    true )  ;", "}", "}  )  ;", "}", "{", "JButton   deleteButton    =    new   JButton (  \" Delete \"  )  ;", "sideButtons . add ( deleteButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "deleteButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "deleteEmitter (  )  ;", "}", "}  )  ;", "}", "{", "JButton   cloneButton    =    new   JButton (  \" Clone \"  )  ;", "sideButtons . add ( cloneButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "cloneButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "cloneEmitter (  )  ;", "}", "}  )  ;", "}", "{", "sideButtons . add ( new   JSeparator ( JSeparator . HORIZONTAL )  ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JButton   saveButton    =    new   JButton (  \" Save \"  )  ;", "sideButtons . add ( saveButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "saveButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "save (  )  ;", "}", "}  )  ;", "}", "{", "JButton   openButton    =    new   JButton (  \" Open \"  )  ;", "sideButtons . add ( openButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "openButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "open (  )  ;", "}", "}  )  ;", "}", "{", "JButton   importButton    =    new   JButton (  \" Import \"  )  ;", "sideButtons . add ( importButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "importButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "import (  )  ;", "}", "}  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "File   file    =    editor . showFileLoadDialog (  )  ;", "if    ( file    !  =    null )     {", "if    (  ( editor . open ( file ,    true )  )     !  =    null )     {", "emitterTableModel . getDataVector (  )  . removeAllElements (  )  ;", "for    ( FlameMain . ControllerData   data    :    editor . controllersData )     {", "emitterTableModel . addRow ( new   Object [  ]  {    data . controller . name ,    true    }  )  ;", "}", "editIndex    =     0  ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( editIndex ,    editIndex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["openEffect"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "File   file    =    editor . showFileSaveDialog (  )  ;", "if    ( file    !  =    null )     {", "int   index    =     0  ;", "for    ( FlameMain . ControllerData   data    :    editor . controllersData )", "data . controller . name    =     (  ( String )     ( emitterTableModel . getValueAt (  ( index +  +  )  ,     0  )  )  )  ;", "editor . save ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["saveEffect"], "fileName": "com.badlogic.gdx.tools.flame.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "boolean   isNew    =    false ;", "Array <  . Listener >    listeners    =    mListeners . get ( aEventType )  ;", "if    ( listeners    =  =    null )     {", "listeners    =    new   Array <  . Listener >  (  )  ;", "mListeners . put ( aEventType ,    listeners )  ;", "isNew    =    true ;", "}", "if    ( isNew    |  |     (  !  ( listeners . contains ( aListener ,    true )  )  )  )     {", "listeners . add ( aListener )  ;", "}", "}", "METHOD_END"], "methodName": ["attach"], "fileName": "com.badlogic.gdx.tools.flame.EventManager"}, {"methodBody": ["METHOD_START", "{", "mListeners . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.tools.flame.EventManager"}, {"methodBody": ["METHOD_START", "{", "Array < EventManager . Listener >    listeners    =    mListeners . get ( aEventType )  ;", "if    ( listeners    !  =    null )     {", "listeners . removeValue ( aListener ,    true )  ;", "if    (  ( listeners . size )     =  =     0  )", "mListeners . remove ( aEventType )  ;", "}", "}", "METHOD_END"], "methodName": ["detach"], "fileName": "com.badlogic.gdx.tools.flame.EventManager"}, {"methodBody": ["METHOD_START", "{", "Array < EventManager . Listener >    listeners    =    mListeners . get ( aEventType )  ;", "if    ( listeners    !  =    null )", "for    ( EventManager . Listener   listener    :    listeners )     {", "listener . handle ( aEventType ,    aEventData )  ;", "}", "}", "METHOD_END"], "methodName": ["fire"], "fileName": "com.badlogic.gdx.tools.flame.EventManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( EventManager . mInstance )     =  =    null )", "EventManager . mInstance    =    new   EventManager (  )  ;", "return   EventManager . mInstance ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.tools.flame.EventManager"}, {"methodBody": ["METHOD_START", "{", "controllersData . add ( new   FlameMain . ControllerData ( emitter )  )  ;", "rebuildActiveControllers (  )  ;", "}", "METHOD_END"], "methodName": ["addEmitter"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "if    (  ( controller . findInfluencer ( type )  )     !  =    null )", "return ;", "try    {", "controller . end (  )  ;", "Influencer   newInfluencer    =    type . newInstance (  )  ;", "boolean   replaced    =    false ;", "if    ( ColorInfluencer . class . isAssignableFrom ( type )  )     {", "replaced    =    controller . replaceInfluencer ( ColorInfluencer . class ,     (  ( ColorInfluencer )     ( newInfluencer )  )  )  ;", "} else", "if    ( graphics . g 3 d . particles . influencers . RegionInfluencer . class . isAssignableFrom ( type )  )     {", "replaced    =    controller . replaceInfluencer ( graphics . g 3 d . particles . influencers . RegionInfluencer . class ,     (  ( graphics . g 3 d . particles . influencers . RegionInfluencer )     ( newInfluencer )  )  )  ;", "} else", "if    ( graphics . g 3 d . particles . influencers . ModelInfluencer . class . isAssignableFrom ( type )  )     {", "graphics . g 3 d . particles . influencers . ModelInfluencer   newModelInfluencer    =     (  ( graphics . g 3 d . particles . influencers . ModelInfluencer )     ( newInfluencer )  )  ;", "graphics . g 3 d . particles . influencers . ModelInfluencer   currentInfluencer    =     (  ( graphics . g 3 d . particles . influencers . ModelInfluencer )     ( controller . findInfluencer ( graphics . g 3 d . particles . influencers . ModelInfluencer . class )  )  )  ;", "if    ( currentInfluencer    !  =    null )     {", "newModelInfluencer . models . add ( currentInfluencer . models . first (  )  )  ;", "}", "replaced    =    controller . replaceInfluencer ( graphics . g 3 d . particles . influencers . ModelInfluencer . class ,     (  ( graphics . g 3 d . particles . influencers . ModelInfluencer )     ( newInfluencer )  )  )  ;", "} else", "if    ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer . class . isAssignableFrom ( type )  )     {", "graphics . g 3 d . particles . influencers . ParticleControllerInfluencer   newModelInfluencer    =     (  ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer )     ( newInfluencer )  )  ;", "graphics . g 3 d . particles . influencers . ParticleControllerInfluencer   currentInfluencer    =     (  ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer )     ( controller . findInfluencer ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer . class )  )  )  ;", "if    ( currentInfluencer    !  =    null )     {", "newModelInfluencer . templates . add ( currentInfluencer . templates . first (  )  )  ;", "}", "replaced    =    controller . replaceInfluencer ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer . class ,     (  ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer )     ( newInfluencer )  )  )  ;", "}", "if    (  ! replaced )     {", "if    (  ( getControllerType (  )  )     !  =     ( FlameMain . ControllerType . ParticleController )  )", "controller . influencers . add ( newInfluencer )  ;", "else    {", "Influencer   finalizer    =    controller . influencers . pop (  )  ;", "controller . influencers . add ( newInfluencer )  ;", "controller . influencers . add ( finalizer )  ;", "}", "}", "controller . init (  )  ;", "effect . start (  )  ;", "reloadRows (  )  ;", "}    catch    ( Exception   e 1  )     {", "e 1  . printStackTrace (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addInfluencer"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "addRow ( panel ,    row ,     1  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["addRow"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "row . setBorder ( BorderFactory . createMatteBorder (  0  ,     0  ,     2  ,     0  ,    Color . black )  )  ;", "panel . add ( row ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,    wx ,    wy ,    GridBagConstraints . NORTH ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["addRow"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "boolean   hasSameInfluencer    =     ( controller . findInfluencer ( influencerType )  )     !  =    null ;", "if    (  ! hasSameInfluencer )     {", "if    (  (  ( Single . class . isAssignableFrom ( influencerType )  )     &  &     (  ( controller . findInfluencer ( Random . class )  )     !  =    null )  )     |  |     (  ( Random . class . isAssignableFrom ( influencerType )  )     &  &     (  ( controller . findInfluencer ( Single . class )  )     !  =    null )  )  )     {", "return   false ;", "}", "if    ( RegionInfluencer . class . isAssignableFrom ( influencerType )  )     {", "return    ( controller . findInfluencer ( RegionInfluencer . class )  )     =  =    null ;", "} else", "if    ( graphics . g 3 d . particles . influencers . ModelInfluencer . class . isAssignableFrom ( influencerType )  )     {", "return    ( controller . findInfluencer ( graphics . g 3 d . particles . influencers . ModelInfluencer . class )  )     =  =    null ;", "} else", "if    ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer . class . isAssignableFrom ( influencerType )  )     {", "return    ( controller . findInfluencer ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer . class )  )     =  =    null ;", "}", "}", "return    ! hasSameInfluencer ;", "}", "METHOD_END"], "methodName": ["canAddInfluencer"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   getAtlas ( renderer . billboardBatch . getTexture (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAtlas"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "Array < TextureAtlas >    atlases    =    assetManager . getAll ( TextureAtlas . class ,    new   Array < TextureAtlas >  (  )  )  ;", "for    ( TextureAtlas   atlas    :    atlases )     {", "if    ( atlas . getTextures (  )  . conts ( texture )  )", "return   atlas ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAtlas"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   renderer . billboardBatch ;", "}", "METHOD_END"], "methodName": ["getBillboardBatch"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "ParticleController   controller    =    getEmitter (  )  ;", "FlameMain . ControllerType   type    =    null ;", "if    (  ( controller . renderer )    instanceof   BillboardRenderer )", "type    =    FlameMain . ControllerType . Billboard ;", "else", "if    (  ( controller . renderer )    instanceof   graphics . g 3 d . particles . renderers . PointSpriteRenderer )", "type    =    FlameMain . ControllerType . PointSprite ;", "else", "if    (  ( controller . renderer )    instanceof   graphics . g 3 d . particles . renderers . ModelInstanceRenderer )", "type    =    FlameMain . ControllerType . ModelInstance ;", "else", "if    (  ( controller . renderer )    instanceof   graphics . g 3 d . particles . renderers . ParticleControllerControllerRenderer )", "type    =    FlameMain . ControllerType . ParticleController ;", "return   type ;", "}", "METHOD_END"], "methodName": ["getControllerType"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return    ( effectPanel . editIndex )     >  =     0     ?    controllersData . get ( effectPanel . editIndex )  . controller    :    null ;", "}", "METHOD_END"], "methodName": ["getEmitter"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   renderer . modelInstanceParticleBatch ;", "}", "METHOD_END"], "methodName": ["getModelInstanceParticleBatch"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "if    ( renderer   instanceof   PointSpriteParticleBatch )     {", "return   new   EmptyPanel ( this ,     \" Point   Sprite   Batch \"  ,     \" It   renders   particles   as   point   sprites .  \"  )  ;", "}", "if    ( renderer   instanceof   BillboardParticleBatch )     {", "return   new   BillboardBatchPanel ( this ,     (  ( BillboardParticleBatch )     ( renderer )  )  )  ;", "} else", "if    ( renderer   instanceof   graphics . g 3 d . particles . batches . ModelInstanceParticleBatch )     {", "return   new   EmptyPanel ( this ,     \" Model   Instance   Batch \"  ,     \" It   renders   particles   as   model   instances .  \"  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPanel"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "if    ( emitter   instanceof   RegularEmitter )     {", "return   new   RegularEmitterPanel ( this ,     (  ( RegularEmitter )     ( emitter )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPanel"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "if    ( influencer   instanceof   ColorInfluencer . Single )     {", "return   new   ColorInfluencerPanel ( this ,     (  ( ColorInfluencer . Single )     ( influencer )  )  )  ;", "}", "if    ( influencer   instanceof   ColorInfluencer . Random )     {", "return   new   InfluencerPanel < ColorInfluencer . Random >  ( this ,     (  ( ColorInfluencer . Random )     ( influencer )  )  ,     \" Random   Color   Influencer \"  ,     \" Assign   a   random   color   to   the   particles \"  )     {  }  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . ScaleInfluencer )     {", "return   new   ScaleInfluencerPanel ( this ,     (  ( graphics . g 3 d . particles . influencers . ScaleInfluencer )     ( influencer )  )  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . SpawnInfluencer )     {", "return   new   SpawnInfluencerPanel ( this ,     (  ( graphics . g 3 d . particles . influencers . SpawnInfluencer )     ( influencer )  )  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . DynamicsInfluencer )     {", "return   new   DynamicsInfluencerPanel ( this ,     (  ( graphics . g 3 d . particles . influencers . DynamicsInfluencer )     ( influencer )  )  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . ModelInfluencer )     {", "boolean   single    =    influencer   instanceof   graphics . g 3 d . particles . influencers . ModelInfluencer . Single ;", "String   name    =     ( single )     ?     \" Model   Single   Influencer \"     :     \" Model   Random   Influencer \"  ;", "return   new   ModelInfluencerPanel ( this ,     (  ( graphics . g 3 d . particles . influencers . ModelInfluencer )     ( influencer )  )  ,    single ,    name ,     \" Defines   what   model   will   be   used   for   the   particles \"  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . ParticleControllerInfluencer )     {", "boolean   single    =    influencer   instanceof   graphics . g 3 d . particles . influencers . ParticleControllerInfluencer . Single ;", "String   name    =     ( single )     ?     \" Particle   Controller   Single   Influencer \"     :     \" Particle   Controller   Random   Influencer \"  ;", "return   new   ParticleControllerInfluencerPanel ( this ,     (  ( graphics . g 3 d . particles . influencers . ParticleControllerInfluencer )     ( influencer )  )  ,    single ,    name ,     \" Defines   what   controller   will   be   used   for   the   particles \"  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . RegionInfluencer . Single )     {", "return   new   RegionInfluencerPanel ( this ,     \" Billboard   Single   Region   Influencer \"  ,     \" Assign   the   chosen   region   to   the   particles \"  ,     (  ( graphics . g 3 d . particles . influencers . RegionInfluencer . Single )     ( influencer )  )  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . RegionInfluencer . Animated )     {", "return   new   RegionInfluencerPanel ( this ,     \" Billboard   Animated   Region   Influencer \"  ,     \" Animates   the   region   of   the   particles \"  ,     (  ( graphics . g 3 d . particles . influencers . RegionInfluencer . Animated )     ( influencer )  )  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . RegionInfluencer . Random )     {", "return   new   RegionInfluencerPanel ( this ,     \" Billboard   Random   Region   Influencer \"  ,     \" Assigns   a   randomly   picked    ( among   those   selected )    region   to   the   particles \"  ,     (  ( graphics . g 3 d . particles . influencers . RegionInfluencer . Random )     ( influencer )  )  )  ;", "} else", "if    ( influencer   instanceof   graphics . g 3 d . particles . influencers . ParticleControllerFinalizerInfluencer )     {", "return   new   InfluencerPanel < graphics . g 3 d . particles . influencers . ParticleControllerFinalizerInfluencer >  ( this ,     (  ( graphics . g 3 d . particles . influencers . ParticleControllerFinalizerInfluencer )     ( influencer )  )  ,     \" ParticleControllerFinalizer   Influencer \"  ,     \" This   is   required   when   dealing   with   a   controller   of   controllers ,    it   will   update   the   controller   assigned   to   each   particle ,    it   MUST   be   the   last   influencer   always .  \"  ,    true ,    false )     {  }  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPanel"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "out . clear (  )  ;", "assetManager . getAll ( ParticleEffect . class ,    out )  ;", "for    ( int   i    =     0  ;    i    <     ( out . size )  ;  )     {", "ParticleEffect   effect    =    out . get ( i )  ;", "Array < ParticleController >    effectControllers    =    effect . getControllers (  )  ;", "bean   remove    =    true ;", "for    ( ParticleController   controller    :    controllers )     {", "if    ( effectControllers . contains ( controller ,    true )  )     {", "remove    =    false ;", "break ;", "}", "}", "if    ( remove )     {", "out . removeIndex ( i )  ;", "continue ;", "}", "+  + i ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["getParticleEffects"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   renderer . pointSpriteBatch ;", "}", "METHOD_END"], "methodName": ["getPointSpriteBatch"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   renderer ;", "}", "METHOD_END"], "methodName": ["getRenderer"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   renderer . billboardBatch . getTexture (  )  ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "splitPane    =    new   JSplitPane (  )  ;", "splitPane . setUI ( new   BasicSplitPaneUI (  )     {", "public   void   paint ( Graphics   g ,    JComponent   jc )     {", "}", "}  )  ;", "splitPane . setDividerSize (  4  )  ;", "getContentPane (  )  . add ( splitPane ,    BorderLayout . CENTER )  ;", "{", "JSplitPane   rightSplit    =    new   JSplitPane ( JSplitPane . VERTICAL _ SPLIT )  ;", "rightSplit . setUI ( new   BasicSplitPaneUI (  )     {", "public   void   paint ( Graphics   g ,    JComponent   jc )     {", "}", "}  )  ;", "rightSplit . setDividerSize (  4  )  ;", "splitPane . add ( rightSplit ,    JSplitPane . RIGHT )  ;", "{", "JPanel   propertiesPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "rightSplit . add ( propertiesPanel ,    JSplitPane . TOP )  ;", "propertiesPanel . setBorder ( new   CompoundBorder ( BorderFactory . createEmptyBorder (  3  ,     0  ,     6  ,     6  )  ,    BorderFactory . createTitledBorder (  \" Editor   Properties \"  )  )  )  ;", "{", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "propertiesPanel . add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . NORTH ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "scroll . setBorder ( BorderFactory . createEmptyBorder (  0  ,     0  ,     0  ,     0  )  )  ;", "{", "editorPropertiesPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "scroll . setViewportView ( editorPropertiesPanel )  ;", "scroll . getVerticalScrollBar (  )  . setUnitIncrement (  7  0  )  ;", "}", "}", "}", "{", "JSplitPane   rightSplitPane    =    new   JSplitPane ( JSplitPane . VERTICAL _ SPLIT )  ;", "rightSplitPane . setUI ( new   BasicSplitPaneUI (  )     {", "public   void   paint ( Graphics   g ,    JComponent   jc )     {", "}", "}  )  ;", "rightSplitPane . setDividerSize (  4  )  ;", "rightSplitPane . setDividerLocation (  1  0  0  )  ;", "rightSplit . add ( rightSplitPane ,    JSplitPane . BOTTOM )  ;", "JPanel   propertiesPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "rightSplitPane . add ( propertiesPanel ,    JSplitPane . TOP )  ;", "propertiesPanel . setBorder ( new   CompoundBorder ( BorderFactory . createEmptyBorder (  3  ,     0  ,     6  ,     6  )  ,    BorderFactory . createTitledBorder (  \" Influencers \"  )  )  )  ;", "{", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "propertiesPanel . add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . NORTH ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "scroll . setBorder ( BorderFactory . createEmptyBorder (  0  ,     0  ,     0  ,     0  )  )  ;", "{", "JPanel   influencersPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "influencerBox    =    new   JComboBox ( new   DefaultComboBoxModel (  )  )  ;", "JButton   addInfluencerButton    =    new   JButton (  \" Add \"  )  ;", "addInfluencerButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   e )     {", ". InfluencerWrapper   wrapper    =     (  (  . InfluencerWrapper )     ( influencerBox . getSelectedItem (  )  )  )  ;", "ParticleController   controller    =    getEmitter (  )  ;", "if    ( controller    !  =    null )", "addInfluencer ( wrapper . type ,    controller )  ;", "}", "}  )  ;", "influencersPanel . add ( influencerBox ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     1  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "influencersPanel . add ( addInfluencerButton ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "scroll . setViewportView ( influencersPanel )  ;", "scroll . getVerticalScrollBar (  )  . setUnitIncrement (  7  0  )  ;", "}", "}", "propertiesPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "rightSplitPane . add ( propertiesPanel ,    JSplitPane . BOTTOM )  ;", "propertiesPanel . setBorder ( new   CompoundBorder ( BorderFactory . createEmptyBorder (  3  ,     0  ,     6  ,     6  )  ,    BorderFactory . createTitledBorder (  \" Particle   Controller   Components \"  )  )  )  ;", "{", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "propertiesPanel . add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . NORTH ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "scroll . setBorder ( BorderFactory . createEmptyBorder (  0  ,     0  ,     0  ,     0  )  )  ;", "{", "controllerPropertiesPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "scroll . setViewportView ( controllerPropertiesPanel )  ;", "scroll . getVerticalScrollBar (  )  . setUnitIncrement (  7  0  )  ;", "}", "}", "}", "rightSplit . setDividerLocation (  2  5  0  )  ;", "}", "{", "JSplitPane   leftSplit    =    new   JSplitPane ( JSplitPane . VERTICAL _ SPLIT )  ;", "leftSplit . setUI ( new   BasicSplitPaneUI (  )     {", "public   void   paint ( Graphics   g ,    JComponent   jc )     {", "}", "}  )  ;", "leftSplit . setDividerSize (  4  )  ;", "splitPane . add ( leftSplit ,    JSplitPane . LEFT )  ;", "{", "JPanel   spacer    =    new   JPanel ( new   BorderLayout (  )  )  ;", "leftSplit . add ( spacer ,    JSplitPane . TOP )  ;", "spacer . add ( lwjglCanvas . getCanvas (  )  )  ;", "spacer . setBorder ( BorderFactory . createEmptyBorder (  0  ,     0  ,     0  ,     4  )  )  ;", "}", "{", "JPanel   emittersPanel    =    new   JPanel ( new   BorderLayout (  )  )  ;", "leftSplit . add ( emittersPanel ,    JSplitPane . BOTTOM )  ;", "emittersPanel . setBorder ( new   CompoundBorder ( BorderFactory . createEmptyBorder (  0  ,     6  ,     6  ,     0  )  ,    BorderFactory . createTitledBorder (  \" Particle   Controllers \"  )  )  )  ;", "{", "effectPanel    =    new   EffectPanel ( this )  ;", "emittersPanel . add ( effectPanel )  ;", "}", "}", "leftSplit . setDividerLocation (  6  2  5  )  ;", "}", "splitPane . setDividerLocation (  5  0  0  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   controllersData . get ( emitterIndex )  . enabled ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return    ( renderer . billboardBatch . getTexture (  )  )     =  =     ( assetManager . get ( FlameMain . DEFAULT _ BILLBOARD _ PARTICLE ,    Texture . class )  )  ;", "}", "METHOD_END"], "methodName": ["isUsingDefaultTexture"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "String   resolvedPath    =    new   String ( resource )  . replaceAll (  \"  \\  \\  \\  \\  \"  ,     \"  /  \"  )  ;", "boolean   exist    =    assetManager . isLoaded ( resolvedPath ,    type )  ;", "T   oldAsset    =    null ;", "if    ( exist )     {", "oldAsset    =    assetManager . get ( resolvedPath ,    type )  ;", "for    ( int   i    =    assetManager . getReferenceCount ( resolvedPath )  ;    i    >     0  ;     -  - i )", "assetManager . unload ( resolvedPath )  ;", "}", "AssetLoader < T ,    AssetLoaderParameters < T >  >    currentLoader    =    assetManager . getLoader ( type )  ;", "if    ( loader    !  =    null )", "assetManager . setLoader ( type ,    loader )  ;", "assetManager . load ( resource ,    type ,    params )  ;", "assetManager . finishLoading (  )  ;", "T   res    =    assetManager . get ( resolvedPath )  ;", "if    ( currentLoader    !  =    null )", "assetManager . setLoader ( type ,    currentLoader )  ;", "if    ( exist )", "EventManager . get (  )  . fire (  . EVT _ ASSET _ RELOADED ,    new   Object [  ]  {    oldAsset ,    res    }  )  ;", "return   res ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "for    ( UIManager . LookAndFeelInfo   info    :    UIManager . getInstalledLookAndFeels (  )  )     {", "if    (  \" Nimbus \"  . equals ( info . getName (  )  )  )     {", "try    {", "UIManager . setLookAndFeel ( info . getClassName (  )  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "break ;", "}", "}", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "new    (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "try    {", "ParticleEffect   loadedEffect    =    load ( file . getAbsolutePath (  )  ,    ParticleEffect . class ,    null ,    new   graphics . g 3 d . particles . ParticleEffectLoader . ParticleEffectLoadParameter ( particleSystem . getBatches (  )  )  )  ;", "loadedEffect    =    loadedEffect . copy (  )  ;", "loadedEffect . init (  )  ;", "if    ( replaceCurrentWorkspace )     {", "effect    =    loadedEffect ;", "controllersData . clear (  )  ;", "particleSystem . removeAll (  )  ;", "particleSystem . add ( effect )  ;", "for    ( ParticleController   controller    :    effect . getControllers (  )  )", "controllersData . add ( new   FlameMain . ControllerData ( controller )  )  ;", "rebuildActiveControllers (  )  ;", "}", "reloadRows (  )  ;", "return   loadedEffect ;", "}    catch    ( Exception   ex )     {", "System . out . println (  (  \" Error   loading   effect :     \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "ex . printStackTrace (  )  ;", "JOptionPane . showMessageDialog ( this ,     \" Error   opening   effect .  \"  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["openEffect"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "Array < ParticleController >    effectControllers    =    effect . getControllers (  )  ;", "effectControllers . clear (  )  ;", "for    (  . ControllerData   controllerData    :    controllersData )     {", "if    ( controllerData . enabled )", "effectControllers . add ( controllerData . controller )  ;", "}", "effect . init (  )  ;", "effect . start (  )  ;", "}", "METHOD_END"], "methodName": ["rebuildActiveControllers"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "EventManager . get (  )  . clear (  )  ;", "editorPropertiesPanel . removeAll (  )  ;", "influencerBox . removeAllItems (  )  ;", "controllerPropertiesPanel . removeAll (  )  ;", "addRow ( editorPropertiesPanel ,    new   NumericPanel (  . this ,    fovValue ,     \" Field   of   View \"  ,     \"  \"  )  )  ;", "addRow ( editorPropertiesPanel ,    new   NumericPanel (  . this ,    deltaMultiplier ,     \" Delta   multiplier \"  ,     \"  \"  )  )  ;", "addRow ( editorPropertiesPanel ,    new   GradientPanel (  . this ,    backgroundColor ,     \" Background   color \"  ,     \"  \"  ,    true )  )  ;", "addRow ( editorPropertiesPanel ,    new   DrawPanel (  . this ,     \" Draw \"  ,     \"  \"  )  )  ;", "addRow ( editorPropertiesPanel ,    new   TextureLoaderPanel (  . this ,     \" Texture \"  ,     \"  \"  )  )  ;", "addRow ( editorPropertiesPanel ,    new   BillboardBatchPanel (  . this ,    renderer . billboardBatch )  ,     1  ,     1  )  ;", "editorPropertiesPanel . repaint (  )  ;", "ParticleController   controller    =    getEmitter (  )  ;", "if    ( controller    !  =    null )     {", "DefaultComboBoxModel   model    =     (  ( DefaultComboBoxModel )     ( influencerBox . getModel (  )  )  )  ;", ". ControllerType   type    =    getControllerType (  )  ;", "if    ( type    !  =    null )     {", "for    ( Object   value    :    type . wrappers )", "model . addElement ( value )  ;", "}", "JPanel   panel    =    null ;", "addRow ( controllerPropertiesPanel ,    getPanel ( controller . emitter )  )  ;", "for    ( int   i    =     0  ,    c    =    controller . influencers . size ;    i    <    c ;     +  + i )     {", "Influencer   influencer    =     (  ( Influencer )     ( controller . influencers . get ( i )  )  )  ;", "panel    =    getPanel ( influencer )  ;", "if    ( panel    !  =    null )", "addRow ( controllerPropertiesPanel ,    panel ,     1  ,     ( i    =  =     ( c    -     1  )     ?     1     :     0  )  )  ;", "}", "for    ( Component   component    :    controllerPropertiesPanel . getComponents (  )  )", "if    ( component   instanceof   EditorPanel )", "(  ( EditorPanel )     ( component )  )  . update (  . this )  ;", "}", "controllerPropertiesPanel . repaint (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["reloadRows"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "controllersData . removeIndex ( row )  . controller . dispose (  )  ;", "rebuildActiveControllers (  )  ;", "}", "METHOD_END"], "methodName": ["removeEmitter"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "effect . init (  )  ;", "effect . start (  )  ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "Writer   fileWriter    =    null ;", "try    {", "ParticleEffectLoader   loader    =     (  ( ParticleEffectLoader )     ( assetManager . getLoader ( ParticleEffect . class )  )  )  ;", "loader . save ( effect ,    new   graphics . g 3 d . particles . ParticleEffectLoader . ParticleEffectSaveParameter ( new   FileHandle ( file . getAbsolutePath (  )  )  ,    assetManager ,    particleSystem . getBatches (  )  )  )  ;", "}    catch    ( Exception   ex )     {", "System . out . println (  (  \" Error   saving   effect :     \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "ex . printStackTrace (  )  ;", "JOptionPane . showMessageDialog ( this ,     \" Error   saving   effect .  \"  )  ;", "}    finally    {", "StreamUtils . closeQuietly ( fileWriter )  ;", "}", "}", "METHOD_END"], "methodName": ["saveEffect"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "setTexture ( atlas . getTextures (  )  . first (  )  )  ;", "}", "METHOD_END"], "methodName": ["setAtlas"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "FlameMain . ControllerData   data    =    controllersData . get ( emitterIndex )  ;", "data . enabled    =    enabled ;", "rebuildActiveControllers (  )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "renderer . billboardBatch . setTexture ( texture )  ;", "renderer . pointSpriteBatch . setTexture ( texture )  ;", "}", "METHOD_END"], "methodName": ["setTexture"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "for    ( Component   component    :    controllerPropertiesPanel . getComponents (  )  )", "if    (  ( component   instanceof   EditorPanel )     &  &     (  (  ( EditorPanel )     ( component )  )  . getName (  )  . equals ( name )  )  )", "component . setVisible ( visible )  ;", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "FileDialog   dialog    =    new   FileDialog ( this ,    title ,    mode )  ;", "if    (  ( lastDir )     !  =    null )", "dialog . setDirectory ( lastDir )  ;", "dialog . setVisible ( true )  ;", "final   String   file    =    dialog . getFile (  )  ;", "final   String   dir    =    dialog . getDirectory (  )  ;", "if    (  (  ( dir    =  =    null )     |  |     ( file    =  =    null )  )     |  |     (  ( file . trim (  )  . length (  )  )     =  =     0  )  )", "return   null ;", "lastDir    =    dir ;", "return   new   File ( dir ,    file )  ;", "}", "METHOD_END"], "methodName": ["showFileDialog"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   showFileDialog (  \" Open \"  ,    FileDialog . LOAD )  ;", "}", "METHOD_END"], "methodName": ["showFileLoadDialog"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "return   showFileDialog (  \" Save \"  ,    FileDialog . SAVE )  ;", "}", "METHOD_END"], "methodName": ["showFileSaveDialog"], "fileName": "com.badlogic.gdx.tools.flame.FlameMain"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    super . getPreferredSize (  )  ;", "size . width    =     1  0  ;", "return   size ;", "}", "METHOD_END"], "methodName": ["getPreferredSize"], "fileName": "com.badlogic.gdx.tools.flame.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "super . initializeComponents (  )  ;", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "gradientEditor    =    new    . GradientEditor (  )     {", "public   void   handleSelected ( Color   color )     {", ". this . setColor ( color )  ;", "}", "}  ;", "contentPanel . add ( gradientEditor ,    new   GridBagConstraints (  0  ,     1  ,     3  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     1  0  )  )  ;", "}", "{", "hueSlider    =    new    . ColorSlider ( new   Color [  ]  {    Color . red ,    Color . yellow ,    Color . green ,    Color . cyan ,    Color . blue ,    Color . magenta ,    Color . red    }  )     {", "protected   void   colorPicked (  )     {", "saturationSlider . setColors ( new   Color [  ]  {    new   Color ( Color . HSBtoRGB ( getPercentage (  )  ,     1  ,     1  )  )  ,    Color . white    }  )  ;", "updateColor (  )  ;", "}", "}  ;", "contentPanel . add ( hueSlider ,    new   GridBagConstraints (  1  ,     2  ,     2  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "saturationSlider    =    new    . ColorSlider ( new   Color [  ]  {    Color . red ,    Color . white    }  )     {", "protected   void   colorPicked (  )     {", "updateColor (  )  ;", "}", "}  ;", "contentPanel . add ( saturationSlider ,    new   GridBagConstraints (  1  ,     3  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "lightnessSlider    =    new    . ColorSlider ( new   Color [  0  ]  )     {", "protected   void   colorPicked (  )     {", "updateColor (  )  ;", "}", "}  ;", "contentPanel . add ( lightnessSlider ,    new   GridBagConstraints (  2  ,     3  ,     1  ,     1  ,     1  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "colorPanel    =    new   JPanel (  )     {", "public   Dimension   getPreferredSize (  )     {", "Dimension   size    =    super . getPreferredSize (  )  ;", "size . width    =     5  2  ;", "return   size ;", "}", "}  ;", "contentPanel . add ( colorPanel ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     2  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  3  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "colorPanel . addMouseListener ( new   MouseAdapter (  )     {", "public   void   mouseClicked ( MouseEvent   e )     {", "Color   color    =    JColorChooser . showDialog ( colorPanel ,     \" Set   Color \"  ,    colorPanel . getBackground (  )  )  ;", "if    ( color    !  =    null )", "setColor ( color )  ;", "}", "}  )  ;", "colorPanel . setBorder ( BorderFactory . createMatteBorder (  1  ,     1  ,     1  ,     1  ,    Color . black )  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "float [  ]    hsb    =    Color . RGBtoHSB ( color . getRed (  )  ,    color . getGreen (  )  ,    color . getBlue (  )  ,    null )  ;", "hueSlider . setPercentage ( hsb [  0  ]  )  ;", "saturationSlider . setPercentage (  (  1     -     ( hsb [  1  ]  )  )  )  ;", "lightnessSlider . setPercentage (  (  1     -     ( hsb [  2  ]  )  )  )  ;", "color . setBackground ( color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tools.flame.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "Color   color    =    new   Color ( Color . HSBtoRGB ( hueSlider . getPercentage (  )  ,     (  1     -     ( saturationSlider . getPercentage (  )  )  )  ,     1  )  )  ;", "lightnessSlider . setColors ( new   Color [  ]  {    color ,    Color . black    }  )  ;", "color    =    new   Color ( Color . HSBtoRGB ( hueSlider . getPercentage (  )  ,     (  1     -     ( saturationSlider . getPercentage (  )  )  )  ,     (  1     -     ( lightnessSlider . getPercentage (  )  )  )  )  )  ;", "colorPanel . setBackground ( color )  ;", "gEditor . setColor ( color )  ;", "float [  ]    colors    =    new   float [  ( gEditor . colors . size (  )  )     *     3  ]  ;", "int   i    =     0  ;", "for    ( Color   c    :    gEditor . colors )     {", "colors [  ( i +  +  )  ]     =     ( c . getRed (  )  )     /     2  5  5  .  0 F ;", "colors [  ( i +  +  )  ]     =     ( c . getGreen (  )  )     /     2  5  5  .  0 F ;", "colors [  ( i +  +  )  ]     =     ( c . getBlue (  )  )     /     2  5  5  .  0 F ;", "}", "float [  ]    percentages    =    new   float [ gEditor . percentages . size (  )  ]  ;", "i    =     0  ;", "for    ( Float   percent    :    gEditor . percentages )", "percentages [  ( i +  +  )  ]     =    percent ;", "value . setColors ( colors )  ;", "value . setTimeline ( percentages )  ;", "}", "METHOD_END"], "methodName": ["updateColor"], "fileName": "com.badlogic.gdx.tools.flame.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "this . image    =    image ;", "}", "METHOD_END"], "methodName": ["setImage"], "fileName": "com.badlogic.gdx.tools.flame.ImagePanel"}, {"methodBody": ["METHOD_START", "{", "try    {", "image    =    IO . read ( new   File ( file )  )  ;", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setImage"], "fileName": "com.badlogic.gdx.tools.flame.ImagePanel"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    listener ;", "}", "METHOD_END"], "methodName": ["setListener"], "fileName": "com.badlogic.gdx.tools.flame.LoaderButton"}, {"methodBody": ["METHOD_START", "{", "super . initializeComponents (  )  ;", "pick    =    new   TemplatePick < Model >  ( editor ,    null ,    this ,    Model . class ,    new   LoaderButton . ModelLoaderButton ( editor )  )  ;", "pick . setIsAlwayShown ( true )  ;", "contentPanel . add ( pick ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.ModelInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "super . initializeComponents (  )  ;", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "JLabel   label    =    new   JLabel (  \" Value :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "valueSpinner    =    new   JSpinner ( new   SpinnerNumberModel ( new   Float (  0  )  ,    new   Float (  (  -  9  9  9  9  9  )  )  ,    new   Float (  9  9  9  9  9  )  ,    new   Float (  0  .  1 F )  )  )  ;", "contentPanel . add ( valueSpinner ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "valueSpinner . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", ". this . value . setValue (  (  ( Float )     ( valueSpinner . getValue (  )  )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.NumericPanel"}, {"methodBody": ["METHOD_START", "{", "Array < ParticleEffect >    effects    =    new   Array < ParticleEffect >  (  )  ;", "Array <  >    controllers    =    new   Array <  >  (  )  ;", "editor . assetManager . getAll ( ParticleEffect . class ,    effects )  ;", "for    ( ParticleEffect   effect    :    effects )     {", "controllers . addAll ( effect . getControllers (  )  )  ;", "}", "controllerPicker . setLoadedTemplates ( controllers )  ;", "}", "METHOD_END"], "methodName": ["reloadControllers"], "fileName": "com.badlogic.gdx.tools.flame.ParticleControllerInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "super . setHasAdvanced ( hasAdvanced )  ;", "advancedButton . setVisible (  ( hasAdvanced    &  &     (  ( v . isActive (  )  )     |  |     ( isAlwaysActive )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setHasAdvanced"], "fileName": "com.badlogic.gdx.tools.flame.ParticleValuePanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "chart    =    new   Chart ( chartTitle )     {", "public   void   pointsChanged (  )     {", "value . setTimeline ( chart . getValuesX (  )  )  ;", "value . setScaling ( chart . getValuesY (  )  )  ;", "}", "}  ;", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     6  2  )  )  ;", "contentPanel . add ( chart ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "expandButton    =    new   JButton (  \"  +  \"  )  ;", "expandButton . setBorder ( BorderFactory . createEmptyBorder (  4  ,     1  0  ,     4  ,     1  0  )  )  ;", "contentPanel . add ( expandButton ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "expandButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "chart . setExpanded (  (  !  ( chart . isExpanded (  )  )  )  )  ;", "boolean   expanded    =    chart . isExpanded (  )  ;", "GridBagLayout   layout    =     (  ( GridBagLayout )     ( getContentPanel (  )  . getLayout (  )  )  )  ;", "GridBagConstraints   chartConstraints    =    layout . getConstraints ( chart )  ;", "GridBagConstraints   expandButtonConstraints    =    layout . getConstraints ( expandButton )  ;", "if    ( expanded )     {", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     2  0  0  )  )  ;", "expandButton . setText (  \"  -  \"  )  ;", "chartConstraints . weightx    =     1  ;", "expandButtonConstraints . weightx    =     0  ;", "} else    {", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     6  2  )  )  ;", "expandButton . setText (  \"  +  \"  )  ;", "chartConstraints . weightx    =     0  ;", "expandButtonConstraints . weightx    =     1  ;", "}", "layout . setConstraints ( chart ,    chartConstraints )  ;", "layout . setConstraints ( expandButton ,    expandButtonConstraints )  ;", "chart . revalidate (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.PercentagePanel"}, {"methodBody": ["METHOD_START", "{", "try    {", "BufferedImage   outImage    =    new   BufferedImage ( image . getWidth (  )  ,    image . getHeight (  )  ,    BufferedImage . TYPE _ INT _ ARGB )  ;", "float [  ]    color    =    new   float [  4  ]  ;", "WritableRaster   raster    =    image . getRaster (  )  ;", "WritableRaster   outRaster    =    outImage . getRaster (  )  ;", "for    ( int   x    =     0  ,    w    =    image . getWidth (  )  ;    x    <    w ;     +  + x )", "for    ( int   y    =     0  ,    h    =    image . getHeight (  )  ;    y    <    h ;     +  + y )     {", "raster . getPixel ( x ,    y ,    color )  ;", "float   a    =     ( color [  3  ]  )     /     2  5  5  .  0 F ;", "for    ( int   i    =     0  ;    i    <     3  ;     +  + i )", "color [ i ]     *  =    a ;", "outRaster . setPixel ( x ,    y ,    color )  ;", "}", "ImageIO . write ( outImage ,     \" png \"  ,    out )  ;", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "METHOD_END"], "methodName": ["generatePremultiplyAlpha"], "fileName": "com.badlogic.gdx.tools.flame.PreAlpha"}, {"methodBody": ["METHOD_START", "{", "JMenuBar   menuBar    =    new   JMenuBar (  )  ;", "JMenu   menu    =    new   JMenu (  \" File \"  )  ;", "menuBar . add ( menu )  ;", "JMenuItem   menuItem    =    new   JMenuItem (  \" Open \"  )  ;", "menuItem . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "open (  )  ;", "}", "}  )  ;", "menu . add ( menuItem )  ;", "menuItem    =    new   JMenuItem (  \" Save \"  )  ;", "menuItem . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "save (  )  ;", "}", "}  )  ;", "menu . add ( menuItem )  ;", "setJMenuBar ( menuBar )  ;", "imagePanel    =    new   ImagePanel (  )  ;", "getContentPane (  )  . add ( imagePanel )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.PreAlpha"}, {"methodBody": ["METHOD_START", "{", "for    ( UIManager . LookAndFeelInfo   info    :    UIManager . getInstalledLookAndFeels (  )  )     {", "if    (  \" Nimbus \"  . equals ( info . getName (  )  )  )     {", "try    {", "UIManager . setLookAndFeel ( info . getClassName (  )  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "break ;", "}", "}", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "new    (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.flame.PreAlpha"}, {"methodBody": ["METHOD_START", "{", "FileDialog   dialog    =    new   FileDialog ( this ,     \" Open   Image \"  ,    FileDialog . LOAD )  ;", "if    (  ( lastDir )     !  =    null )", "dialog . setDirectory ( lastDir )  ;", "dialog . setVisible ( true )  ;", "final   String   file    =    dialog . getFile (  )  ;", "final   String   dir    =    dialog . getDirectory (  )  ;", "if    (  (  ( dir    =  =    null )     |  |     ( file    =  =    null )  )     |  |     (  ( file . trim (  )  . length (  )  )     =  =     0  )  )", "return ;", "lastDir    =    dir ;", "try    {", "image    =    ImageIO . read ( new   File ( dir ,    file )  )  ;", "imagePanel . setImage ( image )  ;", "imagePanel . revalidate (  )  ;", "imagePanel . repaint (  )  ;", "pack (  )  ;", "}    catch    ( Exception   ex )     {", "JOptionPane . showMessageDialog ( this ,     \" Error   opening   image .  \"  )  ;", "return ;", "}", "}", "METHOD_END"], "methodName": ["open"], "fileName": "com.badlogic.gdx.tools.flame.PreAlpha"}, {"methodBody": ["METHOD_START", "{", "FileDialog   dialog    =    new   FileDialog ( this ,     \" Save   Image \"  ,    FileDialog . SAVE )  ;", "if    (  ( lastDir )     !  =    null )", "dialog . setDirectory ( lastDir )  ;", "dialog . setVisible ( true )  ;", "final   String   file    =    dialog . getFile (  )  ;", "final   String   dir    =    dialog . getDirectory (  )  ;", "if    (  (  ( dir    =  =    null )     |  |     ( file    =  =    null )  )     |  |     (  ( file . trim (  )  . length (  )  )     =  =     0  )  )", "return ;", "lastDir    =    dir ;", "try    {", "generatePremultiply ( new   File ( dir ,    file )  )  ;", "JOptionPane . showMessageDialog ( this ,     \" Conversion   complete !  \"  )  ;", "}    catch    ( Exception   ex )     {", "JOptionPane . showMessageDialog ( this ,     \" Error   saving   image .  \"  )  ;", "return ;", "}", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.tools.flame.PreAlpha"}, {"methodBody": ["METHOD_START", "{", "super . setValue ( value )  ;", "if    ( value    =  =    null )", "return ;", "Editor . setValue ( minSlider ,    value . getLowMin (  )  )  ;", "Editor . setValue ( maxSlider ,    value . getLowMax (  )  )  ;", "if    (  ( minSlider . getValue (  )  )     =  =     ( maxSlider . getValue (  )  )  )", "rangeButton . doClick (  0  )  ;", "else", "if    (  !  ( maxSlider . isVisible (  )  )  )", "maxSlider . setVisible ( true )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.flame.RangedNumericPanel"}, {"methodBody": ["METHOD_START", "{", "texturePanel . clear (  )  ;", "Texture   texture    =    texturePanel . getTexture (  )  ;", "int   rows    =     (  ( int )     ( rowSlider . getValue (  )  )  )  ;", "int   columns    =     (  ( int )     ( columnSlider . getValue (  )  )  )  ;", "int   yOffset    =     ( texture . getHeight (  )  )     /    rows ;", "int   xOffset    =     ( texture . getWidth (  )  )     /    columns ;", "if    ( mode    =  =     (  . GenerationMode . ByRows )  )     {", "for    ( int   j    =     0  ;    j    <    rows ;     +  + j )     {", "int   rowOffset    =    j    *    yOffset ;", "for    ( int   i    =     0  ;    i    <    columns ;     +  + i )     {", "texturePanel . unselectedRegions . add ( new   com . badlogic . gdx . graphics . g 2 d . TextureRegion ( texture ,     ( i    *    xOffset )  ,    rowOffset ,    xOffset ,    yOffset )  )  ;", "}", "}", "} else", "if    ( mode    =  =     (  . GenerationMode . ByColumns )  )     {", "for    ( int   i    =     0  ;    i    <    columns ;     +  + i )     {", "int   columnOffset    =    i    *    xOffset ;", "for    ( int   j    =     0  ;    j    <    rows ;     +  + j )     {", "texturePanel . unselectedRegions . add ( new   com . badlogic . gdx . graphics . g 2 d . TextureRegion ( texture ,    columnOffset ,     ( j    *    yOffset )  ,    xOffset ,    yOffset )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["generateRegions"], "fileName": "com.badlogic.gdx.tools.flame.RegionPickerPanel"}, {"methodBody": ["METHOD_START", "{", "setLayout ( new   GridBagLayout (  )  )  ;", "content    =    new   JPanel (  )  ;", "atlasPanel    =    new   TextureAtlasPanel (  )  ;", "texturePanel    =    new   TexturePanel (  )  ;", "CustomCardLayout   cardLayout    =    new   CustomCardLayout (  )  ;", "content . setLayout ( cardLayout )  ;", "content . add ( atlasPanel ,     \" atlas \"  )  ;", "content . add ( texturePanel ,     \" texture \"  )  ;", "add ( content ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "JPanel   controls    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "controls . add (  ( selectButton    =    new   JButton (  \" Select \"  )  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "controls . add ( new   JSeparator ( JSeparator . HORIZONTAL )  ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "JPanel   pickPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "pickPanel . add (  ( selectAllButton    =    new   JButton (  \" Pick   All \"  )  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "pickPanel . add (  ( clearButton    =    new   JButton (  \" Clear   Selection \"  )  )  ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "pickPanel . add (  ( reverseButton    =    new   JButton (  \" Reverse   Selection \"  )  )  ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "controls . add ( pickPanel ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "generationPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "generationPanel . add ( new   JLabel (  \" Rows \"  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "generationPanel . add (  ( rowSlider    =    new   Slider (  1  ,     1  ,     9  9  9  9  ,     1  )  )  ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "generationPanel . add ( new   JLabel (  \" Columns \"  )  ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "generationPanel . add (  ( columnSlider    =    new   Slider (  1  ,     1  ,     9  9  9  9  ,     1  )  )  ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "generationPanel . add (  ( generateBox    =    new   JComboBox ( new   DefaultComboBoxModel (  . GenerationMode . values (  )  )  )  )  ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "generationPanel . add (  ( generateButton    =    new   JButton (  \" Generate \"  )  )  ,    new   GridBagConstraints (  1  ,     2  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "controls . add ( new   JSeparator ( JSeparator . HORIZONTAL )  ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "controls . add ( generationPanel ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "add ( controls ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "selectButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "JPanel   panel    =     (  ( CustomCardLayout )     ( content . getLayout (  )  )  )  . getCurrentCard ( content )  ;", "TexturePanel   currentTexturePanel    =     ( panel    =  =     ( atlasPanel )  )     ?    atlasPanel . getCurrentRegionPanel (  )     :    texturePanel ;", "listener . onRegionsSelected ( currentTexturePanel . selectedRegions )  ;", "}", "}  )  ;", "selectAllButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "JPanel   panel    =     (  ( CustomCardLayout )     ( content . getLayout (  )  )  )  . getCurrentCard ( content )  ;", "TexturePanel   currentTexturePanel    =     ( panel    =  =     ( atlasPanel )  )     ?    atlasPanel . getCurrentRegionPanel (  )     :    texturePanel ;", "currentTexturePanel . selectAll (  )  ;", "}", "}  )  ;", "reverseButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "JPanel   panel    =     (  ( CustomCardLayout )     ( content . getLayout (  )  )  )  . getCurrentCard ( content )  ;", "TexturePanel   currentTexturePanel    =     ( panel    =  =     ( atlasPanel )  )     ?    atlasPanel . getCurrentRegionPanel (  )     :    texturePanel ;", "currentTexturePanel . selectedRegions . reverse (  )  ;", "currentTexturePanel . revalidate (  )  ;", "currentTexturePanel . repaint (  )  ;", "}", "}  )  ;", "clearButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "JPanel   panel    =     (  ( CustomCardLayout )     ( content . getLayout (  )  )  )  . getCurrentCard ( content )  ;", "TexturePanel   currentPanel    =     ( panel    =  =     ( atlasPanel )  )     ?    atlasPanel . getCurrentRegionPanel (  )     :    texturePanel ;", "currentPanel . clearSelection (  )  ;", "}", "}  )  ;", "generateButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "generateRegions (  (  (  . GenerationMode )     ( generateBox . getSelectedItem (  )  )  )  )  ;", "texturePanel . revalidate (  )  ;", "texturePanel . repaint (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.RegionPickerPanel"}, {"methodBody": ["METHOD_START", "{", "atlasPanel . clearSelection (  )  ;", "atlasPanel . setAtlas ( atlas )  ;", "CustomCardLayout   cardLayout    =     (  ( CustomCardLayout )     ( content . getLayout (  )  )  )  ;", "cardLayout . show ( content ,     \" atlas \"  )  ;", "showGenerationPanel ( false )  ;", "content . revalidate (  )  ;", "content . repaint (  )  ;", "revalidate (  )  ;", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setAtlas"], "fileName": "com.badlogic.gdx.tools.flame.RegionPickerPanel"}, {"methodBody": ["METHOD_START", "{", "texturePanel . clearSelection (  )  ;", "texturePanel . setTexture ( texture )  ;", "CustomCardLayout   cardLayout    =     (  ( CustomCardLayout )     ( content . getLayout (  )  )  )  ;", "cardLayout . show ( content ,     \" texture \"  )  ;", "showGenerationPanel ( true )  ;", "content . revalidate (  )  ;", "content . repaint (  )  ;", "revalidate (  )  ;", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setTexture"], "fileName": "com.badlogic.gdx.tools.flame.RegionPickerPanel"}, {"methodBody": ["METHOD_START", "{", "generationPanel . setVisible ( isShown )  ;", "}", "METHOD_END"], "methodName": ["showGenerationPanel"], "fileName": "com.badlogic.gdx.tools.flame.RegionPickerPanel"}, {"methodBody": ["METHOD_START", "{", "continuousCheckbox    =    new   JCheckBox (  \" Continuous \"  )  ;", "continuousCheckbox . setSelected ( emitter . isContinuous (  )  )  ;", "continuousCheckbox . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "emitter    =     (  (  )     ( editor . getEmitter (  )  . emitter )  )  ;", "emitter . setContinuous ( continuousCheckbox . isSelected (  )  )  ;", "}", "}  )  ;", "continuousCheckbox . setHorizontalTextPosition ( SwingConstants . LEFT )  ;", "int   i    =     0  ;", "addContent (  ( i +  +  )  ,     0  ,    continuousCheckbox ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( countPanel    =    new   CountPanel ( editor ,     \" Count \"  ,     \" Min   number   of   particles   at   all   times ,    max   number   of   particles   allowed .  \"  ,    emitter . minParticleCount ,    emitter . maxParticleCount )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( delayPanel    =    new   RangedNumericPanel ( editor ,    emitter . getDelay (  )  ,     \" Delay \"  ,     \" Time   from   beginning   of   effect   to   emission   start ,    in   milliseconds .  \"  ,    false )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( durationPanel    =    new   RangedNumericPanel ( editor ,    emitter . getDuration (  )  ,     \" Duration \"  ,     \" Time   particles   will   be   emitted ,    in   milliseconds .  \"  )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( emissionPanel    =    new   ScaledNumericPanel ( editor ,    emitter . getEmission (  )  ,     \" Duration \"  ,     \" Emission \"  ,     \" Number   of   particles   emitted   per   second .  \"  )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( lifePanel    =    new   ScaledNumericPanel ( editor ,    emitter . getLife (  )  ,     \" Duration \"  ,     \" Life \"  ,     \" Time   particles   will   live ,    in   milliseconds .  \"  )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( lifeOffsetPanel    =    new   ScaledNumericPanel ( editor ,    emitter . getLifeOffset (  )  ,     \" Duration \"  ,     \" Life   Offset \"  ,     \" Particle   starting   life   consumed ,    in   milliseconds .  \"  ,    false )  )  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.RegularEmitterPanel"}, {"methodBody": ["METHOD_START", "{", "return   chart ;", "}", "METHOD_END"], "methodName": ["getChart"], "fileName": "com.badlogic.gdx.tools.flame.ScaledNumericPanel"}, {"methodBody": ["METHOD_START", "{", "return   formPanel ;", "}", "METHOD_END"], "methodName": ["getFormPanel"], "fileName": "com.badlogic.gdx.tools.flame.ScaledNumericPanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "formPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "contentPanel . add ( formPanel ,    new   GridBagConstraints (  5  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "{", "JLabel   label    =    new   JLabel (  \" High :  \"  )  ;", "formPanel . add ( label ,    new   GridBagConstraints (  2  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "highMinSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  9  )  ,     9  9  9  9  9  9  ,     1  .  0 F )  ;", "formPanel . add ( highMinSlider ,    new   GridBagConstraints (  3  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "highMaxSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  9  )  ,     9  9  9  9  9  9  ,     1  .  0 F )  ;", "formPanel . add ( highMaxSlider ,    new   GridBagConstraints (  4  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "highRangeButton    =    new   JButton (  \"  <  \"  )  ;", "highRangeButton . setBorder ( BorderFactory . createEmptyBorder (  6  ,     6  ,     6  ,     6  )  )  ;", "formPanel . add ( highRangeButton ,    new   GridBagConstraints (  5  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Low :  \"  )  ;", "formPanel . add ( label ,    new   GridBagConstraints (  2  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "lowMinSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  9  )  ,     9  9  9  9  9  9  ,     1  .  0 F )  ;", "formPanel . add ( lowMinSlider ,    new   GridBagConstraints (  3  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "lowMaxSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  9  )  ,     9  9  9  9  9  9  ,     1  .  0 F )  ;", "formPanel . add ( lowMaxSlider ,    new   GridBagConstraints (  4  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "lowRangeButton    =    new   JButton (  \"  <  \"  )  ;", "lowRangeButton . setBorder ( BorderFactory . createEmptyBorder (  6  ,     6  ,     6  ,     6  )  )  ;", "formPanel . add ( lowRangeButton ,    new   GridBagConstraints (  5  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "chart    =    new   Chart ( chartTitle )     {", "public   void   pointsChanged (  )     {", "value . setTimeline ( chart . getValuesX (  )  )  ;", "value . setScaling ( chart . getValuesY (  )  )  ;", "}", "}  ;", "contentPanel . add ( chart ,    new   GridBagConstraints (  6  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     3  0  )  )  ;", "}", "{", "expandButton    =    new   JButton (  \"  +  \"  )  ;", "contentPanel . add ( expandButton ,    new   GridBagConstraints (  7  ,     5  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . SOUTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "expandButton . setBorder ( BorderFactory . createEmptyBorder (  4  ,     8  ,     4  ,     8  )  )  ;", "}", "{", "relativeCheckBox    =    new   JCheckBox (  \" Relative \"  )  ;", "contentPanel . add ( relativeCheckBox ,    new   GridBagConstraints (  7  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "lowMinSlider . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", ". this . value . setLowMin ( lowMinSlider . getValue (  )  )  ;", "if    (  !  ( lowMaxSlider . isVisible (  )  )  )", ". this . value . setLowMax ( lowMinSlider . getValue (  )  )  ;", "}", "}  )  ;", "lowMaxSlider . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", ". this . value . setLowMax ( lowMaxSlider . getValue (  )  )  ;", "}", "}  )  ;", "highMinSlider . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", ". this . value . setHighMin ( highMinSlider . getValue (  )  )  ;", "if    (  !  ( highMaxSlider . isVisible (  )  )  )", ". this . value . setHighMax ( highMinSlider . getValue (  )  )  ;", "}", "}  )  ;", "highMaxSlider . addChangeListener ( new   ChangeListener (  )     {", "public   void   stateChanged ( ChangeEvent   event )     {", ". this . value . setHighMax ( highMaxSlider . getValue (  )  )  ;", "}", "}  )  ;", "relativeCheckBox . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", ". this . value . setRelative ( relativeCheckBox . isSelected (  )  )  ;", "}", "}  )  ;", "lowRangeButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "boolean   visible    =     !  ( lowMaxSlider . isVisible (  )  )  ;", "lowMaxSlider . setVisible ( visible )  ;", "lowRangeButton . setText (  ( visible    ?     \"  <  \"     :     \"  >  \"  )  )  ;", "GridBagLayout   layout    =     (  ( GridBagLayout )     ( formPanel . getLayout (  )  )  )  ;", "GridBagConstraints   constraints    =    layout . getConstraints ( lowRangeButton )  ;", "constraints . gridx    =     ( visible )     ?     5     :     4  ;", "layout . setConstraints ( lowRangeButton ,    constraints )  ;", "Slider   slider    =     ( visible )     ?    lowMaxSlider    :    lowMinSlider ;", ". this . value . setLowMax ( slider . getValue (  )  )  ;", "}", "}  )  ;", "highRangeButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "boolean   visible    =     !  ( highMaxSlider . isVisible (  )  )  ;", "highMaxSlider . setVisible ( visible )  ;", "highRangeButton . setText (  ( visible    ?     \"  <  \"     :     \"  >  \"  )  )  ;", "GridBagLayout   layout    =     (  ( GridBagLayout )     ( formPanel . getLayout (  )  )  )  ;", "GridBagConstraints   constraints    =    layout . getConstraints ( highRangeButton )  ;", "constraints . gridx    =     ( visible )     ?     5     :     4  ;", "layout . setConstraints ( highRangeButton ,    constraints )  ;", "Slider   slider    =     ( visible )     ?    highMaxSlider    :    highMinSlider ;", ". this . value . setHighMax ( slider . getValue (  )  )  ;", "}", "}  )  ;", "expandButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "chart . setExpanded (  (  !  ( chart . isExpanded (  )  )  )  )  ;", "boolean   expanded    =    chart . isExpanded (  )  ;", "GridBagLayout   layout    =     (  ( GridBagLayout )     ( getContentPanel (  )  . getLayout (  )  )  )  ;", "GridBagConstraints   chartConstraints    =    layout . getConstraints ( chart )  ;", "GridBagConstraints   expandButtonConstraints    =    layout . getConstraints ( expandButton )  ;", "if    ( expanded )     {", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     2  0  0  )  )  ;", "expandButton . setText (  \"  -  \"  )  ;", "chartConstraints . weightx    =     1  ;", "expandButtonConstraints . weightx    =     0  ;", "} else    {", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     3  0  )  )  ;", "expandButton . setText (  \"  +  \"  )  ;", "chartConstraints . weightx    =     0  ;", "expandButtonConstraints . weightx    =     1  ;", "}", "layout . setConstraints ( chart ,    chartConstraints )  ;", "layout . setConstraints ( expandButton ,    expandButtonConstraints )  ;", "relativeCheckBox . setVisible (  (  ! expanded )  )  ;", "formPanel . setVisible (  (  ! expanded )  )  ;", "chart . revalidate (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.ScaledNumericPanel"}, {"methodBody": ["METHOD_START", "{", "spinner . addChangeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addChangeListener"], "fileName": "com.badlogic.gdx.tools.flame.Slider"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    super . getPreferredSize (  )  ;", "size . width    =     7  5  ;", "size . height    =     2  6  ;", "return   size ;", "}", "METHOD_END"], "methodName": ["getPreferredSize"], "fileName": "com.badlogic.gdx.tools.flame.Slider"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Double )     ( spinner . getValue (  )  )  )  . floatValue (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.tools.flame.Slider"}, {"methodBody": ["METHOD_START", "{", "spinner . setValue (  (  ( double )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.flame.Slider"}, {"methodBody": ["METHOD_START", "{", "super . initializeComponents (  )  ;", "pointSpawnShapeValue    =    new   PointSpawnShapeValue (  )  ;", "lineSpawnShapeValue    =    new   LineSpawnShapeValue (  )  ;", "rectangleSpawnShapeValue    =    new   RectangleSpawnShapeValue (  )  ;", "ellipseSpawnShapeValue    =    new   EllipseSpawnShapeValue (  )  ;", "cylinderSpawnShapeValue    =    new   CylinderSpawnShapeValue (  )  ;", "meshSpawnShapeValue    =    new   UnweightedMeshSpawnShapeValue (  )  ;", "weightMeshSpawnShapeValue    =    new   WeightMeshSpawnShapeValue (  )  ;", "lineSpawnShapeValue . setDimensions (  6  ,     6  ,     6  )  ;", "rectangleSpawnShapeValue . setDimensions (  6  ,     6  ,     6  )  ;", "ellipseSpawnShapeValue . setDimensions (  6  ,     6  ,     6  )  ;", "cylinderSpawnShapeValue . setDimensions (  6  ,     6  ,     6  )  ;", "pointSpawnShapeValue . setActive ( true )  ;", "lineSpawnShapeValue . setActive ( true )  ;", "rectangleSpawnShapeValue . setActive ( true )  ;", "ellipseSpawnShapeValue . setActive ( true )  ;", "cylinderSpawnShapeValue . setActive ( true )  ;", "meshSpawnShapeValue . setActive ( true )  ;", "weightMeshSpawnShapeValue . setActive ( true )  ;", "Model   defaultModel    =    editor . assetManager . get ( FlameMain . DEFAULT _ MODEL _ PARTICLE )  ;", "Array < Model >    models    =    new   Array < Model >  (  )  ;", "models . add ( defaultModel )  ;", "int   i    =     0  ;", "JPanel   panel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "EditorPanel . addContent ( panel ,    i ,     0  ,    new   JLabel (  \" Shape \"  )  ,    false ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,     0  ,     0  )  ;", "EditorPanel . addContent ( panel ,     ( i +  +  )  ,     1  ,     ( shapeCombo    =    new   JComboBox ( new   DefaultComboBoxModel (  . spawnShapes )  )  )  ,    false ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,     1  ,     0  )  ;", "EditorPanel . addContent ( panel ,    i ,     0  ,     ( edgesLabel    =    new   JLabel (  \" Edges \"  )  )  ,    false ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,     0  ,     0  )  ;", "EditorPanel . addContent ( panel ,     ( i +  +  )  ,     1  ,     ( edgesCheckbox    =    new   JCheckBox (  )  )  ,    false ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,     0  ,     0  )  ;", "EditorPanel . addContent ( panel ,    i ,     0  ,     ( sideLabel    =    new   JLabel (  \" Side \"  )  )  ,    false ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,     0  ,     0  )  ;", "EditorPanel . addContent ( panel ,     ( i +  +  )  ,     1  ,     ( sideCombo    =    new   JComboBox ( new   DefaultComboBoxModel ( SpawnSide . values (  )  )  )  )  ,    false ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,     1  ,     0  )  ;", "edgesCheckbox . setHorizontalTextPosition ( SwingConstants . LEFT )  ;", "i    =     0  ;", "addContent (  ( i +  +  )  ,     0  ,    panel ,    GridBagConstraints . WEST ,    GridBagConstraints . HORIZONTAL )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( meshPanel    =    new   TemplatePickerPanel < Model >  ( editor ,    models ,    this ,    Model . class ,    new   LoaderButton . ModelLoaderButton ( editor )  ,    true ,    false )  )  ,    false ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( xPanel    =    new   RangedNumericPanel ( editor ,    pointSpawnShapeValue . xOffsetValue ,     \" X   Offset \"  ,     \" Amount   to   offset   a   particle ' s   starting   X   location ,    in   world   units .  \"  ,    false )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( yPanel    =    new   RangedNumericPanel ( editor ,    pointSpawnShapeValue . yOffsetValue ,     \" Y   Offset \"  ,     \" Amount   to   offset   a   particle ' s   starting   Y   location ,    in   world   units .  \"  ,    false )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( zPanel    =    new   RangedNumericPanel ( editor ,    pointSpawnShapeValue . zOffsetValue ,     \" Z   Offset \"  ,     \" Amount   to   offset   a   particle ' s   starting   Z   location ,    in   world   units .  \"  ,    false )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( widthPanel    =    new   ScaledNumericPanel ( editor ,    pointSpawnShapeValue . getSpawnWidth (  )  ,     \" Duration \"  ,     \" Spawn   Width \"  ,     \" Width   of   the   spawn   shape ,    in   world   units .  \"  ,    true )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( heightPanel    =    new   ScaledNumericPanel ( editor ,    pointSpawnShapeValue . getSpawnWidth (  )  ,     \" Duration \"  ,     \" Spawn   Height \"  ,     \" Height   of   the   spawn   shape ,    in   world   units .  \"  ,    true )  )  )  ;", "addContent (  ( i +  +  )  ,     0  ,     ( depthPanel    =    new   ScaledNumericPanel ( editor ,    pointSpawnShapeValue . getSpawnWidth (  )  ,     \" Duration \"  ,     \" Spawn   Depth \"  ,     \" Depth   of   the   spawn   shape ,    in   world   units .  \"  ,    true )  )  ,    false )  ;", "meshPanel . setIsAlwayShown ( true )  ;", "onTemplateChecked ( defaultModel ,    true )  ;", "shapeCombo . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "String   shape    =     (  ( String )     ( shapeCombo . getSelectedItem (  )  )  )  ;", "if    ( shape    =  =     (  . SPAWN _ SHAPE _ POINT )  )     {", "setPrimitiveSpawnShape ( pointSpawnShapeValue ,    false ,    null )  ;", "} else", "if    ( shape    =  =     (  . SPAWN _ SHAPE _ LINE )  )     {", "setPrimitiveSpawnShape ( lineSpawnShapeValue ,    false ,    null )  ;", "} else", "if    ( shape    =  =     (  . SPAWN _ SHAPE _ RECTANGLE )  )     {", "setPrimitiveSpawnShape ( rectangleSpawnShapeValue ,    true ,    null )  ;", "} else", "if    ( shape    =  =     (  . SPAWN _ SHAPE _ ELLIPSE )  )     {", "setPrimitiveSpawnShape ( ellipseSpawnShapeValue ,    true ,    ellipseSpawnShapeValue . getSide (  )  )  ;", "} else", "if    ( shape    =  =     (  . SPAWN _ SHAPE _ CYLINDER )  )     {", "setPrimitiveSpawnShape ( cylinderSpawnShapeValue ,    true ,    null )  ;", "} else", "if    ( shape    =  =     (  . SPAWN _ SHAPE _ MESH )  )     {", "setMeshSpawnShape ( meshSpawnShapeValue )  ;", "} else", "if    ( shape    =  =     (  . SPAWN _ SHAPE _ WEIGHT _ MESH )  )     {", "setMeshSpawnShape ( weightMeshSpawnShapeValue )  ;", "}", "editor . restart (  )  ;", "}", "}  )  ;", "edgesCheckbox . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "SpawnInfluencer   influencer    =     (  ( SpawnInfluencer )     ( editor . getEmitter (  )  . findInfluencer ( SpawnInfluencer . class )  )  )  ;", "PrimitiveSpawnShapeValue   shapeValue    =     (  ( PrimitiveSpawnShapeValue )     ( influencer . spawnShapeValue )  )  ;", "shapeValue . setEdges ( edgesCheckbox . isSelected (  )  )  ;", "setEdgesVisible ( true )  ;", "}", "}  )  ;", "sideCombo . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "SpawnSide   side    =     (  ( SpawnSide )     ( sideCombo . getSelectedItem (  )  )  )  ;", "SpawnInfluencer   influencer    =     (  ( SpawnInfluencer )     ( editor . getEmitter (  )  . findInfluencer ( SpawnInfluencer . class )  )  )  ;", "EllipseSpawnShapeValue   shapeValue    =     (  ( EllipseSpawnShapeValue )     ( influencer . spawnShapeValue )  )  ;", "shapeValue . setSide ( side )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "SpawnShapeValue   local    =    null ;", "if    ( spawnShapeValue   instanceof   PointSpawnShapeValue )", "local    =    pointSpawnShapeValue ;", "else", "if    ( spawnShapeValue   instanceof   graphics . g 3 d . particles . values . LineSpawnShapeValue )", "local    =    lineSpawnShapeValue ;", "else", "if    ( spawnShapeValue   instanceof   graphics . g 3 d . particles . values . RectangleSpawnShapeValue )", "local    =    rectangleSpawnShapeValue ;", "else", "if    ( spawnShapeValue   instanceof   graphics . g 3 d . particles . values . EllipseSpawnShapeValue )", "local    =    ellipseSpawnShapeValue ;", "else", "if    ( spawnShapeValue   instanceof   graphics . g 3 d . particles . values . CylinderSpawnShapeValue )", "local    =    cylinderSpawnShapeValue ;", "if    ( spawnShapeValue   instanceof   UnweightedMeshSpawnShapeValue )", "local    =    meshSpawnShapeValue ;", "else", "if    ( spawnShapeValue   instanceof   graphics . g 3 d . particles . values . WeightMeshSpawnShapeValue )", "local    =    weightMeshSpawnShapeValue ;", "local . load ( spawnShapeValue )  ;", "}", "METHOD_END"], "methodName": ["setCurrentSpawnData"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "edgesCheckbox . setVisible ( visible )  ;", "edgesLabel . setVisible ( visible )  ;", "}", "METHOD_END"], "methodName": ["setEdgesVisible"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "setSpawnShapeValue ( shape )  ;", "value . spawnShapeValue    =    shape ;", "setEdgesVisible ( false )  ;", "setSidesVisible ( false )  ;", "widthPanel . setVisible ( false )  ;", "heightPanel . setVisible ( false )  ;", "depthPanel . setVisible ( false )  ;", "meshPanel . setVisible ( true )  ;", "}", "METHOD_END"], "methodName": ["setMeshSpawnShape"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "setSpawnShapeValue ( shape )  ;", "influencer    =     (  (  )     ( editor . getEmitter (  )  . findInfluencer (  . class )  )  )  ;", "influencer . spawnShapeValue    =    shape ;", "widthPanel . setValue ( shape . getSpawnWidth (  )  )  ;", "heightPanel . setValue ( shape . getSpawnHeight (  )  )  ;", "depthPanel . setValue ( shape . getSpawnDepth (  )  )  ;", "setEdgesVisible ( showEdges )  ;", "if    ( showEdges )", "edgesCheckbox . setSelected ( shape . isEdges (  )  )  ;", "if    ( side    !  =    null )     {", "setSidesVisible ( true )  ;", "sideCombo . setSelectedItem ( side )  ;", "} else    {", "setSidesVisible ( false )  ;", "}", "widthPanel . setVisible ( true )  ;", "heightPanel . setVisible ( true )  ;", "depthPanel . setVisible ( true )  ;", "meshPanel . setVisible ( false )  ;", "}", "METHOD_END"], "methodName": ["setPrimitiveSpawnShape"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "sideCombo . setVisible ( visible )  ;", "sideLabel . setVisible ( visible )  ;", "}", "METHOD_END"], "methodName": ["setSidesVisible"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "xPanel . setValue ( spawnShapeValue . xOffsetValue )  ;", "yPanel . setValue ( spawnShapeValue . yOffsetValue )  ;", "zPanel . setValue ( spawnShapeValue . zOffsetValue )  ;", "}", "METHOD_END"], "methodName": ["setSpawnShapeValue"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "if    ( spawnShapeValue   instanceof   PrimitiveSpawnShapeValue )     {", "if    ( spawnShapeValue   instanceof   PointSpawnShapeValue )", "return    . SPAWN _ SHAPE _ POINT ;", "else", "if    ( spawnShapeValue   instanceof   com . badlogic . gdx . graphics . g 3 d . particles . values . LineSpawnShapeValue )", "return    . SPAWN _ SHAPE _ LINE ;", "else", "if    ( spawnShapeValue   instanceof   com . badlogic . gdx . graphics . g 3 d . particles . values . RectangleSpawnShapeValue )", "return    . SPAWN _ SHAPE _ RECTANGLE ;", "else", "if    ( spawnShapeValue   instanceof   com . badlogic . gdx . graphics . g 3 d . particles . values . EllipseSpawnShapeValue )", "return    . SPAWN _ SHAPE _ ELLIPSE ;", "else", "if    ( spawnShapeValue   instanceof   com . badlogic . gdx . graphics . g 3 d . particles . values . CylinderSpawnShapeValue )", "return    . SPAWN _ SHAPE _ CYLINDER ;", "}", "if    ( spawnShapeValue   instanceof   WeightMeshSpawnShapeValue )     {", "return    . SPAWN _ SHAPE _ WEIGHT _ MESH ;", "}", "if    ( spawnShapeValue   instanceof   UnweightedMeshSpawnShapeValue )     {", "return    . SPAWN _ SHAPE _ MESH ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["spawnShapeToString"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "SpawnInfluencer   influencer    =     (  ( SpawnInfluencer )     ( editor . getEmitter (  )  . findInfluencer ( SpawnInfluencer . class )  )  )  ;", "shapeCombo . setSelectedItem ( spawnShapeToString ( influencer . spawnShapeValue )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.tools.flame.SpawnInfluencerPanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "JPanel   panel    =    new   JPanel (  )  ;", "panel . add ( new   JLabel (  \" Global \"  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "panel . add (  ( isGlobalCheckBox    =    new   JCheckBox (  )  )  ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "contentPanel . add ( panel ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "contentPanel . add (  ( magnitudePanel    =    new   ScaledNumericPanel ( editor ,    null ,    charTitle ,     \" Strength \"  ,     \" In   world   units   per   second .  \"  ,    true )  )  ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "JPanel   spacer    =    new   JPanel (  )  ;", "spacer . setPreferredSize ( new   Dimension (  )  )  ;", "contentPanel . add ( spacer ,    new   GridBagConstraints (  6  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "magnitudePanel . setIsAlwayShown ( true )  ;", "isGlobalCheckBox . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   e )     {", ". this . value . isGlobal    =    isGlobalCheckBox . isSelected (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.StrengthVelocityPanel"}, {"methodBody": ["METHOD_START", "{", "String   name    =    editor . assetManager . getAssetFileName ( template )  ;", "return   name    =  =    null    ?     \" template    \"     +    index    :    name ;", "}", "METHOD_END"], "methodName": ["getTemplateName"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "if    ( loaderButton    !  =    null )     {", "loaderButton . setListener ( this )  ;", "contentPanel . add ( loaderButton ,    new   GridBagConstraints (  0  ,     ( i +  +  )  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "contentPanel . add ( scroll ,    new   GridBagConstraints (  0  ,    i ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "{", "templatesTable    =    new   JTable (  )     {", "public   Class   getColumnClass ( int   column )     {", "return   column    =  =     1     ?    Boolean . class    :    super . getColumnClass ( column )  ;", "}", "@ Override", "public   Dimension   getPreferredScrollableViewportSize (  )     {", "Dimension   dim    =    super . getPreferredScrollableViewportSize (  )  ;", "dim . height    =    getPreferredSize (  )  . height ;", "return   dim ;", "}", "}  ;", "templatesTable . getTableHeader (  )  . setReorderingAllowed ( false )  ;", "templatesTable . setSelectionMode ( ListSelectionModel . SINGLE _ SELECTION )  ;", "scroll . setViewportView ( templatesTable )  ;", "templatesTableModel    =    new   DefaultTableModel ( new   String [  0  ]  [  0  ]  ,    new   String [  ]  {     \"  \"  ,     \" Selected \"     }  )  ;", "templatesTable . setModel ( templatesTableModel )  ;", "reloads (  )  ;", "templatesTableModel . addTableModelListener ( new   TableModelListener (  )     {", "public   void   tableChanged ( TableModelEvent   event )     {", "if    (  ( event . getColumn (  )  )     !  =     1  )", "return ;", "int   row    =    event . getFirstRow (  )  ;", "boolean   checked    =     (  ( Boolean )     ( templatesTable . getValueAt ( row ,     1  )  )  )  ;", "if    (  ( isOneModelSelectedRequired )     &  &     (  (  ( value . size )     =  =     1  )     &  &     (  ! checked )  )  )     {", "EditorPanel . setValue ( templatesTableModel ,    true ,    row ,     1  )  ;", "return ;", "}", "templateChecked ( row ,    checked )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "setLoadedTemplates ( editor . assetManager . getAll ( type ,    new   Array < T >  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["reloadTemplates"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "this . excludedTemplates . clear (  )  ;", "this . excludedTemplates . addAll ( excludedTemplates )  ;", "}", "METHOD_END"], "methodName": ["setExcludedTemplates"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "loadedTemplates . clear (  )  ;", "loadedTemplates . addAll ( templates )  ;", "loadedTemplates . removeAll ( excludedTemplates ,    true )  ;", "templatesTableModel . getDataVector (  )  . removeAllElements (  )  ;", "int   i    =     0  ;", "for    ( T   template    :    templates )     {", "templatesTableModel . addRow ( new   Object [  ]  {    getTemplateName ( template ,    i )  ,    false    }  )  ;", "i +  +  ;", "}", "lastSelected    =     -  1  ;", "setValue ( value )  ;", "}", "METHOD_END"], "methodName": ["setLoadedTemplates"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "this . isMultipleSelectionAllowed    =    isMultipleSelectionAllowed ;", "}", "METHOD_END"], "methodName": ["setMultipleSelectionAllowed"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "this . isOneModelSelectedRequired    =    isOneModelSelectionRequired ;", "}", "METHOD_END"], "methodName": ["setOneModelSelectionRequired"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "T   template    =    loadedTemplates . get ( index )  ;", "if    ( isChecked )     {", "if    (  !  ( isMultipleSelectionAllowed )  )     {", "if    (  ( lastSelected )     >     (  -  1  )  )     {", "value . removeValue ( loadedTemplates . get ( lastSelected )  ,    true )  ;", "EditorPanel . setValue ( templatesTableModel ,    false ,    lastSelected ,     1  )  ;", "}", "}", "value . add ( template )  ;", "lastSelected    =    index ;", "} else    {", "value . removeValue ( template ,    true )  ;", "}", "listener . onTemplateChecked ( template ,    isChecked )  ;", "}", "METHOD_END"], "methodName": ["templateChecked"], "fileName": "com.badlogic.gdx.tools.flame.TemplatePickerPanel"}, {"methodBody": ["METHOD_START", "{", "for    ( Component   regionPanel    :    regionsPanel . getComponents (  )  )", "(  ( Panel )     ( regionPanel )  )  . clearSelection (  )  ;", "}", "METHOD_END"], "methodName": ["clearSelection"], "fileName": "com.badlogic.gdx.tools.flame.TextureAtlasPanel"}, {"methodBody": ["METHOD_START", "{", "CustomCardLayout   layout    =     (  ( CustomCardLayout )     ( regionsPanel . getLayout (  )  )  )  ;", "return   layout . getCurrentCard ( regionsPanel )  ;", "}", "METHOD_END"], "methodName": ["getCurrentRegionPanel"], "fileName": "com.badlogic.gdx.tools.flame.TextureAtlasPanel"}, {"methodBody": ["METHOD_START", "{", "out . clear (  )  ;", "for    ( Region   region    :    atlasRegions )     {", "if    (  ( region . get (  )  )     =  =    texture )", "out . add ( region )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["getRegions"], "fileName": "com.badlogic.gdx.tools.flame.TextureAtlasPanel"}, {"methodBody": ["METHOD_START", "{", "CustomCardLayout   layout    =     (  ( CustomCardLayout )     ( regionsPanel . getLayout (  )  )  )  ;", "Panel   panel    =    getCurrentRegionPanel (  )  ;", "return   panel . selectedRegions ;", "}", "METHOD_END"], "methodName": ["getSelectedRegions"], "fileName": "com.badlogic.gdx.tools.flame.TextureAtlasPanel"}, {"methodBody": ["METHOD_START", "{", "setLayout ( new   GridBagLayout (  )  )  ;", "JButton   backwardButton ;", "JButton   forwardButton ;", "add (  ( backwardButton    =    new   JButton (  \"  <  \"  )  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "add (  ( region    =    new   JPanel (  )  )  ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "add (  ( forwardButton    =    new   JButton (  \"  >  \"  )  )  ,    new   GridBagConstraints (  2  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "region . setLayout ( new   CustomCardLayout (  )  )  ;", "backwardButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "if    (  ( atlas )     =  =    null )", "return ;", "CustomCardLayout   layout    =     (  ( CustomCardLayout )     ( region . getLayout (  )  )  )  ;", "layout . previous ( region )  ;", "}", "}  )  ;", "forwardButton . addActionListener ( new   ActionListener (  )     {", "@ Override", "public   void   actionPerformed ( ActionEvent   arg 0  )     {", "if    (  ( atlas )     =  =    null )", "return ;", "CustomCardLayout   layout    =     (  ( CustomCardLayout )     ( region . getLayout (  )  )  )  ;", "layout . next ( region )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.flame.TextureAtlasPanel"}, {"methodBody": ["METHOD_START", "{", "if    ( atlas    =  =     ( this . atlas )  )", "return ;", "regionsPanel . removeAll (  )  ;", "Array < AtlasRegion >    atlasRegions    =    atlas . getRegions (  )  ;", "CustomCardLayout   layout    =     (  ( CustomCardLayout )     ( regionsPanel . getLayout (  )  )  )  ;", "Array < Region >    regions    =    new   Array < Region >  (  )  ;", "for    (    texture    :    atlas . gets (  )  )     {", "FileData   file    =     (  ( FileData )     ( texture . getData (  )  )  )  ;", "regionsPanel . add ( new   Panel ( texture ,    getRegions ( texture ,    atlasRegions ,    regions )  )  )  ;", "}", "layout . first ( regionsPanel )  ;", "this . atlas    =    atlas ;", "}", "METHOD_END"], "methodName": ["setAtlas"], "fileName": "com.badlogic.gdx.tools.flame.TextureAtlasPanel"}, {"methodBody": ["METHOD_START", "{", "selectedRegions . clear (  )  ;", "unselectedRegions . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "unselectedRegions . addAll ( selectedRegions )  ;", "selectedRegions . clear (  )  ;", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["clearSelection"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "for    ( Region   region    :    regions )     {", "int   x    =    region . getRegionX (  )  ;", "int   y    =    region . getRegionY (  )  ;", "int   h    =    region . getRegionHeight (  )  ;", "if    ( drawIndex )     {", "String   indexString    =     \"  \"     +    i ;", "Rectangle   bounds    =    g . getFontMetrics (  )  . getStringBounds ( indexString ,    g )  . getBounds (  )  ;", "g . setColor ( indexBackgroundColor )  ;", "g . fillRect ( x ,     (  ( y    +    h )     -     ( bounds . height )  )  ,    bounds . width ,    bounds . height )  ;", "g . setColor ( indexColor )  ;", "g . drawString ( indexString ,    x ,     ( y    +    h )  )  ;", "+  + i ;", "}", "g . setColor ( color )  ;", "g . drawRect ( x ,    y ,    region . getRegionWidth (  )  ,    h )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "return   texture ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "float   rx    =    region . getRegionX (  )  ;", "float   ry    =    region . getRegionY (  )  ;", "ren    (  (  ( rx    <  =    x )     &  &     ( x    <  =     ( rx    +     ( region . getRegionWidth (  )  )  )  )  )     &  &     ( ry    <  =    y )  )     &  &     ( y    <  =     ( ry    +     ( region . getRegionHeight (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInsideRegion"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "swap ( region ,    unselectedRegions ,    selectedRegions )  ;", "}", "METHOD_END"], "methodName": ["select"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "selectedRegions . addAll ( unselectedRegions )  ;", "unselectedRegions . clear (  )  ;", "repaint (  )  ;", "}", "METHOD_END"], "methodName": ["selectAll"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "unselectedRegions . clear (  )  ;", "selectedRegions . clear (  )  ;", "unselectedRegions . addAll ( regions )  ;", "}", "METHOD_END"], "methodName": ["setRegions"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . texture )     =  =    texture )", "return ;", "this . texture    =    texture ;", "FileData   data    =     (  ( FileData )     ( texture . getData (  )  )  )  ;", "setImage ( data . getFileHandle (  )  . file (  )  . getAbsolutePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["setTexture"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "int   index    =    src . indexOf ( region ,    true )  ;", "if    ( index    >     (  -  1  )  )     {", "src . removeIndex ( index )  ;", "dst . add ( region )  ;", "repaint (  )  ;", "}", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "swap ( region ,    selectedRegions ,    unselectedRegions )  ;", "}", "METHOD_END"], "methodName": ["unselect"], "fileName": "com.badlogic.gdx.tools.flame.TexturePanel"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     !  =     1  )     {", ". process (  \"  .  .  /  .  .  / gdx /  \"  )  ;", ". process (  \"  .  .  /  .  .  / backends /  \"  )  ;", ". process (  \"  .  .  /  .  .  / tests /  \"  )  ;", ". process (  \"  .  .  /  .  .  / extensions /  \"  )  ;", "} else    {", ". process ( args [  0  ]  )  ;", "}", "System . out . println (  (  (  (  (  \" Changed    \"     +     (  . filesChanged )  )     +     \"     /     \"  )     +     (  . filesScanned )  )     +     \"    files .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.headers.HeaderFixer"}, {"methodBody": ["METHOD_START", "{", "HeaderFixer . HeaderFileProcessor   processor    =    new   HeaderFixer . HeaderFileProcessor (  )  ;", "processor . process ( new   File ( directory )  ,    new   File ( directory )  )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.headers.HeaderFixer"}, {"methodBody": ["METHOD_START", "{", "char [  ]    chars    =    new   char [  ]  {    c    }  ;", "GlyphVector   vector    =    unicode . get (  )  . layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,     . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "Rectangle   bounds    =    vector . getGlyphPixelBounds (  0  ,    GlyphPage . renderContext ,     0  ,     0  )  ;", "return   unicode . getGlyph ( vector . getGlyphCode (  0  )  ,    c ,    bounds ,    vector ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getGlyph"], "fileName": "com.badlogic.gdx.tools.hiero.BMFontUtil"}, {"methodBody": ["METHOD_START", "{", "char [  ]    chars    =    Character . toChars ( codePoint )  ;", "GlyphVector   vector    =    font . layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,     . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "return   vector . getGlyphCode (  0  )  ;", "}", "METHOD_END"], "methodName": ["getGlyphCode"], "fileName": "com.badlogic.gdx.tools.hiero.BMFontUtil"}, {"methodBody": ["METHOD_START", "{", "File   outputDir    =    outputBMFontFile . getParentFile (  )  ;", "String   outputName    =    outputBMFontFile . getName (  )  ;", "if    ( outputName . endsWith (  \"  . fnt \"  )  )", "outputName    =    outputName . substring (  0  ,     (  ( outputName . length (  )  )     -     4  )  )  ;", "getGlyph (  '     '  )  ;", "getGlyph (  '  \\ u 0  0  0  0  '  )  ;", "unicodeFont . loadGlyphs (  )  ;", "PrintStream   out    =    new   PrintStream ( new   FileOutputStream ( new   File ( outputDir ,     ( outputName    +     \"  . fnt \"  )  )  )  )  ;", "Font   font    =    unicodeFont . getFont (  )  ;", "int   pageWidth    =    unicodeFont . getGlyphPageWidth (  )  ;", "int   pageHeight    =    unicodeFont . getGlyphPageHeight (  )  ;", "out . println (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" info   face =  \\  \"  \"     +     ( font . getFontName (  )  )  )     +     \"  \\  \"    size =  \"  )     +     ( font . getSize (  )  )  )     +     \"    bold =  \"  )     +     ( font . isBold (  )     ?     1     :     0  )  )     +     \"    italic =  \"  )     +     ( font . isItalic (  )     ?     1     :     0  )  )     +     \"    charset =  \\  \"  \\  \"    unicode =  0    stretchH =  1  0  0    smooth =  1    aa =  1    padding =  \"  )     +     ( unicodeFont . getPaddingTop (  )  )  )     +     \"  ,  \"  )     +     ( unicodeFont . getPaddingRight (  )  )  )     +     \"  ,  \"  )     +     ( unicodeFont . getPaddingBottom (  )  )  )     +     \"  ,  \"  )     +     ( unicodeFont . getPaddingLeft (  )  )  )     +     \"    spacing =  \"  )     +     ( unicodeFont . getPaddingAdvanceX (  )  )  )     +     \"  ,  \"  )     +     ( unicodeFont . getPaddingAdvanceY (  )  )  )  )  ;", "out . println (  (  (  (  (  (  (  (  (  (  (  \" common   lineHeight =  \"     +     ( unicodeFont . getLineHeight (  )  )  )     +     \"    base =  \"  )     +     ( unicodeFont . getAscent (  )  )  )     +     \"    scaleW =  \"  )     +    pageWidth )     +     \"    scaleH =  \"  )     +    pageHeight )     +     \"    pages =  \"  )     +     ( unicodeFont . getGlyphPages (  )  . size (  )  )  )     +     \"    packed =  0  \"  )  )  ;", "int   pageIndex    =     0  ;", "int   glyphCount    =     0  ;", "for    ( Iterator   pageIter    =    unicodeFont . getGlyphPages (  )  . iterator (  )  ;    pageIter . hasNext (  )  ;  )     {", "GlyphPage   page    =     (  ( GlyphPage )     ( pageIter . next (  )  )  )  ;", "String   fileName ;", "if    (  ( pageIndex    =  =     0  )     &  &     (  !  ( pageIter . hasNext (  )  )  )  )", "fileName    =    outputName    +     \"  . png \"  ;", "else", "fileName    =     ( outputName    +     ( pageIndex    +     1  )  )     +     \"  . png \"  ;", "out . println (  (  (  (  (  \" page   id =  \"     +    pageIndex )     +     \"    file =  \\  \"  \"  )     +    fileName )     +     \"  \\  \"  \"  )  )  ;", "glyphCount    +  =    page . getGlyphs (  )  . size (  )  ;", "pageIndex +  +  ;", "}", "out . println (  (  \" chars   count =  \"     +    glyphCount )  )  ;", "pageIndex    =     0  ;", "List   allGlyphs    =    new   ArrayList (  5  1  2  )  ;", "for    ( Iterator   pageIter    =    unicodeFont . getGlyphPages (  )  . iterator (  )  ;    pageIter . hasNext (  )  ;  )     {", "GlyphPage   page    =     (  ( GlyphPage )     ( pageIter . next (  )  )  )  ;", "List < Glyph >    glyphs    =    page . getGlyphs (  )  ;", "Collections . sort ( glyphs ,    new   Comparator < Glyph >  (  )     {", "public   int   compare ( Glyph   o 1  ,    Glyph   o 2  )     {", "return    ( o 1  . getCodePoint (  )  )     -     ( o 2  . getCodePoint (  )  )  ;", "}", "}  )  ;", "for    ( Iterator   glyphIter    =    page . getGlyphs (  )  . iterator (  )  ;    glyphIter . hasNext (  )  ;  )     {", "Glyph   glyph    =     (  ( Glyph )     ( glyphIter . next (  )  )  )  ;", "writeGlyph ( out ,    pageWidth ,    pageHeight ,    pageIndex ,    glyph )  ;", "}", "allGlyphs . addAll ( page . getGlyphs (  )  )  ;", "pageIndex +  +  ;", "}", "String   ttfFileRef    =    unicodeFont . getFontFile (  )  ;", "if    ( ttfFileRef    =  =    null )", "System . out . println (  \" Kerning   information   could   not   be   output   because   a   TTF   font   file   was   not   specified .  \"  )  ;", "else    {", "Kerning   kerning    =    new   Kerning (  )  ;", "try    {", "kerning . load ( files . internal ( ttfFileRef )  . read (  )  ,    font . getSize (  )  )  ;", "}    catch    ( IOException   ex )     {", "System . out . println (  (  \" Unable   to   read   kerning   information   from   font :     \"     +    ttfFileRef )  )  ;", "ex . printStackTrace (  )  ;", "}", "IntIntMap   glyphCodeToCodePoint    =    new   IntIntMap (  )  ;", "for    ( Iterator   iter    =    allGlyphs . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Glyph   glyph    =     (  ( Glyph )     ( iter . next (  )  )  )  ;", "glyphCodeToCodePoint . put ( new   Integer ( getGlyphCode ( font ,    glyph . getCodePoint (  )  )  )  ,    new   Integer ( glyph . getCodePoint (  )  )  )  ;", "}", "List   kernings    =    new   ArrayList (  2  5  6  )  ;", "class   KerningPair    {", "public   int   firstCodePoint ;", "public   int   secondCodePoint ;", "public   int   offset ;", "}", "for    ( IntIntMap . Entry   entry    :    kerning . getKernings (  )  )     {", "int   firstGlyphCode    =     ( entry . key )     >  >     1  6  ;", "int   secondGlyphCode    =     ( entry . key )     &     6  5  5  3  5  ;", "int   offset    =    entry . value ;", "int   firstCodePoint    =    glyphCodeToCodePoint . get ( firstGlyphCode ,     (  -  1  )  )  ;", "int   secondCodePoint    =    glyphCodeToCodePoint . get ( secondGlyphCode ,     (  -  1  )  )  ;", "if    (  (  ( firstCodePoint    =  =     (  -  1  )  )     |  |     ( secondCodePoint    =  =     (  -  1  )  )  )     |  |     ( offset    =  =     0  )  )     {", "continue ;", "}", "KerningPair   pair    =    new   KerningPair (  )  ;", "pair . firstCodePoint    =    firstCodePoint ;", "pair . secondCodePoint    =    secondCodePoint ;", "pair . offset    =    offset ;", "kernings . add ( pair )  ;", "}", "out . println (  (  \" kernings   count =  \"     +     ( kernings . size (  )  )  )  )  ;", "for    ( Iterator   iter    =    kernings . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "KerningPair   pair    =     (  ( KerningPair )     ( iter . next (  )  )  )  ;", "out . println (  (  (  (  (  (  \" kerning   first =  \"     +     ( pair . firstCodePoint )  )     +     \"    second =  \"  )     +     ( pair . secondCodePoint )  )     +     \"    amount =  \"  )     +     ( pair . offset )  )  )  ;", "}", "}", "out . close (  )  ;", "int   width    =    unicodeFont . getGlyphPageWidth (  )  ;", "int   height    =    unicodeFont . getGlyphPageHeight (  )  ;", "IntBuffer   buffer    =    BufferUtils . createIntBuffer (  ( width    *    height )  )  ;", "BufferedImage   pageImage    =    new   BufferedImage ( width ,    height ,    BufferedImage . TYPE _ INT _ ARGB )  ;", "int [  ]    row    =    new   int [ width ]  ;", "pageIndex    =     0  ;", "for    ( Iterator   pageIter    =    unicodeFont . getGlyphPages (  )  . iterator (  )  ;    pageIter . hasNext (  )  ;  )     {", "GlyphPage   page    =     (  ( GlyphPage )     ( pageIter . next (  )  )  )  ;", "String   fileName ;", "if    (  ( pageIndex    =  =     0  )     &  &     (  !  ( pageIter . hasNext (  )  )  )  )", "fileName    =    outputName    +     \"  . png \"  ;", "else", "fileName    =     ( outputName    +     ( pageIndex    +     1  )  )     +     \"  . png \"  ;", "page . getTexture (  )  . bind (  )  ;", "buffer . clear (  )  ;", "GL 1  1  . glGetTexImage ( GL _ TEXTURE _  2 D ,     0  ,    GL _ BGRA ,    GL _ UNSIGNED _ BYTE ,    buffer )  ;", "WritableRaster   raster    =    pageImage . getRaster (  )  ;", "for    ( int   y    =     0  ;    y    <    height ;    y +  +  )     {", "buffer . get ( row )  ;", "raster . setDataElements (  0  ,    y ,    width ,     1  ,    row )  ;", "}", "File   imageOutputFile    =    new   File ( outputDir ,    fileName )  ;", "ImageIO . write ( pageImage ,     \" png \"  ,    imageOutputFile )  ;", "pageIndex +  +  ;", "}", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.tools.hiero.BMFontUtil"}, {"methodBody": ["METHOD_START", "{", "out . println (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" char   id =  \"     +     ( String . format (  \"  %  -  7 s    \"  ,    glyph . getCodePoint (  )  )  )  )     +     \" x =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,     (  ( int )     (  ( glyph . getU (  )  )     *    pageWidth )  )  )  )  )     +     \" y =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,     (  ( int )     (  ( glyph . getV (  )  )     *    pageHeight )  )  )  )  )     +     \" width =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,    glyph . getWidth (  )  )  )  )     +     \" height =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,    glyph . getHeight (  )  )  )  )     +     \" xoffset =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,    glyph . getXOffset (  )  )  )  )     +     \" yoffset =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,    glyph . getYOffset (  )  )  )  )     +     \" xadvance =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,    glyph . getXAdvance (  )  )  )  )     +     \" page =  \"  )     +     ( String . format (  \"  %  -  5 s \"  ,    pageIndex )  )  )     +     \" chnl =  0     \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writeGlyph"], "fileName": "com.badlogic.gdx.tools.hiero.BMFontUtil"}, {"methodBody": ["METHOD_START", "{", "rendererCanvas . stop (  )  ;", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "System . exit ( exitCode )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["exit"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   image    =    new   BufferedImage (  3  2  ,     1  6  ,    BufferedImage . TYPE _ INT _ RGB )  ;", "Graphics   g    =    image . getGraphics (  )  ;", "g . setColor ( color )  ;", "g . fillRect (  1  ,     1  ,     3  0  ,     1  4  )  ;", "g . setColor ( Color . black )  ;", "g . drawRect (  0  ,     0  ,     3  1  ,     1  5  )  ;", "return   new   ImageIcon ( image )  ;", "}", "METHOD_END"], "methodName": ["getColorIcon"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "initializeComponents (  )  ;", "initializeMenus (  )  ;", "initializeEvents (  )  ;", "setSize (  1  0  2  4  ,     6  0  0  )  ;", "setLocationRelativeTo ( null )  ;", "setDefaultCloseOperation ( JFrame . DISPOSE _ ON _ CLOSE )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "getContentPane (  )  . setLayout ( new   GridBagLayout (  )  )  ;", "JPanel   leftSidePanel    =    new   JPanel (  )  ;", "leftSidePanel . setLayout ( new   GridBagLayout (  )  )  ;", "getContentPane (  )  . d ( leftSidePanel ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "{", "JPanel   fontPanel    =    new   JPanel (  )  ;", "leftSidePanel . d ( fontPanel ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  5  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "fontPanel . setLayout ( new   GridBagLayout (  )  )  ;", "fontPanel . setBorder ( BorderFactory . createTitledBorder (  \" Font \"  )  )  ;", "{", "fontSizeSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  3  2  ,     0  ,     2  5  6  ,     1  )  )  ;", "fontPanel . d ( fontSizeSpinner ,    new   GridBagConstraints (  1  ,     3  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     1  0  )  ,     0  ,     0  )  )  ;", "(  ( JSpinner . DefaultEditor )     ( fontSizeSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "}", "{", "JScrollPane   fontScroll    =    new   JScrollPane (  )  ;", "fontPanel . d ( fontScroll ,    new   GridBagConstraints (  1  ,     1  ,     3  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "{", "fontListModel    =    new   DefaultComboBoxModel ( GraphicsEnvironment . getLocalGraphicsEnvironment (  )  . getAvailableFontFamilyNames (  )  )  ;", "fontList    =    new   JList (  )  ;", "fontScroll . setViewportView ( fontList )  ;", "fontList . setModel ( fontListModel )  ;", "fontList . setVisibleRowCount (  6  )  ;", "fontList . setSelectedIndex (  0  )  ;", "fontScroll . setMinimumSize ( new   Dimension (  2  2  0  ,    fontList . getPreferredScrollableViewportSize (  )  . height )  )  ;", "}", "}", "{", "systemFontRio    =    new   JRioButton (  \" System :  \"  ,    true )  ;", "fontPanel . d ( systemFontRio ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . NORTHEAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     0  ,     5  )  ,     0  ,     0  )  )  ;", "systemFontRio . setMargin ( new   Insets (  0  ,     0  ,     0  ,     0  )  )  ;", "}", "{", "fontFileRio    =    new   JRioButton (  \" File :  \"  )  ;", "fontPanel . d ( fontFileRio ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "fontFileRio . setMargin ( new   Insets (  0  ,     0  ,     0  ,     0  )  )  ;", "}", "{", "fontFileText    =    new   JTextField (  )  ;", "fontPanel . d ( fontFileText ,    new   GridBagConstraints (  1  ,     2  ,     2  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     5  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "fontPanel . d ( new   JLabel (  \" Size :  \"  )  ,    new   GridBagConstraints (  0  ,     3  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "unicodePanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "fontPanel . d ( unicodePanel ,    new   GridBagConstraints (  2  ,     3  ,     2  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     5  )  ,     0  ,     0  )  )  ;", "{", "boldCheckBox    =    new   JCheckBox (  \" Bold \"  )  ;", "unicodePanel . d ( boldCheckBox ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "italicCheckBox    =    new   JCheckBox (  \" Italic \"  )  ;", "unicodePanel . d ( italicCheckBox ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "bitmapPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "fontPanel . d ( bitmapPanel ,    new   GridBagConstraints (  2  ,     3  ,     2  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     5  )  ,     0  ,     0  )  )  ;", "{", "bitmapPanel . d ( new   JLabel (  \" Gamma :  \"  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "gammaSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  1  .  8 F ,     0  ,     3  0  ,     0  .  0  1  )  )  ;", "(  ( JSpinner . DefaultEditor )     ( gammaSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "bitmapPanel . d ( gammaSpinner ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     1  0  )  ,     0  ,     0  )  )  ;", "}", "{", "monoCheckBox    =    new   JCheckBox (  \" Mono \"  )  ;", "bitmapPanel . d ( monoCheckBox ,    new   GridBagConstraints (  2  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "browseButton    =    new   JButton (  \"  .  .  .  \"  )  ;", "fontPanel . d ( browseButton ,    new   GridBagConstraints (  3  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "browseButton . setMargin ( new   Insets (  0  ,     0  ,     0  ,     0  )  )  ;", "}", "{", "fontPanel . d ( new   JLabel (  \" Rendering :  \"  )  ,    new   GridBagConstraints (  0  ,     4  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . NORTHEAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "JPanel   renderingPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "fontPanel . d ( renderingPanel ,    new   GridBagConstraints (  1  ,     4  ,     3  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "{", "freeTypeRio    =    new   JRioButton (  \" FreeType \"  )  ;", "renderingPanel . d ( freeTypeRio ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "javaRio    =    new   JRioButton (  \" Java \"  )  ;", "renderingPanel . d ( javaRio ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "nativeRio    =    new   JRioButton (  \" Native \"  )  ;", "renderingPanel . d ( nativeRio ,    new   GridBagConstraints (  2  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "}", "ButtonGroup   buttonGroup    =    new   ButtonGroup (  )  ;", "buttonGroup . d ( systemFontRio )  ;", "buttonGroup . d ( fontFileRio )  ;", "buttonGroup    =    new   ButtonGroup (  )  ;", "buttonGroup . d ( freeTypeRio )  ;", "buttonGroup . d ( javaRio )  ;", "buttonGroup . d ( nativeRio )  ;", "freeTypeRio . setSelected ( true )  ;", "}", "{", "JPanel   samplePanel    =    new   JPanel (  )  ;", "leftSidePanel . d ( samplePanel ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  5  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "samplePanel . setLayout ( new   GridBagLayout (  )  )  ;", "samplePanel . setBorder ( BorderFactory . createTitledBorder (  \" Sample   Text \"  )  )  ;", "{", "JScrollPane   textScroll    =    new   JScrollPane (  )  ;", "samplePanel . d ( textScroll ,    new   GridBagConstraints (  0  ,     0  ,     4  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "{", "sampleTextPane    =    new   JTextPane (  )  ;", "textScroll . setViewportView ( sampleTextPane )  ;", "}", "}", "{", "sampleNeheButton    =    new   JButton (  )  ;", "sampleNeheButton . setText (  \" NEHE \"  )  ;", "samplePanel . d ( sampleNeheButton ,    new   GridBagConstraints (  2  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "sampleAsciiButton    =    new   JButton (  )  ;", "sampleAsciiButton . setText (  \" ASCII \"  )  ;", "samplePanel . d ( sampleAsciiButton ,    new   GridBagConstraints (  3  ,     1  ,     1  ,     1  ,     0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "sampleExtendedButton    =    new   JButton (  )  ;", "sampleExtendedButton . setText (  \" Extended \"  )  ;", "samplePanel . d ( sampleExtendedButton ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "JPanel   renderingPanel    =    new   JPanel (  )  ;", "leftSidePanel . d ( renderingPanel ,    new   GridBagConstraints (  0  ,     1  ,     2  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "renderingPanel . setBorder ( BorderFactory . createTitledBorder (  \" Rendering \"  )  )  ;", "renderingPanel . setLayout ( new   GridBagLayout (  )  )  ;", "{", "JPanel   wrapperPanel    =    new   JPanel (  )  ;", "renderingPanel . d ( wrapperPanel ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "wrapperPanel . setLayout ( new   BorderLayout (  )  )  ;", "wrapperPanel . setBackground ( Color . white )  ;", "{", "gamePanel    =    new   JPanel (  )  ;", "wrapperPanel . d ( gamePanel )  ;", "gamePanel . setLayout ( new   BorderLayout (  )  )  ;", "gamePanel . setBackground ( Color . white )  ;", "}", "}", "{", "glyphCachePanel    =    new   JPanel (  )     {", "private   int   maxWidth ;", "public   Dimension   getPreferredSize (  )     {", "Dimension   size    =    super . getPreferredSize (  )  ;", "maxWidth    =    Math . max ( maxWidth ,    size . width )  ;", "size . width    =    maxWidth ;", "return   size ;", "}", "}  ;", "glyphCachePanel . setVisible ( false )  ;", "renderingPanel . d ( glyphCachePanel ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . NORTH ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "glyphCachePanel . setLayout ( new   GridBagLayout (  )  )  ;", "{", "glyphCachePanel . d ( new   JLabel (  \" Glyphs :  \"  )  ,    new   GridBagConstraints (  0  ,     4  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "glyphCachePanel . d ( new   JLabel (  \" Pages :  \"  )  ,    new   GridBagConstraints (  0  ,     3  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "glyphCachePanel . d ( new   JLabel (  \" Page   width :  \"  )  ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "glyphCachePanel . d ( new   JLabel (  \" Page   height :  \"  )  ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "glyphPageWidthCombo    =    new   JComboBox ( new   DefaultComboBoxModel ( new   Integer [  ]  {    new   Integer (  3  2  )  ,    new   Integer (  6  4  )  ,    new   Integer (  1  2  8  )  ,    new   Integer (  2  5  6  )  ,    new   Integer (  5  1  2  )  ,    new   Integer (  1  0  2  4  )  ,    new   Integer (  2  0  4  8  )     }  )  )  ;", "glyphCachePanel . d ( glyphPageWidthCombo ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "glyphPageWidthCombo . setSelectedIndex (  4  )  ;", "}", "{", "glyphPageHeightCombo    =    new   JComboBox ( new   DefaultComboBoxModel ( new   Integer [  ]  {    new   Integer (  3  2  )  ,    new   Integer (  6  4  )  ,    new   Integer (  1  2  8  )  ,    new   Integer (  2  5  6  )  ,    new   Integer (  5  1  2  )  ,    new   Integer (  1  0  2  4  )  ,    new   Integer (  2  0  4  8  )     }  )  )  ;", "glyphCachePanel . d ( glyphPageHeightCombo ,    new   GridBagConstraints (  1  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "glyphPageHeightCombo . setSelectedIndex (  4  )  ;", "}", "{", "resetCacheButton    =    new   JButton (  \" Reset   Cache \"  )  ;", "glyphCachePanel . d ( resetCacheButton ,    new   GridBagConstraints (  0  ,     6  ,     2  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "glyphPagesTotalLabel    =    new   JLabel (  \"  1  \"  )  ;", "glyphCachePanel . d ( glyphPagesTotalLabel ,    new   GridBagConstraints (  1  ,     3  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "glyphsTotalLabel    =    new   JLabel (  \"  0  \"  )  ;", "glyphCachePanel . d ( glyphsTotalLabel ,    new   GridBagConstraints (  1  ,     4  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "glyphPageComboModel    =    new   DefaultComboBoxModel (  )  ;", "glyphPageCombo    =    new   JComboBox (  )  ;", "glyphCachePanel . d ( glyphPageCombo ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "glyphPageCombo . setModel ( glyphPageComboModel )  ;", "}", "{", "glyphCachePanel . d ( new   JLabel (  \" View :  \"  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "JPanel   rioButtonsPanel    =    new   JPanel (  )  ;", "renderingPanel . d ( rioButtonsPanel ,    new   GridBagConstraints (  0  ,     0  ,     2  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "rioButtonsPanel . setLayout ( new   GridBagLayout (  )  )  ;", "{", "sampleTextRio    =    new   JRioButton (  \" Sample   text \"  )  ;", "rioButtonsPanel . d ( sampleTextRio ,    new   GridBagConstraints (  2  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "sampleTextRio . setSelected ( true )  ;", "}", "{", "glyphCacheRio    =    new   JRioButton (  \" Glyph   cache \"  )  ;", "rioButtonsPanel . d ( glyphCacheRio ,    new   GridBagConstraints (  3  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "rioButtonsPanel . d ( new   JLabel (  \" Background :  \"  )  ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "{", "backgroundColorLabel    =    new   JLabel (  )  ;", "rioButtonsPanel . d ( backgroundColorLabel ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "}", "ButtonGroup   buttonGroup    =    new   ButtonGroup (  )  ;", "buttonGroup . d ( glyphCacheRio )  ;", "buttonGroup . d ( sampleTextRio )  ;", "}", "}", "JPanel   rightSidePanel    =    new   JPanel (  )  ;", "rightSidePanel . setLayout ( new   GridBagLayout (  )  )  ;", "getContentPane (  )  . d ( rightSidePanel ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     2  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "{", "JPanel   pdingPanel    =    new   JPanel (  )  ;", "pdingPanel . setLayout ( new   GridBagLayout (  )  )  ;", "rightSidePanel . d ( pdingPanel ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "pdingPanel . setBorder ( BorderFactory . createTitledBorder (  \" Pding \"  )  )  ;", "{", "pTopSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  1  ,     0  ,     9  9  9  ,     1  )  )  ;", "pdingPanel . d ( pTopSpinner ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "(  ( JSpinner . DefaultEditor )     ( pTopSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "}", "{", "pRightSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  1  ,     0  ,     9  9  9  ,     1  )  )  ;", "pdingPanel . d ( pRightSpinner ,    new   GridBagConstraints (  2  ,     2  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     5  )  ,     0  ,     0  )  )  ;", "(  ( JSpinner . DefaultEditor )     ( pRightSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "}", "{", "pLeftSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  1  ,     0  ,     9  9  9  ,     1  )  )  ;", "pdingPanel . d ( pLeftSpinner ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "(  ( JSpinner . DefaultEditor )     ( pLeftSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "}", "{", "pBottomSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  1  ,     0  ,     9  9  9  ,     1  )  )  ;", "pdingPanel . d ( pBottomSpinner ,    new   GridBagConstraints (  1  ,     3  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "(  ( JSpinner . DefaultEditor )     ( pBottomSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "}", "{", "JPanel   vancePanel    =    new   JPanel (  )  ;", "FlowLayout   vancePanelLayout    =    new   FlowLayout (  )  ;", "vancePanel . setLayout ( vancePanelLayout )  ;", "pdingPanel . d ( vancePanel ,    new   GridBagConstraints (  0  ,     4  ,     3  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "{", "vancePanel . d ( new   JLabel (  \" X :  \"  )  )  ;", "}", "{", "pAdvanceXSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  (  -  2  )  ,     (  -  9  9  9  )  ,     9  9  9  ,     1  )  )  ;", "vancePanel . d ( pAdvanceXSpinner )  ;", "(  ( JSpinner . DefaultEditor )     ( pAdvanceXSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "}", "{", "vancePanel . d ( new   JLabel (  \" Y :  \"  )  )  ;", "}", "{", "pAdvanceYSpinner    =    new   JSpinner ( new   SpinnerNumberModel (  (  -  2  )  ,     (  -  9  9  9  )  ,     9  9  9  ,     1  )  )  ;", "vancePanel . d ( pAdvanceYSpinner )  ;", "(  ( JSpinner . DefaultEditor )     ( pAdvanceYSpinner . getEditor (  )  )  )  . getTextField (  )  . setColumns (  2  )  ;", "}", "}", "}", "{", "effectsPanel    =    new   JPanel (  )  ;", "effectsPanel . setLayout ( new   GridBagLayout (  )  )  ;", "rightSidePanel . d ( effectsPanel ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  5  ,     0  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "effectsPanel . setBorder ( BorderFactory . createTitledBorder (  \" Effects \"  )  )  ;", "effectsPanel . setMinimumSize ( new   Dimension (  2  1  0  ,     1  )  )  ;", "{", "effectsScroll    =    new   JScrollPane (  )  ;", "effectsPanel . d ( effectsScroll ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . NORTH ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     5  ,     5  ,     5  )  ,     0  ,     0  )  )  ;", "{", "effectsListModel    =    new   DefaultComboBoxModel (  )  ;", "effectsList    =    new   JList (  )  ;", "effectsScroll . setViewportView ( effectsList )  ;", "effectsList . setModel ( effectsListModel )  ;", "effectsList . setVisibleRowCount (  7  )  ;", "effectsScroll . setMinimumSize ( effectsList . getPreferredScrollableViewportSize (  )  )  ;", "}", "}", "{", "dEffectButton    =    new   JButton (  \" Add \"  )  ;", "effectsPanel . d ( dEffectButton ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     6  ,     5  )  ,     0  ,     0  )  )  ;", "dEffectButton . setEnabled ( false )  ;", "}", "{", "appliedEffectsScroll    =    new   JScrollPane (  )  ;", "effectsPanel . d ( appliedEffectsScroll ,    new   GridBagConstraints (  1  ,     3  ,     1  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . NORTH ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     5  ,     0  )  ,     0  ,     0  )  )  ;", "appliedEffectsScroll . setBorder ( new   EmptyBorder (  0  ,     0  ,     0  ,     0  )  )  ;", "appliedEffectsScroll . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL _ SCROLLBAR _ NEVER )  ;", "{", "JPanel   panel    =    new   JPanel (  )  ;", "panel . setLayout ( new   GridBagLayout (  )  )  ;", "appliedEffectsScroll . setViewportView ( panel )  ;", "{", "appliedEffectsPanel    =    new   JPanel (  )  ;", "appliedEffectsPanel . setLayout ( new   GridBagLayout (  )  )  ;", "panel . d ( appliedEffectsPanel ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  .  0  ,     1  .  0  ,    GridBagConstraints . NORTH ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "appliedEffectsPanel . setBorder ( BorderFactory . createMatteBorder (  1  ,     0  ,     0  ,     0  ,    Color . black )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "fontList . addListSelectionListener ( new   ListSelectionListener (  )     {", "public   void   valueChanged ( ListSelectionEvent   evt )     {", "if    ( evt . getValueIsAdjusting (  )  )", "return ;", "prefs . put (  \" system . font \"  ,     (  ( String )     ( fontList . getSelectedValue (  )  )  )  )  ;", "updateFont (  )  ;", "}", "}  )  ;", "class   FontUpdateListener   implements   ActionListener    ,    ChangeListener    {", "public   void   stateChanged ( ChangeEvent   evt )     {", "updateFont (  )  ;", "}", "public   void   actionPerformed ( ActionEvent   evt )     {", "updateFont (  )  ;", "}", "public   void   addSpinners ( JSpinner [  ]    spinners )     {", "for    ( int   i    =     0  ;    i    <     ( spinners . length )  ;    i +  +  )     {", "final   JSpinner   spinner    =    spinners [ i ]  ;", "spinner . addChangeListener ( this )  ;", "(  ( JSpinner . DefaultEditor )     ( spinner . getEditor (  )  )  )  . getTextField (  )  . addKeyListener ( new   KeyAdapter (  )     {", "String   lastText ;", "public   void   keyReleased ( KeyEvent   evt )     {", "JFormattedTextField   textField    =     (  ( JSpinner . DefaultEditor )     ( spinner . getEditor (  )  )  )  . getTextField (  )  ;", "String   text    =    textField . getText (  )  ;", "if    (  ( text . length (  )  )     =  =     0  )", "return ;", "if    ( text . equals ( lastText )  )", "return ;", "lastText    =    text ;", "int   caretPosition    =    textField . getCaretPosition (  )  ;", "try    {", "spinner . setValue ( Integer . valueOf ( text )  )  ;", "}    catch    ( NumberFormatException   ex )     {", "}", "textField . setCaretPosition ( caretPosition )  ;", "}", "}  )  ;", "}", "}", "}", "FontUpdateListener   listener    =    new   FontUpdateListener (  )  ;", "listener . addSpinners ( new   JSpinner [  ]  {    padTopSpinner ,    padRightSpinner ,    padBottomSpinner ,    padLeftSpinner ,    padAdvanceXSpinner ,    padAdvanceYSpinner    }  )  ;", "fontSizeSpinner . addChangeListener ( listener )  ;", "gammaSpinner . addChangeListener ( listener )  ;", "glyphPageWidthCombo . addActionListener ( listener )  ;", "glyphPageHeightCombo . addActionListener ( listener )  ;", "boldCheckBox . addActionListener ( listener )  ;", "italicCheckBox . addActionListener ( listener )  ;", "monoCheckBox . addActionListener ( listener )  ;", "resetCacheButton . addActionListener ( listener )  ;", "addActionListener ( listener )  ;", "nativeRadio . addActionListener ( listener )  ;", "freeTypeRadio . addActionListener ( listener )  ;", "sampleTextRadio . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "glyphCachePanel . setVisible ( false )  ;", "}", "}  )  ;", "glyphCacheRadio . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "glyphCachePanel . setVisible ( true )  ;", "}", "}  )  ;", "fontFileText . getDocument (  )  . addDocumentListener ( new   DocumentListener (  )     {", "public   void   removeUpdate ( DocumentEvent   evt )     {", "changed (  )  ;", "}", "public   void   insertUpdate ( DocumentEvent   evt )     {", "changed (  )  ;", "}", "public   void   changedUpdate ( DocumentEvent   evt )     {", "changed (  )  ;", "}", "private   void   changed (  )     {", "File   file    =    new   File ( fontFileText . getText (  )  )  ;", "if    (  ( fontList . isEnabled (  )  )     &  &     (  (  !  ( file . exists (  )  )  )     |  |     (  !  ( file . isFile (  )  )  )  )  )", "return ;", "prefs . put (  \" font . file \"  ,    fontFileText . getText (  )  )  ;", "updateFont (  )  ;", "}", "}  )  ;", "final   ActionListener   al    =    new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "updateFontSelector (  )  ;", "updateFont (  )  ;", "}", "}  ;", "systemFontRadio . addActionListener ( al )  ;", "fontFileRadio . addActionListener ( al )  ;", "browseButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "FileDialog   dialog    =    new   FileDialog ( Hiero . this ,     \" Choose   TrueType   font   file \"  ,    FileDialog . LOAD )  ;", "dialog . setLocationRelativeTo ( null )  ;", "dialog . setFile (  \"  *  . ttf \"  )  ;", "dialog . setDirectory ( prefs . get (  \" dir . font \"  ,     \"  \"  )  )  ;", "dialog . setVisible ( true )  ;", "if    (  ( dialog . getDirectory (  )  )     !  =    null )     {", "prefs . put (  \" dir . font \"  ,    dialog . getDirectory (  )  )  ;", "}", "String   fileName    =    dialog . getFile (  )  ;", "if    ( fileName    =  =    null )", "return ;", "fontFileText . setText ( new   File ( dialog . getDirectory (  )  ,    fileName )  . getAbsolutePath (  )  )  ;", "}", "}  )  ;", "backgroundColorLabel . addMouseListener ( new   MouseAdapter (  )     {", "public   void   mouseClicked ( MouseEvent   evt )     {", "Color   color    =    JColorChooser . showDialog ( null ,     \" Choose   a   background   color \"  ,    EffectUtil . fromString ( prefs . get (  \" background \"  ,     \"  0  0  0  0  0  0  \"  )  )  )  ;", "if    ( color    =  =    null )", "return ;", "renderingBackgroundColor    =    new   graphics . Color (  (  ( color . getRed (  )  )     /     2  5  5  .  0 F )  ,     (  ( color . getGreen (  )  )     /     2  5  5  .  0 F )  ,     (  ( color . getBlue (  )  )     /     2  5  5  .  0 F )  ,     1  )  ;", "backgroundColorLabel . setIcon ( Hiero . getColorIcon ( color )  )  ;", "prefs . put (  \" background \"  ,    EffectUtil . toString ( color )  )  ;", "}", "}  )  ;", "effectsList . addListSelectionListener ( new   ListSelectionListener (  )     {", "public   void   valueChanged ( ListSelectionEvent   evt )     {", "ConfigurableEffect   selectedEffect    =     (  ( ConfigurableEffect )     ( effectsList . getSelectedValue (  )  )  )  ;", "boolean   enabled    =    selectedEffect    !  =    null ;", "for    ( Iterator   iter    =    effectPanels . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "ConfigurableEffect   effect    =     (  ( Hiero . EffectPanel )     ( iter . next (  )  )  )  . getEffect (  )  ;", "if    ( effect    =  =    selectedEffect )     {", "enabled    =    false ;", "break ;", "}", "}", "addEffectButton . setEnabled ( enabled )  ;", "}", "}  )  ;", "effectsList . addMouseListener ( new   MouseAdapter (  )     {", "public   void   mouseClicked ( MouseEvent   evt )     {", "if    (  (  ( evt . getClickCount (  )  )     =  =     2  )     &  &     ( addEffectButton . isEnabled (  )  )  )", "addEffectButton . doClick (  )  ;", "}", "}  )  ;", "addEffectButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "new   Hiero . EffectPanel (  (  ( ConfigurableEffect )     ( effectsList . getSelectedValue (  )  )  )  )  ;", "}", "}  )  ;", "openMenuItem . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "FileDialog   dialog    =    new   FileDialog ( Hiero . this ,     \" Open   Hiero   settings   file \"  ,    FileDialog . LOAD )  ;", "dialog . setLocationRelativeTo ( null )  ;", "dialog . setFile (  \"  *  . hiero \"  )  ;", "dialog . setDirectory ( prefs . get (  \" dir . open \"  ,     \"  \"  )  )  ;", "dialog . setVisible ( true )  ;", "if    (  ( dialog . getDirectory (  )  )     !  =    null )     {", "prefs . put (  \" dir . open \"  ,    dialog . getDirectory (  )  )  ;", "}", "String   fileName    =    dialog . getFile (  )  ;", "if    ( fileName    =  =    null )", "return ;", "lastOpenFilename    =    fileName ;", "open ( new   File ( dialog . getDirectory (  )  ,    fileName )  )  ;", "}", "}  )  ;", "saveMenuItem . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "FileDialog   dialog    =    new   FileDialog ( Hiero . this ,     \" Save   Hiero   settings   file \"  ,    FileDialog . SAVE )  ;", "dialog . setLocationRelativeTo ( null )  ;", "dialog . setFile (  \"  *  . hiero \"  )  ;", "dialog . setDirectory ( prefs . get (  \" dir . save \"  ,     \"  \"  )  )  ;", "if    (  ( lastSaveFilename . length (  )  )     >     0  )     {", "dialog . setFile ( lastSaveFilename )  ;", "} else", "if    (  ( lastOpenFilename . length (  )  )     >     0  )     {", "dialog . setFile ( lastOpenFilename )  ;", "}", "dialog . setVisible ( true )  ;", "if    (  ( dialog . getDirectory (  )  )     !  =    null )     {", "prefs . put (  \" dir . save \"  ,    dialog . getDirectory (  )  )  ;", "}", "String   fileName    =    dialog . getFile (  )  ;", "if    ( fileName    =  =    null )", "return ;", "if    (  !  ( fileName . endsWith (  \"  . hiero \"  )  )  )", "fileName    +  =     \"  . hiero \"  ;", "lastSaveFilename    =    fileName ;", "File   file    =    new   File ( dialog . getDirectory (  )  ,    fileName )  ;", "try    {", "save ( file )  ;", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  (  \" Error   saving   Hiero   settings   file :     \"     +     ( file . getAbsolutePath (  )  )  )  ,    ex )  ;", "}", "}", "}  )  ;", "saveBMFontMenuItem . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "FileDialog   dialog    =    new   FileDialog ( Hiero . this ,     \" Save   BMFont   files \"  ,    FileDialog . SAVE )  ;", "dialog . setLocationRelativeTo ( null )  ;", "dialog . setFile (  \"  *  . fnt \"  )  ;", "dialog . setDirectory ( prefs . get (  \" dir . savebm \"  ,     \"  \"  )  )  ;", "if    (  ( lastSaveBMFilename . length (  )  )     >     0  )     {", "dialog . setFile ( lastSaveBMFilename )  ;", "} else", "if    (  ( lastOpenFilename . length (  )  )     >     0  )     {", "dialog . setFile ( lastOpenFilename . replace (  \"  . hiero \"  ,     \"  . fnt \"  )  )  ;", "}", "dialog . setVisible ( true )  ;", "if    (  ( dialog . getDirectory (  )  )     !  =    null )     {", "prefs . put (  \" dir . savebm \"  ,    dialog . getDirectory (  )  )  ;", "}", "String   fileName    =    dialog . getFile (  )  ;", "if    ( fileName    =  =    null )", "return ;", "lastSaveBMFilename    =    fileName ;", "saveBm ( new   File ( dialog . getDirectory (  )  ,    fileName )  )  ;", "}", "}  )  ;", "exitMenuItem . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "dispose (  )  ;", "}", "}  )  ;", "sampleNeheButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "sampleTextPane . setText ( Hiero . NEHE _ CHARS )  ;", "resetCacheButton . doClick (  )  ;", "}", "}  )  ;", "sampleAsciiButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "StringBuilder   buffer    =    new   StringBuilder (  )  ;", "buffer . append ( Hiero . NEHE _ CHARS )  ;", "buffer . append (  '  \\ n '  )  ;", "int   count    =     0  ;", "for    ( int   i    =     3  3  ;    i    <  =     2  5  5  ;    i +  +  )     {", "if    (  ( buffer . indexOf ( Character . toString (  (  ( char )     ( i )  )  )  )  )     !  =     (  -  1  )  )", "continue ;", "buffer . append (  (  ( char )     ( i )  )  )  ;", "if    (  (  (  +  + count )     %     3  0  )     =  =     0  )", "buffer . append (  '  \\ n '  )  ;", "}", "sampleTextPane . setText ( buffer . toString (  )  )  ;", "resetCacheButton . doClick (  )  ;", "}", "}  )  ;", "sampleExtendedButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   evt )     {", "sampleTextPane . setText ( Hiero . EXTENDED _ CHARS )  ;", "resetCacheButton . doClick (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initializeEvents"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "{", "JMenuBar   menuBar    =    new   JMenuBar (  )  ;", "setJMenuBar ( menuBar )  ;", "{", "JMenu   fileMenu    =    new   JMenu (  )  ;", "menuBar . add ( fileMenu )  ;", "fileMenu . setText (  \" File \"  )  ;", "fileMenu . setMnemonic ( KeyEvent . VK _ F )  ;", "{", "openMenuItem    =    new   JMenuItem (  \" Open      settings   file .  .  .  \"  )  ;", "openMenuItem . setMnemonic ( KeyEvent . VK _ O )  ;", "openMenuItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK _ O ,    KeyEvent . CTRL _ MASK )  )  ;", "fileMenu . add ( openMenuItem )  ;", "}", "{", "saveMenuItem    =    new   JMenuItem (  \" Save      settings   file .  .  .  \"  )  ;", "saveMenuItem . setMnemonic ( KeyEvent . VK _ S )  ;", "saveMenuItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK _ S ,    KeyEvent . CTRL _ MASK )  )  ;", "fileMenu . add ( saveMenuItem )  ;", "}", "fileMenu . addSeparator (  )  ;", "{", "saveBMFontMenuItem    =    new   JMenuItem (  \" Save   BMFont   files    ( text )  .  .  .  \"  )  ;", "saveBMFontMenuItem . setMnemonic ( KeyEvent . VK _ B )  ;", "saveBMFontMenuItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK _ B ,    KeyEvent . CTRL _ MASK )  )  ;", "fileMenu . add ( saveBMFontMenuItem )  ;", "}", "fileMenu . addSeparator (  )  ;", "{", "exitMenuItem    =    new   JMenuItem (  \" Exit \"  )  ;", "exitMenuItem . setMnemonic ( KeyEvent . VK _ X )  ;", "fileMenu . add ( exitMenuItem )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["initializeMenus"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "SwingUtilities . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "new    ( args )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "Hiero . EffectPanel [  ]    panels    =     (  ( Hiero . EffectPanel [  ]  )     ( effectPanels . toArray ( new   Hiero . EffectPanel [ effectPanels . size (  )  ]  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( panels . length )  ;    i +  +  )", "panels [ i ]  . remove (  )  ;", "HieroSettings   settings    =    new   HieroSettings ( file . getAbsolutePath (  )  )  ;", "fontList . setSelectedValue ( settings . getFontName (  )  ,    true )  ;", "fontSizeSpinner . setValue ( new   Integer ( settings . getFontSize (  )  )  )  ;", "boldCheckBox . setSelected ( settings . isBold (  )  )  ;", "italicCheckBox . setSelected ( settings . isItalic (  )  )  ;", "monoCheckBox . setSelected ( settings . isMono (  )  )  ;", "gammaSpinner . setValue ( new   Float ( settings . getGamma (  )  )  )  ;", "padTopSpinner . setValue ( new   Integer ( settings . getPaddingTop (  )  )  )  ;", "padRightSpinner . setValue ( new   Integer ( settings . getPaddingRight (  )  )  )  ;", "padBottomSpinner . setValue ( new   Integer ( settings . getPaddingBottom (  )  )  )  ;", "padLeftSpinner . setValue ( new   Integer ( settings . getPaddingLeft (  )  )  )  ;", "padAdvanceXSpinner . setValue ( new   Integer ( settings . getPaddingAdvanceX (  )  )  )  ;", "padAdvanceYSpinner . setValue ( new   Integer ( settings . getPaddingAdvanceY (  )  )  )  ;", "glyphPageWidthCombo . setSelectedItem ( new   Integer ( settings . getGlyphPageWidth (  )  )  )  ;", "glyphPageHeightCombo . setSelectedItem ( new   Integer ( settings . getGlyphPageHeight (  )  )  )  ;", "if    (  ( settings . getRenderType (  )  )     =  =     ( UnicodeFont . RenderType . Native . ordinal (  )  )  )", "nativeRadio . setSelected ( true )  ;", "else", "if    (  ( settings . getRenderType (  )  )     =  =     ( UnicodeFont . RenderType . FreeType . ordinal (  )  )  )", "freeTypeRadio . setSelected ( true )  ;", "else", "if    (  ( settings . getRenderType (  )  )     =  =     ( UnicodeFont . RenderType . Java . ordinal (  )  )  )", "setSelected ( true )  ;", "String   gt    =    settings . getGlyphText (  )  ;", "if    (  ( gt . length (  )  )     >     0  )     {", "sampleTextPane . setText ( settings . getGlyphText (  )  )  ;", "}", "final   String   font 2     =    settings . getFont 2 File (  )  ;", "if    (  ( font 2  . length (  )  )     >     0  )", "fontFileText . setText ( font 2  )  ;", "else", "fontFileText . setText ( prefs . get (  \" font . file \"  ,     \"  \"  )  )  ;", "fontFileRadio . setSelected ( settings . isFont 2 Active (  )  )  ;", "systemFontRadio . setSelected (  (  !  ( settings . isFont 2 Active (  )  )  )  )  ;", "for    ( Iterator   iter    =    settings . getEffects (  )  . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "ConfigurableEffect   settingsEffect    =     (  ( ConfigurableEffect )     ( iter . next (  )  )  )  ;", "for    ( int   i    =     0  ,    n    =    effectsListModel . getSize (  )  ;    i    <    n ;    i +  +  )     {", "ConfigurableEffect   effect    =     (  ( ConfigurableEffect )     ( effectsListModel . getElementAt ( i )  )  )  ;", "if    (  ( effect . getClass (  )  )     =  =     ( settingsEffect . getClass (  )  )  )     {", "effect . setValues ( settingsEffect . getValues (  )  )  ;", "new   Hiero . EffectPanel ( effect )  ;", "break ;", "}", "}", "}", "updateFont (  )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "float   scale    =     1  .  0 F ;", "for    ( int   i    =     0  ;    i    <     ( args . length )  ;    i +  +  )     {", "final   String   param    =    args [ i ]  ;", "final   bean   more    =    i    <     (  ( args . length )     -     1  )  ;", "if    (  ( param . equals (  \"  - b \"  )  )     |  |     ( param . equals (  \"  -  - batch \"  )  )  )     {", "batchMode    =    true ;", "} else", "if    ( more    &  &     (  ( param . equals (  \"  - s \"  )  )     |  |     ( param . equals (  \"  -  - scale \"  )  )  )  )     {", "scale    =    Float . parseFloat ( args [  (  +  + i )  ]  )  ;", "} else", "if    ( more    &  &     (  ( param . equals (  \"  - i \"  )  )     |  |     ( param . equals (  \"  -  - input \"  )  )  )  )     {", "File   f    =    new   File ( args [  (  +  + i )  ]  )  ;", "open ( f )  ;", "fontFileRadio . setText (  \"  \"  )  ;", "updateFont (  )  ;", "} else", "if    ( more    &  &     (  ( param . equals (  \"  - o \"  )  )     |  |     ( param . equals (  \"  -  - output \"  )  )  )  )     {", "File   f    =    new   File ( args [  (  +  + i )  ]  )  ;", "saveBm ( f )  ;", "} else    {", "System . err . println (  (  \" Unknown   parameter :     \"     +    param )  )  ;", "exit (  3  )  ;", "}", "}", "fontSizeSpinner . setValue (  (  ( int )     (  0  .  5 F    +     ( Math . max (  4  ,     ( scale    *     (  ( Integer )     ( fontSizeSpinner . getValue (  )  )  )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseArgs"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "HieroSettings   settings    =    new   HieroSettings (  )  ;", "settings . setFontName (  (  ( String )     ( fontList . getSelectedValue (  )  )  )  )  ;", "settings . setFontSize (  (  ( Integer )     ( fontSizeSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "settings . setFont 2 File ( fontFileText . getText (  )  )  ;", "settings . setFont 2 Active ( fontFileRadio . isSelected (  )  )  ;", "settings . setBold ( boldCheckBox . isSelected (  )  )  ;", "settings . setItalic ( italicCheckBox . isSelected (  )  )  ;", "settings . setMono ( monoCheckBox . isSelected (  )  )  ;", "settings . setGamma (  (  ( Number )     ( gammaSpinner . getValue (  )  )  )  . floatValue (  )  )  ;", "settings . setPaddingTop (  (  ( Number )     ( padTopSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "settings . setPaddingRight (  (  ( Number )     ( padRightSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "settings . setPaddingBottom (  (  ( Number )     ( padBottomSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "settings . setPaddingLeft (  (  ( Number )     ( padLeftSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "settings . setPaddingAdvanceX (  (  ( Number )     ( padAdvanceXSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "settings . setPaddingAdvanceY (  (  ( Number )     ( padAdvanceYSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "settings . setGlyphPageWidth (  (  ( Number )     ( glyphPageWidthCombo . getSelectedItem (  )  )  )  . intValue (  )  )  ;", "settings . setGlyphPageHeight (  (  ( Number )     ( glyphPageHeightCombo . getSelectedItem (  )  )  )  . intValue (  )  )  ;", "settings . setGlyphText ( sampleTextPane . getText (  )  )  ;", "if    ( nativeRadio . isSelected (  )  )", "settings . setRenderType ( unicodefont . UnicodeFont . RenderType . Native . ordinal (  )  )  ;", "else", "if    ( freeTypeRadio . isSelected (  )  )", "settings . setRenderType ( unicodefont . UnicodeFont . RenderType . FreeType . ordinal (  )  )  ;", "else", "settings . setRenderType ( unicodefont . UnicodeFont . RenderType . Java . ordinal (  )  )  ;", "for    ( Iterator   iter    =    effectPanels . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Hiero . EffectPanel   panel    =     (  ( Hiero . EffectPanel )     ( iter . next (  )  )  )  ;", "settings . getEffects (  )  . add ( panel . getEffect (  )  )  ;", "}", "settings . save ( file )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "saveBmFontFile    =    file ;", "}", "METHOD_END"], "methodName": ["saveBm"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "int   fontSize    =     (  ( Integer )     ( fontSizeSpinner . getValue (  )  )  )  . intValue (  )  ;", "File   file    =    null ;", "if    ( fontFileRadio . isSelected (  )  )     {", "file    =    new   File ( fontFileText . getText (  )  )  ;", "if    (  (  !  ( file . exists (  )  )  )     |  |     (  !  ( file . isFile (  )  )  )  )", "file    =    null ;", "}", "boolean   isFreeType    =    freeTypeRadio . isSelected (  )  ;", "boolean   isNative    =    nativeRadio . isSelected (  )  ;", "boolean   isJava    =    isSelected (  )  ;", "addEffectButton . setVisible ( isJava )  ;", "effectsScroll . setVisible ( isJava )  ;", "appliedEffectsScroll . setVisible ( isJava )  ;", "boldCheckBox . setEnabled (  (  ! isFreeType )  )  ;", "italicCheckBox . setEnabled (  (  ! isFreeType )  )  ;", "bitmapPanel . setVisible ( isFreeType )  ;", "unicodePanel . setVisible (  (  ! isFreeType )  )  ;", "updateFontSelector (  )  ;", "UnicodeFont   unicodeFont    =    null ;", "if    ( file    !  =    null )     {", "try    {", "unicodeFont    =    new   UnicodeFont ( fontFileText . getText (  )  ,    fontSize ,    boldCheckBox . isSelected (  )  ,    italicCheckBox . isSelected (  )  )  ;", "}    catch    ( Throwable   ex )     {", "ex . printStackTrace (  )  ;", "fontFileRadio . setSelected ( false )  ;", "}", "}", "if    ( unicodeFont    =  =    null )     {", "unicodeFont    =    new   UnicodeFont ( Font . decode (  (  ( String )     ( fontList . getSelectedValue (  )  )  )  )  ,    fontSize ,    boldCheckBox . isSelected (  )  ,    italicCheckBox . isSelected (  )  )  ;", "}", "unicodeFont . setMono ( monoCheckBox . isSelected (  )  )  ;", "unicodeFont . setGamma (  (  ( Number )     ( gammaSpinner . getValue (  )  )  )  . floatValue (  )  )  ;", "unicodeFont . setPaddingTop (  (  ( Number )     ( padTopSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "unicodeFont . setPaddingRight (  (  ( Number )     ( padRightSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "unicodeFont . setPaddingBottom (  (  ( Number )     ( padBottomSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "unicodeFont . setPaddingLeft (  (  ( Number )     ( padLeftSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "unicodeFont . setPaddingAdvanceX (  (  ( Number )     ( padAdvanceXSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "unicodeFont . setPaddingAdvanceY (  (  ( Number )     ( padAdvanceYSpinner . getValue (  )  )  )  . intValue (  )  )  ;", "unicodeFont . setGlyphPageWidth (  (  ( Number )     ( glyphPageWidthCombo . getSelectedItem (  )  )  )  . intValue (  )  )  ;", "unicodeFont . setGlyphPageHeight (  (  ( Number )     ( glyphPageHeightCombo . getSelectedItem (  )  )  )  . intValue (  )  )  ;", "if    ( nativeRadio . isSelected (  )  )", "unicodeFont . setRenderType ( UnicodeFont . RenderType . Native )  ;", "else", "if    ( freeTypeRadio . isSelected (  )  )", "unicodeFont . setRenderType ( UnicodeFont . RenderType . FreeType )  ;", "else", "unicodeFont . setRenderType ( UnicodeFont . RenderType . Java )  ;", "for    ( Iterator   iter    =    effectPanels . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "HEffectPanel   panel    =     (  ( HEffectPanel )     ( iter . next (  )  )  )  ;", "unicodeFont . getEffects (  )  . add ( panel . getEffect (  )  )  ;", "}", "int   size    =    sampleTextPane . getFont (  )  . getSize (  )  ;", "if    ( size    <     1  4  )", "size    =     1  4  ;", "sampleTextPane . setFont ( unicodeFont . getFont (  )  . deriveFont (  (  ( float )     ( size )  )  )  )  ;", "if    (  ( this . unicodeFont )     !  =    null )", "this . unicodeFont . dispose (  )  ;", "this . unicodeFont    =    unicodeFont ;", "updateFontSelector (  )  ;", "}", "METHOD_END"], "methodName": ["updateFont"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "final   boolean   useFile    =    fontFileRadio . isSelected (  )  ;", "fontList . setEnabled (  (  ! useFile )  )  ;", "fontFileText . setEnabled ( useFile )  ;", "browseButton . setEnabled ( useFile )  ;", "}", "METHOD_END"], "methodName": ["updateFontSelector"], "fileName": "com.badlogic.gdx.tools.hiero.Hiero"}, {"methodBody": ["METHOD_START", "{", "return   effects ;", "}", "METHOD_END"], "methodName": ["getEffects"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   font 2 File ;", "}", "METHOD_END"], "methodName": ["getFont2File"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   fontName ;", "}", "METHOD_END"], "methodName": ["getFontName"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   fontSize ;", "}", "METHOD_END"], "methodName": ["getFontSize"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   gamma ;", "}", "METHOD_END"], "methodName": ["getGamma"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   glyphPageHeight ;", "}", "METHOD_END"], "methodName": ["getGlyphPageHeight"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   glyphPageWidth ;", "}", "METHOD_END"], "methodName": ["getGlyphPageWidth"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   this . glyphText . replace (  \"  \\  \\ n \"  ,     \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["getGlyphText"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   nativeRendering ;", "}", "METHOD_END"], "methodName": ["getNativeRendering"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   paddingAdvanceX ;", "}", "METHOD_END"], "methodName": ["getPaddingAdvanceX"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   paddingAdvanceY ;", "}", "METHOD_END"], "methodName": ["getPaddingAdvanceY"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   paddingBottom ;", "}", "METHOD_END"], "methodName": ["getPaddingBottom"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   paddingLeft ;", "}", "METHOD_END"], "methodName": ["getPaddingLeft"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   paddingRight ;", "}", "METHOD_END"], "methodName": ["getPaddingRight"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   paddingTop ;", "}", "METHOD_END"], "methodName": ["getPaddingTop"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   renderType ;", "}", "METHOD_END"], "methodName": ["getRenderType"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   bold ;", "}", "METHOD_END"], "methodName": ["isBold"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   font 2 Active ;", "}", "METHOD_END"], "methodName": ["isFont2Active"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   italic ;", "}", "METHOD_END"], "methodName": ["isItalic"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   mono ;", "}", "METHOD_END"], "methodName": ["isMono"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "PrintStream   out    =    new   PrintStream ( file ,     \" UTF -  8  \"  )  ;", "out . println (  (  \" font . name =  \"     +     ( fontName )  )  )  ;", "out . println (  (  \" font . size =  \"     +     ( fontSize )  )  )  ;", "out . println (  (  \" font . bold =  \"     +     ( bold )  )  )  ;", "out . println (  (  \" font . italic =  \"     +     ( italic )  )  )  ;", "out . println (  (  \" font . gamma =  \"     +     ( gamma )  )  )  ;", "out . println (  (  \" font . mono =  \"     +     ( mono )  )  )  ;", "out . println (  )  ;", "out . println (  (  \" font 2  . file =  \"     +     ( font 2 File )  )  )  ;", "out . println (  (  \" font 2  . use =  \"     +     ( font 2 Active )  )  )  ;", "out . println (  )  ;", "out . println (  (  \" pad . top =  \"     +     ( paddingTop )  )  )  ;", "out . println (  (  \" pad . right =  \"     +     ( paddingRight )  )  )  ;", "out . println (  (  \" pad . bottom =  \"     +     ( paddingBottom )  )  )  ;", "out . println (  (  \" pad . left =  \"     +     ( paddingLeft )  )  )  ;", "out . println (  (  \" pad . advance . x =  \"     +     ( paddingAdvanceX )  )  )  ;", "out . println (  (  \" pad . advance . y =  \"     +     ( paddingAdvanceY )  )  )  ;", "out . println (  )  ;", "out . println (  (  \" glyph . native . rendering =  \"     +     ( nativeRendering )  )  )  ;", "out . println (  (  \" glyph . page . width =  \"     +     ( glyphPageWidth )  )  )  ;", "out . println (  (  \" glyph . page . height =  \"     +     ( glyphPageHeight )  )  )  ;", "out . println (  (  \" glyph . text =  \"     +     ( glyphText )  )  )  ;", "out . println (  )  ;", "out . println (  (  (  (  . RENDER _ TYPE )     +     \"  =  \"  )     +     ( renderType )  )  )  ;", "out . println (  )  ;", "for    ( Iterator   iter    =    effects . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "ConfigurableEffect   effect    =     (  ( ConfigurableEffect )     ( iter . next (  )  )  )  ;", "out . println (  (  \" effect . class =  \"     +     ( effect . getClass (  )  . getName (  )  )  )  )  ;", "for    ( Iterator   iter 2     =    effect . getValues (  )  . iterator (  )  ;    iter 2  . hasNext (  )  ;  )     {", "ConfigurableEffect . Value   value    =     (  ( ConfigurableEffect . Value )     ( iter 2  . next (  )  )  )  ;", "out . println (  (  (  (  \" effect .  \"     +     ( value . getName (  )  )  )     +     \"  =  \"  )     +     ( value . getString (  )  )  )  )  ;", "}", "out . println (  )  ;", "}", "out . close (  )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . bold    =    bold ;", "}", "METHOD_END"], "methodName": ["setBold"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . font 2 Active    =    active ;", "}", "METHOD_END"], "methodName": ["setFont2Active"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . font 2 File    =    filename ;", "}", "METHOD_END"], "methodName": ["setFont2File"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . fontName    =    fontName ;", "}", "METHOD_END"], "methodName": ["setFontName"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . fontSize    =    fontSize ;", "}", "METHOD_END"], "methodName": ["setFontSize"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . gamma    =    gamma ;", "}", "METHOD_END"], "methodName": ["setGamma"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . glyphPageHeight    =    glyphPageHeight ;", "}", "METHOD_END"], "methodName": ["setGlyphPageHeight"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . glyphPageWidth    =    glyphPageWidth ;", "}", "METHOD_END"], "methodName": ["setGlyphPageWidth"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . glyphText    =    text . replace (  \"  \\ n \"  ,     \"  \\  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["setGlyphText"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . italic    =    italic ;", "}", "METHOD_END"], "methodName": ["setItalic"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . mono    =    mono ;", "}", "METHOD_END"], "methodName": ["setMono"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . nativeRendering    =    nativeRendering ;", "}", "METHOD_END"], "methodName": ["setNativeRendering"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . paddingAdvanceX    =    paddingAdvanceX ;", "}", "METHOD_END"], "methodName": ["setPaddingAdvanceX"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . paddingAdvanceY    =    paddingAdvanceY ;", "}", "METHOD_END"], "methodName": ["setPaddingAdvanceY"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . paddingBottom    =    paddingBottom ;", "}", "METHOD_END"], "methodName": ["setPaddingBottom"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . paddingLeft    =    paddingLeft ;", "}", "METHOD_END"], "methodName": ["setPaddingLeft"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . paddingRight    =    paddingRight ;", "}", "METHOD_END"], "methodName": ["setPaddingRight"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . paddingTop    =    paddingTop ;", "}", "METHOD_END"], "methodName": ["setPaddingTop"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "this . renderType    =    renderType ;", "}", "METHOD_END"], "methodName": ["setRenderType"], "fileName": "com.badlogic.gdx.tools.hiero.HieroSettings"}, {"methodBody": ["METHOD_START", "{", "return   kernings ;", "}", "METHOD_END"], "methodName": ["getKernings"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "if    ( inputStream    =  =    null )", "throw   new   IllegalArgumentException (  \" inputStream   cannot   be   null .  \"  )  ;", "input    =    new    . TTFInputStream ( inputStream )  ;", "inputStream . close (  )  ;", "readTableDirectory (  )  ;", "if    (  ( headOffset )     =  =     (  -  1  )  )", "throw   new   IOException (  \" HEAD   table   not   found .  \"  )  ;", "readHEAD ( fontSize )  ;", "if    (  ( gposOffset )     !  =     (  -  1  )  )     {", "input . seek ( gposOffset )  ;", "readGPOS (  )  ;", "}", "if    (  ( kernOffset )     !  =     (  -  1  )  )     {", "input . seek ( kernOffset )  ;", "readKERN (  )  ;", "}", "input . close (  )  ;", "input    =    null ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "input . seek ( position )  ;", "IntArray [  ]    glyphsByClass    =    new   IntArray [ classCount ]  ;", "for    ( int   i    =     0  ;    i    <    classCount ;    i +  +  )     {", "glyphsByClass [ i ]     =    new   IntArray (  )  ;", "}", "int   classFormat    =    input . readUnsignedShort (  )  ;", "if    ( classFormat    =  =     1  )     {", "readClassDefinitionFormat 1  ( glyphsByClass )  ;", "} else", "if    ( classFormat    =  =     2  )     {", "readClassDefinitionFormat 2  ( glyphsByClass )  ;", "} else    {", "throw   new   IOException (  (  \" Unknown   class   definition   table   type    \"     +    classFormat )  )  ;", "}", "return   glyphsByClass ;", "}", "METHOD_END"], "methodName": ["readClassDefinition"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   startGlyph    =    input . readUnsignedShort (  )  ;", "int   glyphCount    =    input . readUnsignedShort (  )  ;", "int [  ]    classValueArray    =    input . readUnsignedShortArray ( glyphCount )  ;", "for    ( int   i    =     0  ;    i    <    glyphCount ;    i +  +  )     {", "int   glyph    =    startGlyph    +    i ;", "int   glyphClass    =    classValueArray [ i ]  ;", "if    ( glyphClass    <     ( glyphsByClass . length )  )     {", "glyphsByClass [ glyphClass ]  . add ( glyph )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readClassDefinitionFormat1"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   classRangeCount    =    input . readUnsignedShort (  )  ;", "for    ( int   i    =     0  ;    i    <    classRangeCount ;    i +  +  )     {", "int   start    =    input . readUnsignedShort (  )  ;", "int   end    =    input . readUnsignedShort (  )  ;", "int   glyphClass    =    input . readUnsignedShort (  )  ;", "if    ( glyphClass    <     ( glyphsByClass . length )  )     {", "for    ( int   glyph    =    start ;    glyph    <  =    end ;    glyph +  +  )     {", "glyphsByClass [ glyphClass ]  . add ( glyph )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["readClassDefinitionFormat2"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   format    =    input . readUnsignedShort (  )  ;", "if    ( format    =  =     1  )     {", "int   glyphCount    =    input . readUnsignedShort (  )  ;", "int [  ]    glyphArray    =    input . readUnsignedShortArray ( glyphCount )  ;", "return   glyphArray ;", "} else", "if    ( format    =  =     2  )     {", "int   rangeCount    =    input . readUnsignedShort (  )  ;", "utils . IntArray   glyphArray    =    new   utils . IntArray (  )  ;", "for    ( int   i    =     0  ;    i    <    rangeCount ;    i +  +  )     {", "int   start    =    input . readUnsignedShort (  )  ;", "int   end    =    input . readUnsignedShort (  )  ;", "input . skip (  2  )  ;", "for    ( int   glyph    =    start ;    glyph    <  =    end ;    glyph +  +  )     {", "glyphArray . add ( glyph )  ;", "}", "}", "return   glyphArray . shrink (  )  ;", "}", "throw   new   IOException (  (  \" Unknown   coverage   table   format    \"     +    format )  )  ;", "}", "METHOD_END"], "methodName": ["readCoverageTable"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   lookupType    =    input . readUnsignedShort (  )  ;", "int   lookupPosition    =    subTablePosition    +     (  ( int )     ( input . readUnsignedLong (  )  )  )  ;", "readSubtable ( lookupType ,    lookupPosition )  ;", "}", "METHOD_END"], "methodName": ["readExtensionPositioningFormat1"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   type    =    input . readUnsignedShort (  )  ;", "if    ( type    =  =     1  )     {", "readExtensionPositioFormat 1  ( subTablePosition )  ;", "}", "}", "METHOD_END"], "methodName": ["readExtensionPositioningSubtable"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "input . seek (  (  (  (  ( gposOffset )     +     4  )     +     2  )     +     2  )  )  ;", "int   lookupListOffset    =    input . readUnsignedShort (  )  ;", "input . seek (  (  ( gposOffset )     +    lookupListOffset )  )  ;", "int   lookupListPosition    =    input . getPosition (  )  ;", "int   lookupCount    =    input . readUnsignedShort (  )  ;", "int [  ]    lookupOffsets    =    input . readUnsignedShortArray ( lookupCount )  ;", "for    ( int   i    =     0  ;    i    <    lookupCount ;    i +  +  )     {", "int   lookupPosition    =    lookupListPosition    +     ( lookupOffsets [ i ]  )  ;", "input . seek ( lookupPosition )  ;", "int   type    =    input . readUnsignedShort (  )  ;", "readSubtables ( type ,    lookupPosition )  ;", "}", "}", "METHOD_END"], "methodName": ["readGPOS"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "input . seek (  (  (  (  ( headOffset )     +     (  2     *     4  )  )     +     (  2     *     4  )  )     +     2  )  )  ;", "int   unitsPerEm    =    input . readUnsignedShort (  )  ;", "scale    =     (  ( float )     ( fontSize )  )     /    unitsPerEm ;", "}", "METHOD_END"], "methodName": ["readHEAD"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "input . seek (  (  ( kernOffset )     +     2  )  )  ;", "for    ( int   subTableCount    =    input . readUnsignedShort (  )  ;    subTableCount    >     0  ;    subTableCount -  -  )     {", "input . skip (  (  2     *     2  )  )  ;", "int   tupleIndex    =    input . readUnsignedShort (  )  ;", "if    (  (  (  !  (  ( tupleIndex    &     1  )     !  =     0  )  )     |  |     (  ( tupleIndex    &     2  )     !  =     0  )  )     |  |     (  ( tupleIndex    &     4  )     !  =     0  )  )", "return ;", "if    (  ( tupleIndex    >  >     8  )     !  =     0  )", "continue ;", "int   kerningCount    =    input . readUnsignedShort (  )  ;", "input . skip (  (  3     *     2  )  )  ;", "while    (  ( kerningCount -  -  )     >     0  )     {", "int   firstGlyphCode    =    input . readUnsignedShort (  )  ;", "int   secondGlyphCode    =    input . readUnsignedShort (  )  ;", "int   offset    =     (  ( int )     ( input . readShort (  )  )  )  ;", "storeOffset ( firstGlyphCode ,    secondGlyphCode ,    offset )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readKERN"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   type    =    input . readUnsignedShort (  )  ;", "if    ( type    =  =     1  )     {", "readPairPositioAdjustmentFormat 1  ( subTablePosition )  ;", "} else", "if    ( type    =  =     2  )     {", "readPairPositioAdjustmentFormat 2  ( subTablePosition )  ;", "}", "}", "METHOD_END"], "methodName": ["readPairAdjustmentSubtable"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   coverageOffset    =    input . readUnsignedShort (  )  ;", "int   valueFormat 1     =    input . readUnsignedShort (  )  ;", "int   valueFormat 2     =    input . readUnsignedShort (  )  ;", "int   pairSetCount    =    input . readUnsignedShort (  )  ;", "int [  ]    pairSetOffsets    =    input . readUnsignedShortArray ( pairSetCount )  ;", "input . seek (  (  ( int )     ( subTablePosition    +    coverageOffset )  )  )  ;", "int [  ]    coverage    =    readCoverageTable (  )  ;", "pairSetCount    =    Math . min ( pairSetCount ,    coverage . length )  ;", "for    ( int   i    =     0  ;    i    <    pairSetCount ;    i +  +  )     {", "int   firstGlyph    =    coverage [ i ]  ;", "input . seek (  (  ( int )     ( subTablePosition    +     ( pairSetOffsets [ i ]  )  )  )  )  ;", "int   pairValueCount    =    input . readUnsignedShort (  )  ;", "for    ( int   j    =     0  ;    j    <    pairValueCount ;    j +  +  )     {", "int   secondGlyph    =    input . readUnsignedShort (  )  ;", "int   xAdvance 1     =    readXAdvanceFromValueRecord ( valueFormat 1  )  ;", "readXAdvanceFromValueRecord ( valueFormat 2  )  ;", "if    ( xAdvance 1     !  =     0  )     {", "storeOffset ( firstGlyph ,    secondGlyph ,    xAdvance 1  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["readPairPositioningAdjustmentFormat1"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   coverageOffset    =    input . readUnsignedShort (  )  ;", "int   valueFormat 1     =    input . readUnsignedShort (  )  ;", "int   valueFormat 2     =    input . readUnsignedShort (  )  ;", "int   classDefOffset 1     =    input . readUnsignedShort (  )  ;", "int   classDefOffset 2     =    input . readUnsignedShort (  )  ;", "int   class 1 Count    =    input . readUnsignedShort (  )  ;", "int   class 2 Count    =    input . readUnsignedShort (  )  ;", "int   position    =    input . getPosition (  )  ;", "input . seek (  (  ( int )     ( subTablePosition    +    coverageOffset )  )  )  ;", "int [  ]    coverage    =    readCoverageTable (  )  ;", "input . seek ( position )  ;", "IntArray [  ]    glyphsByClass 1     =    readClassDefinition (  ( subTablePosition    +    classDefOffset 1  )  ,    class 1 Count )  ;", "IntArray [  ]    glyphsByClass 2     =    readClassDefinition (  ( subTablePosition    +    classDefOffset 2  )  ,    class 2 Count )  ;", "input . seek ( position )  ;", "for    ( int   i    =     0  ;    i    <     ( coverage . length )  ;    i +  +  )     {", "int   glyph    =    coverage [ i ]  ;", "boolean   found    =    false ;", "for    ( int   j    =     1  ;     ( j    <    class 1 Count )     &  &     (  ! found )  ;    j +  +  )     {", "found    =    glyphsByClass 1  [ j ]  . contains ( glyph )  ;", "}", "if    (  ! found )     {", "glyphsByClass 1  [  0  ]  . add ( glyph )  ;", "}", "}", "for    ( int   i    =     0  ;    i    <    class 1 Count ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    class 2 Count ;    j +  +  )     {", "int   xAdvance 1     =    readXAdvanceFromValueRecord ( valueFormat 1  )  ;", "readXAdvanceFromValueRecord ( valueFormat 2  )  ;", "if    ( xAdvance 1     =  =     0  )", "continue ;", "for    ( int   k    =     0  ;    k    <     ( glyphsByClass 1  [ i ]  . size )  ;    k +  +  )     {", "int   glyph 1     =    glyphsByClass 1  [ i ]  . items [ k ]  ;", "for    ( int   l    =     0  ;    l    <     ( glyphsByClass 2  [ j ]  . size )  ;    l +  +  )     {", "int   glyph 2     =    glyphsByClass 2  [ j ]  . items [ l ]  ;", "storeOffset ( glyph 1  ,    glyph 2  ,    xAdvance 1  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["readPairPositioningAdjustmentFormat2"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "input . seek ( subTablePosition )  ;", "if    ( type    =  =     2  )     {", "readPairAdjustmentSubtable ( subTablePosition )  ;", "} else", "if    ( type    =  =     9  )     {", "readExtensionPositioSubtable ( subTablePosition )  ;", "}", "}", "METHOD_END"], "methodName": ["readSubtable"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "input . skip (  2  )  ;", "int   subTableCount    =    input . readUnsignedShort (  )  ;", "int [  ]    subTableOffsets    =    input . readUnsignedShortArray ( subTableCount )  ;", "for    ( int   i    =     0  ;    i    <    subTableCount ;    i +  +  )     {", "int   subTablePosition    =    lookupPosition    +     ( subTableOffsets [ i ]  )  ;", "readSubtable ( type ,    subTablePosition )  ;", "}", "}", "METHOD_END"], "methodName": ["readSubtables"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "input . skip (  4  )  ;", "int   tableCount    =    input . readUnsignedShort (  )  ;", "input . skip (  6  )  ;", "byte [  ]    tagBytes    =    new   byte [  4  ]  ;", "for    ( int   i    =     0  ;    i    <    tableCount ;    i +  +  )     {", "tagBytes [  0  ]     =    input . readByte (  )  ;", "tagBytes [  1  ]     =    input . readByte (  )  ;", "tagBytes [  2  ]     =    input . readByte (  )  ;", "tagBytes [  3  ]     =    input . readByte (  )  ;", "input . skip (  4  )  ;", "int   offset    =     (  ( int )     ( input . readUnsignedLong (  )  )  )  ;", "input . skip (  4  )  ;", "Str   tag    =    new   Str ( tagBytes ,     \" ISO -  8  8  5  9  -  1  \"  )  ;", "if    ( tag . equals (  \" head \"  )  )     {", "headOffset    =    offset ;", "} else", "if    ( tag . equals (  \" kern \"  )  )     {", "kernOffset    =    offset ;", "} else", "if    ( tag . equals (  \" GPOS \"  )  )     {", "gposOffset    =    offset ;", "}", "}", "}", "METHOD_END"], "methodName": ["readTableDirectory"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   xAdvance    =     0  ;", "for    ( int   mask    =     1  ;     ( mask    <  =     3  2  7  6  8  )     &  &     ( mask    <  =    valueFormat )  ;    mask    <  <  =     1  )     {", "if    (  ( valueFormat    &    mask )     !  =     0  )     {", "int   value    =     (  ( int )     ( input . readShort (  )  )  )  ;", "if    ( mask    =  =     4  )     {", "xAdvance    =    value ;", "}", "}", "}", "return   xAdvance ;", "}", "METHOD_END"], "methodName": ["readXAdvanceFromValueRecord"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "int   value    =    Math . round (  ( offset    *     ( scale )  )  )  ;", "if    ( value    =  =     0  )     {", "return ;", "}", "int   key    =     ( firstGlyphCode    <  <     1  6  )     |    secondGlyphCode ;", "ks . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["storeKerningOffset"], "fileName": "com.badlogic.gdx.tools.hiero.Kerning"}, {"methodBody": ["METHOD_START", "{", "return   codePoint ;", "}", "METHOD_END"], "methodName": ["getCodePoint"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   shape ;", "}", "METHOD_END"], "methodName": ["getShape"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   texture ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   u ;", "}", "METHOD_END"], "methodName": ["getU"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   u 2  ;", "}", "METHOD_END"], "methodName": ["getU2"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   v ;", "}", "METHOD_END"], "methodName": ["getV"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   v 2  ;", "}", "METHOD_END"], "methodName": ["getV2"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   xAdvance ;", "}", "METHOD_END"], "methodName": ["getXAdvance"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   xOffset ;", "}", "METHOD_END"], "methodName": ["getXOffset"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   yOffset ;", "}", "METHOD_END"], "methodName": ["getYOffset"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   isMissing ;", "}", "METHOD_END"], "methodName": ["isMissing"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "this . shape    =    shape ;", "}", "METHOD_END"], "methodName": ["setShape"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "this . texture    =    texture ;", "this . u    =    u ;", "this . v    =    v ;", "this . u 2     =    u 2  ;", "this . v 2     =    v 2  ;", "}", "METHOD_END"], "methodName": ["setTexture"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.Glyph"}, {"methodBody": ["METHOD_START", "{", "return   pageGlyphs ;", "}", "METHOD_END"], "methodName": ["getGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.GlyphPage"}, {"methodBody": ["METHOD_START", "{", "return   texture ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.GlyphPage"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glColor 4 f (  1  ,     1  ,     1  ,     1  )  ;", "texture . bind (  )  ;", "int   loadedCount    =     0  ;", "for    ( Iterator   iter    =    glyphs . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Glyph   glyph    =     (  ( Glyph )     ( iter . next (  )  )  )  ;", "int   width    =    Math . min (  . MAX _ GLYPH _ SIZE ,    glyph . getWidth (  )  )  ;", "int   height    =    Math . min (  . MAX _ GLYPH _ SIZE ,    glyph . getHeight (  )  )  ;", "if    (  ( width    =  =     0  )     |  |     ( height    =  =     0  )  )", "pageGlyphs . add ( glyph )  ;", "else    {", ". Row   bestRow    =    null ;", "for    ( int   ii    =     0  ,    nn    =     ( rows . size )     -     1  ;    ii    <    nn ;    ii +  +  )     {", ". Row   row    =    rows . get ( ii )  ;", "if    (  (  ( row . x )     +    width )     >  =     ( pageWidth )  )", "continue ;", "if    (  (  ( row . y )     +    height )     >  =     ( pageHeight )  )", "continue ;", "if    ( height    >     ( row . height )  )", "continue ;", "if    (  ( bestRow    =  =    null )     |  |     (  ( row . height )     <     ( bestRow . height )  )  )", "bestRow    =    row ;", "}", "if    ( bestRow    =  =    null )     {", ". Row   row    =    rows . peek (  )  ;", "if    (  (  ( row . y )     +    height )     >  =     ( pageHeight )  )", "continue ;", "if    (  (  ( row . x )     +    width )     <     ( pageWidth )  )     {", "row . height    =    Math . max ( row . height ,    height )  ;", "bestRow    =    row ;", "} else", "if    (  (  (  ( row . y )     +     ( row . height )  )     +    height )     <     ( pageHeight )  )     {", "bestRow    =    new    . Row (  )  ;", "bestRow . y    =     ( row . y )     +     ( row . height )  ;", "bestRow . height    =    height ;", "rows . add ( bestRow )  ;", "}", "}", "if    ( bestRow    =  =    null )", "continue ;", "if    ( renderGlyph ( glyph ,    bestRow . x ,    bestRow . y ,    width ,    height )  )", "bestRow . x    +  =    width ;", "}", "iter . remove (  )  ;", "loadedCount +  +  ;", "if    ( loadedCount    =  =    maxGlyphsToLoad )", "break ;", "}", "return   loadedCount ;", "}", "METHOD_END"], "methodName": ["loadGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.GlyphPage"}, {"methodBody": ["METHOD_START", "{", "GlyphPage . scratchGraphics . setComposite ( AlphaComposite . Clear )  ;", "GlyphPage . scratchGraphics . fillRect (  0  ,     0  ,    GlyphPage . MAX _ GLYPH _ SIZE ,    GlyphPage . MAX _ GLYPH _ SIZE )  ;", "GlyphPage . scratchGraphics . setComposite ( AlphaComposite . SrcOver )  ;", "ByteBuffer   glyphPixels    =    GlyphPage . scratchByteBuffer ;", "int   format ;", "if    (  (  ( unicodeFont . getRenderType (  )  )     =  =     ( UnicodeFont . RenderType . FreeType )  )     &  &     (  ( unicodeFont . bitmapFont )     !  =    null )  )     {", "BitmapFontData   data    =    unicodeFont . bitmapFont . getData (  )  ;", "BitmapFont . Glyph   g    =    data . getGlyph (  (  ( char )     ( glyph . getCodePoint (  )  )  )  )  ;", "Pixmap   fontPixmap    =    unicodeFont . bitmapFont . getRegions (  )  . get ( g . page )  . getTexture (  )  . getTextureData (  )  . consumePixmap (  )  ;", "int   fontWidth    =    fontPixmap . getWidth (  )  ;", "int   padTop    =    unicodeFont . getPaddingTop (  )  ;", "int   padBottom    =    unicodeFont . getPaddingBottom (  )  ;", "int   padLeftBytes    =     ( unicodeFont . getPaddingLeft (  )  )     *     4  ;", "int   padXBytes    =    padLeftBytes    +     (  ( unicodeFont . getPaddingRight (  )  )     *     4  )  ;", "int   glyphRowBytes    =    width    *     4  ;", "int   fontRowBytes    =     ( g . width )     *     4  ;", "ByteBuffer   fontPixels    =    fontPixmap . getPixels (  )  ;", "byte [  ]    row    =    new   byte [ glyphRowBytes ]  ;", "glyphPixels . position (  0  )  ;", "for    ( int   i    =     0  ;    i    <    padTop ;    i +  +  )", "glyphPixels . put ( row )  ;", "glyphPixels . position (  (  ( height    -    padBottom )     *    glyphRowBytes )  )  ;", "for    ( int   i    =     0  ;    i    <    padBottom ;    i +  +  )", "glyphPixels . put ( row )  ;", "glyphPixels . position (  ( padTop    *    glyphRowBytes )  )  ;", "for    ( int   y    =     0  ,    n    =    g . height ;    y    <    n ;    y +  +  )     {", "fontPixels . position (  (  (  (  (  ( g . srcY )     +    y )     *    fontWidth )     +     ( g . srcX )  )     *     4  )  )  ;", "fontPixels . get ( row ,    padLeftBytes ,    fontRowBytes )  ;", "glyphPixels . put ( row )  ;", "}", "fontPixels . position (  0  )  ;", "glyphPixels . position (  ( height    *    glyphRowBytes )  )  ;", "glyphPixels . flip (  )  ;", "format    =    GL 1  1  . GL _ RGBA ;", "} else    {", "if    (  ( unicodeFont . getRenderType (  )  )     =  =     ( UnicodeFont . RenderType . Native )  )     {", "for    ( Iterator   iter    =    unicodeFont . getEffects (  )  . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Effect   effect    =     (  ( Effect )     ( iter . next (  )  )  )  ;", "if    ( effect   instanceof   ColorEffect )", "GlyphPage . scratchGraphics . setColor (  (  ( ColorEffect )     ( effect )  )  . getColor (  )  )  ;", "}", "GlyphPage . scratchGraphics . setColor ( Color . white )  ;", "GlyphPage . scratchGraphics . setFont ( unicodeFont . getFont (  )  )  ;", "GlyphPage . scratchGraphics . drawString (  (  \"  \"     +     (  ( char )     ( glyph . getCodePoint (  )  )  )  )  ,     0  ,    unicodeFont . getAscent (  )  )  ;", "} else", "if    (  ( unicodeFont . getRenderType (  )  )     =  =     ( UnicodeFont . RenderType . Java )  )     {", "GlyphPage . scratchGraphics . setColor ( Color . white )  ;", "for    ( Iterator   iter    =    unicodeFont . getEffects (  )  . iterator (  )  ;    iter . hasNext (  )  ;  )", "(  ( Effect )     ( iter . next (  )  )  )  . draw ( GlyphPage . scratchImage ,    GlyphPage . scratchGraphics ,    unicodeFont ,    glyph )  ;", "glyph . setShape ( null )  ;", "}", "width    =    Math . min ( width ,    texture . getWidth (  )  )  ;", "height    =    Math . min ( height ,    texture . getHeight (  )  )  ;", "WritableRaster   raster    =    GlyphPage . scratchImage . getRaster (  )  ;", "int [  ]    row    =    new   int [ width ]  ;", "for    ( int   y    =     0  ;    y    <    height ;    y +  +  )     {", "raster . getDataElements (  0  ,    y ,    width ,     1  ,    row )  ;", "GlyphPage . scratchIntBuffer . put ( row )  ;", "}", "format    =    GL 1  2  . GL _ BGRA ;", "}", "String   hash    =     \"  \"  ;", "try    {", "MessageDigest   md    =    MessageDigest . getInstance (  \" SHA -  2  5  6  \"  )  ;", "md . update ( glyphPixels )  ;", "BigInteger   bigInt    =    new   BigInteger (  1  ,    md . digest (  )  )  ;", "hash    =    bigInt . toString (  1  6  )  ;", "}    catch    ( NoSuchAlgorithmException   ex )     {", "}", "GlyphPage . scratchByteBuffer . clear (  )  ;", "GlyphPage . scratchIntBuffer . clear (  )  ;", "try    {", "for    ( int   i    =     0  ,    n    =    hashes . size (  )  ;    i    <    n ;    i +  +  )     {", "String   other    =    hashes . get ( i )  ;", "if    ( other . equals ( hash )  )     {", "Glyph   dupe    =    pageGlyphs . get ( i )  ;", "glyph . setTexture ( dupe . texture ,    dupe . u ,    dupe . v ,    dupe . u 2  ,    dupe . v 2  )  ;", "return   false ;", "}", "}", "}    finally    {", "hashes . add ( hash )  ;", "pageGlyphs . add ( glyph )  ;", "}", "gl . glTexSubImage 2 D ( texture . glTarget ,     0  ,    pageX ,    pageY ,    width ,    height ,    format ,    GL _ UNSIGNED _ BYTE ,    glyphPixels )  ;", "float   u    =    pageX    /     (  ( float )     ( texture . getWidth (  )  )  )  ;", "float   v    =    pageY    /     (  ( float )     ( texture . getHeight (  )  )  )  ;", "float   u 2     =     ( pageX    +    width )     /     (  ( float )     ( texture . getWidth (  )  )  )  ;", "float   v 2     =     ( pageY    +    height )     /     (  ( float )     ( texture . getHeight (  )  )  )  ;", "glyph . setTexture ( texture ,    u ,    v ,    u 2  ,    v 2  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["renderGlyph"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.GlyphPage"}, {"methodBody": ["METHOD_START", "{", "addGlyphs (  3  2  ,     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["addAsciiGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "for    ( int   codePoint    =    startCodePoint ;    codePoint    <  =    endCodePoint ;    codePoint +  +  )", "addGlyphs ( new   String ( Character . toChars ( codePoint )  )  )  ;", "}", "METHOD_END"], "methodName": ["addGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "throw   new   IllegalArgumentException (  \" text   cannot   be   null .  \"  )  ;", "char [  ]    chars    =    text . toCharArray (  )  ;", "GlyphVector   vector    =    layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,    Font . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "for    ( int   i    =     0  ,    n    =    vector . getNumGlyphs (  )  ;    i    <    n ;    i +  +  )     {", "int   codePoint    =    text . codePointAt ( vector . getGlyphCharIndex ( i )  )  ;", "Rectangle   bounds    =    getGlyphBounds ( vector ,    i ,    codePoint )  ;", "getGlyph ( vector . getGlyphCode ( i )  ,    codePoint ,    bounds ,    vector ,    i )  ;", "}", "}", "METHOD_END"], "methodName": ["addGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "addGlyphs (  3  2  ,     (  3  2     +     9  6  )  )  ;", "}", "METHOD_END"], "methodName": ["addNeheGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Font . creat ( Font . TRUETYPE _ FONT ,    files . absolute ( ttfFileRef )  . read (  )  )  ;", "}    catch    ( FontFormatException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Invalid   font :     \"     +    ttfFileRef )  ,    ex )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   font :     \"     +    ttfFileRef )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createFont"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator   iter    =    glyphPages . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "GlyphPage   page    =     (  ( GlyphPage )     ( iter . next (  )  )  )  ;", "page . getTexture (  )  . dispose (  )  ;", "}", "if    (  ( bitmap )     !  =    null )     {", "bitmap . dispose (  )  ;", "generator . dispose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "BitmapFontData   data    =    bitmapFont . getData (  )  ;", "int   padY    =     (  ( paddingTop )     +     ( paddingBottom )  )     +     ( paddingAdvanceY )  ;", "data . setLineHeight (  (  ( data . lineHeight )     +    padY )  )  ;", "layout . setText ( bitmapFont ,    text )  ;", "data . setLineHeight (  (  ( data . lineHeight )     -    padY )  )  ;", "for    ( GlyphRun   run    :    layout . runs )", "for    ( int   i    =     0  ,    n    =    run . xAdvances . size ;    i    <    n ;    i +  +  )", "run . xAdvances . incr ( i ,     (  (  ( paddingAdvanceX )     +     ( paddingLeft )  )     +     ( paddingRight )  )  )  ;", "cache . setText ( layout ,    paddingLeft ,    paddingRight )  ;", "Array < TextureRegion >    regions    =    bitmapFont . getRegions (  )  ;", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )     {", "regions . get ( i )  . getTexture (  )  . bind (  )  ;", "GL 1  1  . glBegin ( GL _ QUADS )  ;", "float [  ]    vertices    =    cache . getVertices ( i )  ;", "for    ( int   ii    =     0  ,    nn    =    vertices . length ;    ii    <    nn ;    ii    +  =     2  0  )     {", "GL 1  1  . glTexCoord 2 f ( vertices [  ( ii    +     (  . U )  )  ]  ,    vertices [  ( ii    +     (  . V )  )  ]  )  ;", "GL 1  1  . glVertex 3 f ( vertices [  ( ii    +     (  . X )  )  ]  ,    vertices [  ( ii    +     (  . Y )  )  ]  ,     0  )  ;", "GL 1  1  . glTexCoord 2 f ( vertices [  ( ii    +     (  . U )  )  ]  ,    vertices [  ( ii    +     (  . V 2  )  )  ]  )  ;", "GL 1  1  . glVertex 3 f ( vertices [  ( ii    +     (  . X )  )  ]  ,    vertices [  ( ii    +     (  . Y 2  )  )  ]  ,     0  )  ;", "GL 1  1  . glTexCoord 2 f ( vertices [  ( ii    +     (  . U 2  )  )  ]  ,    vertices [  ( ii    +     (  . V 2  )  )  ]  )  ;", "GL 1  1  . glVertex 3 f ( vertices [  ( ii    +     (  . X 2  )  )  ]  ,    vertices [  ( ii    +     (  . Y 2  )  )  ]  ,     0  )  ;", "GL 1  1  . glTexCoord 2 f ( vertices [  ( ii    +     (  . U 2  )  )  ]  ,    vertices [  ( ii    +     (  . V )  )  ]  )  ;", "GL 1  1  . glVertex 3 f ( vertices [  ( ii    +     (  . X 2  )  )  ]  ,    vertices [  ( ii    +     (  . Y )  )  ]  ,     0  )  ;", "}", "GL 1  1  . glEnd (  )  ;", "}", "}", "METHOD_END"], "methodName": ["drawBitmap"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "drawString ( x ,    y ,    text ,    WHITE )  ;", "}", "METHOD_END"], "methodName": ["drawString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "drawString ( x ,    y ,    text ,    col ,     0  ,    text . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "throw   new   IllegalArgumentException (  \" text   cannot   be   null .  \"  )  ;", "if    (  ( text . length (  )  )     =  =     0  )", "return ;", "if    ( color    =  =    null )", "throw   new   IllegalArgumentException (  \" color   cannot   be   null .  \"  )  ;", "x    -  =    paddingLeft ;", "y    -  =    paddingTop ;", "GL 1  1  . glColor 4 f ( color . r ,    color . g ,    color . b ,    color . a )  ;", "GL 1  1  . glTranslatef ( x ,    y ,     0  )  ;", "if    (  (  ( renderType )     =  =     (  . RenderType . FreeType )  )     &  &     (  ( bitmapFont )     !  =    null )  )", "drawBitmap ( text ,    startIndex ,    endIndex )  ;", "else", "drawUnicode ( text ,    startIndex ,    endIndex )  ;", "GL 1  1  . glTranslatef (  (  - x )  ,     (  - y )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["drawString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "char [  ]    chars    =    text . substring (  0  ,    endIndex )  . toCharArray (  )  ;", "GlyphVector   vector    =    font . layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,    Font . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "int   maxWidth    =     0  ;", "int   totalHeight    =     0  ;", "int   lines    =     0  ;", "int   extraX    =     0  ;", "int   extraY    =    ascent ;", "boolean   startNewLine    =    false ;", "Texture   lastBind    =    null ;", "int   offsetX    =     0  ;", "for    ( int   glyphIndex    =     0  ,    n    =    vector . getNumGlyphs (  )  ;    glyphIndex    <    n ;    glyphIndex +  +  )     {", "int   charIndex    =    vector . getGlyphCharIndex ( glyphIndex )  ;", "if    ( charIndex    <    startIndex )", "continue ;", "if    ( charIndex    >    endIndex )", "break ;", "int   codePoint    =    text . codePointAt ( charIndex )  ;", "Rectangle   bounds    =    getGlyphBounds ( vector ,    glyphIndex ,    codePoint )  ;", "bounds . x    +  =    offsetX ;", "Glyph   glyph    =    getGlyph ( vector . getGlyphCode ( glyphIndex )  ,    codePoint ,    bounds ,    vector ,    glyphIndex )  ;", "if    ( startNewLine    &  &     ( codePoint    !  =     '  \\ n '  )  )     {", "extraX    =     -  ( bounds . x )  ;", "startNewLine    =    false ;", "}", "if    (  (  (  ( glyph . getTexture (  )  )     =  =    null )     &  &     (  ( missingGlyph )     !  =    null )  )     &  &     ( glyph . isMissing (  )  )  )", "glyph    =    missingGlyph ;", "if    (  ( glyph . getTexture (  )  )     !  =    null )     {", "Texture   texture    =    glyph . getTexture (  )  ;", "if    (  ( lastBind    !  =    null )     &  &     ( lastBind    !  =    texture )  )     {", "GL 1  1  . glEnd (  )  ;", "lastBind    =    null ;", "}", "if    ( lastBind    =  =    null )     {", "texture . bind (  )  ;", "GL 1  1  . glBegin ( GL _ QUADS )  ;", "lastBind    =    texture ;", "}", "int   glyphX    =     ( bounds . x )     +    extraX ;", "int   glyphY    =     ( bounds . y )     +    extraY ;", "GL 1  1  . glTexCoord 2 f ( glyph . getU (  )  ,    glyph . getV (  )  )  ;", "GL 1  1  . glVertex 3 f ( glyphX ,    glyphY ,     0  )  ;", "GL 1  1  . glTexCoord 2 f ( glyph . getU (  )  ,    glyph . getV 2  (  )  )  ;", "GL 1  1  . glVertex 3 f ( glyphX ,     ( glyphY    +     ( glyph . getHeight (  )  )  )  ,     0  )  ;", "GL 1  1  . glTexCoord 2 f ( glyph . getU 2  (  )  ,    glyph . getV 2  (  )  )  ;", "GL 1  1  . glVertex 3 f (  ( glyphX    +     ( glyph . getWidth (  )  )  )  ,     ( glyphY    +     ( glyph . getHeight (  )  )  )  ,     0  )  ;", "GL 1  1  . glTexCoord 2 f ( glyph . getU 2  (  )  ,    glyph . getV (  )  )  ;", "GL 1  1  . glVertex 3 f (  ( glyphX    +     ( glyph . getWidth (  )  )  )  ,    glyphY ,     0  )  ;", "}", "if    ( glyphIndex    >     0  )", "extraX    +  =     (  ( paddingRight )     +     ( paddingLeft )  )     +     ( paddingAdvanceX )  ;", "maxWidth    =    Math . max ( maxWidth ,     (  (  ( bounds . x )     +    extraX )     +     ( bounds . width )  )  )  ;", "totalHeight    =    Math . max ( totalHeight ,     (  (  ( ascent )     +     ( bounds . y )  )     +     ( bounds . height )  )  )  ;", "if    ( codePoint    =  =     '  \\ n '  )     {", "startNewLine    =    true ;", "extraY    +  =    getLineHeight (  )  ;", "lines +  +  ;", "totalHeight    =     0  ;", "} else", "if    (  ( renderType )     =  =     (  . RenderType . Native )  )", "offsetX    +  =    bounds . width ;", "}", "if    ( lastBind    !  =    null )", "GL 1  1  . glEnd (  )  ;", "}", "METHOD_END"], "methodName": ["drawUnicode"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   ascent ;", "}", "METHOD_END"], "methodName": ["getAscent"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   descent ;", "}", "METHOD_END"], "methodName": ["getDescent"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   effects ;", "}", "METHOD_END"], "methodName": ["getEffects"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   font ;", "}", "METHOD_END"], "methodName": ["getFont"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ttfFileRef )     =  =    null )     {", "try    {", "Object   D ;", "try    {", "D    =    Class . forName (  \" sun . FontUtilities \"  )  . getDeclaredMethod (  \" getFont 2 D \"  ,    new   Class [  ]  {    Font . class    }  )  . invoke ( null ,    new   Object [  ]  {     }  )  ;", "}    catch    ( Throwable   ignored )     {", "D    =    Class . forName (  \" sun . FontManager \"  )  . getDeclaredMethod (  \" getFont 2 D \"  ,    new   Class [  ]  {    Font . class    }  )  . invoke ( null ,    new   Object [  ]  {     }  )  ;", "}", "Field   platNameField    =    Class . forName (  \" sun . PhysicalFont \"  )  . getDeclaredField (  \" platName \"  )  ;", "platNameField . setAccessible ( true )  ;", "ttfFileRef    =     (  ( String )     ( platNameField . get ( D )  )  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "if    (  ( ttfFileRef )     =  =    null )", "ttfFileRef    =     \"  \"  ;", "}", "if    (  ( ttfFileRef . length (  )  )     =  =     0  )", "return   null ;", "return   ttfFileRef ;", "}", "METHOD_END"], "methodName": ["getFontFile"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   gamma ;", "}", "METHOD_END"], "methodName": ["getGamma"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    (  ( glyphCode    <     0  )     |  |     ( glyphCode    >  =     ( UnicodeFont . MAX _ GLYPH _ CODE )  )  )     {", "return   new   Glyph ( codePoint ,    bounds ,    vector ,    index ,    this )     {", "public   boolean   isMissing (  )     {", "return   true ;", "}", "}  ;", "}", "int   pageIndex    =    glyphCode    /     ( UnicodeFont . PAGE _ SIZE )  ;", "int   glyphIndex    =    glyphCode    &     (  ( UnicodeFont . PAGE _ SIZE )     -     1  )  ;", "Glyph   glyph    =    null ;", "Glyph [  ]    page    =    glyphs [ pageIndex ]  ;", "if    ( page    !  =    null )     {", "glyph    =    page [ glyphIndex ]  ;", "if    ( glyph    !  =    null )", "return   glyph ;", "} else", "page    =    glyphs [ pageIndex ]     =    new   Glyph [ UnicodeFont . PAGE _ SIZE ]  ;", "glyph    =    page [ glyphIndex ]     =    new   Glyph ( codePoint ,    bounds ,    vector ,    index ,    this )  ;", "queuedGlyphs . add ( glyph )  ;", "return   glyph ;", "}", "METHOD_END"], "methodName": ["getGlyph"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "Rectangle   bounds ;", "bounds    =    vector . getGlyphPixelBounds ( index ,    GlyphPage . renderContext ,     0  ,     0  )  ;", "if    (  ( renderType )     =  =     (  . RenderType . Native )  )     {", "if    (  (  ( bounds . width )     =  =     0  )     |  |     (  ( bounds . height )     =  =     0  )  )", "bounds    =    new   Rectangle (  )  ;", "else", "bounds    =    metrics . getStringBounds (  (  \"  \"     +     (  ( char )     ( codePoint )  )  )  ,    GlyphPage . scratchGraphics )  . getBounds (  )  ;", "}", "if    ( codePoint    =  =     '     '  )", "bounds . width    =    spaceWidth ;", "return   bounds ;", "}", "METHOD_END"], "methodName": ["getGlyphBounds"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   glyphPageHeight ;", "}", "METHOD_END"], "methodName": ["getGlyphPageHeight"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   glyphPageWidth ;", "}", "METHOD_END"], "methodName": ["getGlyphPageWidth"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   glyphPages ;", "}", "METHOD_END"], "methodName": ["getGlyphPages"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "throw   new   IllegalArgumentException (  \" text   cannot   be   null .  \"  )  ;", "if    (  ( text . length (  )  )     =  =     0  )", "return    0  ;", "char [  ]    chars    =    text . toCharArray (  )  ;", "GlyphVector   vector    =    layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,    Font . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "int   lines    =     0  ;", "int   height    =     0  ;", "for    ( int   i    =     0  ,    n    =    vector . getNumGlyphs (  )  ;    i    <    n ;    i +  +  )     {", "int   charIndex    =    vector . getGlyphCharIndex ( i )  ;", "int   codePoint    =    text . codePointAt ( charIndex )  ;", "if    ( codePoint    =  =     '     '  )", "continue ;", "Rectangle   bounds    =    getGlyphBounds ( vector ,    i ,    codePoint )  ;", "height    =    Math . max ( height ,     (  (  ( ascent )     +     ( bounds . y )  )     +     ( bounds . height )  )  )  ;", "if    ( codePoint    =  =     '  \\ n '  )     {", "lines +  +  ;", "height    =     0  ;", "}", "}", "return    ( lines    *     ( getLineHeight (  )  )  )     +    height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   leading ;", "}", "METHOD_END"], "methodName": ["getLeading"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( descent )     +     ( ascent )  )     +     ( leading )  )     +     ( paddingTop )  )     +     ( paddingBottom )  )     +     ( paddingAdvanceY )  ;", "}", "METHOD_END"], "methodName": ["getLineHeight"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   mono ;", "}", "METHOD_END"], "methodName": ["getMono"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   paddingAdvanceX ;", "}", "METHOD_END"], "methodName": ["getPaddingAdvanceX"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   paddingAdvanceY ;", "}", "METHOD_END"], "methodName": ["getPaddingAdvanceY"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   paddingBottom ;", "}", "METHOD_END"], "methodName": ["getPaddingBottom"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   paddingLeft ;", "}", "METHOD_END"], "methodName": ["getPaddingLeft"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   paddingRight ;", "}", "METHOD_END"], "methodName": ["getPaddingRight"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   paddingTop ;", "}", "METHOD_END"], "methodName": ["getPaddingTop"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   renderType ;", "}", "METHOD_END"], "methodName": ["getRenderType"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   spaceWidth ;", "}", "METHOD_END"], "methodName": ["getSpaceWidth"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "throw   new   IllegalArgumentException (  \" text   cannot   be   null .  \"  )  ;", "if    (  ( text . length (  )  )     =  =     0  )", "return    0  ;", "char [  ]    chars    =    text . toCharArray (  )  ;", "GlyphVector   vector    =    layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,    Font . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "int   width    =     0  ;", "int   extraX    =     0  ;", "boolean   startNewLine    =    false ;", "for    ( int   glyphIndex    =     0  ,    n    =    vector . getNumGlyphs (  )  ;    glyphIndex    <    n ;    glyphIndex +  +  )     {", "int   charIndex    =    vector . getGlyphCharIndex ( glyphIndex )  ;", "int   codePoint    =    text . codePointAt ( charIndex )  ;", "Rectangle   bounds    =    getGlyphBounds ( vector ,    glyphIndex ,    codePoint )  ;", "if    ( startNewLine    &  &     ( codePoint    !  =     '  \\ n '  )  )", "extraX    =     -  ( bounds . x )  ;", "if    ( glyphIndex    >     0  )", "extraX    +  =     (  ( paddingLeft )     +     ( paddingRight )  )     +     ( paddingAdvanceX )  ;", "width    =    Math . max ( width ,     (  (  ( bounds . x )     +    extraX )     +     ( bounds . width )  )  )  ;", "if    ( codePoint    =  =     '  \\ n '  )", "startNewLine    =    true ;", "}", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "throw   new   IllegalArgumentException (  \" text   cannot   be   null .  \"  )  ;", "if    (  (  ( renderType )     =  =     (  . RenderType . FreeType )  )     &  &     (  ( bitmapFont )     !  =    null )  )", "return    (  ( int )     ( bitmapFont . getAscent (  )  )  )  ;", "int   index    =    text . indexOf (  '  \\ n '  )  ;", "if    ( index    !  =     (  -  1  )  )", "text    =    text . substring (  0  ,    index )  ;", "char [  ]    chars    =    text . toCharArray (  )  ;", "GlyphVector   vector    =    font . layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,    Font . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "int   yOffset    =     ( ascent )     +     ( vector . getPixelBounds ( null ,     0  ,     0  )  . y )  ;", "return   yOffset ;", "}", "METHOD_END"], "methodName": ["getYOffset"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "Map   attributes    =    baseFont . getAttributes (  )  ;", "attributes . put ( TextAttribute . SIZE ,    new   Float ( size )  )  ;", "attributes . put ( TextAttribute . WEIGHT ,     ( bold    ?    TextAttribute . WEIGHT _ BOLD    :    TextAttribute . WEIGHT _ REGULAR )  )  ;", "attributes . put ( TextAttribute . POSTURE ,     ( italic    ?    TextAttribute . POSTURE _ OBLIQUE    :    TextAttribute . POSTURE _ REGULAR )  )  ;", "try    {", "attributes . put ( TextAttribute . class . getDeclaredField (  \" KERNING \"  )  . get ( null )  ,    TextAttribute . class . getDeclaredField (  \" KERNING _ ON \"  )  . get ( null )  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "font    =    baseFont . deriveFont ( attributes )  ;", "metrics    =    GlyphPage . scratchGraphics . getFontMetrics ( font )  ;", "ascent    =    metrics . getAscent (  )  ;", "descent    =    metrics . getDescent (  )  ;", "leading    =    metrics . getLeading (  )  ;", "char [  ]    chars    =     \"     \"  . toCharArray (  )  ;", "GlyphVector   vector    =    font . layoutGlyphVector ( GlyphPage . renderContext ,    chars ,     0  ,    chars . length ,    Font . LAYOUT _ LEFT _ TO _ RIGHT )  ;", "spaceWidth    =    vector . getGlyphLogicalBounds (  0  )  . getBounds (  )  . width ;", "}", "METHOD_END"], "methodName": ["initializeFont"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "return   loadGlyphs (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["loadGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "if    ( queuedGlyphs . isEmpty (  )  )", "return   false ;", "if    ( effects . isEmpty (  )  )", "throw   new   IllegalStateException (  \" The      must   have   at   least   one   effect   before   any   glyphs   can   be   loaded .  \"  )  ;", "for    ( Iterator   iter    =    queuedGlyphs . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Glyph   glyph    =     (  ( Glyph )     ( iter . next (  )  )  )  ;", "int   codePoint    =    glyph . getCodePoint (  )  ;", "if    ( glyph . isMissing (  )  )     {", "if    (  ( missingGlyph )     !  =    null )     {", "if    ( glyph    !  =     ( missingGlyph )  )", "iter . remove (  )  ;", "continue ;", "}", "missingGlyph    =    glyph ;", "}", "}", "Collections . sort ( queuedGlyphs ,     . heightComparator )  ;", "for    ( Iterator   iter    =    glyphPages . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "GlyphPage   glyphPage    =     (  ( GlyphPage )     ( iter . next (  )  )  )  ;", "maxGlyphsToLoad    -  =    glyphPage . loadGlyphs ( queuedGlyphs ,    maxGlyphsToLoad )  ;", "if    (  ( maxGlyphsToLoad    =  =     0  )     |  |     ( queuedGlyphs . isEmpty (  )  )  )", "return   true ;", "}", "while    (  !  ( queuedGlyphs . isEmpty (  )  )  )     {", "GlyphPage   glyphPage    =    new   GlyphPage ( this ,    glyphPageWidth ,    glyphPageHeight )  ;", "glyphPages . add ( glyphPage )  ;", "maxGlyphsToLoad    -  =    glyphPage . loadGlyphs ( queuedGlyphs ,    maxGlyphsToLoad )  ;", "if    ( maxGlyphsToLoad    =  =     0  )", "return   true ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["loadGlyphs"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "paddingTop    =    settings . getPaddingTop (  )  ;", "paddingLeft    =    settings . getPaddingLeft (  )  ;", "paddingBottom    =    settings . getPaddingBottom (  )  ;", "paddingRight    =    settings . getPaddingRight (  )  ;", "paddingAdvanceX    =    settings . getPaddingAdvanceX (  )  ;", "paddingAdvanceY    =    settings . getPaddingAdvanceY (  )  ;", "glyphPageWidth    =    settings . getGlyphPageWidth (  )  ;", "glyphPageHeight    =    settings . getGlyphPageHeight (  )  ;", "effects . addAll ( settings . getEffects (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadSettings"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . gamma    =    gamma ;", "}", "METHOD_END"], "methodName": ["setGamma"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . glyphPageHeight    =    glyphPageHeight ;", "}", "METHOD_END"], "methodName": ["setGlyphPageHeight"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . glyphPageWidth    =    glyphPageWidth ;", "}", "METHOD_END"], "methodName": ["setGlyphPageWidth"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . mono    =    mono ;", "}", "METHOD_END"], "methodName": ["setMono"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . paddingAdvanceX    =    paddingAdvanceX ;", "}", "METHOD_END"], "methodName": ["setPaddingAdvanceX"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . paddingAdvanceY    =    paddingAdvanceY ;", "}", "METHOD_END"], "methodName": ["setPaddingAdvanceY"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . paddingBottom    =    paddingBottom ;", "}", "METHOD_END"], "methodName": ["setPaddingBottom"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . paddingLeft    =    paddingLeft ;", "}", "METHOD_END"], "methodName": ["setPaddingLeft"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . paddingRight    =    paddingRight ;", "}", "METHOD_END"], "methodName": ["setPaddingRight"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . paddingTop    =    paddingTop ;", "}", "METHOD_END"], "methodName": ["setPaddingTop"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "this . renderType    =    renderType ;", "if    ( renderType    !  =     ( UnicodeFont . RenderType . FreeType )  )     {", "if    (  ( bitmapFont )     !  =    null )     {", "bitmapFont . dispose (  )  ;", "generator . dispose (  )  ;", "}", "} else    {", "String   fontFile    =    getFontFile (  )  ;", "if    ( fontFile    !  =    null )     {", "generator    =    new   graphics . g 2 d . freetype . FreeTypeFontGenerator ( files . absolute ( fontFile )  )  ;", "FreeTypeFontParameter   param    =    new   FreeTypeFontParameter (  )  ;", "param . size    =    font . getSize (  )  ;", "param . incremental    =    true ;", "param . flip    =    true ;", "param . mono    =    mono ;", "param . gamma    =    gamma ;", "bitmapFont    =    generator . generateFont ( param )  ;", "if    (  ( bitmapFont . getData (  )  . missingGlyph )     =  =    null )", "bitmapFont . getData (  )  . missingGlyph    =    bitmapFont . getData (  )  . getGlyph (  '  \\ ufffd '  )  ;", "cache    =    bitmapFont . newFontCache (  )  ;", "layout    =    new   GlyphLayout (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRenderType"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont"}, {"methodBody": ["METHOD_START", "{", "g . setColor ( color )  ;", "try    {", "g . fill ( glyph . getShape (  )  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ColorEffect"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ColorEffect"}, {"methodBody": ["METHOD_START", "{", "List   values    =    new   ArrayList (  )  ;", "values . add ( Util . colorValue (  \" Color \"  ,    color )  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ColorEffect"}, {"methodBody": ["METHOD_START", "{", "if    ( color    =  =    null )", "throw   new   IllegalArgumentException (  \" color   cannot   be   null .  \"  )  ;", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ColorEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator   iter    =    values . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Configurable . Value   value    =     (  ( Configurable . Value )     ( iter . next (  )  )  )  ;", "if    ( value . getName (  )  . equals (  \" Color \"  )  )     {", "setColor (  (  ( Color )     ( value . getObject (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ColorEffect"}, {"methodBody": ["METHOD_START", "{", "return    \" Color \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ColorEffect"}, {"methodBody": ["METHOD_START", "{", "Graphics 2 D   inputG    =     (  ( Graphics 2 D )     ( image . getGraphics (  )  )  )  ;", "inputG . setTransform ( AffineTransform . getScaleIn ( scale ,    scale )  )  ;", "inputG . setRenderingHint ( RenderingHints . KEY _ FRACTIONALMETRICS ,    RenderingHints . VALUE _ FRACTIONALMETRICS _ ON )  ;", "inputG . setColor ( Color . WHITE )  ;", "inputG . fill ( glyph . getShape (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawGlyph"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.DistanceFieldEffect"}, {"methodBody": ["METHOD_START", "{", "return   new   EffectUtil . DefaultValue ( name ,    String . valueOf ( currentValue )  )     {", "public   void   showDialog (  )     {", "JCheckBox   checkBox    =    new   JCheckBox (  )  ;", "checkBox . setSelected ( currentValue )  ;", "if    ( showValueDialog ( checkBox ,    description )  )", "value    =    String . valueOf ( checkBox . isSelected (  )  )  ;", "}", "public   Object   getObject (  )     {", "return   Boolean . valueOf ( value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["booleanValue"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   EffectUtil . DefaultValue ( name ,    EffectUtil . toString ( currentValue )  )     {", "public   void   showDialog (  )     {", "Color   newColor    =    JColorChooser . showDialog ( null ,     \" Choose   a   color \"  ,    EffectUtil . fromString ( value )  )  ;", "if    ( newColor    !  =    null )", "value    =    EffectUtil . toString ( newColor )  ;", "}", "public   Object   getObject (  )     {", "return   EffectUtil . fromString ( value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["colorValue"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   EffectUtil . DefaultValue ( name ,    String . valueOf ( currentValue )  )     {", "public   void   showDialog (  )     {", "JSpinner   spinner    =    new   JSpinner ( new   SpinnerNumberModel ( currentValue ,    min ,    max ,     0  .  1 F )  )  ;", "if    ( showValueDialog ( spinner ,    description )  )", "value    =    String . valueOf (  (  ( Double )     ( spinner . getValue (  )  )  )  . floatValue (  )  )  ;", "}", "public   Object   getObject (  )     {", "return   Float . valueOf ( value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["floatValue"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( rgb    =  =    null )     |  |     (  ( rgb . length (  )  )     !  =     6  )  )", "return   Cor . white ;", "return   new   Cor ( Integer . parseInt ( rgb . substring (  0  ,     2  )  ,     1  6  )  ,    Integer . parseInt ( rgb . substring (  2  ,     4  )  ,     1  6  )  ,    Integer . parseInt ( rgb . substring (  4  ,     6  )  ,     1  6  )  )  ;", "}", "METHOD_END"], "methodName": ["fromString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "Graphics 2 D   g    =     (  ( Graphics 2 D )     ( EffectUtil . scratchImage . getGraphics (  )  )  )  ;", "g . setComposite ( AlphaComposite . Clear )  ;", "g . fillRect (  0  ,     0  ,    GlyphPage . MAX _ GLYPH _ SIZE ,    GlyphPage . MAX _ GLYPH _ SIZE )  ;", "g . setComposite ( AlphaComposite . SrcOver )  ;", "g . setColor ( Color . white )  ;", "return   EffectUtil . scratchImage ;", "}", "METHOD_END"], "methodName": ["getScratchImage"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   EffectUtil . DefaultValue ( name ,    String . valueOf ( currentValue )  )     {", "public   void   showDialog (  )     {", "JSpinner   spinner    =    new   JSpinner ( new   SpinnerNumberModel ( currentValue ,    Short . MIN _ VALUE ,    Short . MAX _ VALUE ,     1  )  )  ;", "if    ( showValueDialog ( spinner ,    description )  )", "value    =    String . valueOf ( spinner . getValue (  )  )  ;", "}", "public   Object   getObject (  )     {", "return   Integer . valueOf ( value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["intValue"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "return   new   EffectUtil . DefaultValue ( name ,    currentValue . toString (  )  )     {", "public   void   showDialog (  )     {", "int   selectedIndex    =     -  1  ;", "DefaultComboBoxModel   model    =    new   DefaultComboBoxModel (  )  ;", "for    ( int   i    =     0  ;    i    <     ( options . length )  ;    i +  +  )     {", "model . addElement ( options [ i ]  [  0  ]  )  ;", "if    ( getValue ( i )  . equals ( currentValue )  )", "selectedIndex    =    i ;", "}", "JComboBox   comboBox    =    new   JComboBox ( model )  ;", "comboBox . setSelectedIndex ( selectedIndex )  ;", "if    ( showValueDialog ( comboBox ,    description )  )", "value    =    getValue ( comboBox . getSelectedIndex (  )  )  ;", "}", "private   String   getValue ( int   i )     {", "if    (  ( options [ i ]  . length )     =  =     1  )", "return   options [ i ]  [  0  ]  ;", "return   options [ i ]  [  1  ]  ;", "}", "public   String   toString (  )     {", "for    ( int   i    =     0  ;    i    <     ( options . length )  ;    i +  +  )", "if    ( getValue ( i )  . equals ( value )  )", "return   options [ i ]  [  0  ]  . toString (  )  ;", "return    \"  \"  ;", "}", "public   Object   getObject (  )     {", "return   value ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["optionValue"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( color    =  =    null )", "throw   new   IllegalArgumentException (  \" color   cannot   be   null .  \"  )  ;", "String   r    =    IntegerHexString ( color . getRed (  )  )  ;", "if    (  ( r . length (  )  )     =  =     1  )", "r    =     \"  0  \"     +    r ;", "String   g    =    IntegerHexString ( color . getGreen (  )  )  ;", "if    (  ( g . length (  )  )     =  =     1  )", "g    =     \"  0  \"     +    g ;", "String   b    =    IntegerHexString ( color . getBlue (  )  )  ;", "if    (  ( b . length (  )  )     =  =     1  )", "b    =     \"  0  \"     +    b ;", "return    ( r    +    g )     +    b ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   scratchImage    =    EffectUtil . getScratchImage (  )  ;", "filter . filter ( image ,    scratchImage )  ;", "image . getGraphics (  )  . drawImage ( scratchImage ,     0  ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.FilterEffect"}, {"methodBody": ["METHOD_START", "{", "return   filter ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.FilterEffect"}, {"methodBody": ["METHOD_START", "{", "this . filter    =    filter ;", "}", "METHOD_END"], "methodName": ["setFilter"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.FilterEffect"}, {"methodBody": ["METHOD_START", "{", "int   ascent    =    unicodeFont . getAscent (  )  ;", "float   height    =    ascent    *     ( scale )  ;", "float   top    =     (  (  (  (  -  ( glyph . getYOffset (  )  )  )     +     ( unicodeFont . getDescent (  )  )  )     +     ( offset )  )     +     ( ascent    /     2  )  )     -     ( height    /     2  )  ;", "g . setPaint ( new   Paint (  0  ,    top ,    topColor ,     0  ,     ( top    +    height )  ,    bottomColor ,    cyclic )  )  ;", "g . fill ( glyph . getShape (  )  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "return   bottomColor ;", "}", "METHOD_END"], "methodName": ["getBottomColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "return   scale ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "return   topColor ;", "}", "METHOD_END"], "methodName": ["getTopColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "List   values    =    new   ArrayList (  )  ;", "values . add ( EffectUtil . colorValue (  \" Top   color \"  ,    topColor )  )  ;", "values . add ( EffectUtil . colorValue (  \" Bottom   color \"  ,    bottomColor )  )  ;", "values . add ( EffectUtil . intValue (  \" Offset \"  ,    offset ,     \" This   setting   allows   you   to   move   the   g   up   or   down .    The   g   is   normally   centered   on   the   glyph .  \"  )  )  ;", "values . add ( EffectUtil . floatValue (  \" Scale \"  ,    scale ,     0  ,     1  0  ,     (  \" This   setting   allows   you   to   change   the   height   of   the   g   by   a \"     +     \" percentage .    The   g   is   normally   the   height   of   most   glyphs   in   the   font .  \"  )  )  )  ;", "values . add ( EffectUtil . booleanValue (  \" Cyclic \"  ,    cyclic ,     \" If   this   setting   is   checked ,    the   g   will   repeat .  \"  )  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "return   cyclic ;", "}", "METHOD_END"], "methodName": ["isCyclic"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "this . bottomColor    =    bottomColor ;", "}", "METHOD_END"], "methodName": ["setBottomColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "this . cyclic    =    cyclic ;", "}", "METHOD_END"], "methodName": ["setCyclic"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "this . offset    =    offset ;", "}", "METHOD_END"], "methodName": ["setOffset"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "this . scale    =    scale ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "this . topColor    =    topColor ;", "}", "METHOD_END"], "methodName": ["setTopColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator   iter    =    values . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Configurable . Value   value    =     (  ( Configurable . Value )     ( iter . next (  )  )  )  ;", "if    ( value . getName (  )  . equals (  \" Top   color \"  )  )     {", "topColor    =     (  ( Color )     ( value . getObject (  )  )  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Bottom   color \"  )  )     {", "bottomColor    =     (  ( Color )     ( value . getObject (  )  )  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Offset \"  )  )     {", "offset    =     (  ( Integer )     ( value . getObject (  )  )  )  . intValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Scale \"  )  )     {", "scale    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Cyclic \"  )  )     {", "cyclic    =     (  ( Boolean )     ( value . getObject (  )  )  )  . booleanValue (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "return    \" Gradient \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.GradientEffect"}, {"methodBody": ["METHOD_START", "{", "g    =     (  ( Graphics 2 D )     ( g . create (  )  )  )  ;", "if    (  ( stroke )     !  =    null )", "g . setStroke ( stroke )  ;", "else", "g . setStroke ( getStroke (  )  )  ;", "g . setColor ( color )  ;", "g . draw ( glyph . getShape (  )  )  ;", "g . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "return   join ;", "}", "METHOD_END"], "methodName": ["getJoin"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stroke )     =  =    null )", "return   new   BasicStroke ( width ,    CAP _ SQUARE ,    join )  ;", "return   stroke ;", "}", "METHOD_END"], "methodName": ["getStroke"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "List   values    =    new   ArrayList (  )  ;", "values . add ( Util . colorValue (  \" Color \"  ,    color )  )  ;", "values . add ( Util . floatValue (  \" Width \"  ,    width ,     0  .  1 F ,     9  9  9  ,     (  \" This   setting   controls   the   width   of   the   outline .     \"     +     \" The   glyphs   will   need   padding   so   the   outline   doesn ' t   get   clipped .  \"  )  )  )  ;", "values . add ( Util . optionValue (  \" Join \"  ,    String . valueOf ( join )  ,    new   String [  ]  [  ]  {    new   String [  ]  {     \" Bevel \"  ,     ( BasicStroke . JOIN _ BEVEL )     +     \"  \"     }  ,    new   String [  ]  {     \" Miter \"  ,     ( BasicStroke . JOIN _ MITER )     +     \"  \"     }  ,    new   String [  ]  {     \" Round \"  ,     ( BasicStroke . JOIN _ ROUND )     +     \"  \"     }     }  ,     (  \" This   setting   defines   how   the   corners   of   the   outline   are   drawn .     \"     +     \" This   is   usually   only   noticeable   at   large   outline   widths .  \"  )  )  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "this . join    =    join ;", "}", "METHOD_END"], "methodName": ["setJoin"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "this . stroke    =    stroke ;", "}", "METHOD_END"], "methodName": ["setStroke"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator   iter    =    values . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Configurabl . Value   value    =     (  ( Configurabl . Value )     ( iter . next (  )  )  )  ;", "if    ( value . getName (  )  . equals (  \" Color \"  )  )     {", "color    =     (  ( Color )     ( value . getObject (  )  )  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Width \"  )  )     {", "width    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Join \"  )  )     {", "join    =    Integer . parseInt (  (  ( String )     ( value . getObject (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "return    \" Outline \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineEffect"}, {"methodBody": ["METHOD_START", "{", "List   values    =    super . getValues (  )  ;", "values . remove (  2  )  ;", "values . add ( EffectUtil . floatValue (  \" Detail \"  ,    detail ,     1  ,     5  0  ,     (  \" This   setting   controls   how   detailed   the   o   will   be .     \"     +     \" Smaller   numbers   cause   the   o   to   have   more   detail .  \"  )  )  )  ;", "values . add ( EffectUtil . floatValue (  \" Amplitude \"  ,    amplitude ,     0  .  5 F ,     5  0  ,     \" This   setting   controls   the   amplitude   of   the   o .  \"  )  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineWobbleEffect"}, {"methodBody": ["METHOD_START", "{", "super . setValues ( values )  ;", "for    ( Iterator   iter    =    values . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Configura . Value   value    =     (  ( Configura . Value )     ( iter . next (  )  )  )  ;", "if    ( value . getName (  )  . equals (  \" Detail \"  )  )     {", "detail    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Amplitude \"  )  )     {", "amplitude    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineWobbleEffect"}, {"methodBody": ["METHOD_START", "{", "return    \" Outline    ( Wobble )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineWobbleEffect"}, {"methodBody": ["METHOD_START", "{", "List   values    =    super . getValues (  )  ;", "values . add ( EffectUtil . floatValue (  \" Wavelength \"  ,    wavelength ,     1  ,     1  0  0  ,     (  \" This   setting   controls   the   wavelength   of   the   o .     \"     +     \" The   smaller   the   value ,    the   more   segments   will   be   used   to   draw   the   o .  \"  )  )  )  ;", "values . add ( EffectUtil . floatValue (  \" Amplitude \"  ,    amplitude ,     0  .  5 F ,     5  0  ,     (  \" This   setting   controls   the   amplitude   of   the   o .     \"     +     \" The   bigger   the   value ,    the   more   the   zigzags   will   vary .  \"  )  )  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineZigzagEffect"}, {"methodBody": ["METHOD_START", "{", "super . setValues ( values )  ;", "for    ( Iterator   iter    =    values . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Configurable . Value   value    =     (  ( Configurable . Value )     ( iter . next (  )  )  )  ;", "if    ( value . getName (  )  . equals (  \" Wavelength \"  )  )     {", "wavelength    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Amplitude \"  )  )     {", "amplitude    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineZigzagEffect"}, {"methodBody": ["METHOD_START", "{", "return    \" Outline    ( Zigzag )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.OutlineZigzagEffect"}, {"methodBody": ["METHOD_START", "{", "float [  ]    matrix    =    ShadowEffect . GAUSSIAN _ BLUR _ KERNELS [  (  ( blurKernelSize )     -     1  )  ]  ;", "Kernel   gaussianBlur 1     =    new   Kernel ( matrix . length ,     1  ,    matrix )  ;", "Kernel   gaussianBlur 2     =    new   Kernel (  1  ,    matrix . length ,    matrix )  ;", "RenderingHints   hints    =    new   RenderingHints ( RenderingHints . KEY _ RENDERING ,    RenderingHints . VALUE _ RENDER _ SPEED )  ;", "ConvolveOp   gaussianOp 1     =    new   ConvolveOp ( gaussianBlur 1  ,    ConvolveOp . EDGE _ NO _ OP ,    hints )  ;", "ConvolveOp   gaussianOp 2     =    new   ConvolveOp ( gaussianBlur 2  ,    ConvolveOp . EDGE _ NO _ OP ,    hints )  ;", "BufferedImage   scratchImage    =    EffectUtil . getScratchImage (  )  ;", "for    ( int   i    =     0  ;    i    <     ( blurPasses )  ;    i +  +  )     {", "gaussianOp 1  . filter ( image ,    scratchImage )  ;", "gaussianOp 2  . filter ( scratchImage ,    image )  ;", "}", "}", "METHOD_END"], "methodName": ["blur"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "g    =     (  ( Graphics 2 D )     ( g . create (  )  )  )  ;", "g . translate ( xDistance ,    yDistance )  ;", "g . setColor ( new   Color ( color . getRed (  )  ,    color . getGreen (  )  ,    color . getBlue (  )  ,    Math . round (  (  ( opacity )     *     2  5  5  )  )  )  )  ;", "g . fill ( glyph . getShape (  )  )  ;", "for    ( Iterator   iter    =    unicodeFont . getEffects (  )  . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Effect   effect    =     (  ( Effect )     ( iter . next (  )  )  )  ;", "if    ( effect   instanceof   OutlineEffect )     {", "Composite   composite    =    g . getComposite (  )  ;", "g . setComposite ( AlphaComposite . Src )  ;", "g . setStroke (  (  ( OutlineEffect )     ( effect )  )  . getStroke (  )  )  ;", "g . draw ( glyph . getShape (  )  )  ;", "g . setComposite ( composite )  ;", "break ;", "}", "}", "g . dispose (  )  ;", "if    (  (  (  ( blurKernelSize )     >     1  )     &  &     (  ( blurKernelSize )     <     (  . NUM _ KERNELS )  )  )     &  &     (  ( blurPasses )     >     0  )  )", "blur ( image )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "float [  ]  [  ]    pascalsTriangle    =    ShadowEffect . generatePascalsTriangle ( level )  ;", "float [  ]  [  ]    gaussianTriangle    =    new   float [ pascalsTriangle . length ]  [  ]  ;", "for    ( int   i    =     0  ;    i    <     ( gaussianTriangle . length )  ;    i +  +  )     {", "float   total    =     0  .  0 F ;", "gaussianTriangle [ i ]     =    new   float [ pascalsTriangle [ i ]  . length ]  ;", "for    ( int   j    =     0  ;    j    <     ( pascalsTriangle [ i ]  . length )  ;    j +  +  )", "total    +  =    pascalsTriangle [ i ]  [ j ]  ;", "float   coefficient    =     1     /    total ;", "for    ( int   j    =     0  ;    j    <     ( pascalsTriangle [ i ]  . length )  ;    j +  +  )", "gaussianTriangle [ i ]  [ j ]     =    coefficient    *     ( pascalsTriangle [ i ]  [ j ]  )  ;", "}", "return   gaussianTriangle ;", "}", "METHOD_END"], "methodName": ["generateGaussianBlurKernels"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "if    ( level    <     2  )", "level    =     2  ;", "fat [  ]  [  ]    triangle    =    new   fat [ level ]  [  ]  ;", "triangle [  0  ]     =    new   fat [  1  ]  ;", "triangle [  1  ]     =    new   fat [  2  ]  ;", "triangle [  0  ]  [  0  ]     =     1  .  0 F ;", "triangle [  1  ]  [  0  ]     =     1  .  0 F ;", "triangle [  1  ]  [  1  ]     =     1  .  0 F ;", "for    ( int   i    =     2  ;    i    <    level ;    i +  +  )     {", "triangle [ i ]     =    new   fat [ i    +     1  ]  ;", "triangle [ i ]  [  0  ]     =     1  .  0 F ;", "triangle [ i ]  [ i ]     =     1  .  0 F ;", "for    ( int   j    =     1  ;    j    <     (  ( triangle [ i ]  . length )     -     1  )  ;    j +  +  )", "triangle [ i ]  [ j ]     =     ( triangle [  ( i    -     1  )  ]  [  ( j    -     1  )  ]  )     +     ( triangle [  ( i    -     1  )  ]  [ j ]  )  ;", "}", "return   triangle ;", "}", "METHOD_END"], "methodName": ["generatePascalsTriangle"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "return   blurKernelSize ;", "}", "METHOD_END"], "methodName": ["getBlurKernelSize"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "return   blurPasses ;", "}", "METHOD_END"], "methodName": ["getBlurPasses"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "return   opacity ;", "}", "METHOD_END"], "methodName": ["getOpacity"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "List   values    =    new   ArrayList (  )  ;", "values . add ( EffectUtil . colorValue (  \" Color \"  ,    color )  )  ;", "values . add ( EffectUtil . floatValue (  \" Opacity \"  ,    opacity ,     0  ,     1  ,     \" This   setting   sets   the   translucency   of   the   shadow .  \"  )  )  ;", "values . add ( EffectUtil . floatValue (  \" X   distance \"  ,    xDistance ,     (  -  9  9  )  ,     9  9  ,     (  \" This   setting   is   the   amount   of   pixels   to   offset   the    \"     +     \" shadow   on   the   x   axis .    The   glyphs   will   need   padding   so   the   shadow   doesn ' t   get   clipped .  \"  )  )  )  ;", "values . add ( EffectUtil . floatValue (  \" Y   distance \"  ,    yDistance ,     (  -  9  9  )  ,     9  9  ,     (  \" This   setting   is   the   amount   of   pixels   to   offset   the    \"     +     \" shadow   on   the   y   axis .    The   glyphs   will   need   padding   so   the   shadow   doesn ' t   get   clipped .  \"  )  )  )  ;", "List   options    =    new   ArrayList (  )  ;", "options . add ( new   String [  ]  {     \" None \"  ,     \"  0  \"     }  )  ;", "for    ( int   i    =     2  ;    i    <     (  . NUM _ KERNELS )  ;    i +  +  )", "options . add ( new   String [  ]  {    String . valueOf ( i )     }  )  ;", "String [  ]  [  ]    optionsArray    =     (  ( String [  ]  [  ]  )     ( options . toArray ( new   String [ options . size (  )  ]  [  ]  )  )  )  ;", "values . add ( EffectUtil . optionValue (  \" Blur   kernel   size \"  ,    String . valueOf ( blurKernelSize )  ,    optionsArray ,     \" This   setting   controls   how   many   neighboring   pixels   are   used   to   blur   the   shadow .    Set   to    \\  \" None \\  \"    for   no   blur .  \"  )  )  ;", "values . add ( EffectUtil . intValue (  \" Blur   passes \"  ,    blurPasses ,     \" The   setting   is   the   number   of   times   to   apply   a   blur   to   the   shadow .    Set   to    \\  \"  0  \\  \"    for   no   blur .  \"  )  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "return   xDistance ;", "}", "METHOD_END"], "methodName": ["getXDistance"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "return   yDistance ;", "}", "METHOD_END"], "methodName": ["getYDistance"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "this . blurKernelSize    =    blurKernelSize ;", "}", "METHOD_END"], "methodName": ["setBlurKernelSize"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "this . blurPasses    =    blurPasses ;", "}", "METHOD_END"], "methodName": ["setBlurPasses"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "this . opacity    =    opacity ;", "}", "METHOD_END"], "methodName": ["setOpacity"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator   iter    =    values . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Configurable . Value   value    =     (  ( Configurable . Value )     ( iter . next (  )  )  )  ;", "if    ( value . getName (  )  . equals (  \" Color \"  )  )     {", "color    =     (  ( Color )     ( value . getObject (  )  )  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Opacity \"  )  )     {", "opacity    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" X   distance \"  )  )     {", "xDistance    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Y   distance \"  )  )     {", "yDistance    =     (  ( Float )     ( value . getObject (  )  )  )  . floatValue (  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Blur   kernel   size \"  )  )     {", "blurKernelSize    =    Integer . parseInt (  (  ( String )     ( value . getObject (  )  )  )  )  ;", "} else", "if    ( value . getName (  )  . equals (  \" Blur   passes \"  )  )     {", "blurPasses    =     (  ( Integer )     ( value . getObject (  )  )  )  . intValue (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "xDistance    =    distance ;", "}", "METHOD_END"], "methodName": ["setXDistance"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "yDistance    =    distance ;", "}", "METHOD_END"], "methodName": ["setYDistance"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "return    \" Shadow \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.tools.hiero.unicodefont.effects.ShadowEffect"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   image    =    new   BufferedImage ( width ,    height ,    BufferedImage . TYPE _  4 BYTE _ ABGR )  ;", "Graphics 2 D   g    =    image . createGraphics (  )  ;", "g . setColor ( color )  ;", "g . fillRect (  0  ,     0  ,    width ,    height )  ;", "g . dispose (  )  ;", "return   image ;", "}", "METHOD_END"], "methodName": ["createImage"], "fileName": "com.badlogic.gdx.tools.imagepacker.ImagePacker"}, {"methodBody": ["METHOD_START", "{", "return   image ;", "}", "METHOD_END"], "methodName": ["getImage"], "fileName": "com.badlogic.gdx.tools.imagepacker.ImagePacker"}, {"methodBody": ["METHOD_START", "{", "return   rects ;", "}", "METHOD_END"], "methodName": ["getRects"], "fileName": "com.badlogic.gdx.tools.imagepacker.ImagePacker"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( node . leaveName )     =  =    null )     &  &     (  ( node . leftChild )     !  =    null )  )     &  &     (  ( node . rightChild )     !  =    null )  )     {", ". Node   newNode    =    null ;", "newNode    =    insert ( node . leftChild ,    rect )  ;", "if    ( newNode    =  =    null )", "newNode    =    insert ( node . rightChild ,    rect )  ;", "return   newNode ;", "} else    {", "if    (  ( node . leaveName )     !  =    null )", "return   null ;", "if    (  (  ( node . rect . width )     =  =     ( rect . width )  )     &  &     (  ( node . rect . height )     =  =     ( rect . height )  )  )", "return   node ;", "if    (  (  ( node . rect . width )     <     ( rect . width )  )     |  |     (  ( node . rect . height )     <     ( rect . height )  )  )", "return   null ;", "node . leftChild    =    new    . Node (  )  ;", "node . rightChild    =    new    . Node (  )  ;", "int   deltaWidth    =     ( node . rect . width )     -     ( rect . width )  ;", "int   deltaHeight    =     ( node . rect . height )     -     ( rect . height )  ;", "if    ( deltaWidth    >    deltaHeight )     {", "node . leftChild . rect . x    =    node . rect . x ;", "node . leftChild . rect . y    =    node . rect . y ;", "node . leftChild . rect . width    =    rect . width ;", "node . leftChild . rect . height    =    node . rect . height ;", "node . rightChild . rect . x    =     ( node . rect . x )     +     ( rect . width )  ;", "node . rightChild . rect . y    =    node . rect . y ;", "node . rightChild . rect . width    =     ( node . rect . width )     -     ( rect . width )  ;", "node . rightChild . rect . height    =    node . rect . height ;", "} else    {", "node . leftChild . rect . x    =    node . rect . x ;", "node . leftChild . rect . y    =    node . rect . y ;", "node . leftChild . rect . width    =    node . rect . width ;", "node . leftChild . rect . height    =    rect . height ;", "node . rightChild . rect . x    =    node . rect . x ;", "node . rightChild . rect . y    =     ( node . rect . y )     +     ( rect . height )  ;", "node . rightChild . rect . width    =    node . rect . width ;", "node . rightChild . rect . height    =     ( node . rect . height )     -     ( rect . height )  ;", "}", "return   insert ( node . leftChild ,    rect )  ;", "}", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.tools.imagepacker.ImagePacker"}, {"methodBody": ["METHOD_START", "{", "if    ( rects . containsKey ( name )  )", "throw   new   RuntimeException (  (  (  \" Key   with   name    '  \"     +    name )     +     \"  '    is   already   in   map \"  )  )  ;", "int   borderPixels    =     ( padding )     +     ( duplicateBorder    ?     1     :     0  )  ;", "borderPixels    <  <  =     1  ;", "Rectangle   rect    =    new   Rectangle (  0  ,     0  ,     (  ( image . getWidth (  )  )     +    borderPixels )  ,     (  ( image . getHeight (  )  )     +    borderPixels )  )  ;", ". Node   node    =    insert ( root ,    rect )  ;", "if    ( node    =  =    null )", "throw   new   RuntimeException (  \" Image   didn ' t   fit \"  )  ;", "node . leaveName    =    name ;", "rect    =    new   Rectangle ( node . rect )  ;", "rect . width    -  =    borderPixels ;", "rect . height    -  =    borderPixels ;", "borderPixels    >  >  =     1  ;", "rect . x    +  =    borderPixels ;", "rect . y    +  =    borderPixels ;", "rects . put ( name ,    rect )  ;", "Graphics 2 D   g    =    this . image . createGraphics (  )  ;", "g . drawImage ( image ,    rect . x ,    rect . y ,    null )  ;", "if    ( duplicateBorder )     {", "g . drawImage ( image ,    rect . x ,     (  ( rect . y )     -     1  )  ,     (  ( rect . x )     +     ( rect . width )  )  ,    rect . y ,     0  ,     0  ,    image . getWidth (  )  ,     1  ,    null )  ;", "g . drawImage ( image ,    rect . x ,     (  ( rect . y )     +     ( rect . height )  )  ,     (  ( rect . x )     +     ( rect . width )  )  ,     (  (  ( rect . y )     +     ( rect . height )  )     +     1  )  ,     0  ,     (  ( image . getHeight (  )  )     -     1  )  ,    image . getWidth (  )  ,    image . getHeight (  )  ,    null )  ;", "g . drawImage ( image ,     (  ( rect . x )     -     1  )  ,    rect . y ,    rect . x ,     (  ( rect . y )     +     ( rect . height )  )  ,     0  ,     0  ,     1  ,    image . getHeight (  )  ,    null )  ;", "g . drawImage ( image ,     (  ( rect . x )     +     ( rect . width )  )  ,    rect . y ,     (  (  ( rect . x )     +     ( rect . width )  )     +     1  )  ,     (  ( rect . y )     +     ( rect . height )  )  ,     (  ( image . getWidth (  )  )     -     1  )  ,     0  ,    image . getWidth (  )  ,    image . getHeight (  )  ,    null )  ;", "g . drawImage ( image ,     (  ( rect . x )     -     1  )  ,     (  ( rect . y )     -     1  )  ,    rect . x ,    rect . y ,     0  ,     0  ,     1  ,     1  ,    null )  ;", "g . drawImage ( image ,     (  ( rect . x )     +     ( rect . width )  )  ,     (  ( rect . y )     -     1  )  ,     (  (  ( rect . x )     +     ( rect . width )  )     +     1  )  ,    rect . y ,     (  ( image . getWidth (  )  )     -     1  )  ,     0  ,    image . getWidth (  )  ,     1  ,    null )  ;", "g . drawImage ( image ,     (  ( rect . x )     -     1  )  ,     (  ( rect . y )     +     ( rect . height )  )  ,    rect . x ,     (  (  ( rect . y )     +     ( rect . height )  )     +     1  )  ,     0  ,     (  ( image . getHeight (  )  )     -     1  )  ,     1  ,    image . getHeight (  )  ,    null )  ;", "g . drawImage ( image ,     (  ( rect . x )     +     ( rect . width )  )  ,     (  ( rect . y )     +     ( rect . height )  )  ,     (  (  ( rect . x )     +     ( rect . width )  )     +     1  )  ,     (  (  ( rect . y )     +     ( rect . height )  )     +     1  )  ,     (  ( image . getWidth (  )  )     -     1  )  ,     (  ( image . getHeight (  )  )     -     1  )  ,    image . getWidth (  )  ,    image . getHeight (  )  ,    null )  ;", "}", "g . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["insertImage"], "fileName": "com.badlogic.gdx.tools.imagepacker.ImagePacker"}, {"methodBody": ["METHOD_START", "{", "Random   rand    =    new   Random (  0  )  ;", "packer    =    new    (  5  1  2  ,     5  1  2  ,     1  ,    true )  ;", "BufferedImage [  ]    images    =    new   BufferedImage [  1  0  0  ]  ;", "for    ( int   i    =     0  ;    i    <     ( images . length )  ;    i +  +  )     {", "Color   color    =    new   Color (  (  ( float )     ( Math . random (  )  )  )  ,     (  ( float )     ( Math . random (  )  )  )  ,     (  ( float )     ( Math . random (  )  )  )  ,     1  )  ;", "images [ i ]     =     . createImage (  (  ( rand . nextInt (  5  0  )  )     +     1  0  )  ,     (  ( rand . nextInt (  5  0  )  )     +     1  0  )  ,    color )  ;", "}", "Arrays . sort ( images ,    new   Comparator < BufferedImage >  (  )     {", "@ Override", "public   int   compare ( BufferedImage   o 1  ,    BufferedImage   o 2  )     {", "return    (  ( o 2  . getWidth (  )  )     *     ( o 2  . getHeight (  )  )  )     -     (  ( o 1  . getWidth (  )  )     *     ( o 1  . getHeight (  )  )  )  ;", "}", "}  )  ;", "for    ( int   i    =     0  ;    i    <     ( images . length )  ;    i +  +  )", "packer . insertImage (  (  \"  \"     +    i )  ,    images [ i ]  )  ;", "ImageIO . write ( packer . getImage (  )  ,     \" png \"  ,    new   File (  \" packed . png \"  )  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.imagepacker.ImagePacker"}, {"methodBody": ["METHOD_START", "{", "Array < String >    opts    =    new   Array < String >  ( String . class )  ;", "opts . add ( input )  ;", "opts . add ( output )  ;", "if    ( genMipmaps )", "opts . add (  \"  - mipmaps \"  )  ;", "if    ( packETC 1     &  &     (  ! genAlphaAtlas )  )", "opts . add (  \"  - etc 1  \"  )  ;", "if    ( packETC 1     &  &    genAlphaAtlas )", "opts . add (  \"  - etc 1 a \"  )  ;", ". main ( opts . toArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "com.badlogic.gdx.tools.ktx.KTXProcessor"}, {"methodBody": ["METHOD_START", "{", "Array < String >    opts    =    new   Array < String >  ( String . class )  ;", "opts . add ( inPx )  ;", "opts . add ( inNx )  ;", "opts . add ( inPy )  ;", "opts . add ( inNy )  ;", "opts . add ( inPz )  ;", "opts . add ( inNz )  ;", "opts . add ( output )  ;", "if    ( genMipmaps )", "opts . add (  \"  - mipmaps \"  )  ;", "if    ( packETC 1     &  &     (  ! genAlphaAtlas )  )", "opts . add (  \"  - etc 1  \"  )  ;", "if    ( packETC 1     &  &    genAlphaAtlas )", "opts . add (  \"  - etc 1 a \"  )  ;", ". main ( opts . toArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "com.badlogic.gdx.tools.ktx.KTXProcessor"}, {"methodBody": ["METHOD_START", "{", "new   HeadlessApplication ( new   KTXProcessor . KTXProcessorListener ( args )  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.ktx.KTXProcessor"}, {"methodBody": ["METHOD_START", "{", "points . add ( new   Chart . Point ( x ,    y )  )  ;", "}", "METHOD_END"], "methodName": ["addPoint"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "value    =     (  ( int )     ( value    *     1  0  0  )  )  ;", "if    (  ( value    %     1  )     =  =     0  )", "return    ( String . valueOf (  (  ( int )     ( value )  )  )  )     +     '  %  '  ;", "ee", "return    ( String . valueOf ( value )  )     +     '  %  '  ;", "}", "METHOD_END"], "methodName": ["axisLabel"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "float [  ]    values    =    new   float [ points . size (  )  ]  ;", "int   i    =     0  ;", "for    (  . Point   point    :    points )", "values [  ( i +  +  )  ]     =    point . x ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValuesX"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "float [  ]    values    =    new   float [ points . size (  )  ]  ;", "int   i    =     0  ;", "for    (  . Point   point    :    points )", "values [  ( i +  +  )  ]     =    point . y ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValuesY"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "return   isExpanded ;", "}", "METHOD_END"], "methodName": ["isExpanded"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "super . paintComponent ( graphics )  ;", "Graphics 2 D   g    =     (  ( Graphics 2 D )     ( graphics )  )  ;", "FontMetrics   metrics    =    g . getFontMetrics (  )  ;", "if    (  ( numberHeight )     =  =     0  )     {", "numberHeight    =    getFont (  )  . layoutGlyphVector ( g . getFontRenderContext (  )  ,    new   char [  ]  {     '  0  '     }  ,     0  ,     1  ,    Font . LAYOUT _ LEFT _ TO _ RIGHT )  . getGlyphPixelBounds (  0  ,    g . getFontRenderContext (  )  ,     0  ,     0  )  . height ;", "}", "int   width    =    getWidth (  )  ;", "if    (  !  ( isExpanded )  )", "width    =    Math . min (  1  5  0  ,    width )  ;", "width    =    Math . max (  1  0  0  ,    width )  ;", "int   height    =    getHeight (  )  ;", "int   maxAxisLabelWidth ;", "int   yAxisWidth ;", "if    ( isExpanded )     {", "maxAxisLabelWidth    =    metrics . stringWidth (  \"  1  0  0  %  \"  )  ;", "yAxisWidth    =    maxAxisLabelWidth    +     8  ;", "chartX    =    yAxisWidth ;", "chartY    =     (  ( numberHeight )     /     2  )     +     1  ;", "chartWidth    =     ( width    -    yAxisWidth )     -     2  ;", "chartHeight    =     (  ( height    -     ( chartY )  )     -     ( numberHeight )  )     -     8  ;", "} else    {", "maxAxisLabelWidth    =     0  ;", "yAxisWidth    =     2  ;", "chartX    =    yAxisWidth ;", "chartY    =     2  ;", "chartWidth    =     ( width    -    yAxisWidth )     -     2  ;", "chartHeight    =     ( height    -     ( chartY )  )     -     3  ;", "}", "g . setColor ( Color . white )  ;", "g . fillRect ( chartX ,    chartY ,    chartWidth ,    chartHeight )  ;", "g . setColor ( Color . black )  ;", "g . drawRect ( chartX ,    chartY ,    chartWidth ,    chartHeight )  ;", "maxX    =     1  ;", "{", "int   y    =    height ;", "if    ( isExpanded )", "y    -  =    numberHeight ;", "else", "y    +  =     5  ;", "int   xSplit    =     (  ( int )     ( Math . min (  1  0  ,     (  ( chartWidth )     /     ( maxAxisLabelWidth    *     1  .  5 F )  )  )  )  )  ;", "for    ( int   i    =     0  ;    i    <  =    xSplit ;    i +  +  )     {", "float   percent    =    i    /     (  ( float )     ( xSplit )  )  ;", "String   label    =    axisLabel (  (  ( maxX )     *    percent )  )  ;", "int   labelWidth    =    metrics . stringWidth ( label )  ;", "int   x    =     (  ( int )     ( yAxisWidth    +     (  ( chartWidth )     *    percent )  )  )  ;", "if    (  ( i    !  =     0  )     &  &     ( i    !  =    xSplit )  )     {", "g . setColor ( Color . lightGray )  ;", "g . drawLine ( x ,     (  ( chartY )     +     1  )  ,    x ,     (  ( chartY )     +     ( chartHeight )  )  )  ;", "g . setColor ( Color . black )  ;", "}", "g . drawLine ( x ,     ( y    -     4  )  ,    x ,     ( y    -     8  )  )  ;", "if    ( isExpanded )     {", "x    -  =    labelWidth    /     2  ;", "if    ( i    =  =    xSplit )", "x    =    Math . min ( x ,     ( width    -    labelWidth )  )  ;", "g . drawString ( label ,    x ,     ( y    +     ( numberHeight )  )  )  ;", "}", "}", "}", "maxY    =     1  ;", "{", "int   ySplit    =     ( isExpanded )     ?    Math . min (  1  0  ,     (  ( chartHeight )     /     (  ( numberHeight )     *     3  )  )  )     :     4  ;", "for    ( int   i    =     0  ;    i    <  =    ySplit ;    i +  +  )     {", "float   percent    =    i    /     (  ( float )     ( ySplit )  )  ;", "String   label    =    axisLabel (  (  ( maxY )     *    percent )  )  ;", "int   labelWidth    =    metrics . stringWidth ( label )  ;", "int   y    =     (  ( int )     (  (  ( chartY )     +     ( chartHeight )  )     -     (  ( chartHeight )     *    percent )  )  )  ;", "if    ( isExpanded )", "g . drawString ( label ,     (  ( yAxisWidth    -     6  )     -    labelWidth )  ,     ( y    +     (  ( numberHeight )     /     2  )  )  )  ;", "if    (  ( i    !  =     0  )     &  &     ( i    !  =    ySplit )  )     {", "g . setColor ( Color . lightGray )  ;", "g . drawLine ( chartX ,    y ,     (  (  ( chartX )     +     ( chartWidth )  )     -     1  )  ,    y )  ;", "g . setColor ( Color . black )  ;", "}", "g . drawLine (  ( yAxisWidth    -     4  )  ,    y ,    yAxisWidth ,    y )  ;", "}", "}", "{", "int   titleWidth    =    metrics . stringWidth ( title )  ;", "int   x    =     ( yAxisWidth    +     (  ( chartWidth )     /     2  )  )     -     ( titleWidth    /     2  )  ;", "int   y    =     (  ( chartY )     +     (  ( chartHeight )     /     2  )  )     -     (  ( numberHeight )     /     2  )  ;", "g . setColor ( Color . white )  ;", "g . fillRect (  ( x    -     2  )  ,     ( y    -     2  )  ,     ( titleWidth    +     4  )  ,     (  ( numberHeight )     +     4  )  )  ;", "g . setColor ( Color . lightGray )  ;", "g . drawString ( title ,    x ,     ( y    +     ( numberHeight )  )  )  ;", "}", "g . setColor ( Color . blue )  ;", "g . setStroke ( new   BasicStroke (  ( isExpanded    ?     3     :     2  )  )  )  ;", "int   lastX    =     -  1  ;", "int   lastY    =     -  1  ;", "for    (  . Point   point    :    points )     {", ". Point   pixel    =    pointToPixel ( point )  ;", "if    ( lastX    !  =     (  -  1  )  )", "g . drawLine ( lastX ,    lastY ,     (  ( int )     ( pixel . x )  )  ,     (  ( int )     ( pixel . y )  )  )  ;", "lastX    =     (  ( int )     ( pixel . x )  )  ;", "lastY    =     (  ( int )     ( pixel . y )  )  ;", "}", "g . drawLine ( lastX ,    lastY ,     (  (  ( chartX )     +     ( chartWidth )  )     -     1  )  ,    lastY )  ;", "for    ( int   i    =     0  ,    n    =    points . size (  )  ;    i    <    n ;    i +  +  )     {", ". Point   point    =    points . get ( i )  ;", ". Point   pixel    =    pointToPixel ( point )  ;", "if    (  ( overIndex )     =  =    i )", "g . setColor ( Color . red )  ;", "else", "g . setColor ( Color . black )  ;", "String   label    =    valueLabel ( point . y )  ;", "int   labelWidth    =    metrics . stringWidth ( label )  ;", "int   pointSize    =     ( isExpanded )     ?     . POINT _ SIZE _ EXPANDED    :     . POINT _ SIZE ;", "int   x    =     (  ( int )     ( pixel . x )  )     -     ( pointSize    /     2  )  ;", "int   y    =     (  ( int )     ( pixel . y )  )     -     ( pointSize    /     2  )  ;", "g . fillOval ( x ,    y ,    pointSize ,    pointSize )  ;", "if    ( isExpanded )     {", "g . setColor ( Color . black )  ;", "x    =    Math . max (  (  ( chartX )     +     2  )  ,    Math . min (  (  (  ( chartX )     +     ( chartWidth )  )     -    labelWidth )  ,    x )  )  ;", "y    -  =     3  ;", "if    ( y    <     (  (  ( chartY )     +     ( numberHeight )  )     +     3  )  )", "y    +  =     2  7  ;", "else", "if    ( n    >     1  )     {", ". Point   comparePoint    =     ( i    =  =     ( n    -     1  )  )     ?    points . get (  ( i    -     1  )  )     :    points . get (  ( i    +     1  )  )  ;", "if    (  ( y    <     (  (  ( chartY )     +     ( chartHeight )  )     -     2  7  )  )     &  &     (  ( comparePoint . y )     >     ( point . y )  )  )", "y    +  =     2  7  ;", "}", "g . drawString ( label ,    x ,    y )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["paintComponent"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "Chart . Point   point    =    new   Chart . Point (  )  ;", "point . x    =    Math . min ( maxX ,     (  (  ( Math . max (  0  ,     ( x    -     ( chartX )  )  )  )     /     (  ( float )     ( chartWidth )  )  )     *     ( maxX )  )  )  ;", "point . y    =    Math . min ( maxY ,     (  (  ( Math . max (  0  ,     (  ( chartHeight )     -     ( y    -     ( chartY )  )  )  )  )     /     (  ( float )     ( chartHeight )  )  )     *     ( maxY )  )  )  ;", "return   point ;", "}", "METHOD_END"], "methodName": ["pixelToPoint"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "Chart . Point   pixel    =    new   Chart . Point (  )  ;", "pixel . x    =     ( chartX )     +     (  ( int )     (  ( chartWidth )     *     (  ( point . x )     /     (  ( float )     ( maxX )  )  )  )  )  ;", "pixel . y    =     (  ( chartY )     +     ( chartHeight )  )     -     (  ( int )     (  ( chartHeight )     *     (  ( point . y )     /     (  ( float )     ( maxY )  )  )  )  )  ;", "return   pixel ;", "}", "METHOD_END"], "methodName": ["pointToPixel"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "this . isExpanded    =    isExpanded ;", "}", "METHOD_END"], "methodName": ["setExpanded"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "this . title    =    title ;", "}", "METHOD_END"], "methodName": ["setTitle"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "points . clear (  )  ;", "for    ( int   i    =     0  ;    i    <     ( x . length )  ;    i +  +  )", "points . add ( new    . Point ( x [ i ]  ,    y [ i ]  )  )  ;", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "value    =     (  ( int )     ( value    *     1  0  0  0  )  )     /     1  0  .  0 F ;", "if    (  ( value    %     1  )     =  =     0  )", "return    ( String . valueOf (  (  ( int )     ( value )  )  )  )     +     '  %  '  ;", "ee", "return    ( String . valueOf ( value )  )     +     '  %  '  ;", "}", "METHOD_END"], "methodName": ["valueLabel"], "fileName": "com.badlogic.gdx.tools.particleeditor.Chart"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "JLabel   label    =    new   JLabel (  \" Min :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "minSlider    =    new   Slider (  0  ,     0  ,     9  9  9  9  9  ,     1  ,     0  ,     5  0  0  )  ;", "contentPanel . add ( minSlider ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Max :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  2  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  2  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "maxSlider    =    new   Slider (  0  ,     0  ,     9  9  9  9  9  ,     1  ,     0  ,     5  0  0  )  ;", "contentPanel . add ( maxSlider ,    new   GridBagConstraints (  3  ,     1  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.CountPanel"}, {"methodBody": ["METHOD_START", "{", "return   advancedPanel ;", "}", "METHOD_END"], "methodName": ["getAdvancedPanel"], "fileName": "com.badlogic.gdx.tools.particleeditor.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "return   contentPanel ;", "}", "METHOD_END"], "methodName": ["getContentPanel"], "fileName": "com.badlogic.gdx.tools.particleeditor.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.tools.particleeditor.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "setLayout ( new   GridBagLayout (  )  )  ;", "{", "title    =    new   J ( new   GridBagLayout (  )  )  ;", "add ( title ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  3  ,     0  ,     3  ,     0  )  ,     0  ,     0  )  )  ;", "title . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND _ CURSOR )  )  ;", "{", "JLabel   label    =    new   JLabel ( name )  ;", "title . add ( label ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  3  ,     6  ,     3  ,     6  )  ,     0  ,     0  )  )  ;", "label . setFont ( label . getFont (  )  . deriveFont ( Font . BOLD )  )  ;", "}", "{", "descriptionLabel    =    new   JLabel ( description )  ;", "title . add ( descriptionLabel ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  3  ,     6  ,     3  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "advancedButton    =    new   JToggleButton (  \" Advanced \"  )  ;", "title . add ( advancedButton ,    new   GridBagConstraints (  2  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "advancedButton . setVisible ( false )  ;", "}", "{", "activeButton    =    new   JToggleButton (  \" Active \"  )  ;", "title . add ( activeButton ,    new   GridBagConstraints (  3  ,     0  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "content    =    new   J ( new   GridBagLayout (  )  )  ;", "add ( content ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     6  ,     6  ,     6  )  ,     0  ,     0  )  )  ;", "content . setVisible ( false )  ;", "}", "{", "advanced    =    new   J ( new   GridBagLayout (  )  )  ;", "add ( advanced ,    new   GridBagConstraints (  1  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     6  ,     6  ,     6  )  ,     0  ,     0  )  )  ;", "advanced . setVisible ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "GridBagLayout   layout    =     (  ( GridBagLayout )     ( getLayout (  )  )  )  ;", "GridBagConstraints   constraints    =    layout . getConstraints ( content )  ;", "constraints . insets    =    new   Insets (  0  ,     0  ,     0  ,     0  )  ;", "layout . setConstraints ( content ,    constraints )  ;", "title . setVisible ( false )  ;", "}", "METHOD_END"], "methodName": ["setEmbedded"], "fileName": "com.badlogic.gdx.tools.particleeditor.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "this . hasAdvanced    =    hasAdvanced ;", "advancedButton . setVisible (  ( hasAdvanced    &  &     (  ( value . isActive (  )  )     |  |     ( value . isAlwaysActive (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setHasAdvanced"], "fileName": "com.badlogic.gdx.tools.particleeditor.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "contentPanel . setVisible ( activeButton . isSelected (  )  )  ;", "advancedPanel . setVisible (  (  ( activeButton . isSelected (  )  )     &  &     ( advancedButton . isSelected (  )  )  )  )  ;", "advancedButton . setVisible (  (  ( activeButton . isSelected (  )  )     &  &     ( hasAdvanced )  )  )  ;", "descriptionLabel . setText (  ( activeButton . isSelected (  )     ?    description    :     \"  \"  )  )  ;", "if    (  ( value )     !  =    null )", "value . setActive ( activeButton . isSelected (  )  )  ;", "}", "METHOD_END"], "methodName": ["updateActive"], "fileName": "com.badlogic.gdx.tools.particleeditor.EditorPanel"}, {"methodBody": ["METHOD_START", "{", "Array < ParticleEmitter >    emitters    =    editor . effect . getEmitters (  )  ;", "if    (  ( emitters . size )     =  =     0  )", "emitter . setPosition (  (  ( editor . worldCamera . viewportWidth )     /     2  )  ,     (  ( editor . worldCamera . viewportHeight )     /     2  )  )  ;", "else    {", "ParticleEmitter   p    =    emitters . get (  0  )  ;", "emitter . setPosition ( p . getX (  )  ,    p . getY (  )  )  ;", "}", "emitters . add ( emitter )  ;", "emitterTableModel . addRow ( new   Object [  ]  {    name ,    true    }  )  ;", "if    ( select )     {", "editor . reloadRows (  )  ;", "int   row    =     ( emitterTableModel . getRowCount (  )  )     -     1  ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( row ,    row )  ;", "}", "}", "METHOD_END"], "methodName": ["addEmitter"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "if    (  ( editor . effect . getEmitters (  )  . size )     =  =     1  )", "return ;", "int   row    =    emitterTable . getSelectedRow (  )  ;", "if    ( row    =  =     (  -  1  )  )", "return ;", "if    ( row    <  =     ( editIndex )  )     {", "int   oldEditIndex    =    editIndex ;", "editIndex    =    Math . max (  0  ,     (  ( editIndex )     -     1  )  )  ;", "if    ( oldEditIndex    =  =    row )", "editor . reloadRows (  )  ;", "}", "editor . effect . getEmitters (  )  . removeIndex ( row )  ;", "emitterTableModel . removeRow ( row )  ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( editIndex ,    editIndex )  ;", "}", "METHOD_END"], "methodName": ["deleteEmitter"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "int   row    =    emitterTable . getSelectedRow (  )  ;", "if    ( row    =  =     (  -  1  )  )", "return ;", "String   name    =     (  ( String )     ( emitterTableModel . getValueAt ( row ,     0  )  )  )  ;", "addEmitter ( name ,    true ,    new   graphics . g 2 d . ParticleEmitter ( editor . effect . getEmitters (  )  . get ( row )  )  )  ;", "}", "METHOD_END"], "methodName": ["duplicateEmitter"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "editor . setEnabled ( editor . effect . getEmitters (  )  . get ( index )  ,    checked )  ;", "editor . effect . start (  )  ;", "}", "METHOD_END"], "methodName": ["emitterChecked"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "int   row    =    emitterTable . getSelectedRow (  )  ;", "if    ( row    =  =     (  -  1  )  )     {", "row    =    editIndex ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( row ,    row )  ;", "}", "if    ( row    =  =     ( editIndex )  )", "return ;", "editIndex    =    row ;", "reloadRows (  )  ;", "}", "METHOD_END"], "methodName": ["emitterSelected"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "setLayout ( new   GridBagLayout (  )  )  ;", "{", "JPanel   sideButtons    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "add ( sideButtons ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "{", "JButton   newButton    =    new   JButton (  \" New \"  )  ;", "sideButtons . add ( newButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "newButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "newEmitter (  \" Untitled \"  ,    true )  ;", "}", "}  )  ;", "}", "{", "JButton   newButton    =    new   JButton (  \" Duplicate \"  )  ;", "sideButtons . add ( newButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "newButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "duplicateEmitter (  )  ;", "}", "}  )  ;", "}", "{", "JButton   deleteButton    =    new   JButton (  \" Delete \"  )  ;", "sideButtons . add ( deleteButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "deleteButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "deleteEmitter (  )  ;", "}", "}  )  ;", "}", "{", "sideButtons . add ( new   JSeparator ( JSeparator . HORIZONTAL )  ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JButton   saveButton    =    new   JButton (  \" Save \"  )  ;", "sideButtons . add ( saveButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "saveButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "save (  )  ;", "}", "}  )  ;", "}", "{", "JButton   openButton    =    new   JButton (  \" Open \"  )  ;", "sideButtons . add ( openButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "openButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "open ( false )  ;", "}", "}  )  ;", "}", "{", "JButton   mergeButton    =    new   JButton (  \" Merge \"  )  ;", "sideButtons . add ( mergeButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "mergeButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "open ( true )  ;", "}", "}  )  ;", "}", "{", "JButton   upButton    =    new   JButton (  \" Up \"  )  ;", "sideButtons . add ( upButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     1  ,    GridBagConstraints . SOUTH ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "upButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "move (  (  -  1  )  )  ;", "}", "}  )  ;", "}", "{", "JButton   downButton    =    new   JButton (  \" Down \"  )  ;", "sideButtons . add ( downButton ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "downButton . addActionListener ( new   ActionListener (  )     {", "public   void   actionPerformed ( ActionEvent   event )     {", "move (  1  )  ;", "}", "}  )  ;", "}", "}", "{", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "{", "emitterTable    =    new   JTable (  )     {", "public   Class   getColumnClass ( int   column )     {", "return   column    =  =     1     ?    Boolean . class    :    super . getColumnClass ( column )  ;", "}", "}  ;", "emitterTable . getTableHeader (  )  . setReorderingAllowed ( false )  ;", "emitterTable . setSelectionMode ( ListSelectionModel . SINGLE _ SELECTION )  ;", "scroll . setViewportView ( emitterTable )  ;", "emitterTableModel    =    new   DefaultTableModel ( new   String [  0  ]  [  0  ]  ,    new   String [  ]  {     \" Emitter \"  ,     \"  \"     }  )  ;", "emitterTable . setModel ( emitterTableModel )  ;", "emitterTable . getSelectionModel (  )  . addListSelectionListener ( new   ListSelectionListener (  )     {", "public   void   valueChanged ( ListSelectionEvent   event )     {", "if    ( event . getValueIsAdjusting (  )  )", "return ;", "emitterSelected (  )  ;", "}", "}  )  ;", "emitterTableModel . addTableModelListener ( new   TableModelListener (  )     {", "public   void   tableChanged ( TableModelEvent   event )     {", "if    (  ( event . getColumn (  )  )     !  =     1  )", "return ;", "emitterChecked ( event . getFirstRow (  )  ,     (  ( Boolean )     ( emitterTable . getValueAt ( event . getFirstRow (  )  ,     1  )  )  )  )  ;", "}", "}  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "if    (  ( direction    <     0  )     &  &     (  ( editIndex )     =  =     0  )  )", "return ;", "Array < PEmitter >    emitters    =    editor . effect . getEmitters (  )  ;", "if    (  ( direction    >     0  )     &  &     (  ( editIndex )     =  =     (  ( emitters . size )     -     1  )  )  )", "return ;", "int   insertIndex    =     ( editIndex )     +    direction ;", "Object   name    =    emitterTableModel . getValueAt ( editIndex ,     0  )  ;", "emitterTableModel . removeRow ( editIndex )  ;", "PEmitter   emitter    =    emitters . removeIndex ( editIndex )  ;", "emitterTableModel . insertRow ( insertIndex ,    new   Object [  ]  {    name    }  )  ;", "emitters . insert ( insertIndex ,    emitter )  ;", "editIndex    =    insertIndex ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( editIndex ,    editIndex )  ;", "}", "METHOD_END"], "methodName": ["move"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "final   ParticleEmitter   emitter    =    new   ParticleEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  1  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  5  0  )  ;", "emitter . getLife (  )  . setHigh (  5  0  0  )  ;", "emitter . getXScale (  )  . setHigh (  3  2  ,     3  2  )  ;", "emitter . getTint (  )  . setColors ( new   float [  ]  {     1  ,     0  .  1  2  1  5  6  8  6  3 F ,     0  .  0  4  7  0  5  8  8  2  4 F    }  )  ;", "emitter . getTransparency (  )  . setHigh (  1  )  ;", "emitter . setMaxParticleCount (  2  5  )  ;", "emitter . setImagePaths ( new   utils . Array < String >  ( new   String [  ]  {    ParticleEditor . DEFAULT _ PARTICLE    }  )  )  ;", "addEmitter ( name ,    select ,    emitter )  ;", "return   emitter ;", "}", "METHOD_END"], "methodName": ["newEmitter"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "final   ParticleEmitter   emitter    =    new   ParticleEmitter (  )  ;", "emitter . getDuration (  )  . setLow (  3  0  0  0  )  ;", "emitter . getEmission (  )  . setHigh (  2  5  0  )  ;", "emitter . getLife (  )  . setHigh (  5  0  0  ,     1  0  0  0  )  ;", "emitter . getLife (  )  . setTimeline ( new   float [  ]  {     0  ,     0  .  6  6 F ,     1     }  )  ;", "emitter . getLife (  )  . setScaling ( new   float [  ]  {     1  ,     1  ,     0  .  3 F    }  )  ;", "emitter . getXScale (  )  . setHigh (  3  2  ,     3  2  )  ;", "emitter . getRotation (  )  . setLow (  1  ,     3  6  0  )  ;", "emitter . getRotation (  )  . setHigh (  1  8  0  ,     1  8  0  )  ;", "emitter . getRotation (  )  . setTimeline ( new   float [  ]  {     0  ,     1     }  )  ;", "emitter . getRotation (  )  . setScaling ( new   float [  ]  {     0  ,     1     }  )  ;", "emitter . getRotation (  )  . setRelative ( true )  ;", "emitter . getAngle (  )  . setHigh (  4  5  ,     1  3  5  )  ;", "emitter . getAngle (  )  . setLow (  9  0  )  ;", "emitter . getAngle (  )  . setTimeline ( new   float [  ]  {     0  ,     0  .  5 F ,     1     }  )  ;", "emitter . getAngle (  )  . setScaling ( new   float [  ]  {     1  ,     0  ,     0     }  )  ;", "emitter . getAngle (  )  . setActive ( true )  ;", "emitter . getVelocity (  )  . setHigh (  3  0  ,     3  0  0  )  ;", "emitter . getVelocity (  )  . setActive ( true )  ;", "emitter . getTint (  )  . setColors ( new   float [  ]  {     1  ,     0  .  1  2  1  5  6  8  6  3 F ,     0  .  0  4  7  0  5  8  8  2  4 F    }  )  ;", "emitter . getTransparency (  )  . setHigh (  1  ,     1  )  ;", "emitter . getTransparency (  )  . setTimeline ( new   float [  ]  {     0  ,     0  .  2 F ,     0  .  8 F ,     1     }  )  ;", "emitter . getTransparency (  )  . setScaling ( new   float [  ]  {     0  ,     1  ,     0  .  7  5 F ,     0     }  )  ;", "emitter . setMaxParticleCount (  2  0  0  )  ;", "emitter . setImagePaths ( new   utils . Array < String >  ( new   String [  ]  {    ParticleEditor . DEFAULT _ PARTICLE    }  )  )  ;", "addEmitter ( name ,    select ,    emitter )  ;", "return   emitter ;", "}", "METHOD_END"], "methodName": ["newExampleEmitter"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "FileDialog   dialog    =    new   FileDialog ( editor ,     \" Open   Effect \"  ,    FileDialog . LOAD )  ;", "if    (  ( lastDir )     !  =    null )", "dialog . setDirectory ( lastDir )  ;", "dialog . setVisible ( true )  ;", "final   String   file    =    dialog . getFile (  )  ;", "final   String   dir    =    dialog . getDirectory (  )  ;", "if    (  (  ( dir    =  =    null )     |  |     ( file    =  =    null )  )     |  |     (  ( file . trim (  )  . length (  )  )     =  =     0  )  )", "return ;", "lastDir    =    dir ;", "ParticleEffect   effect    =    new   ParticleEffect (  )  ;", "try    {", "File   effectFile    =    new   File ( dir ,    file )  ;", "effect . loadEmitters ( files . absolute ( effectFile . getAbsolutePath (  )  )  )  ;", "if    ( mergeIntoCurrent )     {", "for    ( ParticleEmitter   emitter    :    effect . getEmitters (  )  )     {", "addEmitter ( emitter . getName (  )  ,    false ,    emitter )  ;", "}", "} else    {", "editor . effect    =    effect ;", "editor . effectFile    =    effectFile ;", "}", "emitterTableModel . getDataVector (  )  . removeAllElements (  )  ;", "editorData . clear (  )  ;", "}    catch    ( Exception   ex )     {", "System . out . println (  (  \" Error   loading   effect :     \"     +     ( new   File ( dir ,    file )  . getAbsolutePath (  )  )  )  )  ;", "ex . printStackTrace (  )  ;", "JOptionPane . showMessageDialog ( editor ,     \" Error   opening   effect .  \"  )  ;", "return ;", "}", "for    ( ParticleEmitter   emitter    :    editor . effect . getEmitters (  )  )     {", "emitter . setPosition (  (  ( editor . worldCamera . viewportWidth )     /     2  )  ,     (  ( editor . worldCamera . viewportHeight )     /     2  )  )  ;", "emitterTableModel . addRow ( new   Object [  ]  {    emitter . getName (  )  ,    true    }  )  ;", "}", "editIndex    =     0  ;", "emitterTable . getSelectionModel (  )  . setSelectionInterval ( editIndex ,    editIndex )  ;", "editor . reloadRows (  )  ;", "}", "METHOD_END"], "methodName": ["openEffect"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "FileDialog   dialog    =    new   FileDialog ( editor ,     \" Save   Effect \"  ,    FileDialog . SAVE )  ;", "if    (  ( lastDir )     !  =    null )", "dialog . setDirectory ( lastDir )  ;", "dialog . setVisible ( true )  ;", "String   file    =    dialog . getFile (  )  ;", "String   dir    =    dialog . getDirectory (  )  ;", "if    (  (  ( dir    =  =    null )     |  |     ( file    =  =    null )  )     |  |     (  ( file . trim (  )  . length (  )  )     =  =     0  )  )", "return ;", "lastDir    =    dir ;", "int   index    =     0  ;", "File   effectFile    =    new   File ( dir ,    file )  ;", "URI   effectDirUri    =    effectFile . getParentFile (  )  . toURI (  )  ;", "for    ( PEmitter   emitter    :    editor . effect . getEmitters (  )  )     {", "emitter . setName (  (  ( String )     ( emitterTableModel . getValueAt (  ( index +  +  )  ,     0  )  )  )  )  ;", "Array < String >    imagePaths    =    emitter . getImagePaths (  )  ;", "for    ( int   i    =     0  ;    i    <     ( imagePaths . size )  ;    i +  +  )     {", "String   imagePath    =    imagePaths . get ( i )  ;", "if    (  (  ( imagePath . contains (  \"  /  \"  )  )     |  |     ( imagePath . contains (  \"  \\  \\  \"  )  )  )     &  &     (  !  ( imagePath . contains (  \"  .  .  \"  )  )  )  )     {", "URI   imageUri    =    new   File ( imagePath )  . toURI (  )  ;", "imagePaths . set ( i ,    effectDirUri . relativize ( imageUri )  . getPath (  )  )  ;", "}", "}", "}", "File   outputFile    =    new   File ( dir ,    file )  ;", "Writer   fileWriter    =    null ;", "try    {", "fileWriter    =    new   FileWriter ( outputFile )  ;", "editor . effect . save ( fileWriter )  ;", "}    catch    ( Exception   ex )     {", "System . out . println (  (  \" Error   saving   effect :     \"     +     ( outputFile . getAbsolutePath (  )  )  )  )  ;", "ex . printStackTrace (  )  ;", "JOptionPane . showMessageDialog ( editor ,     \" Error   saving   effect .  \"  )  ;", "}    finally    {", "StreamUtils . closeQuietly ( fileWriter )  ;", "}", "}", "METHOD_END"], "methodName": ["saveEffect"], "fileName": "com.badlogic.gdx.tools.particleeditor.EffectPanel"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    super . getPreferredSize (  )  ;", "size . width    =     1  0  ;", "return   size ;", "}", "METHOD_END"], "methodName": ["getPreferredSize"], "fileName": "com.badlogic.gdx.tools.particleeditor.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "gradientEditor    =    new    . GradientEditor (  )     {", "public   void   handleSelected ( Color   color )     {", ". this . setColor ( color )  ;", "}", "}  ;", "contentPanel . add ( gradientEditor ,    new   GridBagConstraints (  0  ,     1  ,     3  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     1  0  )  )  ;", "}", "{", "hueSlider    =    new    . ColorSlider ( new   Color [  ]  {    Color . red ,    Color . yellow ,    Color . green ,    Color . cyan ,    Color . blue ,    Color . magenta ,    Color . red    }  )     {", "protected   void   colorPicked (  )     {", "saturationSlider . setColors ( new   Color [  ]  {    new   Color ( Color . HSBtoRGB ( getPercentage (  )  ,     1  ,     1  )  )  ,    Color . white    }  )  ;", "updateColor (  )  ;", "}", "}  ;", "contentPanel . add ( hueSlider ,    new   GridBagConstraints (  1  ,     2  ,     2  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     6  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "saturationSlider    =    new    . ColorSlider ( new   Color [  ]  {    Color . red ,    Color . white    }  )     {", "protected   void   colorPicked (  )     {", "updateColor (  )  ;", "}", "}  ;", "contentPanel . add ( saturationSlider ,    new   GridBagConstraints (  1  ,     3  ,     1  ,     1  ,     1  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "lightnessSlider    =    new    . ColorSlider ( new   Color [  0  ]  )     {", "protected   void   colorPicked (  )     {", "updateColor (  )  ;", "}", "}  ;", "contentPanel . add ( lightnessSlider ,    new   GridBagConstraints (  2  ,     3  ,     1  ,     1  ,     1  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "colorPanel    =    new   JPanel (  )     {", "public   Dimension   getPreferredSize (  )     {", "Dimension   size    =    super . getPreferredSize (  )  ;", "size . width    =     5  2  ;", "return   size ;", "}", "}  ;", "contentPanel . add ( colorPanel ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     2  ,     0  .  0  ,     0  .  0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  3  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "colorPanel . addMouseListener ( new   MouseAdapter (  )     {", "public   void   mouseClicked ( MouseEvent   e )     {", "Color   color    =    JColorChooser . showDialog ( colorPanel ,     \" Set   Color \"  ,    colorPanel . getBackground (  )  )  ;", "if    ( color    !  =    null )", "setColor ( color )  ;", "}", "}  )  ;", "colorPanel . setBorder ( BorderFactory . createMatteBorder (  1  ,     1  ,     1  ,     1  ,    Color . black )  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "float [  ]    hsb    =    Color . RGBtoHSB ( color . getRed (  )  ,    color . getGreen (  )  ,    color . getBlue (  )  ,    null )  ;", "hueSlider . setPercentage ( hsb [  0  ]  )  ;", "saturationSlider . setPercentage (  (  1     -     ( hsb [  1  ]  )  )  )  ;", "lightnessSlider . setPercentage (  (  1     -     ( hsb [  2  ]  )  )  )  ;", "color . setBackground ( color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.tools.particleeditor.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "Color   color    =    new   Color ( Color . HSBtoRGB ( hueSlider . getPercentage (  )  ,     (  1     -     ( saturationSlider . getPercentage (  )  )  )  ,     1  )  )  ;", "lightnessSlider . setColors ( new   Color [  ]  {    color ,    Color . black    }  )  ;", "color    =    new   Color ( Color . HSBtoRGB ( hueSlider . getPercentage (  )  ,     (  1     -     ( saturationSlider . getPercentage (  )  )  )  ,     (  1     -     ( lightnessSlider . getPercentage (  )  )  )  )  )  ;", "colorPanel . setBackground ( color )  ;", "gEditor . setColor ( color )  ;", "float [  ]    colors    =    new   float [  ( gEditor . colors . size (  )  )     *     3  ]  ;", "int   i    =     0  ;", "for    ( Color   c    :    gEditor . colors )     {", "colors [  ( i +  +  )  ]     =     ( c . getRed (  )  )     /     2  5  5  .  0 F ;", "colors [  ( i +  +  )  ]     =     ( c . getGreen (  )  )     /     2  5  5  .  0 F ;", "colors [  ( i +  +  )  ]     =     ( c . getBlue (  )  )     /     2  5  5  .  0 F ;", "}", "float [  ]    percentages    =    new   float [ gEditor . percentages . size (  )  ]  ;", "i    =     0  ;", "for    ( Float   percent    :    gEditor . percentages )", "percentages [  ( i +  +  )  ]     =    percent ;", "value . setColors ( colors )  ;", "value . setTimeline ( percentages )  ;", "}", "METHOD_END"], "methodName": ["updateColor"], "fileName": "com.badlogic.gdx.tools.particleeditor.GradientPanel"}, {"methodBody": ["METHOD_START", "{", "if    (  ( imagePaths    !  =    null )     &  &     (  ( imagePaths . size )     >     0  )  )     {", "imagesPanel . setVisible ( true )  ;", "imageListModel . removeAllElements (  )  ;", "for    ( String   imagePath    :    imagePaths )     {", "imageListModel . addElement ( new   File ( imagePath )  . getName (  )  )  ;", "}", "} else    {", "imagesPanel . setVisible ( false )  ;", "}", "revalidate (  )  ;", "}", "METHOD_END"], "methodName": ["updateImageList"], "fileName": "com.badlogic.gdx.tools.particleeditor.ImagePanel"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    listener ;", "}", "METHOD_END"], "methodName": ["addChangeListener"], "fileName": "com.badlogic.gdx.tools.particleeditor.NewSlider"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    super . getPreferredSize (  )  ;", "size . width    =     1  5  0  ;", "size . height    =     2  6  ;", "return   size ;", "}", "METHOD_END"], "methodName": ["getPreferredSize"], "fileName": "com.badlogic.gdx.tools.particleeditor.NewSlider"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.tools.particleeditor.NewSlider"}, {"methodBody": ["METHOD_START", "{", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "JFrame   frame    =    new   JFrame (  )  ;", "frame . setDefaultCloseOperation ( JFrame . DISPOSE _ ON _ CLOSE )  ;", "frame . setSize (  4  8  0  ,     3  2  0  )  ;", "frame . setLocationRelativeTo ( null )  ;", "JPanel   panel    =    new   JPanel (  )  ;", "frame . getContentPane (  )  . add ( panel )  ;", "panel . add ( new    (  2  0  0  ,     1  0  0  ,     5  0  0  ,     0  .  1 F ,     1  5  0  ,     3  0  0  )  )  ;", "frame . setVisible ( true )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.particleeditor.NewSlider"}, {"methodBody": ["METHOD_START", "{", "super . paintComponent ( graphics )  ;", "Graphics 2 D   g    =     (  ( Graphics 2 D )     ( graphics )  )  ;", "int   width    =    getWidth (  )  ;", "int   height    =    getHeight (  )  ;", "g . setColor ( bgColor )  ;", "g . fillRect ( border ,    border ,     ( width    -     (  ( border )     *     2  )  )  ,     ( height    -     (  ( border )     *     2  )  )  )  ;", "int   maxKnobX    =     ( width    -     ( border )  )     -     (  . KNOB _ WIDTH )  ;", "int   knobX    =     (  ( int )     (  (  (  ( width    -     (  ( border )     *     2  )  )     -     (  . KNOB _ WIDTH )  )     *     (  ( value )     -     ( sliderMin )  )  )     /     (  ( sliderMax )     -     ( sliderMin )  )  )  )     +     ( border )  ;", "g . setColor ( knobColor )  ;", "g . fillRect ( Math . max ( border ,    Math . min ( maxKnobX ,    knobX )  )  ,     0  ,     . KNOB _ WIDTH ,    height )  ;", "float   displayValue    =     (  ( int )     (  ( value )     *     1  0  )  )     /     1  0  .  0 F ;", "String   label    =     ( displayValue    =  =     (  ( int )     ( displayValue )  )  )     ?    String . valueOf (  (  ( int )     ( displayValue )  )  )     :    String . valueOf ( displayValue )  ;", "FontMetrics   metrics    =    g . getFontMetrics (  )  ;", "int   labelWidth    =    metrics . stringWidth ( label )  ;", "g . setColor ( Color . white )  ;", "g . drawString ( label ,     (  ( width    /     2  )     -     ( labelWidth    /     2  )  )  ,     (  ( height    /     2  )     +     (  ( metrics . getAscent (  )  )     /     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paintComponent"], "fileName": "com.badlogic.gdx.tools.particleeditor.NewSlider"}, {"methodBody": ["METHOD_START", "{", "this . value    =     (  ( int )     (  ( Math . max ( min ,    Math . min ( max ,    value )  )  )     /     ( stepSize )  )  )     *     ( stepSize )  ;", "repaint (  )  ;", "if    (  ( listener )     !  =    null )", "listener . stateChanged ( new   ChangeEvent ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.particleeditor.NewSlider"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "JLabel   label    =    new   JLabel (  \" Value :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "valueSpinner    =    new   JSpinner ( new   SpinnerNumberModel ( new   Float (  0  )  ,    new   Float (  (  -  9  9  9  9  9  )  )  ,    new   Float (  9  9  9  9  9  )  ,    new   Float (  0  .  1 F )  )  )  ;", "contentPanel . add ( valueSpinner ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.NumericPanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "JLabel   label    =    new   JLabel (  \" Additive :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "additiveCheckbox    =    new   JCheckBox (  )  ;", "contentPanel . add ( additiveCheckbox ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Attached :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "attachedCheckBox    =    new   JCheckBox (  )  ;", "contentPanel . add ( attachedCheckBox ,    new   GridBagConstraints (  1  ,     2  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Continuous :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     3  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "continuousCheckbox    =    new   JCheckBox (  )  ;", "contentPanel . add ( continuousCheckbox ,    new   GridBagConstraints (  1  ,     3  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Aligned :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     4  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "alignedCheckbox    =    new   JCheckBox (  )  ;", "contentPanel . add ( alignedCheckbox ,    new   GridBagConstraints (  1  ,     4  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Behind :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "behindCheckbox    =    new   JCheckBox (  )  ;", "contentPanel . add ( behindCheckbox ,    new   GridBagConstraints (  1  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Premultiplied   Alpha :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     6  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "premultipliedAlphaCheckbox    =    new   JCheckBox (  )  ;", "contentPanel . add ( premultipliedAlphaCheckbox ,    new   GridBagConstraints (  1  ,     6  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  6  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.OptionsPanel"}, {"methodBody": ["METHOD_START", "{", "row . setBorder ( BorderFactory . createMatteBorder (  0  ,     0  ,     1  ,     0  ,    Color . black )  )  ;", "RowsPanel . add ( row ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["addEditorRow"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "row . setBorder ( BorderFactory . createMatteBorder (  0  ,     0  ,     1  ,     0  ,    Color . black )  )  ;", "rowsPanel . add ( row ,    new   GridBagConstraints (  0  ,     (  -  1  )  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . HORIZONTAL ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["addRow"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "return   effect . getEmitters (  )  . get ( effectPanel . editIndex )  ;", "}", "METHOD_END"], "methodName": ["getEmitter"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "splitPane    =    new   JSplitPane (  )  ;", "splitPane . setUI ( new   BasicSplitPaneUI (  )     {", "public   void   paint ( Graphics   g ,    JComponent   jc )     {", "}", "}  )  ;", "splitPane . setDividerSize (  4  )  ;", "getContentPane (  )  . add ( splitPane ,    BorderLayout . CENTER )  ;", "{", "JSplitPane   rightSplit    =    new   JSplitPane ( JSplitPane . VERTICAL _ SPLIT )  ;", "rightSplit . setUI ( new   BasicSplitPaneUI (  )     {", "public   void   paint ( Graphics   g ,    JComponent   jc )     {", "}", "}  )  ;", "rightSplit . setDividerSize (  4  )  ;", "splitPane . add ( rightSplit ,    JSplitPane . RIGHT )  ;", "{", "JPanel   propertiesPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "rightSplit . add ( propertiesPanel ,    JSplitPane . TOP )  ;", "propertiesPanel . setBorder ( new   CompoundBorder ( BorderFactory . createEmptyBorder (  3  ,     0  ,     6  ,     6  )  ,    BorderFactory . createTitledBorder (  \"    Properties \"  )  )  )  ;", "{", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "propertiesPanel . add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . NORTH ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "scroll . setBorder ( BorderFactory . createEmptyBorder (  0  ,     0  ,     0  ,     0  )  )  ;", "{", "editRowsPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "scroll . setViewportView ( editRowsPanel )  ;", "scroll . getVerticalScrollBar (  )  . setUnitIncrement (  7  0  )  ;", "}", "}", "}", "{", "JPanel   propertiesPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "rightSplit . add ( propertiesPanel ,    JSplitPane . BOTTOM )  ;", "propertiesPanel . setBorder ( new   CompoundBorder ( BorderFactory . createEmptyBorder (  3  ,     0  ,     6  ,     6  )  ,    BorderFactory . createTitledBorder (  \" Emitter   Properties \"  )  )  )  ;", "{", "JScrollPane   scroll    =    new   JScrollPane (  )  ;", "propertiesPanel . add ( scroll ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     1  ,     1  ,    GridBagConstraints . NORTH ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "scroll . setBorder ( BorderFactory . createEmptyBorder (  0  ,     0  ,     0  ,     0  )  )  ;", "{", "rowsPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "scroll . setViewportView ( rowsPanel )  ;", "scroll . getVerticalScrollBar (  )  . setUnitIncrement (  7  0  )  ;", "}", "}", "}", "rightSplit . setDividerLocation (  2  0  0  )  ;", "}", "{", "JSplitPane   leftSplit    =    new   JSplitPane ( JSplitPane . VERTICAL _ SPLIT )  ;", "leftSplit . setUI ( new   BasicSplitPaneUI (  )     {", "public   void   paint ( Graphics   g ,    JComponent   jc )     {", "}", "}  )  ;", "leftSplit . setDividerSize (  4  )  ;", "splitPane . add ( leftSplit ,    JSplitPane . LEFT )  ;", "{", "JPanel   spacer    =    new   JPanel ( new   BorderLayout (  )  )  ;", "leftSplit . add ( spacer ,    JSplitPane . BOTTOM )  ;", "spacer . add ( lwjglCanvas . getCanvas (  )  )  ;", "spacer . setBorder ( BorderFactory . createEmptyBorder (  0  ,     0  ,     0  ,     4  )  )  ;", "}", "{", "JPanel   emittersPanel    =    new   JPanel ( new   BorderLayout (  )  )  ;", "leftSplit . add ( emittersPanel ,    JSplitPane . TOP )  ;", "emittersPanel . setBorder ( new   CompoundBorder ( BorderFactory . createEmptyBorder (  0  ,     6  ,     6  ,     0  )  ,    BorderFactory . createTitledBorder (  \" Effect   Emitters \"  )  )  )  ;", "{", "effectPanel    =    new   EffectPanel ( this )  ;", "emittersPanel . add ( effectPanel )  ;", "}", "}", "leftSplit . setDividerLocation (  5  7  5  )  ;", "}", "splitPane . setDividerLocation (  3  2  5  )  ;", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "ParticleEditor . ParticleData   data    =    particleData . get ( emitter )  ;", "if    ( data    =  =    null )", "return   true ;", "return   data . enabled ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "for    ( UIManager . LookAndFeelInfo   info    :    UIManager . getInstalledLookAndFeels (  )  )     {", "if    (  \" Nimbus \"  . equals ( info . getName (  )  )  )     {", "try    {", "UIManager . setLookAndFeel ( info . getClassName (  )  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "break ;", "}", "}", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "new    (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "editRowsPanel . removeAll (  )  ;", "addEditorRow ( new   NumericPanel ( pixelsPerMeter ,     \" Pixels   per   meter \"  ,     \"  \"  )  )  ;", "addEditorRow ( new   NumericPanel ( zoomLevel ,     \" Zoom   level \"  ,     \"  \"  )  )  ;", "addEditorRow ( new   NumericPanel ( deltaMultiplier ,     \" Delta   multiplier \"  ,     \"  \"  )  )  ;", "addEditorRow ( new   GradientPanel ( backgroundColor ,     \" Background   color \"  ,     \"  \"  ,    true )  )  ;", "rowsPanel . removeAll (  )  ;", "ParticleEmitter   emitter    =    getEmitter (  )  ;", "addRow ( new   ImagePanel (  . this ,     \" Images \"  ,     \"  \"  )  )  ;", "addRow ( new   CountPanel (  . this ,     \" Count \"  ,     \" Min   number   of   particles   at   all   times ,    max   number   of   particles   allowed .  \"  )  )  ;", "addRow ( new   RangedNumericPanel ( emitter . getDelay (  )  ,     \" Delay \"  ,     \" Time   from   beginning   of   effect   to   emission   start ,    in   milliseconds .  \"  )  )  ;", "addRow ( new   RangedNumericPanel ( emitter . getDuration (  )  ,     \" Duration \"  ,     \" Time   particles   will   be   emitted ,    in   milliseconds .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getEmission (  )  ,     \" Duration \"  ,     \" Emission \"  ,     \" Number   of   particles   emitted   per   second .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getLife (  )  ,     \" Duration \"  ,     \" Life \"  ,     \" Time   particles   will   live ,    in   milliseconds .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getLifeOffset (  )  ,     \" Duration \"  ,     \" Life   Offset \"  ,     \" Particle   starting   life   consumed ,    in   milliseconds .  \"  )  )  ;", "addRow ( new   RangedNumericPanel ( emitter . getXOffsetValue (  )  ,     \" X   Offset \"  ,     \" Amount   to   offset   a   particle ' s   starting   X   location ,    in   world   units .  \"  )  )  ;", "addRow ( new   RangedNumericPanel ( emitter . getYOffsetValue (  )  ,     \" Y   Offset \"  ,     \" Amount   to   offset   a   particle ' s   starting   Y   location ,    in   world   units .  \"  )  )  ;", "addRow ( new   SpawnPanel (  . this ,    emitter . getSpawnShape (  )  ,     \" Spawn \"  ,     \" Shape   used   to   spawn   particles .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getSpawnWidth (  )  ,     \" Duration \"  ,     \" Spawn   Width \"  ,     \" Width   of   the   spawn   shape ,    in   world   units .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getSpawnHeight (  )  ,     \" Duration \"  ,     \" Spawn   Height \"  ,     \" Height   of   the   spawn   shape ,    in   world   units .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getXScale (  )  ,     \" Life \"  ,     \" X   Size \"  ,     \" Particle   x   size ,    in   world   units .    If   Y   Size   is   not   active ,    this   also   controls   the   y   size \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getYScale (  )  ,     \" Life \"  ,     \" Y   Size \"  ,     \" Particle   y   size ,    in   world   units .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getVelocity (  )  ,     \" Life \"  ,     \" Velocity \"  ,     \" Particle   speed ,    in   world   units   per   second .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getAngle (  )  ,     \" Life \"  ,     \" Angle \"  ,     \" Particle   emission   angle ,    in   degrees .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getRotation (  )  ,     \" Life \"  ,     \" Rotation \"  ,     \" Particle   rotation ,    in   degrees .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getWind (  )  ,     \" Life \"  ,     \" Wind \"  ,     \" Wind   strength ,    in   world   units   per   second .  \"  )  )  ;", "addRow ( new   ScaledNumericPanel ( emitter . getGravity (  )  ,     \" Life \"  ,     \" Gravity \"  ,     \" Gravity   strength ,    in   world   units   per   second .  \"  )  )  ;", "addRow ( new   GradientPanel ( emitter . getTint (  )  ,     \" Tint \"  ,     \"  \"  ,    false )  )  ;", "addRow ( new   PercentagePanel ( emitter . getTransparency (  )  ,     \" Life \"  ,     \" Transparency \"  ,     \"  \"  )  )  ;", "addRow ( new   OptionsPanel (  . this ,     \" Options \"  ,     \"  \"  )  )  ;", "for    ( Component   component    :    rowsPanel . getComponents (  )  )", "if    ( component   instanceof   EditorPanel )", "(  ( EditorPanel )     ( component )  )  . update (  . this )  ;", "rowsPanel . repaint (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["reloadRows"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "ParticleEditor . ParticleData   data    =    particleData . get ( emitter )  ;", "if    ( data    =  =    null )", "particleData . put ( emitter ,     ( data    =    new   ParticleEditor . ParticleData (  )  )  )  ;", "data . enabled    =    enabled ;", "emitter . reset (  )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "for    ( Component   component    :    rowsPanel . getComponents (  )  )", "if    (  ( component   instanceof   Panel )     &  &     (  (  ( Panel )     ( component )  )  . getName (  )  . equals ( name )  )  )", "component . setVisible ( visible )  ;", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.tools.particleeditor.ParticleEditor"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "chart    =    new   Chart ( chartTitle )     {", "public   void   pointsChanged (  )     {", "value . setTimeline ( chart . getValuesX (  )  )  ;", "value . setScaling ( chart . getValuesY (  )  )  ;", "}", "}  ;", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     6  2  )  )  ;", "contentPanel . add ( chart ,    new   GridBagConstraints (  0  ,     0  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "expandButton    =    new   JButton (  \"  +  \"  )  ;", "expandButton . setBorder ( BorderFactory . createEmptyBorder (  4  ,     1  0  ,     4  ,     1  0  )  )  ;", "contentPanel . add ( expandButton ,    new   GridBagConstraints (  1  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.PercentagePanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "label    =    new   JLabel (  \" Value :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  2  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "minSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  )  ,     9  9  9  9  9  ,     1  ,     (  -  4  0  0  )  ,     4  0  0  )  ;", "contentPanel . add ( minSlider ,    new   GridBagConstraints (  3  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "maxSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  )  ,     9  9  9  9  9  ,     1  ,     (  -  4  0  0  )  ,     4  0  0  )  ;", "contentPanel . add ( maxSlider ,    new   GridBagConstraints (  4  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "rangeButton    =    new   JButton (  \"  <  \"  )  ;", "rangeButton . setBorder ( BorderFactory . createEmptyBorder (  6  ,     6  ,     6  ,     6  )  )  ;", "contentPanel . add ( rangeButton ,    new   GridBagConstraints (  5  ,     2  ,     1  ,     1  ,     1  .  0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.RangedNumericPanel"}, {"methodBody": ["METHOD_START", "{", "return   formPanel ;", "}", "METHOD_END"], "methodName": ["getFormPanel"], "fileName": "com.badlogic.gdx.tools.particleeditor.ScaledNumericPanel"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "formPanel    =    new   JPanel ( new   GridBagLayout (  )  )  ;", "contentPanel . add ( formPanel ,    new   GridBagConstraints (  5  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "{", "JLabel   label    =    new   JLabel (  \" High :  \"  )  ;", "formPanel . add ( label ,    new   GridBagConstraints (  2  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "highMinSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  )  ,     9  9  9  9  9  ,     1  .  0 F ,     (  -  4  0  0  )  ,     4  0  0  )  ;", "formPanel . add ( highMinSlider ,    new   GridBagConstraints (  3  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "highMaxSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  )  ,     9  9  9  9  9  ,     1  .  0 F ,     (  -  4  0  0  )  ,     4  0  0  )  ;", "formPanel . add ( highMaxSlider ,    new   GridBagConstraints (  4  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "highRangeButton    =    new   JButton (  \"  <  \"  )  ;", "highRangeButton . setBorder ( BorderFactory . createEmptyBorder (  6  ,     6  ,     6  ,     6  )  )  ;", "formPanel . add ( highRangeButton ,    new   GridBagConstraints (  5  ,     1  ,     1  ,     1  ,     0  .  0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JLabel   label    =    new   JLabel (  \" Low :  \"  )  ;", "formPanel . add ( label ,    new   GridBagConstraints (  2  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "lowMinSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  )  ,     9  9  9  9  9  ,     1  .  0 F ,     (  -  4  0  0  )  ,     4  0  0  )  ;", "formPanel . add ( lowMinSlider ,    new   GridBagConstraints (  3  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "lowMaxSlider    =    new   Slider (  0  ,     (  -  9  9  9  9  9  )  ,     9  9  9  9  9  ,     1  .  0 F ,     (  -  4  0  0  )  ,     4  0  0  )  ;", "formPanel . add ( lowMaxSlider ,    new   GridBagConstraints (  4  ,     2  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "lowRangeButton    =    new   JButton (  \"  <  \"  )  ;", "lowRangeButton . setBorder ( BorderFactory . createEmptyBorder (  6  ,     6  ,     6  ,     6  )  )  ;", "formPanel . add ( lowRangeButton ,    new   GridBagConstraints (  5  ,     2  ,     1  ,     1  ,     0  .  0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "{", "chart    =    new   Chart ( chartTitle )     {", "public   void   pointsChanged (  )     {", "value . setTimeline ( chart . getValuesX (  )  )  ;", "value . setScaling ( chart . getValuesY (  )  )  ;", "}", "}  ;", "contentPanel . add ( chart ,    new   GridBagConstraints (  6  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . CENTER ,    GridBagConstraints . BOTH ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "chart . setPreferredSize ( new   Dimension (  1  5  0  ,     3  0  )  )  ;", "}", "{", "expandButton    =    new   JButton (  \"  +  \"  )  ;", "contentPanel . add ( expandButton ,    new   GridBagConstraints (  7  ,     5  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . SOUTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     5  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "expandButton . setBorder ( BorderFactory . createEmptyBorder (  4  ,     8  ,     4  ,     8  )  )  ;", "}", "{", "relativeCheckBox    =    new   JCheckBox (  \" Relative \"  )  ;", "contentPanel . add ( relativeCheckBox ,    new   GridBagConstraints (  7  ,     5  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . NORTHWEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     6  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.ScaledNumericPanel"}, {"methodBody": ["METHOD_START", "{", "spinner . addChangeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addChangeListener"], "fileName": "com.badlogic.gdx.tools.particleeditor.Slider"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    super . getPreferredSize (  )  ;", "size . width    =     7  5  ;", "size . height    =     2  6  ;", "return   size ;", "}", "METHOD_END"], "methodName": ["getPreferredSize"], "fileName": "com.badlogic.gdx.tools.particleeditor.Slider"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Double )     ( spinner . getValue (  )  )  )  . floatValue (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.tools.particleeditor.Slider"}, {"methodBody": ["METHOD_START", "{", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "JFrame   frame    =    new   JFrame (  )  ;", "frame . setDefaultCloseOperation ( JFrame . DISPOSE _ ON _ CLOSE )  ;", "frame . setSize (  4  8  0  ,     3  2  0  )  ;", "frame . setLocationRelativeTo ( null )  ;", "JPanel   panel    =    new   JPanel (  )  ;", "frame . getContentPane (  )  . add ( panel )  ;", "panel . add ( new    (  2  0  0  ,     1  0  0  ,     5  0  0  ,     0  .  1 F ,     1  5  0  ,     3  0  0  )  )  ;", "frame . setVisible ( true )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.particleeditor.Slider"}, {"methodBody": ["METHOD_START", "{", "spinner . setValue (  (  ( double )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.tools.particleeditor.Slider"}, {"methodBody": ["METHOD_START", "{", "JPanel   contentPanel    =    getContentPanel (  )  ;", "{", "JLabel   label    =    new   JLabel (  \" Shape :  \"  )  ;", "contentPanel . add ( label ,    new   GridBagConstraints (  0  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "shapeCombo    =    new   JComboBox (  )  ;", "shapeCombo . setModel ( new   DefaultComboBoxModel ( SpawnShape . values (  )  )  )  ;", "contentPanel . add ( shapeCombo ,    new   GridBagConstraints (  1  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "edgesLabel    =    new   JLabel (  \" Edges :  \"  )  ;", "contentPanel . add ( edgesLabel ,    new   GridBagConstraints (  2  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  2  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "edgesCheckbox    =    new   JCheckBox (  )  ;", "contentPanel . add ( edgesCheckbox ,    new   GridBagConstraints (  3  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "sideLabel    =    new   JLabel (  \" Side :  \"  )  ;", "contentPanel . add ( sideLabel ,    new   GridBagConstraints (  4  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . EAST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     1  2  ,     0  ,     6  )  ,     0  ,     0  )  )  ;", "}", "{", "sideCombo    =    new   JComboBox (  )  ;", "sideCombo . setModel ( new   DefaultComboBoxModel ( SpawnEllipseSide . values (  )  )  )  ;", "contentPanel . add ( sideCombo ,    new   GridBagConstraints (  5  ,     1  ,     1  ,     1  ,     0  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "{", "JPanel   spacer    =    new   JPanel (  )  ;", "spacer . setPreferredSize ( new   Dimension (  )  )  ;", "contentPanel . add ( spacer ,    new   GridBagConstraints (  6  ,     0  ,     1  ,     1  ,     1  ,     0  ,    GridBagConstraints . WEST ,    GridBagConstraints . NONE ,    new   Insets (  0  ,     0  ,     0  ,     0  )  ,     0  ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "com.badlogic.gdx.tools.particleeditor.SpawnPanel"}, {"methodBody": ["METHOD_START", "{", "edgesCheckbox . setVisible ( visible )  ;", "edgesLabel . setVisible ( visible )  ;", "visible    =    visible    &  &     ( edgesCheckbox . isSelected (  )  )  ;", "sideCombo . setVisible ( visible )  ;", "sideLabel . setVisible ( visible )  ;", "}", "METHOD_END"], "methodName": ["setEdgesVisible"], "fileName": "com.badlogic.gdx.tools.particleeditor.SpawnPanel"}, {"methodBody": ["METHOD_START", "{", "shapeCombo . setSelectedItem ( editor . getEmitter (  )  . getSpawnShape (  )  . getShape (  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.tools.particleeditor.SpawnPanel"}, {"methodBody": ["METHOD_START", "{", "ColorBleedEffect . Mask . MaskIterator   iterator    =    mask . new   MaskIterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", "int   pixelIndex    =    iterator . next (  )  ;", "int   x    =    pixelIndex    %    width ;", "int   y    =    pixelIndex    /    width ;", "int   r    =     0  ;", "int   g    =     0  ;", "int   b    =     0  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    ColorBleedEffect . offsets . length ;    i    <    n ;    i +  +  )     {", "int [  ]    offset    =    ColorBleedEffect . offsets [ i ]  ;", "int   column    =    x    +     ( offset [  0  ]  )  ;", "int   row    =    y    +     ( offset [  1  ]  )  ;", "if    (  (  (  ( column    <     0  )     |  |     ( column    >  =    width )  )     |  |     ( row    <     0  )  )     |  |     ( row    >  =    height )  )", "continue ;", "int   currentPixelIndex    =    getPixelIndex ( width ,    column ,    row )  ;", "if    (  ( mask . getMask ( currentPixelIndex )  )     =  =     ( ColorBleedEffect . REALDATA )  )     {", "color . argb    =    rgb [ currentPixelIndex ]  ;", "r    +  =    color . red (  )  ;", "g    +  =    color . green (  )  ;", "b    +  =    color . blue (  )  ;", "count +  +  ;", "}", "}", "if    ( count    !  =     0  )     {", "color . setARGBA (  0  ,     ( r    /    count )  ,     ( g    /    count )  ,     ( b    /    count )  )  ;", "rgb [ pixelIndex ]     =    color . argb ;", "iterator . markAsInProgress (  )  ;", "}", "}", "iterator . reset (  )  ;", "}", "METHOD_END"], "methodName": ["executeIteration"], "fileName": "com.badlogic.gdx.tools.texturepacker.ColorBleedEffect"}, {"methodBody": ["METHOD_START", "{", "return    ( y    *    width )     +    x ;", "}", "METHOD_END"], "methodName": ["getPixelIndex"], "fileName": "com.badlogic.gdx.tools.texturepacker.ColorBleedEffect"}, {"methodBody": ["METHOD_START", "{", "int   width    =    image . getWidth (  )  ;", "int   height    =    image . getHeight (  )  ;", "BufferedImage   processedImage    =    new   BufferedImage ( width ,    height ,    BufferedImage . TYPE _ INT _ ARGB )  ;", "int [  ]    rgb    =    image . getRGB (  0  ,     0  ,    width ,    height ,    null ,     0  ,    width )  ;", ". Mask   mask    =    new    . Mask ( rgb )  ;", "int   iterations    =     0  ;", "int   lastPending    =     -  1  ;", "while    (  (  (  ( mask . pendingSize )     >     0  )     &  &     (  ( mask . pendingSize )     !  =    lastPending )  )     &  &     ( iterations    <    maxIterations )  )     {", "lastPending    =    mask . pendingSize ;", "executeIteration ( rgb ,    mask ,    width ,    height )  ;", "iterations +  +  ;", "}", "processedImage . setRGB (  0  ,     0  ,    width ,    height ,    rgb ,     0  ,    width )  ;", "return   processedImage ;", "}", "METHOD_END"], "methodName": ["processImage"], "fileName": "com.badlogic.gdx.tools.texturepacker.ColorBleedEffect"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( settings . silent )  )", "System . out . print (  \" Packing \"  )  ;", "int   n    =    inputRects . size ;", "int   cellWidth    =     0  ;", "int   cellHeight    =     0  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "TPacker . Rect   rect    =    inputRects . get ( i )  ;", "cellWidth    =    Math . max ( cellWidth ,    rect . width )  ;", "cellHeight    =    Math . max ( cellHeight ,    rect . height )  ;", "}", "cellWidth    +  =    settings . paddingX ;", "cellHeight    +  =    settings . paddingY ;", "inputRects . reverse (  )  ;", "Array < TPacker . Page >    pages    =    new   Array (  )  ;", "while    (  ( inputRects . size )     >     0  )     {", "if    (  ( progress    !  =    null )     &  &     ( progress . update (  (  ( n    -     ( inputRects . size )  )     +     1  )  ,    n )  )  )", "break ;", "TPacker . Page   result    =    packPage ( inputRects ,    cellWidth ,    cellHeight )  ;", "pages . add ( result )  ;", "}", "return   pages ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.tools.texturepacker.GridPacker"}, {"methodBody": ["METHOD_START", "{", "return   pack ( null ,    inputRects )  ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.tools.texturepacker.GridPacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . Page   page    =    new   TexturePacker . Page (  )  ;", "page . outputRects    =    new   Array (  )  ;", "int   maxWidth    =    settings . maxWidth ;", "int   maxHeight    =    settings . maxHeight ;", "if    ( settings . edgePadding )     {", "maxWidth    -  =    settings . paddingX ;", "maxHeight    -  =    settings . paddingY ;", "}", "int   n    =    inputRects . size ;", "int   x    =     0  ;", "int   y    =     0  ;", "for    ( int   i    =    n    -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    (  ( x    +    cellWidth )     >    maxWidth )     {", "y    +  =    cellHeight ;", "if    ( y    >     ( maxHeight    -    cellHeight )  )", "break ;", "x    =     0  ;", "}", "TexturePacker . Rect   rect    =    inputRects . removeIndex ( i )  ;", "rect . x    =    x ;", "rect . y    =    y ;", "rect . width    +  =    settings . paddingX ;", "rect . height    +  =    settings . paddingY ;", "page . outputRects . add ( rect )  ;", "x    +  =    cellWidth ;", "page . width    =    Math . max ( page . width ,    x )  ;", "page . height    =    Math . max ( page . height ,     ( y    +    cellHeight )  )  ;", "}", "for    ( int   i    =     ( page . outputRects . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "TexturePacker . Rect   rect    =    page . outputRects . get ( i )  ;", "rect . y    =     (  ( page . height )     -     ( rect . y )  )     -     ( rect . height )  ;", "}", "return   page ;", "}", "METHOD_END"], "methodName": ["packPage"], "fileName": "com.badlogic.gdx.tools.texturepacker.GridPacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . Rect   rect    =    processImage ( image ,    name )  ;", "if    ( rect    =  =    null )     {", "if    (  !  ( settings . silent )  )", "System . out . println (  (  \" Ignoring   blank   input   image :     \"     +    name )  )  ;", "return   null ;", "}", "if    ( settings . alias )     {", "String   crc    =     . hash ( rect . getImage ( this )  )  ;", "TexturePacker . Rect   existing    =    crcs . get ( crc )  ;", "if    ( existing    !  =    null )     {", "if    (  !  ( settings . silent )  )     {", "String   rectName    =     ( rect . name )     +     (  ( rect . index )     !  =     (  -  1  )     ?     \"  _  \"     +     ( rect . index )     :     \"  \"  )  ;", "String   existingName    =     ( existing . name )     +     (  ( existing . index )     !  =     (  -  1  )     ?     \"  _  \"     +     ( existing . index )     :     \"  \"  )  ;", "System . out . println (  (  (  ( rectName    +     \"     ( alias   of    \"  )     +    existingName )     +     \"  )  \"  )  )  ;", "}", "existing . aliases . add ( new   TexturePacker . Alias ( rect )  )  ;", "return   null ;", "}", "crcs . put ( crc ,    rect )  ;", "}", "rects . add ( rect )  ;", "return   rect ;", "}", "METHOD_END"], "methodName": ["addImage"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   image ;", "try    {", "image    =    ImageIO . read ( file )  ;", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  (  \" Error   reading   image :     \"     +    file )  ,    ex )  ;", "}", "if    ( image    =  =    null )", "throw   new   RuntimeException (  (  \" Unable   to   read   image :     \"     +    file )  )  ;", "String   name    =    file . getAbsolutePath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "if    (  ( rootPath )     !  =    null )     {", "if    (  !  ( name . startsWith ( rootPath )  )  )", "throw   new   RuntimeException (  (  (  (  \" Path    '  \"     +    name )     +     \"  '    does   not   start   with   root :     \"  )     +     ( rootPath )  )  )  ;", "name    =    name . substring ( rootPath . length (  )  )  ;", "}", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    !  =     (  -  1  )  )", "name    =    name . substring (  0  ,    dotIndex )  ;", "TPacker . Rect   rect    =    addImage ( image ,    name )  ;", "if    (  ( rect    !  =    null )     &  &     ( settings . limitMemory )  )", "rect . unloadImage ( file )  ;", "}", "METHOD_END"], "methodName": ["addImage"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "rects . clear (  )  ;", "crcs . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "return   rects ;", "}", "METHOD_END"], "methodName": ["getImages"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "WritableRaster   raster    =    image . getRaster (  )  ;", "int   bottom    =     ( raster . getHeight (  )  )     -     1  ;", "int   right    =     ( raster . getWidth (  )  )     -     1  ;", "int   startX    =     . getSplitPoint ( raster ,    name ,     1  ,    bottom ,    true ,    true )  ;", "int   startY    =     . getSplitPoint ( raster ,    name ,    right ,     1  ,    true ,    false )  ;", "int   endX    =     0  ;", "int   endY    =     0  ;", "if    ( startX    !  =     0  )", "endX    =     . getSplitPoint ( raster ,    name ,     ( startX    +     1  )  ,    bottom ,    false ,    true )  ;", "if    ( startY    !  =     0  )", "endY    =     . getSplitPoint ( raster ,    name ,    right ,     ( startY    +     1  )  ,    false ,    false )  ;", ". getSplitPoint ( raster ,    name ,     ( endX    +     1  )  ,    bottom ,    true ,    true )  ;", ". getSplitPoint ( raster ,    name ,    right ,     ( endY    +     1  )  ,    true ,    false )  ;", "if    (  (  (  ( startX    =  =     0  )     &  &     ( endX    =  =     0  )  )     &  &     ( startY    =  =     0  )  )     &  &     ( endY    =  =     0  )  )     {", "return   null ;", "}", "if    (  ( startX    =  =     0  )     &  &     ( endX    =  =     0  )  )     {", "startX    =     -  1  ;", "endX    =     -  1  ;", "} else    {", "if    ( startX    >     0  )     {", "startX -  -  ;", "endX    =     (  ( raster . getWidth (  )  )     -     2  )     -     ( endX    -     1  )  ;", "} else    {", "endX    =     ( raster . getWidth (  )  )     -     2  ;", "}", "}", "if    (  ( startY    =  =     0  )     &  &     ( endY    =  =     0  )  )     {", "startY    =     -  1  ;", "endY    =     -  1  ;", "} else    {", "if    ( startY    >     0  )     {", "startY -  -  ;", "endY    =     (  ( raster . getHeight (  )  )     -     2  )     -     ( endY    -     1  )  ;", "} else    {", "endY    =     ( raster . getHeight (  )  )     -     2  ;", "}", "}", "if    (  ( scale )     !  =     1  )     {", "startX    =     (  ( int )     ( Math . round (  ( startX    *     ( scale )  )  )  )  )  ;", "endX    =     (  ( int )     ( Math . round (  ( endX    *     ( scale )  )  )  )  )  ;", "startY    =     (  ( int )     ( Math . round (  ( startY    *     ( scale )  )  )  )  )  ;", "endY    =     (  ( int )     ( Math . round (  ( endY    *     ( scale )  )  )  )  )  ;", "}", "int [  ]    pads    =    new   int [  ]  {    startX ,    endX ,    startY ,    endY    }  ;", "if    (  ( splits    !  =    null )     &  &     ( Arrays . equals ( pads ,    splits )  )  )     {", "return   null ;", "}", "return   pads ;", "}", "METHOD_END"], "methodName": ["getPads"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "int [  ]    rgba    =    new   int [  4  ]  ;", "int   next    =     ( xAxis )     ?    startX    :    startY ;", "int   end    =     ( xAxis )     ?    raster . getWidth (  )     :    raster . getHeight (  )  ;", "int   breakA    =     ( startPoint )     ?     2  5  5     :     0  ;", "int   x    =    startX ;", "int   y    =    startY ;", "while    ( next    !  =    end )     {", "if    ( xAxis )", "x    =    next ;", "else", "y    =    next ;", "raster . getPixel ( x ,    y ,    rgba )  ;", "if    (  ( rgba [  3  ]  )     =  =    breakA )", "return   next ;", "if    (  (  ! startPoint )     &  &     (  (  (  (  ( rgba [  0  ]  )     !  =     0  )     |  |     (  ( rgba [  1  ]  )     !  =     0  )  )     |  |     (  ( rgba [  2  ]  )     !  =     0  )  )     |  |     (  ( rgba [  3  ]  )     !  =     2  5  5  )  )  )", ". splitError ( x ,    y ,    rgba ,    name )  ;", "next +  +  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["getSplitPoint"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "WritableRaster   raster    =    image . getRaster (  )  ;", "int   startX    =     . getSplitPoint ( raster ,    name ,     1  ,     0  ,    true ,    true )  ;", "int   endX    =     . getSplitPoint ( raster ,    name ,    startX ,     0  ,    false ,    true )  ;", "int   startY    =     . getSplitPoint ( raster ,    name ,     0  ,     1  ,    true ,    false )  ;", "int   endY    =     . getSplitPoint ( raster ,    name ,     0  ,    startY ,    false ,    false )  ;", ". getSplitPoint ( raster ,    name ,     ( endX    +     1  )  ,     0  ,    true ,    true )  ;", ". getSplitPoint ( raster ,    name ,     0  ,     ( endY    +     1  )  ,    true ,    false )  ;", "if    (  (  (  ( startX    =  =     0  )     &  &     ( endX    =  =     0  )  )     &  &     ( startY    =  =     0  )  )     &  &     ( endY    =  =     0  )  )", "return   null ;", "if    ( startX    !  =     0  )     {", "startX -  -  ;", "endX    =     (  ( raster . getWidth (  )  )     -     2  )     -     ( endX    -     1  )  ;", "} else    {", "endX    =     ( raster . getWidth (  )  )     -     2  ;", "}", "if    ( startY    !  =     0  )     {", "startY -  -  ;", "endY    =     (  ( raster . getHeight (  )  )     -     2  )     -     ( endY    -     1  )  ;", "} else    {", "endY    =     ( raster . getHeight (  )  )     -     2  ;", "}", "if    (  ( scale )     !  =     1  )     {", "startX    =     (  ( int )     ( Math . round (  ( startX    *     ( scale )  )  )  )  )  ;", "endX    =     (  ( int )     ( Math . round (  ( endX    *     ( scale )  )  )  )  )  ;", "startY    =     (  ( int )     ( Math . round (  ( startY    *     ( scale )  )  )  )  )  ;", "endY    =     (  ( int )     ( Math . round (  ( endY    *     ( scale )  )  )  )  )  ;", "}", "return   new   int [  ]  {    startX ,    endX ,    startY ,    endY    }  ;", "}", "METHOD_END"], "methodName": ["getSplits"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "MessageDigest   digest    =    MessageDigest . getInstance (  \" SHA 1  \"  )  ;", "int   width    =    image . getWidth (  )  ;", "int   height    =    image . getHeight (  )  ;", "if    (  ( image . getType (  )  )     !  =     ( BufferedImage . TYPE _ INT _ ARGB )  )     {", "BufferedImage   newImage    =    new   BufferedImage ( width ,    height ,    BufferedImage . TYPE _ INT _ ARGB )  ;", "newImage . getGraphics (  )  . drawImage ( image ,     0  ,     0  ,    null )  ;", "image    =    newImage ;", "}", "WritableRaster   raster    =    image . getRaster (  )  ;", "int [  ]    pixels    =    new   int [ width ]  ;", "for    ( int   y    =     0  ;    y    <    height ;    y +  +  )     {", "raster . getDataElements (  0  ,    y ,    width ,     1  ,    pixels )  ;", "for    ( int   x    =     0  ;    x    <    width ;    x +  +  )", ". hash ( digest ,    pixels [ x ]  )  ;", "}", ". hash ( digest ,    width )  ;", ". hash ( digest ,    height )  ;", "return   new   BigInteger (  1  ,    digest . digest (  )  )  . toString (  1  6  )  ;", "}    catch    ( NoSuchAlgorithmException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["hash"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "digest . update (  (  ( byte )     ( value    >  >     2  4  )  )  )  ;", "digest . update (  (  ( byte )     ( value    >  >     1  6  )  )  )  ;", "digest . update (  (  ( byte )     ( value    >  >     8  )  )  )  ;", "digest . update (  (  ( byte )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["hash"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( scale )     <  =     0  )", "throw   new   IllegalArgumentException (  (  \" scale   cannot   be    <  =     0  :     \"     +     ( scale )  )  )  ;", "int   width    =    image . getWidth (  )  ;", "int   height    =    image . getHeight (  )  ;", "if    (  ( image . getType (  )  )     !  =     ( BufferedImage . TYPE _  4 BYTE _ ABGR )  )     {", "BufferedImage   newImage    =    new   BufferedImage ( width ,    height ,    BufferedImage . TYPE _  4 BYTE _ ABGR )  ;", "newImage . getGraphics (  )  . drawImage ( image ,     0  ,     0  ,    null )  ;", "image    =    newImage ;", "}", "boolean   isPatch    =    name . endsWith (  \"  .  9  \"  )  ;", "int [  ]    splits    =    null ;", "int [  ]    pads    =    null ;", "TexturePacker . Rect   rect    =    null ;", "if    ( isPatch )     {", "name    =    name . substring (  0  ,     (  ( name . length (  )  )     -     2  )  )  ;", "splits    =    getSplits ( image ,    name )  ;", "pads    =    getPads ( image ,    name ,    splits )  ;", "width    -  =     2  ;", "height    -  =     2  ;", "BufferedImage   newImage    =    new   BufferedImage ( width ,    height ,    BufferedImage . TYPE _  4 BYTE _ ABGR )  ;", "newImage . getGraphics (  )  . drawImage ( image ,     0  ,     0  ,    width ,    height ,     1  ,     1  ,     ( width    +     1  )  ,     ( height    +     1  )  ,    null )  ;", "image    =    newImage ;", "}", "if    (  ( scale )     !  =     1  )     {", "int   originalWidth    =    width ;", "int   originalHeight    =    height ;", "width    =    Math . max (  1  ,    Math . round (  ( width    *     ( scale )  )  )  )  ;", "height    =    Math . max (  1  ,    Math . round (  ( height    *     ( scale )  )  )  )  ;", "BufferedImage   newImage    =    new   BufferedImage ( width ,    height ,    BufferedImage . TYPE _  4 BYTE _ ABGR )  ;", "if    (  ( scale )     <     1  )     {", "newImage . getGraphics (  )  . drawImage ( image . getScaledInstance ( width ,    height ,    Image . SCALE _ AREA _ AVERAGING )  ,     0  ,     0  ,    null )  ;", "} else    {", "Graphics 2 D   g    =     (  ( Graphics 2 D )     ( newImage . getGraphics (  )  )  )  ;", "g . setRenderingHint ( RenderingHints . KEY _ RENDERING ,    RenderingHints . VALUE _ RENDER _ QUALITY )  ;", "g . setRenderingHint ( RenderingHints . KEY _ INTERPOLATION ,    resampling . value )  ;", "g . drawImage ( image ,     0  ,     0  ,    width ,    height ,    null )  ;", "}", "image    =    newImage ;", "}", "if    ( isPatch )     {", "rect    =    new   TexturePacker . Rect ( image ,     0  ,     0  ,    width ,    height ,    true )  ;", "rect . splits    =    splits ;", "rect . pads    =    pads ;", "rect . canRotate    =    false ;", "} else    {", "rect    =    stripWhitespace ( image )  ;", "if    ( rect    =  =    null )", "return   null ;", "}", "int   index    =     -  1  ;", "if    ( settings . useIndexes )     {", "Matcher   matcher    =     . indexPattern . matcher ( name )  ;", "if    ( matcher . matches (  )  )     {", "name    =    matcher . group (  1  )  ;", "index    =    Integer . parseInt ( matcher . group (  2  )  )  ;", "}", "}", "rect . name    =    name ;", "rect . index    =    index ;", "return   rect ;", "}", "METHOD_END"], "methodName": ["processImage"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "this . resampling    =    resampling ;", "}", "METHOD_END"], "methodName": ["setResampling"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "this . scale    =    scale ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" Invalid    \"     +    name )     +     \"    ninepatch   split   pixel   at    \"  )     +    x )     +     \"  ,     \"  )     +    y )     +     \"  ,    rgba :     \"  )     +     ( rgba [  0  ]  )  )     +     \"  ,     \"  )     +     ( rgba [  1  ]  )  )     +     \"  ,     \"  )     +     ( rgba [  2  ]  )  )     +     \"  ,     \"  )     +     ( rgba [  3  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["splitError"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "WritableRaster   alphaRaster    =    source . getAlphaRaster (  )  ;", "if    (  ( alphaRaster    =  =    null )     |  |     (  (  !  ( settings . stripWhitespaceX )  )     &  &     (  !  ( settings . stripWhitespaceY )  )  )  )", "return   new   TexturePacker . Rect ( source ,     0  ,     0  ,    source . getWidth (  )  ,    source . getHeight (  )  ,    false )  ;", "final   byte [  ]    a    =    new   byte [  1  ]  ;", "int   top    =     0  ;", "int   bottom    =    source . getHeight (  )  ;", "if    ( settings . stripWhitespaceY )     {", "outer    :    for    ( int   y    =     0  ;    y    <     ( source . getHeight (  )  )  ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <     ( source . getWidth (  )  )  ;    x +  +  )     {", "alphaRaster . getDataElements ( x ,    y ,    a )  ;", "int   alpha    =    a [  0  ]  ;", "if    ( alpha    <     0  )", "alpha    +  =     2  5  6  ;", "if    ( alpha    >     ( settings . alphaThreshold )  )", "break   outer ;", "}", "top +  +  ;", "}", "outer    :    for    ( int   y    =    source . getHeight (  )  ;     (  -  - y )     >  =    top ;  )     {", "for    ( int   x    =     0  ;    x    <     ( source . getWidth (  )  )  ;    x +  +  )     {", "alphaRaster . getDataElements ( x ,    y ,    a )  ;", "int   alpha    =    a [  0  ]  ;", "if    ( alpha    <     0  )", "alpha    +  =     2  5  6  ;", "if    ( alpha    >     ( settings . alphaThreshold )  )", "break   outer ;", "}", "bottom -  -  ;", "}", "if    ( settings . duplicatePadding )     {", "if    ( top    >     0  )", "top -  -  ;", "if    ( bottom    <     ( source . getHeight (  )  )  )", "bottom +  +  ;", "}", "}", "int   left    =     0  ;", "int   right    =    source . getWidth (  )  ;", "if    ( settings . stripWhitespaceX )     {", "outer    :    for    ( int   x    =     0  ;    x    <     ( source . getWidth (  )  )  ;    x +  +  )     {", "for    ( int   y    =    top ;    y    <    bottom ;    y +  +  )     {", "alphaRaster . getDataElements ( x ,    y ,    a )  ;", "int   alpha    =    a [  0  ]  ;", "if    ( alpha    <     0  )", "alpha    +  =     2  5  6  ;", "if    ( alpha    >     ( settings . alphaThreshold )  )", "break   outer ;", "}", "left +  +  ;", "}", "outer    :    for    ( int   x    =    source . getWidth (  )  ;     (  -  - x )     >  =    left ;  )     {", "for    ( int   y    =    top ;    y    <    bottom ;    y +  +  )     {", "alphaRaster . getDataElements ( x ,    y ,    a )  ;", "int   alpha    =    a [  0  ]  ;", "if    ( alpha    <     0  )", "alpha    +  =     2  5  6  ;", "if    ( alpha    >     ( settings . alphaThreshold )  )", "break   outer ;", "}", "right -  -  ;", "}", "if    ( settings . duplicatePadding )     {", "if    ( left    >     0  )", "left -  -  ;", "if    ( right    <     ( source . getWidth (  )  )  )", "right +  +  ;", "}", "}", "int   newWidth    =    right    -    left ;", "int   newHeight    =    bottom    -    top ;", "if    (  ( newWidth    <  =     0  )     |  |     ( newHeight    <  =     0  )  )     {", "if    ( settings . ignoreBlankImages )", "return   null ;", "else", "return   new   TexturePacker . Rect (  . emptyImage ,     0  ,     0  ,     1  ,     1  ,    false )  ;", "}", "return   new   TexturePacker . Rect ( source ,    left ,    top ,    newWidth ,    newHeight ,    false )  ;", "}", "METHOD_END"], "methodName": ["stripWhitespace"], "fileName": "com.badlogic.gdx.tools.texturepacker.ImageProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( result 1     =  =    null )", "ren   result 2  ;", "if    ( result 2     =  =    null )", "ren   result 1  ;", "ren    ( result 1  . occupancy )     >     ( result 2  . occupancy )     ?    result 1     :    result 2  ;", "}", "METHOD_END"], "methodName": ["getBest"], "fileName": "com.badlogic.gdx.tools.texturepacker.MaxRectsPacker"}, {"methodBody": ["METHOD_START", "{", "int   n    =    inputRects . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "TPacker . Rect   rect    =    inputRects . get ( i )  ;", "rect . width    +  =    settings . paddingX ;", "rect . height    +  =    settings . paddingY ;", "}", "if    ( settings . fast )     {", "if    ( settings . rotation )     {", "sort . sort ( inputRects ,    new   Comparator < TPacker . Rect >  (  )     {", "public   int   compare ( TPacker . Rect   o 1  ,    TPacker . Rect   o 2  )     {", "int   n 1     =     (  ( o 1  . width )     >     ( o 1  . height )  )     ?    o 1  . width    :    o 1  . height ;", "int   n 2     =     (  ( o 2  . width )     >     ( o 2  . height )  )     ?    o 2  . width    :    o 2  . height ;", "return   n 2     -    n 1  ;", "}", "}  )  ;", "} else    {", "sort . sort ( inputRects ,    new   Comparator < TPacker . Rect >  (  )     {", "public   int   compare ( TPacker . Rect   o 1  ,    TPacker . Rect   o 2  )     {", "return    ( o 2  . width )     -     ( o 1  . width )  ;", "}", "}  )  ;", "}", "}", "Array < TPacker . Page >    pages    =    new   Array (  )  ;", "while    (  ( inputRects . size )     >     0  )     {", "if    (  ( progress    !  =    null )     &  &     ( progress . update (  (  ( n    -     ( inputRects . size )  )     +     1  )  ,    n )  )  )", "break ;", "TPacker . Page   result    =    packPage ( progress ,    inputRects )  ;", "pages . add ( result )  ;", "inputRects    =    result . remainingRects ;", "}", "return   pages ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.tools.texturepacker.MaxRectsPacker"}, {"methodBody": ["METHOD_START", "{", "return   pack ( null ,    inputRects )  ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.tools.texturepacker.MaxRectsPacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . Page   bestResult    =    null ;", "for    ( int   i    =     0  ,    n    =    methods . length ;    i    <    n ;    i +  +  )     {", "m . init ( width ,    height )  ;", "TexturePacker . Page   result ;", "if    (  !  ( settings . fast )  )     {", "result    =    m . pack ( inputRects ,    methods [ i ]  )  ;", "} else    {", "Array < TexturePacker . Rect >    remaining    =    new   Array (  )  ;", "for    ( int   ii    =     0  ,    nn    =    inputRects . size ;    ii    <    nn ;    ii +  +  )     {", "TexturePacker . Rect   rect    =    inputRects . get ( ii )  ;", "if    (  ( m . insert ( rect ,    methods [ i ]  )  )     =  =    null )     {", "while    ( ii    <    nn )", "remaining . add ( inputRects . get (  ( ii +  +  )  )  )  ;", "}", "}", "result    =    m . getResult (  )  ;", "result . remainingRects    =    remaining ;", "}", "if    ( fully    &  &     (  ( result . remainingRects . size )     >     0  )  )", "continue ;", "if    (  ( result . outputRects . size )     =  =     0  )", "continue ;", "bestResult    =    getBest ( bestResult ,    result )  ;", "}", "return   bestResult ;", "}", "METHOD_END"], "methodName": ["packAtSize"], "fileName": "com.badlogic.gdx.tools.texturepacker.MaxRectsPacker"}, {"methodBody": ["METHOD_START", "{", "int   paddingX    =    settings . paddingX ;", "int   paddingY    =    settings . paddingY ;", "float   maxWidth    =    settings . maxWidth ;", "float   maxHeight    =    settings . maxHeight ;", "int   edgePaddingX    =     0  ;", "int   edgePaddingY    =     0  ;", "if    ( settings . edgePadding )     {", "if    ( settings . duplicatePadding )     {", "maxWidth    -  =    paddingX ;", "maxHeight    -  =    paddingY ;", "} else    {", "maxWidth    -  =    paddingX    *     2  ;", "maxHeight    -  =    paddingY    *     2  ;", "edgePaddingX    =    paddingX ;", "edgePaddingY    =    paddingY ;", "}", "}", "int   minWidth    =    Integer . MAX _ VALUE ;", "int   minHeight    =    Integer . MAX _ VALUE ;", "for    ( int   i    =     0  ,    nn    =    inputRects . size ;    i    <    nn ;    i +  +  )     {", "TexturePacker . Rect   rect    =    inputRects . get ( i )  ;", "minWidth    =    Math . min ( minWidth ,    rect . width )  ;", "minHeight    =    Math . min ( minHeight ,    rect . height )  ;", "float   width    =     ( rect . width )     -    paddingX ;", "float   height    =     ( rect . height )     -    paddingY ;", "if    ( settings . rotation )     {", "if    (  (  ( width    >    maxWidth )     |  |     ( height    >    maxHeight )  )     &  &     (  ( width    >    maxHeight )     |  |     ( height    >    maxWidth )  )  )     {", "String   paddingMessage    =     (  ( edgePaddingX    >     0  )     |  |     ( edgePaddingY    >     0  )  )     ?     (  (  \"    and   edge   padding    \"     +    paddingX )     +     \"  ,  \"  )     +    paddingY    :     \"  \"  ;", "throw   new   RuntimeException (  (  (  (  (  (  (  (  (  (  (  (  \" Image   does   not   fit   with   max   page   size    \"     +     ( settings . maxWidth )  )     +     \" x \"  )     +     ( settings . maxHeight )  )     +    paddingMessage )     +     \"  :     \"  )     +     ( rect . name )  )     +     \"  [  \"  )     +    width )     +     \"  ,  \"  )     +    height )     +     \"  ]  \"  )  )  ;", "}", "} else    {", "if    ( width    >    maxWidth )     {", "String   paddingMessage    =     ( edgePaddingX    >     0  )     ?     \"    and   X   edge   padding    \"     +    paddingX    :     \"  \"  ;", "throw   new   RuntimeException (  (  (  (  (  (  (  (  (  (  \" Image   does   not   fit   with   max   page   width    \"     +     ( settings . maxWidth )  )     +    paddingMessage )     +     \"  :     \"  )     +     ( rect . name )  )     +     \"  [  \"  )     +    width )     +     \"  ,  \"  )     +    height )     +     \"  ]  \"  )  )  ;", "}", "if    (  ( height    >    maxHeight )     &  &     (  (  !  ( settings . rotation )  )     |  |     ( width    >    maxHeight )  )  )     {", "String   paddingMessage    =     ( edgePaddingY    >     0  )     ?     \"    and   Y   edge   padding    \"     +    paddingY    :     \"  \"  ;", "throw   new   RuntimeException (  (  (  (  (  (  (  (  (  (  \" Image   does   not   fit   in   max   page   height    \"     +     ( settings . maxHeight )  )     +    paddingMessage )     +     \"  :     \"  )     +     ( rect . name )  )     +     \"  [  \"  )     +    width )     +     \"  ,  \"  )     +    height )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "minWidth    =    Math . max ( minWidth ,    settings . minWidth )  ;", "minHeight    =    Math . max ( minHeight ,    settings . minHeight )  ;", "if    (  !  ( settings . silent )  )", "System . out . print (  \" Packing \"  )  ;", "TexturePacker . Page   bestResult    =    null ;", "if    ( settings . square )     {", "int   minSize    =    Math . max ( minWidth ,    minHeight )  ;", "int   maxSize    =    Math . min ( settings . maxWidth ,    settings . maxHeight )  ;", ". BinarySearch   sizeSearch    =    new    . BinarySearch ( minSize ,    maxSize ,     ( settings . fast    ?     2  5     :     1  5  )  ,    settings . pot )  ;", "int   size    =    sizeSearch . reset (  )  ;", "int   i    =     0  ;", "while    ( size    !  =     (  -  1  )  )     {", "TexturePacker . Page   result    =    packAtSize ( true ,     ( size    -    edgePaddingX )  ,     ( size    -    edgePaddingY )  ,    inputRects )  ;", "if    (  !  ( settings . silent )  )     {", "if    (  (  (  +  + i )     %     7  0  )     =  =     0  )", "System . out . println (  )  ;", "System . out . print (  \"  .  \"  )  ;", "}", "bestResult    =    getBest ( bestResult ,    result )  ;", "size    =    sizeSearch . next (  ( result    =  =    null )  )  ;", "}", "if    (  !  ( settings . silent )  )", "System . out . println (  )  ;", "if    ( bestResult    =  =    null )", "bestResult    =    packAtSize ( false ,     ( maxSize    -    edgePaddingX )  ,     ( maxSize    -    edgePaddingY )  ,    inputRects )  ;", "sort . sort ( bestResult . outputRects ,    rectComparator )  ;", "bestResult . width    =    Math . max ( bestResult . width ,    bestResult . height )  ;", "bestResult . height    =    Math . max ( bestResult . width ,    bestResult . height )  ;", "return   bestResult ;", "} else    {", ". BinarySearch   widthSearch    =    new    . BinarySearch ( minWidth ,    settings . maxWidth ,     ( settings . fast    ?     2  5     :     1  5  )  ,    settings . pot )  ;", ". BinarySearch   heightSearch    =    new    . BinarySearch ( minHeight ,    settings . maxHeight ,     ( settings . fast    ?     2  5     :     1  5  )  ,    settings . pot )  ;", "int   width    =    widthSearch . reset (  )  ;", "int   i    =     0  ;", "int   height    =     ( settings . square )     ?    width    :    heightSearch . reset (  )  ;", "while    ( true )     {", "TexturePacker . Page   bestWidthResult    =    null ;", "while    ( width    !  =     (  -  1  )  )     {", "TexturePacker . Page   result    =    packAtSize ( true ,     ( width    -    edgePaddingX )  ,     ( height    -    edgePaddingY )  ,    inputRects )  ;", "if    (  !  ( settings . silent )  )     {", "if    (  (  (  +  + i )     %     7  0  )     =  =     0  )", "System . out . println (  )  ;", "System . out . print (  \"  .  \"  )  ;", "}", "bestWidthResult    =    getBest ( bestWidthResult ,    result )  ;", "width    =    widthSearch . next (  ( result    =  =    null )  )  ;", "if    ( settings . square )", "height    =    width ;", "}", "bestResult    =    getBest ( bestResult ,    bestWidthResult )  ;", "if    ( settings . square )", "break ;", "height    =    heightSearch . next (  ( bestWidthResult    =  =    null )  )  ;", "if    ( height    =  =     (  -  1  )  )", "break ;", "width    =    widthSearch . reset (  )  ;", "}", "if    (  !  ( settings . silent )  )", "System . out . println (  )  ;", "if    ( bestResult    =  =    null )", "bestResult    =    packAtSize ( false ,     (  ( settings . maxWidth )     -    edgePaddingX )  ,     (  ( settings . maxHeight )     -    edgePaddingY )  ,    inputRects )  ;", "sort . sort ( bestResult . outputRects ,    rectComparator )  ;", "return   bestResult ;", "}", "}", "METHOD_END"], "methodName": ["packPage"], "fileName": "com.badlogic.gdx.tools.texturepacker.MaxRectsPacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . InputImage   inputImage    =    new   TexturePacker . InputImage (  )  ;", "inputImage . image    =    image ;", "inputImage . name    =    name ;", "inputImages . add ( inputImage )  ;", "}", "METHOD_END"], "methodName": ["addImage"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . InputImage   inputImage    =    new   TexturePacker . InputImage (  )  ;", "inputImage . file    =    file ;", "inputImages . add ( inputImage )  ;", "}", "METHOD_END"], "methodName": ["addImage"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "if    ( rotated )     {", "for    ( int   i    =     0  ;    i    <    w ;    i +  +  )", "for    ( int   j    =     0  ;    j    <    h ;    j +  +  )", ". plot ( dst ,     ( dx    +    j )  ,     (  (  ( dy    +    w )     -    i )     -     1  )  ,    src . getRGB (  ( x    +    i )  ,     ( y    +    j )  )  )  ;", "} else    {", "for    ( int   i    =     0  ;    i    <    w ;    i +  +  )", "for    ( int   j    =     0  ;    j    <    h ;    j +  +  )", ". plot ( dst ,     ( dx    +    i )  ,     ( dy    +    j )  ,    src . getRGB (  ( x    +    i )  ,     ( y    +    j )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "switch    ( settings . format )     {", "case   RGBA 8  8  8  8     :", "case   RGBA 4  4  4  4     :", "ren   BufferedImage . TYPE _ INT _ ARGB ;", "case   RGB 5  6  5     :", "case   RGB 8  8  8     :", "ren   BufferedImage . TYPE _ INT _ RGB ;", "case   Alpha    :", "ren   BufferedImage . TYPE _ BYTE _ GRAY ;", "default    :", "throw   new   RuntimeException (  (  \" Unsupported   format :     \"     +     ( settings . format )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getBufferedImageType"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( settings . wrapX )     =  =     ( TextureWrap . Repeat )  )     &  &     (  ( settings . wrapY )     =  =     ( TextureWrap . Repeat )  )  )", "return    \" xy \"  ;", "if    (  (  ( settings . wrapX )     =  =     ( TextureWrap . Repeat )  )     &  &     (  ( settings . wrapY )     =  =     ( TextureWrap . ClampToEdge )  )  )", "return    \" x \"  ;", "if    (  (  ( settings . wrapX )     =  =     ( TextureWrap . ClampToEdge )  )     &  &     (  ( settings . wrapY )     =  =     ( TextureWrap . Repeat )  )  )", "return    \" y \"  ;", "return    \" none \"  ;", "}", "METHOD_END"], "methodName": ["getRepeatValue"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . lastModified (  )  )     >    lastModified )", "return   true ;", "File [  ]    children    =    file . listFiles (  )  ;", "if    ( children    !  =    null )     {", "for    ( File   child    :    children )", "if    (  . isModified ( child ,    lastModified )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isModified"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "String   packFullFileName    =    output ;", "if    (  !  ( packFullFileName . endsWith (  \"  /  \"  )  )  )     {", "packFullFileName    +  =     \"  /  \"  ;", "}", "packFullFileName    +  =    packFileName ;", "packFullFileName    +  =    settings . atlasExtension ;", "File   outputFile    =    new   File ( packFullFileName )  ;", "if    (  !  ( outputFile . exists (  )  )  )     {", "return   true ;", "}", "File   inputFile    =    new   File ( input )  ;", "if    (  !  ( inputFile . exists (  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Input   file   does   not   exist :     \"     +     ( inputFile . getAbsolutePath (  )  )  )  )  ;", "}", "return    . isModified ( inputFile ,    outputFile . lastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["isModified"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . Settings   settings    =    null ;", "String   input    =    null ;", "String   output    =    null ;", "String   packFileName    =     \" pack . atlas \"  ;", "switch    ( args . length )     {", "case    4     :", "settings    =    new   Json (  )  . fromJson ( TexturePacker . Settings . class ,    new   FileReader ( args [  3  ]  )  )  ;", "case    3     :", "packFileName    =    args [  2  ]  ;", "case    2     :", "output    =    args [  1  ]  ;", "case    1     :", "input    =    args [  0  ]  ;", "break ;", "default    :", "System . out . println (  \" Usage :    inputDir    [ outputDir ]     [ packFileName ]     [ settingsFileName ]  \"  )  ;", "System . exit (  0  )  ;", "}", "if    ( output    =  =    null )     {", "File   inputFile    =    new   File ( input )  ;", "output    =    new   File ( inputFile . getParentFile (  )  ,     (  ( inputFile . getName (  )  )     +     \"  - packed \"  )  )  . getAbsolutePath (  )  ;", "}", "if    ( settings    =  =    null )", "settings    =    new   TexturePacker . Settings (  )  ;", "TexturePacker . process ( settings ,    input ,    output ,    packFileName )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "if    ( packFileName . endsWith ( settings . atlasExtension )  )", "packFileName    =    packFileName . substring (  0  ,     (  ( packFileName . length (  )  )     -     ( settings . atlasExtension . length (  )  )  )  )  ;", "outputDir . mkdirs (  )  ;", "if    (  ( progress )     =  =    null )     {", "progress    =    new    . ProgressListener (  )     {", "public   void   progress ( float   progress )     {", "}", "}  ;", "}", "progress . reset (  )  ;", "progress . start (  1  )  ;", "int   n    =    settings . scale . length ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "progress . start (  (  1  .  0 F    /    n )  )  ;", "progress . start (  0  .  3  5 F )  ;", "imageProcessor . setScale ( settings . scale [ i ]  )  ;", "if    (  (  (  ( settings . scaleResampling )     !  =    null )     &  &     (  ( settings . scaleResampling . length )     >    i )  )     &  &     (  ( settings . scaleResampling [ i ]  )     !  =    null )  )", "imageProcessor . setResampling ( settings . scaleResampling [ i ]  )  ;", "for    ( int   ii    =     0  ,    nn    =    inputImages . size ;    ii    <    nn ;    ii +  +  )     {", ". InputImage   inputImage    =    inputImages . get ( ii )  ;", "if    (  ( inputImage . file )     !  =    null )", "imageProcessor . addImage ( inputImage . file )  ;", "else", "imageProcessor . addImage ( inputImage . image ,    inputImage . name )  ;", "if    ( progress . update (  ( ii    +     1  )  ,    nn )  )", "return ;", "}", "progress . end (  )  ;", "progress . start (  0  .  1  9 F )  ;", "Array <  . Page >    pages    =    packer . pack ( progress ,    imageProcessor . getImages (  )  )  ;", "progress . end (  )  ;", "progress . start (  0  .  4  5 F )  ;", "String   scaledPackFileName    =    settings . getScaledPackFileName ( packFileName ,    i )  ;", "writeImages ( outputDir ,    scaledPackFileName ,    pages )  ;", "progress . end (  )  ;", "progress . start (  0  .  0  1 F )  ;", "try    {", "writePackFile ( outputDir ,    scaledPackFileName ,    pages )  ;", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  \" Error   writing   pack   file .  \"  ,    ex )  ;", "}", "imageProcessor . clear (  )  ;", "progress . end (  )  ;", "progress . end (  )  ;", "if    ( progress . update (  ( i    +     1  )  ,    n )  )", "return ;", "}", "progress . end (  )  ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  0     <  =    x )     &  &     ( x    <     ( dst . getWidth (  )  )  )  )     &  &     (  0     <  =    y )  )     &  &     ( y    <     ( dst . getHeight (  )  )  )  )", "dst . setRGB ( x ,    y ,    argb )  ;", "}", "METHOD_END"], "methodName": ["plot"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . process ( settings ,    input ,    output ,    packFileName ,    null )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "try    {", "FileProcessor   processor    =    new   FileProcessor ( settings ,    packFileName )     {", "protected      new ( File   root ,     . Settings   settings )     {", "packer    =    super . new ( root ,    settings )  ;", "packer . setProgressListener ( progress )  ;", "return   packer ;", "}", "}  ;", "processor . setComparator ( new   Comparator < File >  (  )     {", "public   int   compare ( File   file 1  ,    File   file 2  )     {", "return   file 1  . getName (  )  . compareTo ( file 2  . getName (  )  )  ;", "}", "}  )  ;", "processor . process ( new   File ( input )  ,    new   File ( output )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException (  \" Error   packing   images .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . process ( new   TexturePacker . Settings (  )  ,    input ,    output ,    packFileName )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "if    ( TexturePacker . isModified ( input ,    output ,    packFileName ,    settings )  )     {", "TexturePacker . process ( settings ,    input ,    output ,    packFileName )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["processIfModified"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . Settings   settings    =    new   TexturePacker . Settings (  )  ;", "if    ( TexturePacker . isModified ( input ,    output ,    packFileName ,    settings )  )     {", "TexturePacker . process ( settings ,    input ,    output ,    packFileName )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["processIfModified"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "this . progress    =    progressListener ;", "}", "METHOD_END"], "methodName": ["setProgressListener"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "File   packFileNoExt    =    new   File ( outputDir ,    scaledPackFileName )  ;", "File   packDir    =    packFileNoExt . getParentFile (  )  ;", "String   imageName    =    packFileNoExt . getName (  )  ;", "int   fileIndex    =     0  ;", "for    ( int   p    =     0  ,    pn    =    pages . size ;    p    <    pn ;    p +  +  )     {", ". Page   page    =    pages . get ( p )  ;", "int   width    =    page . width ;", "int   height    =    page . height ;", "int   paddingX    =    settings . paddingX ;", "int   paddingY    =    settings . paddingY ;", "if    ( settings . duplicatePadding )     {", "paddingX    /  =     2  ;", "paddingY    /  =     2  ;", "}", "width    -  =    settings . paddingX ;", "height    -  =    settings . paddingY ;", "if    ( settings . edgePadding )     {", "page . x    =    paddingX ;", "page . y    =    paddingY ;", "width    +  =    paddingX    *     2  ;", "height    +  =    paddingY    *     2  ;", "}", "if    ( settings . pot )     {", "width    =    MathUtils . nextPowerOfTwo ( width )  ;", "height    =    MathUtils . nextPowerOfTwo ( height )  ;", "}", "width    =    Math . max ( settings . minWidth ,    width )  ;", "height    =    Math . max ( settings . minHeight ,    height )  ;", "page . imageWidth    =    width ;", "page . imageHeight    =    height ;", "File   outputFile ;", "while    ( true )     {", "outputFile    =    new   File ( packDir ,     (  (  ( imageName    +     (  ( fileIndex +  +  )     =  =     0     ?     \"  \"     :    fileIndex )  )     +     \"  .  \"  )     +     ( settings . outputFormat )  )  )  ;", "if    (  !  ( outputFile . exists (  )  )  )", "break ;", "}", "new   FileHandle ( outputFile )  . parent (  )  . mkdirs (  )  ;", "page . imageName    =    outputFile . getName (  )  ;", "BufferedImage   canvas    =    new   BufferedImage ( width ,    height ,    getBufferedImageType ( settings . format )  )  ;", "Graphics 2 D   g    =     (  ( Graphics 2 D )     ( canvas . getGraphics (  )  )  )  ;", "if    (  !  ( settings . silent )  )", "System . out . println (  (  (  (  (  (  \" Writing    \"     +     ( canvas . getWidth (  )  )  )     +     \" x \"  )     +     ( canvas . getHeight (  )  )  )     +     \"  :     \"  )     +    outputFile )  )  ;", "progress . start (  (  1     /     (  ( float )     ( pn )  )  )  )  ;", "for    ( int   r    =     0  ,    rn    =    page . outputRects . size ;    r    <    rn ;    r +  +  )     {", ". Rect   rect    =    page . outputRects . get ( r )  ;", "BufferedImage   image    =    rect . getImage ( imageProcessor )  ;", "int   iw    =    image . getWidth (  )  ;", "int   ih    =    image . getHeight (  )  ;", "int   rectX    =     ( page . x )     +     ( rect . x )  ;", "int   rectY    =     (  (  ( page . y )     +     ( page . height )  )     -     ( rect . y )  )     -     ( rect . height )  ;", "if    ( settings . duplicatePadding )     {", "int   amountX    =     ( settings . paddingX )     /     2  ;", "int   amountY    =     ( settings . paddingY )     /     2  ;", "if    ( rect . rotated )     {", "for    ( int   i    =     1  ;    i    <  =    amountX ;    i +  +  )     {", "for    ( int   j    =     1  ;    j    <  =    amountY ;    j +  +  )     {", ". plot ( canvas ,     ( rectX    -    j )  ,     (  (  ( rectY    +    iw )     -     1  )     +    i )  ,    image . getRGB (  0  ,     0  )  )  ;", ". plot ( canvas ,     (  (  ( rectX    +    ih )     -     1  )     +    j )  ,     (  (  ( rectY    +    iw )     -     1  )     +    i )  ,    image . getRGB (  0  ,     ( ih    -     1  )  )  )  ;", ". plot ( canvas ,     ( rectX    -    j )  ,     ( rectY    -    i )  ,    image . getRGB (  ( iw    -     1  )  ,     0  )  )  ;", ". plot ( canvas ,     (  (  ( rectX    +    ih )     -     1  )     +    j )  ,     ( rectY    -    i )  ,    image . getRGB (  ( iw    -     1  )  ,     ( ih    -     1  )  )  )  ;", "}", "}", "for    ( int   i    =     1  ;    i    <  =    amountY ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    iw ;    j +  +  )     {", ". plot ( canvas ,     ( rectX    -    i )  ,     (  (  ( rectY    +    iw )     -     1  )     -    j )  ,    image . getRGB ( j ,     0  )  )  ;", ". plot ( canvas ,     (  (  ( rectX    +    ih )     -     1  )     +    i )  ,     (  (  ( rectY    +    iw )     -     1  )     -    j )  ,    image . getRGB ( j ,     ( ih    -     1  )  )  )  ;", "}", "}", "for    ( int   i    =     1  ;    i    <  =    amountX ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    ih ;    j +  +  )     {", ". plot ( canvas ,     ( rectX    +    j )  ,     ( rectY    -    i )  ,    image . getRGB (  ( iw    -     1  )  ,    j )  )  ;", ". plot ( canvas ,     ( rectX    +    j )  ,     (  (  ( rectY    +    iw )     -     1  )     +    i )  ,    image . getRGB (  0  ,    j )  )  ;", "}", "}", "} else    {", "for    ( int   i    =     1  ;    i    <  =    amountX ;    i +  +  )     {", "for    ( int   j    =     1  ;    j    <  =    amountY ;    j +  +  )     {", ". plot ( canvas ,     ( rectX    -    i )  ,     ( rectY    -    j )  ,    image . getRGB (  0  ,     0  )  )  ;", ". plot ( canvas ,     ( rectX    -    i )  ,     (  (  ( rectY    +    ih )     -     1  )     +    j )  ,    image . getRGB (  0  ,     ( ih    -     1  )  )  )  ;", ". plot ( canvas ,     (  (  ( rectX    +    iw )     -     1  )     +    i )  ,     ( rectY    -    j )  ,    image . getRGB (  ( iw    -     1  )  ,     0  )  )  ;", ". plot ( canvas ,     (  (  ( rectX    +    iw )     -     1  )     +    i )  ,     (  (  ( rectY    +    ih )     -     1  )     +    j )  ,    image . getRGB (  ( iw    -     1  )  ,     ( ih    -     1  )  )  )  ;", "}", "}", "for    ( int   i    =     1  ;    i    <  =    amountY ;    i +  +  )     {", ". copy ( image ,     0  ,     0  ,    iw ,     1  ,    canvas ,    rectX ,     ( rectY    -    i )  ,    rect . rotated )  ;", ". copy ( image ,     0  ,     ( ih    -     1  )  ,    iw ,     1  ,    canvas ,    rectX ,     (  (  ( rectY    +    ih )     -     1  )     +    i )  ,    rect . rotated )  ;", "}", "for    ( int   i    =     1  ;    i    <  =    amountX ;    i +  +  )     {", ". copy ( image ,     0  ,     0  ,     1  ,    ih ,    canvas ,     ( rectX    -    i )  ,    rectY ,    rect . rotated )  ;", ". copy ( image ,     ( iw    -     1  )  ,     0  ,     1  ,    ih ,    canvas ,     (  (  ( rectX    +    iw )     -     1  )     +    i )  ,    rectY ,    rect . rotated )  ;", "}", "}", "}", ". copy ( image ,     0  ,     0  ,    iw ,    ih ,    canvas ,    rectX ,    rectY ,    rect . rotated )  ;", "if    ( settings . debug )     {", "g . setColor ( Color . magenta )  ;", "g . drawRect ( rectX ,    rectY ,     (  (  ( rect . width )     -     ( settings . paddingX )  )     -     1  )  ,     (  (  ( rect . height )     -     ( settings . paddingY )  )     -     1  )  )  ;", "}", "if    ( progress . update (  ( r    +     1  )  ,    rn )  )", "return ;", "}", "progress . end (  )  ;", "if    (  (  ( settings . bleed )     &  &     (  !  ( settings . premultiplyAlpha )  )  )     &  &     (  !  (  ( settings . outputFormat . equalsIgnoreCase (  \" jpg \"  )  )     |  |     ( settings . outputFormat . equalsIgnoreCase (  \" jpeg \"  )  )  )  )  )     {", "canvas    =    new   ColorBleedEffect (  )  . processImage ( canvas ,    settings . bleedIterations )  ;", "g    =     (  ( Graphics 2 D )     ( canvas . getGraphics (  )  )  )  ;", "}", "if    ( settings . debug )     {", "g . setColor ( Color . magenta )  ;", "g . drawRect (  0  ,     0  ,     ( width    -     1  )  ,     ( height    -     1  )  )  ;", "}", "ImageOutputStream   ios    =    null ;", "try    {", "if    (  ( settings . outputFormat . equalsIgnoreCase (  \" jpg \"  )  )     |  |     ( settings . outputFormat . equalsIgnoreCase (  \" jpeg \"  )  )  )     {", "BufferedImage   newImage    =    new   BufferedImage ( canvas . getWidth (  )  ,    canvas . getHeight (  )  ,    BufferedImage . TYPE _  3 BYTE _ BGR )  ;", "newImage . getGraphics (  )  . drawImage ( canvas ,     0  ,     0  ,    null )  ;", "canvas    =    newImage ;", "Iterator < ImageWriter >    writers    =    ImageIO . getImageWritersByFormatName (  \" jpg \"  )  ;", "ImageWriter   writer    =    writers . next (  )  ;", "ImageWriteParam   param    =    writer . getDefaultWriteParam (  )  ;", "param . setCompressionMode ( ImageWriteParam . MODE _ EXPLICIT )  ;", "param . setCompressionQuality ( settings . jpegQuality )  ;", "ios    =    ImageIO . createImageOutputStream ( outputFile )  ;", "writer . setOutput ( ios )  ;", "writer . write ( null ,    new   IIOImage ( canvas ,    null ,    null )  ,    param )  ;", "} else    {", "if    ( settings . premultiplyAlpha )", "canvas . getColorModel (  )  . coerceData ( canvas . getRaster (  )  ,    true )  ;", "ImageIO . write ( canvas ,     \" png \"  ,    outputFile )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   RuntimeException (  (  \" Error   writing   file :     \"     +    outputFile )  ,    ex )  ;", "}    finally    {", "if    ( ios    !  =    null )     {", "try    {", "ios . close (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "}", "if    ( progress . update (  ( p    +     1  )  ,    pn )  )", "return ;", "}", "}", "METHOD_END"], "methodName": ["writeImages"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "File   packFile    =    new   File ( outputDir ,     ( scaledPackFileName    +     ( settings . atlasExtension )  )  )  ;", "File   packDir    =    packFile . getParentFile (  )  ;", "packDir . mkdirs (  )  ;", "if    ( packFile . exists (  )  )     {", "TextureAtlasData   textureAtlasData    =    new   TextureAtlasData ( new   FileHandle ( packFile )  ,    new   FileHandle ( packFile )  ,    false )  ;", "for    (  . Page   page    :    pages )     {", "for    (  . Rect   rect    :    page . outputRects )     {", "String   rectName    =     . Rect . getAtlasName ( rect . name ,    settings . flattenPaths )  ;", "for    ( Region   region    :    textureAtlasData . getRegions (  )  )     {", "if    ( region . name . equals ( rectName )  )     {", "throw   new   GdxRuntimeException (  (  (  (  \" A   region   with   the   name    \\  \"  \"     +    rectName )     +     \"  \\  \"    has   already   been   packed :     \"  )     +     ( rect . name )  )  )  ;", "}", "}", "}", "}", "}", "Writer   writer    =    new   OutputStreamWriter ( new   FileOutputStream ( packFile ,    true )  ,     \" UTF -  8  \"  )  ;", "for    (  . Page   page    :    pages )     {", "writer . write (  (  (  \"  \\ n \"     +     ( page . imageName )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \" size :     \"     +     ( page . imageWidth )  )     +     \"  ,  \"  )     +     ( page . imageHeight )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  \" format :     \"     +     ( settings . format )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \" filter :     \"     +     ( settings . filterMin )  )     +     \"  ,  \"  )     +     ( settings . filterMag )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  \" repeat :     \"     +     ( getRepeatValue (  )  )  )     +     \"  \\ n \"  )  )  ;", "page . outputRects . sort (  )  ;", "for    (  . Rect   rect    :    page . outputRects )     {", "writeRect ( writer ,    page ,    rect ,    rect . name )  ;", "Array <  . Alias >    aliases    =    new   Array ( rect . aliases . toArray (  )  )  ;", "aliases . sort (  )  ;", "for    (  . Alias   alias    :    aliases )     {", ". Rect   aliasRect    =    new    . Rect (  )  ;", "aliasRect . set ( rect )  ;", "alias . apply ( aliasRect )  ;", "writeRect ( writer ,    page ,    aliasRect ,    alias . name )  ;", "}", "}", "}", "writer . close (  )  ;", "}", "METHOD_END"], "methodName": ["writePackFile"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "writer . write (  (  ( TexturePacker . Rect . getAtlasName ( name ,    settings . flattenPaths )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  \"       rotate :     \"     +     ( rect . rotated )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \"       xy :     \"     +     (  ( page . x )     +     ( rect . x )  )  )     +     \"  ,     \"  )     +     (  (  (  ( page . y )     +     ( page . height )  )     -     ( rect . height )  )     -     ( rect . y )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \"       size :     \"     +     ( rect . regionWidth )  )     +     \"  ,     \"  )     +     ( rect . regionHeight )  )     +     \"  \\ n \"  )  )  ;", "if    (  ( rect . splits )     !  =    null )     {", "writer . write (  (  (  (  (  (  (  (  (  \"       split :     \"     +     ( rect . splits [  0  ]  )  )     +     \"  ,     \"  )     +     ( rect . splits [  1  ]  )  )     +     \"  ,     \"  )     +     ( rect . splits [  2  ]  )  )     +     \"  ,     \"  )     +     ( rect . splits [  3  ]  )  )     +     \"  \\ n \"  )  )  ;", "}", "if    (  ( rect . pads )     !  =    null )     {", "if    (  ( rect . splits )     =  =    null )", "writer . write (  \"       split :     0  ,     0  ,     0  ,     0  \\ n \"  )  ;", "writer . write (  (  (  (  (  (  (  (  (  \"       pad :     \"     +     ( rect . pads [  0  ]  )  )     +     \"  ,     \"  )     +     ( rect . pads [  1  ]  )  )     +     \"  ,     \"  )     +     ( rect . pads [  2  ]  )  )     +     \"  ,     \"  )     +     ( rect . pads [  3  ]  )  )     +     \"  \\ n \"  )  )  ;", "}", "writer . write (  (  (  (  (  \"       orig :     \"     +     ( rect . originalWidth )  )     +     \"  ,     \"  )     +     ( rect . originalHeight )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \"       offset :     \"     +     ( rect . offsetX )  )     +     \"  ,     \"  )     +     (  (  ( rect . originalHeight )     -     ( rect . regionHeight )  )     -     ( rect . offsetY )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  \"       index :     \"     +     ( rect . index )  )     +     \"  \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writeRect"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePacker"}, {"methodBody": ["METHOD_START", "{", "try    {", "json . readFields ( settings ,    new   JsonReader (  )  . parse ( new   Reader ( settings )  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   settings   file :     \"     +    settings )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerFileProcessor"}, {"methodBody": ["METHOD_START", "{", "return   new   TexturePacker ( root ,    settings )  ;", "}", "METHOD_END"], "methodName": ["newTexturePacker"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerFileProcessor"}, {"methodBody": ["METHOD_START", "{", "root    =    inputFile ;", "final   ArrayList < File >    settingsFiles    =    new   ArrayList (  )  ;", "settingsProcessor    =    new    (  )     {", "protected   void   processFile (  . Entry   inputFile )    throws   Exception    {", "settingsFiles . add ( inputFile . inputFile )  ;", "}", "}  ;", "settingsProcessor . addInputRegex (  \" pack \\  \\  . json \"  )  ;", "settingsProcessor . process ( inputFile ,    null )  ;", "Collections . sort ( settingsFiles ,    new   Comparator < File >  (  )     {", "public   int   compare ( File   file 1  ,    File   file 2  )     {", "return    ( file 1  . toString (  )  . length (  )  )     -     ( file 2  . toString (  )  . length (  )  )  ;", "}", "}  )  ;", "for    ( File   settingsFile    :    settingsFiles )     {", "TexturePacker . Settings   settings    =    null ;", "File   parent    =    settingsFile . getParentFile (  )  ;", "while    ( true )     {", "if    ( parent . equals ( root )  )", "break ;", "parent    =    parent . getParentFile (  )  ;", "settings    =    dirToSettings . get ( parent )  ;", "if    ( settings    !  =    null )     {", "settings    =    new   TexturePacker . Settings ( settings )  ;", "break ;", "}", "}", "if    ( settings    =  =    null )", "settings    =    new   TexturePacker . Settings ( defaultSettings )  ;", "merge ( settings ,    settingsFile )  ;", "dirToSettings . put ( settingsFile . getParentFile (  )  ,    settings )  ;", "}", "return   super . process ( inputFile ,    outputRoot )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerFileProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( outputRoot . exists (  )  )     {", "File   settingsFile    =    new   File ( root ,     \" pack . json \"  )  ;", ". Settings   rootSettings    =    defaultSettings ;", "if    ( settingsFile . exists (  )  )     {", "rootSettings    =    new    . Settings ( rootSettings )  ;", "merge ( rootSettings ,    settingsFile )  ;", "}", "String   atlasExtension    =     (  ( rootSettings . atlasExtension )     =  =    null )     ?     \"  \"     :    rootSettings . atlasExtension ;", "atlasExtension    =    Pattern . quote ( atlasExtension )  ;", "for    ( int   i    =     0  ,    n    =    rootSettings . scale . length ;    i    <    n ;    i +  +  )     {", "FileProcessor   deleteProcessor    =    new   FileProcessor (  )     {", "protected   void   processFile ( FileProcessor . Entry   inputFile )    throws   Exception    {", "inputFile . inputFile . delete (  )  ;", "}", "}  ;", "deleteProcessor . setRecursive ( false )  ;", "File   packFile    =    new   File ( rootSettings . getScaledPackFileName ( packFileName ,    i )  )  ;", "String   scaledPackFileName    =    packFile . getName (  )  ;", "String   prefix    =    packFile . getName (  )  ;", "int   dotIndex    =    prefix . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    !  =     (  -  1  )  )", "prefix    =    prefix . substring (  0  ,    dotIndex )  ;", "deleteProcessor . addInputRegex (  (  (  \"  (  ? i )  \"     +    prefix )     +     \"  \\  \\ d *  \\  \\  .  ( png | jpg | jpeg )  \"  )  )  ;", "deleteProcessor . addInputRegex (  (  (  \"  (  ? i )  \"     +    prefix )     +    atlasExtension )  )  ;", "String   dir    =    packFile . getParent (  )  ;", "if    ( dir    =  =    null )", "deleteProcessor . process ( outputRoot ,    null )  ;", "else", "if    ( new   File (  (  ( outputRoot    +     \"  /  \"  )     +    dir )  )  . exists (  )  )", "deleteProcessor . process (  (  ( outputRoot    +     \"  /  \"  )     +    dir )  ,    null )  ;", "}", "}", "return   super . process ( files ,    outputRoot )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerFileProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( ignoreDirs . contains ( inputDir . inputFile )  )", "return ;", ". Settings   settings    =    null ;", "File   parent    =    inputDir . inputFile ;", "while    ( true )     {", "settings    =    dirToSettings . get ( parent )  ;", "if    ( settings    !  =    null )", "break ;", "if    (  ( parent    =  =    null )     |  |     ( parent . equals ( root )  )  )", "break ;", "parent    =    parent . getParentFile (  )  ;", "}", "if    ( settings    =  =    null )", "settings    =    defaultSettings ;", "if    ( settings . ignore )", "return ;", "if    ( settings . combineSubdirectories )     {", "files    =    new   FileProcessor ( this )     {", "protected   void   processDir ( FileProcessor . Entry   entryDir ,    ArrayList < FileProcessor . Entry >    files )     {", "if    (  (  !  ( entryDir . inputFile . equals ( inputDir . inputFile )  )  )     &  &     ( new   File ( entryDir . inputFile ,     \" pack . json \"  )  . exists (  )  )  )     {", "files . clear (  )  ;", "return ;", "}", "ignoreDirs . add ( entryDir . inputFile )  ;", "}", "protected   void   processFile ( FileProcessor . Entry   entry )     {", "addProcessedFile ( entry )  ;", "}", "}  . process ( inputDir . inputFile ,    null )  ;", "}", "if    ( files . isEmpty (  )  )", "return ;", "Collections . sort ( files ,    new   Comparator < FileProcessor . Entry >  (  )     {", "final   Pattern   digitSuffix    =    Pattern . compile (  \"  (  .  *  ?  )  (  \\  \\ d +  )  $  \"  )  ;", "public   int   compare ( FileProcessor . Entry   entry 1  ,    FileProcessor . Entry   entry 2  )     {", "String   full 1     =    entry 1  . inputFile . getName (  )  ;", "int   dotIndex    =    full 1  . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    !  =     (  -  1  )  )", "full 1     =    full 1  . substring (  0  ,    dotIndex )  ;", "String   full 2     =    entry 2  . inputFile . getName (  )  ;", "dotIndex    =    full 2  . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    !  =     (  -  1  )  )", "full 2     =    full 2  . substring (  0  ,    dotIndex )  ;", "String   name 1     =    full 1  ;", "String   name 2     =    full 2  ;", "int   num 1     =     0  ;", "int   num 2     =     0  ;", "Matcher   matcher    =    digitSuffix . matcher ( full 1  )  ;", "if    ( matcher . matches (  )  )     {", "try    {", "num 1     =    Integer . parseInt ( matcher . group (  2  )  )  ;", "name 1     =    matcher . group (  1  )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "matcher    =    digitSuffix . matcher ( full 2  )  ;", "if    ( matcher . matches (  )  )     {", "try    {", "num 2     =    Integer . parseInt ( matcher . group (  2  )  )  ;", "name 2     =    matcher . group (  1  )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "int   compare    =    name 1  . compareTo ( name 2  )  ;", "if    (  ( compare    !  =     0  )     |  |     ( num 1     =  =    num 2  )  )", "return   compare ;", "return   num 1     -    num 2  ;", "}", "}  )  ;", "if    (  !  ( settings . silent )  )", "System . out . println ( inputDir . inputFile . getName (  )  )  ;", "packer    =    new ( root ,    settings )  ;", "for    ( FileProcessor . Entry   file    :    files )", "packer . addImage ( file . inputFile )  ;", "packer . pack ( inputDir . outputDir ,    packFileName )  ;", "}", "METHOD_END"], "methodName": ["processDir"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerFileProcessor"}, {"methodBody": ["METHOD_START", "{", "renderer    =    new   ShapeRenderer (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerTest"}, {"methodBody": ["METHOD_START", "{", "new   LwjglApplication ( new   TexturePackerTest (  )  ,     \"  \"  ,     6  4  0  ,     4  8  0  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerTest"}, {"methodBody": ["METHOD_START", "{", "gl . glClear ( GL _ COLOR _ BUFFER _ BIT )  ;", ". Settings   settings    =    new    . Settings (  )  ;", "settings . fast    =    false ;", "settings . pot    =    false ;", "settings . maxWidth    =     1  0  2  4  ;", "settings . maxHeight    =     1  0  2  4  ;", "settings . rotation    =    false ;", "settings . paddingX    =     0  ;", "if    (  ( pages )     =  =    null )     {", "Random   random    =    new   Random (  1  2  4  3  )  ;", "Array <  . Rect >    inputRects    =    new   Array (  )  ;", "for    ( int   i    =     0  ;    i    <     2  4  0  ;    i +  +  )     {", ". Rect   rect    =    new    . Rect (  )  ;", "rect . name    =     \" rect \"     +    i ;", "rect . height    =     1  6     +     ( random . nextInt (  1  2  0  )  )  ;", "rect . width    =     1  6     +     ( random . nextInt (  2  4  0  )  )  ;", "inputRects . add ( rect )  ;", "}", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", ". Rect   rect    =    new    . Rect (  )  ;", "rect . name    =     \" rect \"     +     (  4  0     +    i )  ;", "rect . height    =     4  0  0     +     ( random . nextInt (  3  4  0  )  )  ;", "rect . width    =     1     +     ( random . nextInt (  1  0  )  )  ;", "inputRects . add ( rect )  ;", "}", "long   s    =    System . nanoTime (  )  ;", "pages    =    new   MaxRectsPacker ( settings )  . pack ( inputRects )  ;", "long   e    =    System . nanoTime (  )  ;", "System . out . println (  (  \" fast :     \"     +     ( settings . fast )  )  )  ;", "System . out . println (  (  (  ( e    -    s )     /     1  0  0  0  0  0  0  .  0 F )     +     \"    ms \"  )  )  ;", "System . out . println (  )  ;", "}", "int   x    =     2  0  ;", "int   y    =     2  0  ;", "for    (  . Page   page    :    pages )     {", "renderer . setColor ( GRAY )  ;", "renderer . begin ( Filled )  ;", "for    ( int   i    =     0  ;    i    <     ( page . outputRects . size )  ;    i +  +  )     {", ". Rect   rect    =    page . outputRects . get ( i )  ;", "renderer . rect (  (  ( x    +     ( rect . x )  )     +     ( settings . paddingX )  )  ,     (  ( y    +     ( rect . y )  )     +     ( settings . paddingY )  )  ,     (  ( rect . width )     -     ( settings . paddingX )  )  ,     (  ( rect . height )     -     ( settings . paddingY )  )  )  ;", "}", "renderer . end (  )  ;", "renderer . setColor ( RED )  ;", "renderer . begin ( Line )  ;", "for    ( int   i    =     0  ;    i    <     ( page . outputRects . size )  ;    i +  +  )     {", ". Rect   rect    =    page . outputRects . get ( i )  ;", "renderer . rect (  (  ( x    +     ( rect . x )  )     +     ( settings . paddingX )  )  ,     (  ( y    +     ( rect . y )  )     +     ( settings . paddingY )  )  ,     (  ( rect . width )     -     ( settings . paddingX )  )  ,     (  ( rect . height )     -     ( settings . paddingY )  )  )  ;", "}", "renderer . setColor ( GREEN )  ;", "renderer . rect ( x ,    y ,     (  ( page . width )     +     (  ( settings . paddingX )     *     2  )  )  ,     (  ( page . height )     +     (  ( settings . paddingY )     *     2  )  )  )  ;", "renderer . end (  )  ;", "x    +  =     ( page . width )     +     2  0  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerTest"}, {"methodBody": ["METHOD_START", "{", "renderer . setProjectionMatrix ( new   Matrix 4  (  )  . setToOrtho 2 D (  0  ,     0  ,    graphics . getWidth (  )  ,    graphics . getHeight (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerTest"}, {"methodBody": ["METHOD_START", "{", "TexturePacker . Settings   settings    =    new   TexturePacker . Settings (  )  ;", "settings . scale    =    new   float [  ]  {     4     }  ;", "settings . scaleResampling    =    new   TexturePacker . Resampling [  ]  {    TexturePacker . Resampling . nearest    }  ;", "TexturePacker   packer    =    new   TexturePacker ( settings )  ;", "packer . addImage ( new   File (  \" tests / gdx - tests - gwt / war / assets / data / bobrgb 8  8  8  -  3  2 x 3  2  . png \"  )  )  ;", "File   out    =    new   File (  \" tmp / packout \"  )  ;", "if    ( out . exists (  )  )     {", "for    ( File   f    :    out . listFiles (  )  )     {", "f . delete (  )  ;", "}", "} else    {", "out . mkdirs (  )  ;", "}", "packer . pack ( out ,     \" main \"  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.texturepacker.TexturePackerUpscaleTest"}, {"methodBody": ["METHOD_START", "{", "File   checkFile    =    new   File ( directory )  ;", "bean   path    =    true ;", "try    {", "checkFile . getCanonicalPath (  )  ;", "}    catch    ( Exception   e )     {", "path    =    false ;", "}", "return   path ;", "}", "METHOD_END"], "methodName": ["checkDirectoryValidity"], "fileName": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   splitImage    =    null ;", "if    ( region . rotate )     {", "BufferedImage   srcImage    =    page . getSubimage ( region . left ,    regionp ,    region . height ,    region . width )  ;", "splitImage    =    new   BufferedImage ( region . width ,    region . height ,    page . getType (  )  )  ;", "AffineTransform   transform    =    new   AffineTransform (  )  ;", "transform . rotate ( MathRadians (  9  0  .  0  )  )  ;", "transform . translate (  0  ,     (  -  ( region . width )  )  )  ;", "AffineTransformOp   op    =    new   AffineTransformOp ( transform ,    AffineTransformOp . TYPE _ BILINEAR )  ;", "op . filter ( srcImage ,    splitImage )  ;", "} else    {", "splitImage    =    page . getSubimage ( region . left ,    regionp ,    region . width ,    region . height )  ;", "}", "if    ( padding    >     0  )     {", "BufferedImage   paddedImage    =    new   BufferedImage (  (  ( splitImage . getWidth (  )  )     +     ( padding    *     2  )  )  ,     (  ( splitImage . getHeight (  )  )     +     ( padding    *     2  )  )  ,    page . getType (  )  )  ;", "Graphics 2 D   g 2     =    paddedImage . createGraphics (  )  ;", "g 2  . drawImage ( splitImage ,    padding ,    padding ,    null )  ;", "g 2  . dispose (  )  ;", "return   paddedImage ;", "} else    {", "return   splitImage ;", "}", "}", "METHOD_END"], "methodName": ["extractImage"], "fileName": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   splitImage    =    extractImage ( page ,    region ,    outputDirFile ,    TextureUnpacker . NINEPATCH _ PADDING )  ;", "Graphics 2 D   g 2     =    splitImage . createGraphics (  )  ;", "g 2  . setColor ( Color . BLACK )  ;", "int   startX    =     ( region . splits [  0  ]  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  ;", "int   endX    =     (  (  ( region . width )     -     ( region . splits [  1  ]  )  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  )     -     1  ;", "int   startY    =     ( region . splits [  2  ]  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  ;", "int   endY    =     (  (  ( region . height )     -     ( region . splits [  3  ]  )  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  )     -     1  ;", "if    ( endX    >  =    startX )", "g 2  . drawLine ( startX ,     0  ,    endX ,     0  )  ;", "if    ( endY    >  =    startY )", "g 2  . drawLine (  0  ,    startY ,     0  ,    endY )  ;", "if    (  ( region . pads )     !  =    null )     {", "int   padStartX    =     ( region . pads [  0  ]  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  ;", "int   padEndX    =     (  (  ( region . width )     -     ( region . pads [  1  ]  )  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  )     -     1  ;", "int   padStartY    =     ( region . pads [  2  ]  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  ;", "int   padEndY    =     (  (  ( region . height )     -     ( region . pads [  3  ]  )  )     +     ( TextureUnpacker . NINEPATCH _ PADDING )  )     -     1  ;", "g 2  . drawLine ( padStartX ,     (  ( splitImage . getHeight (  )  )     -     1  )  ,    padEndX ,     (  ( splitImage . getHeight (  )  )     -     1  )  )  ;", "g 2  . drawLine (  (  ( splitImage . getWidth (  )  )     -     1  )  ,    padStartY ,     (  ( splitImage . getWidth (  )  )     -     1  )  ,    padEndY )  ;", "}", "g 2  . dispose (  )  ;", "return   splitImage ;", "}", "METHOD_END"], "methodName": ["extractNinePatch"], "fileName": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker"}, {"methodBody": ["METHOD_START", "{", "TextureUnpacker   unpacker    =    new   TextureUnpacker (  )  ;", "String   atlasFile    =    null ;", "String   imageDir    =    null ;", "String   outputDir    =    null ;", "switch    ( unpacker . parseArguments ( args )  )     {", "case    0     :", "System . out . println ( TextureUnpacker . HELP )  ;", "return ;", "case    3     :", "outputDir    =    args [  2  ]  ;", "case    2     :", "imageDir    =    args [  1  ]  ;", "case    1     :", "atlasFile    =    args [  0  ]  ;", "}", "File   atlasFileHandle    =    new   File ( atlasFile )  . getAbsoluteFile (  )  ;", "if    (  !  ( atlasFileHandle . exists (  )  )  )", "throw   new   RuntimeException (  (  \" Atlas   file   not   found :     \"     +     ( atlasFileHandle . getAbsolutePath (  )  )  )  )  ;", "String   atlasParentPath    =    atlasFileHandle . getParentFile (  )  . getAbsolutePath (  )  ;", "if    ( imageDir    =  =    null )", "imageDir    =    atlasParentPath ;", "if    ( outputDir    =  =    null )", "outputDir    =    new   File ( atlasParentPath ,    TextureUnpacker . DEFAULT _ OUTPUT _ PATH )  . getAbsolutePath (  )  ;", "TextureAtlasData   atlas    =    new   TextureAtlasData ( new   FileHandle ( atlasFile )  ,    new   FileHandle ( imageDir )  ,    false )  ;", "unpacker . splitAtlas ( atlas ,    outputDir )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker"}, {"methodBody": ["METHOD_START", "{", "int   numArgs    =    args . length ;", "if    ( numArgs    <     1  )", "return    0  ;", "boolean   extension    =    args [  0  ]  . substring (  (  ( args [  0  ]  . length (  )  )     -     (  . ATLAS _ FILE _ EXTENSION . length (  )  )  )  )  . equals (  . ATLAS _ FILE _ EXTENSION )  ;", "boolean   directory    =    true ;", "if    ( numArgs    >  =     2  )", "directory    &  =    checkDirectoryValidity ( args [  1  ]  )  ;", "if    ( numArgs    =  =     3  )", "directory    &  =    checkDirectoryValidity ( args [  2  ]  )  ;", "return   extension    &  &    directory    ?    numArgs    :     0  ;", "}", "METHOD_END"], "methodName": ["parseArguments"], "fileName": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker"}, {"methodBody": ["METHOD_START", "{", "e . printStackTrace (  )  ;", "System . exit (  1  )  ;", "}", "METHOD_END"], "methodName": ["printExceptionAndExit"], "fileName": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker"}, {"methodBody": ["METHOD_START", "{", "File   outputDirFile    =    new   File ( outputDir )  ;", "if    (  !  ( outputDirFile . exists (  )  )  )     {", "outputDirFile . mkdirs (  )  ;", "System . out . println ( String . format (  \" Creating   directory :     % s \"  ,    outputDirFile . getPath (  )  )  )  ;", "}", "for    ( Page   page    :    atlas . getPages (  )  )     {", "File   file    =    page . textureFile . file (  )  ;", "if    (  !  ( file . exists (  )  )  )", "throw   new   RuntimeException (  (  \" Unable   to   find   atlas   image :     \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "BufferedImage   img    =    null ;", "try    {", "img    =    ImageIO . read ( file )  ;", "}    catch    ( IOException   e )     {", "printExceptionAndExit ( e )  ;", "}", "for    ( Region   region    :    atlas . getRegions (  )  )     {", "System . out . println ( String . format (  \" Processing   image   for    % s :    x [  % s ]    y [  % s ]    w [  % s ]    h [  % s ]  ,    rotate [  % s ]  \"  ,    region . name ,    region . left ,    region . top ,    region . width ,    region . height ,    region . rotate )  )  ;", "if    (  ( region . page )     =  =    page )     {", "BufferedImage   splitImage    =    null ;", "String   extension    =    null ;", "if    (  ( region . splits )     =  =    null )     {", "splitImage    =    extractImage ( img ,    region ,    outputDirFile ,     0  )  ;", "extension    =     . OUTPUT _ TYPE ;", "} else    {", "splitImage    =    extractNinePatch ( img ,    region ,    outputDirFile )  ;", "extension    =    String . format (  \"  9  .  % s \"  ,     . OUTPUT _ TYPE )  ;", "}", "File   imgOutput    =    new   File ( outputDirFile ,    String . format (  \"  % s .  % s \"  ,     (  ( region . index )     =  =     (  -  1  )     ?    region . name    :     (  ( region . name )     +     \"  _  \"  )     +     ( region . index )  )  ,    extension )  )  ;", "File   imgDir    =    imgOutput . getParentFile (  )  ;", "if    (  !  ( imgDir . exists (  )  )  )     {", "System . out . println ( String . format (  \" Creating   directory :     % s \"  ,    imgDir . getPath (  )  )  )  ;", "imgDir . mkdirs (  )  ;", "}", "try    {", "ImageIO . write ( splitImage ,     . OUTPUT _ TYPE ,    imgOutput )  ;", "}    catch    ( Exception   e )     {", "printExceptionAndExit ( e )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["splitAtlas"], "fileName": "com.badlogic.gdx.tools.texturepacker.TextureUnpacker"}]