[{"methodBody": ["METHOD_START", "{", "return   screen ;", "}", "METHOD_END"], "methodName": ["getScreen"], "fileName": "com.badlogic.gdx.Game"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . screen )     !  =    null )", "this . screen . hide (  )  ;", "this . screen    =    screen ;", "if    (  ( this . screen )     !  =    null )     {", "this . screen . show (  )  ;", "this . screen . resize ( Ggraphics . getWidth (  )  ,    Ggraphics . getHeight (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setScreen"], "fileName": "com.badlogic.gdx.Game"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["keyDown"], "fileName": "com.badlogic.gdx.InputAdapter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["keyTyped"], "fileName": "com.badlogic.gdx.InputAdapter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["keyUp"], "fileName": "com.badlogic.gdx.InputAdapter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.InputAdapter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDragged"], "fileName": "com.badlogic.gdx.InputAdapter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["touchUp"], "fileName": "com.badlogic.gdx.InputAdapter"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  ( processor )     =  =    null )     {", "queue . clear (  )  ;", "return ;", "}", "processingQueue . addAll ( queue )  ;", "queue . clear (  )  ;", "}", "int [  ]    q    =    processingQueue . items ;", "InputProcessor   localProcessor    =    processor ;", "for    ( int   i    =     0  ,    n    =    processingQueue . size ;    i    <    n ;  )     {", "int   type    =    q [  ( i +  +  )  ]  ;", "currentEventTime    =     (  (  ( long )     ( q [  ( i +  +  )  ]  )  )     <  <     3  2  )     |     (  ( q [  ( i +  +  )  ]  )     &     4  2  9  4  9  6  7  2  9  5 L )  ;", "switch    ( type )     {", "case    . SKIP    :", "i    +  =    q [ i ]  ;", "break ;", "case    . KEY _ DOWN    :", "localProcessor . keyDown ( q [  ( i +  +  )  ]  )  ;", "break ;", "case    . KEY _ UP    :", "localProcessor . keyUp ( q [  ( i +  +  )  ]  )  ;", "break ;", "case    . KEY _ TYPED    :", "localProcessor . keyTyped (  (  ( char )     ( q [  ( i +  +  )  ]  )  )  )  ;", "break ;", "case    . TOUCH _ DOWN    :", "localProcessor . touchDown ( q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  )  ;", "break ;", "case    . TOUCH _ UP    :", "localProcessor . touchUp ( q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  )  ;", "break ;", "case    . TOUCH _ DRAGGED    :", "localProcessor . touchDragged ( q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  )  ;", "break ;", "case    . MOUSE _ MOVED    :", "localProcessor . mouseMoved ( q [  ( i +  +  )  ]  ,    q [  ( i +  +  )  ]  )  ;", "break ;", "case    . SCROLLED    :", "localProcessor . scrolled ( q [  ( i +  +  )  ]  )  ;", "break ;", "default    :", "throw   new   RuntimeException (  )  ;", "}", "}", "processingQueue . clear (  )  ;", "}", "METHOD_END"], "methodName": ["drain"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "return   currentEventTime ;", "}", "METHOD_END"], "methodName": ["getCurrentEventTime"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "return   processor ;", "}", "METHOD_END"], "methodName": ["getProcessor"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "queue . add ( InputEventQueue . KEY _ DOWN )  ;", "queueTime (  )  ;", "queue . add ( keycode )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyDown"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "queue . add ( InputEventQueue . KEY _ TYPED )  ;", "queueTime (  )  ;", "queue . add ( character )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyTyped"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "queue . add ( InputEventQueue . KEY _ UP )  ;", "queueTime (  )  ;", "queue . add ( keycode )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyUp"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    next ( InputEventQueue . MOUSE _ MOVED ,     0  )  ;    i    >  =     0  ;    i    =    next ( InputEventQueue . MOUSE _ MOVED ,     ( i    +     5  )  )  )     {", "queue . set ( i ,    InputEventQueue . SKIP )  ;", "queue . set (  ( i    +     3  )  ,     2  )  ;", "}", "queue . add ( InputEventQueue . MOUSE _ MOVED )  ;", "queueTime (  )  ;", "queue . add ( screenX )  ;", "queue . add ( screenY )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["mouseMoved"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "int [  ]    q    =    queue . items ;", "for    ( int   n    =    queue . size ;    i    <    n ;  )     {", "int   type    =    q [ i ]  ;", "if    ( type    =  =    nextType )", "return   i ;", "i    +  =     3  ;", "switch    ( type )     {", "case    . SKIP    :", "i    +  =    q [ i ]  ;", "break ;", "case    . KEY _ DOWN    :", "i +  +  ;", "break ;", "case    . KEY _ UP    :", "i +  +  ;", "break ;", "case    . KEY _ TYPED    :", "i +  +  ;", "break ;", "case    . TOUCH _ DOWN    :", "i    +  =     4  ;", "break ;", "case    . TOUCH _ UP    :", "i    +  =     4  ;", "break ;", "case    . TOUCH _ DRAGGED    :", "i    +  =     3  ;", "break ;", "case    . MOUSE _ MOVED    :", "i    +  =     2  ;", "break ;", "case    . SCROLLED    :", "i +  +  ;", "break ;", "default    :", "throw   new   RuntimeException (  )  ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "long   time    =    TimeUtils . nanoTime (  )  ;", "q . add (  (  ( int )     ( time    >  >     3  2  )  )  )  ;", "q . add (  (  ( int )     ( time )  )  )  ;", "}", "METHOD_END"], "methodName": ["queueTime"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "queue . add ( InputEventQueue . SCROLLED )  ;", "queueTime (  )  ;", "queue . add ( amount )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["scrolled"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "this . processor    =    processor ;", "}", "METHOD_END"], "methodName": ["setProcessor"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "queue . add ( InputEventQueue . TOUCH _ DOWN )  ;", "queueTime (  )  ;", "queue . add ( screenX )  ;", "queue . add ( screenY )  ;", "queue . add ( pointer )  ;", "queue . add ( button )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    next ( InputEventQueue . TOUCH _ DRAGGED ,     0  )  ;    i    >  =     0  ;    i    =    next ( InputEventQueue . TOUCH _ DRAGGED ,     ( i    +     6  )  )  )     {", "if    (  ( queue . get (  ( i    +     5  )  )  )     =  =    pointer )     {", "queue . set ( i ,    InputEventQueue . SKIP )  ;", "queue . set (  ( i    +     3  )  ,     3  )  ;", "}", "}", "queue . add ( InputEventQueue . TOUCH _ DRAGGED )  ;", "queueTime (  )  ;", "queue . add ( screenX )  ;", "queue . add ( screenY )  ;", "queue . add ( pointer )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDragged"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "queue . add ( InputEventQueue . TOUCH _ UP )  ;", "queueTime (  )  ;", "queue . add ( screenX )  ;", "queue . add ( screenY )  ;", "queue . add ( pointer )  ;", "queue . add ( button )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["touchUp"], "fileName": "com.badlogic.gdx.InputEventQueue"}, {"methodBody": ["METHOD_START", "{", "if    ( processor    =  =    null )", "throw   new   NullPointerException (  \" processor   cannot   be   null \"  )  ;", "processors . add ( processor )  ;", "}", "METHOD_END"], "methodName": ["addProcessor"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "if    ( processor    =  =    null )", "throw   new   NullPointerException (  \" processor   cannot   be   null \"  )  ;", "processors . insert ( index ,    processor )  ;", "}", "METHOD_END"], "methodName": ["addProcessor"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "processors . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "return   processors ;", "}", "METHOD_END"], "methodName": ["getProcessors"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    processors . size ;    i    <    n ;    i +  +  )", "if    ( processors . get ( i )  . keyDown ( keyde )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyDown"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    processors . size ;    i    <    n ;    i +  +  )", "if    ( processorset ( i )  . keyTyped ( character )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyTyped"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    processors . size ;    i    <    n ;    i +  +  )", "if    ( processors . get ( i )  . keyUp ( keyde )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["keyUp"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "processors . removeValue ( processor ,    true )  ;", "}", "METHOD_END"], "methodName": ["removeProcessor"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "processors . removeIndex ( index )  ;", "}", "METHOD_END"], "methodName": ["removeProcessor"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "this . processors    =    processors ;", "}", "METHOD_END"], "methodName": ["setProcessors"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "return   processors . size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    processors . size ;    i    <    n ;    i +  +  )", "if    ( processorset ( i )  . touchDown ( screenX ,    screenY ,    pointer ,    button )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    processors . size ;    i    <    n ;    i +  +  )", "if    ( processorset ( i )  . touchDrged ( screenX ,    screenY ,    pointer )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDragged"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    processors . size ;    i    <    n ;    i +  +  )", "if    ( processorset ( i )  . touchUp ( screenX ,    screenY ,    pointer ,    button )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["touchUp"], "fileName": "com.badlogic.gdx.InputMultiplexer"}, {"methodBody": ["METHOD_START", "{", "return   Version . isHigherEqual ( major ,    minor ,     ( revision    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["isHigher"], "fileName": "com.badlogic.gdx.Version"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Version . MAJOR )     !  =    major )", "return    ( Version . MAJOR )     >    major ;", "if    (  ( Version . MINOR )     !  =    minor )", "return    ( Version . MINOR )     >    minor ;", "return    ( Version . REVISION )     >  =    revision ;", "}", "METHOD_END"], "methodName": ["isHigherEqual"], "fileName": "com.badlogic.gdx.Version"}, {"methodBody": ["METHOD_START", "{", "return   Version . isLowerEqual ( major ,    minor ,     ( revision    -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["isLower"], "fileName": "com.badlogic.gdx.Version"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Version . MAJOR )     !  =    major )", "return    ( Version . MAJOR )     <    major ;", "if    (  ( Version . MINOR )     !  =    minor )", "return    ( Version . MINOR )     <    minor ;", "return    ( Version . REVISION )     <  =    revision ;", "}", "METHOD_END"], "methodName": ["isLowerEqual"], "fileName": "com.badlogic.gdx.Version"}, {"methodBody": ["METHOD_START", "{", "return   asset ;", "}", "METHOD_END"], "methodName": ["getAsset"], "fileName": "com.badlogic.gdx.assets.AssetLoadingTask"}, {"methodBody": ["METHOD_START", "{", "AsynchronousAssetLoader   asyncLoader    =     (  ( AsynchronousAssetLoader )     ( loader )  )  ;", "if    (  !  ( dependenciesLoaded )  )     {", "if    (  ( depsFuture )     =  =    null )     {", "depsFuture    =    executor . submit ( this )  ;", "} else    {", "if    ( depsFuture . isDone (  )  )     {", "try    {", "depsFuture . get (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  (  \" Couldn ' t   load   dependencies   of   asset :     \"     +     ( assetDesc . fileName )  )  ,    e )  ;", "}", "dependenciesLoaded    =    true ;", "if    ( asyncDone )     {", "asset    =    asyncLoader . loadSync ( manager ,    assetDesc . fileName ,    resolve ( loader ,    assetDesc )  ,    assetDesc . params )  ;", "}", "}", "}", "} else    {", "if    (  (  ( loadFuture )     =  =    null )     &  &     (  !  ( asyncDone )  )  )     {", "loadFuture    =    executor . submit ( this )  ;", "} else    {", "if    ( asyncDone )     {", "asset    =    asyncLoader . loadSync ( manager ,    assetDesc . fileName ,    resolve ( loader ,    assetDesc )  ,    assetDesc . params )  ;", "} else", "if    ( loadFuture . isDone (  )  )     {", "try    {", "loadFuture . get (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  (  \" Couldn ' t   load   asset :     \"     +     ( assetDesc . fileName )  )  ,    e )  ;", "}", "asset    =    asyncLoader . loadSync ( manager ,    assetDesc . fileName ,    resolve ( loader ,    assetDesc )  ,    assetDesc . params )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleAsyncLoader"], "fileName": "com.badlogic.gdx.assets.AssetLoadingTask"}, {"methodBody": ["METHOD_START", "{", "SynchronousAssetLoader   syncLoader    =     (  ( SynchronousAssetLoader )     ( loader )  )  ;", "if    (  !  ( dependenciesLoaded )  )     {", "dependenciesLoaded    =    true ;", "dependencies    =    syncLoader . getDependencies ( assetDesc . fileName ,    resolve ( loader ,    assetDesc )  ,    assetDesc . params )  ;", "if    (  ( dependencies )     =  =    null )     {", "asset    =    syncLoader . load ( manager ,    assetDesc . fileName ,    resolve ( loader ,    assetDesc )  ,    assetDesc . params )  ;", "return ;", "}", "removeDuplicates ( dependencies )  ;", "manager . injectDependencies ( assetDesc . fileName ,    dependencies )  ;", "} else    {", "asset    =    syncLoader . load ( manager ,    assetDesc . fileName ,    resolve ( loader ,    assetDesc )  ,    assetDesc . params )  ;", "}", "}", "METHOD_END"], "methodName": ["handleSyncLoader"], "fileName": "com.badlogic.gdx.assets.AssetLoadingTask"}, {"methodBody": ["METHOD_START", "{", "boolean   ordered    =    array . ordered ;", "array . ordered    =    true ;", "for    ( int   i    =     0  ;    i    <     ( array . size )  ;     +  + i )     {", "final   Str   fn    =    array . get ( i )  . fileName ;", "final   Class   type    =    array . get ( i )  . type ;", "for    ( int   j    =     ( array . size )     -     1  ;    j    >    i ;     -  - j )     {", "if    (  ( type    =  =     ( array . get ( j )  . type )  )     &  &     ( fn . equals ( array . get ( j )  . fileName )  )  )", "array . removeIndex ( j )  ;", "}", "}", "array . ordered    =    ordered ;", "}", "METHOD_END"], "methodName": ["removeDuplicates"], "fileName": "com.badlogic.gdx.assets.AssetLoadingTask"}, {"methodBody": ["METHOD_START", "{", "if    (  ( assetDesc . file )     =  =    null )", "assetDesc . file    =    loader . resolve ( assetDesc . fileName )  ;", "return   assetDesc . file ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.badlogic.gdx.assets.AssetLoadingTask"}, {"methodBody": ["METHOD_START", "{", "( ticks )  +  +  ;", "if    (  ( loader )    instanceof   Synchronouser )     {", "handleSyncLoader (  )  ;", "} else    {", "handleAsyncLoader (  )  ;", "}", "return    ( asset )     !  =    null ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.assets.AssetLoadingTask"}, {"methodBody": ["METHOD_START", "{", "assetTypes . put ( fileName ,    type )  ;", "ObjectMap < String ,    RefCountedContainer >    typeToAssets    =    get ( type )  ;", "if    ( typeToAssets    =  =    null )     {", "typeToAssets    =    new   ObjectMap < String ,    RefCountedContainer >  (  )  ;", "put ( type ,    typeToAssets )  ;", "}", "typeToAssets . put ( fileName ,    new   RefCountedContainer ( asset )  )  ;", "}", "METHOD_END"], "methodName": ["addAsset"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "AssetLoader   loader    =    getLoader ( assetDesc . type ,    assetDesc . fileName )  ;", "if    ( loader    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" No   loader   for   type :     \"     +     ( utils . reflect . ClassReflection . getSimpleName ( assetDesc . type )  )  )  )  ;", "tasks . push ( new   AssetLoadingTask ( this ,    assetDesc ,    loader ,    executor )  )  ;", "( peakTasks )  +  +  ;", "}", "METHOD_END"], "methodName": ["addTask"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "loadQueue . clear (  )  ;", "while    (  !  ( update (  )  )  )  ;", "ObjectIntMap < String >    dependencyCount    =    new   ObjectIntMap < String >  (  )  ;", "while    (  ( assetTypes . size )     >     0  )     {", "dependencyCount . clear (  )  ;", "Array < String >  =    assetTypes . keys (  )  . toArray (  )  ;", "for    ( String   asset    :     {", "dependencyCount . put ( asset ,     0  )  ;", "}", "for    ( String   asset    :     {", "Array < String >    dependencies    =    assetDependencies . get ( asset )  ;", "if    ( dependencies    =  =    null )", "continue ;", "for    ( String   dependency    :    dependencies )     {", "int   count    =    dependencyCount . get ( dependency ,     0  )  ;", "count +  +  ;", "dependencyCount . put ( dependency ,    count )  ;", "}", "}", "for    ( String   asset    :     {", "if    (  ( dependencyCount . get ( asset ,     0  )  )     =  =     0  )     {", "unload ( asset )  ;", "}", "}", "}", "thisclear (  )  ;", "this . assetTypes . clear (  )  ;", "this . assetDependencies . clear (  )  ;", "this . loaded    =     0  ;", "this . toLoad    =     0  ;", "this . peakTasks    =     0  ;", "this . loadQueue . clear (  )  ;", "this . tasks . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    RefCountedContainer >    typedAssets    =    assets . get ( asset . getClass (  )  )  ;", "if    ( typedAssets    =  =    null )", "return   false ;", "for    ( String   fileName    :    typedAssets . keys (  )  )     {", "T   otherAsset    =     (  ( T )     ( typedAssets . get ( fileName )  . getObject ( Object . class )  )  )  ;", "if    (  ( otherAsset    =  =    asset )     |  |     ( asset . equals ( otherAsset )  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsAsset"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "log . debug (  \" Waiting   for   loading   to   complete .  .  .  \"  )  ;", "while    (  !  ( update (  )  )  )", "utils . async . ThreadUtils . yield (  )  ;", "log . debug (  \" Loading   complete .  \"  )  ;", "}", "METHOD_END"], "methodName": ["finishLoading"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "finishLoadingAsset ( assetDesc . fileName )  ;", "}", "METHOD_END"], "methodName": ["finishLoadingAsset"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "log . debug (  (  \" Waiting   for   asset   to   be   loaded :     \"     +    fileName )  )  ;", "while    (  !  ( isLoaded ( fileName )  )  )     {", "update (  )  ;", "ThreadUtils . yield (  )  ;", "}", "log . debug (  (  \" Asset   loaded :     \"     +    fileName )  )  ;", "}", "METHOD_END"], "methodName": ["finishLoadingAsset"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   get ( assetDescriptor . fileName ,    assetDescriptor . type )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "Class < T >    type    =    assetTypes . get ( fileName )  ;", "if    ( type    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "ObjectMap < String ,    RefCountedContainer >    assetsByType    =    assets . get ( type )  ;", "if    ( assetsByType    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "RefCountedContainer   assetContainer    =    assetsByType . get ( fileName )  ;", "if    ( assetContainer    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "T   asset    =    assetContainer . getObject ( type )  ;", "if    ( asset    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "return   asset ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    RefCountedContainer >    assetsByType    =    assets . get ( type )  ;", "if    ( assetsByType    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "RefCountedContainer   assetContainer    =    assetsByType . get ( fileName )  ;", "if    ( assetContainer    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "T   asset    =    assetContainer . getObject ( type )  ;", "if    ( asset    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "return   asset ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    RefCountedContainer >    assetsByType    =    assets . get ( type )  ;", "if    ( assetsByType    !  =    null )     {", "for    ( ObjectMap . Entry < String ,    RefCountedContainer >    asset    :    assetsByType . entries (  )  )     {", "out . add ( asset . value . getObject ( type )  )  ;", "}", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["getAll"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "for    ( Class   assetType    :    assets . keys (  )  )     {", "ObjectMap < String ,    RefCountedContainer >    typedAssets    =    assets . get ( assetType )  ;", "for    ( String   fileName    :    typedAssets . keys (  )  )     {", "T   otherAsset    =     (  ( T )     ( typedAssets . get ( fileName )  . getObject ( Object . class )  )  )  ;", "if    (  ( otherAsset    =  =    asset )     |  |     ( asset . equals ( otherAsset )  )  )", "return   fileName ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAssetFileName"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   assetTypes . keys (  )  . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["getAssetNames"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   assetTypes . get ( fileName )  ;", "}", "METHOD_END"], "methodName": ["getAssetType"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   assetDependencies . get ( fileName )  ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buffer    =    new   StringBuffer (  )  ;", "for    ( String   fileName    :    assetTypes . keys (  )  )     {", "buffer . append ( fileName )  ;", "buffer . append (  \"  ,     \"  )  ;", "Class   type    =    assetTypes . get ( fileName )  ;", "RefCountedContainer   assetRef    =    get ( type )  . get ( fileName )  ;", "Array < String >    dependencies    =    assetDependencies . get ( fileName )  ;", "buffer . append ( ClassReflection . getSimpleName ( type )  )  ;", "buffer . append (  \"  ,    refs :     \"  )  ;", "buffer . append ( assetRef . getRefCount (  )  )  ;", "if    ( dependencies    !  =    null )     {", "buffer . append (  \"  ,    deps :     [  \"  )  ;", "for    ( String   dep    :    dependencies )     {", "buffer . append ( dep )  ;", "buffer . append (  \"  ,  \"  )  ;", "}", "buffer . append (  \"  ]  \"  )  ;", "}", "buffer . append (  \"  \\ n \"  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDiagnostics"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   resolver ;", "}", "METHOD_END"], "methodName": ["getFileHandleResolver"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   assetTypes . size ;", "}", "METHOD_END"], "methodName": ["getLoadedAssets"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   getLoader ( type ,    null )  ;", "}", "METHOD_END"], "methodName": ["getLoader"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "final   ObjectMap < String ,    AssetLoader >    loaders    =    this . loaders . get ( type )  ;", "if    (  ( loaders    =  =    null )     |  |     (  ( loaders . size )     <     1  )  )", "return   null ;", "if    ( fileName    =  =    null )", "return   loaders . get (  \"  \"  )  ;", "AssetLoader   result    =    null ;", "int   l    =     -  1  ;", "for    ( ObjectMap . Entry < String ,    AssetLoader >    entry    :    loaders . entries (  )  )     {", "if    (  (  ( entry . key . length (  )  )     >    l )     &  &     ( fileName . endsWith ( entry . key )  )  )     {", "result    =    entry . value ;", "l    =    entry . key . length (  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getLoader"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   log ;", "}", "METHOD_END"], "methodName": ["getLogger"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( toLoad )     =  =     0  )", "return    1  ;", "float   fractionalLoaded    =     (  ( float )     ( loaded )  )  ;", "if    (  ( peakTasks )     >     0  )     {", "fractionalLoaded    +  =     (  ( peakTasks )     -     ( tasks . size (  )  )  )     /     (  ( float )     ( peakTasks )  )  ;", "}", "return   Math . min (  1  ,     ( fractionalLoaded    /     (  ( float )     ( toLoad )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProgress"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return    ( loadQueue . size )     +     ( tasks . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getQueuedAssets"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "Class   type    =    assetTypes . get ( fileName )  ;", "if    ( type    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "return   assets . get ( type )  . get ( fileName )  . getRefCount (  )  ;", "}", "METHOD_END"], "methodName": ["getReferenceCount"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "log . error (  \" Error   loading .  \"  ,    t )  ;", "if    ( tasks . isEmpty (  )  )", "throw   new   GdxRuntimeException ( t )  ;", "AssetLoadingTask   task    =    tasks . pop (  )  ;", "AssetDescriptorDesc    =    taskDesc ;", "if    (  ( task . dependenciesLoaded )     &  &     (  ( task . dependencies )     !  =    null )  )     {", "for    ( AssetDescriptor   desc    :    task . dependencies )     {", "unload ( desc . fileName )  ;", "}", "}", "tasks . clear (  )  ;", "if    (  ( listener )     !  =    null )     {", "listener . errorDesc ,    t )  ;", "} else    {", "throw   new   GdxRuntimeException ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["handleTaskError"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "Array < String >    dependencies    =    assetDependencies . get ( parent )  ;", "if    ( dependencies    =  =    null )", "return ;", "for    ( String   dependency    :    dependencies )     {", "Class   type    =    assetTypes . get ( dependency )  ;", "RefCountedContainer   assetRef    =    get ( type )  . get ( dependency )  ;", "assetRef . incRefCount (  )  ;", "incrementRefCountedDependencies ( dependency )  ;", "}", "}", "METHOD_END"], "methodName": ["incrementRefCountedDependencies"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "ObjectSet < String >    injected    =    this . injected ;", "for    ( Descriptor   desc    :    dependendDescs )     {", "if    ( injected . contains ( desc . fileName )  )", "continue ;", "injected . add ( desc . fileName )  ;", "injectDependency ( parentFilename ,    desc )  ;", "}", "injected . clear (  )  ;", "}", "METHOD_END"], "methodName": ["injectDependencies"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "Array < String >    dependencies    =    assetDependencies . get ( parentAssetFilename )  ;", "if    ( dependencies    =  =    null )     {", "dependencies    =    new   Array (  )  ;", "assetDependencies . put ( parentAssetFilename ,    dependencies )  ;", "}", "dependencies . add ( dependendAssetDesc . fileName )  ;", "if    ( isLoaded ( dependendAssetDesc . fileName )  )     {", "log . debug (  (  \" Dependency   already   loaded :     \"     +    dependendAssetDesc )  )  ;", "Class   type    =    assetTypes . get ( dependendAssetDesc . fileName )  ;", "RefCountedContainer   assetRef    =    get ( type )  . get ( dependendAssetDesc . fileName )  ;", "assetRef . incRefCount (  )  ;", "incrementRefCountedDependencies ( dependendAssetDesc . fileName )  ;", "} else    {", "log . info (  (  \" Loading   dependency :     \"     +    dependendAssetDesc )  )  ;", "addTask ( dependendAssetDesc )  ;", "}", "}", "METHOD_END"], "methodName": ["injectDependency"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "return   isLoaded ( assetDesc . fileName )  ;", "}", "METHOD_END"], "methodName": ["isLoaded"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "if    ( fileName    =  =    null )", "return   false ;", "return   Types . containsKey ( fileName )  ;", "}", "METHOD_END"], "methodName": ["isLoaded"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    RefCountedContainer >    assetsByType    =    assets . get ( type )  ;", "if    ( assetsByType    =  =    null )", "return   false ;", "RefCountedContainer   assetContainer    =    assetsByType . get ( fileName )  ;", "if    ( assetContainer    =  =    null )", "return   false ;", "return    ( assetContainer . getObject ( type )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isLoaded"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "load ( desc . fileName ,    desc . type ,    desc . params )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "load ( fileName ,    type ,    null )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "AssetLoader   loader    =    getLoader ( type ,    fileName )  ;", "if    ( loader    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" No   loader   for   type :     \"     +     ( utils . reflect . ClassReflection . getSimpleName ( type )  )  )  )  ;", "if    (  ( loadQueue . size )     =  =     0  )     {", "loaded    =     0  ;", "toLoad    =     0  ;", "peakTasks    =     0  ;", "}", "for    ( int   i    =     0  ;    i    <     ( loadQueue . size )  ;    i +  +  )     {", "AssetDescriptor   desc    =    loadQueue . get ( i )  ;", "if    (  ( desc . fileName . equals ( fileName )  )     &  &     (  !  ( desc . type . equals ( type )  )  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  (  (  \" Asset   with   name    '  \"     +    fileName )     +     \"  '    already   in   preload   queue ,    but   has   different   type    ( expected :     \"  )     +     ( utils . reflect . ClassReflection . getSimpleName ( type )  )  )     +     \"  ,    found :     \"  )     +     ( utils . reflect . ClassReflection . getSimpleName ( desc . type )  )  )     +     \"  )  \"  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( tasks . size (  )  )  ;    i +  +  )     {", "AssetDescriptor   desc    =    tasks . get ( i )  . assetDesc ;", "if    (  ( desc . fileName . equals ( fileName )  )     &  &     (  !  ( desc . type . equals ( type )  )  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  (  (  \" Asset   with   name    '  \"     +    fileName )     +     \"  '    already   in   task   list ,    but   has   different   type    ( expected :     \"  )     +     ( utils . reflect . ClassReflection . getSimpleName ( type )  )  )     +     \"  ,    found :     \"  )     +     ( utils . reflect . ClassReflection . getSimpleName ( desc . type )  )  )     +     \"  )  \"  )  )  ;", "}", "Class   otherType    =    assetTypes . get ( fileName )  ;", "if    (  ( otherType    !  =    null )     &  &     (  !  ( otherType . equals ( type )  )  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  (  (  \" Asset   with   name    '  \"     +    fileName )     +     \"  '    already   loaded ,    but   has   different   type    ( expected :     \"  )     +     ( utils . reflect . ClassReflection . getSimpleName ( type )  )  )     +     \"  ,    found :     \"  )     +     ( utils . reflect . ClassReflection . getSimpleName ( otherType )  )  )     +     \"  )  \"  )  )  ;", "( toLoad )  +  +  ;", "AssetDescriptor   assetDesc    =    new   AssetDescriptor ( fileName ,    type ,    parameter )  ;", "loadQueue . add ( assetDesc )  ;", "log . debug (  (  \" Queued :     \"     +    assetDesc )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "AssetDescriptor   assetDesc    =    loadQueue . removeIndex (  0  )  ;", "if    ( isLoaded ( assetDesc . fileName )  )     {", "log . debug (  (  \" Already   loaded :     \"     +    assetDesc )  )  ;", "Class   type    =    assetTypes . get ( assetDesc . fileName )  ;", "RefCountedContainer   assetRef    =    get ( type )  . get ( assetDesc . fileName )  ;", "assetRef . incRefCount (  )  ;", "incrementRefCountedDependencies ( assetDesc . fileName )  ;", "if    (  (  ( assetDesc . params )     !  =    null )     &  &     (  ( assetDesc . params . loadedCallback )     !  =    null )  )     {", "assetDesc . params . loadedCallback . finishedLoading ( this ,    assetDesc . fileName ,    assetDesc . type )  ;", "}", "( loaded )  +  +  ;", "} else    {", "log . info (  (  \" Loading :     \"     +    assetDesc )  )  ;", "addTask ( assetDesc )  ;", "}", "}", "METHOD_END"], "methodName": ["nextTask"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    listener ;", "}", "METHOD_END"], "methodName": ["setErrorListener"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "setLoader ( type ,    null ,    loader )  ;", "}", "METHOD_END"], "methodName": ["setLoader"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )", "throw   new   IllegalArgumentException (  \" type   cannot   be   null .  \"  )  ;", "if    ( loader    =  =    null )", "throw   new   IllegalArgumentException (  \" loader   cannot   be   null .  \"  )  ;", "log . debug (  (  (  (  \" Loader   set :     \"     +     ( ClassReflection . getSimpleName ( type )  )  )     +     \"     -  >     \"  )     +     ( ClassReflection . getSimpleName ( loader . getClass (  )  )  )  )  )  ;", "ObjectMap < String ,    Loader >    loaders    =    this . loaders . get ( type )  ;", "if    ( loaders    =  =    null )", "this . loaders . put ( type ,     ( loaders    =    new   ObjectMap < String ,    Loader >  (  )  )  )  ;", "loaders . put (  ( suffix    =  =    null    ?     \"  \"     :    suffix )  ,    loader )  ;", "}", "METHOD_END"], "methodName": ["setLoader"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "log    =    logger ;", "}", "METHOD_END"], "methodName": ["setLogger"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "Class   type    =    assetTypes . get ( fileName )  ;", "if    ( type    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "assets . get ( type )  . get ( fileName )  . setRefCount ( refCount )  ;", "}", "METHOD_END"], "methodName": ["setReferenceCount"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "throw   ex ;", "}", "METHOD_END"], "methodName": ["taskFailed"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tasks . size (  )  )     >     0  )     {", "AssetLoadingTask   currAsset    =    tasks . firstElement (  )  ;", "if    ( currAsset . assetDesc . fileName . equals ( fileName )  )     {", "currAsset . cancel    =    true ;", "log . debug (  (  \" Unload    ( from   tasks )  :     \"     +    fileName )  )  ;", "return ;", "}", "}", "int   foundIndex    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     ( loadQueue . size )  ;    i +  +  )     {", "if    ( loadQueue . get ( i )  . fileName . equals ( fileName )  )     {", "foundIndex    =    i ;", "break ;", "}", "}", "if    ( foundIndex    !  =     (  -  1  )  )     {", "( toLoad )  -  -  ;", "loadQueue . removeIndex ( foundIndex )  ;", "log . debug (  (  \" Unload    ( from   queue )  :     \"     +    fileName )  )  ;", "return ;", "}", "Class   type    =    assetTypes . get ( fileName )  ;", "if    ( type    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Asset   not   loaded :     \"     +    fileName )  )  ;", "RefCountedContainer   assetRef    =    assets . get ( type )  . get ( fileName )  ;", "assetRef . decRefCount (  )  ;", "if    (  ( assetRef . getRefCount (  )  )     <  =     0  )     {", "log . debug (  (  \" Unload    ( dispose )  :     \"     +    fileName )  )  ;", "if    (  ( assetRef . getObject ( Object . class )  )    instanceof   Disposable )", "(  ( Disposable )     ( assetRef . getObject ( Object . class )  )  )  . dispose (  )  ;", "assetTypes . remove ( fileName )  ;", "assets . get ( type )  . remove ( fileName )  ;", "} else    {", "log . debug (  (  \" Unload    ( decrement )  :     \"     +    fileName )  )  ;", "}", "Array < String >    dependencies    =    assetDependencies . get ( fileName )  ;", "if    ( dependencies    !  =    null )     {", "for    ( String   dependency    :    dependencies )     {", "if    ( isLoaded ( dependency )  )", "unload ( dependency )  ;", "}", "}", "if    (  ( assetRef . getRefCount (  )  )     <  =     0  )     {", "assetDependencies . remove ( fileName )  ;", "}", "}", "METHOD_END"], "methodName": ["unload"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( tks . size (  )  )     =  =     0  )     {", "while    (  (  ( loadQueue . size )     !  =     0  )     &  &     (  ( tks . size (  )  )     =  =     0  )  )     {", "nextTk (  )  ;", "}", "if    (  ( tks . size (  )  )     =  =     0  )", "return   true ;", "}", "return    (  ( updateTk (  )  )     &  &     (  ( loadQueue . size )     =  =     0  )  )     &  &     (  ( tks . size (  )  )     =  =     0  )  ;", "}    catch    ( Throwable   t )     {", "handleTkError ( t )  ;", "return    ( loadQueue . size )     =  =     0  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "long   endTime    =     ( TimeUtils . millis (  )  )     +    millis ;", "while    ( true )     {", "boolean   done    =    update (  )  ;", "if    ( done    |  |     (  ( TimeUtils . millis (  )  )     >    endTime )  )", "return   done ;", "ThreadUtils . yield (  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "AssetLoadingTask   task    =    tasks . peek (  )  ;", "boolean   complete    =    true ;", "try    {", "complete    =     ( task . cancel )     |  |     ( task . update (  )  )  ;", "}    catch    ( RuntimeException   ex )     {", "task . cancel    =    true ;", "taskFailed ( taskDesc ,    ex )  ;", "}", "if    ( complete )     {", "if    (  ( tasks . size (  )  )     =  =     1  )     {", "( loaded )  +  +  ;", "peakTasks    =     0  ;", "}", "tasks . pop (  )  ;", "if    ( task . cancel )", "return   true ;", "addAsset ( taskDesc . fileName ,    taskDesc . type ,    task . getAsset (  )  )  ;", "if    (  (  ( taskDesc . params )     !  =    null )     &  &     (  ( taskDesc . params . loadedCallback )     !  =    null )  )     {", "taskDesc . params . loadedCallback . finishedLoading ( this ,    taskDesc . fileName ,    taskDesc . type )  ;", "}", "long   endTime    =    TimeUtils . nanoTime (  )  ;", "log . debug (  (  (  (  \" Loaded :     \"     +     (  ( endTime    -     ( task . startTime )  )     /     1  0  0  0  0  0  0  .  0 F )  )     +     \" ms    \"  )     +     ( taskDesc )  )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["updateTask"], "fileName": "com.badlogic.gdx.assets.AssetManager"}, {"methodBody": ["METHOD_START", "{", "( refCount )  -  -  ;", "}", "METHOD_END"], "methodName": ["decRefCount"], "fileName": "com.badlogic.gdx.assets.RefCountedContainer"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( object )  )  ;", "}", "METHOD_END"], "methodName": ["getObject"], "fileName": "com.badlogic.gdx.assets.RefCountedContainer"}, {"methodBody": ["METHOD_START", "{", "return   refCount ;", "}", "METHOD_END"], "methodName": ["getRefCount"], "fileName": "com.badlogic.gdx.assets.RefCountedContainer"}, {"methodBody": ["METHOD_START", "{", "( refCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["incRefCount"], "fileName": "com.badlogic.gdx.assets.RefCountedContainer"}, {"methodBody": ["METHOD_START", "{", "this . object    =    asset ;", "}", "METHOD_END"], "methodName": ["setObject"], "fileName": "com.badlogic.gdx.assets.RefCountedContainer"}, {"methodBody": ["METHOD_START", "{", "this . refCount    =    refCount ;", "}", "METHOD_END"], "methodName": ["setRefCount"], "fileName": "com.badlogic.gdx.assets.RefCountedContainer"}, {"methodBody": ["METHOD_START", "{", "return   resolver . resolve ( fileName )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.badlogic.gdx.assets.loaders.AssetLoader"}, {"methodBody": ["METHOD_START", "{", "return   loadModel ( fileHandle ,    new   TextureProvider . FileTextureProvider (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["loadModel"], "fileName": "com.badlogic.gdx.assets.loaders.ModelLoader"}, {"methodBody": ["METHOD_START", "{", "return   loadModel ( fileHandle ,    new   TextureProvider . FileTextureProvider (  )  ,    parameters )  ;", "}", "METHOD_END"], "methodName": ["loadModel"], "fileName": "com.badlogic.gdx.assets.loaders.ModelLoader"}, {"methodBody": ["METHOD_START", "{", "return   loadModel ( fileHandle ,    textureProvider ,    null )  ;", "}", "METHOD_END"], "methodName": ["loadModel"], "fileName": "com.badlogic.gdx.assets.loaders.ModelLoader"}, {"methodBody": ["METHOD_START", "{", "final   ModelData   data    =    loadModelData ( fileHandle ,    parameters )  ;", "return   data    =  =    null    ?    null    :    new   Model ( data ,    textureProvider )  ;", "}", "METHOD_END"], "methodName": ["loadModel"], "fileName": "com.badlogic.gdx.assets.loaders.ModelLoader"}, {"methodBody": ["METHOD_START", "{", "return   loadModelData ( fileHandle ,    null )  ;", "}", "METHOD_END"], "methodName": ["loadModelData"], "fileName": "com.badlogic.gdx.assets.loaders.ModelLoader"}, {"methodBody": ["METHOD_START", "{", "return   music ;", "}", "METHOD_END"], "methodName": ["getLoadedMusic"], "fileName": "com.badlogic.gdx.assets.loaders.MusicLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   Skin ( atlas )  ;", "}", "METHOD_END"], "methodName": ["newSkin"], "fileName": "com.badlogic.gdx.assets.loaders.SkinLoader"}, {"methodBody": ["METHOD_START", "{", "return   sound ;", "}", "METHOD_END"], "methodName": ["getLoadedSound"], "fileName": "com.badlogic.gdx.assets.loaders.SoundLoader"}, {"methodBody": ["METHOD_START", "{", "return   baseResolver ;", "}", "METHOD_END"], "methodName": ["getBaseResolver"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.PrefixFileHandleResolver"}, {"methodBody": ["METHOD_START", "{", "return   prefix ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.PrefixFileHandleResolver"}, {"methodBody": ["METHOD_START", "{", "this . baseResolver    =    baseResolver ;", "}", "METHOD_END"], "methodName": ["setBaseResolver"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.PrefixFileHandleResolver"}, {"methodBody": ["METHOD_START", "{", "this . prefix    =    prefix ;", "}", "METHOD_END"], "methodName": ["setPrefix"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.PrefixFileHandleResolver"}, {"methodBody": ["METHOD_START", "{", "int   w    =    Gdx . graphics . getWidth (  )  ;", "int   h    =    Gdx . graphics . getHeight (  )  ;", ". Resolution   best    =    descriptors [  0  ]  ;", "if    ( w    <    h )     {", "for    ( int   i    =     0  ,    n    =    descriptors . length ;    i    <    n ;    i +  +  )     {", ". Resolution   other    =    descriptors [ i ]  ;", "if    (  (  (  ( w    >  =     ( other . portraitWidth )  )     &  &     (  ( other . portraitWidth )     >  =     ( best . portraitWidth )  )  )     &  &     ( h    >  =     ( other . portraitHeight )  )  )     &  &     (  ( other . portraitHeight )     >  =     ( best . portraitHeight )  )  )", "best    =    descriptors [ i ]  ;", "}", "} else    {", "for    ( int   i    =     0  ,    n    =    descriptors . length ;    i    <    n ;    i +  +  )     {", ". Resolution   other    =    descriptors [ i ]  ;", "if    (  (  (  ( w    >  =     ( other . portraitHeight )  )     &  &     (  ( other . portraitHeight )     >  =     ( best . portraitHeight )  )  )     &  &     ( h    >  =     ( other . portraitWidth )  )  )     &  &     (  ( other . portraitWidth )     >  =     ( best . portraitWidth )  )  )", "best    =    descriptors [ i ]  ;", "}", "}", "return   best ;", "}", "METHOD_END"], "methodName": ["choose"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver"}, {"methodBody": ["METHOD_START", "{", "String   parentString    =     \"  \"  ;", "Handle   parent    =    originalHandle . parent (  )  ;", "if    (  ( parent    !  =    null )     &  &     (  !  ( parent . name (  )  . equals (  \"  \"  )  )  )  )     {", "parentString    =    parent    +     \"  /  \"  ;", "}", "return    (  ( parentString    +    suffix )     +     \"  /  \"  )     +     ( originalHandle . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "return   new    ( new   File ( name )  ,    type )  ;", "return   new    ( new   File ( file ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "destDir . mkdirs (  )  ;", "[  ]    files    =    sourceDir . list (  )  ;", "for    ( int   i    =     0  ,    n    =    files . length ;    i    <    n ;    i +  +  )     {", "srcFile    =    files [ i ]  ;", "destFile    =    destDir . child ( srcFile . name (  )  )  ;", "if    ( srcFile . isDirectory (  )  )", ". copyDirectory ( srcFile ,    destFile )  ;", "else", ". copyFile ( srcFile ,    destFile )  ;", "}", "}", "METHOD_END"], "methodName": ["copyDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "try    {", "dest . write ( source . read (  )  ,    false )  ;", "}    catch    ( Exception   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  (  (  (  (  (  \" Error   copying   source :     \"     +     ( source )  )     +     \"     (  \"  )     +     ( source . type )  )     +     \"  )  \\ n \"  )     +     \" To   destination :     \"  )     +     ( dest )  )     +     \"     (  \"  )     +     ( dest . type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFile"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isDirectory (  )  )  )     {", "if    ( dest . isDirectory (  )  )", "dest    =    dest . child ( name (  )  )  ;", "FileHandle . copyFile ( this ,    dest )  ;", "return ;", "}", "if    ( dest . exists (  )  )     {", "if    (  !  ( dest . isDirectory (  )  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Destination   exists   but   is   not   a   directory :     \"     +    dest )  )  ;", "} else    {", "dest . mkdirs (  )  ;", "if    (  !  ( dest . isDirectory (  )  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Destination   directory   cannot   be   created :     \"     +    dest )  )  ;", "}", "FileHandle . copyDirectory ( this ,    dest . child ( name (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( Files . FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   an   internal   file :     \"     +     ( file )  )  )  ;", "return   file (  )  . delete (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( Files . FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   an   internal   file :     \"     +     ( file )  )  )  ;", "return   FileHandle . deleteDirectory ( file (  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "FileHandle . emptyDirectory ( file ,    false )  ;", "return   file . delete (  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "emptyDirectory ( false )  ;", "}", "METHOD_END"], "methodName": ["emptyDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( Files . FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   an   internal   file :     \"     +     ( file )  )  )  ;", "FileHandle . emptyDirectory ( file (  )  ,    preserveTree )  ;", "}", "METHOD_END"], "methodName": ["emptyDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    ( file . exists (  )  )     {", "File [  ]    files    =    file . listFiles (  )  ;", "if    ( files    !  =    null )     {", "for    ( int   i    =     0  ,    n    =    files . length ;    i    <    n ;    i +  +  )     {", "if    (  !  ( files [ i ]  . isDirectory (  )  )  )", "files [ i ]  . delete (  )  ;", "else", "if    ( preserveTree )", ". emptyDirectory ( files [ i ]  ,    true )  ;", "else", ". deleteDirectory ( files [ i ]  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["emptyDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "int   length    =     (  ( int )     ( length (  )  )  )  ;", "return   length    !  =     0     ?    length    :     5  1  2  ;", "}", "METHOD_END"], "methodName": ["estimateLength"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   Internal    :", "if    ( file (  )  . exists (  )  )", "return   true ;", "case   Classpath    :", "return    (  . class . getResource (  (  \"  /  \"     +     ( file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )  )  )     !  =    null ;", "}", "return   file (  )  . exists (  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "String   name    =    file . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return    \"  \"  ;", "return   name . substring (  ( dotIndex    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["extension"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . External )  )", "return   new   File ( Gdx . files . getExternalStoragePath (  )  ,    file . getPath (  )  )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "return   false ;", "return   file (  )  . isDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   file (  )  . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type )     =  =     ( Files . FileType . Classpath )  )     |  |     (  (  ( type )     =  =     ( Files . FileType . Internal )  )     &  &     (  !  ( file . exists (  )  )  )  )  )     {", "InputStream   input    =    read (  )  ;", "try    {", "return   input . available (  )  ;", "}    catch    ( Exception   ignored )     {", "}    finally    {", "StreamUtils . closeQuietly ( input )  ;", "}", "return    0  ;", "}", "return   file (  )  . length (  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "String [  ]    relativePaths    =    file (  )  . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileHandle [  0  ]  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )", "handles [ i ]     =    child ( relativePaths [ i ]  )  ;", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "File   file    =    file (  )  ;", "String [  ]    relativePaths    =    file . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileHandle [  0  ]  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "FileHandle   child    =    child ( path )  ;", "if    (  !  ( filter . accept ( child . file (  )  )  )  )", "continue ;", "handles [ count ]     =    child ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileHandle [  ]    newHandles    =    new   FileHandle [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "File   file    =    file (  )  ;", "String [  ]    relativePaths    =    file . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileHandle [  0  ]  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "if    (  !  ( filter . accept ( file ,    path )  )  )", "continue ;", "handles [ count ]     =    child ( path )  ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileHandle [  ]    newHandles    =    new   FileHandle [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "String [  ]    relativePaths    =    file (  )  . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileHandle [  0  ]  ;", "FileHandle [  ]    handles    =    new   FileHandle [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "if    (  !  ( path . endsWith ( suffix )  )  )", "continue ;", "handles [ count ]     =    child ( path )  ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileHandle [  ]    newHandles    =    new   FileHandle [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   mkdirs   with   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( Files . FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   mkdirs   with   an   internal   file :     \"     +     ( file )  )  )  ;", "file (  )  . mkdirs (  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   Classpath    :", "throw   new   GdxRuntimeException (  (  \" Cannot   move   a   classpath :     \"     +     )  )  )  ;", "case   Internal    :", "throw   new   GdxRuntimeException (  (  \" Cannot   move   an   internal :     \"     +     )  )  )  ;", "case   Absolute    :", "case   External    :", "if    (  )  . renameTo ( dest (  )  )  )", "return ;", "}", "copyTo ( dest )  ;", "delete (  )  ;", "if    (  ( exists (  )  )     &  &     ( isDirectory (  )  )  )", "deleteDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   file . getName (  )  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "String   name    =    file . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return   name ;", "return   name . substring (  0  ,    dotIndex )  ;", "}", "METHOD_END"], "methodName": ["nameWithoutExtension"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "File   parent    =    file . getParentFile (  )  ;", "if    ( parent    =  =    null )     {", "if    (  ( type )     =  =     ( Files . FileType . Absolute )  )", "parent    =    new   File (  \"  /  \"  )  ;", "else", "parent    =    new   File (  \"  \"  )  ;", "}", "return   new    ( parent ,    type )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "String   path    =    file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "int   dotIndex    =    path . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return   path ;", "return   path . substring (  0  ,    dotIndex )  ;", "}", "METHOD_END"], "methodName": ["pathWithoutExtension"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( type )     =  =     ( Files . FileType . Classpath )  )     |  |     (  (  ( type )     =  =     ( Files . FileType . Internal )  )     &  &     (  !  ( file (  )  . exists (  )  )  )  )  )     |  |     (  (  ( type )     =  =     ( Files . FileType . Local )  )     &  &     (  !  ( file (  )  . exists (  )  )  )  )  )     {", "InputStream   input    =     . class . getResourceAsStream (  (  \"  /  \"     +     ( file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )  )  ;", "if    ( input    =  =    null )", "throw   new   GdxRuntimeException (  (  (  (  (  \" File   not   found :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  )  ;", "return   input ;", "}", "try    {", "return   new   FileInputStream ( file (  )  )  ;", "}    catch    ( Exception   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   GdxRuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   reading   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedInputStream ( read (  )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    read (  )  ;", "try    {", "return   StreamUtils . copyStreamToByteArray ( input ,    estimateLength (  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading    :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( input )  ;", "}", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    read (  )  ;", "int   position    =     0  ;", "try    {", "while    ( true )     {", "int   count    =    input . read ( bytes ,     ( offset    +    position )  ,     ( size    -    position )  )  ;", "if    ( count    <  =     0  )", "break ;", "position    +  =    count ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading    :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( input )  ;", "}", "return   position    -    offset ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   readString ( null )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   output    =    new   StringBuilder ( estimateLength (  )  )  ;", "InputStreamReader   reader    =    null ;", "try    {", "if    ( charset    =  =    null )", "reader    =    new   InputStreamReader ( read (  )  )  ;", "else", "reader    =    new   InputStreamReader ( read (  )  ,    charset )  ;", "char [  ]    buffer    =    new   char [  2  5  6  ]  ;", "while    ( true )     {", "int   length    =    reader . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "output . append ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   layout    :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( reader )  ;", "}", "return   output . toString (  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   InputStreamReader ( read (  )  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedReader ( new   InputStreamReader ( read (  )  )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   BufferedReader ( new   InputStreamReader ( read (  )  ,    charset )  ,    bufferSize )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading    :     \"     +     ( this )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "InputStream   stream    =    read (  )  ;", "try    {", "return   new   InputStreamReader ( stream ,    charset )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "StreamUtils . closeQuietly ( stream )  ;", "throw   new   GdxRuntimeException (  (  \" Error   reading    :     \"     +     ( this )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" Cannot   get   the   sibling   of   the   root .  \"  )  ;", "return   new   FileHandle ( new   File ( file . getParent (  )  ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["sibling"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   file    =    File . createTempFile ( prefix ,    null )  ;", "if    (  !  ( file . delete (  )  )  )", "throw   new   IOException (  (  \" Unable   to   delete   temp   file :     \"     +    file )  )  ;", "if    (  !  ( file . mkdir (  )  )  )", "throw   new   IOException (  (  \" Unable   to   create   temp   directory :     \"     +    file )  )  ;", "return   new    ( file )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  \" Unable   to   create   temp   file .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tempDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   FileHandle ( File . createTempFile ( prefix ,    null )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  \" Unable   to   create   temp   file .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tempFile"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   GdxRuntimeException (  (  \" Cannot   write   to   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( Files . FileType . Internal )  )", "throw   new   GdxRuntimeException (  (  \" Cannot   write   to   an   internal   file :     \"     +     ( file )  )  )  ;", "parent (  )  . mkdirs (  )  ;", "try    {", "return   new   FileOutputStream ( file (  )  ,    append )  ;", "}    catch    ( Exception   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   GdxRuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedOutputStream ( write ( append )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    null ;", "try    {", "output    =    write ( append )  ;", "StreamUtils . copyStream ( input ,    output )  ;", "}    catch    ( Exception   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   stream   writing   to    :     \"     +     (  )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( input )  ;", "StreamUtils . closeQuietly ( output )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    write ( append )  ;", "try    {", "output . write ( bytes )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   writing    :     \"     +     (  )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( output )  ;", "}", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    write ( append )  ;", "try    {", "output . write ( bytes ,    offset ,    length )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   writing    :     \"     +     (  )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( output )  ;", "}", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "writeString ( string ,    append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "Writer   writer    =    null ;", "try    {", "writer    =    writer ( append ,    charset )  ;", "writer . write ( string )  ;", "}    catch    ( Exception   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   writing    :     \"     +     (  )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "return   writer ( append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( Files . FileType . Classpath )  )", "throw   new   GdxRuntimeException (  (  \" Cannot   write   to   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( Files . FileType . Internal )  )", "throw   new   GdxRuntimeException (  (  \" Cannot   write   to   an   internal   file :     \"     +     ( file )  )  )  ;", "parent (  )  . mkdirs (  )  ;", "try    {", "FileOutputStream   output    =    new   FileOutputStream ( file (  )  ,    append )  ;", "if    ( charset    =  =    null )", "return   new   OutputStreamWriter ( output )  ;", "else", "return   new   OutputStreamWriter ( output ,    charset )  ;", "}    catch    ( IOException   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   GdxRuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["sibling"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return   getPickRay ( screenX ,    screenY ,     0  ,     0  ,    Gdx . graphics . getWidth (  )  ,    Gdx . graphics . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPickRay"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "unproject ( ray . origin . set ( screenX ,    screenY ,     0  )  ,    viewportX ,    viewportY ,    viewportWidth ,    viewportHeight )  ;", "unproject ( ray . direction . set ( screenX ,    screenY ,     1  )  ,    viewportX ,    viewportY ,    viewportWidth ,    viewportHeight )  ;", "ray . direction . sub ( ray . origin )  . nor (  )  ;", "return   ray ;", "}", "METHOD_END"], "methodName": ["getPickRay"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "lookAt ( target . x ,    target . y ,    target . z )  ;", "}", "METHOD_END"], "methodName": ["lookAt"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "tmpVec . set ( x ,    y ,    z )  . sub ( position )  . nor (  )  ;", "if    (  !  ( tmpVec . isZero (  )  )  )     {", "float   dot    =    tmpVec . dot ( up )  ;", "if    (  ( Math . abs (  ( dot    -     1  )  )  )     <     1  .  0 E -  9 F )     {", "up . set ( direction )  . scl (  (  -  1  )  )  ;", "} else", "if    (  ( Math . abs (  ( dot    +     1  )  )  )     <     1  .  0 E -  9 F )     {", "up . set ( direction )  ;", "}", "direction . set ( tmpVec )  ;", "normalizeUp (  )  ;", "}", "}", "METHOD_END"], "methodName": ["lookAt"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "tmpVec . set ( direction )  . crs ( up )  . nor (  )  ;", "up . set ( tmpVec )  . crs ( direction )  . nor (  )  ;", "}", "METHOD_END"], "methodName": ["normalizeUp"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "project ( worldCoords ,     0  ,     0  ,    Gdx . graphics . getWidth (  )  ,    Gdx . graphics . getHeight (  )  )  ;", "return   worldCoords ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "worldCoords . prj ( combined )  ;", "worldCoords . x    =     (  ( viewportWidth    *     (  ( worldCoords . x )     +     1  )  )     /     2  )     +    viewportX ;", "worldCoords . y    =     (  ( viewportHeight    *     (  ( worldCoords . y )     +     1  )  )     /     2  )     +    viewportY ;", "worldCoords . z    =     (  ( worldCoords . z )     +     1  )     /     2  ;", "return   worldCoords ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "direction . rot ( transform )  ;", "up . rot ( transform )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "quat . transform ( direction )  ;", "quat . transform ( up )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "direction . rotate ( axis ,    angle )  ;", "up . rotate ( axis ,    angle )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "direction . rotate ( angle ,    axisX ,    axisY ,    axisZ )  ;", "up . rotate ( angle ,    axisX ,    axisY ,    axisZ )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "tmpVec . set ( point )  ;", "tmpVec . sub ( position )  ;", "translate ( tmpVec )  ;", "rotate ( axis ,    angle )  ;", "tmpVec . rotate ( axis ,    angle )  ;", "translate (  (  -  ( tmpVec . x )  )  ,     (  -  ( tmpVec . y )  )  ,     (  -  ( tmpVec . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["rotateAround"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "position . mul ( transform )  ;", "rotate ( transform )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "position . add ( vec )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "position . add ( x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "unproject ( screenCoords ,     0  ,     0  ,    Gdx . graphics . getWidth (  )  ,    Gdx . graphics . getHeight (  )  )  ;", "return   screenCoords ;", "}", "METHOD_END"], "methodName": ["unproject"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "float   x    =    screenCoords . x ;", "float   y    =    screenCoords . y ;", "x    =    x    -    viewportX ;", "y    =     (  ( GgetHeight (  )  )     -    y )     -     1  ;", "y    =    y    -    viewportY ;", "screenCoords . x    =     (  (  2     *    x )     /    viewportWidth )     -     1  ;", "screenCoords . y    =     (  (  2     *    y )     /    viewportHeight )     -     1  ;", "screenCoords . z    =     (  2     *     ( screenCoords . z )  )     -     1  ;", "screenCoords . prj ( invProjectionView )  ;", "return   screenCoords ;", "}", "METHOD_END"], "methodName": ["unproject"], "fileName": "com.badlogic.gdx.graphics.Camera"}, {"methodBody": ["METHOD_START", "{", "int   c    =    NumberUtils . floatToIntColor ( value )  ;", "color . a    =     (  ( c    &     -  1  6  7  7  7  2  1  6  )     >  >  >     2  4  )     /     2  5  5  .  0 F ;", "color . b    =     (  ( c    &     1  6  7  1  1  6  8  0  )     >  >  >     1  6  )     /     2  5  5  .  0 F ;", "color . g    =     (  ( c    &     6  5  2  8  0  )     >  >  >     8  )     /     2  5  5  .  0 F ;", "color . r    =     ( c    &     2  5  5  )     /     2  5  5  .  0 F ;", "}", "METHOD_END"], "methodName": ["abgr8888ToColor"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    +  =    color . r ;", "this . g    +  =    color . g ;", "this . b    +  =    color . b ;", "this . a    +  =    color . a ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    +  =    r ;", "this . g    +  =    g ;", "this . b    +  =    b ;", "this . a    +  =    a ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( alpha    *     2  5  5  .  0 F )  )  ;", "}", "METHOD_END"], "methodName": ["alpha"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( int )     (  ( color . a )     *     2  5  5  )  )     <  <     2  4  )     |     (  (  ( int )     (  ( color . r )     *     2  5  5  )  )     <  <     1  6  )  )     |     (  (  ( int )     (  ( color . g )     *     2  5  5  )  )     <  <     8  )  )     |     (  ( int )     (  ( color . b )     *     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["argb8888"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( int )     ( a    *     2  5  5  )  )     <  <     2  4  )     |     (  (  ( int )     ( r    *     2  5  5  )  )     <  <     1  6  )  )     |     (  (  ( int )     ( g    *     2  5  5  )  )     <  <     8  )  )     |     (  ( int )     ( b    *     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["argb8888"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "color . a    =     (  ( value    &     -  1  6  7  7  7  2  1  6  )     >  >  >     2  4  )     /     2  5  5  .  0 F ;", "color . r    =     (  ( value    &     1  6  7  1  1  6  8  0  )     >  >  >     1  6  )     /     2  5  5  .  0 F ;", "color . g    =     (  ( value    &     6  5  2  8  0  )     >  >  >     8  )     /     2  5  5  .  0 F ;", "color . b    =     ( value    &     2  5  5  )     /     2  5  5  .  0 F ;", "}", "METHOD_END"], "methodName": ["argb8888ToColor"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "if    (  ( r )     <     0  )", "r    =     0  ;", "else", "if    (  ( r )     >     1  )", "r    =     1  ;", "if    (  ( g )     <     0  )", "g    =     0  ;", "else", "if    (  ( g )     >     1  )", "g    =     1  ;", "if    (  ( b )     <     0  )", "b    =     0  ;", "else", "if    (  ( b )     >     1  )", "b    =     1  ;", "if    (  ( a )     <     0  )", "a    =     0  ;", "else", "if    (  ( a )     >     1  )", "a    =     1  ;", "return   ts ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return   new   Color ( this )  ;", "}", "METHOD_END"], "methodName": ["cpy"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  ( h    /     6  0  .  0 F )     +     6  )     %     6  ;", "int   i    =     (  ( int )     ( x )  )  ;", "float   f    =    x    -    i ;", "float   p    =    v    *     (  1     -    s )  ;", "float   q    =    v    *     (  1     -     ( s    *    f )  )  ;", "float   t    =    v    *     (  1     -     ( s    *     (  1     -    f )  )  )  ;", "switch    ( i )     {", "case    0     :", "r    =    v ;", "g    =    t ;", "b    =    p ;", "break ;", "case    1     :", "r    =    q ;", "g    =    v ;", "b    =    p ;", "break ;", "case    2     :", "r    =    p ;", "g    =    v ;", "b    =    t ;", "break ;", "case    3     :", "r    =    p ;", "g    =    q ;", "b    =    v ;", "break ;", "case    4     :", "r    =    t ;", "g    =    p ;", "b    =    v ;", "break ;", "default    :", "r    =    v ;", "g    =    p ;", "b    =    q ;", "}", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["fromHsv"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return   fromHsv ( hsv [  0  ]  ,    hsv [  1  ]  ,    hsv [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["fromHsv"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    +  =    t    *     (  ( target . r )     -     ( this . r )  )  ;", "this . g    +  =    t    *     (  ( target . g )     -     ( this . g )  )  ;", "this . b    +  =    t    *     (  ( target . b )     -     ( this . b )  )  ;", "this . a    +  =    t    *     (  ( target . a )     -     ( this . a )  )  ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["lerp"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    +  =    t    *     ( r    -     ( this . r )  )  ;", "this . g    +  =    t    *     ( g    -     ( this . g )  )  ;", "this . b    +  =    t    *     ( b    -     ( this . b )  )  ;", "this . a    +  =    t    *     ( a    -     ( this . a )  )  ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["lerp"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( int )     ( luminance    *     2  5  5  .  0 F )  )     <  <     8  )     |     (  ( int )     ( alpha    *     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["luminanceAlpha"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    *  =    color . r ;", "this . g    *  =    color . g ;", "this . b    *  =    color . b ;", "this . a    *  =    color . a ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    *  =    value ;", "this . g    *  =    value ;", "this . b    *  =    value ;", "this . a    *  =    value ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    *  =    r ;", "this . g    *  =    g ;", "this . b    *  =    b ;", "this . a    *  =    a ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "r    *  =    a ;", "g    *  =    a ;", "b    *  =    a ;", "return   ts ;", "}", "METHOD_END"], "methodName": ["premultiplyAlpha"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( int )     (  ( color . r )     *     3  1  )  )     <  <     1  1  )     |     (  (  ( int )     (  ( color . g )     *     6  3  )  )     <  <     5  )  )     |     (  ( int )     (  ( color . b )     *     3  1  )  )  ;", "}", "METHOD_END"], "methodName": ["rgb565"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( int )     ( r    *     3  1  )  )     <  <     1  1  )     |     (  (  ( int )     ( g    *     6  3  )  )     <  <     5  )  )     |     (  ( int )     ( b    *     3  1  )  )  ;", "}", "METHOD_END"], "methodName": ["rgb565"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "color . r    =     (  ( value    &     6  3  4  8  8  )     >  >  >     1  1  )     /     3  1  .  0 F ;", "color . g    =     (  ( value    &     2  0  1  6  )     >  >  >     5  )     /     6  3  .  0 F ;", "color . b    =     (  ( value    &     3  1  )     >  >  >     0  )     /     3  1  .  0 F ;", "}", "METHOD_END"], "methodName": ["rgb565ToColor"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( int )     (  ( color . r )     *     2  5  5  )  )     <  <     1  6  )     |     (  (  ( int )     (  ( color . g )     *     2  5  5  )  )     <  <     8  )  )     |     (  ( int )     (  ( color . b )     *     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["rgb888"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( int )     ( r    *     2  5  5  )  )     <  <     1  6  )     |     (  (  ( int )     ( g    *     2  5  5  )  )     <  <     8  )  )     |     (  ( int )     ( b    *     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["rgb888"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "color . r    =     (  ( value    &     1  6  7  1  1  6  8  0  )     >  >  >     1  6  )     /     2  5  5  .  0 F ;", "color . g    =     (  ( value    &     6  5  2  8  0  )     >  >  >     8  )     /     2  5  5  .  0 F ;", "color . b    =     ( value    &     2  5  5  )     /     2  5  5  .  0 F ;", "}", "METHOD_END"], "methodName": ["rgb888ToColor"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( int )     (  ( color . r )     *     1  5  )  )     <  <     1  2  )     |     (  (  ( int )     (  ( color . g )     *     1  5  )  )     <  <     8  )  )     |     (  (  ( int )     (  ( color . b )     *     1  5  )  )     <  <     4  )  )     |     (  ( int )     (  ( color . a )     *     1  5  )  )  ;", "}", "METHOD_END"], "methodName": ["rgba4444"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( int )     ( r    *     1  5  )  )     <  <     1  2  )     |     (  (  ( int )     ( g    *     1  5  )  )     <  <     8  )  )     |     (  (  ( int )     ( b    *     1  5  )  )     <  <     4  )  )     |     (  ( int )     ( a    *     1  5  )  )  ;", "}", "METHOD_END"], "methodName": ["rgba4444"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "color . r    =     (  ( value    &     6  1  4  4  0  )     >  >  >     1  2  )     /     1  5  .  0 F ;", "color . g    =     (  ( value    &     3  8  4  0  )     >  >  >     8  )     /     1  5  .  0 F ;", "color . b    =     (  ( value    &     2  4  0  )     >  >  >     4  )     /     1  5  .  0 F ;", "color . a    =     ( value    &     1  5  )     /     1  5  .  0 F ;", "}", "METHOD_END"], "methodName": ["rgba4444ToColor"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( int )     (  ( color . r )     *     2  5  5  )  )     <  <     2  4  )     |     (  (  ( int )     (  ( color . g )     *     2  5  5  )  )     <  <     1  6  )  )     |     (  (  ( int )     (  ( color . b )     *     2  5  5  )  )     <  <     8  )  )     |     (  ( int )     (  ( color . a )     *     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["rgba8888"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( int )     ( r    *     2  5  5  )  )     <  <     2  4  )     |     (  (  ( int )     ( g    *     2  5  5  )  )     <  <     1  6  )  )     |     (  (  ( int )     ( b    *     2  5  5  )  )     <  <     8  )  )     |     (  ( int )     ( a    *     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["rgba8888"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "color . r    =     (  ( value    &     -  1  6  7  7  7  2  1  6  )     >  >  >     2  4  )     /     2  5  5  .  0 F ;", "color . g    =     (  ( value    &     1  6  7  1  1  6  8  0  )     >  >  >     1  6  )     /     2  5  5  .  0 F ;", "color . b    =     (  ( value    &     6  5  2  8  0  )     >  >  >     8  )     /     2  5  5  .  0 F ;", "color . a    =     ( value    &     2  5  5  )     /     2  5  5  .  0 F ;", "}", "METHOD_END"], "methodName": ["rgba8888ToColor"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    =    color . r ;", "this . g    =    color . g ;", "this . b    =    color . b ;", "this . a    =    color . a ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    =    r ;", "this . g    =    g ;", "this . b    =    b ;", "this . a    =    a ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "Color . rgba 8  8  8  8 ToColor ( this ,    rgba )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    -  =    color . r ;", "this . g    -  =    color . g ;", "this . b    -  =    color . b ;", "this . a    -  =    color . a ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "this . r    -  =    r ;", "this . g    -  =    g ;", "this . b    -  =    b ;", "this . a    -  =    a ;", "return   clamp (  )  ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "int   color    =     (  (  (  (  ( int )     (  2  5  5     *     ( a )  )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *     ( b )  )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *     ( g )  )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *     ( r )  )  )  ;", "return   NumberUtils . intToFloat ( color )  ;", "}", "METHOD_END"], "methodName": ["toFloatBits"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "int   color    =     (  (  (  (  ( int )     (  2  5  5     *    a )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *    b )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *    g )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *    r )  )  ;", "return   NumberUtils . intToFloat ( color )  ;", "}", "METHOD_END"], "methodName": ["toFloatBits"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "int   color    =     (  (  ( a    <  <     2  4  )     |     ( b    <  <     1  6  )  )     |     ( g    <  <     8  )  )     |    r ;", "float   float    =    NumberUtils . intToFloat ( color )  ;", "return   float ;", "}", "METHOD_END"], "methodName": ["toFloatBits"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "float   max    =    Math . max ( Math . max ( r ,    g )  ,    b )  ;", "float   min    =    Math . min ( Math . min ( r ,    g )  ,    b )  ;", "float   range    =    max    -    min ;", "if    ( range    =  =     0  )     {", "hsv [  0  ]     =     0  ;", "} else", "if    ( max    =  =     ( r )  )     {", "hsv [  0  ]     =     (  (  (  6  0     *     (  ( g )     -     ( b )  )  )     /    range )     +     3  6  0  )     %     3  6  0  ;", "} else", "if    ( max    =  =     ( g )  )     {", "hsv [  0  ]     =     (  (  6  0     *     (  ( b )     -     ( r )  )  )     /    range )     +     1  2  0  ;", "} else    {", "hsv [  0  ]     =     (  (  6  0     *     (  ( r )     -     ( g )  )  )     /    range )     +     2  4  0  ;", "}", "if    ( max    >     0  )     {", "hsv [  1  ]     =     1     -     ( min    /    max )  ;", "} else    {", "hsv [  1  ]     =     0  ;", "}", "hsv [  2  ]     =    max ;", "return   hsv ;", "}", "METHOD_END"], "methodName": ["toHsv"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "int   color    =     (  (  (  (  ( int )     (  2  5  5     *     ( a )  )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *     ( b )  )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *     ( g )  )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *     ( r )  )  )  ;", "return   color ;", "}", "METHOD_END"], "methodName": ["toIntBits"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( a    <  <     2  4  )     |     ( b    <  <     1  6  )  )     |     ( g    <  <     8  )  )     |    r ;", "}", "METHOD_END"], "methodName": ["toIntBits"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "String   value    =    Integer . toHexString (  (  (  (  (  (  ( int )     (  2  5  5     *     ( r )  )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *     ( g )  )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *     ( b )  )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *     ( a )  )  )  )  )  ;", "wle    (  ( value . length (  )  )     <     8  )", "value    =     \"  0  \"     +    value ;", "return   value ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "hex    =     (  ( hex . charAt (  0  )  )     =  =     '  #  '  )     ?    hex . substring (  1  )     :    hex ;", "int   r    =    Integer . valueOf ( hex . substring (  0  ,     2  )  ,     1  6  )  ;", "int   g    =    Integer . valueOf ( hex . substring (  2  ,     4  )  ,     1  6  )  ;", "int   b    =    Integer . valueOf ( hex . substring (  4  ,     6  )  ,     1  6  )  ;", "int   a    =     (  ( hex . length (  )  )     !  =     8  )     ?     2  5  5     :    Integer . valueOf ( hex . substring (  6  ,     8  )  ,     1  6  )  ;", "return   new    (  ( r    /     2  5  5  .  0 F )  ,     ( g    /     2  5  5  .  0 F )  ,     ( b    /     2  5  5  .  0 F )  ,     ( a    /     2  5  5  .  0 F )  )  ;", "}", "METHOD_END"], "methodName": ["valueOf"], "fileName": "com.badlogic.gdx.graphics.Color"}, {"methodBody": ["METHOD_START", "{", "return   Colors . map . get ( name )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.graphics.Colors"}, {"methodBody": ["METHOD_START", "{", "return   Colors . map ;", "}", "METHOD_END"], "methodName": ["getColors"], "fileName": "com.badlogic.gdx.graphics.Colors"}, {"methodBody": ["METHOD_START", "{", "return   Colors . map . put ( name ,    color )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.graphics.Colors"}, {"methodBody": ["METHOD_START", "{", "Colors . map . clear (  )  ;", "Colors . map . put (  \" CLEAR \"  ,    Color . CLEAR )  ;", "Colors . map . put (  \" BLACK \"  ,    Color . BLACK )  ;", "Colors . map . put (  \" WHITE \"  ,    Color . WHITE )  ;", "Colors . map . put (  \" LIGHT _ GRAY \"  ,    Color . LIGHT _ GRAY )  ;", "Colors . map . put (  \" GRAY \"  ,    Color . GRAY )  ;", "Colors . map . put (  \" DARK _ GRAY \"  ,    Color . DARK _ GRAY )  ;", "Colors . map . put (  \" BLUE \"  ,    Color . BLUE )  ;", "Colors . map . put (  \" NAVY \"  ,    Color . NAVY )  ;", "Colors . map . put (  \" ROYAL \"  ,    Color . ROYAL )  ;", "Colors . map . put (  \" SLATE \"  ,    Color . SLATE )  ;", "Colors . map . put (  \" SKY \"  ,    Color . SKY )  ;", "Colors . map . put (  \" CYAN \"  ,    Color . CYAN )  ;", "Colors . map . put (  \" TEAL \"  ,    Color . TEAL )  ;", "Colors . map . put (  \" GREEN \"  ,    Color . GREEN )  ;", "Colors . map . put (  \" CHARTREUSE \"  ,    Color . CHARTREUSE )  ;", "Colors . map . put (  \" LIME \"  ,    Color . LIME )  ;", "Colors . map . put (  \" FOREST \"  ,    Color . FOREST )  ;", "Colors . map . put (  \" OLIVE \"  ,    Color . OLIVE )  ;", "Colors . map . put (  \" YELLOW \"  ,    Color . YELLOW )  ;", "Colors . map . put (  \" GOLD \"  ,    Color . GOLD )  ;", "Colors . map . put (  \" GOLDENROD \"  ,    Color . GOLDENROD )  ;", "Colors . map . put (  \" ORANGE \"  ,    Color . ORANGE )  ;", "Colors . map . put (  \" BROWN \"  ,    Color . BROWN )  ;", "Colors . map . put (  \" TAN \"  ,    Color . TAN )  ;", "Colors . map . put (  \" FIREBRICK \"  ,    Color . FIREBRICK )  ;", "Colors . map . put (  \" RED \"  ,    Color . RED )  ;", "Colors . map . put (  \" SCARLET \"  ,    Color . SCARLET )  ;", "Colors . map . put (  \" CORAL \"  ,    Color . CORAL )  ;", "Colors . map . put (  \" SALMON \"  ,    Color . SALMON )  ;", "Colors . map . put (  \" PINK \"  ,    Color . PINK )  ;", "Colors . map . put (  \" MAGENTA \"  ,    Color . MAGENTA )  ;", "Colors . map . put (  \" PURPLE \"  ,    Color . PURPLE )  ;", "Colors . map . put (  \" VIOLET \"  ,    Color . VIOLET )  ;", "Colors . map . put (  \" MAROON \"  ,    Color . MAROON )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.Colors"}, {"methodBody": ["METHOD_START", "{", "Array < Cubemap >    managedCubemapArray    =    Cubemap . managedCubemaps . get ( app )  ;", "if    ( managedCubemapArray    =  =    null )", "managedCubemapArray    =    new   Array < Cubemap >  (  )  ;", "managedCubemapArray . add ( cubemap )  ;", "Cubemap . managedCubemaps . put ( app ,    managedCubemapArray )  ;", "}", "METHOD_END"], "methodName": ["addManagedCubemap"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "Cubemap . managedCubemaps . remove ( app )  ;", "}", "METHOD_END"], "methodName": ["clearAllCubemaps"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "return   data ;", "}", "METHOD_END"], "methodName": ["getCubemapData"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  \" Managed   cubemap / app :     {     \"  )  ;", "for    ( Application   app    :     . manageds . keySet (  )  )     {", "builder . append (  . manageds . get ( app )  . size )  ;", "builder . append (  \"     \"  )  ;", "}", "builder . append (  \"  }  \"  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getManagedStatus"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "return   Cubemap . managedCubemaps . get ( Gdx . app )  . size ;", "}", "METHOD_END"], "methodName": ["getNumManagedCubemaps"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "Array >    manageArray    =  . manages . get ( app )  ;", "if    ( manageArray    =  =    null )", "return ;", "if    (  . assetManager )     =  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( manageArray . size )  ;    i +  +  )     {", "cubemap    =    manageArray . get ( i )  ;", "cubemap . reload (  )  ;", "}", "} else    {", ". assetManager . finishLoading (  )  ;", "Array >    cubemaps    =    new   Array >  ( manageArray )  ;", "for      cubemap    :    cubemaps )     {", "String   fileName    =  . assetManager . getAssetFileName ( cubemap )  ;", "if    ( fileName    =  =    null )     {", "cubemap . reload (  )  ;", "} else    {", "final   int   refCount    =  . assetManager . getReferenceCount ( fileName )  ;", ". assetManager . setReferenceCount ( fileName ,     0  )  ;", "cubemap . glHandle    =     0  ;", "LoaderParameter   params    =    newLoaderParameter (  )  ;", "params . cubemapData    =    cubemap . geData (  )  ;", "params . minFilter    =    cubemap . getMinFilter (  )  ;", "params . magFilter    =    cubemap . getMagFilter (  )  ;", "params . wrapU    =    cubemap . getUWrap (  )  ;", "params . wrapV    =    cubemap . getVWrap (  )  ;", "params . cubemap    =    cubemap ;", "params . loadedCallback    =    new   AssetLoaderParameters . LoadedCallback (  )     {", "@ Override", "public   void   finishedLoading ( AssetManager   assetManager ,    String   fileName ,    Class   type )     {", "assetManager . setReferenceCount ( fileName ,    refCount )  ;", "}", "}  ;", ". assetManager . unload ( fileName )  ;", "cubemap . glHandle    =    Gdx . gl . glGenTexture (  )  ;", ". assetManager . load ( fileName ,  . class ,    params )  ;", "}", "}", "manageArray . clear (  )  ;", "manageArray . addAll ( cubemaps )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidateAllCubemaps"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( data . isPrepared (  )  )  )", "data . prepare (  )  ;", "bind (  )  ;", "unsafeSetFilter ( minFilter ,    magFilter ,    true )  ;", "unsafeSetWrap ( uWrap ,    vWrap ,    true )  ;", "data . consumeData (  )  ;", "Gdx . gl . glBindTexture ( glTarget ,     0  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "Cubemap . assetManager    =    manager ;", "}", "METHOD_END"], "methodName": ["setAssetManager"], "fileName": "com.badlogic.gdx.graphics.Cubemap"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( TimeUtils . nanoTime (  )  )     -     ( startTime )  )     >     1  0  0  0  0  0  0  0  0  0  )     {", "Gdx . app . log (  \" FPSLogger \"  ,     (  \" fps :     \"     +     ( GgetFramesPerSecond (  )  )  )  )  ;", "startTime    =    TimeUtils . nanoTime (  )  ;", "}", "}", "METHOD_END"], "methodName": ["log"], "fileName": "com.badlogic.gdx.graphics.FPSLogger"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glBindTexture ( glTarget ,    glHandle )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glActiveTexture (  (  ( GL 2  0  . GL _ TEXTURE 0  )     +    unit )  )  ;", "Gdx . gl . glBindTexture ( glTarget ,    glHandle )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( glHandle )     !  =     0  )     {", "Gdx . gl . glDelete ( glHandle )  ;", "glHandle    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "return   magFilter ;", "}", "METHOD_END"], "methodName": ["getMagFilter"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "return   minFilter ;", "}", "METHOD_END"], "methodName": ["getMinFilter"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "return   glHandle ;", "}", "METHOD_END"], "methodName": ["getTextureObjectHandle"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "return   uWrap ;", "}", "METHOD_END"], "methodName": ["getUWrap"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "return   vWrap ;", "}", "METHOD_END"], "methodName": ["getVWrap"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "this . minFilter    =    minFilter ;", "this . magFilter    =    magFilter ;", "bind (  )  ;", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ MIN _ FILTER ,    minFilter . getGLEnum (  )  )  ;", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ MAG _ FILTER ,    magFilter . getGLEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["setFilter"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "this . uWrap    =    u ;", "this . vWrap    =    v ;", "bind (  )  ;", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ WRAP _ S ,    u . getGLEnum (  )  )  ;", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ WRAP _ T ,    v . getGLEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["setWrap"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "unsafeSetFilter ( minFilter ,    magFilter ,    false )  ;", "}", "METHOD_END"], "methodName": ["unsafeSetFilter"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( minFilter    !  =    null )     &  &     ( force    |  |     (  ( this . minFilter )     !  =    minFilter )  )  )     {", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ MIN _ FILTER ,    minFilter . getGLEnum (  )  )  ;", "this . minFilter    =    minFilter ;", "}", "if    (  ( magFilter    !  =    null )     &  &     ( force    |  |     (  ( this . magFilter )     !  =    magFilter )  )  )     {", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ MAG _ FILTER ,    magFilter . getGLEnum (  )  )  ;", "this . magFilter    =    magFilter ;", "}", "}", "METHOD_END"], "methodName": ["unsafeSetFilter"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "unsafeSetWrap ( u ,    v ,    false )  ;", "}", "METHOD_END"], "methodName": ["unsafeSetWrap"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( u    !  =    null )     &  &     ( force    |  |     (  ( uWrap )     !  =    u )  )  )     {", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ WRAP _ S ,    u . getGLEnum (  )  )  ;", "uWrap    =    u ;", "}", "if    (  ( v    !  =    null )     &  &     ( force    |  |     (  ( vWrap )     !  =    v )  )  )     {", "Gl . glTexParameterf ( glTarget ,    GL 2  0  . GL _ TEXTURE _ WRAP _ T ,    v . getGLEnum (  )  )  ;", "vWrap    =    v ;", "}", "}", "METHOD_END"], "methodName": ["unsafeSetWrap"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "GLTexture . uploadImageData ( target ,    data ,     0  )  ;", "}", "METHOD_END"], "methodName": ["uploadImageData"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "if    ( data    =  =    null )     {", "return ;", "}", "if    (  !  ( data . isPrepared (  )  )  )", "data . prepare (  )  ;", "final   Data . DataType   type    =    data . getType (  )  ;", "if    ( type    =  =     ( Data . DataType . Custom )  )     {", "data . consumeCustomData ( target )  ;", "return ;", "}", "Pixmap   pixmap    =    data . consumePixmap (  )  ;", "boolean   disposePixmap    =    data . disposePixmap (  )  ;", "if    (  ( data . getFormat (  )  )     !  =     ( pixmap . getFormat (  )  )  )     {", "Pixmap   tmp    =    new   Pixmap ( pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    data . getFormat (  )  )  ;", "tmp . setBlending ( Pixmap . Blending . None )  ;", "tmp . drawPixmap ( pixmap ,     0  ,     0  ,     0  ,     0  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  )  ;", "if    ( data . disposePixmap (  )  )     {", "pixmap . dispose (  )  ;", "}", "pixmap    =    tmp ;", "disposePixmap    =    true ;", "}", "Gdx . gl . glPixelStorei ( GL 2  0  . GL _ UNPACK _ ALIGNMENT ,     1  )  ;", "if    ( data . useMipMaps (  )  )     {", "MipMapGenerator . generateMipMap ( target ,    pixmap ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  )  ;", "} else    {", "Gdx . gl . glTexImage 2 D ( target ,    miplevel ,    pixmap . getGLInternalFormat (  )  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,     0  ,    pixmap . getGLFormat (  )  ,    pixmap . getGLType (  )  ,    pixmap . getPixels (  )  )  ;", "}", "if    ( disposePixmap )", "pixmap . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["uploadImageData"], "fileName": "com.badlogic.gdx.graphics.GLTexture"}, {"methodBody": ["METHOD_START", "{", "Array < Mesh >    managedResources    =    Mesh . meshes . get ( app )  ;", "if    ( managedResources    =  =    null )", "managedResources    =    new   Array < Mesh >  (  )  ;", "managedResources . add ( mesh )  ;", "Mesh . meshes . put ( app ,    managedResources )  ;", "}", "METHOD_END"], "methodName": ["addManagedMesh"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "bind ( shader ,    null )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "vertices . bind ( shader ,    locations )  ;", "if    (  ( indices . getNumIndices (  )  )     >     0  )", "indices . bind (  )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "BoundingBox   bbox    =    new   BoundingBox (  )  ;", "calculateBoundingBox ( bbox )  ;", "return   bbox ;", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "final   int   numVertices    =    getNumVertices (  )  ;", "if    ( numVertices    =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" No   vertices   defined \"  )  ;", "final   FloatBuffer   verts    =    vertices . getBuffer (  )  ;", "bbox . inf (  )  ;", "final   VertexAttribute   posAttrib    =    getVertexAttribute ( VertexAttributes . Usage . Position )  ;", "final   int   offset    =     ( posAttrib . offset )     /     4  ;", "final   int   vertexSize    =     ( vertices . getAttributes (  )  . vertexSize )     /     4  ;", "int   idx    =    offset ;", "switch    ( posAttrib . numComponents )     {", "case    1     :", "for    ( int   i    =     0  ;    i    <    numVertices ;    i +  +  )     {", "bbox . ext ( verts . get ( idx )  ,     0  ,     0  )  ;", "idx    +  =    vertexSize ;", "}", "break ;", "case    2     :", "for    ( int   i    =     0  ;    i    <    numVertices ;    i +  +  )     {", "bbox . ext ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,     0  )  ;", "idx    +  =    vertexSize ;", "}", "break ;", "case    3     :", "for    ( int   i    =     0  ;    i    <    numVertices ;    i +  +  )     {", "bbox . ext ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,    verts . get (  ( idx    +     2  )  )  )  ;", "idx    +  =    vertexSize ;", "}", "break ;", "}", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   extendBoundingBox ( out . inf (  )  ,    offset ,    count )  ;", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   extendBoundingBox ( out . inf (  )  ,    offset ,    count ,    transform )  ;", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   calculateRadius ( center . x ,    center . y ,    center . z ,     0  ,    getNumIndices (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["calculateRadius"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   calculateRadius ( center . x ,    center . y ,    center . z ,    offset ,    count ,    null )  ;", "}", "METHOD_END"], "methodName": ["calculateRadius"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   calculateRadius ( center . x ,    center . y ,    center . z ,    offset ,    count ,    transform )  ;", "}", "METHOD_END"], "methodName": ["calculateRadius"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   calculateRadius ( centerX ,    centerY ,    centerZ ,     0  ,    getNumIndices (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["calculateRadius"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   calculateRadius ( centerX ,    centerY ,    centerZ ,    offset ,    count ,    null )  ;", "}", "METHOD_END"], "methodName": ["calculateRadius"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . sqrt ( calculateRadiusSquared ( centerX ,    centerY ,    centerZ ,    offset ,    count ,    transform )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["calculateRadius"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "int   numIndices    =    getNumIndices (  )  ;", "if    (  (  ( offset    <     0  )     |  |     ( count    <     1  )  )     |  |     (  ( offset    +    count )     >    numIndices )  )", "throw   new   utils . GdxRuntimeException (  \" Not   enough   indices \"  )  ;", "final   FloatBuffer   verts    =    vertices . getBuffer (  )  ;", "final   ShortBuffer   index    =    indices . getBuffer (  )  ;", "final   VertexAttribute   posAttrib    =    getVertexAttribute ( VertexAttributes . Usage . Position )  ;", "final   int   posoff    =     ( posAttrib . offset )     /     4  ;", "final   int   vertexSize    =     ( vertices . getAttributes (  )  . vertexSize )     /     4  ;", "final   int   end    =    offset    +    count ;", "float   result    =     0  ;", "switch    ( posAttrib . numComponents )     {", "case    1     :", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     (  ( index . get ( i )  )     *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,     0  ,     0  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "final   float   r    =    tmpV . sub ( centerX ,    centerY ,    centerZ )  . len 2  (  )  ;", "if    ( r    >    result )", "result    =    r ;", "}", "break ;", "case    2     :", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     (  ( index . get ( i )  )     *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,     0  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "final   float   r    =    tmpV . sub ( centerX ,    centerY ,    centerZ )  . len 2  (  )  ;", "if    ( r    >    result )", "result    =    r ;", "}", "break ;", "case    3     :", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     (  ( index . get ( i )  )     *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,    verts . get (  ( idx    +     2  )  )  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "final   float   r    =    tmpV . sub ( centerX ,    centerY ,    centerZ )  . len 2  (  )  ;", "if    ( r    >    result )", "result    =    r ;", "}", "break ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["calculateRadiusSquared"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "Mesh . meshes . remove ( app )  ;", "}", "METHOD_END"], "methodName": ["clearAllMeshes"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   copy ( isStatic ,    false ,    null )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "final   int   vertexSize    =     ( getVertexSize (  )  )     /     4  ;", "int   numVertices    =    getNumVertices (  )  ;", "float [  ]    vertices    =    new   float [ numVertices    *    vertexSize ]  ;", "getVertices (  0  ,    vertices . length ,    vertices )  ;", "short [  ]    checks    =    null ;", "VertexAttribute [  ]    attrs    =    null ;", "int   newVertexSize    =     0  ;", "if    ( usage    !  =    null )     {", "int   size    =     0  ;", "int   as    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( usage . length )  ;    i +  +  )", "if    (  ( getVertexAttribute ( usage [ i ]  )  )     !  =    null )     {", "size    +  =    getVertexAttribute ( usage [ i ]  )  . numComponents ;", "as +  +  ;", "}", "if    ( size    >     0  )     {", "attrs    =    new   VertexAttribute [ as ]  ;", "checks    =    new   short [ size ]  ;", "int   idx    =     -  1  ;", "int   ai    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     ( usage . length )  ;    i +  +  )     {", "VertexAttribute   a    =    getVertexAttribute ( usage [ i ]  )  ;", "if    ( a    =  =    null )", "continue ;", "for    ( int   j    =     0  ;    j    <     ( a . numComponents )  ;    j +  +  )", "checks [  (  +  + idx )  ]     =     (  ( short )     (  ( a . offset )     +    j )  )  ;", "attrs [  (  +  + ai )  ]     =    a . copy (  )  ;", "newVertexSize    +  =    a . numComponents ;", "}", "}", "}", "if    ( checks    =  =    null )     {", "checks    =    new   short [ vertexSize ]  ;", "for    ( short   i    =     0  ;    i    <    vertexSize ;    i +  +  )", "checks [ i ]     =    i ;", "newVertexSize    =    vertexSize ;", "}", "int   numIndices    =    getNumIndices (  )  ;", "short [  ]    indices    =    null ;", "if    ( numIndices    >     0  )     {", "indices    =    new   short [ numIndices ]  ;", "getIndices ( indices )  ;", "if    ( removeDuplicates    |  |     ( newVertexSize    !  =    vertexSize )  )     {", "float [  ]    tmp    =    new   float [ vertices . length ]  ;", "int   size    =     0  ;", "for    ( int   i    =     0  ;    i    <    numIndices ;    i +  +  )     {", "final   int   idx 1     =     ( indices [ i ]  )     *    vertexSize ;", "short   newIndex    =     -  1  ;", "if    ( removeDuplicates )     {", "for    ( short   j    =     0  ;     ( j    <    size )     &  &     ( newIndex    <     0  )  ;    j +  +  )     {", "final   int   idx 2     =    j    *    newVertexSize ;", "boolean   found    =    true ;", "for    ( int   k    =     0  ;     ( k    <     ( checks . length )  )     &  &    found ;    k +  +  )     {", "if    (  ( tmp [  ( idx 2     +    k )  ]  )     !  =     ( vertices [  ( idx 1     +     ( checks [ k ]  )  )  ]  )  )", "found    =    false ;", "}", "if    ( found )", "newIndex    =    j ;", "}", "}", "if    ( newIndex    >     0  )", "indices [ i ]     =    newIndex ;", "else    {", "final   int   idx    =    size    *    newVertexSize ;", "for    ( int   j    =     0  ;    j    <     ( checks . length )  ;    j +  +  )", "tmp [  ( idx    +    j )  ]     =    vertices [  ( idx 1     +     ( checks [ j ]  )  )  ]  ;", "indices [ i ]     =     (  ( short )     ( size )  )  ;", "size +  +  ;", "}", "}", "vertices    =    tmp ;", "numVertices    =    size ;", "}", "}", "result ;", "if    ( attrs    =  =    null )", "result    =    new    ( isStatic ,    numVertices ,     ( indices    =  =    null    ?     0     :    indices . length )  ,    getVertexAttributes (  )  )  ;", "else", "result    =    new    ( isStatic ,    numVertices ,     ( indices    =  =    null    ?     0     :    indices . length )  ,    attrs )  ;", "result . setVertices ( vertices ,     0  ,     ( numVertices    *    newVertexSize )  )  ;", "if    ( indices    !  =    null )", "result . setIndices ( indices )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Mesh . meshes . get ( Gdx . app )  )     !  =    null )", "Mesh . meshes . get ( Gdx . app )  . removeValue ( this ,    true )  ;", "vertices . dispose (  )  ;", "indices . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   extendBoundingBox ( out ,    offset ,    count ,    null )  ;", "}", "METHOD_END"], "methodName": ["extendBoundingBox"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "final   int   numIndices    =    getNumIndices (  )  ;", "final   int   numVertices    =    getNumVertices (  )  ;", "final   int   max    =     ( numIndices    =  =     0  )     ?    numVertices    :    numIndices ;", "if    (  (  ( offset    <     0  )     |  |     ( count    <     1  )  )     |  |     (  ( offset    +    count )     >    max )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  (  (  \" Invalid   part   specified    (    offset =  \"     +    offset )     +     \"  ,    count =  \"  )     +    count )     +     \"  ,    max =  \"  )     +    max )     +     \"     )  \"  )  )  ;", "final   FloatBuffer   verts    =    vertices . getBuffer (  )  ;", "final   ShortBuffer   index    =    indices . getBuffer (  )  ;", "final   VertexAttribute   posAttrib    =    getVertexAttribute ( VertexAttributes . Usage . Position )  ;", "final   int   posoff    =     ( posAttrib . offset )     /     4  ;", "final   int   vertexSize    =     ( vertices . getAttributes (  )  . vertexSize )     /     4  ;", "final   int   end    =    offset    +    count ;", "switch    ( posAttrib . numComponents )     {", "case    1     :", "if    ( numIndices    >     0  )     {", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     (  ( index . get ( i )  )     *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,     0  ,     0  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "out . ext ( tmpV )  ;", "}", "} else    {", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     ( i    *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,     0  ,     0  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "out . ext ( tmpV )  ;", "}", "}", "break ;", "case    2     :", "if    ( numIndices    >     0  )     {", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     (  ( index . get ( i )  )     *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,     0  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "out . ext ( tmpV )  ;", "}", "} else    {", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     ( i    *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,     0  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "out . ext ( tmpV )  ;", "}", "}", "break ;", "case    3     :", "if    ( numIndices    >     0  )     {", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     (  ( index . get ( i )  )     *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,    verts . get (  ( idx    +     2  )  )  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "out . ext ( tmpV )  ;", "}", "} else    {", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "final   int   idx    =     ( i    *    vertexSize )     +    posoff ;", "tmpV . set ( verts . get ( idx )  ,    verts . get (  ( idx    +     1  )  )  ,    verts . get (  ( idx    +     2  )  )  )  ;", "if    ( transform    !  =    null )", "tmpV . mul ( transform )  ;", "out . ext ( tmpV )  ;", "}", "}", "break ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["extendBoundingBox"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "int   max    =    getNumIndices (  )  ;", "if    ( count    <     0  )", "count    =    max    -    srcOffset ;", "if    (  (  ( srcOffset    <     0  )     |  |     ( srcOffset    >  =    max )  )     |  |     (  ( srcOffset    +    count )     >    max )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Invalid   range   specified ,    offset :     \"     +    srcOffset )     +     \"  ,    count :     \"  )     +    count )     +     \"  ,    max :     \"  )     +    max )  )  ;", "if    (  (  ( indices . length )     -    destOffset )     <    count )", "throw   new   IllegalArgumentException (  (  (  (  \" not   enough   room   in   indices   array ,    has    \"     +     ( indices . length )  )     +     \"    shorts ,    needs    \"  )     +    count )  )  ;", "int   pos    =    getIndicesBuffer (  )  . position (  )  ;", "getIndicesBuffer (  )  . position ( srcOffset )  ;", "getIndicesBuffer (  )  . get ( indices ,    destOffset ,    count )  ;", "getIndicesBuffer (  )  . position ( pos )  ;", "}", "METHOD_END"], "methodName": ["getIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "getIndices ( srcOffset ,     (  -  1  )  ,    indices ,    destOffset )  ;", "}", "METHOD_END"], "methodName": ["getIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "getIndices ( indices ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "getIndices (  0  ,    indices ,    destOffset )  ;", "}", "METHOD_END"], "methodName": ["getIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   indices . getBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getIndicesBuffer"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "int   i    =     0  ;", "builder . append (  \" Managed   meshes / app :     {     \"  )  ;", "for    ( Application   app    :     . meshes . keySet (  )  )     {", "builder . append (  . meshes . get ( app )  . size )  ;", "builder . append (  \"     \"  )  ;", "}", "builder . append (  \"  }  \"  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getManagedStatus"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   indices . getNumMaxIndices (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   vertices . getNumMaxVertices (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   indices . getNumIndices (  )  ;", "}", "METHOD_END"], "methodName": ["getNumIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   vertices . getNumVertices (  )  ;", "}", "METHOD_END"], "methodName": ["getNumVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "VertexAttributes   attributes    =    vertices . getAttributes (  )  ;", "int   len    =    attributes . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "if    (  ( attributes . get ( i )  . usage )     =  =    usage )", "return   attributes . get ( i )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   vertices . getAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["getVertexAttributes"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   vertices . getAttributes (  )  . vertexSize ;", "}", "METHOD_END"], "methodName": ["getVertexSize"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   getVertices (  0  ,     (  -  1  )  ,    vertices )  ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   getVertices ( srcOffset ,     (  -  1  )  ,    vertices )  ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   getVertices ( srcOffset ,    count ,    vertices ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "final   int   max    =     (  ( getNumVertices (  )  )     *     ( getVertexSize (  )  )  )     /     4  ;", "if    ( count    =  =     (  -  1  )  )     {", "count    =    max    -    srcOffset ;", "if    ( count    >     (  ( vertices . length )     -    destOffset )  )", "count    =     ( vertices . length )     -    destOffset ;", "}", "if    (  (  (  (  ( srcOffset    <     0  )     |  |     ( count    <  =     0  )  )     |  |     (  ( srcOffset    +    count )     >    max )  )     |  |     ( destOffset    <     0  )  )     |  |     ( destOffset    >  =     ( vertices . length )  )  )", "throw   new   IndexOutOfBoundsException (  )  ;", "if    (  (  ( vertices . length )     -    destOffset )     <    count )", "throw   new   IllegalArgumentException (  (  (  (  \" not   enough   room   in   vertices   array ,    has    \"     +     ( vertices . length )  )     +     \"    floats ,    needs    \"  )     +    count )  )  ;", "int   pos    =    getVerticesBuffer (  )  . position (  )  ;", "getVerticesBuffer (  )  . position ( srcOffset )  ;", "getVerticesBuffer (  )  . get ( vertices ,    destOffset ,    count )  ;", "getVerticesBuffer (  )  . position ( pos )  ;", "return   vertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   vertices . getBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getVerticesBuffer"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "Array < Mesh >    meshesArray    =    Mesh . meshes . get ( app )  ;", "if    ( meshesArray    =  =    null )", "return ;", "for    ( int   i    =     0  ;    i    <     ( meshesArray . size )  ;    i +  +  )     {", "meshesArray . get ( i )  . vertices . invalidate (  )  ;", "meshesArray . get ( i )  . indices . invalidate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidateAllMeshes"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Gdx . gl 3  0  )     !  =    null )     {", "return   new   VertexBufferObjectWithVAO ( isStatic ,    maxVertices ,    vertexAttributes )  ;", "} else    {", "return   new   VertexBufferObject ( isStatic ,    maxVertices ,    vertexAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["makeVertexBuffer"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "render ( shader ,    primitiveType ,     0  ,     (  ( indices . getNumMaxIndices (  )  )     >     0     ?    getNumIndices (  )     :    getNumVertices (  )  )  ,    autoBind )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "render ( shader ,    primitiveType ,    offset ,    count ,    autoBind )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "if    ( count    =  =     0  )", "return ;", "if    ( autoBind )", "bind ( shader )  ;", "if    ( isVertexArray )     {", "if    (  ( indices . getNumIndices (  )  )     >     0  )     {", "ShortBuffer   buffer    =    indices . getBuffer (  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "int   oldLimit    =    buffer . limit (  )  ;", "buffer . position ( offset )  ;", "buffer . limit (  ( offset    +    count )  )  ;", "Gl 2  0  . glDrawElements ( primitiveType ,    count ,    GL 2  0  . GL _ UNSIGNED _ SHORT ,    buffer )  ;", "buffer . position ( oldPosition )  ;", "buffer . limit ( oldLimit )  ;", "} else    {", "Gl 2  0  . glDrawArrays ( primitiveType ,    offset ,    count )  ;", "}", "} else    {", "if    (  ( indices . getNumIndices (  )  )     >     0  )     {", "if    (  ( count    +    offset )     >     ( indices . getNumMaxIndices (  )  )  )     {", "throw   new   GdxRuntimeException (  (  (  (  (  (  (  \" Mesh   attempting   to   access   memory   outside   of   the   index   buffer    ( count :     \"     +    count )     +     \"  ,    offset :     \"  )     +    offset )     +     \"  ,    max :     \"  )     +     ( indices . getNumMaxIndices (  )  )  )     +     \"  )  \"  )  )  ;", "}", "Gl 2  0  . glDrawElements ( primitiveType ,    count ,    GL 2  0  . GL _ UNSIGNED _ SHORT ,     ( offset    *     2  )  )  ;", "} else    {", "Gl 2  0  . glDrawArrays ( primitiveType ,    offset ,    count )  ;", "}", "}", "if    ( autoBind )", "unbind ( shader )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "final   VertexAttribute   posAttr    =    getVertexAttribute ( VertexAttributes . Usage . Position )  ;", "final   int   offset    =     ( posAttr . offset )     /     4  ;", "final   int   numComponents    =    posAttr . numComponents ;", "final   int   numVertices    =    getNumVertices (  )  ;", "final   int   vertexSize    =     ( getVertexSize (  )  )     /     4  ;", "final   float [  ]    vertices    =    new   float [ numVertices    *    vertexSize ]  ;", "getVertices ( vertices )  ;", "int   idx    =    offset ;", "switch    ( numComponents )     {", "case    1     :", "for    ( int   i    =     0  ;    i    <    numVertices ;    i +  +  )     {", "vertices [ idx ]     *  =    scaleX ;", "idx    +  =    vertexSize ;", "}", "break ;", "case    2     :", "for    ( int   i    =     0  ;    i    <    numVertices ;    i +  +  )     {", "vertices [ idx ]     *  =    scaleX ;", "vertices [  ( idx    +     1  )  ]     *  =    scaleY ;", "idx    +  =    vertexSize ;", "}", "break ;", "case    3     :", "for    ( int   i    =     0  ;    i    <    numVertices ;    i +  +  )     {", "vertices [ idx ]     *  =    scaleX ;", "vertices [  ( idx    +     1  )  ]     *  =    scaleY ;", "vertices [  ( idx    +     2  )  ]     *  =    scaleZ ;", "idx    +  =    vertexSize ;", "}", "break ;", "}", "setVertices ( vertices )  ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "this . autoBind    =    autoBind ;", "}", "METHOD_END"], "methodName": ["setAutoBind"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "this . indices . setIndices ( indices ,     0  ,    indices . length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "this . indices . setIndices ( indices ,    offset ,    count )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "this . vertices . setVertices ( vertices ,     0  ,    vertices . length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "this . vertices . setVertices ( vertices ,    offset ,    count )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "transform ( matrix ,     0  ,    getNumVertices (  )  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( offset    <     0  )     |  |     ( dimensions    <     1  )  )     |  |     (  ( offset    +    dimensions )     >    vertexSize )  )", "throw   new   IndexOutOfBoundsException (  )  ;", "if    (  (  ( start    <     0  )     |  |     ( unt    <     1  )  )     |  |     (  (  ( start    +    unt )     *    vertexSize )     >     ( vertices . length )  )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  (  (  (  (  \" start    =     \"     +    start )     +     \"  ,    unt    =     \"  )     +    unt )     +     \"  ,    vertexSize    =     \"  )     +    vertexSize )     +     \"  ,    length    =     \"  )     +     ( vertices . length )  )  )  ;", "final   Vector 3    tmp    =    new   Vector 3  (  )  ;", "int   idx    =    offset    +     ( start    *    vertexSize )  ;", "switch    ( dimensions )     {", "case    1     :", "for    ( int   i    =     0  ;    i    <    unt ;    i +  +  )     {", "tmp . set ( vertices [ idx ]  ,     0  ,     0  )  . mul ( matrix )  ;", "vertices [ idx ]     =    tmp . x ;", "idx    +  =    vertexSize ;", "}", "break ;", "case    2     :", "for    ( int   i    =     0  ;    i    <    unt ;    i +  +  )     {", "tmp . set ( vertices [ idx ]  ,    vertices [  ( idx    +     1  )  ]  ,     0  )  . mul ( matrix )  ;", "vertices [ idx ]     =    tmp . x ;", "vertices [  ( idx    +     1  )  ]     =    tmp . y ;", "idx    +  =    vertexSize ;", "}", "break ;", "case    3     :", "for    ( int   i    =     0  ;    i    <    unt ;    i +  +  )     {", "tmp . set ( vertices [ idx ]  ,    vertices [  ( idx    +     1  )  ]  ,    vertices [  ( idx    +     2  )  ]  )  . mul ( matrix )  ;", "vertices [ idx ]     =    tmp . x ;", "vertices [  ( idx    +     1  )  ]     =    tmp . y ;", "vertices [  ( idx    +     2  )  ]     =    tmp . z ;", "idx    +  =    vertexSize ;", "}", "break ;", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "final   VertexAttribute   posAttr    =    getVertexAttribute ( VertexAttributes . Usage . Position )  ;", "final   int   posOffset    =     ( posAttr . offset )     /     4  ;", "final   int   stride    =     ( getVertexSize (  )  )     /     4  ;", "final   int   numComponents    =    posAttr . numComponents ;", "final   int   numVertices    =    getNumVertices (  )  ;", "final   float [  ]    vertices    =    new   float [ count    *    stride ]  ;", "getVertices (  ( start    *    stride )  ,     ( count    *    stride )  ,    vertices )  ;", ". transform ( matrix ,    vertices ,    stride ,    posOffset ,    numComponents ,     0  ,    count )  ;", "updateVertices (  ( start    *    stride )  ,    vertices )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "transformUV ( matrix ,     0  ,    getNumVertices (  )  )  ;", "}", "METHOD_END"], "methodName": ["transformUV"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( start    <     0  )     |  |     ( count    <     1  )  )     |  |     (  (  ( start    +    count )     *    vertexSize )     >     ( vertices . length )  )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  (  (  (  (  \" start    =     \"     +    start )     +     \"  ,    count    =     \"  )     +    count )     +     \"  ,    vertexSize    =     \"  )     +    vertexSize )     +     \"  ,    length    =     \"  )     +     ( vertices . length )  )  )  ;", "final   Vector 2    tmp    =    new   Vector 2  (  )  ;", "int   idx    =    offset    +     ( start    *    vertexSize )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "tmp . set ( vertices [ idx ]  ,    vertices [  ( idx    +     1  )  ]  )  . mul ( matrix )  ;", "vertices [ idx ]     =    tmp . x ;", "vertices [  ( idx    +     1  )  ]     =    tmp . y ;", "idx    +  =    vertexSize ;", "}", "}", "METHOD_END"], "methodName": ["transformUV"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "final   VertexAttribute   posAttr    =    getVertexAttribute ( VertexAttributes . Usage . TextureCoordinates )  ;", "final   int   offset    =     ( posAttr . offset )     /     4  ;", "final   int   vertexSize    =     ( getVertexSize (  )  )     /     4  ;", "final   int   numVertices    =    getNumVertices (  )  ;", "final   float [  ]    vertices    =    new   float [ numVertices    *    vertexSize ]  ;", "getVertices (  0  ,    vertices . length ,    vertices )  ;", ". transformUV ( matrix ,    vertices ,    vertexSize ,    offset ,    start ,    count )  ;", "setVertices ( vertices ,     0  ,    vertices . length )  ;", "}", "METHOD_END"], "methodName": ["transformUV"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "unbind ( shader ,    null )  ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "vertices . unbind ( shader ,    locations )  ;", "if    (  ( indices . getNumIndices (  )  )     >     0  )", "indices . unbind (  )  ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "return   updateVertices ( targetOffset ,    source ,     0  ,    source . length )  ;", "}", "METHOD_END"], "methodName": ["updateVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "this . vertices . updateVertices ( targetOffset ,    source ,    sourceOffset ,    count )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["updateVertices"], "fileName": "com.badlogic.gdx.graphics.Mesh"}, {"methodBody": ["METHOD_START", "{", "rotate ( direction ,    angle )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.OrthographicCamera"}, {"methodBody": ["METHOD_START", "{", "setToOrtho ( yDown ,    Gdx . graphics . getWidth (  )  ,    Gdx . graphics . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["setToOrtho"], "fileName": "com.badlogic.gdx.graphics.OrthographicCamera"}, {"methodBody": ["METHOD_START", "{", "if    ( yDown )     {", "up . set (  0  ,     (  -  1  )  ,     0  )  ;", "direction . set (  0  ,     0  ,     1  )  ;", "} else    {", "up . set (  0  ,     1  ,     0  )  ;", "direction . set (  0  ,     0  ,     (  -  1  )  )  ;", "}", "position . set (  (  (  ( zo )     *    viewportWidth )     /     2  .  0 F )  ,     (  (  ( zo )     *    viewportHeight )     /     2  .  0 F )  ,     0  )  ;", "this . viewportWidth    =    viewportWidth ;", "this . viewportHeight    =    viewportHeight ;", "update (  )  ;", "}", "METHOD_END"], "methodName": ["setToOrtho"], "fileName": "com.badlogic.gdx.graphics.OrthographicCamera"}, {"methodBody": ["METHOD_START", "{", "translate ( vec . x ,    vec . y ,     0  )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.OrthographicCamera"}, {"methodBody": ["METHOD_START", "{", "translate ( x ,    y ,     0  )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.OrthographicCamera"}, {"methodBody": ["METHOD_START", "{", "if    ( disposed )", "throw   new   utils . GdxRuntimeException (  \" Pixmap   already   disposed !  \"  )  ;", "pixmap . dispose (  )  ;", "disposed    =    true ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . drawCircle ( x ,    y ,    radius ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawCircle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . drawLine ( x ,    y ,    x 2  ,    y 2  ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawLine"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . setPixel ( x ,    y ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawPixel"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . setPixel ( x ,    y ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawPixel"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "drawPixmap ( pixmap ,    x ,    y ,     0  ,     0  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . pixmap . drawPixmap ( pixmap . pixmap ,    srcx ,    srcy ,    x ,    y ,    srcWidth ,    srcHeight )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . pixmap . drawPixmap ( pixmap . pixmap ,    srcx ,    srcy ,    srcWidth ,    srcHeight ,    dstx ,    dsty ,    dstWidth ,    dstHeight )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . drawRect ( x ,    y ,    width ,    height ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawRectangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . clear ( color )  ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . fillCircle ( x ,    y ,    radius ,    color )  ;", "}", "METHOD_END"], "methodName": ["fillCircle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . fillRect ( x ,    y ,    width ,    height ,    color )  ;", "}", "METHOD_END"], "methodName": ["fillRectangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "pixmap . fillTriangle ( x 1  ,    y 1  ,    x 2  ,    y 2  ,    x 3  ,    y 3  ,    color )  ;", "}", "METHOD_END"], "methodName": ["fillTriangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   blending ;", "}", "METHOD_END"], "methodName": ["getBlending"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   filter ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   Pixmap . Format . fromGdx 2 DPixmapFormat ( pixmap . getFormat (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFormat"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   pixmap . getGLFormat (  )  ;", "}", "METHOD_END"], "methodName": ["getGLFormat"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   pixmap . getGLInternalFormat (  )  ;", "}", "METHOD_END"], "methodName": ["getGLInternalFormat"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   pixmap . getGLType (  )  ;", "}", "METHOD_END"], "methodName": ["getGLType"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   pixmap . getHeight (  )  ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   pixmap . getPixel ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["getPixel"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "if    ( disposed )", "throw   new   utils . GdxRuntimeException (  \" Pixmap   already   disposed \"  )  ;", "return   pixmap . getPixels (  )  ;", "}", "METHOD_END"], "methodName": ["getPixels"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   pixmap . getWidth (  )  ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . blending    =    blending ;", "pixmap . setBlend (  ( blending    =  =     (  . Blending . None )     ?     0     :     1  )  )  ;", "}", "METHOD_END"], "methodName": ["setBlending"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . color    =    Color . rgba 8  8  8  8  ( color . r ,    color . g ,    color . b ,    color . a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "color    =    Color . rgba 8  8  8  8  ( r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . filter    =    filter ;", "pixmap . setScale (  ( filter    =  =     (  . Filter . NearestNeighbour )     ?    Gdx 2 D . GDX 2 D _ SCALE _ NEAREST    :    Gdx 2 D . GDX 2 D _ SCALE _ LINEAR )  )  ;", "}", "METHOD_END"], "methodName": ["setFilter"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   PixmapIO . CIM . read ( file )  ;", "}", "METHOD_END"], "methodName": ["readCIM"], "fileName": "com.badlogic.gdx.graphics.PixmapIO"}, {"methodBody": ["METHOD_START", "{", "PixmapIO . CIM . write ( file ,    pixmap )  ;", "}", "METHOD_END"], "methodName": ["writeCIM"], "fileName": "com.badlogic.gdx.graphics.PixmapIO"}, {"methodBody": ["METHOD_START", "{", "try    {", ". PNG   writer    =    new    . PNG (  (  ( int )     (  (  ( pixmap . getWidth (  )  )     *     ( pixmap . getHeight (  )  )  )     *     1  .  5 F )  )  )  ;", "try    {", "writer . setFlipY ( false )  ;", "writer . write ( file ,    pixmap )  ;", "}    finally    {", "writer . dispose (  )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   writing   PNG :     \"     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writePNG"], "fileName": "com.badlogic.gdx.graphics.PixmapIO"}, {"methodBody": ["METHOD_START", "{", "Array < Texture >    managedTextureArray    =    Texture . managedTextures . get ( app )  ;", "if    ( managedTextureArray    =  =    null )", "managedTextureArray    =    new   Array < Texture >  (  )  ;", "managedTextureArray . add ( texture )  ;", "Texture . managedTextures . put ( app ,    managedTextureArray )  ;", "}", "METHOD_END"], "methodName": ["addManagedTexture"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "Texture . managedTextures . remove ( app )  ;", "}", "METHOD_END"], "methodName": ["clearAllTextures"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( glHandle )     =  =     0  )", "return ;", "delete (  )  ;", "if    ( data . isManaged (  )  )", "if    (  ( Texture . managedTextures . get ( Gdx . app )  )     !  =    null )", "Texture . managedTextures . get ( Gdx . app )  . removeValue ( this ,    true )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "if    ( data . isManaged (  )  )", "throw   new   utils . GdxRuntimeException (  \" can ' t   draw   to   a   managed   texture \"  )  ;", "bind (  )  ;", "Gdx . gl . glTexSubImage 2 D ( glTarget ,     0  ,    x ,    y ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    pixmap . getGLFormat (  )  ,    pixmap . getGLType (  )  ,    pixmap . getPixels (  )  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  \" Managed   textures / app :     {     \"  )  ;", "for    ( Application   app    :     . manageds . keySet (  )  )     {", "builder . append (  . manageds . get ( app )  . size )  ;", "builder . append (  \"     \"  )  ;", "}", "builder . append (  \"  }  \"  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getManagedStatus"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "return   Texture . managedTextures . get ( Gdx . app )  . size ;", "}", "METHOD_END"], "methodName": ["getNumManagedTextures"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "return   data ;", "}", "METHOD_END"], "methodName": ["getTextureData"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "Array >    manageArray    =  . manages . get ( app )  ;", "if    ( manageArray    =  =    null )", "return ;", "if    (  . assetManager )     =  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( manageArray . size )  ;    i +  +  )     {", "texture    =    manageArray . get ( i )  ;", "texture . reload (  )  ;", "}", "} else    {", ". assetManager . finishLoading (  )  ;", "Array >    textures    =    new   Array >  ( manageArray )  ;", "for      texture    :    textures )     {", "String   fileName    =  . assetManager . getAssetFileName ( texture )  ;", "if    ( fileName    =  =    null )     {", "texture . reload (  )  ;", "} else    {", "final   int   refCount    =  . assetManager . getReferenceCount ( fileName )  ;", ". assetManager . setReferenceCount ( fileName ,     0  )  ;", "texture . glHandle    =     0  ;", "LoaderParameter   params    =    newLoaderParameter (  )  ;", "params . textureData    =    texture . geData (  )  ;", "params . minFilter    =    texture . getMinFilter (  )  ;", "params . magFilter    =    texture . getMagFilter (  )  ;", "params . wrapU    =    texture . getUWrap (  )  ;", "params . wrapV    =    texture . getVWrap (  )  ;", "params . genMipMaps    =    texture . data . useMipMaps (  )  ;", "params . texture    =    texture ;", "params . loadedCallback    =    new   AssetLoaderParameters . LoadedCallback (  )     {", "@ Override", "public   void   finishedLoading ( AssetManager   assetManager ,    String   fileName ,    Class   type )     {", "assetManager . setReferenceCount ( fileName ,    refCount )  ;", "}", "}  ;", ". assetManager . unload ( fileName )  ;", "texture . glHandle    =    Gdx . gl . glGe (  )  ;", ". assetManager . load ( fileName ,  . class ,    params )  ;", "}", "}", "manageArray . clear (  )  ;", "manageArray . addAll ( textures )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidateAllTextures"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "return   data . isManaged (  )  ;", "}", "METHOD_END"], "methodName": ["isManaged"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . data )     !  =    null )     &  &     (  ( data . isManaged (  )  )     !  =     ( this . data . isManaged (  )  )  )  )", "throw   new   utils . GdxRuntimeException (  \" New   data   must   have   the   same   managed   status   as   the   old   data \"  )  ;", "this . data    =    data ;", "if    (  !  ( data . isPrepared (  )  )  )", "data . prepare (  )  ;", "bind (  )  ;", "GLTexture . uploadImageData ( GL 2  0  . GL _ TEXTURE _  2 D ,    data )  ;", "unsafeSetFilter ( minFilter ,    magFilter ,    true )  ;", "unsafeSetWrap ( uWrap ,    vWrap ,    true )  ;", "Gdx . gl . glBindTexture ( glTarget ,     0  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "Texture . assetManager    =    manager ;", "}", "METHOD_END"], "methodName": ["setAssetManager"], "fileName": "com.badlogic.gdx.graphics.Texture"}, {"methodBody": ["METHOD_START", "{", "Array < TextureArray >    managedTextureArray    =    TextureArray . managedTextureArrays . get ( app )  ;", "if    ( managedTextureArray    =  =    null )", "managedTextureArray    =    new   Array < TextureArray >  (  )  ;", "managedTextureArray . add ( texture )  ;", "TextureArray . managedTextureArrays . put ( app ,    managedTextureArray )  ;", "}", "METHOD_END"], "methodName": ["addManagedTexture"], "fileName": "com.badlogic.gdx.graphics.TextureArray"}, {"methodBody": ["METHOD_START", "{", "TextureArray . managedTextureArrays . remove ( app )  ;", "}", "METHOD_END"], "methodName": ["clearAllTextureArrays"], "fileName": "com.badlogic.gdx.graphics.TextureArray"}, {"methodBody": ["METHOD_START", "{", "FileHandle [  ]    handles    =    new   FileHandle [ internalPaths . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( internalPaths . length )  ;    i +  +  )     {", "handles [ i ]     =    Gfiles . internal ( internalPaths [ i ]  )  ;", "}", "return   handles ;", "}", "METHOD_END"], "methodName": ["getInternalHandles"], "fileName": "com.badlogic.gdx.graphics.TextureArray"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  \" Managed   s / app :     {     \"  )  ;", "for    ( Application   app    :     . manageds . keySet (  )  )     {", "builder . append (  . manageds . get ( app )  . size )  ;", "builder . append (  \"     \"  )  ;", "}", "builder . append (  \"  }  \"  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getManagedStatus"], "fileName": "com.badlogic.gdx.graphics.TextureArray"}, {"methodBody": ["METHOD_START", "{", "return   TextureArray . managedTextureArrays . get ( Gdx . app )  . size ;", "}", "METHOD_END"], "methodName": ["getNumManagedTextureArrays"], "fileName": "com.badlogic.gdx.graphics.TextureArray"}, {"methodBody": ["METHOD_START", "{", "Array < TextureArray >    managedTextureArray    =    TextureArray . managedTextureArrays . get ( app )  ;", "if    ( managedTextureArray    =  =    null )", "return ;", "for    ( int   i    =     0  ;    i    <     ( managedTextureArray . size )  ;    i +  +  )     {", "TextureArray   textureArray    =    managedTextureArray . get ( i )  ;", "textureArray . reload (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidateAllTextureArrays"], "fileName": "com.badlogic.gdx.graphics.TextureArray"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . data )     !  =    null )     &  &     (  ( data . isManaged (  )  )     !  =     ( this . data . isManaged (  )  )  )  )", "throw   new   utils . GdxRuntimeException (  \" New   data   must   have   the   same   managed   status   as   the   old   data \"  )  ;", "this . data    =    data ;", "bind (  )  ;", "Gdx . gl 3  0  . glTexImage 3 D ( GL 3  0  . GL _ TEXTURE _  2 D _ ARRAY ,     0  ,    data . getInternalFormat (  )  ,    data . getWidth (  )  ,    data . getHeight (  )  ,    data . getDepth (  )  ,     0  ,    data . getInternalFormat (  )  ,    data . getGLType (  )  ,    null )  ;", "if    (  !  ( data . isPrepared (  )  )  )", "data . prepare (  )  ;", "data . consumeTextureArrayData (  )  ;", "setFilter ( minFilter ,    magFilter )  ;", "setWrap ( uWrap ,    vWrap )  ;", "Gdx . gl . glBindTexture ( glTarget ,     0  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.TextureArray"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . BiNormal ,     3  ,    ShaderProgram . BINORMAL _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["Binormal"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . BoneWeight ,     2  ,     (  ( ShaderProgram . BONEWEIGHT _ ATTRIBUTE )     +    unit )  ,    unit )  ;", "}", "METHOD_END"], "methodName": ["BoneWeight"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . ColorPacked ,     4  ,    GL 2  0  . GL _ UNSIGNED _ BYTE ,    true ,    ShaderProgram . COLOR _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["ColorPacked"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . ColorUnpacked ,     4  ,    GL 2  0  . GL _ FLOAT ,    false ,    ShaderProgram . COLOR _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["ColorUnpacked"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . Normal ,     3  ,    ShaderProgram . NORMAL _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["Normal"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . Position ,     3  ,    ShaderProgram . POSITION _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["Position"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . Tangent ,     3  ,    ShaderProgram . TANGENT _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["Tangent"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( VertexAttributes . Usage . TextureCoordinates ,     2  ,     (  ( ShaderProgram . TEXCOORD _ ATTRIBUTE )     +    unit )  ,    unit )  ;", "}", "METHOD_END"], "methodName": ["TexCoords"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   VertexAttribute ( usage ,    numComponents ,    type ,    normalized ,    alias ,    unit )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  ( other    !  =    null )     &  &     (  ( usage )     =  =     ( other . usage )  )  )     &  &     (  ( numComponents )     =  =     ( other . numComponents )  )  )     &  &     (  ( type )     =  =     ( other . type )  )  )     &  &     (  ( normalized )     =  =     ( other . normalized )  )  )     &  &     ( alias . equals ( other . alias )  )  )     &  &     (  ( unit )     =  =     ( other . unit )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "return    (  ( usageIndex )     <  <     8  )     +     (  ( unit )     &     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   GL 2  0  . GL _ FLOAT    :", "case   GL 2  0  . GL _ FIXED    :", "return    4     *     ( numCponents )  ;", "case   GL 2  0  . GL _ UNSIGNED _ BYTE    :", "case   GL 2  0  . GL _ BYTE    :", "return   numCponents ;", "case   GL 2  0  . GL _ UNSIGNED _ SHORT    :", "case   GL 2  0  . GL _ SHORT    :", "return    2     *     ( numCponents )  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["getSizeInBytes"], "fileName": "com.badlogic.gdx.graphics.VertexAttribute"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( attributes . length )  ;    i +  +  )     {", "attribute    =    attributes [ i ]  ;", "attribute . offset    =    count ;", "count    +  =    attribute . getSizeInBytes (  )  ;", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["calculateOffsets"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "int   len    =    size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )", "if    (  ( get ( i )  . usage )     =  =    usage )", "return   get ( i )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["findByUsage"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "return   attributes [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mask )     =  =     (  -  1  )  )     {", "long   result    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( a . length )  ;    i +  +  )     {", "result    |  =    a [ i ]  . usage ;", "}", "mask    =    result ;", "}", "return   mask ;", "}", "METHOD_END"], "methodName": ["getMask"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "return    ( getMask (  )  )     |     (  (  ( long )     ( attributes . length )  )     <  <     3  2  )  ;", "}", "METHOD_END"], "methodName": ["getMaskWithSizePacked"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getOffset ( usage ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "VertexAttribute   vertexAttribute    =    findByUsage ( usage )  ;", "if    ( vertexAttribute    =  =    null )", "return   defaultIfNotFound ;", "return    ( vertexAttribute . offset )     /     4  ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "return   attributes . length ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  \"  [  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( a . length )  ;    i +  +  )     {", "builder . append (  \"  (  \"  )  ;", "builder . append ( a [ i ]  . alias )  ;", "builder . append (  \"  ,     \"  )  ;", "builder . append ( a [ i ]  . usage )  ;", "builder . append (  \"  ,     \"  )  ;", "builder . append ( a [ i ]  . numComponents )  ;", "builder . append (  \"  ,     \"  )  ;", "builder . append ( a [ i ]  . offset )  ;", "builder . append (  \"  )  \"  )  ;", "builder . append (  \"  \\ n \"  )  ;", "}", "builder . append (  \"  ]  \"  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.graphics.VertexAttributes"}, {"methodBody": ["METHOD_START", "{", "return   animationDuration ;", "}", "METHOD_END"], "methodName": ["getAnimationDuration"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "return   frameDuration ;", "}", "METHOD_END"], "methodName": ["getFrameDuration"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "int   frameNumber    =    getKeyFrameIndex ( stateTime )  ;", "return   keyFrames [ frameNumber ]  ;", "}", "METHOD_END"], "methodName": ["getKeyFrame"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "Animation . PlayMode   oldPlayMode    =    playMode ;", "if    ( looping    &  &     (  (  ( playMode )     =  =     ( Animation . PlayMode . NORMAL )  )     |  |     (  ( playMode )     =  =     ( Animation . PlayMode . REVERSED )  )  )  )     {", "if    (  ( playMode )     =  =     ( Animation . PlayMode . NORMAL )  )", "playMode    =    Animation . PlayMode . LOOP ;", "else", "playMode    =    Animation . PlayMode . LOOP _ REVERSED ;", "} else", "if    (  (  ! looping )     &  &     (  !  (  (  ( playMode )     =  =     ( Animation . PlayMode . NORMAL )  )     |  |     (  ( playMode )     =  =     ( Animation . PlayMode . REVERSED )  )  )  )  )     {", "if    (  ( playMode )     =  =     ( Animation . PlayMode . LOOP _ REVERSED )  )", "playMode    =    Animation . PlayMode . REVERSED ;", "else", "playMode    =    Animation . PlayMode . LOOP ;", "}", "T   frame    =    getKeyFrame ( stateTime )  ;", "playMode    =    oldPlayMode ;", "return   frame ;", "}", "METHOD_END"], "methodName": ["getKeyFrame"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keyFrames . length )     =  =     1  )", "return    0  ;", "int   frameNumber    =     (  ( int )     ( stateTime    /     ( frameDur )  )  )  ;", "switch    ( playMode )     {", "case   NORMAL    :", "frameNumber    =    Math . min (  (  ( keyFrames . length )     -     1  )  ,    frameNumber )  ;", "break ;", "case   LOOP    :", "frameNumber    =    frameNumber    %     ( keyFrames . length )  ;", "break ;", "case   LOOP _ PINGPONG    :", "frameNumber    =    frameNumber    %     (  (  ( keyFrames . length )     *     2  )     -     2  )  ;", "if    ( frameNumber    >  =     ( keyFrames . length )  )", "frameNumber    =     (  ( keyFrames . length )     -     2  )     -     ( frameNumber    -     ( keyFrames . length )  )  ;", "break ;", "case   LOOP _ RANDOM    :", "int   lastFrameNumber    =     (  ( int )     (  ( lastStateTime )     /     ( frameDur )  )  )  ;", "if    ( lastFrameNumber    !  =    frameNumber )     {", "frameNumber    =    MathUtils . random (  (  ( keyFrames . length )     -     1  )  )  ;", "} else    {", "frameNumber    =    this . lastFrameNumber ;", "}", "break ;", "case   REVERSED    :", "frameNumber    =    Math . max (  (  (  ( keyFrames . length )     -    frameNumber )     -     1  )  ,     0  )  ;", "break ;", "case   LOOP _ REVERSED    :", "frameNumber    =    frameNumber    %     ( keyFrames . length )  ;", "frameNumber    =     (  ( keyFrames . length )     -    frameNumber )     -     1  ;", "break ;", "}", "lastFrameNumber    =    frameNumber ;", "lastStateTime    =    stateTime ;", "return   frameNumber ;", "}", "METHOD_END"], "methodName": ["getKeyFrameIndex"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "return   keyFrames ;", "}", "METHOD_END"], "methodName": ["getKeyFrames"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "return   playMode ;", "}", "METHOD_END"], "methodName": ["getPlayMode"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "int   frameNumber    =     (  ( int )     ( stateTime    /     ( frameDuration )  )  )  ;", "return    (  ( keyFrames . length )     -     1  )     <    frameNumber ;", "}", "METHOD_END"], "methodName": ["isAnimationFinished"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "this . frameDuration    =    frameDuration ;", "this . aDuration    =     ( keyFrames . length )     *    frameDuration ;", "}", "METHOD_END"], "methodName": ["setFrameDuration"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "this . keyFrames    =    keyFrames ;", "this . aDuration    =     ( keyFrames . length )     *     ( frameDuration )  ;", "}", "METHOD_END"], "methodName": ["setKeyFrames"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "this . playMode    =    playMode ;", "}", "METHOD_END"], "methodName": ["setPlayMode"], "fileName": "com.badlogic.gdx.graphics.g2d.Animation"}, {"methodBody": ["METHOD_START", "{", "if    ( ownsTexture )     {", "for    ( int   i    =     0  ;    i    <     ( regions . size )  ;    i +  +  )", "regionet ( i )  . getTexture (  )  . dispose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "cache . clear (  )  ;", "cache . dText ( layout ,    x ,    y )  ;", "cache . draw ( batch )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "cache . clear (  )  ;", "GlyphLayout   layout    =    cache . dText ( str ,    x ,    y )  ;", "cache . draw ( batch )  ;", "return   layout ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "cache . clear (  )  ;", "GlyphLayout   layout    =    cache . addText ( str ,    x ,    y ,    targetWidth ,    halign ,    w )  ;", "cache . draw ( batch )  ;", "return   layout ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "cache . clear (  )  ;", "GlyphLayout   layout    =    cache . addText ( str ,    x ,    y ,    start ,    end ,    targetWidth ,    halign ,    w )  ;", "cache . draw ( batch )  ;", "return   layout ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "cache . clear (  )  ;", "GlyphLayout   layout    =    cache . addText ( str ,    x ,    y ,    start ,    end ,    targetWidth ,    halign ,    w ,    truncate )  ;", "cache . draw ( batch )  ;", "return   layout ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . ascent ;", "}", "METHOD_END"], "methodName": ["getAscent"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . capHeight ;", "}", "METHOD_END"], "methodName": ["getCapHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   cache . getColor (  )  ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . descent ;", "}", "METHOD_END"], "methodName": ["getDescent"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . lineHeight ;", "}", "METHOD_END"], "methodName": ["getLineHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   regions . first (  )  ;", "}", "METHOD_END"], "methodName": ["getRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   regions . get ( index )  ;", "}", "METHOD_END"], "methodName": ["getRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   regions ;", "}", "METHOD_END"], "methodName": ["getRegions"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . scaleX ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . scaleY ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . spaceWidth ;", "}", "METHOD_END"], "methodName": ["getSpaceWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   data . xHeight ;", "}", "METHOD_END"], "methodName": ["getXHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    text . length (  )  ;", "for    (  ;    start    <    n ;    start +  +  )", "if    (  ( text . charAt ( start )  )     =  =    ch )", "return   start ;", "return   n ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   flipped ;", "}", "METHOD_END"], "methodName": ["isFlipped"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "for    ( BitmapFont . Glyph [  ]    page    :    data . glyphs )     {", "if    ( page    =  =    null )", "continue ;", "for    ( BitmapFont . Glyph   glyph    :    page )", "if    ( glyph    !  =    null )", "data . setGlyphRegion ( glyph ,    regions . get ( glyph . page )  )  ;", "}", "if    (  ( data . missingGlyph )     !  =    null )", "data . setGlyphRegion ( data . missingGlyph ,    regions . get ( data . missingGlyph . page )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   new   BitmapFontCache ( this ,    integer )  ;", "}", "METHOD_END"], "methodName": ["newFontCache"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   ownsTexture ;", "}", "METHOD_END"], "methodName": ["ownsTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "cache . getColor (  )  . set ( color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "cache . getColor (  )  . set ( r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "BitmapFont . BitmapFontData   data    =    this . data ;", "int   maxAdvance    =     0  ;", "for    ( int   index    =     0  ,    end    =    glyphs . length (  )  ;    index    <    end ;    index +  +  )     {", "BitmapFont . Glyph   g    =    data . getGlyph ( glyphs . charAt ( index )  )  ;", "if    (  ( g    !  =    null )     &  &     (  ( g . xadvance )     >    maxAdvance )  )", "maxAdvance    =    g . xadvance ;", "}", "for    ( int   index    =     0  ,    end    =    glyphs . length (  )  ;    index    <    end ;    index +  +  )     {", "BitmapFont . Glyph   g    =    data . getGlyph ( glyphs . charAt ( index )  )  ;", "if    ( g    =  =    null )", "continue ;", "g . xoffset    +  =    Math . round (  (  ( maxAdvance    -     ( g . xadvance )  )     /     2  )  )  ;", "g . xadvance    =    maxAdvance ;", "g . kerning    =    null ;", "g . fixedWidth    =    true ;", "}", "}", "METHOD_END"], "methodName": ["setFixedWidthGlyphs"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "this . ownsTexture    =    ownsTexture ;", "}", "METHOD_END"], "methodName": ["setOwnsTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "this . integer    =    integer ;", "cache . setUseIntegerPositions ( integer )  ;", "}", "METHOD_END"], "methodName": ["setUseIntegerPositions"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "if    (  ( data . fontFile )     !  =    null )", "return   data . fontFile . nameWithoutExtension (  )  ;", "return   super . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "return   integer ;", "}", "METHOD_END"], "methodName": ["usesIntegerPositions"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFont"}, {"methodBody": ["METHOD_START", "{", "final   float   scaleX    =    font . data . scaleX ;", "final   float   scaleY    =    font . data . scaleY ;", "x    +  =     ( glyph . xoffset )     *    scaleX ;", "y    +  =     ( glyph . yoffset )     *    scaleY ;", "float   width    =     ( glyph . width )     *    scaleX ;", "float   height    =     ( glyph . height )     *    scaleY ;", "final   float   u    =    glyph . u ;", "final   float   u 2     =    glyph . u 2  ;", "final   float   v    =    glyph . v ;", "final   float   v 2     =    glyph . v 2  ;", "if    ( integer )     {", "x    =    Math . round ( x )  ;", "y    =    Math . round ( y )  ;", "width    =    Math . round ( width )  ;", "height    =    Math . round ( height )  ;", "}", "final   float   x 2     =    x    +    width ;", "final   float   y 2     =    y    +    height ;", "final   int   page    =    glyph . page ;", "int   idx    =    this . idx [ page ]  ;", "this . idx [ page ]     +  =     2  0  ;", "if    (  ( pageGlyphIndices )     !  =    null )", "pageGlyphIndices [ page ]  . add (  (  ( glyphCount )  +  +  )  )  ;", "final   float [  ]    vertices    =    pageVertices [ page ]  ;", "vertices [  ( idx +  +  )  ]     =    x ;", "vertices [  ( idx +  +  )  ]     =    y ;", "vertices [  ( idx +  +  )  ]     =    color ;", "vertices [  ( idx +  +  )  ]     =    u ;", "vertices [  ( idx +  +  )  ]     =    v ;", "vertices [  ( idx +  +  )  ]     =    x ;", "vertices [  ( idx +  +  )  ]     =    y 2  ;", "vertices [  ( idx +  +  )  ]     =    color ;", "vertices [  ( idx +  +  )  ]     =    u ;", "vertices [  ( idx +  +  )  ]     =    v 2  ;", "vertices [  ( idx +  +  )  ]     =    x 2  ;", "vertices [  ( idx +  +  )  ]     =    y 2  ;", "vertices [  ( idx +  +  )  ]     =    color ;", "vertices [  ( idx +  +  )  ]     =    u 2  ;", "vertices [  ( idx +  +  )  ]     =    v 2  ;", "vertices [  ( idx +  +  )  ]     =    x 2  ;", "vertices [  ( idx +  +  )  ]     =    y ;", "vertices [  ( idx +  +  )  ]     =    color ;", "vertices [  ( idx +  +  )  ]     =    u 2  ;", "vertices [ idx ]     =    v ;", "}", "METHOD_END"], "methodName": ["addGlyph"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "addToCache ( layout ,    x ,     ( y    +     ( font . data . ascent )  )  )  ;", "}", "METHOD_END"], "methodName": ["addText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   addText ( str ,    x ,    y ,     0  ,    str . length (  )  ,     0  ,    Align . left ,    false ,    null )  ;", "}", "METHOD_END"], "methodName": ["addText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   addText ( str ,    x ,    y ,     0  ,    str . length (  )  ,    targetWidth ,    halign ,    wrap ,    null )  ;", "}", "METHOD_END"], "methodName": ["addText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   addText ( str ,    x ,    y ,    start ,    end ,    targetWidth ,    halign ,    wrap ,    null )  ;", "}", "METHOD_END"], "methodName": ["addText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "GlyphLayout   layout    =    Pools . obtain ( GlyphLayout . class )  ;", "pooledLayouts . add ( layout )  ;", "layout . setText ( font ,    str ,    start ,    end ,    color ,    targetWidth ,    halign ,    w ,    truncate )  ;", "addText ( layout ,    x ,    y )  ;", "return   layout ;", "}", "METHOD_END"], "methodName": ["addText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "int   pageCount    =    font . regions . size ;", "if    (  ( pageVertices . length )     <    pageCount )     {", "float [  ]  [  ]    newPageVertices    =    new   float [ pageCount ]  [  ]  ;", "System . arraycopy ( pageVertices ,     0  ,    newPageVertices ,     0  ,    pageVertices . length )  ;", "pageVertices    =    newPageVertices ;", "int [  ]    newIdx    =    new   int [ pageCount ]  ;", "System . arraycopy ( idx ,     0  ,    newIdx ,     0  ,    idx . length )  ;", "idx    =    newIdx ;", "IntArray [  ]    newPageGlyphIndices    =    new   IntArray [ pageCount ]  ;", "int   pageGlyphIndicesLength    =     0  ;", "if    (  ( pageGlyphIndices )     !  =    null )     {", "pageGlyphIndicesLength    =    pageGlyphIndices . length ;", "System . arraycopy ( pageGlyphIndices ,     0  ,    newPageGlyphIndices ,     0  ,    pageGlyphIndices . length )  ;", "}", "for    ( int   i    =    pageGlyphIndicesLength ;    i    <    pageCount ;    i +  +  )", "newPageGlyphIndices [ i ]     =    new   IntArray (  )  ;", "pageGlyphIndices    =    newPageGlyphIndices ;", "tempGlyphCount    =    new   int [ pageCount ]  ;", "}", "layouts . add ( layout )  ;", "requireGlyphs ( layout )  ;", "for    ( int   i    =     0  ,    n    =    layout . runs . size ;    i    <    n ;    i +  +  )     {", "GlyphLayout . GlyphRun   run    =    layout . runs . get ( i )  ;", "Array < BitmapFont . Glyph >    glyphs    =    run . glyphs ;", "FloatArray   xAdvances    =    run . xAdvances ;", "float   color    =    run . color . toFloatBits (  )  ;", "float   gx    =    x    +     ( run . x )  ;", "float   gy    =    y    +     ( run . y )  ;", "for    ( int   ii    =     0  ,    nn    =    glyphs . size ;    ii    <    nn ;    ii +  +  )     {", "BitmapFont . Glyph   glyph    =    glyphs . get ( ii )  ;", "gx    +  =    xAdvances . get ( ii )  ;", "addGlyph ( glyph ,    gx ,    gy ,    color )  ;", "}", "}", "currentTint    =     . whiteTint ;", "}", "METHOD_END"], "methodName": ["addToCache"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "x    =     0  ;", "y    =     0  ;", "Pools . freeAll ( pooledLayouts ,    true )  ;", "pooledLayouts . clear (  )  ;", "layouts . clear (  )  ;", "for    ( int   i    =     0  ,    n    =    ilength ;    i    <    n ;    i +  +  )     {", "if    (  ( pageGlyphIndices )     !  =    null )", "pageGlyphIndices [ i ]  . clear (  )  ;", "ii ]     =     0  ;", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "Array < TextureRegion >    regions    =    font . getRegions (  )  ;", "for    ( int   j    =     0  ,    n    =    pageVertices . length ;    j    <    n ;    j +  +  )     {", "if    (  ( idx [ j ]  )     >     0  )     {", "float [  ]    vertices    =    pageVertices [ j ]  ;", "spriteBatch . draw ( regions . get ( j )  . getTexture (  )  ,    vertices ,     0  ,    idx [ j ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "if    ( alphaModulation    =  =     1  )     {", "draw ( spriteBatch )  ;", "return ;", "}", "Color   color    =    getColor (  )  ;", "float   oldAlpha    =    color . a ;", "color . a    *  =    alphaModulation ;", "setColors ( color )  ;", "draw ( spriteBatch )  ;", "color . a    =    oldAlpha ;", "setColors ( color )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pageVertices . length )     =  =     1  )     {", "spriteBatch . draw ( f . getRegion (  )  . getTexture (  )  ,    pageVertices [  0  ]  ,     ( start    *     2  0  )  ,     (  ( end    -    start )     *     2  0  )  )  ;", "return ;", "}", "Array < TextureRegion >    regions    =    f . getRegions (  )  ;", "for    ( int   i    =     0  ,    pageCount    =    pageVertices . length ;    i    <    pageCount ;    i +  +  )     {", "int   offset    =     -  1  ;", "int   count    =     0  ;", "IntArray   glyphIndices    =    pageGlyphIndices [ i ]  ;", "for    ( int   ii    =     0  ,    n    =    glyphIndices . size ;    ii    <    n ;    ii +  +  )     {", "int   glyphIndex    =    glyphIndices . get ( ii )  ;", "if    ( glyphIndex    >  =    end )", "break ;", "if    (  ( offset    =  =     (  -  1  )  )     &  &     ( glyphIndex    >  =    start )  )", "offset    =    ii ;", "if    ( glyphIndex    >  =    start )", "count +  +  ;", "}", "if    (  ( offset    =  =     (  -  1  )  )     |  |     ( count    =  =     0  )  )", "cinue ;", "spriteBatch . draw ( regions . get ( i )  . getTexture (  )  ,    pageVertices [ i ]  ,     ( offset    *     2  0  )  ,     ( count    *     2  0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   font ;", "}", "METHOD_END"], "methodName": ["getFont"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   layouts ;", "}", "METHOD_END"], "methodName": ["getLayouts"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   idx [ page ]  ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   getVertices (  0  )  ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   pageVertices [ page ]  ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pageVertices . length )     =  =     1  )     {", "int   newGlyphCount    =     0  ;", "for    ( int   i    =     0  ,    n    =    layout . runs . size ;    i    <    n ;    i +  +  )", "newGlyphCount    +  =    layout . runs . get ( i )  . glyphs . size ;", "requirePageGlyphs (  0  ,    newGlyphCount )  ;", "} else    {", "int [  ]    tempGlyphCount    =    this . tempGlyphCount ;", "for    ( int   i    =     0  ,    n    =    tempGlyphCount . length ;    i    <    n ;    i +  +  )", "tempGlyphCount [ i ]     =     0  ;", "for    ( int   i    =     0  ,    n    =    layout . runs . size ;    i    <    n ;    i +  +  )     {", "Array <  . Glyph >    glyphs    =    layout . runs . get ( i )  . glyphs ;", "for    ( int   ii    =     0  ,    nn    =    glyphs . size ;    ii    <    nn ;    ii +  +  )", "( tempGlyphCount [ glyphs . get ( ii )  . page ]  )  +  +  ;", "}", "for    ( int   i    =     0  ,    n    =    tempGlyphCount . length ;    i    <    n ;    i +  +  )", "requirePageGlyphs ( i ,    tempGlyphCount [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["requireGlyphs"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pageGlyphIndices )     !  =    null )     {", "if    ( glyphCount    >     ( pageGlyphIndices [ page ]  . items . length )  )", "pageGlyphIndices [ page ]  . ensureCapacity (  ( glyphCount    -     ( pageGlyphIndices [ page ]  . items . length )  )  )  ;", "}", "int   vertexCount    =     ( idx [ page ]  )     +     ( glyphCount    *     2  0  )  ;", "float [  ]    vertices    =    pageVertices [ page ]  ;", "if    ( vertices    =  =    null )     {", "pageVertices [ page ]     =    new   float [ vertexCount ]  ;", "} else", "if    (  ( vertices . length )     <    vertexCount )     {", "float [  ]    newVertices    =    new   float [ vertexCount ]  ;", "System . arraycopy ( vertices ,     0  ,    newVertices ,     0  ,    idx [ page ]  )  ;", "pageVertices [ page ]     =    newVertices ;", "}", "}", "METHOD_END"], "methodName": ["requirePageGlyphs"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "int   alphaBits    =     (  ( int )     (  2  5  4     *    alpha )  )     <  <     2  4  ;", "float   prev    =     0  ;", "float   newColor    =     0  ;", "for    ( int   j    =     0  ,    length    =    pageVertices . length ;    j    <    length ;    j +  +  )     {", "float [  ]    vertices    =    pageVertices [ j ]  ;", "for    ( int   i    =     2  ,    n    =    idx [ j ]  ;    i    <    n ;    i    +  =     5  )     {", "float   c    =    vertices [ i ]  ;", "if    (  ( c    =  =    prev )     &  &     ( i    !  =     2  )  )     {", "vertices [ i ]     =    newColor ;", "} else    {", "prev    =    c ;", "int   rgba    =    NumberUtils . floatToIntColor ( c )  ;", "rgba    =     ( rgba    &     1  6  7  7  7  2  1  5  )     |    alphaBits ;", "newColor    =    NumberUtils . intToFloatColor ( rgba )  ;", "vertices [ i ]     =    newColor ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setAlphas"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "color . set ( r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "setColors ( tint . toFloatBits (  )  )  ;", "}", "METHOD_END"], "methodName": ["setColors"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "setColors ( tint . toFloatBits (  )  ,    start ,    end )  ;", "}", "METHOD_END"], "methodName": ["setColors"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "for    ( int   j    =     0  ,    length    =    pageVertices . length ;    j    <    length ;    j +  +  )     {", "float [  ]    vertices    =    pageVertices [ j ]  ;", "for    ( int   i    =     2  ,    n    =    idx [ j ]  ;    i    <    n ;    i    +  =     5  )", "vertices [ i ]     =    color ;", "}", "}", "METHOD_END"], "methodName": ["setColors"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "int   intBits    =     (  (  (  (  ( int )     (  2  5  5     *    a )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *    b )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *    g )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *    r )  )  ;", "setColors ( NumberUtils . intToFloatColor ( intBits )  )  ;", "}", "METHOD_END"], "methodName": ["setColors"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pageVertices . length )     =  =     1  )     {", "float [  ]    vertices    =    pageVertices [  0  ]  ;", "for    ( int   i    =     ( start    *     2  0  )     +     2  ,    n    =    end    *     2  0  ;    i    <    n ;    i    +  =     5  )", "vertices [ i ]     =    color ;", "return ;", "}", "int   pageCount    =    pageVertices . length ;", "for    ( int   i    =     0  ;    i    <    pageCount ;    i +  +  )     {", "float [  ]    vertices    =    pageVertices [ i ]  ;", "IntArray   glyphIndices    =    pageGlyphIndices [ i ]  ;", "for    ( int   j    =     0  ,    n    =    glyphIndices . size ;    j    <    n ;    j +  +  )     {", "int   glyphIndex    =    glyphIndices . items [ j ]  ;", "if    ( glyphIndex    >  =    end )", "break ;", "if    ( glyphIndex    >  =    start )     {", "for    ( int   off    =     0  ;    off    <     2  0  ;    off    +  =     5  )", "vertices [  ( off    +     (  ( j    *     2  0  )     +     2  )  )  ]     =    color ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setColors"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "translate (  ( x    -     ( this . x )  )  ,     ( y    -     ( this . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "clear (  )  ;", "dText ( layout ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "clear (  )  ;", "return   dText ( str ,    x ,    y ,     0  ,    str . length (  )  ,     0  ,    Align . left ,    false )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "clear (  )  ;", "return   addText ( str ,    x ,    y ,     0  ,    str . length (  )  ,    targetWidth ,    halign ,    w )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "clear (  )  ;", "return   addText ( str ,    x ,    y ,    start ,    end ,    targetWidth ,    halign ,    w )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "clear (  )  ;", "return   addText ( str ,    x ,    y ,    start ,    end ,    targetWidth ,    halign ,    w ,    truncate )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "this . integer    =    use ;", "}", "METHOD_END"], "methodName": ["setUseIntegerPositions"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "float   newTint    =    tint . toFloatBits (  )  ;", "if    (  ( currentTint )     =  =    newTint )", "return ;", "currentTint    =    newTint ;", "int [  ]    tempGlyphCount    =    this . tempGlyphCount ;", "for    ( int   i    =     0  ,    n    =    tempGlyphCount . length ;    i    <    n ;    i +  +  )", "tempGlyphCount [ i ]     =     0  ;", "for    ( int   i    =     0  ,    n    =    layouts . size ;    i    <    n ;    i +  +  )     {", "GlyphLayout   layout    =    layouts . get ( i )  ;", "for    ( int   ii    =     0  ,    nn    =    layout . runs . size ;    ii    <    nn ;    ii +  +  )     {", "GlyphLayout . GlyphRun   run    =    layout . runs . get ( ii )  ;", "Array < BitmapFont . Glyph >    glyphs    =    run . glyphs ;", "float   colorFloat    =     . tempColor . set ( run . color )  . mul ( tint )  . toFloatBits (  )  ;", "for    ( int   iii    =     0  ,    nnn    =    glyphs . size ;    iii    <    nnn ;    iii +  +  )     {", "BitmapFont . Glyph   glyph    =    glyphs . get ( iii )  ;", "int   page    =    glyph . page ;", "int   offset    =     (  ( tempGlyphCount [ page ]  )     *     2  0  )     +     2  ;", "( tempGlyphCount [ page ]  )  +  +  ;", "float [  ]    vertices    =    pageVertices [ page ]  ;", "for    ( int   v    =     0  ;    v    <     2  0  ;    v    +  =     5  )", "vertices [  ( offset    +    v )  ]     =    colorFloat ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["tint"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( xAmount    =  =     0  )     &  &     ( yAmount    =  =     0  )  )", "return ;", "if    ( integer )     {", "xAmount    =    Math . round ( xAmount )  ;", "yAmount    =    Math . round ( yAmount )  ;", "}", "x    +  =    xAmount ;", "y    +  =    yAmount ;", "float [  ]  [  ]    pageVertices    =    this . pageVertices ;", "for    ( int   i    =     0  ,    n    =    pageVertices . length ;    i    <    n ;    i +  +  )     {", "float [  ]    vertices    =    pageVertices [ i ]  ;", "for    ( int   ii    =     0  ,    nn    =    idx [ i ]  ;    ii    <    nn ;    ii    +  =     5  )     {", "vertices [ ii ]     +  =    xAmount ;", "vertices [  ( ii    +     1  )  ]     +  =    yAmount ;", "}", "}", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "return   integer ;", "}", "METHOD_END"], "methodName": ["usesIntegerPositions"], "fileName": "com.badlogic.gdx.graphics.g2d.BitmapFontCache"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    val    =    matrix . getValues (  )  ;", "return    (  (  (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     =  =     ( affine . m 0  0  )  )     &  &     (  ( val [ Matrix 4  . M 1  0  ]  )     =  =     ( affine . m 1  0  )  )  )     &  &     (  ( val [ Matrix 4  . M 0  1  ]  )     =  =     ( affine . m 0  1  )  )  )     &  &     (  ( val [ Matrix 4  . M 1  1  ]  )     =  =     ( affine . m 1  1  )  )  )     &  &     (  ( val [ Matrix 4  . M 0  3  ]  )     =  =     ( affine . m 0  2  )  )  )     &  &     (  ( val [ Matrix 4  . M 1  3  ]  )     =  =     ( affine . m 1  2  )  )  ;", "}", "METHOD_END"], "methodName": ["checkEqual"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    ( a    =  =    b )", "return   true ;", "return    (  (  (  (  (  ( a . val [ Matx 4  . M 0  0  ]  )     =  =     ( b . val [ Matx 4  . M 0  0  ]  )  )     &  &     (  ( a . val [ Matx 4  . M 1  0  ]  )     =  =     ( b . val [ Matx 4  . M 1  0  ]  )  )  )     &  &     (  ( a . val [ Matx 4  . M 0  1  ]  )     =  =     ( b . val [ Matx 4  . M 0  1  ]  )  )  )     &  &     (  ( a . val [ Matx 4  . M 1  1  ]  )     =  =     ( b . val [ Matx 4  . M 1  1  ]  )  )  )     &  &     (  ( a . val [ Matx 4  . M 0  3  ]  )     =  =     ( b . val [ Matx 4  . M 0  3  ]  )  )  )     &  &     (  ( a . val [ Matx 4  . M 1  3  ]  )     =  =     ( b . val [ Matx 4  . M 1  3  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["checkEqual"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    val    =    matrix . getValues (  )  ;", "return    (  (  (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     =  =     1  )     &  &     (  ( val [ Matrix 4  . M 1  0  ]  )     =  =     0  )  )     &  &     (  ( val [ Matrix 4  . M 0  1  ]  )     =  =     0  )  )     &  &     (  ( val [ Matrix 4  . M 1  1  ]  )     =  =     1  )  )     &  &     (  ( val [ Matrix 4  . M 0  3  ]  )     =  =     0  )  )     &  &     (  ( val [ Matrix 4  . M 1  3  ]  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["checkIdt"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "float   invTexWidth    =     1  .  0 F    /     ( texture . getWidth (  )  )  ;", "float   invTexHeight    =     1  .  0 F    /     ( texture . getHeight (  )  )  ;", "float   u    =    srcX    *    invTexWidth ;", "float   v    =     ( srcY    +    srcHeight )     *    invTexHeight ;", "float   u 2     =     ( srcX    +    srcWidth )     *    invTexWidth ;", "float   v 2     =    srcY    *    invTexHeight ;", "drawAdjustedUV ( texture ,    x ,    y ,    originX ,    originY ,    width ,    height ,    scaleX ,    scaleY ,    rotation ,    u ,    v ,    u 2  ,    v 2  ,    flipX ,    flipY )  ;", "}", "METHOD_END"], "methodName": ["drawAdjusted"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "if    ( texture    !  =     ( lastTexture )  )", "switchTexture ( texture )  ;", "Affine 2    t    =    adjustAffine ;", "int   copyCount    =    Math . min (  (  ( vertices . length )     -     ( idx )  )  ,    count )  ;", "do    {", "count    -  =    copyCount ;", "while    ( copyCount    >     0  )     {", "float   x    =    spriteVertices [ offset ]  ;", "float   y    =    spriteVertices [  ( offset    +     1  )  ]  ;", "vertices [ idx ]     =     (  (  ( t . m 0  0  )     *    x )     +     (  ( t . m 0  1  )     *    y )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  )  ]     =     (  (  ( t . m 1  0  )     *    x )     +     (  ( t . m 1  1  )     *    y )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     2  )  ]     =    spriteVertices [  ( offset    +     2  )  ]  ;", "vertices [  (  ( idx )     +     3  )  ]     =    spriteVertices [  ( offset    +     3  )  ]  ;", "vertices [  (  ( idx )     +     4  )  ]     =    spriteVertices [  ( offset    +     4  )  ]  ;", "idx    +  =    Sprite . VERTEX _ SIZE ;", "offset    +  =    Sprite . VERTEX _ SIZE ;", "copyCount    -  =    Sprite . VERTEX _ SIZE ;", "}", "if    ( count    >     0  )     {", "super . flush (  )  ;", "copyCount    =    Math . min ( vertices . length ,    count )  ;", "}", "}    while    ( count    >     0     )  ;", "}", "METHOD_END"], "methodName": ["drawAdjusted"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "if    (  ( region . texture )     !  =     ( lastTexture )  )", "switchTexture ( region . texture )  ;", "else", "if    (  ( idx )     =  =     ( vertices . length )  )", "super . flush (  )  ;", "Affine 2    t    =    transform ;", "float   x 1     =    t . m 0  2  ;", "float   y 1     =    t . m 1  2  ;", "float   x 2     =     (  ( t . m 0  1  )     *    height )     +     ( t . m 0  2  )  ;", "float   y 2     =     (  ( t . m 1  1  )     *    height )     +     ( t . m 1  2  )  ;", "float   x 3     =     (  (  ( t . m 0  0  )     *    width )     +     (  ( t . m 0  1  )     *    height )  )     +     ( t . m 0  2  )  ;", "float   y 3     =     (  (  ( t . m 1  0  )     *    width )     +     (  ( t . m 1  1  )     *    height )  )     +     ( t . m 1  2  )  ;", "float   x 4     =     (  ( t . m 0  0  )     *    width )     +     ( t . m 0  2  )  ;", "float   y 4     =     (  ( t . m 1  0  )     *    width )     +     ( t . m 1  2  )  ;", "float   u    =    region . u ;", "float   v    =    region . v 2  ;", "float   u 2     =    region . u 2  ;", "float   v 2     =    region . v ;", "t    =    adjustAffine ;", "vertices [  (  ( idx )     +     0  )  ]     =     (  (  ( t . m 0  0  )     *    x 1  )     +     (  ( t . m 0  1  )     *    y 1  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  )  ]     =     (  (  ( t . m 1  0  )     *    x 1  )     +     (  ( t . m 1  1  )     *    y 1  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     2  )  ]     =    color ;", "vertices [  (  ( idx )     +     3  )  ]     =    u ;", "vertices [  (  ( idx )     +     4  )  ]     =    v ;", "vertices [  (  ( idx )     +     5  )  ]     =     (  (  ( t . m 0  0  )     *    x 2  )     +     (  ( t . m 0  1  )     *    y 2  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     6  )  ]     =     (  (  ( t . m 1  0  )     *    x 2  )     +     (  ( t . m 1  1  )     *    y 2  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     7  )  ]     =    color ;", "vertices [  (  ( idx )     +     8  )  ]     =    u ;", "vertices [  (  ( idx )     +     9  )  ]     =    v 2  ;", "vertices [  (  ( idx )     +     1  0  )  ]     =     (  (  ( t . m 0  0  )     *    x 3  )     +     (  ( t . m 0  1  )     *    y 3  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  1  )  ]     =     (  (  ( t . m 1  0  )     *    x 3  )     +     (  ( t . m 1  1  )     *    y 3  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     1  2  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  3  )  ]     =    u 2  ;", "vertices [  (  ( idx )     +     1  4  )  ]     =    v 2  ;", "vertices [  (  ( idx )     +     1  5  )  ]     =     (  (  ( t . m 0  0  )     *    x 4  )     +     (  ( t . m 0  1  )     *    y 4  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  6  )  ]     =     (  (  ( t . m 1  0  )     *    x 4  )     +     (  ( t . m 1  1  )     *    y 4  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     1  7  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  8  )  ]     =    u 2  ;", "vertices [  (  ( idx )     +     1  9  )  ]     =    v ;", "idx    +  =    Sprite . SPRITE _ SIZE ;", "}", "METHOD_END"], "methodName": ["drawAdjusted"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "drawAdjustedUV ( region . texture ,    x ,    y ,    originX ,    originY ,    width ,    height ,    scaleX ,    scaleY ,    rotation ,    region . u ,    region . v 2  ,    region . u 2  ,    region . v ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["drawAdjusted"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "if    (  ( region . texture )     !  =     ( lastTexture )  )", "switchTexture ( region . texture )  ;", "else", "if    (  ( idx )     =  =     ( vertices . length )  )", "super . flush (  )  ;", "final   float   worldOriginX    =    x    +    originX ;", "final   float   worldOriginY    =    y    +    originY ;", "float   fx    =     - originX ;", "float   fy    =     - originY ;", "float   fx 2     =    width    -    originX ;", "float   fy 2     =    height    -    originY ;", "if    (  ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  )     {", "fx    *  =    scaleX ;", "fy    *  =    scaleY ;", "fx 2     *  =    scaleX ;", "fy 2     *  =    scaleY ;", "}", "final   float   p 1 x    =    fx ;", "final   float   p 1 y    =    fy ;", "final   float   p 2 x    =    fx ;", "final   float   p 2 y    =    fy 2  ;", "final   float   p 3 x    =    fx 2  ;", "final   float   p 3 y    =    fy 2  ;", "final   float   p 4 x    =    fx 2  ;", "final   float   p 4 y    =    fy ;", "float   x 1  ;", "float   y 1  ;", "float   x 2  ;", "float   y 2  ;", "float   x 3  ;", "float   y 3  ;", "float   x 4  ;", "float   y 4  ;", "if    ( rotation    !  =     0  )     {", "final   float   cos    =    MathUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MathUtils . sinDeg ( rotation )  ;", "x 1     =     ( cos    *    p 1 x )     -     ( sin    *    p 1 y )  ;", "y 1     =     ( sin    *    p 1 x )     +     ( cos    *    p 1 y )  ;", "x 2     =     ( cos    *    p 2 x )     -     ( sin    *    p 2 y )  ;", "y 2     =     ( sin    *    p 2 x )     +     ( cos    *    p 2 y )  ;", "x 3     =     ( cos    *    p 3 x )     -     ( sin    *    p 3 y )  ;", "y 3     =     ( sin    *    p 3 x )     +     ( cos    *    p 3 y )  ;", "x 4     =    x 1     +     ( x 3     -    x 2  )  ;", "y 4     =    y 3     -     ( y 2     -    y 1  )  ;", "} else    {", "x 1     =    p 1 x ;", "y 1     =    p 1 y ;", "x 2     =    p 2 x ;", "y 2     =    p 2 y ;", "x 3     =    p 3 x ;", "y 3     =    p 3 y ;", "x 4     =    p 4 x ;", "y 4     =    p 4 y ;", "}", "x 1     +  =    worldOriginX ;", "y 1     +  =    worldOriginY ;", "x 2     +  =    worldOriginX ;", "y 2     +  =    worldOriginY ;", "x 3     +  =    worldOriginX ;", "y 3     +  =    worldOriginY ;", "x 4     +  =    worldOriginX ;", "y 4     +  =    worldOriginY ;", "float   u 1  ;", "float   v 1  ;", "float   u 2  ;", "float   v 2  ;", "float   u 3  ;", "float   v 3  ;", "float   u 4  ;", "float   v 4  ;", "if    ( clockwise )     {", "u 1     =    region . u 2  ;", "v 1     =    region . v 2  ;", "u 2     =    region . u ;", "v 2     =    region . v 2  ;", "u 3     =    region . u ;", "v 3     =    region . v ;", "u 4     =    region . u 2  ;", "v 4     =    region . v ;", "} else    {", "u 1     =    region . u ;", "v 1     =    region . v ;", "u 2     =    region . u 2  ;", "v 2     =    region . v ;", "u 3     =    region . u 2  ;", "v 3     =    region . v 2  ;", "u 4     =    region . u ;", "v 4     =    region . v 2  ;", "}", "Affine 2    t    =    adjustAffine ;", "vertices [  (  ( idx )     +     0  )  ]     =     (  (  ( t . m 0  0  )     *    x 1  )     +     (  ( t . m 0  1  )     *    y 1  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  )  ]     =     (  (  ( t . m 1  0  )     *    x 1  )     +     (  ( t . m 1  1  )     *    y 1  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     2  )  ]     =    color ;", "vertices [  (  ( idx )     +     3  )  ]     =    u 1  ;", "vertices [  (  ( idx )     +     4  )  ]     =    v 1  ;", "vertices [  (  ( idx )     +     5  )  ]     =     (  (  ( t . m 0  0  )     *    x 2  )     +     (  ( t . m 0  1  )     *    y 2  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     6  )  ]     =     (  (  ( t . m 1  0  )     *    x 2  )     +     (  ( t . m 1  1  )     *    y 2  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     7  )  ]     =    color ;", "vertices [  (  ( idx )     +     8  )  ]     =    u 2  ;", "vertices [  (  ( idx )     +     9  )  ]     =    v 2  ;", "vertices [  (  ( idx )     +     1  0  )  ]     =     (  (  ( t . m 0  0  )     *    x 3  )     +     (  ( t . m 0  1  )     *    y 3  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  1  )  ]     =     (  (  ( t . m 1  0  )     *    x 3  )     +     (  ( t . m 1  1  )     *    y 3  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     1  2  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  3  )  ]     =    u 3  ;", "vertices [  (  ( idx )     +     1  4  )  ]     =    v 3  ;", "vertices [  (  ( idx )     +     1  5  )  ]     =     (  (  ( t . m 0  0  )     *    x 4  )     +     (  ( t . m 0  1  )     *    y 4  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  6  )  ]     =     (  (  ( t . m 1  0  )     *    x 4  )     +     (  ( t . m 1  1  )     *    y 4  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     1  7  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  8  )  ]     =    u 4  ;", "vertices [  (  ( idx )     +     1  9  )  ]     =    v 4  ;", "idx    +  =    Sprite . SPRITE _ SIZE ;", "}", "METHOD_END"], "methodName": ["drawAdjusted"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "if    ( texture    !  =     ( lastTexture )  )", "switchTexture ( texture )  ;", "else", "if    (  ( idx )     =  =     ( vertices . length )  )", "super . flush (  )  ;", "final   float   worldOriginX    =    x    +    originX ;", "final   float   worldOriginY    =    y    +    originY ;", "float   fx    =     - originX ;", "float   fy    =     - originY ;", "float   fx 2     =    width    -    originX ;", "float   fy 2     =    height    -    originY ;", "if    (  ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  )     {", "fx    *  =    scaleX ;", "fy    *  =    scaleY ;", "fx 2     *  =    scaleX ;", "fy 2     *  =    scaleY ;", "}", "final   float   p 1 x    =    fx ;", "final   float   p 1 y    =    fy ;", "final   float   p 2 x    =    fx ;", "final   float   p 2 y    =    fy 2  ;", "final   float   p 3 x    =    fx 2  ;", "final   float   p 3 y    =    fy 2  ;", "final   float   p 4 x    =    fx 2  ;", "final   float   p 4 y    =    fy ;", "float   x 1  ;", "float   y 1  ;", "float   x 2  ;", "float   y 2  ;", "float   x 3  ;", "float   y 3  ;", "float   x 4  ;", "float   y 4  ;", "if    ( rotation    !  =     0  )     {", "final   float   cos    =    MathUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MathUtils . sinDeg ( rotation )  ;", "x 1     =     ( cos    *    p 1 x )     -     ( sin    *    p 1 y )  ;", "y 1     =     ( sin    *    p 1 x )     +     ( cos    *    p 1 y )  ;", "x 2     =     ( cos    *    p 2 x )     -     ( sin    *    p 2 y )  ;", "y 2     =     ( sin    *    p 2 x )     +     ( cos    *    p 2 y )  ;", "x 3     =     ( cos    *    p 3 x )     -     ( sin    *    p 3 y )  ;", "y 3     =     ( sin    *    p 3 x )     +     ( cos    *    p 3 y )  ;", "x 4     =    x 1     +     ( x 3     -    x 2  )  ;", "y 4     =    y 3     -     ( y 2     -    y 1  )  ;", "} else    {", "x 1     =    p 1 x ;", "y 1     =    p 1 y ;", "x 2     =    p 2 x ;", "y 2     =    p 2 y ;", "x 3     =    p 3 x ;", "y 3     =    p 3 y ;", "x 4     =    p 4 x ;", "y 4     =    p 4 y ;", "}", "x 1     +  =    worldOriginX ;", "y 1     +  =    worldOriginY ;", "x 2     +  =    worldOriginX ;", "y 2     +  =    worldOriginY ;", "x 3     +  =    worldOriginX ;", "y 3     +  =    worldOriginY ;", "x 4     +  =    worldOriginX ;", "y 4     +  =    worldOriginY ;", "if    ( flipX )     {", "float   tmp    =    u ;", "u    =    u 2  ;", "u 2     =    tmp ;", "}", "if    ( flipY )     {", "float   tmp    =    v ;", "v    =    v 2  ;", "v 2     =    tmp ;", "}", "Affine 2    t    =    adjustAffine ;", "vertices [  (  ( idx )     +     0  )  ]     =     (  (  ( t . m 0  0  )     *    x 1  )     +     (  ( t . m 0  1  )     *    y 1  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  )  ]     =     (  (  ( t . m 1  0  )     *    x 1  )     +     (  ( t . m 1  1  )     *    y 1  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     2  )  ]     =    color ;", "vertices [  (  ( idx )     +     3  )  ]     =    u ;", "vertices [  (  ( idx )     +     4  )  ]     =    v ;", "vertices [  (  ( idx )     +     5  )  ]     =     (  (  ( t . m 0  0  )     *    x 2  )     +     (  ( t . m 0  1  )     *    y 2  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     6  )  ]     =     (  (  ( t . m 1  0  )     *    x 2  )     +     (  ( t . m 1  1  )     *    y 2  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     7  )  ]     =    color ;", "vertices [  (  ( idx )     +     8  )  ]     =    u ;", "vertices [  (  ( idx )     +     9  )  ]     =    v 2  ;", "vertices [  (  ( idx )     +     1  0  )  ]     =     (  (  ( t . m 0  0  )     *    x 3  )     +     (  ( t . m 0  1  )     *    y 3  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  1  )  ]     =     (  (  ( t . m 1  0  )     *    x 3  )     +     (  ( t . m 1  1  )     *    y 3  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     1  2  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  3  )  ]     =    u 2  ;", "vertices [  (  ( idx )     +     1  4  )  ]     =    v 2  ;", "vertices [  (  ( idx )     +     1  5  )  ]     =     (  (  ( t . m 0  0  )     *    x 4  )     +     (  ( t . m 0  1  )     *    y 4  )  )     +     ( t . m 0  2  )  ;", "vertices [  (  ( idx )     +     1  6  )  ]     =     (  (  ( t . m 1  0  )     *    x 4  )     +     (  ( t . m 1  1  )     *    y 4  )  )     +     ( t . m 1  2  )  ;", "vertices [  (  ( idx )     +     1  7  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  8  )  ]     =    u 2  ;", "vertices [  (  ( idx )     +     1  9  )  ]     =    v ;", "idx    +  =    Sprite . SPRITE _ SIZE ;", "}", "METHOD_END"], "methodName": ["drawAdjustedUV"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "flush (  )  ;", "if    ( adjustNeeded )     {", "haveIdentityRealMatrix    =    CpuSpriteBatch . checkIdt ( virtualMatrix )  ;", "if    (  (  !  ( haveIdentityRealMatrix )  )     &  &     (  ( virtualMatrix . det (  )  )     =  =     0  )  )", "throw   new   utils . GdxRuntimeException (  \" Transform   matrix   is   singular ,    can ' t   sync \"  )  ;", "adjustNeeded    =    false ;", "super . setTransformMatrix ( virtualMatrix )  ;", "}", "}", "METHOD_END"], "methodName": ["flushAndSyncTransformMatrix"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "Matrix 4    realMatrix    =    super . getTransformMatrix (  )  ;", "if    (  . checkEqual ( realMatrix ,    transform )  )     {", "adjustNeeded    =    false ;", "} else    {", "virtualMatrix . setAsAffine ( transform )  ;", "if    ( isDrawing (  )  )     {", "adjustNeeded    =    true ;", "if    ( haveIdentityRealMatrix )     {", "adjustAffine . set ( transform )  ;", "} else    {", "adjustAffine . set ( realMatrix )  . inv (  )  . mul ( transform )  ;", "}", "} else    {", "realMatrix . setAsAffine ( transform )  ;", "haveIdentityRealMatrix    =     . checkIdt ( realMatrix )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setTransformMatrix"], "fileName": "com.badlogic.gdx.graphics.g2d.CpuSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "String   vertexShader    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" attribute   vec 4     \"     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 4     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 2     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \" uniform   mat 4    u _ projTrans ;  \\ n \"  )     +     \" varying   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \"  \\ n \"  )     +     \" void   main (  )     {  \\ n \"  )     +     \"  \t v _ color    =     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"  \\ tv _ color . a    =    v _ color . a    *     (  2  5  5  .  0  /  2  5  4  .  0  )  ;  \\ n \"  )     +     \"  \t v _ texCoords    =     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \"  \t gl _ Position    =       u _ projTrans    *     \"  )     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"  }  \\ n \"  ;", "String   fragmentShader    =     \"  # ifdef   GL _ ES \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  \\ tprecision   mediump   float ;  \\ n \"     +     \"  \\ tprecision   mediump   int ;  \\ n \"  )     +     \"  # endif \\ n \"  )     +     \"  \\ n \"  )     +     \" uniform   sampler 2 D   u _ texture ;  \\ n \"  )     +     \" uniform   float   u _ smoothing ;  \\ n \"  )     +     \" varying   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \"  \\ n \"  )     +     \" void   main (  )     {  \\ n \"  )     +     \"  \\ tif    ( u _ smoothing    >     0  .  0  )     {  \\ n \"  )     +     \"  \\ t \\ tfloat   smoothing    =     0  .  2  5     /    u _ smoothing ;  \\ n \"  )     +     \"  \\ t \\ tfloat   d    =    texture 2 D ( u _ texture ,    v _ texCoords )  . a ;  \\ n \"  )     +     \"  \\ t \\ tfloat   alpha    =    smoothstep (  0  .  5     -    smoothing ,     0  .  5     +    smoothing ,    d )  ;  \\ n \"  )     +     \"  \\ t \\ tgl _ FragColor    =    vec 4  ( v _ color . rgb ,    alpha    *    v _ color . a )  ;  \\ n \"  )     +     \"  \\ t }    else    {  \\ n \"  )     +     \"  \\ t \\ tgl _ FragColor    =    v _ color    *    texture 2 D ( u _ texture ,    v _ texCoords )  ;  \\ n \"  )     +     \"  \\ t }  \\ n \"  )     +     \"  }  \\ n \"  )  ;", "ShaderProgram   shader    =    new   ShaderProgram ( vertexShader ,    fragmentShader )  ;", "if    (  ( shader . isCompiled (  )  )     =  =    false )", "throw   new   IllegalArgumentException (  (  \" Error   compiling   d   field   shader :     \"     +     ( shader . getLog (  )  )  )  )  ;", "return   shader ;", "}", "METHOD_END"], "methodName": ["createDistanceFieldShader"], "fileName": "com.badlogic.gdx.graphics.g2d.DistanceFieldFont"}, {"methodBody": ["METHOD_START", "{", "return   distanceFieldSmoothing ;", "}", "METHOD_END"], "methodName": ["getDistanceFieldSmoothing"], "fileName": "com.badlogic.gdx.graphics.g2d.DistanceFieldFont"}, {"methodBody": ["METHOD_START", "{", "super . load ( data )  ;", "final   Array < TextureRegion >    regions    =    getRegions (  )  ;", "for    ( TextureRegion   region    :    regions )", "region . getTexture (  )  . setFilter ( Texture . TextureFilter . Linear ,    Texture . TextureFilter . Linear )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.DistanceFieldFont"}, {"methodBody": ["METHOD_START", "{", "this . distanceFieldSmoothing    =    distanceFieldSmoothing ;", "}", "METHOD_END"], "methodName": ["setDistanceFieldSmoothing"], "fileName": "com.badlogic.gdx.graphics.g2d.DistanceFieldFont"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . clear ( basePtr ,    color )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap   pixmap    =    new   Gdx 2 DPixmap ( width ,    height ,    requestedFormat )  ;", "pixmap . drawPixmap ( this ,     0  ,     0  ,     0  ,     0  ,    width ,    height )  ;", "dispose (  )  ;", "this . basePtr    =    pixmap . basePtr ;", "this . format    =    pixmap . format ;", "this . height    =    pixmap . height ;", "this . nativeData    =    pixmap . nativeData ;", "this . pixelPtr    =    pixmap . pixelPtr ;", "this . width    =    pixmap . width ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . drawCircle ( basePtr ,    x ,    y ,    radius ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawCircle"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . drawLine ( basePtr ,    x ,    y ,    x 2  ,    y 2  ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawLine"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . drawPixmap ( src . basePtr ,    basePtr ,    srcX ,    srcY ,    width ,    height ,    dstX ,    dstY ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . drawPixmap ( src . basePtr ,    basePtr ,    srcX ,    srcY ,    srcWidth ,    srcHeight ,    dstX ,    dstY ,    dstWidth ,    dstHeight )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . drawRect ( basePtr ,    x ,    y ,    width ,    height ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawRect"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . fillCircle ( basePtr ,    x ,    y ,    radius ,    color )  ;", "}", "METHOD_END"], "methodName": ["fillCircle"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . fillRect ( basePtr ,    x ,    y ,    width ,    height ,    color )  ;", "}", "METHOD_END"], "methodName": ["fillRect"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . fillTriangle ( basePtr ,    x 1  ,    y 1  ,    x 2  ,    y 2  ,    x 3  ,    y 3  ,    color )  ;", "}", "METHOD_END"], "methodName": ["fillTriangle"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   format ;", "}", "METHOD_END"], "methodName": ["getFormat"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "switch    ( format )     {", "case    . GDX 2 D _ FORMAT _ ALPHA    :", "return    \" alpha \"  ;", "case    . GDX 2 D _ FORMAT _ LUMINANCE _ ALPHA    :", "return    \" luminance   alpha \"  ;", "case    . GDX 2 D _ FORMAT _ RGB 8  8  8     :", "return    \" rgb 8  8  8  \"  ;", "case    . GDX 2 D _ FORMAT _ RGBA 8  8  8  8     :", "return    \" rgba 8  8  8  8  \"  ;", "case    . GDX 2 D _ FORMAT _ RGB 5  6  5     :", "return    \" rgb 5  6  5  \"  ;", "case    . GDX 2 D _ FORMAT _ RGBA 4  4  4  4     :", "return    \" rgba 4  4  4  4  \"  ;", "default    :", "return    \" unknown \"  ;", "}", "}", "METHOD_END"], "methodName": ["getFormatString"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   getGLInternalFormat (  )  ;", "}", "METHOD_END"], "methodName": ["getGLFormat"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   Gdx 2 DPixmap . toGlFormat ( format )  ;", "}", "METHOD_END"], "methodName": ["getGLInternalFormat"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   Gdx 2 DPixmap . toGlType ( format )  ;", "}", "METHOD_END"], "methodName": ["getGLType"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   Gdx 2 DPixmap . getPixel ( basePtr ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["getPixel"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   pixelPtr ;", "}", "METHOD_END"], "methodName": ["getPixels"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new    ( width ,    height ,    format )  ;", "}    catch    ( IllegalArgumentException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["newPixmap"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new    ( in ,    requestedFormat )  ;", "}    catch    ( IOException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["newPixmap"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . setBlend ( basePtr ,    blend )  ;", "}", "METHOD_END"], "methodName": ["setBlend"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . setPixel ( basePtr ,    x ,    y ,    color )  ;", "}", "METHOD_END"], "methodName": ["setPixel"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "Gdx 2 DPixmap . setScale ( basePtr ,    scale )  ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "switch    ( format )     {", "case    . GDX 2 D _ FORMAT _ ALPHA    :", "return   GL 2  0  . GL _ ALPHA ;", "case    . GDX 2 D _ FORMAT _ LUMINANCE _ ALPHA    :", "return   GL 2  0  . GL _ LUMINANCE _ ALPHA ;", "case    . GDX 2 D _ FORMAT _ RGB 8  8  8     :", "case    . GDX 2 D _ FORMAT _ RGB 5  6  5     :", "return   GL 2  0  . GL _ RGB ;", "case    . GDX 2 D _ FORMAT _ RGBA 8  8  8  8     :", "case    . GDX 2 D _ FORMAT _ RGBA 4  4  4  4     :", "return   GL 2  0  . GL _ RGBA ;", "default    :", "throw   new   GdxRuntimeException (  (  \" unknown   format :     \"     +    format )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toGlFormat"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "switch    ( format )     {", "case    . GDX 2 D _ FORMAT _ ALPHA    :", "case    . GDX 2 D _ FORMAT _ LUMINANCE _ ALPHA    :", "case    . GDX 2 D _ FORMAT _ RGB 8  8  8     :", "case    . GDX 2 D _ FORMAT _ RGBA 8  8  8  8     :", "return   GL 2  0  . GL _ UNSIGNED _ BYTE ;", "case    . GDX 2 D _ FORMAT _ RGB 5  6  5     :", "return   GL 2  0  . GL _ UNSIGNED _ SHORT _  5  _  6  _  5  ;", "case    . GDX 2 D _ FORMAT _ RGBA 4  4  4  4     :", "return   GL 2  0  . GL _ UNSIGNED _ SHORT _  4  _  4  _  4  _  4  ;", "default    :", "throw   new   GdxRuntimeException (  (  \" unknown   format :     \"     +    format )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toGlType"], "fileName": "com.badlogic.gdx.graphics.g2d.Gdx2DPixmap"}, {"methodBody": ["METHOD_START", "{", "BitmapFont . Glyph   last    =    run . glyphs . peek (  )  ;", "if    ( fontData . isWhitespace (  (  ( char )     ( last . id )  )  )  )", "return ;", "float   width    =     (  (  ( last . xoffset )     +     ( last . width )  )     *     ( fontData . scaleX )  )     -     ( fontData . padRight )  ;", "run . width    +  =    width    -     ( run . xAdvances . peek (  )  )  ;", "run . xAdvances . set (  (  ( run . xAdvances . size )     -     1  )  ,    width )  ;", "}", "METHOD_END"], "methodName": ["adjustLastGlyph"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "if    ( start    =  =    end )", "return    -  1  ;", "switch    ( str . charAt ( start )  )     {", "case    '  #  '     :", "int   colorInt    =     0  ;", "for    ( int   i    =    start    +     1  ;    i    <    end ;    i +  +  )     {", "char   ch    =    str . charAt ( i )  ;", "if    ( ch    =  =     '  ]  '  )     {", "if    (  ( i    <     ( start    +     2  )  )     |  |     ( i    >     ( start    +     9  )  )  )", "break ;", "if    (  ( i    -    start )     <  =     7  )     {", "for    ( int   ii    =     0  ,    nn    =     9     -     ( i    -    start )  ;    ii    <    nn ;    ii +  +  )", "colorInt    =    colorInt    <  <     4  ;", "colorInt    |  =     2  5  5  ;", "}", "Color   color    =    colorPool . obtain (  )  ;", "colorStack . add ( color )  ;", "Color . rgba 8  8  8  8 ToColor ( color ,    colorInt )  ;", "return   i    -    start ;", "}", "if    (  ( ch    >  =     '  0  '  )     &  &     ( ch    <  =     '  9  '  )  )", "colorInt    =     ( colorInt    *     1  6  )     +     ( ch    -     '  0  '  )  ;", "else", "if    (  ( ch    >  =     ' a '  )     &  &     ( ch    <  =     ' f '  )  )", "colorInt    =     ( colorInt    *     1  6  )     +     ( ch    -     (  ' a '     -     1  0  )  )  ;", "else", "if    (  ( ch    >  =     ' A '  )     &  &     ( ch    <  =     ' F '  )  )", "colorInt    =     ( colorInt    *     1  6  )     +     ( ch    -     (  ' A '     -     1  0  )  )  ;", "else", "break ;", "}", "return    -  1  ;", "case    '  [  '     :", "return    -  2  ;", "case    '  ]  '     :", "if    (  ( colorStack . size )     >     1  )", "colorPool . free ( colorStack . pop (  )  )  ;", "return    0  ;", "}", "int   colorStart    =    start ;", "for    ( int   i    =    start    +     1  ;    i    <    end ;    i +  +  )     {", "char   ch    =    str . charAt ( i )  ;", "if    ( ch    !  =     '  ]  '  )", "continue ;", "Color   namedColor    =    Coloret ( str . subSequence ( colorStart ,    i )  . toString (  )  )  ;", "if    ( namedColor    =  =    null )", "return    -  1  ;", "Color   color    =    colorPool . obtain (  )  ;", "colorStack . add ( color )  ;", "color . set ( namedColor )  ;", "return   i    -    start ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["parseColorMarkup"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "Pools . get ( GlyphLayout . GlyphRun . class )  . freeAll ( runs )  ;", "runs . clear (  )  ;", "width    =     0  ;", "height    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "setText ( font ,    str ,     0  ,    str . length (  )  ,    font . getColor (  )  ,     0  ,    Align . left ,    false ,    null )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "setText ( font ,    str ,     0  ,    str . length (  )  ,    color ,    targetWidth ,    halign ,    wrap ,    null )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "if    ( truncate    !  =    null )", "wrap    =    true ;", "else", "if    ( targetWidth    <  =     ( font . data . spaceWidth )  )", "wrap    =    false ;", "BitmapFont . BitmapFontData   fontData    =    font . data ;", "boolean   markupEnabled    =    fontData . markupEnabled ;", "Pool <  . GlyphRun >    glyphRunPool    =    Pools . get (  . GlyphRun . class )  ;", "Array <  . GlyphRun >    runs    =    this . runs ;", "glyphRunPool . freeAll ( runs )  ;", "runs . clear (  )  ;", "float   x    =     0  ;", "float   y    =     0  ;", "float   width    =     0  ;", "int   lines    =     0  ;", "int   blankLines    =     0  ;", "Array < Color >    colorStack    =    this . colorStack ;", "Color   nextColor    =    color ;", "colorStack . add ( color )  ;", "Pool < Color >    colorPool    =    Pools . get ( Color . class )  ;", "int   runStart    =    start ;", "outer    :    while    ( true )     {", "int   runEnd    =     -  1  ;", "boolean   newline    =    false ;", "boolean   colorRun    =    false ;", "if    ( start    =  =    end )     {", "if    ( runStart    =  =    end )", "break ;", "runEnd    =    end ;", "} else    {", "switch    ( str . charAt (  ( start +  +  )  )  )     {", "case    '  \\ n '     :", "runEnd    =    start    -     1  ;", "newline    =    true ;", "break ;", "case    '  [  '     :", "if    ( markupEnabled )     {", "int   length    =    parseColorMarkup ( str ,    start ,    end ,    colorPool )  ;", "if    ( length    >  =     0  )     {", "runEnd    =    start    -     1  ;", "start    +  =    length    +     1  ;", "nextColor    =    colorStack . peek (  )  ;", "colorRun    =    true ;", "} else", "if    ( length    =  =     (  -  2  )  )     {", "start +  +  ;", "continue   outer ;", "}", "}", "break ;", "}", "}", "if    ( runEnd    !  =     (  -  1  )  )     {", "if    ( runEnd    !  =    runStart )     {", ". GlyphRun   run    =    glyphRunPool . obtain (  )  ;", "run . color . set ( color )  ;", "run . x    =    x ;", "run . y    =    y ;", "fontData . getGlyphs ( run ,    str ,    runStart ,    runEnd ,    colorRun )  ;", "if    (  ( run . glyphs . size )     =  =     0  )", "glyphRunPool . free ( run )  ;", "else    {", "runs . add ( run )  ;", "float [  ]    xAdvances    =    run . xAdvances . items ;", "for    ( int   i    =     0  ,    n    =    run . xAdvances . size ;    i    <    n ;    i +  +  )     {", "float   xAdvance    =    xAdvances [ i ]  ;", "x    +  =    xAdvance ;", "if    (  (  ( wrap    &  &     ( x    >    targetWidth )  )     &  &     ( i    >     1  )  )     &  &     (  (  (  ( x    -    xAdvance )     +     (  (  ( run . glyphs . get (  ( i    -     1  )  )  . xoffset )     +     ( run . glyphs . get (  ( i    -     1  )  )  . width )  )     *     ( fontData . scaleX )  )  )     -     1  .  0 E -  4 F )     >    targetWidth )  )     {", "if    ( truncate    !  =    null )     {", "truncate ( fontData ,    run ,    targetWidth ,    truncate ,    i ,    glyphRunPool )  ;", "x    =     ( run . x )     +     ( run . width )  ;", "break   outer ;", "}", "int   wrapIndex    =    fontData . getWrapIndex ( run . glyphs ,    i )  ;", "if    (  (  (  ( run . x )     =  =     0  )     &  &     ( wrapIndex    =  =     0  )  )     |  |     ( wrapIndex    >  =     ( run . glyphs . size )  )  )     {", "wrapIndex    =    i    -     1  ;", "}", ". GlyphRun   next ;", "if    ( wrapIndex    =  =     0  )     {", "next    =    run ;", "run . width    =     0  ;", "width    =    Math . max ( width ,    run . x )  ;", "} else    {", "next    =    wrap ( fontData ,    run ,    glyphRunPool ,    wrapIndex ,    i )  ;", "runs . add ( next )  ;", "width    =    Math . max ( width ,     (  ( run . x )     +     ( run . width )  )  )  ;", "}", "x    =     0  ;", "y    +  =    fontData . down ;", "lines +  +  ;", "next . x    =     0  ;", "next . y    =    y ;", "i    =     -  1  ;", "n    =    next . xAdvances . size ;", "xAdvances    =    next . xAdvances . items ;", "run    =    next ;", "} else", "run . width    +  =    xAdvance ;", "}", "}", "}", "if    ( newline )     {", "width    =    Math . max ( width ,    x )  ;", "x    =     0  ;", "float   down    =    fontData . down ;", "if    ( runEnd    =  =    runStart )     {", "down    *  =    fontData . blankLineScale ;", "blankLines +  +  ;", "} else", "lines +  +  ;", "y    +  =    down ;", "}", "runStart    =    start ;", "color    =    nextColor ;", "}", "}", "width    =    Math . max ( width ,    x )  ;", "for    ( int   i    =     1  ,    n    =    colorStack . size ;    i    <    n ;    i +  +  )", "colorPool . free ( colorStack . get ( i )  )  ;", "colorStack . clear (  )  ;", "if    (  ( halign    &     ( Align . left )  )     =  =     0  )     {", "boolean   center    =     ( halign    &     ( Align . center )  )     !  =     0  ;", "float   lineWidth    =     0  ;", "float   lineY    =    Integer . MIN _ VALUE ;", "int   lineStart    =     0  ;", "int   n    =    runs . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", ". GlyphRun   run    =    runs . get ( i )  ;", "if    (  ( run . y )     !  =    lineY )     {", "lineY    =    run . y ;", "float   shift    =    targetWidth    -    lineWidth ;", "if    ( center )", "shift    /  =     2  ;", "while    ( lineStart    <    i )", "runs . get (  ( lineStart +  +  )  )  . x    +  =    shift ;", "lineWidth    =     0  ;", "}", "lineWidth    +  =    run . width ;", "}", "float   shift    =    targetWidth    -    lineWidth ;", "if    ( center )", "shift    /  =     2  ;", "while    ( lineStart    <    n )", "runs . get (  ( lineStart +  +  )  )  . x    +  =    shift ;", "}", "this . width    =    width ;", "this . height    =     (  ( fontData . capHeight )     -     ( lines    *     ( fontData . down )  )  )     -     (  ( blankLines    *     ( fontData . down )  )     *     ( fontData . blankLineScale )  )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "if    (  ( runs . size )     =  =     0  )", "return    \"  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  1  2  8  )  ;", "buffer . append ( width )  ;", "buffer . append (  ' x '  )  ;", "buffer . append ( height )  ;", "buffer . append (  '  \\ n '  )  ;", "for    ( int   i    =     0  ,    n    =    runs . size ;    i    <    n ;    i +  +  )     {", "buffer . append ( runet ( i )  . toString (  )  )  ;", "buffer . append (  '  \\ n '  )  ;", "}", "buffer . setLength (  (  ( buffer . length (  )  )     -     1  )  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "GlyphLayout . GlyphRun   truncateRun    =    glyphRunPool . obtain (  )  ;", "fontData . getGlyphs ( truncateRun ,    truncate ,     0  ,    truncate . length (  )  ,    true )  ;", "float   truncateWidth    =     0  ;", "for    ( int   i    =     1  ,    n    =    truncateRun . xAdvances . size ;    i    <    n ;    i +  +  )", "truncateWidth    +  =    truncateRun . xAdvances . get ( i )  ;", "targetWidth    -  =    truncateWidth ;", "int   count    =     0  ;", "float   width    =    run . x ;", "while    ( count    <     ( run . xAdvances . size )  )     {", "float   xAdvance    =    run . xAdvances . get ( count )  ;", "width    +  =    xAdvance ;", "if    ( width    >    targetWidth )     {", "run . width    =     ( width    -     ( run . x )  )     -    xAdvance ;", "break ;", "}", "count +  +  ;", "}", "if    ( count    >     1  )     {", "run . glyphs . truncate (  ( count    -     1  )  )  ;", "run . xAdvances . truncate ( count )  ;", "adjustLastGlyph ( fontData ,    run )  ;", "if    (  ( truncateRun . xAdvances . size )     >     0  )", "run . xAdvances . addAll ( truncateRun . xAdvances ,     1  ,     (  ( truncateRun . xAdvances . size )     -     1  )  )  ;", "} else    {", "run . glyphs . clear (  )  ;", "run . xAdvances . clear (  )  ;", "run . xAdvances . addAll ( truncateRun . xAdvances )  ;", "if    (  ( truncateRun . xAdvances . size )     >     0  )", "run . width    +  =    truncateRun . xAdvances . get (  0  )  ;", "}", "run . glyphs . addAll ( truncateRun . glyphs )  ;", "run . width    +  =    truncateWidth ;", "glyphRunPool . free ( truncateRun )  ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "GlyphLayout . GlyphRun   second    =    glyphRunPool . obtain (  )  ;", "second . color . set ( first . color )  ;", "int   glyphCount    =    first . glyphs . size ;", "while    ( widthIndex    <    wrapIndex )", "first . width    +  =    first . xAdvances . get (  ( widthIndex +  +  )  )  ;", "while    ( widthIndex    >     ( wrapIndex    +     1  )  )", "first . width    -  =    first . xAdvances . get (  (  -  - widthIndex )  )  ;", "if    ( wrapIndex    <    glyphCount )     {", "Array < BitmapFont . Glyph >    glyphs 1     =    second . glyphs ;", "Array < BitmapFont . Glyph >    glyphs 2     =    first . glyphs ;", "glyphs 1  . addAll ( glyphs 2  ,     0  ,    wrapIndex )  ;", "glyphs 2  . removeRange (  0  ,     ( wrapIndex    -     1  )  )  ;", "first . glyphs    =    glyphs 1  ;", "second . glyphs    =    glyphs 2  ;", "FloatArray   xAdvances 1     =    second . xAdvances ;", "FloatArray   xAdvances 2     =    first . xAdvances ;", "xAdvances 1  . addAll ( xAdvances 2  ,     0  ,     ( wrapIndex    +     1  )  )  ;", "xAdvances 2  . removeRange (  1  ,    wrapIndex )  ;", "xAdvances 2  . set (  0  ,     (  (  (  -  ( glyphs 2  . first (  )  . xoffset )  )     *     ( fontData . scaleX )  )     -     ( fontData . padLeft )  )  )  ;", "first . xAdvances    =    xAdvances 1  ;", "second . xAdvances    =    xAdvances 2  ;", "}", "if    ( wrapIndex    =  =     0  )     {", "glyphRunPool . free ( first )  ;", "runs . pop (  )  ;", "} else", "adjustLastGlyph ( fontData ,    first )  ;", "return   second ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "com.badlogic.gdx.graphics.g2d.GlyphLayout"}, {"methodBody": ["METHOD_START", "{", "if    (  ( texture )     =  =    null )", "texture    =    region . getTexture (  )  ;", "else", "if    (  ( texture )     !  =     ( region . getTexture (  )  )  )", "throw   new   IllegalArgumentException (  \" All   regions   must   be   from   the   same   texture .  \"  )  ;", "float   u    =    region . u ;", "float   v    =    region . v 2  ;", "float   u 2     =    region . u 2  ;", "float   v 2     =    region . v ;", "if    (  (  ( texture . getMagFilter (  )  )     =  =     ( Texture . TextureFilter . Lar )  )     |  |     (  ( texture . getMinFilter (  )  )     =  =     ( Texture . TextureFilter . Lar )  )  )     {", "if    ( isStretchW )     {", "float   halfTexelWidth    =     (  0  .  5 F    *     1  .  0 F )     /     ( texture . getWidth (  )  )  ;", "u    +  =    halfTexelWidth ;", "u 2     -  =    halfTexelWidth ;", "}", "if    ( isStretchH )     {", "float   halfTexelHeight    =     (  0  .  5 F    *     1  .  0 F )     /     ( texture . getHeight (  )  )  ;", "v    -  =    halfTexelHeight ;", "v 2     +  =    halfTexelHeight ;", "}", "}", "final   float [  ]    vertices    =    this . vertices ;", "vertices [  (  ( idx )     +     2  )  ]     =    color ;", "vertices [  (  ( idx )     +     3  )  ]     =    u ;", "vertices [  (  ( idx )     +     4  )  ]     =    v ;", "vertices [  (  ( idx )     +     7  )  ]     =    color ;", "vertices [  (  ( idx )     +     8  )  ]     =    u ;", "vertices [  (  ( idx )     +     9  )  ]     =    v 2  ;", "vertices [  (  ( idx )     +     1  2  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  3  )  ]     =    u 2  ;", "vertices [  (  ( idx )     +     1  4  )  ]     =    v 2  ;", "vertices [  (  ( idx )     +     1  7  )  ]     =    color ;", "vertices [  (  ( idx )     +     1  8  )  ]     =    u 2  ;", "vertices [  (  ( idx )     +     1  9  )  ]     =    v ;", "idx    +  =     2  0  ;", "return    ( idx )     -     2  0  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "prepareVertices ( batch ,    x ,    y ,    width ,    height )  ;", "batch . draw ( texture ,    vertices ,     0  ,    idx )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "prepareVertices ( batch ,    x ,    y ,    width ,    height )  ;", "float   worldOriginX    =    x    +    originX ;", "float   worldOriginY    =    y    +    originY ;", "int   n    =    this . idx ;", "float [  ]    vertices    =    this . vertices ;", "if    ( rotation    !  =     0  )     {", "for    ( int   i    =     0  ;    i    <    n ;    i    +  =     5  )     {", "float   vx    =     (  ( vertices [ i ]  )     -    worldOriginX )     *    scaleX ;", "float   vy    =     (  ( vertices [  ( i    +     1  )  ]  )     -    worldOriginY )     *    scaleY ;", "float   cos    =    MathUtils . cosDeg ( rotation )  ;", "float   sin    =    MathUtils . sinDeg ( rotation )  ;", "vertices [ i ]     =     (  ( cos    *    vx )     -     ( sin    *    vy )  )     +    worldOriginX ;", "vertices [  ( i    +     1  )  ]     =     (  ( sin    *    vx )     +     ( cos    *    vy )  )     +    worldOriginY ;", "}", "} else", "if    (  ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  )     {", "for    ( int   i    =     0  ;    i    <    n ;    i    +  =     5  )     {", "vertices [ i ]     =     (  (  ( vertices [ i ]  )     -    worldOriginX )     *    scaleX )     +    worldOriginX ;", "vertices [  ( i    +     1  )  ]     =     (  (  ( vertices [  ( i    +     1  )  ]  )     -    worldOriginY )     *    scaleY )     +    worldOriginY ;", "}", "}", "batch . draw ( texture ,    vertices ,     0  ,    n )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   bottomHeight ;", "}", "METHOD_END"], "methodName": ["getBottomHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   leftWidth ;", "}", "METHOD_END"], "methodName": ["getLeftWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   middleHeight ;", "}", "METHOD_END"], "methodName": ["getMiddleHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   middleWidth ;", "}", "METHOD_END"], "methodName": ["getMiddleWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( padBottom )     =  =     (  -  1  )  )", "return   getBottomHeight (  )  ;", "return   padBottom ;", "}", "METHOD_END"], "methodName": ["getPadBottom"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( padLeft )     =  =     (  -  1  )  )", "return   getLeftWidth (  )  ;", "return   padLeft ;", "}", "METHOD_END"], "methodName": ["getPadLeft"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( padRight )     =  =     (  -  1  )  )", "return   getRightWidth (  )  ;", "return   padRight ;", "}", "METHOD_END"], "methodName": ["getPadRight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( padTop )     =  =     (  -  1  )  )", "return   getTopHeight (  )  ;", "return   padTop ;", "}", "METHOD_END"], "methodName": ["getPadTop"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   rightWidth ;", "}", "METHOD_END"], "methodName": ["getRightWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   texture ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return   topHeight ;", "}", "METHOD_END"], "methodName": ["getTopHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return    (  ( topHeight )     +     ( middleHeight )  )     +     ( bottomHeight )  ;", "}", "METHOD_END"], "methodName": ["getTotalHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "return    (  ( leftWidth )     +     ( middleWidth )  )     +     ( rightWidth )  ;", "}", "METHOD_END"], "methodName": ["getTotalWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "final   float   color    =    Color . WHITE . toFloatBits (  )  ;", "if    (  ( patches [  . BOTTOM _ LEFT ]  )     !  =    null )     {", "bottomLeft    =    add ( patches [  . BOTTOM _ LEFT ]  ,    color ,    false ,    false )  ;", "leftWidth    =    patches [  . BOTTOM _ LEFT ]  . getRegionWidth (  )  ;", "bottomHeight    =    patches [  . BOTTOM _ LEFT ]  . getRegionHeight (  )  ;", "}", "if    (  ( patches [  . BOTTOM _ CENTER ]  )     !  =    null )     {", "bottomCenter    =    add ( patches [  . BOTTOM _ CENTER ]  ,    color ,    true ,    false )  ;", "middleWidth    =    Math . max ( middleWidth ,    patches [  . BOTTOM _ CENTER ]  . getRegionWidth (  )  )  ;", "bottomHeight    =    Math . max ( bottomHeight ,    patches [  . BOTTOM _ CENTER ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( patches [  . BOTTOM _ RIGHT ]  )     !  =    null )     {", "bottomRight    =    add ( patches [  . BOTTOM _ RIGHT ]  ,    color ,    false ,    false )  ;", "rightWidth    =    Math . max ( rightWidth ,    patches [  . BOTTOM _ RIGHT ]  . getRegionWidth (  )  )  ;", "bottomHeight    =    Math . max ( bottomHeight ,    patches [  . BOTTOM _ RIGHT ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( patches [  . MIDDLE _ LEFT ]  )     !  =    null )     {", "middleLeft    =    add ( patches [  . MIDDLE _ LEFT ]  ,    color ,    false ,    true )  ;", "leftWidth    =    Math . max ( leftWidth ,    patches [  . MIDDLE _ LEFT ]  . getRegionWidth (  )  )  ;", "middleHeight    =    Math . max ( middleHeight ,    patches [  . MIDDLE _ LEFT ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( patches [  . MIDDLE _ CENTER ]  )     !  =    null )     {", "middleCenter    =    add ( patches [  . MIDDLE _ CENTER ]  ,    color ,    true ,    true )  ;", "middleWidth    =    Math . max ( middleWidth ,    patches [  . MIDDLE _ CENTER ]  . getRegionWidth (  )  )  ;", "middleHeight    =    Math . max ( middleHeight ,    patches [  . MIDDLE _ CENTER ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( patches [  . MIDDLE _ RIGHT ]  )     !  =    null )     {", "middleRight    =    add ( patches [  . MIDDLE _ RIGHT ]  ,    color ,    false ,    true )  ;", "rightWidth    =    Math . max ( rightWidth ,    patches [  . MIDDLE _ RIGHT ]  . getRegionWidth (  )  )  ;", "middleHeight    =    Math . max ( middleHeight ,    patches [  . MIDDLE _ RIGHT ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( patches [  . TOP _ LEFT ]  )     !  =    null )     {", "topLeft    =    add ( patches [  . TOP _ LEFT ]  ,    color ,    false ,    false )  ;", "leftWidth    =    Math . max ( leftWidth ,    patches [  . TOP _ LEFT ]  . getRegionWidth (  )  )  ;", "topHeight    =    Math . max ( topHeight ,    patches [  . TOP _ LEFT ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( patches [  . TOP _ CENTER ]  )     !  =    null )     {", "topCenter    =    add ( patches [  . TOP _ CENTER ]  ,    color ,    true ,    false )  ;", "middleWidth    =    Math . max ( middleWidth ,    patches [  . TOP _ CENTER ]  . getRegionWidth (  )  )  ;", "topHeight    =    Math . max ( topHeight ,    patches [  . TOP _ CENTER ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( patches [  . TOP _ RIGHT ]  )     !  =    null )     {", "topRight    =    add ( patches [  . TOP _ RIGHT ]  ,    color ,    false ,    false )  ;", "rightWidth    =    Math . max ( rightWidth ,    patches [  . TOP _ RIGHT ]  . getRegionWidth (  )  )  ;", "topHeight    =    Math . max ( topHeight ,    patches [  . TOP _ RIGHT ]  . getRegionHeight (  )  )  ;", "}", "if    (  ( idx )     <     ( vertices . length )  )     {", "float [  ]    newVertices    =    new   float [ idx ]  ;", "System . arraycopy ( vertices ,     0  ,    newVertices ,     0  ,    idx )  ;", "vertices    =    newVertices ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "final   float   centerColumnX    =    x    +     ( leftWidth )  ;", "final   float   rightColumnX    =     ( x    +    width )     -     ( rightWidth )  ;", "final   float   middleRowY    =    y    +     ( bottomHeight )  ;", "final   float   topRowY    =     ( y    +    height )     -     ( topHeight )  ;", "final   float   c    =     . tmpDrawColor . set ( color )  . mul ( batch . getColor (  )  )  . toFloatBits (  )  ;", "if    (  ( bottomLeft )     !  =     (  -  1  )  )", "set ( bottomLeft ,    x ,    y ,     ( centerColumnX    -    x )  ,     ( middleRowY    -    y )  ,    c )  ;", "if    (  ( bottomCenter )     !  =     (  -  1  )  )", "set ( bottomCenter ,    centerColumnX ,    y ,     ( rightColumnX    -    centerColumnX )  ,     ( middleRowY    -    y )  ,    c )  ;", "if    (  ( bottomRight )     !  =     (  -  1  )  )", "set ( bottomRight ,    rightColumnX ,    y ,     (  ( x    +    width )     -    rightColumnX )  ,     ( middleRowY    -    y )  ,    c )  ;", "if    (  ( middleLeft )     !  =     (  -  1  )  )", "set ( middleLeft ,    x ,    middleRowY ,     ( centerColumnX    -    x )  ,     ( topRowY    -    middleRowY )  ,    c )  ;", "if    (  ( middleCenter )     !  =     (  -  1  )  )", "set ( middleCenter ,    centerColumnX ,    middleRowY ,     ( rightColumnX    -    centerColumnX )  ,     ( topRowY    -    middleRowY )  ,    c )  ;", "if    (  ( middleRight )     !  =     (  -  1  )  )", "set ( middleRight ,    rightColumnX ,    middleRowY ,     (  ( x    +    width )     -    rightColumnX )  ,     ( topRowY    -    middleRowY )  ,    c )  ;", "if    (  ( topLeft )     !  =     (  -  1  )  )", "set ( topLeft ,    x ,    topRowY ,     ( centerColumnX    -    x )  ,     (  ( y    +    height )     -    topRowY )  ,    c )  ;", "if    (  ( topCenter )     !  =     (  -  1  )  )", "set ( topCenter ,    centerColumnX ,    topRowY ,     ( rightColumnX    -    centerColumnX )  ,     (  ( y    +    height )     -    topRowY )  ,    c )  ;", "if    (  ( topRight )     !  =     (  -  1  )  )", "set ( topRight ,    rightColumnX ,    topRowY ,     (  ( x    +    width )     -    rightColumnX )  ,     (  ( y    +    height )     -    topRowY )  ,    c )  ;", "}", "METHOD_END"], "methodName": ["prepareVertices"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "leftWidth    *  =    scaleX ;", "rightWidth    *  =    scaleX ;", "topHeight    *  =    scaleY ;", "bottHeight    *  =    scaleY ;", "middleWidth    *  =    scaleX ;", "middleHeight    *  =    scaleY ;", "if    (  ( padLeft )     !  =     (  -  1  )  )", "padLeft    *  =    scaleX ;", "if    (  ( padRight )     !  =     (  -  1  )  )", "padRight    *  =    scaleX ;", "if    (  ( padTop )     !  =     (  -  1  )  )", "padTop    *  =    scaleY ;", "if    (  ( padBott )     !  =     (  -  1  )  )", "padBott    *  =    scaleY ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "final   float   fx 2     =    x    +    width ;", "final   float   fy 2     =    y    +    height ;", "final   float [  ]    vertices    =    this . vertices ;", "vertices [ idx ]     =    x ;", "vertices [  ( idx    +     1  )  ]     =    y ;", "vertices [  ( idx    +     2  )  ]     =    color ;", "vertices [  ( idx    +     5  )  ]     =    x ;", "vertices [  ( idx    +     6  )  ]     =    fy 2  ;", "vertices [  ( idx    +     7  )  ]     =    color ;", "vertices [  ( idx    +     1  0  )  ]     =    fx 2  ;", "vertices [  ( idx    +     1  1  )  ]     =    fy 2  ;", "vertices [  ( idx    +     1  2  )  ]     =    color ;", "vertices [  ( idx    +     1  5  )  ]     =    fx 2  ;", "vertices [  ( idx    +     1  6  )  ]     =    y ;", "vertices [  ( idx    +     1  7  )  ]     =    color ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . bottomHeight    =    bottomHeight ;", "}", "METHOD_END"], "methodName": ["setBottomHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . leftWidth    =    leftWidth ;", "}", "METHOD_END"], "methodName": ["setLeftWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . middleHeight    =    middleHeight ;", "}", "METHOD_END"], "methodName": ["setMiddleHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . middleWidth    =    middleWidth ;", "}", "METHOD_END"], "methodName": ["setMiddleWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . padBottom    =    bottom ;", "}", "METHOD_END"], "methodName": ["setPadBottom"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . padLeft    =    left ;", "}", "METHOD_END"], "methodName": ["setPadLeft"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . padRight    =    right ;", "}", "METHOD_END"], "methodName": ["setPadRight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . padTop    =    top ;", "}", "METHOD_END"], "methodName": ["setPadTop"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . padLeft    =    left ;", "this . padRight    =    right ;", "this . padTop    =    top ;", "this . padBottom    =    bottom ;", "}", "METHOD_END"], "methodName": ["setPadding"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . rightWidth    =    rightWidth ;", "}", "METHOD_END"], "methodName": ["setRightWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "this . topHeight    =    topHeight ;", "}", "METHOD_END"], "methodName": ["setTopHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.NinePatch"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . allowCompletion (  )  ;", "}", "METHOD_END"], "methodName": ["allowCompletion"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ownsTexture )  )", "return ;", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "for    ( Sprite   sprite    :    emitter . getSprites (  )  )     {", "sprite . getTexture (  )  . dispose (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . draw ( spriteBatch )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . draw ( spriteBatch ,    delta )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "if    ( emitter . getName (  )  . equals ( name )  )", "return   emitter ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findEmitter"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . flipY (  )  ;", "}", "METHOD_END"], "methodName": ["flipY"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bounds )     =  =    null )", "bounds    =    new   BoundingBox (  )  ;", "BoundingBox   bounds    =    this . bounds ;", "bounds . inf (  )  ;", "for    ( mitter   emitter    :    this . emitters )", "bounds . ext ( emitter . getBoundingBox (  )  )  ;", "return   bounds ;", "}", "METHOD_END"], "methodName": ["getBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "return   emitters ;", "}", "METHOD_END"], "methodName": ["getEmitters"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "if    (  !  ( emitter . isComplete (  )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "loadEmitters ( effectFile )  ;", "loadEmitterImages ( imagesDir )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "load ( effectFile ,    atlas ,    null )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "loadEmitters ( effectFile )  ;", "loadEmitterImages ( atlas ,    atlasPrefix )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "ownsTexture    =    true ;", "ObjectMap < String ,    Sprite >    loadedSprites    =    new   ObjectMap < String ,    Sprite >  ( emitters . size )  ;", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "if    (  ( emitter . getImagePaths (  )  . size )     =  =     0  )", "continue ;", "Array < Sprite >    sprites    =    new   Array < Sprite >  (  )  ;", "for    ( String   imagePath    :    emitter . getImagePaths (  )  )     {", "String   imageName    =    new   File ( imagePath . replace (  '  \\  \\  '  ,     '  /  '  )  )  . getName (  )  ;", "Sprite   sprite    =    loadedSprites . get ( imageName )  ;", "if    ( sprite    =  =    null )     {", "sprite    =    new   Sprite ( loadTexture ( imagesDir . child ( imageName )  )  )  ;", "loadedSprites . put ( imageName ,    sprite )  ;", "}", "sprites . add ( sprite )  ;", "}", "emitter . setSprites ( sprites )  ;", "}", "}", "METHOD_END"], "methodName": ["loadEmitterImages"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "loadEmitterImages ( atlas ,    null )  ;", "}", "METHOD_END"], "methodName": ["loadEmitterImages"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "if    (  ( emitter . getImagePaths (  )  . size )     =  =     0  )", "continue ;", "Array < Sprite >    sprites    =    new   Array < Sprite >  (  )  ;", "for    ( String   imagePath    :    emitter . getImagePaths (  )  )     {", "String   imageName    =    new   File ( imagePath . replace (  '  \\  \\  '  ,     '  /  '  )  )  . getName (  )  ;", "int   lastDotIndex    =    imageName . lastIndexOf (  '  .  '  )  ;", "if    ( lastDotIndex    !  =     (  -  1  )  )", "imageName    =    imageName . substring (  0  ,    lastDotIndex )  ;", "if    ( atlasPrefix    !  =    null )", "imageName    =    atlasPrefix    +    imageName ;", "Sprite   sprite    =    atlas . createSprite ( imageName )  ;", "if    ( sprite    =  =    null )", "throw   new   IllegalArgumentException (  (  \" SpriteSheet   missing   image :     \"     +    imageName )  )  ;", "sprites . add ( sprite )  ;", "}", "emitter . setSprites ( sprites )  ;", "}", "}", "METHOD_END"], "methodName": ["loadEmitterImages"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    effectFile . read (  )  ;", "emitters . clear (  )  ;", "BufferedReader   reader    =    null ;", "try    {", "reader    =    new   BufferedReader ( new   InputStreamReader ( input )  ,     5  1  2  )  ;", "while    ( true )     {", "mitter   emitter    =    newEmitter ( reader )  ;", "emitters . add ( emitter )  ;", "if    (  ( reader . readLine (  )  )     =  =    null )", "break ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   loading   effect :     \"     +    effectFile )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( reader )  ;", "}", "}", "METHOD_END"], "methodName": ["loadEmitters"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "return   new   Texture ( file ,    false )  ;", "}", "METHOD_END"], "methodName": ["loadTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "return   new   ParticleEmitter ( emitter )  ;", "}", "METHOD_END"], "methodName": ["newEmitter"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "return   new   ParticleEmitter ( reader )  ;", "}", "METHOD_END"], "methodName": ["newEmitter"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "reset ( true )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitters . get ( i )  . reset (  )  ;", "if    ( resetScaling    &  &     (  (  (  ( xSizeScale )     !  =     1  .  0 F )     |  |     (  ( ySizeScale )     !  =     1  .  0 F )  )     |  |     (  ( motionScale )     !  =     1  .  0 F )  )  )     {", "sca (  (  1  .  0 F    /     ( xSizeScale )  )  ,     (  1  .  0 F    /     ( ySizeScale )  )  ,     (  1  .  0 F    /     ( motionScale )  )  )  ;", "xSizeScale    =    ySizeScale    =    motionScale    =     1  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "int   index    =     0  ;", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "if    (  ( index +  +  )     >     0  )", "output . write (  \"  \\ n \"  )  ;", "emitter . save ( output )  ;", "}", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "scaleEffect ( scaleFactor ,    scaleFactor ,    scaleFactor )  ;", "}", "METHOD_END"], "methodName": ["scaleEffect"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "scaleEffect ( scaleFactor ,    scaleFactor ,    motionScaleFactor )  ;", "}", "METHOD_END"], "methodName": ["scaleEffect"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "xSizeScale    *  =    xSizeScaleFactor ;", "ySizeScale    *  =    ySizeScaleFactor ;", "motionScale    *  =    motionScaleFactor ;", "for    ( mitter   particleEmitter    :    emitters )     {", "particleEmitter . scaleSize ( xSizeScaleFactor ,    ySizeScaleFactor )  ;", "particleEmitter . scaleMotion ( motionScaleFactor )  ;", "}", "}", "METHOD_END"], "methodName": ["scaleEffect"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "emitter . setContinuous ( false )  ;", "emitter . duration    =    duration ;", "emitter . durationTimer    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["setDuration"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )     {", "emitteret ( i )  . setCleansUpBlendFunction ( cleanUpBlendFunction )  ;", "}", "}", "METHOD_END"], "methodName": ["setEmittersCleanUpBlendFunction"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . setFlip ( flipX ,    flipY )  ;", "}", "METHOD_END"], "methodName": ["setFlip"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . setPosition ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    emitters . size ;    i    <    n ;    i +  +  )", "emitteret ( i )  . update ( delta )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "super . free ( effect )  ;", "effect . reset ( false )  ;", "if    (  (  (  ( effect . xSizeScale )     !  =     ( this . effect . xSizeScale )  )     |  |     (  ( effect . ySizeScale )     !  =     ( this . effect . ySizeScale )  )  )     |  |     (  ( effect . motionScale )     !  =     ( this . effect . motionScale )  )  )     {", "Array < mitter >    emitters    =    effect . getEmitters (  )  ;", "Array < mitter >    templateEmitters    =    this . effect . getEmitters (  )  ;", "for    ( int   i    =     0  ;    i    <     ( emitters . size )  ;    i +  +  )     {", "mitter   emitter    =    emitters . get ( i )  ;", "mitter   templateEmitter    =    templateEmitters . get ( i )  ;", "emitter . matchSize ( templateEmitter )  ;", "emitter . matchMotion ( templateEmitter )  ;", "}", "effect . xSizeScale    =    this . effect . xSizeScale ;", "effect . ySizeScale    =    this . effect . ySizeScale ;", "effect . motionScale    =    this . effect . motionScale ;", "}", "}", "METHOD_END"], "methodName": ["free"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffectPool"}, {"methodBody": ["METHOD_START", "{", "return   new   ParticleEffectPool . PooledEffect ( effect )  ;", "}", "METHOD_END"], "methodName": ["newObject"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEffectPool"}, {"methodBody": ["METHOD_START", "{", "Sprite   sprite    =    null ;", "switch    ( spriteMode )     {", "case   single    :", "case   animated    :", "sprite    =    sprites . first (  )  ;", "break ;", "case   random    :", "sprite    =    sprites . random (  )  ;", "break ;", "}", ". Particle   particle    =    particles [ index ]  ;", "if    ( particle    =  =    null )     {", "particles [ index ]     =    particle    =    newParticle ( sprite )  ;", "particle . flip ( flipX ,    flipY )  ;", "} else    {", "particle . set ( sprite )  ;", "}", "float   percent    =     ( durationTimer )     /     (  ( float )     ( duration )  )  ;", "int   updateFlags    =    this . updateFlags ;", "particle . currentLife    =    particle . life    =     ( life )     +     (  ( int )     (  ( lifeDiff )     *     ( lifeValue . getScale ( percent )  )  )  )  ;", "if    ( velocityValue . active )     {", "particle . velocity    =    velocityValue . newLowValue (  )  ;", "particle . velocityDiff    =    velocityValue . newHighValue (  )  ;", "if    (  !  ( velocityValue . isRelative (  )  )  )", "particle . velocityDiff    -  =    particle . velocity ;", "}", "particle . angle    =    angleValue . newLowValue (  )  ;", "particle . angleDiff    =    angleValue . newHighValue (  )  ;", "if    (  !  ( angleValue . isRelative (  )  )  )", "particle . angleDiff    -  =    particle . angle ;", "float   angle    =     0  ;", "if    (  ( updateFlags    &     (  . UPDATE _ ANGLE )  )     =  =     0  )     {", "angle    =     ( particle . angle )     +     (  ( particle . angleDiff )     *     ( angleValue . getScale (  0  )  )  )  ;", "particle . angle    =    angle ;", "particle . angleCos    =    MathUtils . cosDeg ( angle )  ;", "particle . angleSin    =    MathUtils . sinDeg ( angle )  ;", "}", "float   spriteWidth    =    sprite . getWidth (  )  ;", "float   spriteHeight    =    sprite . getHeight (  )  ;", "particle . xScale    =     ( xScaleValue . newLowValue (  )  )     /    spriteWidth ;", "particle . xScaleDiff    =     ( xScaleValue . newHighValue (  )  )     /    spriteWidth ;", "if    (  !  ( xScaleValue . isRelative (  )  )  )", "particle . xScaleDiff    -  =    particle . xScale ;", "if    ( yScaleValue . active )     {", "particle . yScale    =     ( yScaleValue . newLowValue (  )  )     /    spriteHeight ;", "particle . yScaleDiff    =     ( yScaleValue . newHighValue (  )  )     /    spriteHeight ;", "if    (  !  ( yScaleValue . isRelative (  )  )  )", "particle . yScaleDiff    -  =    particle . yScale ;", "particle . setScale (  (  ( particle . xScale )     +     (  ( particle . xScaleDiff )     *     ( xScaleValue . getScale (  0  )  )  )  )  ,     (  ( particle . yScale )     +     (  ( particle . yScaleDiff )     *     ( yScaleValue . getScale (  0  )  )  )  )  )  ;", "} else    {", "particle . setScale (  (  ( particle . xScale )     +     (  ( particle . xScaleDiff )     *     ( xScaleValue . getScale (  0  )  )  )  )  )  ;", "}", "if    ( rotationValue . active )     {", "particle . rotation    =    rotationValue . newLowValue (  )  ;", "particle . rotationDiff    =    rotationValue . newHighValue (  )  ;", "if    (  !  ( rotationValue . isRelative (  )  )  )", "particle . rotationDiff    -  =    particle . rotation ;", "float   rotation    =     ( particle . rotation )     +     (  ( particle . rotationDiff )     *     ( rotationValue . getScale (  0  )  )  )  ;", "if    ( aligned )", "rotation    +  =    angle ;", "particle . setRotation ( rotation )  ;", "}", "if    ( windValue . active )     {", "particle . wind    =    windValue . newLowValue (  )  ;", "particle . windDiff    =    windValue . newHighValue (  )  ;", "if    (  !  ( windValue . isRelative (  )  )  )", "particle . windDiff    -  =    particle . wind ;", "}", "if    ( gravityValue . active )     {", "particle . gravity    =    gravityValue . newLowValue (  )  ;", "particle . gravityDiff    =    gravityValue . newHighValue (  )  ;", "if    (  !  ( gravityValue . isRelative (  )  )  )", "particle . gravityDiff    -  =    particle . gravity ;", "}", "float [  ]    color    =    particle . tint ;", "if    ( color    =  =    null )", "particle . tint    =    color    =    new   float [  3  ]  ;", "float [  ]    temp    =    tintValue . getColor (  0  )  ;", "color [  0  ]     =    temp [  0  ]  ;", "color [  1  ]     =    temp [  1  ]  ;", "color [  2  ]     =    temp [  2  ]  ;", "particle . transparency    =    transparencyValue . newLowValue (  )  ;", "particle . transparencyDiff    =     ( transparencyValue . newHighValue (  )  )     -     ( particle . transparency )  ;", "float   x    =    this . x ;", "if    ( xOffsetValue . active )", "x    +  =    xOffsetValue . newLowValue (  )  ;", "float   y    =    this . y ;", "if    ( yOffsetValue . active )", "y    +  =    yOffsetValue . newLowValue (  )  ;", "switch    ( spawnShapeValue . shape )     {", "case   square    :", "{", "float   width    =     ( spawnWidth )     +     (  ( spawnWidthDiff )     *     ( spawnWidthValue . getScale ( percent )  )  )  ;", "float   height    =     ( spawnHeight )     +     (  ( spawnHeightDiff )     *     ( spawnHeightValue . getScale ( percent )  )  )  ;", "x    +  =     ( MathUtils . random ( width )  )     -     ( width    /     2  )  ;", "y    +  =     ( MathUtils . random ( height )  )     -     ( height    /     2  )  ;", "break ;", "}", "case   ellipse    :", "{", "float   width    =     ( spawnWidth )     +     (  ( spawnWidthDiff )     *     ( spawnWidthValue . getScale ( percent )  )  )  ;", "float   height    =     ( spawnHeight )     +     (  ( spawnHeightDiff )     *     ( spawnHeightValue . getScale ( percent )  )  )  ;", "float   radiusX    =    width    /     2  ;", "float   radiusY    =    height    /     2  ;", "if    (  ( radiusX    =  =     0  )     |  |     ( radiusY    =  =     0  )  )", "break ;", "float   scaleY    =    radiusX    /     (  ( float )     ( radiusY )  )  ;", "if    ( spawnShapeValue . edges )     {", "float   spawnAngle ;", "switch    ( spawnShapeValue . side )     {", "case   top    :", "spawnAngle    =     -  ( MathUtils . random (  1  7  9  .  0 F )  )  ;", "break ;", "case   bottom    :", "spawnAngle    =    MathUtils . random (  1  7  9  .  0 F )  ;", "break ;", "default    :", "spawnAngle    =    MathUtils . random (  3  6  0  .  0 F )  ;", "break ;", "}", "float   cosDeg    =    MathUtils . cosDeg ( spawnAngle )  ;", "float   sinDeg    =    MathUtils . sinDeg ( spawnAngle )  ;", "x    +  =    cosDeg    *    radiusX ;", "y    +  =     ( sinDeg    *    radiusX )     /    scaleY ;", "if    (  ( updateFlags    &     (  . UPDATE _ ANGLE )  )     =  =     0  )     {", "particle . angle    =    spawnAngle ;", "particle . angleCos    =    cosDeg ;", "particle . angleSin    =    sinDeg ;", "}", "} else    {", "float   radius 2     =    radiusX    *    radiusX ;", "while    ( true )     {", "float   px    =     ( MathUtils . random ( width )  )     -    radiusX ;", "float   py    =     ( MathUtils . random ( height )  )     -    radiusY ;", "if    (  (  ( px    *    px )     +     ( py    *    py )  )     <  =    radius 2  )     {", "x    +  =    px ;", "y    +  =    py    /    scaleY ;", "break ;", "}", "}", "}", "break ;", "}", "case   line    :", "{", "float   width    =     ( spawnWidth )     +     (  ( spawnWidthDiff )     *     ( spawnWidthValue . getScale ( percent )  )  )  ;", "float   height    =     ( spawnHeight )     +     (  ( spawnHeightDiff )     *     ( spawnHeightValue . getScale ( percent )  )  )  ;", "if    ( width    !  =     0  )     {", "float   lineX    =    width    *     ( MathUtils . random (  )  )  ;", "x    +  =    lineX ;", "y    +  =    lineX    *     ( height    /     (  ( float )     ( width )  )  )  ;", "} else", "y    +  =    height    *     ( MathUtils . random (  )  )  ;", "break ;", "}", "}", "particle . setBounds (  ( x    -     ( spriteWidth    /     2  )  )  ,     ( y    -     ( spriteHeight    /     2  )  )  ,    spriteWidth ,    spriteHeight )  ;", "int   offsetTime    =     (  ( int )     (  ( lifeOffset )     +     (  ( lifeOffsetDiff )     *     ( lifeOffsetValue . getScale ( percent )  )  )  )  )  ;", "if    ( offsetTime    >     0  )     {", "if    ( offsetTime    >  =     ( particle . currentLife )  )", "offsetTime    =     ( particle . currentLife )     -     1  ;", "updateParticle ( particle ,     ( offsetTime    /     1  0  0  0  .  0 F )  ,    offsetTime )  ;", "}", "}", "METHOD_END"], "methodName": ["activateParticle"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "int   activeCount    =    this . activeCount ;", "if    ( activeCount    =  =     ( maxCount )  )", "return ;", "boolean [  ]    active    =    this . active ;", "for    ( int   i    =     0  ,    n    =    active . length ;    i    <    n ;    i +  +  )     {", "if    (  !  ( active [ i ]  )  )     {", "activate ( i )  ;", "active [ i ]     =    true ;", "this . activeCount    =    activeCount    +     1  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["addParticle"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "count    =    Math . min ( count ,     (  ( maxParticleCount )     -     ( activeCount )  )  )  ;", "if    ( count    =  =     0  )", "return ;", "boolean [  ]    active    =    this . active ;", "int   index    =     0  ;", "int   n    =    active . length ;", "outer    :    for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "for    (  ;    index    <    n ;    index +  +  )     {", "if    (  !  ( active [ index ]  )  )     {", "activateParticle ( index )  ;", "active [  ( index +  +  )  ]     =    true ;", "continue   outer ;", "}", "}", "break ;", "}", "this . activeCount    +  =    count ;", "}", "METHOD_END"], "methodName": ["addParticles"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "allowCompletion    =    true ;", "durationTimer    =    duration ;", "}", "METHOD_END"], "methodName": ["allowCompletion"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   cleansUpBlendFunction ;", "}", "METHOD_END"], "methodName": ["cleansUpBlendFunction"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    ( premultipliedAlpha )     {", "batch . setBlendFunction ( GL 2  0  . GL _ ONE ,    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA )  ;", "} else", "if    ( additive )     {", "batch . setBlendFunction ( GL 2  0  . GL _ SRC _ ALPHA ,    GL 2  0  . GL _ ONE )  ;", "} else    {", "batch . setBlendFunction ( GL 2  0  . GL _ SRC _ ALPHA ,    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA )  ;", "}", ". Particle [  ]    particles    =    this . particles ;", "boolean [  ]    active    =    this . active ;", "for    ( int   i    =     0  ,    n    =    active . length ;    i    <    n ;    i +  +  )     {", "if    ( active [ i ]  )", "particles [ i ]  . draw ( batch )  ;", "}", "if    (  ( cleansUpBlendFunction )     &  &     (  ( additive )     |  |     ( premultipliedAlpha )  )  )", "batch . setBlendFunction ( GL 2  0  . GL _ SRC _ ALPHA ,    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "accumulator    +  =    delta    *     1  0  0  0  ;", "if    (  ( accumulator )     <     1  )     {", "draw ( batch )  ;", "return ;", "}", "int   deltaMillis    =     (  ( int )     ( accumulator )  )  ;", "accumulator    -  =    deltaMillis ;", "if    ( premultipliedAlpha )     {", "batch . setBlendFunction ( GL 2  0  . GL _ ONE ,    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA )  ;", "} else", "if    ( additive )     {", "batch . setBlendFunction ( GL 2  0  . GL _ SRC _ ALPHA ,    GL 2  0  . GL _ ONE )  ;", "} else    {", "batch . setBlendFunction ( GL 2  0  . GL _ SRC _ ALPHA ,    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA )  ;", "}", ". Particle [  ]    particles    =    this . particles ;", "boolean [  ]    active    =    this . active ;", "int   activeCount    =    this . activeCount ;", "for    ( int   i    =     0  ,    n    =    active . length ;    i    <    n ;    i +  +  )     {", "if    ( active [ i ]  )     {", ". Particle   particle    =    particles [ i ]  ;", "if    ( updateParticle ( particle ,    delta ,    deltaMillis )  )", "particle . draw ( batch )  ;", "else    {", "active [ i ]     =    false ;", "activeCount -  -  ;", "}", "}", "}", "this . activeCount    =    activeCount ;", "if    (  ( cleansUpBlendFunction )     &  &     (  ( additive )     |  |     ( premultipliedAlpha )  )  )", "batch . setBlendFunction ( GL 2  0  . GL _ SRC _ ALPHA ,    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA )  ;", "if    (  ( delayTimer )     <     ( delay )  )     {", "delayTimer    +  =    deltaMillis ;", "return ;", "}", "if    ( firstUpdate )     {", "firstUpdate    =    false ;", "addParticle (  )  ;", "}", "if    (  ( durationTimer )     <     ( duration )  )", "durationTimer    +  =    deltaMillis ;", "else    {", "if    (  (  !  ( continuous )  )     |  |     ( allowCompletion )  )", "return ;", "restart (  )  ;", "}", "emissionDelta    +  =    deltaMillis ;", "float   emissionTime    =     ( emission )     +     (  ( emissionDiff )     *     ( emissionValue . getScale (  (  ( durationTimer )     /     (  ( float )     ( duration )  )  )  )  )  )  ;", "if    ( emissionTime    >     0  )     {", "emissionTime    =     1  0  0  0     /    emissionTime ;", "if    (  ( emissionDelta )     >  =    emissionTime )     {", "int   emitCount    =     (  ( int )     (  ( emissionDelta )     /    emissionTime )  )  ;", "emitCount    =    Math . min ( emitCount ,     (  ( maxParticleCount )     -    activeCount )  )  ;", "emissionDelta    -  =    emitCount    *    emissionTime ;", "emissionDelta    %  =    emissionTime ;", "addParticles ( emitCount )  ;", "}", "}", "if    ( activeCount    <     ( minParticleCount )  )", "addParticles (  (  ( minParticleCount )     -    activeCount )  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "angleValue . setHigh (  (  -  ( angleValue . getHighMin (  )  )  )  ,     (  -  ( angleValue . getHighMax (  )  )  )  )  ;", "angleValue . setLow (  (  -  ( angleValue . getLowMin (  )  )  )  ,     (  -  ( angleValue . getLowMax (  )  )  )  )  ;", "vityValue . setHigh (  (  -  ( vityValue . getHighMin (  )  )  )  ,     (  -  ( vityValue . getHighMax (  )  )  )  )  ;", "vityValue . setLow (  (  -  ( vityValue . getLowMin (  )  )  )  ,     (  -  ( vityValue . getLowMax (  )  )  )  )  ;", "windValue . setHigh (  (  -  ( windValue . getHighMin (  )  )  )  ,     (  -  ( windValue . getHighMax (  )  )  )  )  ;", "windValue . setLow (  (  -  ( windValue . getLowMin (  )  )  )  ,     (  -  ( windValue . getLowMax (  )  )  )  )  ;", "rotationValue . setHigh (  (  -  ( rotationValue . getHighMin (  )  )  )  ,     (  -  ( rotationValue . getHighMax (  )  )  )  )  ;", "rotationValue . setLow (  (  -  ( rotationValue . getLowMin (  )  )  )  ,     (  -  ( rotationValue . getLowMax (  )  )  )  )  ;", "yOffsetValue . setLow (  (  -  ( yOffsetValue . getLowMin (  )  )  )  ,     (  -  ( yOffsetValue . getLowMax (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["flipY"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   activeCount ;", "}", "METHOD_END"], "methodName": ["getActiveCount"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   angleValue ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bounds )     =  =    null )", "bounds    =    new   BoundingBox (  )  ;", "ParticleEmitter . Particle [  ]    particles    =    this . particles ;", "boolean [  ]    active    =    this . active ;", "BoundingBox   bounds    =    this . bounds ;", "bounds . inf (  )  ;", "for    ( int   i    =     0  ,    n    =    active . length ;    i    <    n ;    i +  +  )", "if    ( active [ i ]  )     {", "math . Rectangle   r    =    particles [ i ]  . getBoundingRectangle (  )  ;", "bounds . ext ( r . x ,    r . y ,     0  )  ;", "bounds . ext (  (  ( r . x )     +     ( r . width )  )  ,     (  ( r . y )     +     ( r . height )  )  ,     0  )  ;", "}", "return   bounds ;", "}", "METHOD_END"], "methodName": ["getBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   delayValue ;", "}", "METHOD_END"], "methodName": ["getDelay"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   durationValue ;", "}", "METHOD_END"], "methodName": ["getDuration"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   emissionValue ;", "}", "METHOD_END"], "methodName": ["getEmission"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   gravityValue ;", "}", "METHOD_END"], "methodName": ["getGravity"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   imagePaths ;", "}", "METHOD_END"], "methodName": ["getImagePaths"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   lifeValue ;", "}", "METHOD_END"], "methodName": ["getLife"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   lifeOffsetValue ;", "}", "METHOD_END"], "methodName": ["getLifeOffset"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   maxParticleCount ;", "}", "METHOD_END"], "methodName": ["getMaxParticleCount"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   minParticleCount ;", "}", "METHOD_END"], "methodName": ["getMinParticleCount"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( motionValues )     =  =    null )     {", "motionValues    =    new    . RangedNumericValue [  3  ]  ;", "motionValues [  0  ]     =    velocityValue ;", "motionValues [  1  ]     =    windValue ;", "motionValues [  2  ]     =    gravityValue ;", "}", "return   motionValues ;", "}", "METHOD_END"], "methodName": ["getMotionValues"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   particles ;", "}", "METHOD_END"], "methodName": ["getParticles"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( delayTimer )     <     ( delay )  )", "return    0  ;", "return   Math . min (  1  ,     (  ( durationTimer )     /     (  ( float )     ( duration )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPercentComplete"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   rotationValue ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   spawnHeightValue ;", "}", "METHOD_END"], "methodName": ["getSpawnHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   spawnShapeValue ;", "}", "METHOD_END"], "methodName": ["getSpawnShape"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   spawnWidthValue ;", "}", "METHOD_END"], "methodName": ["getSpawnWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   spriteMode ;", "}", "METHOD_END"], "methodName": ["getSpriteMode"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   sprites ;", "}", "METHOD_END"], "methodName": ["getSprites"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   tintValue ;", "}", "METHOD_END"], "methodName": ["getTint"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   transparencyValue ;", "}", "METHOD_END"], "methodName": ["getTransparency"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   velocityValue ;", "}", "METHOD_END"], "methodName": ["getVelocity"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   windValue ;", "}", "METHOD_END"], "methodName": ["getWind"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   xOffsetValue ;", "}", "METHOD_END"], "methodName": ["getXOffsetValue"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   xScaleValue ;", "}", "METHOD_END"], "methodName": ["getXScale"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( xSizeValues )     =  =    null )     {", "xSizeValues    =    new    . RangedNumericValue [  3  ]  ;", "xSizeValues [  0  ]     =    xScaleValue ;", "xSizeValues [  1  ]     =    spawnWidthValue ;", "xSizeValues [  2  ]     =    xOffsetValue ;", "}", "return   xSizeValues ;", "}", "METHOD_END"], "methodName": ["getXSizeValues"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   yOffsetValue ;", "}", "METHOD_END"], "methodName": ["getYOffsetValue"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   yScaleValue ;", "}", "METHOD_END"], "methodName": ["getYScale"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ySizeValues )     =  =    null )     {", "ySizeValues    =    new    . RangedNumericValue [  3  ]  ;", "ySizeValues [  0  ]     =    yScaleValue ;", "ySizeValues [  1  ]     =    spawnHeightValue ;", "ySizeValues [  2  ]     =    yOffsetValue ;", "}", "return   ySizeValues ;", "}", "METHOD_END"], "methodName": ["getYSizeValues"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "sprites    =    new   Array < Sprite >  (  )  ;", "imagePaths    =    new   Array < String >  (  )  ;", "durationValue . setAlwaysActive ( true )  ;", "emissionValue . setAlwaysActive ( true )  ;", "lifeValue . setAlwaysActive ( true )  ;", "xScaleValue . setAlwaysActive ( true )  ;", "transparencyValue . setAlwaysActive ( true )  ;", "spawnShapeValue . setAlwaysActive ( true )  ;", "spawnWidthValue . setAlwaysActive ( true )  ;", "spawnHeightValue . setAlwaysActive ( true )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   additive ;", "}", "METHOD_END"], "methodName": ["isAdditive"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   aligned ;", "}", "METHOD_END"], "methodName": ["isAligned"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   attached ;", "}", "METHOD_END"], "methodName": ["isAttached"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   behind ;", "}", "METHOD_END"], "methodName": ["isBehind"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( continuous )     &  &     (  !  ( allowCompletion )  )  )", "return   false ;", "if    (  ( delayTimer )     <     ( delay )  )", "return   false ;", "return    (  ( durationTimer )     >  =     ( duration )  )     &  &     (  ( activeCount )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   continuous ;", "}", "METHOD_END"], "methodName": ["isContinuous"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   premultipliedAlpha ;", "}", "METHOD_END"], "methodName": ["isPremultipliedAlpha"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "try    {", "name    =     . readString ( reader ,     \" name \"  )  ;", "reader . readLine (  )  ;", "delayValue . load ( reader )  ;", "reader . readLine (  )  ;", "durationValue . load ( reader )  ;", "reader . readLine (  )  ;", "setMinParticleCount (  . readInt ( reader ,     \" minParticleCount \"  )  )  ;", "setMaxParticleCount (  . readInt ( reader ,     \" maxParticleCount \"  )  )  ;", "reader . readLine (  )  ;", "emissionValue . load ( reader )  ;", "reader . readLine (  )  ;", "lifeValue . load ( reader )  ;", "reader . readLine (  )  ;", "lifeOffsetValue . load ( reader )  ;", "reader . readLine (  )  ;", "xOffsetValue . load ( reader )  ;", "reader . readLine (  )  ;", "yOffsetValue . load ( reader )  ;", "reader . readLine (  )  ;", "spawnShapeValue . load ( reader )  ;", "reader . readLine (  )  ;", "spawnWidthValue . load ( reader )  ;", "reader . readLine (  )  ;", "spawnHeightValue . load ( reader )  ;", "String   line    =    reader . readLine (  )  ;", "if    ( line . trim (  )  . equals (  \"  -    Scale    -  \"  )  )     {", "xScaleValue . load ( reader )  ;", "yScaleValue . setActive ( false )  ;", "} else    {", "xScaleValue . load ( reader )  ;", "reader . readLine (  )  ;", "yScaleValue . load ( reader )  ;", "}", "reader . readLine (  )  ;", "velocityValue . load ( reader )  ;", "reader . readLine (  )  ;", "angleValue . load ( reader )  ;", "reader . readLine (  )  ;", "rotationValue . load ( reader )  ;", "reader . readLine (  )  ;", "windValue . load ( reader )  ;", "reader . readLine (  )  ;", "gravityValue . load ( reader )  ;", "reader . readLine (  )  ;", "tintValue . load ( reader )  ;", "reader . readLine (  )  ;", "transparencyValue . load ( reader )  ;", "reader . readLine (  )  ;", "attached    =     . readBoolean ( reader ,     \" attached \"  )  ;", "continuous    =     . readBoolean ( reader ,     \" continuous \"  )  ;", "aligned    =     . readBoolean ( reader ,     \" aligned \"  )  ;", "additive    =     . readBoolean ( reader ,     \" additive \"  )  ;", "behind    =     . readBoolean ( reader ,     \" behind \"  )  ;", "line    =    reader . readLine (  )  ;", "if    ( line . startsWith (  \" premultipliedAlpha \"  )  )     {", "premultipliedAlpha    =     . readBoolean ( line )  ;", "line    =    reader . readLine (  )  ;", "}", "if    ( line . startsWith (  \" spriteMode \"  )  )     {", "spriteMode    =     . SpriteMode . valueOf (  . readString ( line )  )  ;", "line    =    reader . readLine (  )  ;", "}", "Array < String >    imagePaths    =    new   Array < String >  (  )  ;", "while    (  (  ( line    =    reader . readLine (  )  )     !  =    null )     &  &     (  !  ( line . isEmpty (  )  )  )  )     {", "imagePaths . add ( line )  ;", "}", "setImagePaths ( imagePaths )  ;", "}    catch    ( RuntimeException   ex )     {", "if    (  ( name )     =  =    null )", "throw   ex ;", "throw   new   RuntimeException (  (  \" Error   parsing   emitter :     \"     +     ( name )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "ParticleEmitter . RangedNumericValue [  ]    values    =    getMotionValues (  )  ;", "ParticleEmitter . RangedNumericValue [  ]    templateValues    =    template . getMotionValues (  )  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )     {", "values [ i ]  . set ( templateValues [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["matchMotion"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "matchXSize ( template )  ;", "matchYSize ( template )  ;", "}", "METHOD_END"], "methodName": ["matchSize"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "ParticleEmitter . RangedNumericValue [  ]    values    =    getXSizeValues (  )  ;", "ParticleEmitter . RangedNumericValue [  ]    templateValues    =    template . getXSizeValues (  )  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )     {", "values [ i ]  . set ( templateValues [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["matchXSize"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "ParticleEmitter . RangedNumericValue [  ]    values    =    getYSizeValues (  )  ;", "ParticleEmitter . RangedNumericValue [  ]    templateValues    =    template . getYSizeValues (  )  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )     {", "values [ i ]  . set ( templateValues [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["matchYSize"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   new   ParticleEmitter . Particle ( sprite )  ;", "}", "METHOD_END"], "methodName": ["newParticle"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . parseBoolean ( ParticleEmitter . readString ( reader ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["readBoolean"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . parseBoolean ( ParticleEmitter . readString ( line )  )  ;", "}", "METHOD_END"], "methodName": ["readBoolean"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   Float . parseFloat ( ParticleEmitter . readString ( reader ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["readFloat"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   Integer . parseInt ( ParticleEmitter . readString ( reader ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "String   line    =    reader . readLine (  )  ;", "if    ( line    =  =    null )", "throw   new   IOException (  (  \" Missing   value :     \"     +    name )  )  ;", "return    . readString ( line )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "return   line . substring (  (  ( line . indexOf (  \"  :  \"  )  )     +     1  )  )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "emissionDelta    =     0  ;", "durationTimer    =    duration ;", "boolean [  ]    active    =    this . active ;", "for    ( int   i    =     0  ,    n    =    active . length ;    i    <    n ;    i +  +  )", "active [ i ]     =    false ;", "activeCount    =     0  ;", "st (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "delay    =     ( delayValue . active )     ?    delayValue . newLowValue (  )     :     0  ;", "delayTimer    =     0  ;", "durationTimer    -  =    duration ;", "duration    =    durationValue . newLowValue (  )  ;", "emission    =     (  ( int )     ( emissionValue . newLowValue (  )  )  )  ;", "emissionDiff    =     (  ( int )     ( emissionValue . newHighValue (  )  )  )  ;", "if    (  !  ( emissionValue . isRelative (  )  )  )", "emissionDiff    -  =    emission ;", "life    =     (  ( int )     ( lifeValue . newLowValue (  )  )  )  ;", "lifeDiff    =     (  ( int )     ( lifeValue . newHighValue (  )  )  )  ;", "if    (  !  ( lifeValue . isRelative (  )  )  )", "lifeDiff    -  =    life ;", "lifeOffset    =     ( lifeOffsetValue . active )     ?     (  ( int )     ( lifeOffsetValue . newLowValue (  )  )  )     :     0  ;", "lifeOffsetDiff    =     (  ( int )     ( lifeOffsetValue . newHighValue (  )  )  )  ;", "if    (  !  ( lifeOffsetValue . isRelative (  )  )  )", "lifeOffsetDiff    -  =    lifeOffset ;", "spawnWidth    =    spawnWidthValue . newLowValue (  )  ;", "spawnWidthDiff    =    spawnWidthValue . newHighValue (  )  ;", "if    (  !  ( spawnWidthValue . isRelative (  )  )  )", "spawnWidthDiff    -  =    spawnWidth ;", "spawnHeight    =    spawnHeightValue . newLowValue (  )  ;", "spawnHeightDiff    =    spawnHeightValue . newHighValue (  )  ;", "if    (  !  ( spawnHeightValue . isRelative (  )  )  )", "spawnHeightDiff    -  =    spawnHeight ;", "updateFlags    =     0  ;", "if    (  ( angleValue . active )     &  &     (  ( angleValue . timeline . length )     >     1  )  )", "updateFlags    |  =     . UPDATE _ ANGLE ;", "if    ( velocityValue . active )", "updateFlags    |  =     . UPDATE _ VELOCITY ;", "if    (  ( xScaleValue . timeline . length )     >     1  )", "updateFlags    |  =     . UPDATE _ SCALE ;", "if    (  ( yScaleValue . active )     &  &     (  ( yScaleValue . timeline . length )     >     1  )  )", "updateFlags    |  =     . UPDATE _ SCALE ;", "if    (  ( rotationValue . active )     &  &     (  ( rotationValue . timeline . length )     >     1  )  )", "updateFlags    |  =     . UPDATE _ ROTATION ;", "if    ( windValue . active )", "updateFlags    |  =     . UPDATE _ WIND ;", "if    ( gravityValue . active )", "updateFlags    |  =     . UPDATE _ GRAVITY ;", "if    (  ( tintValue . timeline . length )     >     1  )", "updateFlags    |  =     . UPDATE _ TINT ;", "if    (  ( spriteMode )     =  =     (  . SpriteMode . animated )  )", "updateFlags    |  =     . UPDATE _ SPRITE ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "output . write (  (  ( name )     +     \"  \\ n \"  )  )  ;", "output . write (  \"  -    Delay    -  \\ n \"  )  ;", "delayValue . save ( output )  ;", "output . write (  \"  -    Duration    -     \\ n \"  )  ;", "durationValue . save ( output )  ;", "output . write (  \"  -    Count    -     \\ n \"  )  ;", "output . write (  (  (  \" min :     \"     +     ( minCount )  )     +     \"  \\ n \"  )  )  ;", "output . write (  (  (  \" max :     \"     +     ( maxCount )  )     +     \"  \\ n \"  )  )  ;", "output . write (  \"  -    Emission    -     \\ n \"  )  ;", "emissionValue . save ( output )  ;", "output . write (  \"  -    Life    -     \\ n \"  )  ;", "lifeValue . save ( output )  ;", "output . write (  \"  -    Life   Offset    -     \\ n \"  )  ;", "lifeOffsetValue . save ( output )  ;", "output . write (  \"  -    X   Offset    -     \\ n \"  )  ;", "xOffsetValue . save ( output )  ;", "output . write (  \"  -    Y   Offset    -     \\ n \"  )  ;", "yOffsetValue . save ( output )  ;", "output . write (  \"  -    Spawn   Shape    -     \\ n \"  )  ;", "spawnShapeValue . save ( output )  ;", "output . write (  \"  -    Spawn   Width    -     \\ n \"  )  ;", "spawnWidthValue . save ( output )  ;", "output . write (  \"  -    Spawn   Height    -     \\ n \"  )  ;", "spawnHeightValue . save ( output )  ;", "output . write (  \"  -    X   Scale    -     \\ n \"  )  ;", "xScaleValue . save ( output )  ;", "output . write (  \"  -    Y   Scale    -     \\ n \"  )  ;", "yScaleValue . save ( output )  ;", "output . write (  \"  -    Velocity    -     \\ n \"  )  ;", "velocityValue . save ( output )  ;", "output . write (  \"  -    Angle    -     \\ n \"  )  ;", "angleValue . save ( output )  ;", "output . write (  \"  -    Rotation    -     \\ n \"  )  ;", "rotationValue . save ( output )  ;", "output . write (  \"  -    Wind    -     \\ n \"  )  ;", "windValue . save ( output )  ;", "output . write (  \"  -    Gravity    -     \\ n \"  )  ;", "gravityValue . save ( output )  ;", "output . write (  \"  -    Tint    -     \\ n \"  )  ;", "tintValue . save ( output )  ;", "output . write (  \"  -    Transparency    -     \\ n \"  )  ;", "transparencyValue . save ( output )  ;", "output . write (  \"  -    Options    -     \\ n \"  )  ;", "output . write (  (  (  \" attached :     \"     +     ( attached )  )     +     \"  \\ n \"  )  )  ;", "output . write (  (  (  \" continuous :     \"     +     ( continuous )  )     +     \"  \\ n \"  )  )  ;", "output . write (  (  (  \" aligned :     \"     +     ( aligned )  )     +     \"  \\ n \"  )  )  ;", "output . write (  (  (  \" additive :     \"     +     ( additive )  )     +     \"  \\ n \"  )  )  ;", "output . write (  (  (  \" behind :     \"     +     ( behind )  )     +     \"  \\ n \"  )  )  ;", "output . write (  (  (  \" premultipliedAlpha :     \"     +     ( premultipliedAlpha )  )     +     \"  \\ n \"  )  )  ;", "output . write (  (  (  \" spriteMode :     \"     +     ( spriteMode . toString (  )  )  )     +     \"  \\ n \"  )  )  ;", "output . write (  \"  -    Image   Paths    -  \\ n \"  )  ;", "for    ( String   imagePath    :    imagePaths )     {", "output . write (  ( imagePath    +     \"  \\ n \"  )  )  ;", "}", "output . write (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    ( scale    =  =     1  .  0 F )", "return ;", "for    (  . RangedNumericValue   value    :    getMotionValues (  )  )", "value . scale ( scale )  ;", "}", "METHOD_END"], "methodName": ["scaleMotion"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    ( scale    =  =     1  .  0 F )", "return ;", "scaleSize ( scale ,    scale )  ;", "}", "METHOD_END"], "methodName": ["scaleSize"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( scaleX    =  =     1  .  0 F )     &  &     ( scaleY    =  =     1  .  0 F )  )", "return ;", "for    (  . RangedNumericValue   value    :    getXSizeValues (  )  )", "value . scale ( scaleX )  ;", "for    (  . RangedNumericValue   value    :    getYSizeValues (  )  )", "value . scale ( scaleY )  ;", "}", "METHOD_END"], "methodName": ["scaleSize"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . additive    =    additive ;", "}", "METHOD_END"], "methodName": ["setAdditive"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . aligned    =    aligned ;", "}", "METHOD_END"], "methodName": ["setAligned"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . attached    =    attached ;", "}", "METHOD_END"], "methodName": ["setAttached"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . behind    =    behind ;", "}", "METHOD_END"], "methodName": ["setBehind"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . cleansUpBlendFunction    =    cleansUpBlendFunction ;", "}", "METHOD_END"], "methodName": ["setCleansUpBlendFunction"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . continuous    =    continuous ;", "}", "METHOD_END"], "methodName": ["setContinuous"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . flipX    =    flipX ;", "this . flipY    =    flipY ;", "if    (  ( particles )     =  =    null )", "return ;", "for    ( int   i    =     0  ,    n    =    particles . length ;    i    <    n ;    i +  +  )     {", ". Particle   particle    =    particles [ i ]  ;", "if    ( particle    !  =    null )", "particle . flip ( flipX ,    flipY )  ;", "}", "}", "METHOD_END"], "methodName": ["setFlip"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . imagePaths    =    imagePaths ;", "}", "METHOD_END"], "methodName": ["setImagePaths"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . maxParticleCount    =    maxParticleCount ;", "active    =    new   boolean [ maxParticleCount ]  ;", "activeCount    =     0  ;", "particles    =    new    . Particle [ maxParticleCount ]  ;", "}", "METHOD_END"], "methodName": ["setMaxParticleCount"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . minParticleCount    =    minParticleCount ;", "}", "METHOD_END"], "methodName": ["setMinParticleCount"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "if    ( attached )     {", "float   xAmount    =    x    -     ( this . x )  ;", "float   yAmount    =    y    -     ( this . y )  ;", "boolean [  ]    active    =    this . active ;", "for    ( int   i    =     0  ,    n    =    active . length ;    i    <    n ;    i +  +  )", "if    ( active [ i ]  )", "ps [ i ]  . translate ( xAmount ,    yAmount )  ;", "}", "this . x    =    x ;", "this . y    =    y ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . premultipliedAlpha    =    premultipliedAlpha ;", "}", "METHOD_END"], "methodName": ["setPremultipliedAlpha"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . spriteMode    =    spriteMode ;", "}", "METHOD_END"], "methodName": ["setSpriteMode"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "this . sprites    =    sprites ;", "if    (  ( sprites . size )     =  =     0  )", "return ;", "for    ( int   i    =     0  ,    n    =    particles . length ;    i    <    n ;    i +  +  )     {", ". Particle   particle    =    particles [ i ]  ;", "if    ( particle    =  =    null )", "break ;", "Sprite   sprite    =    null ;", "switch    ( spriteMode )     {", "case   single    :", "sprite    =    sprites . first (  )  ;", "break ;", "case   random    :", "sprite    =    sprites . random (  )  ;", "break ;", "case   animated    :", "float   percent    =     1     -     (  ( particle . currentLife )     /     (  ( float )     ( particle . life )  )  )  ;", "particle . frame    =    Math . min (  (  ( int )     ( percent    *     ( sprites . size )  )  )  ,     (  ( sprites . size )     -     1  )  )  ;", "sprite    =    sprites . get ( particle . frame )  ;", "break ;", "}", "particle . setRegion ( sprite )  ;", "particle . setOrigin ( sprite . getOriginX (  )  ,    sprite . getOriginY (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSprites"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "firstUpdate    =    true ;", "allowCompletion    =    false ;", "rest (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "accumulator    +  =    delta    *     1  0  0  0  ;", "if    (  ( accumulator )     <     1  )", "return ;", "int   deltaMillis    =     (  ( int )     ( accumulator )  )  ;", "accumulator    -  =    deltaMillis ;", "if    (  ( delayTimer )     <     ( delay )  )     {", "delayTimer    +  =    deltaMillis ;", "} else    {", "boolean   done    =    false ;", "if    ( firstUpdate )     {", "firstUpdate    =    false ;", "addParticle (  )  ;", "}", "if    (  ( durationTimer )     <     ( duration )  )", "durationTimer    +  =    deltaMillis ;", "else    {", "if    (  (  !  ( continuous )  )     |  |     ( allowCompletion )  )", "done    =    true ;", "else", "restart (  )  ;", "}", "if    (  ! done )     {", "emissionDelta    +  =    deltaMillis ;", "float   emissionTime    =     ( emission )     +     (  ( emissionDiff )     *     ( emissionValue . getScale (  (  ( durationTimer )     /     (  ( float )     ( duration )  )  )  )  )  )  ;", "if    ( emissionTime    >     0  )     {", "emissionTime    =     1  0  0  0     /    emissionTime ;", "if    (  ( emissionDelta )     >  =    emissionTime )     {", "int   emitCount    =     (  ( int )     (  ( emissionDelta )     /    emissionTime )  )  ;", "emitCount    =    Math . min ( emitCount ,     (  ( maxParticleCount )     -     ( activeCount )  )  )  ;", "emissionDelta    -  =    emitCount    *    emissionTime ;", "emissionDelta    %  =    emissionTime ;", "addParticles ( emitCount )  ;", "}", "}", "if    (  ( activeCount )     <     ( minParticleCount )  )", "addParticles (  (  ( minParticleCount )     -     ( activeCount )  )  )  ;", "}", "}", "boolean [  ]    active    =    this . active ;", "int   activeCount    =    this . activeCount ;", ". Particle [  ]    particles    =    this . particles ;", "for    ( int   i    =     0  ,    n    =    active . length ;    i    <    n ;    i +  +  )     {", "if    (  ( active [ i ]  )     &  &     (  !  ( updateParticle ( particles [ i ]  ,    delta ,    deltaMillis )  )  )  )     {", "active [ i ]     =    false ;", "activeCount -  -  ;", "}", "}", "this . activeCount    =    activeCount ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "int   life    =     ( particle . currentLife )     -    deltaMillis ;", "if    ( life    <  =     0  )", "return   false ;", "particle . currentLife    =    life ;", "float   percent    =     1     -     (  ( particle . currentLife )     /     (  ( float )     ( particle . life )  )  )  ;", "int   updateFlags    =    this . updateFlags ;", "if    (  ( updateFlags    &     (  . UPDATE _ SCALE )  )     !  =     0  )     {", "if    ( yScaleValue . active )     {", "particle . setScale (  (  ( particle . xScale )     +     (  ( particle . xScaleDiff )     *     ( xScaleValue . getScale ( percent )  )  )  )  ,     (  ( particle . yScale )     +     (  ( particle . yScaleDiff )     *     ( yScaleValue . getScale ( percent )  )  )  )  )  ;", "} else    {", "particle . setScale (  (  ( particle . xScale )     +     (  ( particle . xScaleDiff )     *     ( xScaleValue . getScale ( percent )  )  )  )  )  ;", "}", "}", "if    (  ( updateFlags    &     (  . UPDATE _ VELOCITY )  )     !  =     0  )     {", "float   velocity    =     (  ( particle . velocity )     +     (  ( particle . velocityDiff )     *     ( velocityValue . getScale ( percent )  )  )  )     *    delta ;", "float   velocityX ;", "float   velocityY ;", "if    (  ( updateFlags    &     (  . UPDATE _ ANGLE )  )     !  =     0  )     {", "float   angle    =     ( particle . angle )     +     (  ( particle . angleDiff )     *     ( angleValue . getScale ( percent )  )  )  ;", "velocityX    =    velocity    *     ( MathUtils . cosDeg ( angle )  )  ;", "velocityY    =    velocity    *     ( MathUtils . sinDeg ( angle )  )  ;", "if    (  ( updateFlags    &     (  . UPDATE _ ROTATION )  )     !  =     0  )     {", "float   rotation    =     ( particle . rotation )     +     (  ( particle . rotationDiff )     *     ( rotationValue . getScale ( percent )  )  )  ;", "if    ( aligned )", "rotation    +  =    angle ;", "particle . setRotation ( rotation )  ;", "}", "} else    {", "velocityX    =    velocity    *     ( particle . angleCos )  ;", "velocityY    =    velocity    *     ( particle . angleSin )  ;", "if    (  ( aligned )     |  |     (  ( updateFlags    &     (  . UPDATE _ ROTATION )  )     !  =     0  )  )     {", "float   rotation    =     ( particle . rotation )     +     (  ( particle . rotationDiff )     *     ( rotationValue . getScale ( percent )  )  )  ;", "if    ( aligned )", "rotation    +  =    particle . angle ;", "particle . setRotation ( rotation )  ;", "}", "}", "if    (  ( updateFlags    &     (  . UPDATE _ WIND )  )     !  =     0  )", "velocityX    +  =     (  ( particle . wind )     +     (  ( particle . windDiff )     *     ( windValue . getScale ( percent )  )  )  )     *    delta ;", "if    (  ( updateFlags    &     (  . UPDATE _ GRAVITY )  )     !  =     0  )", "velocityY    +  =     (  ( particle . gravity )     +     (  ( particle . gravityDiff )     *     ( gravityValue . getScale ( percent )  )  )  )     *    delta ;", "particle . translate ( velocityX ,    velocityY )  ;", "} else    {", "if    (  ( updateFlags    &     (  . UPDATE _ ROTATION )  )     !  =     0  )", "particle . setRotation (  (  ( particle . rotation )     +     (  ( particle . rotationDiff )     *     ( rotationValue . getScale ( percent )  )  )  )  )  ;", "}", "float [  ]    color ;", "if    (  ( updateFlags    &     (  . UPDATE _ TINT )  )     !  =     0  )", "color    =    tintValue . getColor ( percent )  ;", "else", "color    =    particle . tint ;", "if    ( premultipliedAlpha )     {", "float   alphaMultiplier    =     ( additive )     ?     0     :     1  ;", "float   a    =     ( particle . transparency )     +     (  ( particle . transparencyDiff )     *     ( transparencyValue . getScale ( percent )  )  )  ;", "particle . setColor (  (  ( color [  0  ]  )     *    a )  ,     (  ( color [  1  ]  )     *    a )  ,     (  ( color [  2  ]  )     *    a )  ,     ( a    *    alphaMultiplier )  )  ;", "} else    {", "particle . setColor ( color [  0  ]  ,    color [  1  ]  ,    color [  2  ]  ,     (  ( particle . transparency )     +     (  ( particle . transparencyDiff )     *     ( transparencyValue . getScale ( percent )  )  )  )  )  ;", "}", "if    (  ( updateFlags    &     (  . UPDATE _ SPRITE )  )     !  =     0  )     {", "int   frame    =    Math . min (  (  ( int )     ( percent    *     ( sprites . size )  )  )  ,     (  ( sprites . size )     -     1  )  )  ;", "if    (  ( particle . frame )     !  =    frame )     {", "Sprite   sprite    =    sprites . get ( frame )  ;", "float   prevSpriteWidth    =    particle . getWidth (  )  ;", "float   prevSpriteHeight    =    particle . getHeight (  )  ;", "particle . setRegion ( sprite )  ;", "particle . setSize ( sprite . getWidth (  )  ,    sprite . getHeight (  )  )  ;", "particle . setOrigin ( sprite . getOriginX (  )  ,    sprite . getOriginY (  )  )  ;", "particle . translate (  (  ( prevSpriteWidth    -     ( sprite . getWidth (  )  )  )     /     2  )  ,     (  ( prevSpriteHeight    -     ( sprite . getHeight (  )  )  )     /     2  )  )  ;", "particle . frame    =    frame ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["updateParticle"], "fileName": "com.badlogic.gdx.graphics.g2d.ParticleEmitter"}, {"methodBody": ["METHOD_START", "{", "for    ( PixmapPacker . Page   page    :    pages )     {", "if    (  ( page . texture )     =  =    null )     {", "page . image . dispose (  )  ;", "}", "}", "disposed    =    true ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "TextureAtlas   atlas    =    new   TextureAtlas (  )  ;", "updateTextureAtlas ( atlas ,    minFilter ,    magFilter ,    useMipMs )  ;", "return   atlas ;", "}", "METHOD_END"], "methodName": ["generateTextureAtlas"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   duplicateBorder ;", "}", "METHOD_END"], "methodName": ["getDuplicateBorder"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   packToTexture ;", "}", "METHOD_END"], "methodName": ["getPackToTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   padding ;", "}", "METHOD_END"], "methodName": ["getPadding"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "for    ( PixmapPacker . Page   page    :    pages )     {", "Rectangle   rect    =    page . rects . get ( name )  ;", "if    ( rect    !  =    null )", "return   page ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPage"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   pageFormat ;", "}", "METHOD_END"], "methodName": ["getPageFormat"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   pageHeight ;", "}", "METHOD_END"], "methodName": ["getPageHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( pages . size )  ;    i +  +  )     {", "Rectangle   rect    =    pageet ( i )  . rectet ( name )  ;", "if    ( rect    !  =    null )", "return   i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getPageIndex"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   pageWidth ;", "}", "METHOD_END"], "methodName": ["getPageWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   pages ;", "}", "METHOD_END"], "methodName": ["getPages"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "for    ( PixmapPacker . Page   page    :    pages )     {", "Rectangle   rect    =    page . rects . get ( name )  ;", "if    ( rect    !  =    null )", "return   rect ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getRect"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   this . transparentColor ;", "}", "METHOD_END"], "methodName": ["getTransparentColor"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "return   pack ( null ,    image )  ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "if    ( disposed )", "return   null ;", "if    (  ( name    !  =    null )     &  &     (  ( getRect ( name )  )     !  =    null )  )", "throw   new   GdxRuntimeException (  (  \" Pixmap   has   already   been   packed   with   name :     \"     +    name )  )  ;", "Rectangle   rect    =    new   Rectangle (  0  ,     0  ,    image . getWidth (  )  ,    image . getHeight (  )  )  ;", "if    (  (  ( rect . getWidth (  )  )     >     ( pageWidth )  )     |  |     (  ( rect . getHeight (  )  )     >     ( pageHeight )  )  )     {", "if    ( name    =  =    null )", "throw   new   GdxRuntimeException (  \" Page   size   too   small   for   pixmap .  \"  )  ;", "throw   new   GdxRuntimeException (  (  \" Page   size   too   small   for   pixmap :     \"     +    name )  )  ;", "}", ". Page   page    =    packStrategy . pack ( this ,    name ,    rect )  ;", "if    ( name    !  =    null )     {", "page . rects . put ( name ,    rect )  ;", "page . addedRects . add ( name )  ;", "}", "int   rectX    =     (  ( int )     ( rect . x )  )  ;", "int   rectY    =     (  ( int )     ( rect . y )  )  ;", "int   rectWidth    =     (  ( int )     ( rect . width )  )  ;", "int   rectHeight    =     (  ( int )     ( rect . height )  )  ;", "if    (  (  (  ( packToTexture )     &  &     (  !  ( duplicateBorder )  )  )     &  &     (  ( page . texture )     !  =    null )  )     &  &     (  !  ( page . dirty )  )  )     {", "page . texture . bind (  )  ;", "Gdx . gl . glTexSubImage 2 D ( page . texture . glTarget ,     0  ,    rectX ,    rectY ,    rectWidth ,    rectHeight ,    image . getGLFormat (  )  ,    image . getGLType (  )  ,    image . getPixels (  )  )  ;", "} else", "page . dirty    =    true ;", "page . image . setBlending ( Pixmap . Blending . None )  ;", "page . image . drawPixmap ( image ,    rectX ,    rectY )  ;", "if    ( duplicateBorder )     {", "int   imageWidth    =    image . getWidth (  )  ;", "int   imageHeight    =    image . getHeight (  )  ;", "page . image . drawPixmap ( image ,     0  ,     0  ,     1  ,     1  ,     ( rectX    -     1  )  ,     ( rectY    -     1  )  ,     1  ,     1  )  ;", "page . image . drawPixmap ( image ,     ( imageWidth    -     1  )  ,     0  ,     1  ,     1  ,     ( rectX    +    rectWidth )  ,     ( rectY    -     1  )  ,     1  ,     1  )  ;", "page . image . drawPixmap ( image ,     0  ,     ( imageHeight    -     1  )  ,     1  ,     1  ,     ( rectX    -     1  )  ,     ( rectY    +    rectHeight )  ,     1  ,     1  )  ;", "page . image . drawPixmap ( image ,     ( imageWidth    -     1  )  ,     ( imageHeight    -     1  )  ,     1  ,     1  ,     ( rectX    +    rectWidth )  ,     ( rectY    +    rectHeight )  ,     1  ,     1  )  ;", "page . image . drawPixmap ( image ,     0  ,     0  ,    imageWidth ,     1  ,    rectX ,     ( rectY    -     1  )  ,    rectWidth ,     1  )  ;", "page . image . drawPixmap ( image ,     0  ,     ( imageHeight    -     1  )  ,    imageWidth ,     1  ,    rectX ,     ( rectY    +    rectHeight )  ,    rectWidth ,     1  )  ;", "page . image . drawPixmap ( image ,     0  ,     0  ,     1  ,    imageHeight ,     ( rectX    -     1  )  ,    rectY ,     1  ,    rectHeight )  ;", "page . image . drawPixmap ( image ,     ( imageWidth    -     1  )  ,     0  ,     1  ,    imageHeight ,     ( rectX    +    rectWidth )  ,    rectY ,     1  ,    rectHeight )  ;", "}", "return   rect ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "this . duplicateBorder    =    duplicateBorder ;", "}", "METHOD_END"], "methodName": ["setDuplicateBorder"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "this . packToTexture    =    packToTexture ;", "}", "METHOD_END"], "methodName": ["setPackToTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "this . padding    =    padding ;", "}", "METHOD_END"], "methodName": ["setPadding"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "this . pageFormat    =    pageFormat ;", "}", "METHOD_END"], "methodName": ["setPageFormat"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "this . pageHeight    =    pageHeight ;", "}", "METHOD_END"], "methodName": ["setPageHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "this . pageWidth    =    pageWidth ;", "}", "METHOD_END"], "methodName": ["setPageWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "this . transparentColor . set ( color )  ;", "}", "METHOD_END"], "methodName": ["setTransparentColor"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "packStrategy . sort ( images )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "for    ( PixmapPacker . Page   page    :    pages )", "page . updateTexture ( minFilter ,    magFilter ,    useMipMaps )  ;", "}", "METHOD_END"], "methodName": ["updatePageTextures"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "updatePageTextures ( minFilter ,    magFilter ,    useMipMaps )  ;", "for    (  . Page   page    :    pages )     {", "if    (  ( page . addedRects . size )     >     0  )     {", "for    ( String   name    :    page . addedRects )     {", "Rectangle   rect    =    page . rects . get ( name )  ;", "TextureRegion   region    =    new   TextureRegion ( page . texture ,     (  ( int )     ( rect . x )  )  ,     (  ( int )     ( rect . y )  )  ,     (  ( int )     ( rect . width )  )  ,     (  ( int )     ( rect . height )  )  )  ;", "atlas . addRegion ( name ,    region )  ;", "}", "page . addedRects . clear (  )  ;", "atlas . getTextures (  )  . add ( page . texture )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateTextureAtlas"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "updatePageTextures ( minFilter ,    magFilter ,    useMipMaps )  ;", "while    (  ( regions . size )     <     ( pages . size )  )", "regions . add ( new   TextureRegion ( pageet ( regions . size )  . texture )  )  ;", "}", "METHOD_END"], "methodName": ["updateTextureRegions"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPacker"}, {"methodBody": ["METHOD_START", "{", "save ( file ,    packer ,    new   PixmapPackerIO . SaveParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPackerIO"}, {"methodBody": ["METHOD_START", "{", "Writer   writer    =    file . writer ( false )  ;", "int   index    =     0  ;", "for    (  . Page   page    :    packer . pages )     {", "if    (  ( page . rects . size )     >     0  )     {", "FileHandle   pageFile    =    file . sibling (  (  (  (  ( file . nameWithoutExtension (  )  )     +     \"  _  \"  )     +     (  +  + index )  )     +     ( parameters . format . getExtension (  )  )  )  )  ;", "switch    ( parameters . format )     {", "case   CIM    :", "{", "PixmapIO . writeCIM ( pageFile ,    page . image )  ;", "break ;", "}", "case   PNG    :", "{", "PixmapIO . writePNG ( pageFile ,    page . image )  ;", "break ;", "}", "}", "writer . write (  \"  \\ n \"  )  ;", "writer . write (  (  ( pageFile . name (  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \" size :     \"     +     ( page . image . getWidth (  )  )  )     +     \"  ,  \"  )     +     ( page . image . getHeight (  )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  \" format :     \"     +     ( packer . pageFormat . name (  )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \" filter :     \"     +     ( parameters . minFilter . name (  )  )  )     +     \"  ,  \"  )     +     ( parameters . magFilter . name (  )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  \" repeat :    none \"     +     \"  \\ n \"  )  )  ;", "for    ( String   name    :    page . rects . keys (  )  )     {", "writer . write (  ( name    +     \"  \\ n \"  )  )  ;", "Rectangle   rect    =    page . rects . get ( name )  ;", "writer . write (  (  \" rotate :    false \"     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \" xy :     \"     +     (  ( int )     ( rect . x )  )  )     +     \"  ,  \"  )     +     (  ( int )     ( rect . y )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \" size :     \"     +     (  ( int )     ( rect . width )  )  )     +     \"  ,  \"  )     +     (  ( int )     ( rect . height )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  (  (  (  \" orig :     \"     +     (  ( int )     ( rect . width )  )  )     +     \"  ,  \"  )     +     (  ( int )     ( rect . height )  )  )     +     \"  \\ n \"  )  )  ;", "writer . write (  (  \" offset :     0  ,     0  \"     +     \"  \\ n \"  )  )  ;", "writer . write (  (  \" index :     -  1  \"     +     \"  \\ n \"  )  )  ;", "}", "}", "}", "writer . close (  )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.graphics.g2d.PixmapPackerIO"}, {"methodBody": ["METHOD_START", "{", "return   region ;", "}", "METHOD_END"], "methodName": ["getRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonRegion"}, {"methodBody": ["METHOD_START", "{", "return   textureCoords ;", "}", "METHOD_END"], "methodName": ["getTextureCoords"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonRegion"}, {"methodBody": ["METHOD_START", "{", "return   triangles ;", "}", "METHOD_END"], "methodName": ["getTriangles"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonRegion"}, {"methodBody": ["METHOD_START", "{", "return   vertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonRegion"}, {"methodBody": ["METHOD_START", "{", "BufferedReader   reader    =    file . reader (  2  5  6  )  ;", "try    {", "while    ( true )     {", "String   line    =    reader . readLine (  )  ;", "if    ( line    =  =    null )", "break ;", "if    ( line . startsWith (  \" s \"  )  )     {", "String [  ]    polygonStrings    =    line . substring (  1  )  . trim (  )  . split (  \"  ,  \"  )  ;", "float [  ]    vertices    =    new   float [ polygonStrings . length ]  ;", "for    ( int   i    =     0  ,    n    =    vertices . length ;    i    <    n ;    i +  +  )", "vertices [ i ]     =    Float . parseFloat ( polygonStrings [ i ]  )  ;", "return   new    ( textureRegion ,    vertices ,    triangulator . computeTriangles ( vertices )  . toArray (  )  )  ;", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   polygon   shape   file :     \"     +    file )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( reader )  ;", "}", "throw   new   GdxRuntimeException (  (  \" Polygon   shape   not   found :     \"     +    file )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonRegionLoader"}, {"methodBody": ["METHOD_START", "{", "final   PolygonRegion   region    =    this . region ;", "spriteBatch . draw ( region . region . texture ,    getVertices (  )  ,     0  ,    vertices . length ,    region . triangles ,     0  ,    region . triangles . length )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "Color   color    =    getColor (  )  ;", "float   oldAlpha    =    color . a ;", "color . a    *  =    alphaModulation ;", "setColor ( color )  ;", "draw ( sBatch )  ;", "color . a    =    oldAlpha ;", "setColor ( color )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    vertices    =    getVertices (  )  ;", "float   minx    =    vertices [  0  ]  ;", "float   miny    =    vertices [  1  ]  ;", "float   maxx    =    vertices [  0  ]  ;", "float   maxy    =    vertices [  1  ]  ;", "for    ( int   i    =     5  ;    i    <     ( vertices . length )  ;    i    +  =     5  )     {", "float   x    =    vertices [ i ]  ;", "float   y    =    vertices [  ( i    +     1  )  ]  ;", "minx    =     ( minx    >    x )     ?    x    :    minx ;", "maxx    =     ( maxx    <    x )     ?    x    :    maxx ;", "miny    =     ( miny    >    y )     ?    y    :    miny ;", "maxy    =     ( maxy    <    y )     ?    y    :    maxy ;", "}", "bounds . x    =    minx ;", "bounds . y    =    miny ;", "bounds . width    =    maxx    -    minx ;", "bounds . height    =    maxy    -    miny ;", "return   bounds ;", "}", "METHOD_END"], "methodName": ["getBoundingRectangle"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   originX ;", "}", "METHOD_END"], "methodName": ["getOriginX"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   originY ;", "}", "METHOD_END"], "methodName": ["getOriginY"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   region ;", "}", "METHOD_END"], "methodName": ["getRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   rotation ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   scaleX ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   scaleY ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "int   intBits    =    NumberUtils . floatToIntColor ( vertices [  2  ]  )  ;", "Color   color    =    this . color ;", "color . r    =     ( intBits    &     2  5  5  )     /     2  5  5  .  0 F ;", "color . g    =     (  ( intBits    >  >  >     8  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "color . b    =     (  ( intBits    >  >  >     1  6  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "color . a    =     (  ( intBits    >  >  >     2  4  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "return   color ;", "}", "METHOD_END"], "methodName": ["getVertexColor"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dirty )  )", "return   vertices ;", "dirty    =    false ;", "final   float   originX    =    this . originX ;", "final   float   originY    =    this . originY ;", "final   float   scaleX    =    this . scaleX ;", "final   float   scaleY    =    this . scaleY ;", "final   Region   region    =    this . region ;", "final   float [  ]    vertices    =    this . vertices ;", "final   float [  ]    regionVertices    =    region . vertices ;", "final   float   worldOriginX    =     ( x )     +    originX ;", "final   float   worldOriginY    =     ( y )     +    originY ;", "final   float   sX    =     ( width )     /     ( region . region . getRegionWidth (  )  )  ;", "final   float   sY    =     ( height )     /     ( region . region . getRegionHeight (  )  )  ;", "final   float   cos    =    MathUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MathUtils . sinDeg ( rotation )  ;", "float   fx ;", "float   fy ;", "for    ( int   i    =     0  ,    v    =     0  ,    n    =    regionVertices . length ;    i    <    n ;    i    +  =     2     ,    v    +  =     5  )     {", "fx    =     (  (  ( regionVertices [ i ]  )     *    sX )     -    originX )     *    scaleX ;", "fy    =     (  (  ( regionVertices [  ( i    +     1  )  ]  )     *    sY )     -    originY )     *    scaleY ;", "vertices [ v ]     =     (  ( cos    *    fx )     -     ( sin    *    fy )  )     +    worldOriginX ;", "vertices [  ( v    +     1  )  ]     =     (  ( sin    *    fx )     +     ( cos    *    fy )  )     +    worldOriginY ;", "}", "return   vertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "rotation    +  =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    +  =    amount ;", "this . scaleY    +  =    amount ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "if    ( sprite    =  =    null )", "throw   new   IllegalArgumentException (  \" sprite   cannot   be   null .  \"  )  ;", "setRegion ( sprite . region )  ;", "x    =    sprite . x ;", "y    =    sprite . y ;", "width    =    sprite . width ;", "height    =    sprite . height ;", "originX    =    sprite . originX ;", "originY    =    sprite . originY ;", "rotation    =    sprite . rotation ;", "scaleX    =    sprite . scaleX ;", "scaleY    =    sprite . scaleY ;", "color . set ( sprite . color )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . width    =    width ;", "this . height    =    height ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setBounds"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "color . set ( tint )  ;", "float   color    =    tint . toFloatBits (  )  ;", "final   float [  ]    vertices    =    this . vertices ;", "for    ( int   i    =     2  ;    i    <     ( vertices . length )  ;    i    +  =     . VERTEX _ SIZE )", "vertices [ i ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "color . set ( r ,    g ,    b ,    a )  ;", "int   intBits    =     (  (  (  (  ( int )     (  2  5  5     *    a )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *    b )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *    g )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *    r )  )  ;", "float   color    =    NumberUtils . intToFloatColor ( intBits )  ;", "final   float [  ]    vertices    =    this . vertices ;", "for    ( int   i    =     2  ;    i    <     ( vertices . length )  ;    i    +  =     . VERTEX _ SIZE )", "vertices [ i ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . originX    =    originX ;", "this . originY    =    originY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "translate (  ( x    -     ( this . x )  )  ,     ( y    -     ( this . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . region    =    region ;", "float [  ]    regionVertices    =    region . vertices ;", "float [  ]    textureCoords    =    region . textureCoords ;", "int   verticesLength    =     (  ( regionVertices . length )     /     2  )     *     5  ;", "if    (  (  ( vertices )     =  =    null )     |  |     (  ( vertices . length )     !  =    verticesLength )  )", "vertices    =    new   float [ verticesLength ]  ;", "float   floatColor    =    color . toFloatBits (  )  ;", "float [  ]    vertices    =    this . vertices ;", "for    ( int   i    =     0  ,    v    =     2  ;    v    <    verticesLength ;    i    +  =     2     ,    v    +  =     5  )     {", "vertices [ v ]     =    floatColor ;", "vertices [  ( v    +     1  )  ]     =    textureCoords [ i ]  ;", "vertices [  ( v    +     2  )  ]     =    textureCoords [  ( i    +     1  )  ]  ;", "}", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . rotation    =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleXY ;", "this . scaleY    =    scaleXY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleX ;", "this . scaleY    =    scaleY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "this . height    =    height ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "translateX (  ( x    -     ( this . x )  )  )  ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "translateY (  ( y    -     ( this . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "x    +  =    xAmount ;", "y    +  =    yAmount ;", "if    ( dirty )", "return ;", "final   float [  ]    vertices    =    this . vertices ;", "for    ( int   i    =     0  ;    i    <     ( vertices . length )  ;    i    +  =     . VERTEX _ SIZE )     {", "vertices [ i ]     +  =    xAmount ;", "vertices [  ( i    +     1  )  ]     +  =    yAmount ;", "}", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    xAmount ;", "if    ( dirty )", "return ;", "final   float [  ]    vertices    =    this . vertices ;", "for    ( int   i    =     0  ;    i    <     ( vertices . length )  ;    i    +  =     . VERTEX _ SIZE )", "vertices [ i ]     +  =    xAmount ;", "}", "METHOD_END"], "methodName": ["translateX"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "y    +  =    yAmount ;", "if    ( dirty )", "return ;", "final   float [  ]    vertices    =    this . vertices ;", "for    ( int   i    =     1  ;    i    <     ( vertices . length )  ;    i    +  =     . VERTEX _ SIZE )", "vertices [ i ]     +  =    yAmount ;", "}", "METHOD_END"], "methodName": ["translateY"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSprite"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "final   short [  ]    triangles    =    this . triangles ;", "final   float [  ]    vertices    =    this . vertices ;", "if    ( texture    !  =     ( lastTexture )  )", "switchTexture ( texture )  ;", "else", "if    (  (  (  ( triangleIndex )     +    trianglesCount )     >     ( triangles . length )  )     |  |     (  (  ( vertexIndex )     +    verticesCount )     >     ( vertices . length )  )  )", "flush (  )  ;", "int   triangleIndex    =    this . triangleIndex ;", "final   int   vertexIndex    =    this . vertexIndex ;", "final   int   startVertex    =    vertexIndex    /     ( Sprite . VERTEX _ SIZE )  ;", "for    ( int   i    =    trianglesOffset ,    n    =    i    +    trianglesCount ;    i    <    n ;    i +  +  )", "triangles [  ( triangleIndex +  +  )  ]     =     (  ( short )     (  ( polygonTriangles [ i ]  )     +    startVertex )  )  ;", "this . triangleIndex    =    triangleIndex ;", "System . arraycopy ( polygonVertices ,    verticesOffset ,    vertices ,    vertexIndex ,    verticesCount )  ;", "this . vertexIndex    +  =    verticesCount ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "final   short [  ]    triangles    =    this . triangles ;", "final   short [  ]    regionTriangles    =    region . triangles ;", "final   int   regionTrianglesLength    =    regionTriangles . length ;", "final   float [  ]    regionVertices    =    region . vertices ;", "final   int   regionVerticesLength    =    regionVertices . length ;", "final   Texture   texture    =    region . region . texture ;", "if    ( texture    !  =     ( lastTexture )  )", "switchTexture ( texture )  ;", "else", "if    (  (  (  ( triangleIndex )     +    regionTrianglesLength )     >     ( triangles . length )  )     |  |     (  (  ( vertexIndex )     +     (  ( regionVerticesLength    *     ( Sprite . VERTEX _ SIZE )  )     /     2  )  )     >     ( vertices . length )  )  )", "flush (  )  ;", "int   triangleIndex    =    this . triangleIndex ;", "int   vertexIndex    =    this . vertexIndex ;", "final   int   startVertex    =    vertexIndex    /     ( Sprite . VERTEX _ SIZE )  ;", "for    ( int   i    =     0  ;    i    <    regionTrianglesLength ;    i +  +  )", "triangles [  ( triangleIndex +  +  )  ]     =     (  ( short )     (  ( regionTriangles [ i ]  )     +    startVertex )  )  ;", "this . triangleIndex    =    triangleIndex ;", "final   float [  ]    vertices    =    this . vertices ;", "final   float   color    =    this . color ;", "final   float [  ]    textureCoords    =    region . textureCoords ;", "for    ( int   i    =     0  ;    i    <    regionVerticesLength ;    i    +  =     2  )     {", "vertices [  ( vertexIndex +  +  )  ]     =     ( regionVertices [ i ]  )     +    x ;", "vertices [  ( vertexIndex +  +  )  ]     =     ( regionVertices [  ( i    +     1  )  ]  )     +    y ;", "vertices [  ( vertexIndex +  +  )  ]     =    color ;", "vertices [  ( vertexIndex +  +  )  ]     =    textureCoords [ i ]  ;", "vertices [  ( vertexIndex +  +  )  ]     =    textureCoords [  ( i    +     1  )  ]  ;", "}", "this . vertexIndex    =    vertexIndex ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "final   short [  ]    triangles    =    this . triangles ;", "final   short [  ]    regionTriangles    =    region . triangles ;", "final   int   regionTrianglesLength    =    regionTriangles . length ;", "final   float [  ]    regionVertices    =    region . vertices ;", "final   int   regionVerticesLength    =    regionVertices . length ;", "final   TextureRegion   textureRegion    =    region . region ;", "final   Texture   texture    =    textureRegion . texture ;", "if    ( texture    !  =     ( lastTexture )  )", "switchTexture ( texture )  ;", "else", "if    (  (  (  ( triangleIndex )     +    regionTrianglesLength )     >     ( triangles . length )  )     |  |     (  (  ( vertexIndex )     +     (  ( regionVerticesLength    *     ( Sprite . VERTEX _ SIZE )  )     /     2  )  )     >     ( vertices . length )  )  )", "flush (  )  ;", "int   triangleIndex    =    this . triangleIndex ;", "int   vertexIndex    =    this . vertexIndex ;", "final   int   startVertex    =    vertexIndex    /     ( Sprite . VERTEX _ SIZE )  ;", "for    ( int   i    =     0  ,    n    =    regionTriangles . length ;    i    <    n ;    i +  +  )", "triangles [  ( triangleIndex +  +  )  ]     =     (  ( short )     (  ( regionTriangles [ i ]  )     +    startVertex )  )  ;", "this . triangleIndex    =    triangleIndex ;", "final   float [  ]    vertices    =    this . vertices ;", "final   float   color    =    this . color ;", "final   float [  ]    textureCoords    =    region . textureCoords ;", "final   float   sX    =    width    /     ( textureRegion . regionWidth )  ;", "final   float   sY    =    height    /     ( textureRegion . regionHeight )  ;", "for    ( int   i    =     0  ;    i    <    regionVerticesLength ;    i    +  =     2  )     {", "vertices [  ( vertexIndex +  +  )  ]     =     (  ( regionVertices [ i ]  )     *    sX )     +    x ;", "vertices [  ( vertexIndex +  +  )  ]     =     (  ( regionVertices [  ( i    +     1  )  ]  )     *    sY )     +    y ;", "vertices [  ( vertexIndex +  +  )  ]     =    color ;", "vertices [  ( vertexIndex +  +  )  ]     =    textureCoords [ i ]  ;", "vertices [  ( vertexIndex +  +  )  ]     =    textureCoords [  ( i    +     1  )  ]  ;", "}", "this . vertexIndex    =    vertexIndex ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \"  . begin   must   be   called   before   draw .  \"  )  ;", "final   short [  ]    triangles    =    this . triangles ;", "final   short [  ]    regionTriangles    =    region . triangles ;", "final   int   regionTrianglesLength    =    regionTriangles . length ;", "final   float [  ]    regionVertices    =    region . vertices ;", "final   int   regionVerticesLength    =    regionVertices . length ;", "final   TextureRegion   textureRegion    =    region . region ;", "Texture   texture    =    textureRegion . texture ;", "if    ( texture    !  =     ( lastTexture )  )", "switchTexture ( texture )  ;", "else", "if    (  (  (  ( triangleIndex )     +    regionTrianglesLength )     >     ( triangles . length )  )     |  |     (  (  ( vertexIndex )     +     (  ( regionVerticesLength    *     ( Sprite . VERTEX _ SIZE )  )     /     2  )  )     >     ( vertices . length )  )  )", "flush (  )  ;", "int   triangleIndex    =    this . triangleIndex ;", "int   vertexIndex    =    this . vertexIndex ;", "final   int   startVertex    =    vertexIndex    /     ( Sprite . VERTEX _ SIZE )  ;", "for    ( int   i    =     0  ;    i    <    regionTrianglesLength ;    i +  +  )", "triangles [  ( triangleIndex +  +  )  ]     =     (  ( short )     (  ( regionTriangles [ i ]  )     +    startVertex )  )  ;", "this . triangleIndex    =    triangleIndex ;", "final   float [  ]    vertices    =    this . vertices ;", "final   float   color    =    this . color ;", "final   float [  ]    textureCoords    =    region . textureCoords ;", "final   float   worldOriginX    =    x    +    originX ;", "final   float   worldOriginY    =    y    +    originY ;", "final   float   sX    =    width    /     ( textureRegion . regionWidth )  ;", "final   float   sY    =    height    /     ( textureRegion . regionHeight )  ;", "final   float   cos    =    MathUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MathUtils . sinDeg ( rotation )  ;", "float   fx ;", "float   fy ;", "for    ( int   i    =     0  ;    i    <    regionVerticesLength ;    i    +  =     2  )     {", "fx    =     (  (  ( regionVertices [ i ]  )     *    sX )     -    originX )     *    scaleX ;", "fy    =     (  (  ( regionVertices [  ( i    +     1  )  ]  )     *    sY )     -    originY )     *    scaleY ;", "vertices [  ( vertexIndex +  +  )  ]     =     (  ( cos    *    fx )     -     ( sin    *    fy )  )     +    worldOriginX ;", "vertices [  ( vertexIndex +  +  )  ]     =     (  ( sin    *    fx )     +     ( cos    *    fy )  )     +    worldOriginY ;", "vertices [  ( vertexIndex +  +  )  ]     =    color ;", "vertices [  ( vertexIndex +  +  )  ]     =    textureCoords [ i ]  ;", "vertices [  ( vertexIndex +  +  )  ]     =    textureCoords [  ( i    +     1  )  ]  ;", "}", "this . vertexIndex    =    vertexIndex ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "combinedMatrix . set ( projectionMatrix )  . mul ( transformMatrix )  ;", "if    (  ( customShader )     !  =    null )     {", "customShader . setUniformMatrix (  \" u _ projTrans \"  ,    combinedMatrix )  ;", "customShader . setUniformi (  \" u _ texture \"  ,     0  )  ;", "} else    {", "shader . setUniformMatrix (  \" u _ projTrans \"  ,    combinedMatrix )  ;", "shader . setUniformi (  \" u _ texture \"  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["setupMatrices"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "flush (  )  ;", "lastTexture    =    xture ;", "invTexWidth    =     1  .  0 F    /     ( xture . getWidth (  )  )  ;", "invTexHeight    =     1  .  0 F    /     ( xture . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["switchTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.PolygonSpriteBatch"}, {"methodBody": ["METHOD_START", "{", "vertices . clear (  )  ;", "for    ( int   i    =     0  ;    i    <     ( parts . size )  ;    i +  +  )     {", "float [  ]    verts    =    partet ( i )  ;", "if    ( verts    =  =    null )", "continue ;", "float [  ]    fullVerts    =    new   float [  (  5     *     ( verts . length )  )     /     2  ]  ;", "int   idx    =     0  ;", "int   col    =    i    /     ( rows )  ;", "int   row    =    i    %     ( rows )  ;", "for    ( int   j    =     0  ;    j    <     ( verts . length )  ;    j    +  =     2  )     {", "fullVerts [  ( idx +  +  )  ]     =     (  ( verts [ j ]  )     +     ( offset . x )  )     +     ( x )  ;", "fullVerts [  ( idx +  +  )  ]     =     (  ( verts [  ( j    +     1  )  ]  )     +     ( offset . y )  )     +     ( y )  ;", "fullVerts [  ( idx +  +  )  ]     =    color . toFloatBits (  )  ;", "float   u    =     (  ( verts [ j ]  )     %     ( gridWidth )  )     /     ( gridWidth )  ;", "float   v    =     (  ( verts [  ( j    +     1  )  ]  )     %     ( gridHeight )  )     /     ( gridHeight )  ;", "if    (  ( verts [ j ]  )     =  =     ( col    *     ( gridWidth )  )  )", "u    =     0  .  0 F ;", "if    (  ( verts [ j ]  )     =  =     (  ( col    +     1  )     *     ( gridWidth )  )  )", "u    =     1  .  0 F ;", "if    (  ( verts [  ( j    +     1  )  ]  )     =  =     ( row    *     ( gridHeight )  )  )", "v    =     0  .  0 F ;", "if    (  ( verts [  ( j    +     1  )  ]  )     =  =     (  ( row    +     1  )     *     ( gridHeight )  )  )", "v    =     1  .  0 F ;", "u    =     ( region . getU (  )  )     +     (  (  ( region . getU 2  (  )  )     -     ( region . getU (  )  )  )     *    u )  ;", "v    =     ( region . getV (  )  )     +     (  (  ( region . getV 2  (  )  )     -     ( region . getV (  )  )  )     *    v )  ;", "fullVerts [  ( idx +  +  )  ]     =    u ;", "fullVerts [  ( idx +  +  )  ]     =    v ;", "}", "vertices . add ( fullVerts )  ;", "}", "dirty    =    false ;", "}", "METHOD_END"], "methodName": ["buildVertices"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "if    ( dirty )     {", "buildVertices (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( vertices . size )  ;    i +  +  )     {", "batch . draw ( region . getTexture (  )  ,    verticeet ( i )  ,     0  ,    verticeet ( i )  . length ,    indiceet ( i )  ,     0  ,    indiceet ( i )  . length )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "offset . set ( vertices [  0  ]  ,    vertices [  1  ]  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( vertices . length )     -     1  )  ;    i    +  =     2  )     {", "if    (  ( offset . x )     >     ( vertices [ i ]  )  )     {", "offset . x    =    vertices [ i ]  ;", "}", "if    (  ( offset . y )     >     ( vertices [  ( i    +     1  )  ]  )  )     {", "offset . y    =    vertices [  ( i    +     1  )  ]  ;", "}", "}", "for    ( int   i    =     0  ;    i    <     ( vertices . length )  ;    i    +  =     2  )     {", "vertices [ i ]     -  =    offset . x ;", "vertices [  ( i    +     1  )  ]     -  =    offset . y ;", "}", "return   vertices ;", "}", "METHOD_END"], "methodName": ["offset"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "setPolygon ( region ,    vertices ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setPolygon"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . region    =    region ;", "vertices    =    offset ( vertices )  ;", "polygon    =    new    ( vertices )  ;", "tmpPoly    =    new    (  )  ;", "intersectionPoly    =    new    (  )  ;", "EarClippingTriangulator   triangulator    =    new   EarClippingTriangulator (  )  ;", "int   idx ;", "Rectangle   boundRect    =    polygon . getBoundingRectangle (  )  ;", "if    ( density    =  =     (  -  1  )  )", "density    =     ( boundRect . getWidth (  )  )     /     ( region . getRegionWidth (  )  )  ;", "float   regionAspectRatio    =     (  ( float )     ( region . getRegionHeight (  )  )  )     /     (  ( float )     ( region . getRegionWidth (  )  )  )  ;", "cols    =     (  ( int )     ( Math . ceil ( density )  )  )  ;", "gridWidth    =     ( boundRect . getWidth (  )  )     /    density ;", "gridHeight    =    regionAspectRatio    *     ( gridWidth )  ;", "rows    =     (  ( int )     ( Math . ceil (  (  ( boundRect . getHeight (  )  )     /     ( gridHeight )  )  )  )  )  ;", "for    ( int   col    =     0  ;    col    <     ( cols )  ;    col +  +  )     {", "for    ( int   row    =     0  ;    row    <     ( rows )  ;    row +  +  )     {", "float [  ]    verts    =    new   float [  8  ]  ;", "idx    =     0  ;", "verts [  ( idx +  +  )  ]     =    col    *     ( gridWidth )  ;", "verts [  ( idx +  +  )  ]     =    row    *     ( gridHeight )  ;", "verts [  ( idx +  +  )  ]     =    col    *     ( gridWidth )  ;", "verts [  ( idx +  +  )  ]     =     ( row    +     1  )     *     ( gridHeight )  ;", "verts [  ( idx +  +  )  ]     =     ( col    +     1  )     *     ( gridWidth )  ;", "verts [  ( idx +  +  )  ]     =     ( row    +     1  )     *     ( gridHeight )  ;", "verts [  ( idx +  +  )  ]     =     ( col    +     1  )     *     ( gridWidth )  ;", "verts [ idx ]     =    row    *     ( gridHeight )  ;", "tmpPoly . setVertices ( verts )  ;", "Intersector . intersects ( polygon ,    tmpPoly ,    intersectionPoly )  ;", "verts    =    intersectionPoly . getVertices (  )  ;", "if    (  ( verts . length )     >     0  )     {", "parts . add ( snapToGrid ( verts )  )  ;", "ShortArray   arr    =    triangulator . computeTriangles ( verts )  ;", "indices . add ( arr . toArray (  )  )  ;", "} else    {", "parts . add ( null )  ;", "}", "}", "}", "buildVertices (  )  ;", "}", "METHOD_END"], "methodName": ["setPolygon"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( vertices . length )  ;    i    +  =     2  )     {", "float   numX    =     (  ( vertices [ i ]  )     /     ( gridWidth )  )     %     1  ;", "float   numY    =     (  ( vertices [  ( i    +     1  )  ]  )     /     ( gridHeight )  )     %     1  ;", "if    (  ( numX    >     0  .  9  9 F )     |  |     ( numX    <     0  .  0  1 F )  )     {", "vertices [ i ]     =     ( gridWidth )     *     ( Math . round (  (  ( vertices [ i ]  )     /     ( gridWidth )  )  )  )  ;", "}", "if    (  ( numY    >     0  .  9  9 F )     |  |     ( numY    <     0  .  0  1 F )  )     {", "vertices [  ( i    +     1  )  ]     =     ( gridHeight )     *     ( Math . round (  (  ( vertices [  ( i    +     1  )  ]  )     /     ( gridHeight )  )  )  )  ;", "}", "}", "return   vertices ;", "}", "METHOD_END"], "methodName": ["snapToGrid"], "fileName": "com.badlogic.gdx.graphics.g2d.RepeatablePolygonSprite"}, {"methodBody": ["METHOD_START", "{", "batch . draw ( texture ,    getVertices (  )  ,     0  ,    Sprite . SPRITE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "float   oldAlpha    =    getColor (  )  . a ;", "setAlpha (  ( oldAlpha    *    alphaModulation )  )  ;", "draw ( batch )  ;", "setAlpha ( oldAlpha )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "super . flip ( x ,    y )  ;", "fat [  ]    vertices    =    this . vertices ;", "if    ( x )     {", "fat   temp    =    vertices [ Batch . U 1  ]  ;", "vertices [ Batch . U 1  ]     =    vertices [ Batch . U 3  ]  ;", "vertices [ Batch . U 3  ]     =    temp ;", "temp    =    vertices [ Batch . U 2  ]  ;", "vertices [ Batch . U 2  ]     =    vertices [ Batch . U 4  ]  ;", "vertices [ Batch . U 4  ]     =    temp ;", "}", "if    ( y )     {", "fat   temp    =    vertices [ Batch . V 1  ]  ;", "vertices [ Batch . V 1  ]     =    vertices [ Batch . V 3  ]  ;", "vertices [ Batch . V 3  ]     =    temp ;", "temp    =    vertices [ Batch . V 2  ]  ;", "vertices [ Batch . V 2  ]     =    vertices [ Batch . V 4  ]  ;", "vertices [ Batch . V 4  ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["flip"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    vertices    =    getVertices (  )  ;", "float   minx    =    vertices [ Batch . X 1  ]  ;", "float   miny    =    vertices [ Batch . Y 1  ]  ;", "float   maxx    =    vertices [ Batch . X 1  ]  ;", "float   maxy    =    vertices [ Batch . Y 1  ]  ;", "minx    =     ( minx    >     ( vertices [ Batch . X 2  ]  )  )     ?    vertices [ Batch . X 2  ]     :    minx ;", "minx    =     ( minx    >     ( vertices [ Batch . X 3  ]  )  )     ?    vertices [ Batch . X 3  ]     :    minx ;", "minx    =     ( minx    >     ( vertices [ Batch . X 4  ]  )  )     ?    vertices [ Batch . X 4  ]     :    minx ;", "maxx    =     ( maxx    <     ( vertices [ Batch . X 2  ]  )  )     ?    vertices [ Batch . X 2  ]     :    maxx ;", "maxx    =     ( maxx    <     ( vertices [ Batch . X 3  ]  )  )     ?    vertices [ Batch . X 3  ]     :    maxx ;", "maxx    =     ( maxx    <     ( vertices [ Batch . X 4  ]  )  )     ?    vertices [ Batch . X 4  ]     :    maxx ;", "miny    =     ( miny    >     ( vertices [ Batch . Y 2  ]  )  )     ?    vertices [ Batch . Y 2  ]     :    miny ;", "miny    =     ( miny    >     ( vertices [ Batch . Y 3  ]  )  )     ?    vertices [ Batch . Y 3  ]     :    miny ;", "miny    =     ( miny    >     ( vertices [ Batch . Y 4  ]  )  )     ?    vertices [ Batch . Y 4  ]     :    miny ;", "maxy    =     ( maxy    <     ( vertices [ Batch . Y 2  ]  )  )     ?    vertices [ Batch . Y 2  ]     :    maxy ;", "maxy    =     ( maxy    <     ( vertices [ Batch . Y 3  ]  )  )     ?    vertices [ Batch . Y 3  ]     :    maxy ;", "maxy    =     ( maxy    <     ( vertices [ Batch . Y 4  ]  )  )     ?    vertices [ Batch . Y 4  ]     :    maxy ;", "if    (  ( bounds )     =  =    null )", "bounds    =    new   Rectangle (  )  ;", "bounds . x    =    minx ;", "bounds . y    =    miny ;", "bounds . width    =    maxx    -    minx ;", "bounds . height    =    maxy    -    miny ;", "return   bounds ;", "}", "METHOD_END"], "methodName": ["getBoundingRectangle"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "int   intBits    =    NumberUtils . floatToIntColor ( vertices [ Batch . C 1  ]  )  ;", "Color   color    =    this . color ;", "color . r    =     ( intBits    &     2  5  5  )     /     2  5  5  .  0 F ;", "color . g    =     (  ( intBits    >  >  >     8  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "color . b    =     (  ( intBits    >  >  >     1  6  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "color . a    =     (  ( intBits    >  >  >     2  4  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   originX ;", "}", "METHOD_END"], "methodName": ["getOriginX"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   originY ;", "}", "METHOD_END"], "methodName": ["getOriginY"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   rotation ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   scaleX ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   scaleY ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "if    ( dirty )     {", "dirty    =    false ;", "fat [  ]    vertices    =    this . vertices ;", "fat   calX    =     -  ( originX )  ;", "fat   calY    =     -  ( originY )  ;", "fat   calX 2     =    calX    +     ( width )  ;", "fat   calY 2     =    calY    +     ( height )  ;", "fat   worldOriginX    =     ( this . x )     -    calX ;", "fat   worldOriginY    =     ( this . y )     -    calY ;", "if    (  (  ( scaleX )     !  =     1  )     |  |     (  ( scaleY )     !  =     1  )  )     {", "calX    *  =    scaleX ;", "calY    *  =    scaleY ;", "calX 2     *  =    scaleX ;", "calY 2     *  =    scaleY ;", "}", "if    (  ( rotation )     !  =     0  )     {", "final   fat   cos    =    MathUtils . cosDeg ( rotation )  ;", "final   fat   sin    =    MathUtils . sinDeg ( rotation )  ;", "final   fat   calXCos    =    calX    *    cos ;", "final   fat   calXSin    =    calX    *    sin ;", "final   fat   calYCos    =    calY    *    cos ;", "final   fat   calYSin    =    calY    *    sin ;", "final   fat   calX 2 Cos    =    calX 2     *    cos ;", "final   fat   calX 2 Sin    =    calX 2     *    sin ;", "final   fat   calY 2 Cos    =    calY 2     *    cos ;", "final   fat   calY 2 Sin    =    calY 2     *    sin ;", "final   fat   x 1     =     ( calXCos    -    calYSin )     +    worldOriginX ;", "final   fat   y 1     =     ( calYCos    +    calXSin )     +    worldOriginY ;", "vertices [ Batch . X 1  ]     =    x 1  ;", "vertices [ Batch . Y 1  ]     =    y 1  ;", "final   fat   x 2     =     ( calXCos    -    calY 2 Sin )     +    worldOriginX ;", "final   fat   y 2     =     ( calY 2 Cos    +    calXSin )     +    worldOriginY ;", "vertices [ Batch . X 2  ]     =    x 2  ;", "vertices [ Batch . Y 2  ]     =    y 2  ;", "final   fat   x 3     =     ( calX 2 Cos    -    calY 2 Sin )     +    worldOriginX ;", "final   fat   y 3     =     ( calY 2 Cos    +    calX 2 Sin )     +    worldOriginY ;", "vertices [ Batch . X 3  ]     =    x 3  ;", "vertices [ Batch . Y 3  ]     =    y 3  ;", "vertices [ Batch . X 4  ]     =    x 1     +     ( x 3     -    x 2  )  ;", "vertices [ Batch . Y 4  ]     =    y 3     -     ( y 2     -    y 1  )  ;", "} else    {", "final   fat   x 1     =    calX    +    worldOriginX ;", "final   fat   y 1     =    calY    +    worldOriginY ;", "final   fat   x 2     =    calX 2     +    worldOriginX ;", "final   fat   y 2     =    calY 2     +    worldOriginY ;", "vertices [ Batch . X 1  ]     =    x 1  ;", "vertices [ Batch . Y 1  ]     =    y 1  ;", "vertices [ Batch . X 2  ]     =    x 1  ;", "vertices [ Batch . Y 2  ]     =    y 2  ;", "vertices [ Batch . X 3  ]     =    x 2  ;", "vertices [ Batch . Y 3  ]     =    y 2  ;", "vertices [ Batch . X 4  ]     =    x 2  ;", "vertices [ Batch . Y 4  ]     =    y 1  ;", "}", "}", "return   vertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )", "return ;", "rotation    +  =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "float [  ]    vertices    =    this . vertices ;", "if    ( clockwise )     {", "float   temp    =    vertices [ Batch . V 1  ]  ;", "vertices [ Batch . V 1  ]     =    vertices [ Batch . V 4  ]  ;", "vertices [ Batch . V 4  ]     =    vertices [ Batch . V 3  ]  ;", "vertices [ Batch . V 3  ]     =    vertices [ Batch . V 2  ]  ;", "vertices [ Batch . V 2  ]     =    temp ;", "temp    =    vertices [ Batch . U 1  ]  ;", "vertices [ Batch . U 1  ]     =    vertices [ Batch . U 4  ]  ;", "vertices [ Batch . U 4  ]     =    vertices [ Batch . U 3  ]  ;", "vertices [ Batch . U 3  ]     =    vertices [ Batch . U 2  ]  ;", "vertices [ Batch . U 2  ]     =    temp ;", "} else    {", "float   temp    =    vertices [ Batch . V 1  ]  ;", "vertices [ Batch . V 1  ]     =    vertices [ Batch . V 2  ]  ;", "vertices [ Batch . V 2  ]     =    vertices [ Batch . V 3  ]  ;", "vertices [ Batch . V 3  ]     =    vertices [ Batch . V 4  ]  ;", "vertices [ Batch . V 4  ]     =    temp ;", "temp    =    vertices [ Batch . U 1  ]  ;", "vertices [ Batch . U 1  ]     =    vertices [ Batch . U 2  ]  ;", "vertices [ Batch . U 2  ]     =    vertices [ Batch . U 3  ]  ;", "vertices [ Batch . U 3  ]     =    vertices [ Batch . U 4  ]  ;", "vertices [ Batch . U 4  ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["rotate90"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    +  =    amount ;", "this . scaleY    +  =    amount ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "float [  ]    vertices    =    this . vertices ;", "if    ( xAmount    !  =     0  )     {", "float   u    =     (  ( vertices [ Batch . U 1  ]  )     +    xAmount )     %     1  ;", "float   u 2     =    u    +     (  ( width )     /     ( texture . getWidth (  )  )  )  ;", "this . u    =    u ;", "this . u 2     =    u 2  ;", "vertices [ Batch . U 1  ]     =    u ;", "vertices [ Batch . U 2  ]     =    u ;", "vertices [ Batch . U 3  ]     =    u 2  ;", "vertices [ Batch . U 4  ]     =    u 2  ;", "}", "if    ( yAmount    !  =     0  )     {", "float   v    =     (  ( vertices [ Batch . V 2  ]  )     +    yAmount )     %     1  ;", "float   v 2     =    v    +     (  ( height )     /     ( texture . getHeight (  )  )  )  ;", "this . v    =    v ;", "this . v 2     =    v 2  ;", "vertices [ Batch . V 1  ]     =    v 2  ;", "vertices [ Batch . V 2  ]     =    v ;", "vertices [ Batch . V 3  ]     =    v ;", "vertices [ Batch . V 4  ]     =    v 2  ;", "}", "}", "METHOD_END"], "methodName": ["scroll"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "if    ( sprite    =  =    null )", "throw   new   IllegalArgumentException (  \" sprite   cannot   be   null .  \"  )  ;", "System . arraycopy ( sprite . vertices ,     0  ,    vertices ,     0  ,     . SPRITE _ SIZE )  ;", "texture    =    sprite . texture ;", "u    =    sprite . u ;", "v    =    sprite . v ;", "u 2     =    sprite . u 2  ;", "v 2     =    sprite . v 2  ;", "x    =    sprite . x ;", "y    =    sprite . y ;", "width    =    sprite . width ;", "height    =    sprite . height ;", "regionWidth    =    sprite . regionWidth ;", "regionHeight    =    sprite . regionHeight ;", "originX    =    sprite . originX ;", "originY    =    sprite . originY ;", "rotation    =    sprite . rotation ;", "scaleX    =    sprite . scaleX ;", "scaleY    =    sprite . scaleY ;", "color . set ( sprite . color )  ;", "dirty    =    sprite . dirty ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "int   intBits    =    NumberUtils . floatToIntColor ( vertices [ Batch . C 1  ]  )  ;", "int   alphaBits    =     (  ( int )     (  2  5  5     *    a )  )     <  <     2  4  ;", "intBits    =    intBits    &     1  6  7  7  7  2  1  5  ;", "intBits    =    intBits    |    alphaBits ;", "float   color    =    NumberUtils . intToFloatColor ( intBits )  ;", "vertices [ Batch . C 1  ]     =    color ;", "vertices [ Batch . C 2  ]     =    color ;", "vertices [ Batch . C 3  ]     =    color ;", "vertices [ Batch . C 4  ]     =    color ;", "}", "METHOD_END"], "methodName": ["setAlpha"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . width    =    width ;", "this . height    =    height ;", "if    ( dirty )", "return ;", "float   x 2     =    x    +    width ;", "float   y 2     =    y    +    height ;", "float [  ]    vertices    =    this . vertices ;", "vertices [ Batch . X 1  ]     =    x ;", "vertices [ Batch . Y 1  ]     =    y ;", "vertices [ Batch . X 2  ]     =    x ;", "vertices [ Batch . Y 2  ]     =    y 2  ;", "vertices [ Batch . X 3  ]     =    x 2  ;", "vertices [ Batch . Y 3  ]     =    y 2  ;", "vertices [ Batch . X 4  ]     =    x 2  ;", "vertices [ Batch . Y 4  ]     =    y ;", "if    (  (  (  ( rotation )     !  =     0  )     |  |     (  ( scaleX )     !  =     1  )  )     |  |     (  ( scaleY )     !  =     1  )  )", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setBounds"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "setCenterX ( x )  ;", "setCenterY ( y )  ;", "}", "METHOD_END"], "methodName": ["setCenter"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "setX (  ( x    -     (  ( width )     /     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setCenterX"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "setY (  ( y    -     (  ( height )     /     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setCenterY"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "float   color    =    tint . toFloatBits (  )  ;", "float [  ]    vertices    =    this . vertices ;", "vertices [ Batch . C 1  ]     =    color ;", "vertices [ Batch . C 2  ]     =    color ;", "vertices [ Batch . C 3  ]     =    color ;", "vertices [ Batch . C 4  ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "float [  ]    vertices    =    this . vertices ;", "vertices [ Batch . C 1  ]     =    color ;", "vertices [ Batch . C 2  ]     =    color ;", "vertices [ Batch . C 3  ]     =    color ;", "vertices [ Batch . C 4  ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "int   intBits    =     (  (  (  (  ( int )     (  2  5  5     *    a )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *    b )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *    g )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *    r )  )  ;", "float   color    =    NumberUtils . intToFloatColor ( intBits )  ;", "float [  ]    vertices    =    this . vertices ;", "vertices [ Batch . C 1  ]     =    color ;", "vertices [ Batch . C 2  ]     =    color ;", "vertices [ Batch . C 3  ]     =    color ;", "vertices [ Batch . C 4  ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "boolean   performX    =    false ;", "boolean   performY    =    false ;", "if    (  ( isFlipX (  )  )     !  =    x )     {", "performX    =    true ;", "}", "if    (  ( isFlipY (  )  )     !  =    y )     {", "performY    =    true ;", "}", "flip ( performX ,    performY )  ;", "}", "METHOD_END"], "methodName": ["setFlip"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . originX    =    originX ;", "this . originY    =    originY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "setPosition (  ( x    -     ( this . originX )  )  ,     ( y    -     ( this . originY )  )  )  ;", "}", "METHOD_END"], "methodName": ["setOriginBasedPosition"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . originX    =     ( width )     /     2  ;", "this . originY    =     ( height )     /     2  ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setOriginCenter"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "translate (  ( x    -     ( this . x )  )  ,     ( y    -     ( this . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "super . setRegion ( u ,    v ,    u 2  ,    v 2  )  ;", "float [  ]    vertices    =    this . vertices ;", "vertices [ Batch . U 1  ]     =    u ;", "vertices [ Batch . V 1  ]     =    v 2  ;", "vertices [ Batch . U 2  ]     =    u ;", "vertices [ Batch . V 2  ]     =    v ;", "vertices [ Batch . U 3  ]     =    u 2  ;", "vertices [ Batch . V 3  ]     =    v ;", "vertices [ Batch . U 4  ]     =    u 2  ;", "vertices [ Batch . V 4  ]     =    v 2  ;", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . rotation    =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleXY ;", "this . scaleY    =    scaleXY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleX ;", "this . scaleY    =    scaleY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "this . height    =    height ;", "if    ( dirty )", "return ;", "float   x 2     =     ( x )     +    width ;", "float   y 2     =     ( y )     +    height ;", "float [  ]    vertices    =    this . vertices ;", "vertices [ Batch . X 1  ]     =    x ;", "vertices [ Batch . Y 1  ]     =    y ;", "vertices [ Batch . X 2  ]     =    x ;", "vertices [ Batch . Y 2  ]     =    y 2  ;", "vertices [ Batch . X 3  ]     =    x 2  ;", "vertices [ Batch . Y 3  ]     =    y 2  ;", "vertices [ Batch . X 4  ]     =    x 2  ;", "vertices [ Batch . Y 4  ]     =    y ;", "if    (  (  (  ( rotation )     !  =     0  )     |  |     (  ( scaleX )     !  =     1  )  )     |  |     (  ( scaleY )     !  =     1  )  )", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "super . setU ( u )  ;", "vertes [ Batch . U 1  ]     =    u ;", "vertes [ Batch . U 2  ]     =    u ;", "}", "METHOD_END"], "methodName": ["setU"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "super . setU 2  ( u 2  )  ;", "vertes [ Batch . U 3  ]     =    u 2  ;", "vertes [ Batch . U 4  ]     =    u 2  ;", "}", "METHOD_END"], "methodName": ["setU2"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "super . setV ( v )  ;", "vertes [ Batch . V 2  ]     =    v ;", "vertes [ Batch . V 3  ]     =    v ;", "}", "METHOD_END"], "methodName": ["setV"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "super . setV 2  ( v 2  )  ;", "vertes [ Batch . V 1  ]     =    v 2  ;", "vertes [ Batch . V 4  ]     =    v 2  ;", "}", "METHOD_END"], "methodName": ["setV2"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "translateX (  ( x    -     ( this . x )  )  )  ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "translateY (  ( y    -     ( this . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "x    +  =    xAmount ;", "y    +  =    yAmount ;", "if    ( dirty )", "return ;", "fat [  ]    vertices    =    this . vertices ;", "vertices [ Batch . X 1  ]     +  =    xAmount ;", "vertices [ Batch . Y 1  ]     +  =    yAmount ;", "vertices [ Batch . X 2  ]     +  =    xAmount ;", "vertices [ Batch . Y 2  ]     +  =    yAmount ;", "vertices [ Batch . X 3  ]     +  =    xAmount ;", "vertices [ Batch . Y 3  ]     +  =    yAmount ;", "vertices [ Batch . X 4  ]     +  =    xAmount ;", "vertices [ Batch . Y 4  ]     +  =    yAmount ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    xAmount ;", "if    ( dirty )", "return ;", "float [  ]    vertices    =    this . vertices ;", "vertices [ Batch . X 1  ]     +  =    xAmount ;", "vertices [ Batch . X 2  ]     +  =    xAmount ;", "vertices [ Batch . X 3  ]     +  =    xAmount ;", "vertices [ Batch . X 4  ]     +  =    xAmount ;", "}", "METHOD_END"], "methodName": ["translateX"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "y    +  =    yAmount ;", "if    ( dirty )", "return ;", "fat [  ]    vertices    =    this . vertices ;", "vertices [ Batch . Y 1  ]     +  =    yAmount ;", "vertices [ Batch . Y 2  ]     +  =    yAmount ;", "vertices [ Batch . Y 3  ]     +  =    yAmount ;", "vertices [ Batch . Y 4  ]     +  =    yAmount ;", "}", "METHOD_END"], "methodName": ["translateY"], "fileName": "com.badlogic.gdx.graphics.g2d.Sprite"}, {"methodBody": ["METHOD_START", "{", "String   vertexShader    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" attribute   vec 4     \"     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 4     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 2     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \" uniform   mat 4    u _ projTrans ;  \\ n \"  )     +     \" varying   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \"  \\ n \"  )     +     \" void   main (  )  \\ n \"  )     +     \"  {  \\ n \"  )     +     \"          v _ color    =     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"          v _ color . a    =    v _ color . a    *     (  2  5  5  .  0  /  2  5  4  .  0  )  ;  \\ n \"  )     +     \"          v _ texCoords    =     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \"          gl _ Position    =       u _ projTrans    *     \"  )     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"  }  \\ n \"  ;", "String   fragmentShader    =     \"  # ifdef   GL _ ES \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  \"  # define   LOWP   lowp \\ n \"     +     \" precision   mediump   float ;  \\ n \"  )     +     \"  # else \\ n \"  )     +     \"  # define   LOWP    \\ n \"  )     +     \"  # endif \\ n \"  )     +     \" varying   LOWP   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \" uniform   sampler 2 D   u _ texture ;  \\ n \"  )     +     \" void   main (  )  \\ n \"  )     +     \"  {  \\ n \"  )     +     \"       gl _ FragColor    =    v _ color    *    texture 2 D ( u _ texture ,    v _ texCoords )  ;  \\ n \"  )     +     \"  }  \"  )  ;", "ShaderProgram   shader    =    new   ShaderProgram ( vertexShader ,    fragmentShader )  ;", "if    (  ( shader . isCompiled (  )  )     =  =    false )", "throw   new   IllegalArgumentException (  (  \" Error   compiling   shader :     \"     +     ( shader . getLog (  )  )  )  )  ;", "return   shader ;", "}", "METHOD_END"], "methodName": ["createDefaultShader"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteBatch"}, {"methodBody": ["METHOD_START", "{", "return   drawing ;", "}", "METHOD_END"], "methodName": ["isDrawing"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteBatch"}, {"methodBody": ["METHOD_START", "{", "combinedMatrix . set ( projectionMatrix )  . mul ( transformMatrix )  ;", "if    (  ( customShader )     !  =    null )     {", "customShader . setUniformMatrix (  \" u _ projTrans \"  ,    combinedMatrix )  ;", "customShader . setUniformi (  \" u _ texture \"  ,     0  )  ;", "} else    {", "shader . setUniformMatrix (  \" u _ projTrans \"  ,    combinedMatrix )  ;", "shader . setUniformi (  \" u _ texture \"  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["setupMatrices"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteBatch"}, {"methodBody": ["METHOD_START", "{", "flush (  )  ;", "lastTexture    =    xture ;", "invTexWidth    =     1  .  0 F    /     ( xture . getWidth (  )  )  ;", "invTexHeight    =     1  .  0 F    /     ( xture . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["switchTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteBatch"}, {"methodBody": ["METHOD_START", "{", "final   float   fx 2     =    x    +     ( texture . getWidth (  )  )  ;", "final   float   fy 2     =    y    +     ( texture . getHeight (  )  )  ;", ". tempVertices [  0  ]     =    x ;", ". tempVertices [  1  ]     =    y ;", ". tempVertices [  2  ]     =    color ;", ". tempVertices [  3  ]     =     0  ;", ". tempVertices [  4  ]     =     1  ;", ". tempVertices [  5  ]     =    x ;", ". tempVertices [  6  ]     =    fy 2  ;", ". tempVertices [  7  ]     =    color ;", ". tempVertices [  8  ]     =     0  ;", ". tempVertices [  9  ]     =     0  ;", ". tempVertices [  1  0  ]     =    fx 2  ;", ". tempVertices [  1  1  ]     =    fy 2  ;", ". tempVertices [  1  2  ]     =    color ;", ". tempVertices [  1  3  ]     =     1  ;", ". tempVertices [  1  4  ]     =     0  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    y ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =     1  ;", ". tempVertices [  1  9  ]     =     1  ;", "add ( texture ,     . tempVertices ,     0  ,     2  0  )  ;", "} else    {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    fy 2  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =     1  ;", ". tempVertices [  1  9  ]     =     0  ;", ". tempVertices [  2  0  ]     =    fx 2  ;", ". tempVertices [  2  1  ]     =    y ;", ". tempVertices [  2  2  ]     =    color ;", ". tempVertices [  2  3  ]     =     1  ;", ". tempVertices [  2  4  ]     =     1  ;", ". tempVertices [  2  5  ]     =    x ;", ". tempVertices [  2  6  ]     =    y ;", ". tempVertices [  2  7  ]     =    color ;", ". tempVertices [  2  8  ]     =     0  ;", ". tempVertices [  2  9  ]     =     1  ;", "add ( texture ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "final   float   worldOriginX    =    x    +    originX ;", "final   float   worldOriginY    =    y    +    originY ;", "float   fx    =     - originX ;", "float   fy    =     - originY ;", "float   fx 2     =    width    -    originX ;", "float   fy 2     =    height    -    originY ;", "if    (  ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  )     {", "fx    *  =    scaleX ;", "fy    *  =    scaleY ;", "fx 2     *  =    scaleX ;", "fy 2     *  =    scaleY ;", "}", "final   float   p 1 x    =    fx ;", "final   float   p 1 y    =    fy ;", "final   float   p 2 x    =    fx ;", "final   float   p 2 y    =    fy 2  ;", "final   float   p 3 x    =    fx 2  ;", "final   float   p 3 y    =    fy 2  ;", "final   float   p 4 x    =    fx 2  ;", "final   float   p 4 y    =    fy ;", "float   x 1  ;", "float   y 1  ;", "float   x 2  ;", "float   y 2  ;", "float   x 3  ;", "float   y 3  ;", "float   x 4  ;", "float   y 4  ;", "if    ( rotation    !  =     0  )     {", "final   float   cos    =    MathUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MathUtils . sinDeg ( rotation )  ;", "x 1     =     ( cos    *    p 1 x )     -     ( sin    *    p 1 y )  ;", "y 1     =     ( sin    *    p 1 x )     +     ( cos    *    p 1 y )  ;", "x 2     =     ( cos    *    p 2 x )     -     ( sin    *    p 2 y )  ;", "y 2     =     ( sin    *    p 2 x )     +     ( cos    *    p 2 y )  ;", "x 3     =     ( cos    *    p 3 x )     -     ( sin    *    p 3 y )  ;", "y 3     =     ( sin    *    p 3 x )     +     ( cos    *    p 3 y )  ;", "x 4     =    x 1     +     ( x 3     -    x 2  )  ;", "y 4     =    y 3     -     ( y 2     -    y 1  )  ;", "} else    {", "x 1     =    p 1 x ;", "y 1     =    p 1 y ;", "x 2     =    p 2 x ;", "y 2     =    p 2 y ;", "x 3     =    p 3 x ;", "y 3     =    p 3 y ;", "x 4     =    p 4 x ;", "y 4     =    p 4 y ;", "}", "x 1     +  =    worldOriginX ;", "y 1     +  =    worldOriginY ;", "x 2     +  =    worldOriginX ;", "y 2     +  =    worldOriginY ;", "x 3     +  =    worldOriginX ;", "y 3     +  =    worldOriginY ;", "x 4     +  =    worldOriginX ;", "y 4     +  =    worldOriginY ;", "float   invTexWidth    =     1  .  0 F    /     ( texture . getWidth (  )  )  ;", "float   invTexHeight    =     1  .  0 F    /     ( texture . getHeight (  )  )  ;", "float   u    =    srcX    *    invTexWidth ;", "float   v    =     ( srcY    +    srcHeight )     *    invTexHeight ;", "float   u 2     =     ( srcX    +    srcWidth )     *    invTexWidth ;", "float   v 2     =    srcY    *    invTexHeight ;", "if    ( flipX )     {", "float   tmp    =    u ;", "u    =    u 2  ;", "u 2     =    tmp ;", "}", "if    ( flipY )     {", "float   tmp    =    v ;", "v    =    v 2  ;", "v 2     =    tmp ;", "}", ". tempVertices [  0  ]     =    x 1  ;", ". tempVertices [  1  ]     =    y 1  ;", ". tempVertices [  2  ]     =    color ;", ". tempVertices [  3  ]     =    u ;", ". tempVertices [  4  ]     =    v ;", ". tempVertices [  5  ]     =    x 2  ;", ". tempVertices [  6  ]     =    y 2  ;", ". tempVertices [  7  ]     =    color ;", ". tempVertices [  8  ]     =    u ;", ". tempVertices [  9  ]     =    v 2  ;", ". tempVertices [  1  0  ]     =    x 3  ;", ". tempVertices [  1  1  ]     =    y 3  ;", ". tempVertices [  1  2  ]     =    color ;", ". tempVertices [  1  3  ]     =    u 2  ;", ". tempVertices [  1  4  ]     =    v 2  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". tempVertices [  1  5  ]     =    x 4  ;", ". tempVertices [  1  6  ]     =    y 4  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     2  0  )  ;", "} else    {", ". tempVertices [  1  5  ]     =    x 3  ;", ". tempVertices [  1  6  ]     =    y 3  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v 2  ;", ". tempVertices [  2  0  ]     =    x 4  ;", ". tempVertices [  2  1  ]     =    y 4  ;", ". tempVertices [  2  2  ]     =    color ;", ". tempVertices [  2  3  ]     =    u 2  ;", ". tempVertices [  2  4  ]     =    v ;", ". tempVertices [  2  5  ]     =    x 1  ;", ". tempVertices [  2  6  ]     =    y 1  ;", ". tempVertices [  2  7  ]     =    color ;", ". tempVertices [  2  8  ]     =    u ;", ". tempVertices [  2  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "float   invTexWidth    =     1  .  0 F    /     ( texture . getWidth (  )  )  ;", "float   invTexHeight    =     1  .  0 F    /     ( texture . getHeight (  )  )  ;", "float   u    =    srcX    *    invTexWidth ;", "float   v    =     ( srcY    +    srcHeight )     *    invTexHeight ;", "float   u 2     =     ( srcX    +    srcWidth )     *    invTexWidth ;", "float   v 2     =    srcY    *    invTexHeight ;", "final   float   fx 2     =    x    +    width ;", "final   float   fy 2     =    y    +    height ;", "if    ( flipX )     {", "float   tmp    =    u ;", "u    =    u 2  ;", "u 2     =    tmp ;", "}", "if    ( flipY )     {", "float   tmp    =    v ;", "v    =    v 2  ;", "v 2     =    tmp ;", "}", ". tempVertices [  0  ]     =    x ;", ". tempVertices [  1  ]     =    y ;", ". tempVertices [  2  ]     =    color ;", ". tempVertices [  3  ]     =    u ;", ". tempVertices [  4  ]     =    v ;", ". tempVertices [  5  ]     =    x ;", ". tempVertices [  6  ]     =    fy 2  ;", ". tempVertices [  7  ]     =    color ;", ". tempVertices [  8  ]     =    u ;", ". tempVertices [  9  ]     =    v 2  ;", ". tempVertices [  1  0  ]     =    fx 2  ;", ". tempVertices [  1  1  ]     =    fy 2  ;", ". tempVertices [  1  2  ]     =    color ;", ". tempVertices [  1  3  ]     =    u 2  ;", ". tempVertices [  1  4  ]     =    v 2  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    y ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     2  0  )  ;", "} else    {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    fy 2  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v 2  ;", ". tempVertices [  2  0  ]     =    fx 2  ;", ". tempVertices [  2  1  ]     =    y ;", ". tempVertices [  2  2  ]     =    color ;", ". tempVertices [  2  3  ]     =    u 2  ;", ". tempVertices [  2  4  ]     =    v ;", ". tempVertices [  2  5  ]     =    x ;", ". tempVertices [  2  6  ]     =    y ;", ". tempVertices [  2  7  ]     =    color ;", ". tempVertices [  2  8  ]     =    u ;", ". tempVertices [  2  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "final   float   fx 2     =    x    +    srcWidth ;", "final   float   fy 2     =    y    +    srcHeight ;", ". tempVertices [  0  ]     =    x ;", ". tempVertices [  1  ]     =    y ;", ". tempVertices [  2  ]     =    color ;", ". tempVertices [  3  ]     =    u ;", ". tempVertices [  4  ]     =    v ;", ". tempVertices [  5  ]     =    x ;", ". tempVertices [  6  ]     =    fy 2  ;", ". tempVertices [  7  ]     =    color ;", ". tempVertices [  8  ]     =    u ;", ". tempVertices [  9  ]     =    v 2  ;", ". tempVertices [  1  0  ]     =    fx 2  ;", ". tempVertices [  1  1  ]     =    fy 2  ;", ". tempVertices [  1  2  ]     =    color ;", ". tempVertices [  1  3  ]     =    u 2  ;", ". tempVertices [  1  4  ]     =    v 2  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    y ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     2  0  )  ;", "} else    {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    fy 2  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v 2  ;", ". tempVertices [  2  0  ]     =    fx 2  ;", ". tempVertices [  2  1  ]     =    y ;", ". tempVertices [  2  2  ]     =    color ;", ". tempVertices [  2  3  ]     =    u 2  ;", ". tempVertices [  2  4  ]     =    v ;", ". tempVertices [  2  5  ]     =    x ;", ". tempVertices [  2  6  ]     =    y ;", ". tempVertices [  2  7  ]     =    color ;", ". tempVertices [  2  8  ]     =    u ;", ". tempVertices [  2  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "float   invTexWidth    =     1  .  0 F    /     ( texture . getWidth (  )  )  ;", "float   invTexHeight    =     1  .  0 F    /     ( texture . getHeight (  )  )  ;", "final   float   u    =    srcX    *    invTexWidth ;", "final   float   v    =     ( srcY    +    srcHeight )     *    invTexHeight ;", "final   float   u 2     =     ( srcX    +    srcWidth )     *    invTexWidth ;", "final   float   v 2     =    srcY    *    invTexHeight ;", "final   float   fx 2     =    x    +    srcWidth ;", "final   float   fy 2     =    y    +    srcHeight ;", ". tempVertices [  0  ]     =    x ;", ". tempVertices [  1  ]     =    y ;", ". tempVertices [  2  ]     =    color ;", ". tempVertices [  3  ]     =    u ;", ". tempVertices [  4  ]     =    v ;", ". tempVertices [  5  ]     =    x ;", ". tempVertices [  6  ]     =    fy 2  ;", ". tempVertices [  7  ]     =    color ;", ". tempVertices [  8  ]     =    u ;", ". tempVertices [  9  ]     =    v 2  ;", ". tempVertices [  1  0  ]     =    fx 2  ;", ". tempVertices [  1  1  ]     =    fy 2  ;", ". tempVertices [  1  2  ]     =    color ;", ". tempVertices [  1  3  ]     =    u 2  ;", ". tempVertices [  1  4  ]     =    v 2  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    y ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     2  0  )  ;", "} else    {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    fy 2  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v 2  ;", ". tempVertices [  2  0  ]     =    fx 2  ;", ". tempVertices [  2  1  ]     =    y ;", ". tempVertices [  2  2  ]     =    color ;", ". tempVertices [  2  3  ]     =    u 2  ;", ". tempVertices [  2  4  ]     =    v ;", ". tempVertices [  2  5  ]     =    x ;", ". tempVertices [  2  6  ]     =    y ;", ". tempVertices [  2  7  ]     =    color ;", ". tempVertices [  2  8  ]     =    u ;", ". tempVertices [  2  9  ]     =    v ;", "add ( texture ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentCache )     =  =    null )", "throw   new   IllegalStateException (  \" beginCache   must   be   called   before   add .  \"  )  ;", "int   verticesPerImage    =     (  ( mesh . getNumIndices (  )  )     >     0  )     ?     4     :     6  ;", "int   count    =     ( length    /     ( verticesPerImage    *     (  . VERTEX _ SIZE )  )  )     *     6  ;", "int   lastIndex    =     ( textures . size )     -     1  ;", "if    (  ( lastIndex    <     0  )     |  |     (  ( textures . get ( lastIndex )  )     !  =    texture )  )     {", "textures . add ( texture )  ;", "counts . add ( count )  ;", "} else", "counts . incr ( lastIndex ,    count )  ;", "mesh . getVerticesBuffer (  )  . put ( vertices ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", "add ( sprite . getTexture (  )  ,    sprite . getVertices (  )  ,     0  ,    Sprite . SPRITE _ SIZE )  ;", "return ;", "}", "float [  ]    spriteVertices    =    sprite . getVertices (  )  ;", "System . arraycopy ( spriteVertices ,     0  ,     . tempVertices ,     0  ,     (  3     *     ( Sprite . VERTEX _ SIZE )  )  )  ;", "System . arraycopy ( spriteVertices ,     (  2     *     ( Sprite . VERTEX _ SIZE )  )  ,     . tempVertices ,     (  3     *     ( Sprite . VERTEX _ SIZE )  )  ,    Sprite . VERTEX _ SIZE )  ;", "System . arraycopy ( spriteVertices ,     (  3     *     ( Sprite . VERTEX _ SIZE )  )  ,     . tempVertices ,     (  4     *     ( Sprite . VERTEX _ SIZE )  )  ,    Sprite . VERTEX _ SIZE )  ;", "System . arraycopy ( spriteVertices ,     0  ,     . tempVertices ,     (  5     *     ( Sprite . VERTEX _ SIZE )  )  ,    Sprite . VERTEX _ SIZE )  ;", "add ( sprite . getTexture (  )  ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "add ( region ,    x ,    y ,    region . getRegionWidth (  )  ,    region . getRegionHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "final   float   fx 2     =    x    +    width ;", "final   float   fy 2     =    y    +    height ;", "final   float   u    =    region . u ;", "final   float   v    =    region . v 2  ;", "final   float   u 2     =    region . u 2  ;", "final   float   v 2     =    region . v ;", ". tempVertices [  0  ]     =    x ;", ". tempVertices [  1  ]     =    y ;", ". tempVertices [  2  ]     =    color ;", ". tempVertices [  3  ]     =    u ;", ". tempVertices [  4  ]     =    v ;", ". tempVertices [  5  ]     =    x ;", ". tempVertices [  6  ]     =    fy 2  ;", ". tempVertices [  7  ]     =    color ;", ". tempVertices [  8  ]     =    u ;", ". tempVertices [  9  ]     =    v 2  ;", ". tempVertices [  1  0  ]     =    fx 2  ;", ". tempVertices [  1  1  ]     =    fy 2  ;", ". tempVertices [  1  2  ]     =    color ;", ". tempVertices [  1  3  ]     =    u 2  ;", ". tempVertices [  1  4  ]     =    v 2  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    y ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v ;", "add ( region . texture ,     . tempVertices ,     0  ,     2  0  )  ;", "} else    {", ". tempVertices [  1  5  ]     =    fx 2  ;", ". tempVertices [  1  6  ]     =    fy 2  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v 2  ;", ". tempVertices [  2  0  ]     =    fx 2  ;", ". tempVertices [  2  1  ]     =    y ;", ". tempVertices [  2  2  ]     =    color ;", ". tempVertices [  2  3  ]     =    u 2  ;", ". tempVertices [  2  4  ]     =    v ;", ". tempVertices [  2  5  ]     =    x ;", ". tempVertices [  2  6  ]     =    y ;", ". tempVertices [  2  7  ]     =    color ;", ". tempVertices [  2  8  ]     =    u ;", ". tempVertices [  2  9  ]     =    v ;", "add ( region . texture ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "final   float   worldOriginX    =    x    +    originX ;", "final   float   worldOriginY    =    y    +    originY ;", "float   fx    =     - originX ;", "float   fy    =     - originY ;", "float   fx 2     =    width    -    originX ;", "float   fy 2     =    height    -    originY ;", "if    (  ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  )     {", "fx    *  =    scaleX ;", "fy    *  =    scaleY ;", "fx 2     *  =    scaleX ;", "fy 2     *  =    scaleY ;", "}", "final   float   p 1 x    =    fx ;", "final   float   p 1 y    =    fy ;", "final   float   p 2 x    =    fx ;", "final   float   p 2 y    =    fy 2  ;", "final   float   p 3 x    =    fx 2  ;", "final   float   p 3 y    =    fy 2  ;", "final   float   p 4 x    =    fx 2  ;", "final   float   p 4 y    =    fy ;", "float   x 1  ;", "float   y 1  ;", "float   x 2  ;", "float   y 2  ;", "float   x 3  ;", "float   y 3  ;", "float   x 4  ;", "float   y 4  ;", "if    ( rotation    !  =     0  )     {", "final   float   cos    =    MathUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MathUtils . sinDeg ( rotation )  ;", "x 1     =     ( cos    *    p 1 x )     -     ( sin    *    p 1 y )  ;", "y 1     =     ( sin    *    p 1 x )     +     ( cos    *    p 1 y )  ;", "x 2     =     ( cos    *    p 2 x )     -     ( sin    *    p 2 y )  ;", "y 2     =     ( sin    *    p 2 x )     +     ( cos    *    p 2 y )  ;", "x 3     =     ( cos    *    p 3 x )     -     ( sin    *    p 3 y )  ;", "y 3     =     ( sin    *    p 3 x )     +     ( cos    *    p 3 y )  ;", "x 4     =    x 1     +     ( x 3     -    x 2  )  ;", "y 4     =    y 3     -     ( y 2     -    y 1  )  ;", "} else    {", "x 1     =    p 1 x ;", "y 1     =    p 1 y ;", "x 2     =    p 2 x ;", "y 2     =    p 2 y ;", "x 3     =    p 3 x ;", "y 3     =    p 3 y ;", "x 4     =    p 4 x ;", "y 4     =    p 4 y ;", "}", "x 1     +  =    worldOriginX ;", "y 1     +  =    worldOriginY ;", "x 2     +  =    worldOriginX ;", "y 2     +  =    worldOriginY ;", "x 3     +  =    worldOriginX ;", "y 3     +  =    worldOriginY ;", "x 4     +  =    worldOriginX ;", "y 4     +  =    worldOriginY ;", "final   float   u    =    region . u ;", "final   float   v    =    region . v 2  ;", "final   float   u 2     =    region . u 2  ;", "final   float   v 2     =    region . v ;", ". tempVertices [  0  ]     =    x 1  ;", ". tempVertices [  1  ]     =    y 1  ;", ". tempVertices [  2  ]     =    color ;", ". tempVertices [  3  ]     =    u ;", ". tempVertices [  4  ]     =    v ;", ". tempVertices [  5  ]     =    x 2  ;", ". tempVertices [  6  ]     =    y 2  ;", ". tempVertices [  7  ]     =    color ;", ". tempVertices [  8  ]     =    u ;", ". tempVertices [  9  ]     =    v 2  ;", ". tempVertices [  1  0  ]     =    x 3  ;", ". tempVertices [  1  1  ]     =    y 3  ;", ". tempVertices [  1  2  ]     =    color ;", ". tempVertices [  1  3  ]     =    u 2  ;", ". tempVertices [  1  4  ]     =    v 2  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". tempVertices [  1  5  ]     =    x 4  ;", ". tempVertices [  1  6  ]     =    y 4  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v ;", "add ( region . texture ,     . tempVertices ,     0  ,     2  0  )  ;", "} else    {", ". tempVertices [  1  5  ]     =    x 3  ;", ". tempVertices [  1  6  ]     =    y 3  ;", ". tempVertices [  1  7  ]     =    color ;", ". tempVertices [  1  8  ]     =    u 2  ;", ". tempVertices [  1  9  ]     =    v 2  ;", ". tempVertices [  2  0  ]     =    x 4  ;", ". tempVertices [  2  1  ]     =    y 4  ;", ". tempVertices [  2  2  ]     =    color ;", ". tempVertices [  2  3  ]     =    u 2  ;", ". tempVertices [  2  4  ]     =    v ;", ". tempVertices [  2  5  ]     =    x 1  ;", ". tempVertices [  2  6  ]     =    y 1  ;", ". tempVertices [  2  7  ]     =    color ;", ". tempVertices [  2  8  ]     =    u ;", ". tempVertices [  2  9  ]     =    v ;", "add ( region . texture ,     . tempVertices ,     0  ,     3  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    ( drawing )", "throw   new   IllegalStateException (  \" end   must   be   called   before   begin .  \"  )  ;", "if    (  ( current )     !  =    null )", "throw   new   IllegalStateException (  \" end   must   be   called   before   begin \"  )  ;", "renderCalls    =     0  ;", "combinedMatrix . set ( projectionMatrix )  . mul ( transformMatrix )  ;", "Gdx . gl 2  0  . glDepthMask ( false )  ;", "if    (  ( customShader )     !  =    null )     {", "customShader . begin (  )  ;", "customShader . setUniformMatrix (  \" u _ proj \"  ,    projectionMatrix )  ;", "customShader . setUniformMatrix (  \" u _ trans \"  ,    transformMatrix )  ;", "customShader . setUniformMatrix (  \" u _ projTrans \"  ,    combinedMatrix )  ;", "customShader . setUniformi (  \" u _ texture \"  ,     0  )  ;", "mesh . bind ( customShader )  ;", "} else    {", "shader . begin (  )  ;", "shader . setUniformMatrix (  \" u _ projectionViewMatrix \"  ,    combinedMatrix )  ;", "shader . setUniformi (  \" u _ texture \"  ,     0  )  ;", "mesh . bind ( shader )  ;", "}", "drawing    =    true ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    ( drawing )", "throw   new   IllegalStateException (  \" end   must   be   called   before   beginCache \"  )  ;", "if    (  ( currentCache )     !  =    null )", "throw   new   IllegalStateException (  \" endCache   must   be   called   before   begin .  \"  )  ;", "int   verticesPerImage    =     (  ( mesh . getNumIndices (  )  )     >     0  )     ?     4     :     6  ;", "currentCache    =    new    . Cache ( caches . size ,    mesh . getVerticesBuffer (  )  . limit (  )  )  ;", "caches . add ( currentCache )  ;", "mesh . getVerticesBuffer (  )  . compact (  )  ;", "}", "METHOD_END"], "methodName": ["beginCache"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    ( drawing )", "throw   new   IllegalStateException (  \" end   must   be   called   before   beginCache \"  )  ;", "if    (  ( currentCache )     !  =    null )", "throw   new   IllegalStateException (  \" endCache   must   be   called   before   begin .  \"  )  ;", "if    ( cacheID    =  =     (  ( caches . size )     -     1  )  )     {", ". Cache   oldCache    =    caches . removeIndex ( cacheID )  ;", "mesh . getVerticesBuffer (  )  . limit ( oldCache . offset )  ;", "beginCache (  )  ;", "return ;", "}", "currentCache    =    caches . get ( cacheID )  ;", "mesh . getVerticesBuffer (  )  . position ( currentCache . offset )  ;", "}", "METHOD_END"], "methodName": ["beginCache"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "caches . clear (  )  ;", "mesh . getVerticesBuffer (  )  . clear (  )  . flip (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "String   vertexShader    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" attribute   vec 4     \"     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 4     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 2     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \" uniform   mat 4    u _ projectionViewMatrix ;  \\ n \"  )     +     \" varying   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \"  \\ n \"  )     +     \" void   main (  )  \\ n \"  )     +     \"  {  \\ n \"  )     +     \"          v _ color    =     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"          v _ color . a    =    v _ color . a    *     (  2  5  5  .  0  /  2  5  4  .  0  )  ;  \\ n \"  )     +     \"          v _ texCoords    =     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \"          gl _ Position    =       u _ projectionViewMatrix    *     \"  )     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"  }  \\ n \"  ;", "String   fragmentShader    =     \"  # ifdef   GL _ ES \\ n \"     +     (  (  (  (  (  (  (  (  \" precision   mediump   float ;  \\ n \"     +     \"  # endif \\ n \"  )     +     \" varying   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \" uniform   sampler 2 D   u _ texture ;  \\ n \"  )     +     \" void   main (  )  \\ n \"  )     +     \"  {  \\ n \"  )     +     \"       gl _ FragColor    =    v _ color    *    texture 2 D ( u _ texture ,    v _ texCoords )  ;  \\ n \"  )     +     \"  }  \"  )  ;", "ShaderProgram   shader    =    new   ShaderProgram ( vertexShader ,    fragmentShader )  ;", "if    (  ( shader . isCompiled (  )  )     =  =    false )", "throw   new   IllegalArgumentException (  (  \" Error   compiling   shader :     \"     +     ( shader . getLog (  )  )  )  )  ;", "return   shader ;", "}", "METHOD_END"], "methodName": ["createDefaultShader"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "mesh . dispose (  )  ;", "if    (  ( sher )     !  =    null )", "sher . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \" SpriteCache . begin   must   be   called   before   draw .  \"  )  ;", "SpriteCache . Cache   cache    =    caches . get ( cacheID )  ;", "int   verticesPerImage    =     (  ( mesh . getNumIndices (  )  )     >     0  )     ?     4     :     6  ;", "int   offset    =     (  ( cache . offset )     /     ( verticesPerImage    *     ( Sprite . VERTEX _ SIZE )  )  )     *     6  ;", "Texture [  ]    textures    =    cache . textures ;", "int [  ]    counts    =    cache . counts ;", "int   textureCount    =    cache . textureCount ;", "for    ( int   i    =     0  ;    i    <    textureCount ;    i +  +  )     {", "int   count    =    counts [ i ]  ;", "textures [ i ]  . bind (  )  ;", "if    (  ( customShader )     !  =    null )", "mesh . render ( customShader ,    GL 2  0  . GL _ TRIANGLES ,    offset ,    count )  ;", "else", "mesh . render ( shader ,    GL 2  0  . GL _ TRIANGLES ,    offset ,    count )  ;", "offset    +  =    count ;", "}", "renderCalls    +  =    textureCount ;", "totalRenderCalls    +  =    textureCount ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \" SpriteCache . begin   must   be   called   before   draw .  \"  )  ;", "SpriteCache . Cache   cache    =    caches . get ( cacheID )  ;", "offset    =     ( offset    *     6  )     +     ( cache . offset )  ;", "length    *  =     6  ;", "Texture [  ]    textures    =    cache . textures ;", "int [  ]    counts    =    cache . counts ;", "int   textureCount    =    cache . textureCount ;", "for    ( int   i    =     0  ;    i    <    textureCount ;    i +  +  )     {", "textures [ i ]  . bind (  )  ;", "int   count    =    counts [ i ]  ;", "if    ( count    >    length )     {", "i    =    textureCount ;", "count    =    length ;", "} else", "length    -  =    count ;", "if    (  ( customShader )     !  =    null )", "mesh . render ( customShader ,    GL 2  0  . GL _ TRIANGLES ,    offset ,    count )  ;", "else", "mesh . render ( shader ,    GL 2  0  . GL _ TRIANGLES ,    offset ,    count )  ;", "offset    +  =    count ;", "}", "renderCalls    +  =    cache . textureCount ;", "totalRenderCalls    +  =    textureCount ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( drawing )  )", "throw   new   IllegalStateException (  \" begin   must   be   called   before   end .  \"  )  ;", "drawing    =    false ;", "shader . end (  )  ;", "GL 2  0    gl    =    Gl 2  0  ;", "gl . glDepthMask ( true )  ;", "if    (  ( customShader )     !  =    null )", "mesh . unbind ( customShader )  ;", "else", "mesh . unbind ( shader )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentCache )     =  =    null )", "throw   new   IllegalStateException (  \" beginCache   must   be   called   before   endCache .  \"  )  ;", ". Cache   cache    =    currentCache ;", "int   cacheCount    =     ( mesh . getVerticesBuffer (  )  . position (  )  )     -     ( cache . offset )  ;", "if    (  ( cache . textures )     =  =    null )     {", "cache . maxCount    =    cacheCount ;", "cache . textureCount    =    textures . size ;", "cache . textures    =    textures . toArray ( Texture . class )  ;", "cache . counts    =    new   int [ cache . textureCount ]  ;", "for    ( int   i    =     0  ,    n    =    counts . size ;    i    <    n ;    i +  +  )", "cache . counts [ i ]     =    counts . get ( i )  ;", "mesh . getVerticesBuffer (  )  . flip (  )  ;", "} else    {", "if    ( cacheCount    >     ( cache . maxCount )  )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" If   a   cache   is   not   the   last   created ,    it   cannot   be   redefined   with   more   entries   than   when   it   was   first   created :     \"     +    cacheCount )     +     \"     (  \"  )     +     ( cache . maxCount )  )     +     \"    max )  \"  )  )  ;", "}", "cache . textureCount    =    textures . size ;", "if    (  ( cache . textures . length )     <     ( cache . textureCount )  )", "cache . textures    =    new   Texture [ cache . textureCount ]  ;", "for    ( int   i    =     0  ,    n    =    cache . textureCount ;    i    <    n ;    i +  +  )", "cache . textures [ i ]     =    textures . get ( i )  ;", "if    (  ( cache . counts . length )     <     ( cache . textureCount )  )", "cache . counts    =    new   int [ cache . textureCount ]  ;", "for    ( int   i    =     0  ,    n    =    cache . textureCount ;    i    <    n ;    i +  +  )", "cache . counts [ i ]     =    counts . get ( i )  ;", "FloatBuffer   vertices    =    mesh . getVerticesBuffer (  )  ;", "vertices . position (  0  )  ;", ". Cache   lastCache    =    caches . get (  (  ( caches . size )     -     1  )  )  ;", "vertices . limit (  (  ( lastCache . offset )     +     ( lastCache . maxCount )  )  )  ;", "}", "currentCache    =    null ;", "textures . clear (  )  ;", "counts . clear (  )  ;", "return   cache . id ;", "}", "METHOD_END"], "methodName": ["endCache"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "int   intBits    =    NumberUtils . floatToIntColor ( color )  ;", "Color   color    =    this . tempColor ;", "color . r    =     ( intBits    &     2  5  5  )     /     2  5  5  .  0 F ;", "color . g    =     (  ( intBits    >  >  >     8  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "color . b    =     (  ( intBits    >  >  >     1  6  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "color . a    =     (  ( intBits    >  >  >     2  4  )     &     2  5  5  )     /     2  5  5  .  0 F ;", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "return   projectionMatrix ;", "}", "METHOD_END"], "methodName": ["getProjectionMatrix"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "return   transformMatrix ;", "}", "METHOD_END"], "methodName": ["getTransformMatrix"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "color    =    tint . toFloatBits (  )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "int   intBits    =     (  (  (  (  ( int )     (  2  5  5     *    a )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *    b )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *    g )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *    r )  )  ;", "color    =    NumberUtils . intToFloatColor ( intBits )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    ( drawing )", "throw   new   IllegalStateException (  \" Can ' t   set   the   matrix   within   begin / end .  \"  )  ;", "projectionMatrix . set ( projection )  ;", "}", "METHOD_END"], "methodName": ["setProjectionMatrix"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "customShader    =    shader ;", "}", "METHOD_END"], "methodName": ["setShader"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "if    ( drawing )", "throw   new   IllegalStateException (  \" Can ' t   set   the   matrix   within   begin / end .  \"  )  ;", "transformMatrix . set ( transform )  ;", "}", "METHOD_END"], "methodName": ["setTransformMatrix"], "fileName": "com.badlogic.gdx.graphics.g2d.SpriteCache"}, {"methodBody": ["METHOD_START", "{", "textures . add ( texture )  ;", ". AtlasRegion   region    =    new    . AtlasRegion ( texture ,    x ,    y ,    width ,    height )  ;", "region . name    =    name ;", "region . originalWidth    =    width ;", "region . originalHeight    =    height ;", "region . index    =     -  1  ;", "regions . add ( region )  ;", "return   region ;", "}", "METHOD_END"], "methodName": ["addRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "return   addRegion ( name ,    textureRegion . texture ,    textureRegion . getRegionX (  )  ,    textureRegion . getRegionY (  )  ,    textureRegion . getRegionWidth (  )  ,    textureRegion . getRegionHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["addRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )     {", ". AtlasRegion   region    =    regions . get ( i )  ;", "if    ( region . name . equals ( name )  )     {", "int [  ]    splits    =    region . splits ;", "if    ( splits    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Region   does   not   have   ninepatch   splits :     \"     +    name )  )  ;", "NinePatch   patch    =    new   NinePatch ( region ,    splits [  0  ]  ,    splits [  1  ]  ,    splits [  2  ]  ,    splits [  3  ]  )  ;", "if    (  ( region . pads )     !  =    null )", "patch . setPadding ( region . pads [  0  ]  ,    region . pads [  1  ]  ,    region . pads [  2  ]  ,    region . pads [  3  ]  )  ;", "return   patch ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createPatch"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )", "if    ( regionet ( i )  . name . equals ( name )  )", "return   newSprite ( regionet ( i )  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["createSprite"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )     {", ". AtlasRegion   region    =    regions . get ( i )  ;", "if    (  !  ( region . name . equals ( name )  )  )", "continue ;", "if    (  ( region . index )     !  =    index )", "continue ;", "return   newSprite ( regions . get ( i )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createSprite"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "Array   sprites    =    new   Array ( true ,    regions . size ,    Sprite . class )  ;", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )", "sprites . add ( newSprite ( regions . get ( i )  )  )  ;", "return   sprites ;", "}", "METHOD_END"], "methodName": ["createSprites"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "Array < Sprite >    matched    =    new   Array ( Sprite . class )  ;", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )     {", ". AtlasRegion   region    =    regions . get ( i )  ;", "if    ( region . name . equals ( name )  )", "matched . add ( newSprite ( region )  )  ;", "}", "return   matched ;", "}", "METHOD_END"], "methodName": ["createSprites"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "for    ( Texture   texture    :    textures )", "texture . dispose (  )  ;", "textures . clear (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )", "if    ( regionet ( i )  . name . equals ( name )  )", "return   regionet ( i )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["findRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )     {", ". AtlasRegion   region    =    regions . get ( i )  ;", "if    (  !  ( region . name . equals ( name )  )  )", "continue ;", "if    (  ( region . index )     !  =    index )", "continue ;", "return   region ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "Array < TextureAtlas . AtlasRegion >    matched    =    new   Array ( TextureAtlas . AtlasRegion . class )  ;", "for    ( int   i    =     0  ,    n    =    regions . size ;    i    <    n ;    i +  +  )     {", "TextureAtlas . AtlasRegion   region    =    regions . get ( i )  ;", "if    ( region . name . equals ( name )  )", "matched . add ( new   TextureAtlas . AtlasRegion ( region )  )  ;", "}", "return   matched ;", "}", "METHOD_END"], "methodName": ["findRegions"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "return   regions ;", "}", "METHOD_END"], "methodName": ["getRegions"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "return   textures ;", "}", "METHOD_END"], "methodName": ["getTextures"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < TextureAtlas . TextureAtlasData . Page ,    Texture >    pageToTexture    =    new   ObjectMap < TextureAtlas . TextureAtlasData . Page ,    Texture >  (  )  ;", "for    ( TextureAtlas . TextureAtlasData . Page   page    :    data . pages )     {", "Texture   texture    =    null ;", "if    (  ( page . texture )     =  =    null )     {", "texture    =    new   Texture ( page . textureFile ,    page . format ,    page . useMipMaps )  ;", "texture . setFilter ( page . minFilter ,    page . magFilter )  ;", "texture . setWrap ( page . uWrap ,    page . vWrap )  ;", "} else    {", "texture    =    page . texture ;", "texture . setFilter ( page . minFilter ,    page . magFilter )  ;", "texture . setWrap ( page . uWrap ,    page . vWrap )  ;", "}", "textures . add ( texture )  ;", "pageToTexture . put ( page ,    texture )  ;", "}", "for    ( TextureAtlas . TextureAtlasData . Region   region    :    data . regions )     {", "int   width    =    region . width ;", "int   height    =    region . height ;", "TextureAtlas . AtlasRegion   atlasRegion    =    new   TextureAtlas . AtlasRegion ( pageToTexture . get ( region . page )  ,    region . left ,    region . top ,     ( region . rotate    ?    height    :    width )  ,     ( region . rotate    ?    width    :    height )  )  ;", "atlasRegion . index    =    region . index ;", "atlasRegion . name    =    region . name ;", "atlasRegion . offsetX    =    region . offsetX ;", "atlasRegion . offsetY    =    region . offsetY ;", "atlasRegion . originalHeight    =    region . originalHeight ;", "atlasRegion . originalWidth    =    region . originalWidth ;", "atlasRegion . rotate    =    region . rotate ;", "atlasRegion . splits    =    region . splits ;", "atlasRegion . pads    =    region . pads ;", "if    ( region . flip )", "atlasRegion . flip ( false ,    true )  ;", "regions . add ( atlasRegion )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( region . packedWidth )     =  =     ( region . originalWidth )  )     &  &     (  ( region . packedHeight )     =  =     ( region . originalHeight )  )  )     {", "if    ( region . rotate )     {", "Sprite   sprite    =    new   Sprite ( region )  ;", "sprite . setBounds (  0  ,     0  ,    region . getRegionHeight (  )  ,    region . getRegionWidth (  )  )  ;", "sprite . rotate 9  0  ( true )  ;", "return   sprite ;", "}", "return   new   Sprite ( region )  ;", "}", "return   new    . AtlasSprite ( region )  ;", "}", "METHOD_END"], "methodName": ["newSprite"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "String   line    =    reader . readLine (  )  ;", "int   colon    =    line . indexOf (  '  :  '  )  ;", "if    ( colon    =  =     (  -  1  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Invalid   line :     \"     +    line )  )  ;", "int   i    =     0  ;", "int   lastMatch    =    colon    +     1  ;", "for    ( i    =     0  ;    i    <     3  ;    i +  +  )     {", "int   comma    =    line . indexOf (  '  ,  '  ,    lastMatch )  ;", "if    ( comma    =  =     (  -  1  )  )", "break ;", "TextureAtlas . tuple [ i ]     =    line . substring ( lastMatch ,    comma )  . trim (  )  ;", "lastMatch    =    comma    +     1  ;", "}", "TextureAtlas . tuple [ i ]     =    line . substring ( lastMatch )  . trim (  )  ;", "return   i    +     1  ;", "}", "METHOD_END"], "methodName": ["readTuple"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "String   line    =    reader . readLine (  )  ;", "int   colon    =    line . indexOf (  '  :  '  )  ;", "if    ( colon    =  =     (  -  1  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Invalid   line :     \"     +    line )  )  ;", "return   line . substring (  ( colon    +     1  )  )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureAtlas"}, {"methodBody": ["METHOD_START", "{", "if    ( x )     {", "fat   temp    =    u ;", "u    =    u 2  ;", "u 2     =    temp ;", "}", "if    ( y )     {", "fat   temp    =    v ;", "v    =    v 2  ;", "v 2     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["flip"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   regionHeight ;", "}", "METHOD_END"], "methodName": ["getRegionHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   regionWidth ;", "}", "METHOD_END"], "methodName": ["getRegionWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   Math . round (  (  ( u )     *     ( texture . getWidth (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRegionX"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   Math . round (  (  ( v )     *     ( texture . getHeight (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRegionY"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   texture ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   u ;", "}", "METHOD_END"], "methodName": ["getU"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   u 2  ;", "}", "METHOD_END"], "methodName": ["getU2"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   v ;", "}", "METHOD_END"], "methodName": ["getV"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return   v 2  ;", "}", "METHOD_END"], "methodName": ["getV2"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return    ( u )     >     ( u 2  )  ;", "}", "METHOD_END"], "methodName": ["isFlipX"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return    ( v )     >     ( v 2  )  ;", "}", "METHOD_END"], "methodName": ["isFlipY"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "if    ( xAmount    !  =     0  )     {", "float   width    =     (  ( u 2  )     -     ( u )  )     *     ( t . getWidth (  )  )  ;", "u    =     (  ( u )     +    xAmount )     %     1  ;", "u 2     =     ( u )     +     ( width    /     ( t . getWidth (  )  )  )  ;", "}", "if    ( yAmount    !  =     0  )     {", "float   height    =     (  ( v 2  )     -     ( v )  )     *     ( t . getHeight (  )  )  ;", "v    =     (  ( v )     +    yAmount )     %     1  ;", "v 2     =     ( v )     +     ( height    /     ( t . getHeight (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["scroll"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "this . texture    =    texture ;", "setRegion (  0  ,     0  ,    texture . getWidth (  )  ,    texture . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "texture    =    region . texture ;", "setRegion ( region . u ,    region . v ,    region . u 2  ,    region . v 2  )  ;", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "texture    =    region . texture ;", "setRegion (  (  ( region . getRegionX (  )  )     +    x )  ,     (  ( region . getRegionY (  )  )     +    y )  ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "int   texWidth    =    texture . getWidth (  )  ;", "int   texHeight    =    texture . getHeight (  )  ;", "regionWidth    =    Math . round (  (  ( Math . abs (  ( u 2     -    u )  )  )     *    texWidth )  )  ;", "regionHeight    =    Math . round (  (  ( Math . abs (  ( v 2     -    v )  )  )     *    texHeight )  )  ;", "if    (  (  ( regionWidth )     =  =     1  )     &  &     (  ( regionHeight )     =  =     1  )  )     {", "float   adjustX    =     0  .  2  5 F    /    texWidth ;", "u    +  =    adjustX ;", "u 2     -  =    adjustX ;", "float   adjustY    =     0  .  2  5 F    /    texHeight ;", "v    +  =    adjustY ;", "v 2     -  =    adjustY ;", "}", "this . u    =    u ;", "this . v    =    v ;", "this . u 2     =    u 2  ;", "this . v 2     =    v 2  ;", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "float   invTexWidth    =     1  .  0 F    /     ( texture . getWidth (  )  )  ;", "float   invTexHeight    =     1  .  0 F    /     ( texture . getHeight (  )  )  ;", "setRegion (  ( x    *    invTexWidth )  ,     ( y    *    invTexHeight )  ,     (  ( x    +    width )     *    invTexWidth )  ,     (  ( y    +    height )     *    invTexHeight )  )  ;", "regionWidth    =    Math . abs ( width )  ;", "regionHeight    =    Math . abs ( height )  ;", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "if    ( isFlipY (  )  )     {", "setV (  (  ( v 2  )     +     ( height    /     (  ( float )     ( t . getHeight (  )  )  )  )  )  )  ;", "} else    {", "setV 2  (  (  ( v )     +     ( height    /     (  ( float )     ( t . getHeight (  )  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRegionHeight"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "if    ( isFlipX (  )  )     {", "setU (  (  ( u 2  )     +     ( width    /     (  ( float )     ( t . getWidth (  )  )  )  )  )  )  ;", "} else    {", "setU 2  (  (  ( u )     +     ( width    /     (  ( float )     ( t . getWidth (  )  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRegionWidth"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "setU (  ( x    /     (  ( float )     ( texture . getWidth (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setRegionX"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "setV (  ( y    /     (  ( float )     ( texture . getHeight (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setRegionY"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "this . texture    =    texture ;", "}", "METHOD_END"], "methodName": ["setTexture"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "this . u    =    u ;", "regionWidth    =    Math . round (  (  ( Math . abs (  (  ( u 2  )     -    u )  )  )     *     ( t . getWidth (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setU"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "this . u 2     =    u 2  ;", "regionWidth    =    Math . round (  (  ( Math . abs (  ( u 2     -     ( u )  )  )  )     *     ( t . getWidth (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setU2"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "this . v    =    v ;", "regionHeight    =    Math . round (  (  ( Math . abs (  (  ( v 2  )     -    v )  )  )     *     ( t . getHeight (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setV"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "this . v 2     =    v 2  ;", "regionHeight    =    Math . round (  (  ( Math . abs (  ( v 2     -     ( v )  )  )  )     *     ( t . getHeight (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setV2"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "TextureRegion   region    =    new   TextureRegion ( texture )  ;", "return   region . split ( tileWidth ,    tileHeight )  ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "int   x    =    getRegionX (  )  ;", "int   y    =    getRegionY (  )  ;", "int   width    =    regionWidth ;", "int   height    =    regionHeight ;", "int   rows    =    height    /    tileHeight ;", "int   cols    =    width    /    tileWidth ;", "int   startX    =    x ;", "[  ]  [  ]    tiles    =    new    [ rows ]  [ cols ]  ;", "for    ( int   row    =     0  ;    row    <    rows ;    row +  +     ,    y    +  =    tileHeight )     {", "x    =    startX ;", "for    ( int   col    =     0  ;    col    <    cols ;    col +  +     ,    x    +  =    tileWidth )     {", "tiles [ row ]  [ col ]     =    new    ( texture ,    x ,    y ,    tileWidth ,    tileHeight )  ;", "}", "}", "return   tiles ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "com.badlogic.gdx.graphics.g2d.TextureRegion"}, {"methodBody": ["METHOD_START", "{", "return    ( other . hashCode (  )  )     =  =     ( hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.g3d.Attribute"}, {"methodBody": ["METHOD_START", "{", "int   idx    =     -  1  ;", "while    (  (  ( type    !  =     0  )     &  &     (  (  +  + idx )     <     6  3  )  )     &  &     (  (  ( type    >  >    idx )     &     1  )     =  =     0  )  )  ;", "return    ( idx    >  =     0  )     &  &     ( idx    <     (  . types . size )  )     ?     . types . get ( idx )     :    null ;", "}", "METHOD_END"], "methodName": ["getAttributeAlias"], "fileName": "com.badlogic.gdx.graphics.g3d.Attribute"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( Attribute . types . size )  ;    i +  +  )", "if    (  ( Attribute . types . get ( i )  . compareTo ( alias )  )     =  =     0  )", "return    1 L    <  <    i ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["getAttributeType"], "fileName": "com.badlogic.gdx.graphics.g3d.Attribute"}, {"methodBody": ["METHOD_START", "{", "long   result    =    Attribute . getAttributeType ( alias )  ;", "if    ( result    >     0  )", "return   result ;", "Attribute . types . add ( alias )  ;", "return    1 L    <  <     (  ( Attribute . types . size )     -     1  )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "com.badlogic.gdx.graphics.g3d.Attribute"}, {"methodBody": ["METHOD_START", "{", "sort (  )  ;", "final   int   n    =    a . size ;", "long   result    =     7  1     +     ( mask )  ;", "int   m    =     1  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "result    +  =     (  ( mask )     *     ( a . get ( i )  . hashCode (  )  )  )     *     ( m    =     ( m    *     7  )     &     6  5  5  3  5  )  ;", "return    (  ( int )     ( result    ^     ( result    >  >     3  2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["attributesHash"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "mask    =     0  ;", "a . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "this . mask    &  =     ~ mask ;", "}", "METHOD_END"], "methodName": ["disable"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "this . mask    |  =    mask ;", "}", "METHOD_END"], "methodName": ["enable"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( attributes . size )  ;    i +  +  )", "if    (  (  ( attributes . get ( i )  . type )     &    type )     !  =     0  )", "out . add ( attributes . get ( i )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( get ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "if    ( has ( type )  )", "for    ( int   i    =     0  ;    i    <     ( a . size )  ;    i +  +  )", "if    (  ( a . get ( i )  . type )     =  =    type )", "return   a . get ( i )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "return   mask ;", "}", "METHOD_END"], "methodName": ["getMask"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "return    ( type    !  =     0  )     &  &     (  (  ( this . mask )     &    type )     =  =    type )  ;", "}", "METHOD_END"], "methodName": ["has"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "if    ( has ( type )  )", "for    ( int   i    =     0  ;    i    <     ( a . size )  ;    i +  +  )", "if    (  ( a . get ( i )  . type )     =  =    type )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( attributes . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "final   long   type    =    attributes . get ( i )  . type ;", "if    (  ( mask    &    type )     =  =    type )     {", "attributes . removeIndex ( i )  ;", "disable ( type )  ;", "sorted    =    false ;", "}", "}", "sort (  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "return   same ( other ,    false )  ;", "}", "METHOD_END"], "methodName": ["same"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "if    ( other    =  =     ( this )  )", "return   true ;", "if    (  ( other    =  =    null )     |  |     (  ( mask )     !  =     ( other . mask )  )  )", "return   false ;", "if    (  ! compareValues )", "return   true ;", "sort (  )  ;", "other . sort (  )  ;", "for    ( int   i    =     0  ;    i    <     ( a . size )  ;    i +  +  )", "if    (  !  ( a . get ( i )  . equals ( other . a . get ( i )  )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["same"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "final   int   idx    =    indexOf ( attribute . type )  ;", "if    ( idx    <     0  )     {", "enable ( attribute . type )  ;", "a . add ( attribute )  ;", "sorted    =    false ;", "} else    {", "a . set ( idx ,    attribute )  ;", "}", "sort (  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "set ( attribute 1  )  ;", "set ( attribute 2  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "set ( attribute 1  )  ;", "set ( attribute 2  )  ;", "set ( attribute 3  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "set ( attribute 1  )  ;", "set ( attribute 2  )  ;", "set ( attribute 3  )  ;", "set ( attribute 4  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Attribute   attr    :    attributes )", "set ( attr )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Attribute   attr    :    attributes )", "set ( attr )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "return   attributes . size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( sorted )  )     {", "a . sort ( this )  ;", "sorted    =    true ;", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.graphics.g3d.Attributes"}, {"methodBody": ["METHOD_START", "{", "if    ( light   instanceof   DirectionalLight )", "add (  (  ( DirectionalLight )     ( light )  )  )  ;", "else", "if    ( light   instanceof   environment . PointLight )     {", "add (  (  ( environment . PointLight )     ( light )  )  )  ;", "} else", "if    ( light   instanceof   environment . SpotLight )", "add (  (  ( environment . SpotLight )     ( light )  )  )  ;", "else", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" Unknown   light   type \"  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "for    ( final   BaseLight   light    :    lights )", "d ( light )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "DirectionalLightsAttribute   dirLights    =     (  ( DirectionalLightsAttribute )     ( get ( DirectionalLightsAttribute . Type )  )  )  ;", "if    ( dirLights    =  =    null )", "set (  ( dirLights    =    new   DirectionalLightsAttribute (  )  )  )  ;", "dirLights . lights . add ( light )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "PointLightsAttribute   pointLights    =     (  ( PointLightsAttribute )     ( get ( PointLightsAttribute . Type )  )  )  ;", "if    ( pointLights    =  =    null )", "set (  ( pointLights    =    new   PointLightsAttribute (  )  )  )  ;", "pointLights . lights . add ( light )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "SpotLightttribute   otLight =     (  ( SpotLightttribute )     ( get ( SpotLightttribute . Type )  )  )  ;", "if    ( otLight =  =    null )", "t (  ( otLight =    new   SpotLightttribute (  )  )  )  ;", "otLightlightadd ( light )  ;", "return   thi", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "for    ( final   BaseLight   light    :    lights )", "d ( light )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "if    ( light   instanceof   DirectionalLight )", "remove (  (  ( DirectionalLight )     ( light )  )  )  ;", "else", "if    ( light   instanceof   environment . PointLight )", "remove (  (  ( environment . PointLight )     ( light )  )  )  ;", "else", "if    ( light   instanceof   environment . SpotLight )", "remove (  (  ( environment . SpotLight )     ( light )  )  )  ;", "else", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" Unknown   light   type \"  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "for    ( final   BaseLight   light    :    lights )", "remove ( light )  ;", "return   ts ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "if    ( has ( DirectionalLightsAttribute . Type )  )     {", "DirectionalLightsAttribute   dirLights    =     (  ( DirectionalLightsAttribute )     ( get ( DirectionalLightsAttribute . Type )  )  )  ;", "dirLights . lights . removeValue ( light ,    false )  ;", "if    (  ( dirLights . lights . size )     =  =     0  )", "remove ( DirectionalLightsAttribute . Type )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "if    ( has ( PointLightsAttribute . Type )  )     {", "PointLightsAttribute   pointLights    =     (  ( PointLightsAttribute )     ( get ( PointLightsAttribute . Type )  )  )  ;", "pointLights . lights . removeValue ( light ,    false )  ;", "if    (  ( pointLights . lights . size )     =  =     0  )", "remove ( PointLightsAttribute . Type )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "if    ( haSpotLightttribute . Type )  )     {", "SpotLightttribute   otLight =     (  ( SpotLightttribute )     ( get ( SpotLightttribute . Type )  )  )  ;", "otLightlightremoveValue ( light ,    fal )  ;", "if    (  ( otLightlightze )     =  =     0  )", "remove ( SpotLightttribute . Type )  ;", "}", "return   thi", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "for    ( final   BaseLight   light    :    lights )", "remove ( light )  ;", "return   ts ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.Environment"}, {"methodBody": ["METHOD_START", "{", "return   new   Material ( this )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.g3d.Material"}, {"methodBody": ["METHOD_START", "{", "out . inf (  )  ;", "return   extendBoundingBox ( out )  ;", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    nodes . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "nodes . get ( i )  . calculateTransforms ( true )  ;", "}", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "nodes . get ( i )  . calculateBoneTransforms ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateTransforms"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "Material   result    =    new   Material (  )  ;", "result . id    =    mtl . id ;", "if    (  ( mtl . ambient )     !  =    null )", "result . set ( new   attributes . ColorAttribute ( attributes . ColorAttribute . Ambient ,    mtl . ambient )  )  ;", "if    (  ( mtl . diffuse )     !  =    null )", "result . set ( new   attributes . ColorAttribute ( attributes . ColorAttribute . Diffuse ,    mtl . diffuse )  )  ;", "if    (  ( mtl . specular )     !  =    null )", "result . set ( new   attributes . ColorAttribute ( attributes . ColorAttribute . Specular ,    mtl . specular )  )  ;", "if    (  ( mtl . emissive )     !  =    null )", "result . set ( new   attributes . ColorAttribute ( attributes . ColorAttribute . Emissive ,    mtl . emissive )  )  ;", "if    (  ( mtl . reflection )     !  =    null )", "result . set ( new   attributes . ColorAttribute ( attributes . ColorAttribute . Reflection ,    mtl . reflection )  )  ;", "if    (  ( mtl . shininess )     >     0  .  0 F )", "result . set ( new   attributes . FloatAttribute ( attributes . FloatAttribute . Shininess ,    mtl . shininess )  )  ;", "if    (  ( mtl . opacity )     !  =     1  .  0 F )", "result . set ( new   attributes . BlendingAttribute ( com . badlogic . gdx . graphics . GL 2  0  . GL _ SRC _ ALPHA ,    com . badlogic . gdx . graphics . GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA ,    mtl . opacity )  )  ;", "ObjectMap < String ,    Texture >    textures    =    new   ObjectMap < String ,    Texture >  (  )  ;", "if    (  ( mtl . textures )     !  =    null )     {", "for    ( ModelTexture   tex    :    mtl . textures )     {", "Texture   texture ;", "if    ( textures . containsKey ( tex . fileName )  )     {", "texture    =    textures . get ( tex . fileName )  ;", "} else    {", "texture    =    textureProvider . load ( tex . fileName )  ;", "textures . put ( tex . fileName ,    texture )  ;", "disposables . add ( texture )  ;", "}", "TextureDescriptor   descriptor    =    new   TextureDescriptor ( texture )  ;", "descriptor . minFilter    =    texture . getMinFilter (  )  ;", "descriptor . magFilter    =    texture . getMagFilter (  )  ;", "descriptor . uWrap    =    texture . getUWrap (  )  ;", "descriptor . vWrap    =    texture . getVWrap (  )  ;", "float   offsetU    =     (  ( tex . uvTranslation )     =  =    null )     ?     0  .  0 F    :    tex . uvTranslation . x ;", "float   offsetV    =     (  ( tex . uvTranslation )     =  =    null )     ?     0  .  0 F    :    tex . uvTranslation . y ;", "float   scaleU    =     (  ( tex . uvScaling )     =  =    null )     ?     1  .  0 F    :    tex . uvScaling . x ;", "float   scaleV    =     (  ( tex . uvScaling )     =  =    null )     ?     1  .  0 F    :    tex . uvScaling . y ;", "switch    ( tex . usage )     {", "case   ModelTexture . USAGE _ DIFFUSE    :", "result . set ( new   TextureAttribute ( TextureAttribute . Diffuse ,    descriptor ,    offsetU ,    offsetV ,    scaleU ,    scaleV )  )  ;", "break ;", "case   ModelTexture . USAGE _ SPECULAR    :", "result . set ( new   TextureAttribute ( TextureAttribute . Specular ,    descriptor ,    offsetU ,    offsetV ,    scaleU ,    scaleV )  )  ;", "break ;", "case   ModelTexture . USAGE _ BUMP    :", "result . set ( new   TextureAttribute ( TextureAttribute . Bump ,    descriptor ,    offsetU ,    offsetV ,    scaleU ,    scaleV )  )  ;", "break ;", "case   ModelTexture . USAGE _ NORMAL    :", "result . set ( new   TextureAttribute ( TextureAttribute . Normal ,    descriptor ,    offsetU ,    offsetV ,    scaleU ,    scaleV )  )  ;", "break ;", "case   ModelTexture . USAGE _ AMBIENT    :", "result . set ( new   TextureAttribute ( TextureAttribute . Ambient ,    descriptor ,    offsetU ,    offsetV ,    scaleU ,    scaleV )  )  ;", "break ;", "case   ModelTexture . USAGE _ EMISSIVE    :", "result . set ( new   TextureAttribute ( TextureAttribute . Emissive ,    descriptor ,    offsetU ,    offsetV ,    scaleU ,    scaleV )  )  ;", "break ;", "case   ModelTexture . USAGE _ REFLECTION    :", "result . set ( new   TextureAttribute ( TextureAttribute . Reflection ,    descriptor ,    offsetU ,    offsetV ,    scaleU ,    scaleV )  )  ;", "break ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "int   numIndices    =     0  ;", "for    ( MeshPart   part    :    modelMesh . parts )     {", "numIndices    +  =    part . indices . length ;", "}", "VertexAttributes   attributes    =    new   VertexAttributes ( modelMesh . attributes )  ;", "int   numVertices    =     ( modelMesh . vertices . length )     /     (  ( attributes . vertexSize )     /     4  )  ;", "Mesh   mesh    =    new   Mesh ( true ,    numVertices ,    numIndices ,    attributes )  ;", "meshes . add ( mesh )  ;", "disposables . add ( mesh )  ;", "BufferUtils . copy ( modelMesh . vertices ,    mesh . getVerticesBuffer (  )  ,    modelMesh . vertices . length ,     0  )  ;", "int   offset    =     0  ;", "mesh . getIndicesBuffer (  )  . clear (  )  ;", "for    ( MeshPart   part    :    modelMesh . parts )     {", "MeshPart   meshPart    =    new   MeshPart (  )  ;", "meshPart . id    =    part . id ;", "meshPart . primitiveType    =    part . primitiveType ;", "meshPart . offset    =    offset ;", "meshPart . size    =    part . indices . length ;", "meshPart . mesh    =    mesh ;", "mesh . getIndicesBuffer (  )  . put ( part . indices )  ;", "offset    +  =    meshPart . size ;", "meshParts . add ( meshPart )  ;", "}", "mesh . getIndicesBuffer (  )  . position (  0  )  ;", "for    ( MeshPart   part    :    meshParts )", "part . update (  )  ;", "}", "METHOD_END"], "methodName": ["convertMesh"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    nodes . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "nodes . get ( i )  . extendBoundingBox ( out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["extendBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "return   getAnimation ( id ,    true )  ;", "}", "METHOD_END"], "methodName": ["getAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    animations . size ;", "Animation   animation ;", "if    ( ignoreCase )     {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( animation    =    animationet ( i )  )  . id . equalnoreCase ( id )  )", "return   animation ;", "} else    {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( animation    =    animationet ( i )  )  . id . equals ( id )  )", "return   animation ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "return   disposables ;", "}", "METHOD_END"], "methodName": ["getManagedDisposables"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "return   getMaterial ( id ,    true )  ;", "}", "METHOD_END"], "methodName": ["getMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    materials . size ;", "Material   material ;", "if    ( ignoreCase )     {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( material    =    materialet ( i )  )  . id . equalnoreCase ( id )  )", "return   material ;", "} else    {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( material    =    materialet ( i )  )  . id . equals ( id )  )", "return   material ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "return   getNode ( id ,    true )  ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "return   getNode ( id ,    recursive ,    false )  ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "return   Node . getNode ( nodes ,    id ,    recursive ,    ignoreCase )  ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "loadMeshes ( modelData . meshes )  ;", "loadMaterials ( modelData . materials ,    textureProvider )  ;", "loadNodes ( modelData . nodes )  ;", "loadAnimations ( modelData . animations )  ;", "calculateTransforms (  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "for    ( final   ModelAnimation   anim    :    modelAnimations )     {", "Animation   animation    =    new   Animation (  )  ;", "animation . id    =    anim . id ;", "for    ( ModelNodeAnimation   nanim    :    anim . nodeAnimations )     {", "final   Node   node    =    getNode ( nanim . nodeId )  ;", "if    ( node    =  =    null )", "continue ;", "NodeAnimation   nodeAnim    =    new   NodeAnimation (  )  ;", "nodeAnim . node    =    node ;", "if    (  ( nanim . translation )     !  =    null )     {", "nodeAnim . translation    =    new   Array < NodeKeyframe < Vector 3  >  >  (  )  ;", "nodeAnim . translation . ensureCapacity ( nanim . translation . size )  ;", "for    ( ModelNodeKeyframe < Vector 3  >    kf    :    nanim . translation )     {", "if    (  ( kf . keytime )     >     ( animation . duration )  )", "animation . duration    =    kf . keytime ;", "nodeAnim . translation . add ( new   NodeKeyframe < Vector 3  >  ( kf . keytime ,    new   Vector 3  (  (  ( kf . value )     =  =    null    ?    node . translation    :    kf . value )  )  )  )  ;", "}", "}", "if    (  ( nanim . rotation )     !  =    null )     {", "nodeAnim . rotation    =    new   Array < NodeKeyframe < Quaternion >  >  (  )  ;", "nodeAnim . rotation . ensureCapacity ( nanim . rotation . size )  ;", "for    ( ModelNodeKeyframe < Quaternion >    kf    :    nanim . rotation )     {", "if    (  ( kf . keytime )     >     ( animation . duration )  )", "animation . duration    =    kf . keytime ;", "nodeAnim . rotation . add ( new   NodeKeyframe < Quaternion >  ( kf . keytime ,    new   Quaternion (  (  ( kf . value )     =  =    null    ?    node . rotation    :    kf . value )  )  )  )  ;", "}", "}", "if    (  ( nanim . scaling )     !  =    null )     {", "nodeAnim . scaling    =    new   Array < NodeKeyframe < Vector 3  >  >  (  )  ;", "nodeAnim . scaling . ensureCapacity ( nanim . scaling . size )  ;", "for    ( ModelNodeKeyframe < Vector 3  >    kf    :    nanim . scaling )     {", "if    (  ( kf . keytime )     >     ( animation . duration )  )", "animation . duration    =    kf . keytime ;", "nodeAnim . scaling . add ( new   NodeKeyframe < Vector 3  >  ( kf . keytime ,    new   Vector 3  (  (  ( kf . value )     =  =    null    ?    node . scale    :    kf . value )  )  )  )  ;", "}", "}", "if    (  (  (  (  ( nodeAnim . translation )     !  =    null )     &  &     (  ( nodeAnim . translation . size )     >     0  )  )     |  |     (  (  ( nodeAnim . rotation )     !  =    null )     &  &     (  ( nodeAnim . rotation . size )     >     0  )  )  )     |  |     (  (  ( nodeAnim . scaling )     !  =    null )     &  &     (  ( nodeAnim . scaling . size )     >     0  )  )  )", "animation . nodeAnimations . add ( nodeAnim )  ;", "}", "if    (  ( animation . nodeAnimations . size )     >     0  )", "animations . add ( animation )  ;", "}", "}", "METHOD_END"], "methodName": ["loadAnimations"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelMaterial   mtl    :    modelMaterials )     {", "this . materials . add ( convertMaterial ( mtl ,    textureProvider )  )  ;", "}", "}", "METHOD_END"], "methodName": ["loadMaterials"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelMesh   mesh    :    meshes )     {", "convertMesh ( mesh )  ;", "}", "}", "METHOD_END"], "methodName": ["loadMeshes"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "Node   node    =    new   Node (  )  ;", "node . id    =    modelNode . id ;", "if    (  ( modelNode . translation )     !  =    null )", "node . translation . set ( modelNode . translation )  ;", "if    (  ( modelNode . rotation )     !  =    null )", "node . rotation . set ( modelNode . rotation )  ;", "if    (  ( modelNode . scale )     !  =    null )", "node . scale . set ( modelNode . scale )  ;", "if    (  ( modelNode . parts )     !  =    null )     {", "for    ( ModelNodePart   modelNodePart    :    modelNode . parts )     {", "MeshPart   meshPart    =    null ;", "Material   meshMaterial    =    null ;", "if    (  ( modelNodePart . meshPartId )     !  =    null )     {", "for    ( MeshPart   part    :    meshParts )     {", "if    ( modelNodePart . meshPartId . equals ( part . id )  )     {", "meshPart    =    part ;", "break ;", "}", "}", "}", "if    (  ( modelNodePart . materialId )     !  =    null )     {", "for    ( Material   material    :    materials )     {", "if    ( modelNodePart . materialId . equals ( material . id )  )     {", "meshMaterial    =    material ;", "break ;", "}", "}", "}", "if    (  ( meshPart    =  =    null )     |  |     ( meshMaterial    =  =    null )  )", "throw   new   utils . GdxRuntimeException (  (  \" Invalid   node :     \"     +     ( node . id )  )  )  ;", "if    (  ( meshPart    !  =    null )     &  &     ( meshMaterial    !  =    null )  )     {", "NodePart   nodePart    =    new   NodePart (  )  ;", "nodePart . meshPart    =    meshPart ;", "nodePart . material    =    meshMaterial ;", "node . parts . add ( nodePart )  ;", "if    (  ( modelNodePart . bones )     !  =    null )", "nodePartBones . put ( nodePart ,    modelNodePart . bones )  ;", "}", "}", "}", "if    (  ( modelNode . children )     !  =    null )     {", "for    ( ModelNode   child    :    modelNode . children )     {", "node . addChild ( loadNode ( child )  )  ;", "}", "}", "return   node ;", "}", "METHOD_END"], "methodName": ["loadNode"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "nodePartBones . clear (  )  ;", "for    ( ModelNode   node    :    modelNodes )     {", "nodes . add ( loadNode ( node )  )  ;", "}", "for    ( ObjectMap . Entry < NodePart ,    ArrayMap < String ,    Matrix 4  >  >    e    :    nodePartBones . entries (  )  )     {", "if    (  ( e . key . invBoneBindTransforms )     =  =    null )", "e . key . invBoneBindTransforms    =    new   ArrayMap < model . Node ,    Matrix 4  >  ( model . Node . class ,    Matrix 4  . class )  ;", "e . key . invBoneBindTransforms . clear (  )  ;", "for    ( ObjectMap . Entry < String ,    Matrix 4  >    b    :    e . value . entries (  )  )", "e . key . invBoneBindTransforms . put ( getNode ( b . key )  ,    new   Matrix 4  ( b . value )  . inv (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["loadNodes"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( disposables . contains ( disposable ,    true )  )  )", "disposables . add ( disposable )  ;", "}", "METHOD_END"], "methodName": ["manageDisposable"], "fileName": "com.badlogic.gdx.graphics.g3d.Model"}, {"methodBody": ["METHOD_START", "{", "if    (  ( camera )     !  =    null )", "throw   new   utils . GdxRuntimeException (  \" Call   end (  )    first .  \"  )  ;", "camera    =    cam ;", "if    ( ownContext )", "context . begin (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "flush (  )  ;", "if    ( ownContext )", "ntext . end (  )  ;", "camera    =    null ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "sorter . sort ( camera ,    renderables )  ;", "Shader   currentShader    =    null ;", "for    ( int   i    =     0  ;    i    <     ( renderables . size )  ;    i +  +  )     {", "final   Renderable   renderable    =    renderableet ( i )  ;", "if    ( currentShader    !  =     ( renderable . shader )  )     {", "if    ( currentShader    !  =    null )", "currentShader . end (  )  ;", "currentShader    =    renderable . shader ;", "currentShader . begin ( camera ,    context )  ;", "}", "currentShader . render ( renderable )  ;", "}", "if    ( currentShader    !  =    null )", "currentShader . end (  )  ;", "renderablesPool . flush (  )  ;", "renderables . clear (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "return   camera ;", "}", "METHOD_END"], "methodName": ["getCamera"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "return   context ;", "}", "METHOD_END"], "methodName": ["getRenderContext"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "return   sorter ;", "}", "METHOD_END"], "methodName": ["getRenderableSorter"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "return   shaderProvider ;", "}", "METHOD_END"], "methodName": ["getShaderProvider"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "return   ownContext ;", "}", "METHOD_END"], "methodName": ["ownsRenderContext"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "renderable . shader    =    shaderProvider . getShader ( renderable )  ;", "renderable . meshPart . mesh . setAutoBind ( false )  ;", "renderables . add ( renderable )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "final   int   offset    =    renderables . size ;", "renderableProvider . getRenderables ( renderables ,    renderablesPool )  ;", "for    ( int   i    =    offset ;    i    <     ( renderables . size )  ;    i +  +  )     {", "Renderable   renderable    =    renderableet ( i )  ;", "renderable . shader    =    shaderProvider . getShader ( renderable )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "final   int   offset    =    renderables . size ;", "renderableProvider . getRenderables ( renderables ,    renderablesPool )  ;", "for    ( int   i    =    offset ;    i    <     ( renderables . size )  ;    i +  +  )     {", "Renderable   renderable    =    renderableet ( i )  ;", "renderable . environment    =    environment ;", "renderable . shader    =    shaderProvider . getShader ( renderable )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "final   int   offset    =    renderables . size ;", "renderableProvider . getRenderables ( renderables ,    renderablesPool )  ;", "for    ( int   i    =    offset ;    i    <     ( renderables . size )  ;    i +  +  )     {", "Renderable   renderable    =    renderableet ( i )  ;", "renderable . environment    =    environment ;", "renderable . shader    =    shader ;", "renderable . shader    =    shaderProvider . getShader ( renderable )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "final   int   offset    =    renderables . size ;", "renderableProvider . getRenderables ( renderables ,    renderablesPool )  ;", "for    ( int   i    =    offset ;    i    <     ( renderables . size )  ;    i +  +  )     {", "Renderable   renderable    =    renderableet ( i )  ;", "renderable . shader    =    shader ;", "renderable . shader    =    shaderProvider . getShader ( renderable )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "for    ( final   RenderableProvider   renderableProvider    :    renderableProviders )", "render ( renderableProvider )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "for    ( final   RenderableProvider   renderableProvider    :    renderableProviders )", "render ( renderableProvider ,    environment )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "for    ( final   RenderableProvider   renderableProvider    :    renderableProviders )", "render ( renderableProvider ,    environment ,    shader )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "for    ( final   RenderableProvider   renderableProvider    :    renderableProviders )", "render ( renderableProvider ,    shader )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( camera )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Call   begin (  )    first .  \"  )  ;", "if    (  ( renderables . size )     >     0  )", "flush (  )  ;", "camera    =    cam ;", "}", "METHOD_END"], "methodName": ["setCamera"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( building )  )", "throw   new   utils . GdxRuntimeException (  \" Can   only   add   items   to   the   ModelCache   in   between    . begin (  )    and    . end (  )  \"  )  ;", "if    (  ( renderable . bones )     =  =    null )", "items . add ( renderable )  ;", "else", "renderables . add ( renderable )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelCache"}, {"methodBody": ["METHOD_START", "{", "renderableProvider . getRenderables ( tmp ,    renderablesPool )  ;", "for    ( int   i    =     0  ,    n    =    tmp . size ;    i    <    n ;     +  + i )", "add ( tmp . get ( i )  )  ;", "tmp . clear (  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelCache"}, {"methodBody": ["METHOD_START", "{", "for    ( final   RenderableProvider   renderableProvider    :    renderableProviders )", "add ( renderableProvider )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelCache"}, {"methodBody": ["METHOD_START", "{", "begin ( null )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelCache"}, {"methodBody": ["METHOD_START", "{", "if    ( building )", "throw   new   utils . GdxRuntimeException (  \" Call   end (  )    after   calling   begin (  )  \"  )  ;", "building    =    true ;", "this . camera    =    camera ;", "renderablesPool . flush (  )  ;", "renderables . clear (  )  ;", "items . clear (  )  ;", "meshPartPool . flush (  )  ;", "meshPool . flush (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelCache"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( building )  )", "throw   new   utils . GdxRuntimeException (  \" Call   begin (  )    prior   to   calling   end (  )  \"  )  ;", "building    =    false ;", "if    (  ( items . size )     =  =     0  )", "return ;", "sorter . sort ( camera ,    items )  ;", "int   itemCount    =    items . size ;", "int   initCount    =    renderables . size ;", "final   Renderable   first    =    items . get (  0  )  ;", "VertexAttributes   vertexAttributes    =    first . meshPart . mesh . getVertexAttributes (  )  ;", "Material   material    =    first . material ;", "int   primitiveType    =    first . meshPart . primitiveType ;", "int   offset    =    renderables . size ;", "meshBuilder . begin ( vertexAttributes )  ;", "MeshPart   part    =    meshBuilder . part (  \"  \"  ,    primitiveType ,    meshPartPool . obtain (  )  )  ;", "renderables . add ( obtainRenderable ( material ,    primitiveType )  )  ;", "for    ( int   i    =     0  ,    n    =    items . size ;    i    <    n ;     +  + i )     {", "final   Renderable   renderable    =    items . get ( i )  ;", "final   VertexAttributes   va    =    renderable . meshPart . mesh . getVertexAttributes (  )  ;", "final   Material   mat    =    renderable . material ;", "final   int   pt    =    renderable . meshPart . primitiveType ;", "final   boolean   sameMesh    =     ( va . equals ( vertexAttributes )  )     &  &     (  (  ( renderable . meshPart . size )     +     ( meshBuilder . getNumVertices (  )  )  )     <     ( Short . MAX _ VALUE )  )  ;", "final   boolean   samePart    =     ( sameMesh    &  &     ( pt    =  =    primitiveType )  )     &  &     ( mat . same ( material ,    true )  )  ;", "if    (  ! samePart )     {", "if    (  ! sameMesh )     {", "final   Mesh   mesh    =    meshBuilder . end ( meshPool . obtain ( vertexAttributes ,    meshBuilder . getNumVertices (  )  ,    meshBuilder . getNumIndices (  )  )  )  ;", "while    ( offset    <     ( renderables . size )  )", "renderables . get (  ( offset +  +  )  )  . meshPart . mesh    =    mesh ;", "meshBuilder . begin (  ( vertexAttributes    =    va )  )  ;", "}", "final   MeshPart   newPart    =    meshBuilder . part (  \"  \"  ,    pt ,    meshPartPool . obtain (  )  )  ;", "final   Renderable   previous    =    renderables . get (  (  ( renderables . size )     -     1  )  )  ;", "previous . meshPart . offset    =    part . offset ;", "previous . meshPart . size    =    part . size ;", "part    =    newPart ;", "renderables . add ( obtainRenderable (  ( material    =    mat )  ,     ( primitiveType    =    pt )  )  )  ;", "}", "meshBuilder . setVertexTransform ( renderable . worldTransform )  ;", "meshBuilder . addMesh ( renderable . meshPart . mesh ,    renderable . meshPart . offset ,    renderable . meshPart . size )  ;", "}", "final   Mesh   mesh    =    meshBuilder . end ( meshPool . obtain ( vertexAttributes ,    meshBuilder . getNumVertices (  )  ,    meshBuilder . getNumIndices (  )  )  )  ;", "while    ( offset    <     ( renderables . size )  )", "renderables . get (  ( offset +  +  )  )  . meshPart . mesh    =    mesh ;", "final   Renderable   previous    =    renderables . get (  (  ( renderables . size )     -     1  )  )  ;", "previous . meshPart . offset    =    part . offset ;", "previous . meshPart . size    =    part . size ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelCache"}, {"methodBody": ["METHOD_START", "{", "Renderable   result    =    renderablesPool . obtain (  )  ;", "result . bones    =    null ;", "result . environment    =    null ;", "result . material    =    material ;", "result . meshPart . mesh    =    null ;", "result . meshPart . offset    =     0  ;", "result . meshPart . size    =     0  ;", "result . meshPart . primitiveType    =    primitiveType ;", "result . meshPart . center . set (  0  ,     0  ,     0  )  ;", "result . meshPart . halfExtents . set (  0  ,     0  ,     0  )  ;", "result . meshPart . radius    =     -  1  .  0 F ;", "result . shader    =    null ;", "result . userData    =    null ;", "result . worldTransform . idt (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["obtainRenderable"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelCache"}, {"methodBody": ["METHOD_START", "{", "out . inf (  )  ;", "return   extendBoundingBox ( out )  ;", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    nodes . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "nodes . get ( i )  . calculateTransforms ( true )  ;", "}", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "nodes . get ( i )  . calculateBoneTransforms ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateTransforms"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelInstance ( this )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( final   Animation   anim    :    source )     {", "Animation   animation    =    new   Animation (  )  ;", "animation . id    =    anim . id ;", "animation . duration    =    anim . duration ;", "for    ( final   NAnimation   nanim    :    anim . nAnimations )     {", "final   N   n    =    getN ( nanim . n . id )  ;", "if    ( n    =  =    null )", "continue ;", "NAnimation   nAnim    =    new   NAnimation (  )  ;", "nAnim . n    =    n ;", "if    ( shareKeyframes )     {", "nAnim . translation    =    nanim . translation ;", "nAnim . rotation    =    nanim . rotation ;", "nAnim . scaling    =    nanim . scaling ;", "} else    {", "if    (  ( nanim . translation )     !  =    null )     {", "nAnim . translation    =    new   Array < NKeyframe < Vector 3  >  >  (  )  ;", "for    ( final   NKeyframe < Vector 3  >    kf    :    nanim . translation )", "nAnim . translation . add ( new   NKeyframe < Vector 3  >  ( kf . keytime ,    kf . value )  )  ;", "}", "if    (  ( nanim . rotation )     !  =    null )     {", "nAnim . rotation    =    new   Array < NKeyframe < Quaternion >  >  (  )  ;", "for    ( final   NKeyframe < Quaternion >    kf    :    nanim . rotation )", "nAnim . rotation . add ( new   NKeyframe < Quaternion >  ( kf . keytime ,    kf . value )  )  ;", "}", "if    (  ( nanim . scaling )     !  =    null )     {", "nAnim . scaling    =    new   Array < NKeyframe < Vector 3  >  >  (  )  ;", "for    ( final   NKeyframe < Vector 3  >    kf    :    nanim . scaling )", "nAnim . scaling . add ( new   NKeyframe < Vector 3  >  ( kf . keytime ,    kf . value )  )  ;", "}", "}", "if    (  (  (  ( nAnim . translation )     !  =    null )     |  |     (  ( nAnim . rotation )     !  =    null )  )     |  |     (  ( nAnim . scaling )     !  =    null )  )", "animation . nAnimations . add ( nAnim )  ;", "}", "if    (  ( animation . nAnimations . size )     >     0  )", "animations . add ( animation )  ;", "}", "}", "METHOD_END"], "methodName": ["copyAnimations"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;     +  + i )     {", "final   Node   node    =    nodes . get ( i )  ;", "this . nodes . add ( node . copy (  )  )  ;", "}", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["copyNodes"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;     +  + i )     {", "final   Node   node    =    nodes . get ( i )  ;", "for    ( final   String   nodeId    :    nodeIds )     {", "if    ( nodeId . equals ( node . id )  )     {", "this . nodes . add ( node . copy (  )  )  ;", "break ;", "}", "}", "}", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["copyNodes"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;     +  + i )     {", "final   Node   node    =    nodes . get ( i )  ;", "for    ( final   String   nodeId    :    nodeIds )     {", "if    ( nodeId . equals ( node . id )  )     {", "this . nodes . add ( node . copy (  )  )  ;", "break ;", "}", "}", "}", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["copyNodes"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    nodes . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "nodes . get ( i )  . extendBoundingBox ( out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["extendBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   getAnimation ( id ,    false )  ;", "}", "METHOD_END"], "methodName": ["getAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    animations . size ;", "Animation   animation ;", "if    ( ignoreCase )     {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( animation    =    animationet ( i )  )  . id . equalnoreCase ( id )  )", "return   animation ;", "} else    {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( animation    =    animationet ( i )  )  . id . equals ( id )  )", "return   animation ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   getMaterial ( id ,    true )  ;", "}", "METHOD_END"], "methodName": ["getMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    materials . size ;", "Material   material ;", "if    ( ignoreCase )     {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( material    =    materialet ( i )  )  . id . equalnoreCase ( id )  )", "return   material ;", "} else    {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( material    =    materialet ( i )  )  . id . equals ( id )  )", "return   material ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   getNode ( id ,    true )  ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   getNode ( id ,    recursive ,    false )  ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   Node . getNode ( nodes ,    id ,    recursive ,    ignoreCase )  ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   getRenderable ( out ,    nodes . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getRenderable"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "return   getRenderable ( out ,    node ,    node . parts . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getRenderable"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "nodePart . setRenderable ( out )  ;", "if    (  (  ( nodePart . bones )     =  =    null )     &  &     (  ( transform )     !  =    null )  )", "out . worldTransform . set ( transform )  . mul ( node . globalTransform )  ;", "else", "if    (  ( transform )     !  =    null )", "out . worldTransform . set ( transform )  ;", "else", "out . worldTransform . idt (  )  ;", "out . userData    =    userData ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getRenderable"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node . parts . size )     >     0  )     {", "for    ( NodePart   nodePart    :    node . parts )     {", "if    ( nodePart . enabled )", "renderables . add ( getRenderable ( pool . obtain (  )  ,    node ,    nodePart )  )  ;", "}", "}", "for    ( Node   child    :    node . getChildren (  )  )     {", "getRenderables ( child ,    renderables ,    pool )  ;", "}", "}", "METHOD_END"], "methodName": ["getRenderables"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   node    :    nodes )     {", "getRenderables ( node ,    renderables ,    pool )  ;", "}", "}", "METHOD_END"], "methodName": ["getRenderables"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;     +  + i )     {", "invalidate ( nodes . get ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    node . parts . size ;    i    <    n ;     +  + i )     {", "NodePart   part    =    node . parts . get ( i )  ;", "ArrayMap < Node ,    Matrix 4  >    bindPose    =    part . invBoneBindTransforms ;", "if    ( bindPose    !  =    null )     {", "for    ( int   j    =     0  ;    j    <     ( bindPose . size )  ;     +  + j )     {", "bindPose . keys [ j ]     =    getNode ( bindPose . keys [ j ]  . id )  ;", "}", "}", "if    (  !  ( materials . contains ( part . material ,    true )  )  )     {", "final   int   midx    =    materials . indexOf ( part . material ,    false )  ;", "if    ( midx    <     0  )", "materials . add (  ( part . material    =    part . material . copy (  )  )  )  ;", "else", "part . material    =    materials . get ( midx )  ;", "}", "}", "for    ( int   i    =     0  ,    n    =    node . getChildCount (  )  ;    i    <    n ;     +  + i )     {", "invalidate ( node . getChild ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.graphics.g3d.ModelInstance"}, {"methodBody": ["METHOD_START", "{", "worldTransform . set ( renderable . worldTransform )  ;", "material    =    renderable . material ;", "meshPart . set ( renderable . meshPart )  ;", "bones    =    renderable . bones ;", "environment    =    renderable . environment ;", "shader    =    renderable . shader ;", "userData    =    renderable . userData ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.Renderable"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( BlendingAttribute . Type )  )     =  =    mask ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Ambient ,    color )  ;", "}", "METHOD_END"], "methodName": ["createAmbient"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Ambient ,    r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["createAmbient"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Diffuse ,    color )  ;", "}", "METHOD_END"], "methodName": ["createDiffuse"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Diffuse ,    r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["createDiffuse"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Reflection ,    color )  ;", "}", "METHOD_END"], "methodName": ["createReflection"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Reflection ,    r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["createReflection"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Specular ,    color )  ;", "}", "METHOD_END"], "methodName": ["createSpecular"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   ColorAttribute ( ColorAttribute . Specular ,    r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["createSpecular"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( ColorAttribute . Mask )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( CubemapAttribute . Mask )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.CubemapAttribute"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( DepthTestAttribute . Mask )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( DirectionalLightsAttribute . Type )  )     =  =    mask ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.DirectionalLightsAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   FloatAttribute ( FloatAttribute . AlphaTest ,    value )  ;", "}", "METHOD_END"], "methodName": ["createAlphaTest"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   FloatAttribute ( FloatAttribute . Shininess ,    value )  ;", "}", "METHOD_END"], "methodName": ["createShininess"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   IntAttribute ( IntAttribute . CullFace ,    value )  ;", "}", "METHOD_END"], "methodName": ["createCullFace"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.IntAttribute"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( PointLightsAttribute . Type )  )     =  =    mask ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.PointLightsAttribute"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( SpotLightsAttribute . Type )  )     =  =    mask ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.SpotLightsAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Ambient ,    texture )  ;", "}", "METHOD_END"], "methodName": ["createAmbient"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Ambient ,    region )  ;", "}", "METHOD_END"], "methodName": ["createAmbient"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Bump ,    texture )  ;", "}", "METHOD_END"], "methodName": ["createBump"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Bump ,    region )  ;", "}", "METHOD_END"], "methodName": ["createBump"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Diffuse ,    texture )  ;", "}", "METHOD_END"], "methodName": ["createDiffuse"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Diffuse ,    region )  ;", "}", "METHOD_END"], "methodName": ["createDiffuse"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Emissive ,    texture )  ;", "}", "METHOD_END"], "methodName": ["createEmissive"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Emissive ,    region )  ;", "}", "METHOD_END"], "methodName": ["createEmissive"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Normal ,    texture )  ;", "}", "METHOD_END"], "methodName": ["createNormal"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Normal ,    region )  ;", "}", "METHOD_END"], "methodName": ["createNormal"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Reflection ,    texture )  ;", "}", "METHOD_END"], "methodName": ["createReflection"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Reflection ,    region )  ;", "}", "METHOD_END"], "methodName": ["createReflection"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Specular ,    texture )  ;", "}", "METHOD_END"], "methodName": ["createSpecular"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return   new   TextureAttribute ( TextureAttribute . Specular ,    region )  ;", "}", "METHOD_END"], "methodName": ["createSpecular"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &     ( TextureAttribute . Mask )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "textureDescription . texture    =    region . getTexture (  )  ;", "offsetU    =    region . getU (  )  ;", "offsetV    =    region . getV (  )  ;", "scaleU    =     ( region . getU 2  (  )  )     -     ( offsetU )  ;", "scaleV    =     ( region . getV 2  (  )  )     -     ( offsetV )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute"}, {"methodBody": ["METHOD_START", "{", "String   vertexShader    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" attribute   vec 4     \"     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 4     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \" attribute   vec 2     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \" uniform   mat 4    u _ projectionViewMatrix ;  \\ n \"  )     +     \" varying   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \"  \\ n \"  )     +     \" void   main (  )  \\ n \"  )     +     \"  {  \\ n \"  )     +     \"          v _ color    =     \"  )     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"          v _ color . a    =    v _ color . a    *     (  2  5  5  .  0  /  2  5  4  .  0  )  ;  \\ n \"  )     +     \"          v _ texCoords    =     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +     \"  0  ;  \\ n \"  )     +     \"          gl _ Position    =       u _ projectionViewMatrix    *     \"  )     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     \"  }  \\ n \"  ;", "String   fragmentShader    =     \"  # ifdef   GL _ ES \\ n \"     +     (  (  (  (  (  (  (  (  \" precision   mediump   float ;  \\ n \"     +     \"  # endif \\ n \"  )     +     \" varying   vec 4    v _ color ;  \\ n \"  )     +     \" varying   vec 2    v _ texCoords ;  \\ n \"  )     +     \" uniform   sampler 2 D   u _ texture ;  \\ n \"  )     +     \" void   main (  )  \\ n \"  )     +     \"  {  \\ n \"  )     +     \"       gl _ FragColor    =    v _ color    *    texture 2 D ( u _ texture ,    v _ texCoords )  ;  \\ n \"  )     +     \"  }  \"  )  ;", "shader    =    new   ShaderProgram ( vertexShader ,    fragmentShader )  ;", "if    (  ( shader . isCompiled (  )  )     =  =    false )", "throw   new   IllegalArgumentException (  (  \" couldn ' t   compile   shader :     \"     +     ( shader . getLog (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultShader"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.CameraGroupStrategy"}, {"methodBody": ["METHOD_START", "{", "return   camera ;", "}", "METHOD_END"], "methodName": ["getCamera"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.CameraGroupStrategy"}, {"methodBody": ["METHOD_START", "{", "this . camera    =    camera ;", "}", "METHOD_END"], "methodName": ["setCamera"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.CameraGroupStrategy"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   dimensions . y ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   material ;", "}", "METHOD_END"], "methodName": ["getMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   rotation ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   this . scale . x ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   this . scale . y ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   this . material . textureRegion ;", "}", "METHOD_END"], "methodName": ["getTextureRegion"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   vertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   this . dimensions . x ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   this . position . x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   this . position . y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   this . position . z ;", "}", "METHOD_END"], "methodName": ["getZ"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "Decal . dir . set ( position )  . sub ( this . position )  . nor (  )  ;", "setRotation ( Decal . dir ,    up )  ;", "}", "METHOD_END"], "methodName": ["lookAt"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   Decal . newDecal ( textureRegion . getRegionWidth (  )  ,    textureRegion . getRegionHeight (  )  ,    textureRegion ,    DecalMaterial . NO _ BLEND ,    DecalMaterial . NO _ BLEND )  ;", "}", "METHOD_END"], "methodName": ["newDecal"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   Decal . newDecal ( textureRegion . getRegionWidth (  )  ,    textureRegion . getRegionHeight (  )  ,    textureRegion ,     ( hasTransparency    ?    GL 2  0  . GL _ SRC _ ALPHA    :    DecalMaterial . NO _ BLEND )  ,     ( hasTransparency    ?    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA    :    DecalMaterial . NO _ BLEND )  )  ;", "}", "METHOD_END"], "methodName": ["newDecal"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   Decal . newDecal ( width ,    height ,    textureRegion ,    DecalMaterial . NO _ BLEND ,    DecalMaterial . NO _ BLEND )  ;", "}", "METHOD_END"], "methodName": ["newDecal"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "return   Decal . newDecal ( width ,    height ,    textureRegion ,     ( hasTransparency    ?    GL 2  0  . GL _ SRC _ ALPHA    :    DecalMaterial . NO _ BLEND )  ,     ( hasTransparency    ?    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA    :    DecalMaterial . NO _ BLEND )  )  ;", "}", "METHOD_END"], "methodName": ["newDecal"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "Decal   decal    =    new   Decal (  )  ;", "decal . setTextureRegion ( textureRegion )  ;", "decal . setBlending ( srcBlendFactor ,    dstBlendFactor )  ;", "decal . dimensions . x    =    width ;", "decal . dimensions . y    =    height ;", "decal . setColor (  1  ,     1  ,     1  ,     1  )  ;", "return   decal ;", "}", "METHOD_END"], "methodName": ["newDecal"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "Decal   decal    =    new   Decal ( material )  ;", "decal . setTextureRegion ( textureRegion )  ;", "decal . setBlending ( srcBlendFactor ,    dstBlendFactor )  ;", "decal . dimensions . x    =    width ;", "decal . dimensions . y    =    height ;", "decal . setColor (  1  ,     1  ,     1  ,     1  )  ;", "return   decal ;", "}", "METHOD_END"], "methodName": ["newDecal"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "float   left    =     (  -  ( dimensions . x )  )     /     2  .  0 F ;", "float   right    =    left    +     ( dimensions . x )  ;", "float   top    =     ( dimensions . y )     /     2  .  0 F ;", "float   bottom    =    top    -     ( dimensions . y )  ;", "vertices [  . X 1  ]     =    left ;", "vertices [  . Y 1  ]     =    top ;", "vertices [  . Z 1  ]     =     0  ;", "vertices [  . X 2  ]     =    right ;", "vertices [  . Y 2  ]     =    top ;", "vertices [  . Z 2  ]     =     0  ;", "vertices [  . X 3  ]     =    left ;", "vertices [  . Y 3  ]     =    bottom ;", "vertices [  . Z 3  ]     =     0  ;", "vertices [  . X 4  ]     =    right ;", "vertices [  . Y 4  ]     =    bottom ;", "vertices [  . Z 4  ]     =     0  ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["resetVertices"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "Decal . rotator . set ( Vector 3  . X ,    angle )  ;", "rotation . mul ( Decal . rotator )  ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["rotateX"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "Decal . rotator . set ( Vector 3  . Y ,    angle )  ;", "rotation . mul ( Decal . rotator )  ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["rotateY"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "Decal . rotator . set ( Vector 3  . Z ,    angle )  ;", "rotation . mul ( Decal . rotator )  ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["rotateZ"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "material . srcBlendFactor    =    srcBlendFactor ;", "material . dstBlendFactor    =    dstBlendFactor ;", "}", "METHOD_END"], "methodName": ["setBlending"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "color . set ( tint )  ;", "float   color    =    tint . toFloatBits (  )  ;", "vertices [  . C 1  ]     =    color ;", "vertices [  . C 2  ]     =    color ;", "vertices [  . C 3  ]     =    color ;", "vertices [  . C 4  ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( NumberUtils . floatToIntColor ( color )  )  ;", "vertices [  . C 1  ]     =    color ;", "vertices [  . C 2  ]     =    color ;", "vertices [  . C 3  ]     =    color ;", "vertices [  . C 4  ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "color . set ( r ,    g ,    b ,    a )  ;", "int   intBits    =     (  (  (  (  ( int )     (  2  5  5     *    a )  )     <  <     2  4  )     |     (  (  ( int )     (  2  5  5     *    b )  )     <  <     1  6  )  )     |     (  (  ( int )     (  2  5  5     *    g )  )     <  <     8  )  )     |     (  ( int )     (  2  5  5     *    r )  )  ;", "float   color    =    NumberUtils . intToFloatColor ( intBits )  ;", "vertices [  . C 1  ]     =    color ;", "vertices [  . C 2  ]     =    color ;", "vertices [  . C 3  ]     =    color ;", "vertices [  . C 4  ]     =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "dimensions . set ( width ,    height )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setDimensions"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . dimensions . y    =    height ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setHeight"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . material    =    material ;", "}", "METHOD_END"], "methodName": ["setMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . set ( pos )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . set ( x ,    y ,    z )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "rotation . set ( q )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "Decal . tmp . set ( up )  . crs ( dir )  . nor (  )  ;", "Decal . tmp 2  . set ( dir )  . crs ( Decal . tmp )  . nor (  )  ;", "rotation . setFromAxes ( Decal . tmp . x ,    Decal . tmp 2  . x ,    dir . x ,    Decal . tmp . y ,    Decal . tmp 2  . y ,    dir . y ,    Decal . tmp . z ,    Decal . tmp 2  . z ,    dir . z )  ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "rotation . setEulerAngles ( yaw ,    pitch ,    roll )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "rotation . set ( Vector 3  . X ,    angle )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setRotationX"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "rotation . set ( Vector 3  . Y ,    angle )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setRotationY"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "rotation . set ( Vector 3  . Z ,    angle )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setRotationZ"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . scale . set ( scale ,    scale )  ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . scale . set ( scaleX ,    scaleY )  ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . scale . x    =    scale ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["setScaleX"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . scale . y    =    scale ;", "updated    =    false ;", "}", "METHOD_END"], "methodName": ["setScaleY"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . material . textureRegion    =    textureRegion ;", "updateUVs (  )  ;", "}", "METHOD_END"], "methodName": ["setTextureRegion"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . dimensions . x    =    width ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . x    =    x ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . y    =    y ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . z    =    z ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["setZ"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "float   x ;", "float   y ;", "float   z ;", "float   w ;", "float   tx ;", "float   ty ;", "if    (  ( transformationOffset )     !  =    null )     {", "tx    =     -  ( transformationOffset . x )  ;", "ty    =     -  ( transformationOffset . y )  ;", "} else    {", "tx    =    ty    =     0  ;", "}", "x    =     (  ( vertices [  . X 1  ]  )     +    tx )     *     ( scale . x )  ;", "y    =     (  ( vertices [  . Y 1  ]  )     +    ty )     *     ( scale . y )  ;", "z    =    vertices [  . Z 1  ]  ;", "vertices [  . X 1  ]     =     (  (  ( rotation . w )     *    x )     +     (  ( rotation . y )     *    z )  )     -     (  ( rotation . z )     *    y )  ;", "vertices [  . Y 1  ]     =     (  (  ( rotation . w )     *    y )     +     (  ( rotation . z )     *    x )  )     -     (  ( rotation . x )     *    z )  ;", "vertices [  . Z 1  ]     =     (  (  ( rotation . w )     *    z )     +     (  ( rotation . x )     *    y )  )     -     (  ( rotation . y )     *    x )  ;", "w    =     (  (  (  -  ( rotation . x )  )     *    x )     -     (  ( rotation . y )     *    y )  )     -     (  ( rotation . z )     *    z )  ;", "rotation . conjugate (  )  ;", "x    =    vertices [  . X 1  ]  ;", "y    =    vertices [  . Y 1  ]  ;", "z    =    vertices [  . Z 1  ]  ;", "vertices [  . X 1  ]     =     (  (  ( w    *     ( rotation . x )  )     +     ( x    *     ( rotation . w )  )  )     +     ( y    *     ( rotation . z )  )  )     -     ( z    *     ( rotation . y )  )  ;", "vertices [  . Y 1  ]     =     (  (  ( w    *     ( rotation . y )  )     +     ( y    *     ( rotation . w )  )  )     +     ( z    *     ( rotation . x )  )  )     -     ( x    *     ( rotation . z )  )  ;", "vertices [  . Z 1  ]     =     (  (  ( w    *     ( rotation . z )  )     +     ( z    *     ( rotation . w )  )  )     +     ( x    *     ( rotation . y )  )  )     -     ( y    *     ( rotation . x )  )  ;", "rotation . conjugate (  )  ;", "vertices [  . X 1  ]     +  =     ( position . x )     -    tx ;", "vertices [  . Y 1  ]     +  =     ( position . y )     -    ty ;", "vertices [  . Z 1  ]     +  =    position . z ;", "x    =     (  ( vertices [  . X 2  ]  )     +    tx )     *     ( scale . x )  ;", "y    =     (  ( vertices [  . Y 2  ]  )     +    ty )     *     ( scale . y )  ;", "z    =    vertices [  . Z 2  ]  ;", "vertices [  . X 2  ]     =     (  (  ( rotation . w )     *    x )     +     (  ( rotation . y )     *    z )  )     -     (  ( rotation . z )     *    y )  ;", "vertices [  . Y 2  ]     =     (  (  ( rotation . w )     *    y )     +     (  ( rotation . z )     *    x )  )     -     (  ( rotation . x )     *    z )  ;", "vertices [  . Z 2  ]     =     (  (  ( rotation . w )     *    z )     +     (  ( rotation . x )     *    y )  )     -     (  ( rotation . y )     *    x )  ;", "w    =     (  (  (  -  ( rotation . x )  )     *    x )     -     (  ( rotation . y )     *    y )  )     -     (  ( rotation . z )     *    z )  ;", "rotation . conjugate (  )  ;", "x    =    vertices [  . X 2  ]  ;", "y    =    vertices [  . Y 2  ]  ;", "z    =    vertices [  . Z 2  ]  ;", "vertices [  . X 2  ]     =     (  (  ( w    *     ( rotation . x )  )     +     ( x    *     ( rotation . w )  )  )     +     ( y    *     ( rotation . z )  )  )     -     ( z    *     ( rotation . y )  )  ;", "vertices [  . Y 2  ]     =     (  (  ( w    *     ( rotation . y )  )     +     ( y    *     ( rotation . w )  )  )     +     ( z    *     ( rotation . x )  )  )     -     ( x    *     ( rotation . z )  )  ;", "vertices [  . Z 2  ]     =     (  (  ( w    *     ( rotation . z )  )     +     ( z    *     ( rotation . w )  )  )     +     ( x    *     ( rotation . y )  )  )     -     ( y    *     ( rotation . x )  )  ;", "rotation . conjugate (  )  ;", "vertices [  . X 2  ]     +  =     ( position . x )     -    tx ;", "vertices [  . Y 2  ]     +  =     ( position . y )     -    ty ;", "vertices [  . Z 2  ]     +  =    position . z ;", "x    =     (  ( vertices [  . X 3  ]  )     +    tx )     *     ( scale . x )  ;", "y    =     (  ( vertices [  . Y 3  ]  )     +    ty )     *     ( scale . y )  ;", "z    =    vertices [  . Z 3  ]  ;", "vertices [  . X 3  ]     =     (  (  ( rotation . w )     *    x )     +     (  ( rotation . y )     *    z )  )     -     (  ( rotation . z )     *    y )  ;", "vertices [  . Y 3  ]     =     (  (  ( rotation . w )     *    y )     +     (  ( rotation . z )     *    x )  )     -     (  ( rotation . x )     *    z )  ;", "vertices [  . Z 3  ]     =     (  (  ( rotation . w )     *    z )     +     (  ( rotation . x )     *    y )  )     -     (  ( rotation . y )     *    x )  ;", "w    =     (  (  (  -  ( rotation . x )  )     *    x )     -     (  ( rotation . y )     *    y )  )     -     (  ( rotation . z )     *    z )  ;", "rotation . conjugate (  )  ;", "x    =    vertices [  . X 3  ]  ;", "y    =    vertices [  . Y 3  ]  ;", "z    =    vertices [  . Z 3  ]  ;", "vertices [  . X 3  ]     =     (  (  ( w    *     ( rotation . x )  )     +     ( x    *     ( rotation . w )  )  )     +     ( y    *     ( rotation . z )  )  )     -     ( z    *     ( rotation . y )  )  ;", "vertices [  . Y 3  ]     =     (  (  ( w    *     ( rotation . y )  )     +     ( y    *     ( rotation . w )  )  )     +     ( z    *     ( rotation . x )  )  )     -     ( x    *     ( rotation . z )  )  ;", "vertices [  . Z 3  ]     =     (  (  ( w    *     ( rotation . z )  )     +     ( z    *     ( rotation . w )  )  )     +     ( x    *     ( rotation . y )  )  )     -     ( y    *     ( rotation . x )  )  ;", "rotation . conjugate (  )  ;", "vertices [  . X 3  ]     +  =     ( position . x )     -    tx ;", "vertices [  . Y 3  ]     +  =     ( position . y )     -    ty ;", "vertices [  . Z 3  ]     +  =    position . z ;", "x    =     (  ( vertices [  . X 4  ]  )     +    tx )     *     ( scale . x )  ;", "y    =     (  ( vertices [  . Y 4  ]  )     +    ty )     *     ( scale . y )  ;", "z    =    vertices [  . Z 4  ]  ;", "vertices [  . X 4  ]     =     (  (  ( rotation . w )     *    x )     +     (  ( rotation . y )     *    z )  )     -     (  ( rotation . z )     *    y )  ;", "vertices [  . Y 4  ]     =     (  (  ( rotation . w )     *    y )     +     (  ( rotation . z )     *    x )  )     -     (  ( rotation . x )     *    z )  ;", "vertices [  . Z 4  ]     =     (  (  ( rotation . w )     *    z )     +     (  ( rotation . x )     *    y )  )     -     (  ( rotation . y )     *    x )  ;", "w    =     (  (  (  -  ( rotation . x )  )     *    x )     -     (  ( rotation . y )     *    y )  )     -     (  ( rotation . z )     *    z )  ;", "rotation . conjugate (  )  ;", "x    =    vertices [  . X 4  ]  ;", "y    =    vertices [  . Y 4  ]  ;", "z    =    vertices [  . Z 4  ]  ;", "vertices [  . X 4  ]     =     (  (  ( w    *     ( rotation . x )  )     +     ( x    *     ( rotation . w )  )  )     +     ( y    *     ( rotation . z )  )  )     -     ( z    *     ( rotation . y )  )  ;", "vertices [  . Y 4  ]     =     (  (  ( w    *     ( rotation . y )  )     +     ( y    *     ( rotation . w )  )  )     +     ( z    *     ( rotation . x )  )  )     -     ( x    *     ( rotation . z )  )  ;", "vertices [  . Z 4  ]     =     (  (  ( w    *     ( rotation . z )  )     +     ( z    *     ( rotation . w )  )  )     +     ( x    *     ( rotation . y )  )  )     -     ( y    *     ( rotation . x )  )  ;", "rotation . conjugate (  )  ;", "vertices [  . X 4  ]     +  =     ( position . x )     -    tx ;", "vertices [  . Y 4  ]     +  =     ( position . y )     -    ty ;", "vertices [  . Z 4  ]     +  =    position . z ;", "updated    =    true ;", "}", "METHOD_END"], "methodName": ["transformVertices"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . add ( trans )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . add ( x ,    y ,    z )  ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . x    +  =    units ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["translateX"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . y    +  =    units ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["translateY"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "this . position . z    +  =    units ;", "updated    =    fe ;", "}", "METHOD_END"], "methodName": ["translateZ"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( updated )  )     {", "resetVertes (  )  ;", "transformVertes (  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "TextureRegion   tr    =    material . textureRegion ;", "vertices [  . U 1  ]     =    tr . getU (  )  ;", "vertices [  . V 1  ]     =    tr . getV (  )  ;", "vertices [  . U 2  ]     =    tr . getU 2  (  )  ;", "vertices [  . V 2  ]     =    tr . getV (  )  ;", "vertices [  . U 3  ]     =    tr . getU (  )  ;", "vertices [  . V 3  ]     =    tr . getV 2  (  )  ;", "vertices [  . U 4  ]     =    tr . getU 2  (  )  ;", "vertices [  . V 4  ]     =    tr . getV 2  (  )  ;", "}", "METHOD_END"], "methodName": ["updateUVs"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.Decal"}, {"methodBody": ["METHOD_START", "{", "int   groupIndex    =    groupStrategy . decideGroup ( decal )  ;", "Array < Decal >    targetGroup    =    groupList . get ( groupIndex )  ;", "if    ( targetGroup    =  =    null )     {", "targetGroup    =    groupPool . obtain (  )  ;", "targetGroup . clear (  )  ;", "usedGroups . add ( targetGroup )  ;", "groupList . insert ( groupIndex ,    targetGroup )  ;", "}", "targetGroup . add ( decal )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "groupList . clear (  )  ;", "groupPool . freeAll ( usedGroups )  ;", "usedGroups . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "clear (  )  ;", "vertes    =    null ;", "mesh . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "render (  )  ;", "clear (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "mesh . setVertices ( vertices ,     0  ,    verticesPosition )  ;", "mesh . render ( shader ,    GL 2  0  . GL _ TRIANGLES ,     0  ,     ( verticesPosition    /     4  )  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "return    ( vertices . length )     /     ( Decal . SIZE )  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "vertices    =    new   float [ size    *     ( Decal . SIZE )  ]  ;", "Mesh . VertexDataType   vertexDataType    =    Mesh . VertexDataType . VertexArray ;", "if    (  ( Gdx . gl 3  0  )     !  =    null )     {", "vertexDataType    =    Mesh . VertexDataType . VertexBufferObjectWithVAO ;", "}", "mesh    =    new   Mesh ( vertexDataType ,    false ,     ( size    *     4  )  ,     ( size    *     6  )  ,    new   VertexAttribute ( VertexAttributes . Usage . Position ,     3  ,    ShaderProgram . POSITION _ ATTRIBUTE )  ,    new   VertexAttribute ( VertexAttributes . Usage . ColorPacked ,     4  ,    ShaderProgram . COLOR _ ATTRIBUTE )  ,    new   VertexAttribute ( VertexAttributes . Usage . TextureCoordinates ,     2  ,     (  ( ShaderProgram . TEXCOORD _ ATTRIBUTE )     +     \"  0  \"  )  )  )  ;", "short [  ]    indices    =    new   short [ size    *     6  ]  ;", "int   v    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( indices . length )  ;    i    +  =     6     ,    v    +  =     4  )     {", "indices [ i ]     =     (  ( short )     ( v )  )  ;", "indices [  ( i    +     1  )  ]     =     (  ( short )     ( v    +     2  )  )  ;", "indices [  ( i    +     2  )  ]     =     (  ( short )     ( v    +     1  )  )  ;", "indices [  ( i    +     3  )  ]     =     (  ( short )     ( v    +     1  )  )  ;", "indices [  ( i    +     4  )  ]     =     (  ( short )     ( v    +     2  )  )  ;", "indices [  ( i    +     5  )  ]     =     (  ( short )     ( v    +     3  )  )  ;", "}", "mesh . setIndices ( indices )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "groupStrategy . beforeGroups (  )  ;", "for    ( SortedIntList . Node < Array <  >  >    group    :    groupList )     {", "groupStrategy . beforeGroup ( group . index ,    group . value )  ;", "ShaderProgram   shader    =    groupStrategy . getGroupShader ( group . index )  ;", "render ( shader ,    group . value )  ;", "groupStrategy . afterGroup ( group . index )  ;", "}", "groupStrategy . afterGroups (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "DecalMaterial   lastMaterial    =    null ;", "int   idx    =     0  ;", "for    ( Decal   decal    :     )     {", "if    (  ( lastMaterial    =  =    null )     |  |     (  !  ( lastMaterial . equals ( decal . getMaterial (  )  )  )  )  )     {", "if    ( idx    >     0  )     {", "flush ( shader ,    idx )  ;", "idx    =     0  ;", "}", "decal . material . set (  )  ;", "lastMaterial    =    decal . material ;", "}", "decal . update (  )  ;", "System . arraycopy ( decal . vertices ,     0  ,    vertices ,    idx ,    decal . vertices . length )  ;", "idx    +  =    decal . vertices . length ;", "if    ( idx    =  =     ( vertices . length )  )     {", "flush ( shader ,    idx )  ;", "idx    =     0  ;", "}", "}", "if    ( idx    >     0  )     {", "flush ( shader ,    idx )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "this . groupStrategy    =    groupStrategy ;", "}", "METHOD_END"], "methodName": ["setGroupStrategy"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalBatch"}, {"methodBody": ["METHOD_START", "{", "return   dstBlendFactor ;", "}", "METHOD_END"], "methodName": ["getDstBlendFactor"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalMaterial"}, {"methodBody": ["METHOD_START", "{", "return   srcBlendFactor ;", "}", "METHOD_END"], "methodName": ["getSrcBlendFactor"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalMaterial"}, {"methodBody": ["METHOD_START", "{", "return    ( srcBlendFactor )     =  =     ( DecalMaterial . NO _ BLEND )  ;", "}", "METHOD_END"], "methodName": ["isOpaque"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalMaterial"}, {"methodBody": ["METHOD_START", "{", "textureRegion . getTexture (  )  . bind (  0  )  ;", "if    (  !  ( isOpaque (  )  )  )     {", "Gl . glBlendFunc ( srcBlendFactor ,    dstBlendFactor )  ;", "}", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.DecalMaterial"}, {"methodBody": ["METHOD_START", "{", "plugs . put ( group ,    plug )  ;", "}", "METHOD_END"], "methodName": ["plugIn"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.PluggableGroupStrategy"}, {"methodBody": ["METHOD_START", "{", "return   plugs . remove ( group )  ;", "}", "METHOD_END"], "methodName": ["unPlug"], "fileName": "com.badlogic.gdx.graphics.g3d.decals.PluggableGroupStrategy"}, {"methodBody": ["METHOD_START", "{", "return   add ( color . r ,    color . g ,    color . b )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "return   add ( color . r ,    color . g ,    color . b ,    direction . x ,    direction . y ,    direction . z )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "return   add ( color . r ,    color . g ,    color . b ,     (  ( target . x )     -     ( point . x )  )  ,     (  ( target . y )     -     ( point . y )  )  ,     (  ( target . z )     -     ( point . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "final   float   t    =    insity    /     (  1  .  0 F    +     ( target . dst ( poi )  )  ;", "return   add (  (  ( color . r )     *    t )  ,     (  ( color . g )     *    t )  ,     (  ( color . b )     *    t )  ,     (  ( target . x )     -     ( poix )  )  ,     (  ( target . y )     -     ( poiy )  )  ,     (  ( target . z )     -     ( poiz )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "return   add ( color . r ,    color . g ,    color . b ,    x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "for    ( int   idx    =     0  ;    idx    <     ( data . length )  ;  )     {", "data [  ( idx +  +  )  ]     +  =    r ;", "data [  ( idx +  +  )  ]     +  =    g ;", "data [  ( idx +  +  )  ]     +  =    b ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "return   add ( r ,    g ,    b ,    direction . x ,    direction . y ,    direction . z )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "final   float   x 2     =    x    *    x ;", "final   float   y 2     =    y    *    y ;", "final   float   z 2     =    z    *    z ;", "float   d    =     ( x 2     +    y 2  )     +    z 2  ;", "if    ( d    =  =     0  .  0 F )", "return   this ;", "d    =     (  1  .  0 F    /    d )     *     ( d    +     1  .  0 F )  ;", "final   float   rd    =    r    *    d ;", "final   float   gd    =    g    *    d ;", "final   float   bd    =    b    *    d ;", "int   idx    =     ( x    >     0  )     ?     0     :     3  ;", "data [ idx ]     +  =    x 2     *    rd ;", "data [  ( idx    +     1  )  ]     +  =    x 2     *    gd ;", "data [  ( idx    +     2  )  ]     +  =    x 2     *    bd ;", "idx    =     ( y    >     0  )     ?     6     :     9  ;", "data [ idx ]     +  =    y 2     *    rd ;", "data [  ( idx    +     1  )  ]     +  =    y 2     *    gd ;", "data [  ( idx    +     2  )  ]     +  =    y 2     *    bd ;", "idx    =     ( z    >     0  )     ?     1  2     :     1  5  ;", "data [ idx ]     +  =    z 2     *    rd ;", "data [  ( idx    +     1  )  ]     +  =    z 2     *    gd ;", "data [  ( idx    +     2  )  ]     +  =    z 2     *    bd ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( data . length )  ;    i +  +  )", "data [ i ]     =     . clamp ( data [ i ]  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "return   v    <     0  .  0 F    ?     0  .  0 F    :    v    >     1  .  0 F    ?     1  .  0 F    :    v ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( data . length )  ;    i +  +  )", "data [ i ]     =     0  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "side    *  =     3  ;", "rern   ouseda [ side ]  ,    da [  ( side    +     1  )  ]  ,    da [  ( side    +     2  )  ]  ,     1  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "return   set ( color . r ,    color . g ,    color . b )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "return   set ( other . data )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "for    ( int   idx    =     0  ;    idx    <     ( AmbientCubemap . NUM _ VALUES )  ;  )     {", "data [ idx ]     =    r ;", "data [  ( idx    +     1  )  ]     =    g ;", "data [  ( idx    +     2  )  ]     =    b ;", "idx    +  =     3  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( data . length )  ;    i +  +  )", "data [ i ]     =    values [ i ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.AmbientCubemap"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( color )  ;", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.BaseLight"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,    a )  ;", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.BaseLight"}, {"methodBody": ["METHOD_START", "{", "return    ( other    !  =    null )     &  &     (  ( other    =  =     ( this )  )     |  |     (  ( color . equals ( other . color )  )     &  &     ( direction . equals ( other . direction )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "if    ( color    !  =    null )", "this . color . set ( color )  ;", "if    ( d    !  =    null )", "this . d . set ( d )  . nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "if    ( color    !  =    null )", "this . color . set ( color )  ;", "this . d . set ( dirX ,    dirY ,    dirZ )  . nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "return   set ( copyFrom . color ,    copyFrom . direction )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,     1  .  0 F )  ;", "if    ( d    !  =    null )", "this . d . set ( d )  . nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,     1  .  0 F )  ;", "this . d . set ( dirX ,    dirY ,    dirZ )  . nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "this . direction . set ( direction )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDirection"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "this . direction . set ( directionX ,    directionY ,    directionZ )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDirection"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalLight"}, {"methodBody": ["METHOD_START", "{", "final   int   w    =    fbo . getWidth (  )  ;", "final   int   h    =    fbo . getHe (  )  ;", "fbo . begin (  )  ;", "Gdx . gl . glViewport (  0  ,     0  ,    w ,    h )  ;", "Gdx . gl . glClearColor (  1  ,     1  ,     1  ,     1  )  ;", "Gdx . gl . glClear (  (  ( GL 2  0  . GL _ COLOR _ BUFFER _ BIT )     |     ( GL 2  0  . GL _ DEPTH _ BUFFER _ BIT )  )  )  ;", "Gdx . gl . glEnable ( GL 2  0  . GL _ SCISSOR _ TEST )  ;", "Gdx . gl . glScissor (  1  ,     1  ,     ( w    -     2  )  ,     ( h    -     2  )  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "update ( camera )  ;", "begin (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "update ( center ,    forward )  ;", "begin (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glDisable ( GL 2  0  . GL _ SCISSOR _ TEST )  ;", "fbo . end (  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "return   cam ;", "}", "METHOD_END"], "methodName": ["getCamera"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "return   fbo ;", "}", "METHOD_END"], "methodName": ["getFrameBuffer"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "update ( tmpV . set ( camera . direction )  . scl ( halfHeight )  ,    camera . direction )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "cam . position . set ( direction )  . scl (  (  -  ( halfDepth )  )  )  . add ( center )  ;", "cam . direction . set ( direction )  . nor (  )  ;", "cam . normalizeUp (  )  ;", "cam . update (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.DirectionalShadowLight"}, {"methodBody": ["METHOD_START", "{", "return    ( other    !  =    null )     &  &     (  ( other    =  =     ( this )  )     |  |     (  (  ( color . equals ( other . color )  )     &  &     ( position . equals ( other . position )  )  )     &  &     (  ( intensity )     =  =     ( other . intensity )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "if    ( color    !  =    null )", "this . color . set ( color )  ;", "if    ( position    !  =    null )", "this . position . set ( position )  ;", "this . ensity    =    ensity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "if    ( color    !  =    null )", "this . color . set ( color )  ;", "this . position . set ( x ,    y ,    z )  ;", "this . ensity    =    ensity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "return   set ( copyFrom . color ,    copyFrom . position ,    copyFrom . intensity )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,     1  .  0 F )  ;", "if    ( position    !  =    null )", "this . position . set ( position )  ;", "this . ensity    =    ensity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,     1  .  0 F )  ;", "this . position . set ( x ,    y ,    z )  ;", "this . ensity    =    ensity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "this . intensity    =    intensity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIntensity"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "this . position . set ( position )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "this . position . set ( positionX ,    positionY ,    positionZ )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.PointLight"}, {"methodBody": ["METHOD_START", "{", "return   v    <     0  .  0 F    ?     0  .  0 F    :    v    >     1  .  0 F    ?     1  .  0 F    :    v ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SphericalHarmonics"}, {"methodBody": ["METHOD_START", "{", "return   set ( color . r ,    color . g ,    color . b )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SphericalHarmonics"}, {"methodBody": ["METHOD_START", "{", "return   set ( other . data )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SphericalHarmonics"}, {"methodBody": ["METHOD_START", "{", "for    ( int   idx    =     0  ;    idx    <     ( data . length )  ;  )     {", "data [  ( idx +  +  )  ]     =    r ;", "data [  ( idx +  +  )  ]     =    g ;", "data [  ( idx +  +  )  ]     =    b ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SphericalHarmonics"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( data . length )  ;    i +  +  )", "data [ i ]     =    values [ i ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SphericalHarmonics"}, {"methodBody": ["METHOD_START", "{", "return    ( other    !  =    null )     &  &     (  ( other    =  =     ( this )  )     |  |     (  (  (  (  (  ( color . equals ( other . color )  )     &  &     ( position . equals ( other . position )  )  )     &  &     ( direction . equals ( other . direction )  )  )     &  &     ( MathUtils . isEqual ( intensity ,    other . intensity )  )  )     &  &     ( MathUtils . isEqual ( cutoffAngle ,    other . cutoffAngle )  )  )     &  &     ( MathUtils . isEqual ( exponent ,    other . exponent )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "if    ( color    !  =    null )", "this . color . set ( color )  ;", "if    ( position    !  =    null )", "this . position . set ( position )  ;", "if    ( direction    !  =    null )", "this . direction . set ( direction )  . nor (  )  ;", "this . intensity    =    intensity ;", "this . cutoffAngle    =    cutoffAngle ;", "this . expon    =    expon ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "if    ( color    !  =    null )", "this . color . set ( color )  ;", "this . position . set ( posX ,    posY ,    posZ )  ;", "this . direction . set ( dirX ,    dirY ,    dirZ )  . nor (  )  ;", "this . intensity    =    intensity ;", "this . cutoffAngle    =    cutoffAngle ;", "this . expon    =    expon ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "return   set ( copyFrom . color ,    copyFrom . position ,    copyFrom . direction ,    copyFrom . intensity ,    copyFrom . cutoffAngle ,    copyFrom . exponent )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,     1  .  0 F )  ;", "if    ( position    !  =    null )", "this . position . set ( position )  ;", "if    ( direction    !  =    null )", "this . direction . set ( direction )  . nor (  )  ;", "this . intensity    =    intensity ;", "this . cutoffAngle    =    cutoffAngle ;", "this . expon    =    expon ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,     1  .  0 F )  ;", "this . position . set ( posX ,    posY ,    posZ )  ;", "this . direction . set ( dirX ,    dirY ,    dirZ )  . nor (  )  ;", "this . intensity    =    intensity ;", "this . cutoffAngle    =    cutoffAngle ;", "this . expon    =    expon ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . cutoffAngle    =    cutoffAngle ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCutoffAngle"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . direction . set ( direction )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDirection"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . direction . set ( directionX ,    directionY ,    directionZ )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDirection"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . exponent    =    exponent ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExponent"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . intensity    =    intensity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIntensity"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . position . set ( position )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "this . position . set ( positionX ,    positionY ,    positionZ )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "direction . set ( target )  . sub ( position )  . nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.graphics.g3d.environment.SpotLight"}, {"methodBody": ["METHOD_START", "{", "JsonValue   animations    =    json . get (  \" animations \"  )  ;", "if    ( animations    =  =    null )", "return ;", "model . animations . ensureCapacity ( animations . size )  ;", "for    ( JsonValue   anim    =    animations . child ;    anim    !  =    null ;    anim    =    anim . next )     {", "JsonValue   nodes    =    anim . get (  \" bones \"  )  ;", "if    ( nodes    =  =    null )", "continue ;", "Animation   animation    =    new   Animation (  )  ;", "model . animations . add ( animation )  ;", "animation . nodeAnimations . ensureCapacity ( nodes . size )  ;", "animation . id    =    anim . getString (  \" id \"  )  ;", "for    ( JsonValue   node    =    nodes . child ;    node    !  =    null ;    node    =    node . next )     {", "NodeAnimation   nodeAnim    =    new   NodeAnimation (  )  ;", "animation . nodeAnimations . add ( nodeAnim )  ;", "nodeAnim . nodeId    =    node . getString (  \" boneId \"  )  ;", "JsonValue   keyframes    =    node . get (  \" keyframes \"  )  ;", "if    (  ( keyframes    !  =    null )     &  &     ( keyframes . isArray (  )  )  )     {", "for    ( JsonValue   keyframe    =    keyframes . child ;    keyframe    !  =    null ;    keyframe    =    keyframe . next )     {", "final   float   keytime    =     ( keyframe . getFloat (  \" keytime \"  ,     0  .  0 F )  )     /     1  0  0  0  .  0 F ;", "JsonValue   translation    =    keyframe . get (  \" translation \"  )  ;", "if    (  ( translation    !  =    null )     &  &     (  ( translation . size )     =  =     3  )  )     {", "if    (  ( nodeAnim . translation )     =  =    null )", "nodeAnim . translation    =    new   Array < NodeKeyframe < Vector 3  >  >  (  )  ;", "NodeKeyframe < Vector 3  >    tkf    =    new   NodeKeyframe < Vector 3  >  (  )  ;", "tkf . keytime    =    keytime ;", "tkf . value    =    new   Vector 3  ( translation . getFloat (  0  )  ,    translation . getFloat (  1  )  ,    translation . getFloat (  2  )  )  ;", "nodeAnim . translation . add ( tkf )  ;", "}", "JsonValue   rotation    =    keyframe . get (  \" rotation \"  )  ;", "if    (  ( rotation    !  =    null )     &  &     (  ( rotation . size )     =  =     4  )  )     {", "if    (  ( nodeAnim . rotation )     =  =    null )", "nodeAnim . rotation    =    new   Array < NodeKeyframe < Quaternion >  >  (  )  ;", "NodeKeyframe < Quaternion >    rkf    =    new   NodeKeyframe < Quaternion >  (  )  ;", "rkf . keytime    =    keytime ;", "rkf . value    =    new   Quaternion ( rotation . getFloat (  0  )  ,    rotation . getFloat (  1  )  ,    rotation . getFloat (  2  )  ,    rotation . getFloat (  3  )  )  ;", "nodeAnim . rotation . add ( rkf )  ;", "}", "JsonValue   scale    =    keyframe . get (  \" scale \"  )  ;", "if    (  ( scale    !  =    null )     &  &     (  ( scale . size )     =  =     3  )  )     {", "if    (  ( nodeAnim . scaling )     =  =    null )", "nodeAnim . scaling    =    new   Array < NodeKeyframe < Vector 3  >  >  (  )  ;", "NodeKeyframe < Vector 3  >    skf    =    new   NodeKeyframe (  )  ;", "skf . keytime    =    keytime ;", "skf . value    =    new   Vector 3  ( scale . getFloat (  0  )  ,    scale . getFloat (  1  )  ,    scale . getFloat (  2  )  )  ;", "nodeAnim . scaling . add ( skf )  ;", "}", "}", "} else    {", "JsonValue   translationKF    =    node . get (  \" translation \"  )  ;", "if    (  ( translationKF    !  =    null )     &  &     ( translationKF . isArray (  )  )  )     {", "nodeAnim . translation    =    new   Array < NodeKeyframe < Vector 3  >  >  (  )  ;", "nodeAnim . translation . ensureCapacity ( translationKF . size )  ;", "for    ( JsonValue   keyframe    =    translationKF . child ;    keyframe    !  =    null ;    keyframe    =    keyframe . next )     {", "NodeKeyframe < Vector 3  >    kf    =    new   NodeKeyframe < Vector 3  >  (  )  ;", "nodeAnim . translation . add ( kf )  ;", "kf . keytime    =     ( keyframe . getFloat (  \" keytime \"  ,     0  .  0 F )  )     /     1  0  0  0  .  0 F ;", "JsonValue   translation    =    keyframe . get (  \" value \"  )  ;", "if    (  ( translation    !  =    null )     &  &     (  ( translation . size )     >  =     3  )  )", "kf . value    =    new   Vector 3  ( translation . getFloat (  0  )  ,    translation . getFloat (  1  )  ,    translation . getFloat (  2  )  )  ;", "}", "}", "JsonValue   rotationKF    =    node . get (  \" rotation \"  )  ;", "if    (  ( rotationKF    !  =    null )     &  &     ( rotationKF . isArray (  )  )  )     {", "nodeAnim . rotation    =    new   Array < NodeKeyframe < Quaternion >  >  (  )  ;", "nodeAnim . rotation . ensureCapacity ( rotationKF . size )  ;", "for    ( JsonValue   keyframe    =    rotationKF . child ;    keyframe    !  =    null ;    keyframe    =    keyframe . next )     {", "NodeKeyframe < Quaternion >    kf    =    new   NodeKeyframe < Quaternion >  (  )  ;", "nodeAnim . rotation . add ( kf )  ;", "kf . keytime    =     ( keyframe . getFloat (  \" keytime \"  ,     0  .  0 F )  )     /     1  0  0  0  .  0 F ;", "JsonValue   rotation    =    keyframe . get (  \" value \"  )  ;", "if    (  ( rotation    !  =    null )     &  &     (  ( rotation . size )     >  =     4  )  )", "kf . value    =    new   Quaternion ( rotation . getFloat (  0  )  ,    rotation . getFloat (  1  )  ,    rotation . getFloat (  2  )  ,    rotation . getFloat (  3  )  )  ;", "}", "}", "JsonValue   scalingKF    =    node . get (  \" scaling \"  )  ;", "if    (  ( scalingKF    !  =    null )     &  &     ( scalingKF . isArray (  )  )  )     {", "nodeAnim . scaling    =    new   Array < NodeKeyframe < Vector 3  >  >  (  )  ;", "nodeAnim . scaling . ensureCapacity ( scalingKF . size )  ;", "for    ( JsonValue   keyframe    =    scalingKF . child ;    keyframe    !  =    null ;    keyframe    =    keyframe . next )     {", "NodeKeyframe < Vector 3  >    kf    =    new   NodeKeyframe < Vector 3  >  (  )  ;", "nodeAnim . scaling . add ( kf )  ;", "kf . keytime    =     ( keyframe . getFloat (  \" keytime \"  ,     0  .  0 F )  )     /     1  0  0  0  .  0 F ;", "JsonValue   scaling    =    keyframe . get (  \" value \"  )  ;", "if    (  ( scaling    !  =    null )     &  &     (  ( scaling . size )     >  =     3  )  )", "kf . value    =    new   Vector 3  ( scaling . getFloat (  0  )  ,    scaling . getFloat (  1  )  ,    scaling . getFloat (  2  )  )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseAnimations"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "Array < VertexAttribute >    vertexAttributes    =    new   Array < VertexAttribute >  (  )  ;", "int   unit    =     0  ;", "int   blendWeightCount    =     0  ;", "for    ( JsonValue   value    =    attributes . child ;    value    !  =    null ;    value    =    value . next )     {", "String   attribute    =    value . asString (  )  ;", "String   attr    =     (  ( String )     ( attribute )  )  ;", "if    ( attr . equals (  \" POSITION \"  )  )     {", "vertexAttributes . add ( VertexAttribute . Position (  )  )  ;", "} else", "if    ( attr . equals (  \" NORMAL \"  )  )     {", "vertexAttributes . add ( VertexAttribute . Normal (  )  )  ;", "} else", "if    ( attr . equals (  \" COLOR \"  )  )     {", "vertexAttributes . add ( VertexAttribute . ColorUnpacked (  )  )  ;", "} else", "if    ( attr . equals (  \" COLORPACKED \"  )  )     {", "vertexAttributes . add ( VertexAttribute . ColorPacked (  )  )  ;", "} else", "if    ( attr . equals (  \" TANGENT \"  )  )     {", "vertexAttributes . add ( VertexAttribute . Tangent (  )  )  ;", "} else", "if    ( attr . equals (  \" BINORMAL \"  )  )     {", "vertexAttributes . add ( VertexAttribute . Binormal (  )  )  ;", "} else", "if    ( attr . startsWith (  \" TEXCOORD \"  )  )     {", "vertexAttributes . add ( VertexAttribute . TexCoords (  ( unit +  +  )  )  )  ;", "} else", "if    ( attr . startsWith (  \" BLENDWEIGHT \"  )  )     {", "vertexAttributes . add ( VertexAttribute . BoneWeight (  ( blendWeightCount +  +  )  )  )  ;", "} else    {", "throw   new   utils . GdxRuntimeException (  (  (  \" Unknown   vertex   attribute    '  \"     +    attr )     +     \"  '  ,    should   be   one   of   position ,    normal ,    uv ,    tangent   or   binormal \"  )  )  ;", "}", "}", "return   vertexAttributes . toArray ( VertexAttribute . class )  ;", "}", "METHOD_END"], "methodName": ["parseAttributes"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( colorArray . size )     >  =     3  )", "return   new   Color ( colorArray . getFloat (  0  )  ,    colorArray . getFloat (  1  )  ,    colorArray . getFloat (  2  )  ,     1  .  0 F )  ;", "else", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" Expected   Color   values    <  >    than   three .  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseColor"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   materials    =    json . get (  \" materials \"  )  ;", "if    ( materials    =  =    null )     {", "} else    {", "model . materials . ensureCapacity ( materials . size )  ;", "for    ( JsonValue   material    =    materials . child ;    material    !  =    null ;    material    =    material . next )     {", "ModelMaterial   jsonMaterial    =    new   ModelMaterial (  )  ;", "String   id    =    material . getString (  \" id \"  ,    null )  ;", "if    ( id    =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Material   needs   an   id .  \"  )  ;", "jsonMaterial . id    =    id ;", "final   JsonValue   diffuse    =    material . get (  \" diffuse \"  )  ;", "if    ( diffuse    !  =    null )", "jsonMaterial . diffuse    =    parseColor ( diffuse )  ;", "final   JsonValue   ambient    =    material . get (  \" ambient \"  )  ;", "if    ( ambient    !  =    null )", "jsonMaterial . ambient    =    parseColor ( ambient )  ;", "final   JsonValue   emissive    =    material . get (  \" emissive \"  )  ;", "if    ( emissive    !  =    null )", "jsonMaterial . emissive    =    parseColor ( emissive )  ;", "final   JsonValue   specular    =    material . get (  \" specular \"  )  ;", "if    ( specular    !  =    null )", "jsonMaterial . specular    =    parseColor ( specular )  ;", "final   JsonValue   reflection    =    material . get (  \" reflection \"  )  ;", "if    ( reflection    !  =    null )", "jsonMaterial . reflection    =    parseColor ( reflection )  ;", "jsonMaterial . shininess    =    material . getFloat (  \" shininess \"  ,     0  .  0 F )  ;", "jsonMaterial . opacity    =    material . getFloat (  \" opacity \"  ,     1  .  0 F )  ;", "JsonValue   textures    =    material . get (  \" textures \"  )  ;", "if    ( textures    !  =    null )     {", "for    ( JsonValue   texture    =    textures . child ;    texture    !  =    null ;    texture    =    texture . next )     {", "ModelTexture   jsonTexture    =    new   ModelTexture (  )  ;", "String   textureId    =    texture . getString (  \" id \"  ,    null )  ;", "if    ( textureId    =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Texture   has   no   id .  \"  )  ;", "jsonTexture . id    =    textureId ;", "String   fileName    =    texture . getString (  \" filename \"  ,    null )  ;", "if    ( fileName    =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Texture   needs   filename .  \"  )  ;", "jsonTexture . fileName    =     ( materialDir    +     (  (  ( materialDir . length (  )  )     =  =     0  )     |  |     ( materialDir . endsWith (  \"  /  \"  )  )     ?     \"  \"     :     \"  /  \"  )  )     +    fileName ;", "jsonTexture . uvTranslation    =    readVector 2  ( texture . get (  \" uvTranslation \"  )  ,     0  .  0 F ,     0  .  0 F )  ;", "jsonTexture . uvScaling    =    readVector 2  ( texture . get (  \" uvScaling \"  )  ,     1  .  0 F ,     1  .  0 F )  ;", "String   textureType    =    texture . getString (  \" type \"  ,    null )  ;", "if    ( textureType    =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Texture   needs   type .  \"  )  ;", "jsonTexture . usage    =    parseTextureUsage ( textureType )  ;", "if    (  ( jsonMaterial . textures )     =  =    null )", "jsonMaterial . textures    =    new   utils . Array < ModelTexture >  (  )  ;", "jsonMaterial . textures . add ( jsonTexture )  ;", "}", "}", "model . materials . add ( jsonMaterial )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseMaterials"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   meshes    =    json . get (  \" meshes \"  )  ;", "if    ( meshes    !  =    null )     {", "model . meshes . ensureCapacity ( meshes . size )  ;", "for    ( JsonValue   mesh    =    meshes . child ;    mesh    !  =    null ;    mesh    =    mesh . next )     {", "Mesh   jsonMesh    =    new   Mesh (  )  ;", "String   id    =    mesh . getString (  \" id \"  ,     \"  \"  )  ;", "jsonMesh . id    =    id ;", "JsonValue   attributes    =    mesh . require (  \" attributes \"  )  ;", "jsonMesh . attributes    =    parseAttributes ( attributes )  ;", "jsonMesh . vertices    =    mesh . require (  \" vertices \"  )  . asFloatArray (  )  ;", "JsonValue   meshParts    =    mesh . require (  \" parts \"  )  ;", "Array < MeshPart >    parts    =    new   Array < MeshPart >  (  )  ;", "for    ( JsonValue   meshPart    =    meshParts . child ;    meshPart    !  =    null ;    meshPart    =    meshPart . next )     {", "MeshPart   jsonPart    =    new   MeshPart (  )  ;", "String   partId    =    meshPart . getString (  \" id \"  ,    null )  ;", "if    ( partId    =  =    null )     {", "throw   new   GdxRuntimeException (  \" Not   id   given   for   mesh   part \"  )  ;", "}", "for    ( MeshPart   other    :    parts )     {", "if    ( other . id . equals ( partId )  )     {", "throw   new   GdxRuntimeException (  (  (  \" Mesh   part   with   id    '  \"     +    partId )     +     \"  '    already   in   defined \"  )  )  ;", "}", "}", "jsonPart . id    =    partId ;", "String   type    =    meshPart . getString (  \" type \"  ,    null )  ;", "if    ( type    =  =    null )     {", "throw   new   GdxRuntimeException (  (  (  \" No   primitive   type   given   for   mesh   part    '  \"     +    partId )     +     \"  '  \"  )  )  ;", "}", "jsonPart . primitiveType    =    parseType ( type )  ;", "jsonPart . indices    =    meshPart . require (  \" indices \"  )  . asShortArray (  )  ;", "parts . add ( jsonPart )  ;", "}", "jsonMesh . parts    =    parts . toArray ( MeshPart . class )  ;", "model . meshes . add ( jsonMesh )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseMeshes"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   json    =    reader . parse ( handle )  ;", "ModelData   model    =    new   ModelData (  )  ;", "JsonValue   version    =    json . require (  \" version \"  )  ;", "model . version [  0  ]     =    version . getShort (  0  )  ;", "model . version [  1  ]     =    version . getShort (  1  )  ;", "if    (  (  ( model . version [  0  ]  )     !  =     ( G 3 dModelLoader . VERSION _ HI )  )     |  |     (  ( model . version [  1  ]  )     !  =     ( G 3 dModelLoader . VERSION _ LO )  )  )", "throw   new   utils . GdxRuntimeException (  \" Model   version   not   supported \"  )  ;", "model . id    =    json . getString (  \" id \"  ,     \"  \"  )  ;", "parseMeshes ( model ,    json )  ;", "parseMaterials ( model ,    json ,    handle . parent (  )  . path (  )  )  ;", "parseNodes ( model ,    json )  ;", "parseAnimations ( model ,    json )  ;", "return   model ;", "}", "METHOD_END"], "methodName": ["parseModel"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   nodes    =    json . get (  \" nodes \"  )  ;", "if    ( nodes    !  =    null )     {", "m . nodes . ensureCapacity ( nodes . size )  ;", "for    ( JsonValue   node    =    nodes . child ;    node    !  =    null ;    node    =    node . next )     {", "m . nodes . add ( parseNodesRecursively ( node )  )  ;", "}", "}", "return   m . nodes ;", "}", "METHOD_END"], "methodName": ["parseNodes"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "ModelNode   jsonNode    =    new   ModelNode (  )  ;", "String   id    =    json . getString (  \" id \"  ,    null )  ;", "if    ( id    =  =    null )", "throw   new   GdxRuntimeException (  \" Node   id   missing .  \"  )  ;", "jsonNode . id    =    id ;", "JsonValue   translation    =    json . get (  \" translation \"  )  ;", "if    (  ( translation    !  =    null )     &  &     (  ( translation . size )     !  =     3  )  )", "throw   new   GdxRuntimeException (  \" Node   translation   incomplete \"  )  ;", "jsonNode . translation    =     ( translation    =  =    null )     ?    null    :    new   Vector 3  ( translation . getFloat (  0  )  ,    translation . getFloat (  1  )  ,    translation . getFloat (  2  )  )  ;", "JsonValue   rotation    =    json . get (  \" rotation \"  )  ;", "if    (  ( rotation    !  =    null )     &  &     (  ( rotation . size )     !  =     4  )  )", "throw   new   GdxRuntimeException (  \" Node   rotation   incomplete \"  )  ;", "jsonNode . rotation    =     ( rotation    =  =    null )     ?    null    :    new   Quaternion ( rotation . getFloat (  0  )  ,    rotation . getFloat (  1  )  ,    rotation . getFloat (  2  )  ,    rotation . getFloat (  3  )  )  ;", "JsonValue   scale    =    json . get (  \" scale \"  )  ;", "if    (  ( scale    !  =    null )     &  &     (  ( scale . size )     !  =     3  )  )", "throw   new   GdxRuntimeException (  \" Node   scale   incomplete \"  )  ;", "jsonNode . scale    =     ( scale    =  =    null )     ?    null    :    new   Vector 3  ( scale . getFloat (  0  )  ,    scale . getFloat (  1  )  ,    scale . getFloat (  2  )  )  ;", "String   meshId    =    json . getString (  \" mesh \"  ,    null )  ;", "if    ( meshId    !  =    null )", "jsonNode . meshId    =    meshId ;", "JsonValue   materials    =    json . get (  \" parts \"  )  ;", "if    ( materials    !  =    null )     {", "jsonNode . parts    =    new   ModelNodePart [ materials . size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   material    =    materials . child ;    material    !  =    null ;    material    =    material . next    ,    i +  +  )     {", "ModelNodePart   nodePart    =    new   ModelNodePart (  )  ;", "String   meshPartId    =    material . getString (  \" meshpartid \"  ,    null )  ;", "String   materialId    =    material . getString (  \" materialid \"  ,    null )  ;", "if    (  ( meshPartId    =  =    null )     |  |     ( materialId    =  =    null )  )     {", "throw   new   GdxRuntimeException (  (  (  \" Node    \"     +    id )     +     \"    part   is   missing   meshPartId   or   materialId \"  )  )  ;", "}", "nodePart . materialId    =    materialId ;", "nodePart . meshPartId    =    meshPartId ;", "JsonValue   bones    =    material . get (  \" bones \"  )  ;", "if    ( bones    !  =    null )     {", "nodePart . bones    =    new   ArrayMap < String ,    Matrix 4  >  ( true ,    bones . size ,    String . class ,    Matrix 4  . class )  ;", "int   j    =     0  ;", "for    ( JsonValue   bone    =    bones . child ;    bone    !  =    null ;    bone    =    bone . next    ,    j +  +  )     {", "String   nodeId    =    bone . getString (  \" node \"  ,    null )  ;", "if    ( nodeId    =  =    null )", "throw   new   GdxRuntimeException (  \" Bone   node   ID   missing \"  )  ;", "Matrix 4    transform    =    new   Matrix 4  (  )  ;", "JsonValue   val    =    bone . get (  \" translation \"  )  ;", "if    (  ( val    !  =    null )     &  &     (  ( val . size )     >  =     3  )  )", "transform . translate ( val . getFloat (  0  )  ,    val . getFloat (  1  )  ,    val . getFloat (  2  )  )  ;", "val    =    bone . get (  \" rotation \"  )  ;", "if    (  ( val    !  =    null )     &  &     (  ( val . size )     >  =     4  )  )", "transform . rotate ( tempQ . set ( val . getFloat (  0  )  ,    val . getFloat (  1  )  ,    val . getFloat (  2  )  ,    val . getFloat (  3  )  )  )  ;", "val    =    bone . get (  \" scale \"  )  ;", "if    (  ( val    !  =    null )     &  &     (  ( val . size )     >  =     3  )  )", "transform . scale ( val . getFloat (  0  )  ,    val . getFloat (  1  )  ,    val . getFloat (  2  )  )  ;", "nodePart . bones . put ( nodeId ,    transform )  ;", "}", "}", "jsonNode . parts [ i ]     =    nodePart ;", "}", "}", "JsonValue   children    =    json . get (  \" children \"  )  ;", "if    ( children    !  =    null )     {", "jsonNode . children    =    new   ModelNode [ children . size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   child    =    children . child ;    child    !  =    null ;    child    =    child . next    ,    i +  +  )     {", "jsonNode . children [ i ]     =    parseNodesRecursively ( child )  ;", "}", "}", "return   jsonNode ;", "}", "METHOD_END"], "methodName": ["parseNodesRecursively"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( value . equalsIgnoreCase (  \" AMBIENT \"  )  )", "return   Texture . USAGE _ AMBIENT ;", "else", "if    ( value . equalsIgnoreCase (  \" BUMP \"  )  )", "return   Texture . USAGE _ BUMP ;", "else", "if    ( value . equalsIgnoreCase (  \" DIFFUSE \"  )  )", "return   Texture . USAGE _ DIFFUSE ;", "else", "if    ( value . equalsIgnoreCase (  \" EMISSIVE \"  )  )", "return   Texture . USAGE _ EMISSIVE ;", "else", "if    ( value . equalsIgnoreCase (  \" NONE \"  )  )", "return   Texture . USAGE _ NONE ;", "else", "if    ( value . equalsIgnoreCase (  \" NORMAL \"  )  )", "return   Texture . USAGE _ NORMAL ;", "else", "if    ( value . equalsIgnoreCase (  \" REFLECTION \"  )  )", "return   Texture . USAGE _ REFLECTION ;", "else", "if    ( value . equalsIgnoreCase (  \" SHININESS \"  )  )", "return   Texture . USAGE _ SHININESS ;", "else", "if    ( value . equalsIgnoreCase (  \" SPECULAR \"  )  )", "return   Texture . USAGE _ SPECULAR ;", "else", "if    ( value . equalsIgnoreCase (  \" TRANSPARENCY \"  )  )", "return   Texture . USAGE _ TRANSPARENCY ;", "return   Texture . USAGE _ UNKNOWN ;", "}", "METHOD_END"], "methodName": ["parseTextureUsage"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( type . equals (  \" TRIANGLES \"  )  )     {", "return   GL 2  0  . GL _ TRIANGLES ;", "} else", "if    ( type . equals (  \" LINES \"  )  )     {", "return   GL 2  0  . GL _ LINES ;", "} else", "if    ( type . equals (  \" POINTS \"  )  )     {", "return   GL 2  0  . GL _ POINTS ;", "} else", "if    ( type . equals (  \" TRIANGLE _ STRIP \"  )  )     {", "return   GL 2  0  . GL _ TRIANGLE _ STRIP ;", "} else", "if    ( type . equals (  \" LINE _ STRIP \"  )  )     {", "return   GL 2  0  . GL _ LINE _ STRIP ;", "} else    {", "throw   new   utils . GdxRuntimeException (  (  (  \" Unknown   primitive   type    '  \"     +    type )     +     \"  '  ,    should   be   one   of   triangle ,    trianglestrip ,    line ,    linestrip ,    lineloop   or   point \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseType"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( vectorArray    =  =    null )", "return   new   math . Vector 2  ( x ,    y )  ;", "else", "if    (  ( vectorArray . size )     =  =     2  )", "return   new   math . Vector 2  ( vectorArray . getFloat (  0  )  ,    vectorArray . getFloat (  1  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  \" Expected   Vector 2    values    <  >    than   two .  \"  )  ;", "}", "METHOD_END"], "methodName": ["readVector2"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader"}, {"methodBody": ["METHOD_START", "{", "for    ( final   ModelMaterial   m    :    materials )", "if    ( m . id . equals ( name )  )", "return   m ;", "ModelMaterial   mat    =    new   ModelMaterial (  )  ;", "mat . id    =    name ;", "mat . diffuse    =    new   Color ( Color . WHITE )  ;", "materials . add ( mat )  ;", "return   mat ;", "}", "METHOD_END"], "methodName": ["getMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.MtlLoader"}, {"methodBody": ["METHOD_START", "{", "String   line ;", "String [  ]    tokens ;", "String   curMatName    =     \" default \"  ;", "Color   difcolor    =    Color . WHITE ;", "Color   speccolor    =    Color . WHITE ;", "float   opacity    =     1  .  0 F ;", "float   shininess    =     0  .  0 F ;", "String   texFilename    =    null ;", "if    (  ( file    =  =    null )     |  |     (  ( file . exists (  )  )     =  =    false )  )", "return ;", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( file . read (  )  )  ,     4  0  9  6  )  ;", "try    {", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "if    (  (  ( line . length (  )  )     >     0  )     &  &     (  ( line . charAt (  0  )  )     =  =     '  \\ t '  )  )", "line    =    line . substring (  1  )  . trim (  )  ;", "tokens    =    line . split (  \"  \\  \\ s +  \"  )  ;", "if    (  ( tokens [  0  ]  . length (  )  )     =  =     0  )     {", "continue ;", "} else", "if    (  ( tokens [  0  ]  . charAt (  0  )  )     =  =     '  #  '  )", "continue ;", "else    {", "final   String   key    =    tokens [  0  ]  . toLowerCase (  )  ;", "if    ( key . equals (  \" newmtl \"  )  )     {", "ModelMaterial   mat    =    new   ModelMaterial (  )  ;", "mat . id    =    curMatName ;", "mat . diffuse    =    new   Color ( difcolor )  ;", "mat . specular    =    new   Color ( speccolor )  ;", "mat . opacity    =    opacity ;", "mat . shininess    =    shininess ;", "if    ( texFilename    !  =    null )     {", "ModelTexture   tex    =    new   ModelTexture (  )  ;", "tex . usage    =    ModelTexture . USAGE _ DIFFUSE ;", "tex . fileName    =    new   String ( texFilename )  ;", "if    (  ( mat . textures )     =  =    null )", "mat . textures    =    new   utils . Array < ModelTexture >  (  1  )  ;", "mat . textures . add ( tex )  ;", "}", "materials . add ( mat )  ;", "if    (  ( tokens . length )     >     1  )     {", "curMatName    =    tokens [  1  ]  ;", "curMatName    =    curMatName . replace (  '  .  '  ,     '  _  '  )  ;", "} else", "curMatName    =     \" default \"  ;", "difcolor    =    Color . WHITE ;", "speccolor    =    Color . WHITE ;", "opacity    =     1  .  0 F ;", "shininess    =     0  .  0 F ;", "} else", "if    (  ( key . equals (  \" kd \"  )  )     |  |     ( key . equals (  \" ks \"  )  )  )     {", "float   r    =    Float . parseFloat ( tokens [  1  ]  )  ;", "float   g    =    Float . parseFloat ( tokens [  2  ]  )  ;", "float   b    =    Float . parseFloat ( tokens [  3  ]  )  ;", "float   a    =     1  ;", "if    (  ( tokens . length )     >     4  )", "a    =    Float . parseFloat ( tokens [  4  ]  )  ;", "if    ( tokens [  0  ]  . toLowerCase (  )  . equals (  \" kd \"  )  )     {", "difcolor    =    new   Color (  )  ;", "difcolor . set ( r ,    g ,    b ,    a )  ;", "} else    {", "speccolor    =    new   Color (  )  ;", "speccolor . set ( r ,    g ,    b ,    a )  ;", "}", "} else", "if    (  ( key . equals (  \" tr \"  )  )     |  |     ( key . equals (  \" d \"  )  )  )     {", "opacity    =    Float . parseFloat ( tokens [  1  ]  )  ;", "} else", "if    ( key . equals (  \" ns \"  )  )     {", "shininess    =    Float . parseFloat ( tokens [  1  ]  )  ;", "} else", "if    ( key . equals (  \" map _ kd \"  )  )     {", "texFilename    =    file . parent (  )  . child ( tokens [  1  ]  )  . path (  )  ;", "}", "}", "}", "reader . close (  )  ;", "}    catch    ( IOException   e )     {", "return ;", "}", "ModelMaterial   mat    =    new   ModelMaterial (  )  ;", "mat . id    =    curMatName ;", "mat . diffuse    =    new   Color ( difcolor )  ;", "mat . specular    =    new   Color ( speccolor )  ;", "mat . opacity    =    opacity ;", "mat . shininess    =    shininess ;", "if    ( texFilename    !  =    null )     {", "ModelTexture   tex    =    new   ModelTexture (  )  ;", "tex . usage    =    ModelTexture . USAGE _ DIFFUSE ;", "tex . fileName    =    new   String ( texFilename )  ;", "if    (  ( mat . textures )     =  =    null )", "mat . textures    =    new   utils . Array < ModelTexture >  (  1  )  ;", "mat . textures . add ( tex )  ;", "}", "materials . add ( mat )  ;", "return ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.MtlLoader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    =  =    null )     |  |     (  ( index . length (  )  )     =  =     0  )  )", "return    0  ;", "final   int   idx    =    IntegparseInt ( index )  ;", "if    ( idx    <     0  )", "return   size    +    idx ;", "else", "return   idx    -     1  ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.ObjLoader"}, {"methodBody": ["METHOD_START", "{", "return   loadModel ( fileHandle ,    new   ObjLoader . ObjLoaderParameters ( flipV )  )  ;", "}", "METHOD_END"], "methodName": ["loadModel"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.ObjLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjLoader . logWarning )", "Gdx . app . error (  \" ObjLoader \"  ,     \" Wavefront    ( OBJ )    is   not   fully   supported ,    consult   the   documentation   for   more   information \"  )  ;", "String   line ;", "String [  ]    tokens ;", "char   firstChar ;", "MtlLoader   mtl    =    new   MtlLoader (  )  ;", "ObjLoader . Group   activeGroup    =    new   ObjLoader . Group (  \" default \"  )  ;", "groups . add ( activeGroup )  ;", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( file . read (  )  )  ,     4  0  9  6  )  ;", "int   id    =     0  ;", "try    {", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "tokens    =    line . split (  \"  \\  \\ s +  \"  )  ;", "if    (  ( tokens . length )     <     1  )", "break ;", "if    (  ( tokens [  0  ]  . length (  )  )     =  =     0  )     {", "continue ;", "} else", "if    (  ( firstChar    =    tokens [  0  ]  . toLowerCase (  )  . charAt (  0  )  )     =  =     '  #  '  )     {", "continue ;", "} else", "if    ( firstChar    =  =     ' v '  )     {", "if    (  ( tokens [  0  ]  . length (  )  )     =  =     1  )     {", "verts . add ( Float . parseFloat ( tokens [  1  ]  )  )  ;", "verts . add ( Float . parseFloat ( tokens [  2  ]  )  )  ;", "verts . add ( Float . parseFloat ( tokens [  3  ]  )  )  ;", "} else", "if    (  ( tokens [  0  ]  . charAt (  1  )  )     =  =     ' n '  )     {", "norms . add ( Float . parseFloat ( tokens [  1  ]  )  )  ;", "norms . add ( Float . parseFloat ( tokens [  2  ]  )  )  ;", "norms . add ( Float . parseFloat ( tokens [  3  ]  )  )  ;", "} else", "if    (  ( tokens [  0  ]  . charAt (  1  )  )     =  =     ' t '  )     {", "uvs . add ( Float . parseFloat ( tokens [  1  ]  )  )  ;", "uvs . add (  ( flipV    ?     1     -     ( Float . parseFloat ( tokens [  2  ]  )  )     :    Float . parseFloat ( tokens [  2  ]  )  )  )  ;", "}", "} else", "if    ( firstChar    =  =     ' f '  )     {", "String [  ]    parts ;", "Array < Integer >    faces    =    activeGroup . faces ;", "for    ( int   i    =     1  ;    i    <     (  ( tokens . length )     -     2  )  ;    i -  -  )     {", "parts    =    tokens [  1  ]  . split (  \"  /  \"  )  ;", "faces . add ( getIndex ( parts [  0  ]  ,    verts . size )  )  ;", "if    (  ( parts . length )     >     2  )     {", "if    ( i    =  =     1  )", "activeGroup . hasNorms    =    true ;", "faces . add ( getIndex ( parts [  2  ]  ,    norms . size )  )  ;", "}", "if    (  (  ( parts . length )     >     1  )     &  &     (  ( parts [  1  ]  . length (  )  )     >     0  )  )     {", "if    ( i    =  =     1  )", "activeGroup . hasUVs    =    true ;", "faces . add ( getIndex ( parts [  1  ]  ,    uvs . size )  )  ;", "}", "parts    =    tokens [  (  +  + i )  ]  . split (  \"  /  \"  )  ;", "faces . add ( getIndex ( parts [  0  ]  ,    verts . size )  )  ;", "if    (  ( parts . length )     >     2  )", "faces . add ( getIndex ( parts [  2  ]  ,    norms . size )  )  ;", "if    (  (  ( parts . length )     >     1  )     &  &     (  ( parts [  1  ]  . length (  )  )     >     0  )  )", "faces . add ( getIndex ( parts [  1  ]  ,    uvs . size )  )  ;", "parts    =    tokens [  (  +  + i )  ]  . split (  \"  /  \"  )  ;", "faces . add ( getIndex ( parts [  0  ]  ,    verts . size )  )  ;", "if    (  ( parts . length )     >     2  )", "faces . add ( getIndex ( parts [  2  ]  ,    norms . size )  )  ;", "if    (  (  ( parts . length )     >     1  )     &  &     (  ( parts [  1  ]  . length (  )  )     >     0  )  )", "faces . add ( getIndex ( parts [  1  ]  ,    uvs . size )  )  ;", "( activeGroup . numFaces )  +  +  ;", "}", "} else", "if    (  ( firstChar    =  =     ' o '  )     |  |     ( firstChar    =  =     ' g '  )  )     {", "if    (  ( tokens . length )     >     1  )", "activeGroup    =    setActiveGroup ( tokens [  1  ]  )  ;", "else", "activeGroup    =    setActiveGroup (  \" default \"  )  ;", "} else", "if    ( tokens [  0  ]  . equals (  \" mtllib \"  )  )     {", "mtl . load ( file . parent (  )  . child ( tokens [  1  ]  )  )  ;", "} else", "if    ( tokens [  0  ]  . equals (  \" usemtl \"  )  )     {", "if    (  ( tokens . length )     =  =     1  )", "activeGroup . materialName    =     \" default \"  ;", "else", "activeGroup . materialName    =    tokens [  1  ]  . replace (  '  .  '  ,     '  _  '  )  ;", "}", "}", "reader . close (  )  ;", "}    catch    ( IOException   e )     {", "return   null ;", "}", "for    ( int   i    =     0  ;    i    <     ( groups . size )  ;    i +  +  )     {", "if    (  ( groups . get ( i )  . numFaces )     <     1  )     {", "groups . removeIndex ( i )  ;", "i -  -  ;", "}", "}", "if    (  ( groups . size )     <     1  )", "return   null ;", "final   int   numGroups    =    groups . size ;", "final   ModelData   data    =    new   ModelData (  )  ;", "for    ( int   g    =     0  ;    g    <    numGroups ;    g +  +  )     {", "ObjLoader . Group   group    =    groups . get ( g )  ;", "Array < Integer >    faces    =    group . faces ;", "final   int   numElements    =    faces . size ;", "final   int   numFaces    =    group . numFaces ;", "final   boolean   hasNorms    =    group . hasNorms ;", "final   boolean   hasUVs    =    group . hasUVs ;", "final   float [  ]    finalVerts    =    new   float [  ( numFaces    *     3  )     *     (  (  3     +     ( hasNorms    ?     3     :     0  )  )     +     ( hasUVs    ?     2     :     0  )  )  ]  ;", "for    ( int   i    =     0  ,    vi    =     0  ;    i    <    numElements ;  )     {", "int   vertIndex    =     ( faces . get (  ( i +  +  )  )  )     *     3  ;", "finalVerts [  ( vi +  +  )  ]     =    verts . get (  ( vertIndex +  +  )  )  ;", "finalVerts [  ( vi +  +  )  ]     =    verts . get (  ( vertIndex +  +  )  )  ;", "finalVerts [  ( vi +  +  )  ]     =    verts . get ( vertIndex )  ;", "if    ( hasNorms )     {", "int   normIndex    =     ( faces . get (  ( i +  +  )  )  )     *     3  ;", "finalVerts [  ( vi +  +  )  ]     =    norms . get (  ( normIndex +  +  )  )  ;", "finalVerts [  ( vi +  +  )  ]     =    norms . get (  ( normIndex +  +  )  )  ;", "finalVerts [  ( vi +  +  )  ]     =    norms . get ( normIndex )  ;", "}", "if    ( hasUVs )     {", "int   uvIndex    =     ( faces . get (  ( i +  +  )  )  )     *     2  ;", "finalVerts [  ( vi +  +  )  ]     =    uvs . get (  ( uvIndex +  +  )  )  ;", "finalVerts [  ( vi +  +  )  ]     =    uvs . get ( uvIndex )  ;", "}", "}", "final   int   numIndices    =     (  ( numFaces    *     3  )     >  =     ( Short . MAX _ VALUE )  )     ?     0     :    numFaces    *     3  ;", "final   short [  ]    finalIndices    =    new   short [ numIndices ]  ;", "if    ( numIndices    >     0  )     {", "for    ( int   i    =     0  ;    i    <    numIndices ;    i +  +  )     {", "finalIndices [ i ]     =     (  ( short )     ( i )  )  ;", "}", "}", "Array < VertexAttribute >    attributes    =    new   Array < VertexAttribute >  (  )  ;", "attributes . add ( new   VertexAttribute ( VertexAttributes . Usage . Position ,     3  ,    ShaderProgram . POSITION _ ATTRIBUTE )  )  ;", "if    ( hasNorms )", "attributes . add ( new   VertexAttribute ( VertexAttributes . Usage . Normal ,     3  ,    ShaderProgram . NORMAL _ ATTRIBUTE )  )  ;", "if    ( hasUVs )", "attributes . add ( new   VertexAttribute ( VertexAttributes . Usage . TextureCoordinates ,     2  ,     (  ( ShaderProgram . TEXCOORD _ ATTRIBUTE )     +     \"  0  \"  )  )  )  ;", "String   stringId    =    Integer . toString (  (  +  + id )  )  ;", "String   nodeId    =     (  \" default \"  . equals ( group . name )  )     ?     \" node \"     +    stringId    :    group . name ;", "String   meshId    =     (  \" default \"  . equals ( group . name )  )     ?     \" mesh \"     +    stringId    :    group . name ;", "String   partId    =     (  \" default \"  . equals ( group . name )  )     ?     \" part \"     +    stringId    :    group . name ;", "ModelNode   node    =    new   ModelNode (  )  ;", "node . id    =    nodeId ;", "node . meshId    =    meshId ;", "node . scale    =    new   Vector 3  (  1  ,     1  ,     1  )  ;", "node . translation    =    new   Vector 3  (  )  ;", "node . rotation    =    new   Quaternion (  )  ;", "ModelNodePart   pm    =    new   ModelNodePart (  )  ;", "pm . meshPartId    =    partId ;", "pm . materialId    =    group . materialName ;", "node . parts    =    new   ModelNodePart [  ]  {    pm    }  ;", "ModelMeshPart   part    =    new   ModelMeshPart (  )  ;", "part . id    =    partId ;", "part . indices    =    finalIndices ;", "part . primitiveType    =    GL 2  0  . GL _ TRIANGLES ;", "ModelMesh   mesh    =    new   ModelMesh (  )  ;", "mesh . id    =    meshId ;", "mesh . attributes    =    attributes . toArray ( VertexAttribute . class )  ;", "mesh . vertices    =    finalVerts ;", "mesh . parts    =    new   ModelMeshPart [  ]  {    part    }  ;", "data . nodes . add ( node )  ;", "data . meshes . add ( mesh )  ;", "ModelMaterial   mm    =    mtl . getMaterial ( group . materialName )  ;", "data . materials . add ( mm )  ;", "}", "if    (  ( verts . size )     >     0  )", "verts . clear (  )  ;", "if    (  ( norms . size )     >     0  )", "norms . clear (  )  ;", "if    (  ( uvs . size )     >     0  )", "uvs . clear (  )  ;", "if    (  ( groups . size )     >     0  )", "groups . clear (  )  ;", "return   data ;", "}", "METHOD_END"], "methodName": ["loadModelData"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.ObjLoader"}, {"methodBody": ["METHOD_START", "{", "for    ( ObjLoader . Group   group    :    groups )     {", "if    ( group . name . equals ( name )  )", "return   group ;", "}", "ObjLoader . Group   group    =    new   ObjLoader . Group ( name )  ;", "groups . add ( group )  ;", "return   group ;", "}", "METHOD_END"], "methodName": ["setActiveGroup"], "fileName": "com.badlogic.gdx.graphics.g3d.loader.ObjLoader"}, {"methodBody": ["METHOD_START", "{", "return    ( other    =  =     ( this )  )     |  |     (  (  (  (  ( other    !  =    null )     &  &     (  ( other . mesh )     =  =     ( mesh )  )  )     &  &     (  ( other . primitiveType )     =  =     ( primitiveType )  )  )     &  &     (  ( other . offset )     =  =     ( offset )  )  )     &  &     (  ( other . size )     =  =     ( size )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.g3d.model.MeshPart"}, {"methodBody": ["METHOD_START", "{", "mesh . render ( shader ,    primitiveType ,    offset ,    size )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.model.MeshPart"}, {"methodBody": ["METHOD_START", "{", "mesh . render ( shader ,    primitiveType ,    offset ,    size ,    autoBind )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.model.MeshPart"}, {"methodBody": ["METHOD_START", "{", "this . id    =    other . id ;", "this . m    =    other . m ;", "this . offset    =    other . offset ;", "this . size    =    other . size ;", "this . primitiveType    =    other . primitiveType ;", "this . center . set ( other . center )  ;", "this . halfExtents . set ( other . halfExtents )  ;", "this . radius    =    other . radius ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.model.MeshPart"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "this . m    =    m ;", "this . offset    =    offset ;", "this . size    =    size ;", "this . primitiveType    =    type ;", "this . center . set (  0  ,     0  ,     0  )  ;", "this . halfExtents . set (  0  ,     0  ,     0  )  ;", "this . radius    =     -  1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.model.MeshPart"}, {"methodBody": ["METHOD_START", "{", "mesh . calculateBoundingBox ( MeshPart . bounds ,    offset ,    size )  ;", "MeshPart . bounds . getCenter ( center )  ;", "MeshPart . bounds . getDimensions ( halfExtents )  . scl (  0  .  5 F )  ;", "radius    =    halfExtents . len (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.model.MeshPart"}, {"methodBody": ["METHOD_START", "{", "return   insertChild (  (  -  1  )  ,    child )  ;", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   insertChildren (  (  -  1  )  ,    nodes )  ;", "}", "METHOD_END"], "methodName": ["addChildren"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "parent . addChild ( this )  ;", "}", "METHOD_END"], "methodName": ["attachTo"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "for    ( final   NodePart   part    :    parts )     {", "if    (  (  (  ( part . invBoneBindTransforms )     =  =    null )     |  |     (  ( part . bones )     =  =    null )  )     |  |     (  ( part . invBoneBindTransforms . size )     !  =     ( part . bones . length )  )  )", "continue ;", "final   int   n    =    part . invBoneBindTransforms . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "part . bones [ i ]  . set ( part . invBoneBindTransforms . keys [ i ]  . globalTransform )  . mul ( part . invBoneBindTransforms . values [ i ]  )  ;", "}", "if    ( recursive )     {", "for    ( Node   child    :    children )     {", "child . calculateBoneTransforms ( true )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["calculateBoneTransforms"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "out . inf (  )  ;", "return   extendBoundingBox ( out )  ;", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "out . inf (  )  ;", "return   extendBoundingBox ( out ,    tnsform )  ;", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isAnited )  )", "localTransforset ( translation ,    rotation ,    scale )  ;", "return   localTransfor", "}", "METHOD_END"], "methodName": ["calculateLocalTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "calculateLocalTransform (  )  ;", "calculateWorldTransform (  )  ;", "if    ( recursive )     {", "for    (    child    :    children )     {", "child . calculateTransforms ( true )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["calculateTransforms"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "if    (  ( inheritTransform )     &  &     (  ( parent )     !  =    null )  )", "globalTransform . set ( parent . globalTransform )  . mul ( localTransform )  ;", "else", "globalTransform . set ( localTransform )  ;", "return   globalTransform ;", "}", "METHOD_END"], "methodName": ["calculateWorldTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   new   Node (  )  . set ( this )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     !  =    null )     {", "parent . reveChild ( this )  ;", "parent    =    null ;", "}", "}", "METHOD_END"], "methodName": ["detach"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   extendBoundingBox ( out ,    true )  ;", "}", "METHOD_END"], "methodName": ["extendBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "final   int   partCount    =    parts . size ;", "for    ( int   i    =     0  ;    i    <    partCount ;    i +  +  )     {", "final   Part   part    =    parts . get ( i )  ;", "if    ( part . enabled )     {", "final   MeshPart   meshPart    =    part . meshPart ;", "if    ( transform )", "meshPart . mesh . extendBoundingBox ( out ,    meshPart . offset ,    meshPart . size ,    globalTransform )  ;", "else", "meshPart . mesh . extendBoundingBox ( out ,    meshPart . offset ,    meshPart . size )  ;", "}", "}", "final   int   childCount    =    children . size ;", "for    ( int   i    =     0  ;    i    <    childCount ;    i +  +  )", "children . get ( i )  . extendBoundingBox ( out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["extendBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   children . get ( index )  ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   Node . getNode ( children ,    id ,    recursive ,    ignoreCase )  ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   children . size ;", "}", "METHOD_END"], "methodName": ["getChildCount"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    nodes . size ;", "node ;", "if    ( ignoreCase )     {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( node    =    nodes . get ( i )  )  . id . equalsIgnoreCase ( id )  )", "return   node ;", "} else    {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( node    =    nodes . get ( i )  )  . id . equals ( id )  )", "return   node ;", "}", "if    ( recursive )     {", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( node    =     . get ( nodes . get ( i )  . children ,    id ,    true ,    ignoreCase )  )     !  =    null )", "return   node ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return    (  ( children )     !  =    null )     &  &     (  ( children . size )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["hasChildren"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return    ( parent )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasParent"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   p    =    this ;    p    !  =    null ;    p    =    p . getParent (  )  )     {", "if    ( p    =  =    child )", "throw   new   utils . GdxRuntimeException (  \" Cannot   add   a   parent   as   a   child \"  )  ;", "}", "Node   p    =    child . getParent (  )  ;", "if    (  ( p    !  =    null )     &  &     (  !  ( p . removeChild ( child )  )  )  )", "throw   new   utils . GdxRuntimeException (  \" Could   not   remove   child   from   its   current   parent \"  )  ;", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( children . size )  )  )     {", "index    =    children . size ;", "children . add ( child )  ;", "} else", "children . insert ( index ,    child )  ;", "child . parent    =    this ;", "return   index ;", "}", "METHOD_END"], "methodName": ["insertChild"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >     ( children . size )  )  )", "index    =    children . size ;", "int   i    =    index ;", "for    ( T   child    :    ns )", "insertChild (  ( i +  +  )  ,    child )  ;", "return   index ;", "}", "METHOD_END"], "methodName": ["insertChildren"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( children . removeValue ( child ,    true )  )  )", "return   false ;", "child . parent    =    null ;", "return   true ;", "}", "METHOD_END"], "methodName": ["removeChild"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "detach (  )  ;", "id    =    other . id ;", "isAnimated    =    other . isAnimated ;", "inheritTransform    =    other . inheritTransform ;", "translation . set ( other . translation )  ;", "rotation . set ( other . rotation )  ;", "scale . set ( other . scale )  ;", "localTransform . set ( other . localTransform )  ;", "globalTransform . set ( other . globalTransform )  ;", "parts . clear (  )  ;", "for    ( Part   nodePart    :    other . parts )     {", "parts . add ( nodePart . copy (  )  )  ;", "}", "children . clear (  )  ;", "for    (    child    :    other . getChildren (  )  )     {", "addChild ( child . copy (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.model.Node"}, {"methodBody": ["METHOD_START", "{", "return   new   NodePart (  )  . set ( this )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.g3d.model.NodePart"}, {"methodBody": ["METHOD_START", "{", "meshPart    =    new   MeshPart ( other . meshPart )  ;", "material    =    other . material ;", "enabled    =    other . enabled ;", "if    (  ( other . invBoneBindTransforms )     =  =    null )     {", "invBoneBindTransforms    =    null ;", "bones    =    null ;", "} else    {", "if    (  ( invBoneBindTransforms )     =  =    null )", "invBoneBindTransforms    =    new   ArrayMap < Node ,    Matrix 4  >  ( true ,    other . invBoneBindTransforms . size ,    Node . class ,    Matrix 4  . class )  ;", "else", "invBoneBindTransforms . clear (  )  ;", "invBoneBindTransforms . putAll ( other . invBoneBindTransforms )  ;", "if    (  (  ( bones )     =  =    null )     |  |     (  ( bones . length )     !  =     ( invBoneBindTransforms . size )  )  )", "bones    =    new   Matrix 4  [ invBoneBindTransforms . size ]  ;", "for    ( int   i    =     0  ;    i    <     ( bones . length )  ;    i +  +  )     {", "if    (  ( bones [ i ]  )     =  =    null )", "bones [ i ]     =    new   Matrix 4  (  )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.model.NodePart"}, {"methodBody": ["METHOD_START", "{", "out . material    =    material ;", "out . mesh . set ( mesh )  ;", "out . bones    =    bones ;", "return   out ;", "}", "METHOD_END"], "methodName": ["setRenderable"], "fileName": "com.badlogic.gdx.graphics.g3d.model.NodePart"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelMesh   other    :    meshes )     {", "if    ( other . id . equals ( mesh . id )  )     {", "throw   new   GdxRuntimeException (  (  (  \" Mesh   with   id    '  \"     +     ( other . id )  )     +     \"  '    already   in   model \"  )  )  ;", "}", "}", "meshes . add ( mesh )  ;", "}", "METHOD_END"], "methodName": ["addMesh"], "fileName": "com.badlogic.gdx.graphics.g3d.model.data.ModelData"}, {"methodBody": ["METHOD_START", "{", "return   addChannel ( channelDescriptor ,    null )  ;", "}", "METHOD_END"], "methodName": ["addChannel"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "T   channel    =    getChannel ( channelDescriptor )  ;", "if    ( channel    =  =    null )     {", "channel    =    allocateChannel ( channelDescriptor )  ;", "if    ( initializer    !  =    null )", "initializer . init ( channel )  ;", "as . add ( channel )  ;", "}", "return   channel ;", "}", "METHOD_END"], "methodName": ["addChannel"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     ( capacity )  )", "throw   new   utils . GdxRuntimeException (  \" Capacity   reached ,    cannot   add   other   elements \"  )  ;", "int   k    =     0  ;", "for    ( ParallelArray . Channel   strideArray    :    arrays )     {", "strideArray . add ( k ,    values )  ;", "k    +  =    strideArray . strideSize ;", "}", "+  +  ( size )  ;", "}", "METHOD_END"], "methodName": ["addElement"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( channelDescriptor . type )     =  =     ( float . class )  )     {", "return    (  ( T )     ( new    . FloatChannel ( channelDescriptor . id ,    channelDescriptor . count ,    capacity )  )  )  ;", "} else", "if    (  ( channelDescriptor . type )     =  =     ( int . class )  )     {", "return    (  ( T )     ( new    . IntChannel ( channelDescriptor . id ,    channelDescriptor . count ,    capacity )  )  )  ;", "} else    {", "return    (  ( T )     ( new    . ObjectChannel ( channelDescriptor . id ,    channelDescriptor . count ,    capacity ,    channelDescriptor . type )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["allocateChannel"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "arrays . clear (  )  ;", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( arrays . size )  ;     +  + i )     {", ". Channel   array    =    arrays . items [ i ]  ;", "if    (  ( array . id )     =  =    id )", "return   i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findIndex"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "for    ( ParallelArray . Channel   array    :    arrays )     {", "if    (  ( array . id )     =  =     ( descriptor . id )  )", "return    (  ( T )     ( array )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getChannel"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "arrays . removeIndex ( findIndex ( id )  )  ;", "}", "METHOD_END"], "methodName": ["removeArray"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "int   last    =     ( size )     -     1  ;", "for    (  . Channel   strideArray    :    arrays )     {", "strideArray . swap ( index ,    last )  ;", "}", "size    =    last ;", "}", "METHOD_END"], "methodName": ["removeElement"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     !  =    requiredCapacity )     {", "for    (  . Channel   channel    :    arrays )     {", "channel . setCapacity ( requiredCapacity )  ;", "}", "capacity    =    requiredCapacity ;", "}", "}", "METHOD_END"], "methodName": ["setCapacity"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParallelArray"}, {"methodBody": ["METHOD_START", "{", "return    ( ParticleChannels . currentGlobalId )  +  +  ;", "}", "METHOD_END"], "methodName": ["newGlobalId"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleChannels"}, {"methodBody": ["METHOD_START", "{", "return    ( currentId )  +  +  ;", "}", "METHOD_END"], "methodName": ["newId"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleChannels"}, {"methodBody": ["METHOD_START", "{", "currentId    =    ParticleChannels . currentGlobalId ;", "}", "METHOD_END"], "methodName": ["resetIds"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleChannels"}, {"methodBody": ["METHOD_START", "{", "emitter . activateParticles ( startIndex ,    count )  ;", "for    ( Influencer   influencer    :    influencers )", "influencer . activateParticles ( startIndex ,    count )  ;", "}", "METHOD_END"], "methodName": ["activateParticles"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "particles    =    new   ParallelArray ( maxParticleCount )  ;", "emitter . allocateChannels (  )  ;", "for    ( Influencer   influencer    :    influencers )", "influencer . allocateChannels (  )  ;", "renderer . allocateChannels (  )  ;", "}", "METHOD_END"], "methodName": ["allocateChannels"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "emitter . set ( this )  ;", "for    ( Influencer   influencer    :    influencers )", "influencer . set ( this )  ;", "renderer . set ( this )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "boundingBox . clr (  )  ;", "ParallelArray . FloatChannel   positionChannel    =    getChannel ( ParticleChannels . Position )  ;", "for    ( int   pos    =     0  ,    c    =     ( positionChannel . strideSize )     *     ( size )  ;    pos    <    c ;    pos    +  =    positionChannel . strideSize )     {", "boundingBox . ext ( positionChannel . data [  ( pos    +     ( ParticleChannels . XOffset )  )  ]  ,    positionChannel . data [  ( pos    +     ( ParticleChannels . YOffset )  )  ]  ,    positionChannel . data [  ( pos    +     ( ParticleChannels . ZOffset )  )  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "Emitter   emitter    =     (  ( Emitter )     ( this . emitter . copy (  )  )  )  ;", "Influencer [  ]    influencers    =    new   Influencer [ this . influencers . size ]  ;", "int   i    =     0  ;", "for    ( Influencer   influencer    :    this . influencers )     {", "influencers [  ( i +  +  )  ]     =     (  ( Influencer )     ( influencer . copy (  )  )  )  ;", "}", "return   new    ( new   String ( this . name )  ,    emitter ,     (  ( Renderer <  ?  ,     ?  >  )     ( renderer . copy (  )  )  )  ,    influencers )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "emitter . dispose (  )  ;", "for    ( Influencer   influencer    :    influencers )", "influencer . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( particles . size )     >     0  )     {", "renderer . update (  )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "for    ( Influencer   influencer    :    influencers )", "influencer . end (  )  ;", "emitter . end (  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( influencers . size )  ;     +  + i )     {", "Influencer   influencer    =    influenceret ( i )  ;", "if    ( ClassReflection . isAsnableFrom ( type ,    influencer . getClass (  )  )  )     {", "return   i ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findIndex"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "int   index    =    findIndex ( influencerClass )  ;", "return   index    >     (  -  1  )     ?     (  ( K )     ( influenceret ( index )  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["findInfluencer"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( boundingBox )     =  =    null )", "boundingBox    =    new   math . collision . BoundingBox (  )  ;", "calculateBoundingBox (  )  ;", "return   boundingBox ;", "}", "METHOD_END"], "methodName": ["getBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "transform . set ( this . transform )  ;", "}", "METHOD_END"], "methodName": ["getTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "bind (  )  ;", "if    (  ( particles )     !  =    null )     {", "end (  )  ;", "particleChannels . resetIds (  )  ;", "}", "allocateChannels ( emitter . maxunt )  ;", "emitter . init (  )  ;", "for    ( Influencer   influencer    :    influencers )", "influencer . init (  )  ;", "renderer . init (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "return   emitter . isComplete (  )  ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "emitter . killParticles ( startIndex ,    count )  ;", "for    ( Influencer   influencer    :    influencers )", "influencer . killParticles ( startIndex ,    count )  ;", "}", "METHOD_END"], "methodName": ["killParticles"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "this . transform . mul ( transform )  ;", "this . transform . getScale ( scale )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "int   index    =    findIndex ( type )  ;", "if    ( index    >     (  -  1  )  )", "influencers . removeIndex ( index )  ;", "}", "METHOD_END"], "methodName": ["removeInfluencer"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "int   index    =    findIndex ( type )  ;", "if    ( index    >     (  -  1  )  )     {", "influencers . insert ( index ,    newInfluencer )  ;", "influencers . removeIndex (  ( index    +     1  )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["replaceInfluencer"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "end (  )  ;", "st (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "this . transform . rotate ( rotation )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "this . transform . rotate ( axis ,    angle )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "scale ( scale . x ,    scale . y ,    scale . z )  ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "this . transform . scale ( scaleX ,    scaleY ,    scaleZ )  ;", "this . transform . getScale ( scale )  ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "deltaTime    =    timeStep ;", "deltaTimeSqr    =     ( deltaTime )     *     ( deltaTime )  ;", "}", "METHOD_END"], "methodName": ["setTimeStep"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "this . transform . set ( transform )  ;", "transform . getScale ( scale )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "transform . set ( x ,    y ,    z ,    qx ,    qy ,    qz ,    qw ,    scale ,    scale ,    scale )  ;", "this . scale . set ( scale ,    scale ,    scale )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "this . transform . setTranslation ( translation )  ;", "}", "METHOD_END"], "methodName": ["setTranslation"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "emitter . start (  )  ;", "for    ( Influencer   influencer    :    influencers )", "influencer . start (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "this . transform . translate ( translation )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "update ( Gdx . graphics . getDeltaTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "setTimeStep ( deltaTime )  ;", "emitt . update (  )  ;", "for    ( Influenc   influenc    :    influencs )", "influenc . update (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleController"}, {"methodBody": ["METHOD_START", "{", "controller    =    particleController ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   ParticleEffect ( this )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )     {", "controlleret ( i )  . dispose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . draw (  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . end (  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )     {", "Controller   emitter    =    controllers . get ( i )  ;", "if    ( emitter . name . equals ( name )  )", "return   emitter ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findController"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bounds )     =  =    null )", "bounds    =    new   BoundingBox (  )  ;", "BoundingBox   bounds    =    this . bounds ;", "bounds . inf (  )  ;", "for    ( Controller   emitter    :    controllers )", "bounds . ext ( emitter . getBoundingBox (  )  )  ;", "return   bounds ;", "}", "METHOD_END"], "methodName": ["getBoundingBox"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "return   controllers ;", "}", "METHOD_END"], "methodName": ["getControllers"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . init (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )     {", "if    (  !  ( controlleret ( i )  . isComplete (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "for    ( Controller   controller    :    controllers )     {", "controller . load ( assetManager ,    data )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . reset (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . rotate ( rotation )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . rotate ( axis ,    angle )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleController   controller    :    controllers )     {", "controller . save ( assetManager ,    data )  ;", "}", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . scale ( scale . x ,    scale . y ,    scale . z )  ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . scale ( scaleX ,    scaleY ,    scaleZ )  ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleController   controller    :    controllers )     {", "for    ( ParticleBatch <  ?  >    batch    :    batches )", "if    ( controller . renderer . setBatch ( batch )  )", "break ;", "}", "}", "METHOD_END"], "methodName": ["setBatch"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . setTransform ( transform )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . translate ( translation )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . update (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    controllers . size ;    i    <    n ;    i +  +  )", "controlleret ( i )  . update ( deltaTime )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffect"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   object    :    array )     {", "if    ( ClassReflection . isAssignableFrom ( type ,    object . getClass (  )  )  )", "return    (  ( T )     ( object )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader"}, {"methodBody": ["METHOD_START", "{", "ResourceData < ParticleEffect >    data    =    new   ResourceData < ParticleEffect >  ( effect )  ;", "effect . save ( parameter . manager ,    data )  ;", "if    (  ( parameter . batches )     !  =    null )     {", "for    ( ParticleBatch <  ?  >    batch    :    parameter . batches )     {", "boolean   save    =    false ;", "for    ( ParticleController   controller    :    effect . getControllers (  )  )     {", "if    ( controller . renderer . isCompatible ( batch )  )     {", "save    =    true ;", "break ;", "}", "}", "if    ( save )", "batch . save ( parameter . manager ,    data )  ;", "}", "}", "Json   json    =    new   Json (  )  ;", "json . toJson ( data ,    parameter . file )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentMaterial )     =  =     ( renderable . material )  )", "return ;", "int   cullFace    =     (  ( config . defaultCullFace )     =  =     (  -  1  )  )     ?    GL 2  0  . GL _ BACK    :    config . defaultCullFace ;", "int   depthFunc    =     (  ( config . defaultDepthFunc )     =  =     (  -  1  )  )     ?    GL 2  0  . GL _ LEQUAL    :    config . defaultDepthFunc ;", "float   depthRangeNear    =     0  .  0 F ;", "float   depthRangeFar    =     1  .  0 F ;", "boolean   depthMask    =    true ;", "currentMaterial    =    renderable . material ;", "for    ( final   Attribute   attr    :    currentMaterial )     {", "final   long   t    =    attr . type ;", "if    ( BlendingAttribute . is ( t )  )     {", "context . setBlending ( true ,     (  ( BlendingAttribute )     ( attr )  )  . sourceFunction ,     (  ( BlendingAttribute )     ( attr )  )  . destFunction )  ;", "} else", "if    (  ( t    &     ( attributes . DepthTestAttribute . Type )  )     =  =     ( attributes . DepthTestAttribute . Type )  )     {", "attributes . DepthTestAttribute   dta    =     (  ( attributes . DepthTestAttribute )     ( attr )  )  ;", "depthFunc    =    dta . depthFunc ;", "depthRangeNear    =    dta . depthRangeNear ;", "depthRangeFar    =    dta . depthRangeFar ;", "depthMask    =    dta . depthMask ;", "} else", "if    (  !  ( config . ignoreUnimplemented )  )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  \" Unknown   material   attribute :     \"     +     ( attr . toString (  )  )  )  )  ;", "}", "context . setCullFace ( cullFace )  ;", "context . setDepthTest ( depthFunc ,    depthRangeNear ,    depthRangeFar )  ;", "context . setDepthMask ( depthMask )  ;", "}", "METHOD_END"], "methodName": ["bindMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =     \"  \"  ;", "if    (  ( Gdx . app . getType (  )  )     =  =     ( Application . ApplicationType . Desktop )  )", "prefix    +  =     \"  # version    1  2  0  \\ n \"  ;", "else", "prefix    +  =     \"  # version    1  0  0  \\ n \"  ;", "if    (  ( config . type )     =  =     (  . ParticleType . Billboard )  )     {", "prefix    +  =     \"  # define   billboard \\ n \"  ;", "if    (  ( config . align )     =  =     (  . AlignMode . Screen )  )", "prefix    +  =     \"  # define   screenFacing \\ n \"  ;", "else", "if    (  ( config . align )     =  =     (  . AlignMode . ViewPoint )  )", "prefix    +  =     \"  # define   viewPointFacing \\ n \"  ;", "}", "return   prefix ;", "}", "METHOD_END"], "methodName": ["createPrefix"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "return   obj    =  =     ( this )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "return    ( config . defaultCullFace )     =  =     (  -  1  )     ?    GL 2  0  . GL _ BACK    :    config . defaultCullFace ;", "}", "METHOD_END"], "methodName": ["getDefaultCullFace"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "return    ( config . defaultDepthFunc )     =  =     (  -  1  )     ?    GL 2  0  . GL _ LEQUAL    :    config . defaultDepthFunc ;", "}", "METHOD_END"], "methodName": ["getDefaultDepthFunc"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ParticleShader . defaultFragmentShader )     =  =    null )", "ParticleShader . defaultFragmentShader    =    Gdx . files . classpath (  \" graphics / g 3 d / particles / particles . fragment . glsl \"  )  . readString (  )  ;", "return   ParticleShader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ParticleShader . defaultVertexShader )     =  =    null )", "ParticleShader . defaultVertexShader    =    Gdx . files . classpath (  \" graphics / g 3 d / particles / particles . vertex . glsl \"  )  . readString (  )  ;", "return   ParticleShader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "config . defaultCullFace    =    cullFace ;", "}", "METHOD_END"], "methodName": ["setDefaultCullFace"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "config . defaultDepthFunc    =    depthFunc ;", "}", "METHOD_END"], "methodName": ["setDefaultDepthFunc"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleShader"}, {"methodBody": ["METHOD_START", "{", "this . camera    =    camera ;", "}", "METHOD_END"], "methodName": ["setCamera"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSorter"}, {"methodBody": ["METHOD_START", "{", "effects . add ( effect )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "batches . add ( batch )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleBatch <  ?  >    batch    :    batches )", "batch . begin (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleEffect   effect    :    effects )     {", "effect . draw (  )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleBatch <  ?  >    batch    :    batches )", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ParticleSystem . instance )     =  =    null )", "ParticleSystem . instance    =    new   ParticleSystem (  )  ;", "return   ParticleSystem . instance ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   batches ;", "}", "METHOD_END"], "methodName": ["getBatches"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "effects . removeValue ( effect ,    true )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "effects . clear (  )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleEffect   effect    :    effects )     {", "effect . update (  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleEffect   effect    :    effects )     {", "effect . update ( deltaTime )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleEffect   effect    :    effects )     {", "effect . update (  )  ;", "effect . draw (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateAndDraw"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleEffect   effect    :    effects )     {", "effect . update ( deltaTime )  ;", "effect . draw (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateAndDraw"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "ResourceData . SaveData   saveData    =    new   ResourceData . SaveData ( this )  ;", "data . add ( saveData )  ;", "return   saveData ;", "}", "METHOD_END"], "methodName": ["createSaveData"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ResourceData"}, {"methodBody": ["METHOD_START", "{", "ResourceData . SaveData   saveData    =    new   ResourceData . SaveData ( this )  ;", "if    ( uniqueData . containsKey ( key )  )", "throw   new   RuntimeException (  \" Key   already   used ,    data   must   be   unique ,    use   a   different   key \"  )  ;", "uniqueData . put ( key ,    saveData )  ;", "return   saveData ;", "}", "METHOD_END"], "methodName": ["createSaveData"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ResourceData"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "for    (  . AssetData   data    :    sharedAssets )     {", "if    (  ( data . filename . equals ( filename )  )     &  &     ( data . type . equals ( type )  )  )     {", "return   i ;", "}", "+  + i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getAssetData"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ResourceData"}, {"methodBody": ["METHOD_START", "{", "Array < AssetDescriptor >    descriptors    =    new   Array < AssetDescriptor >  (  )  ;", "for    (  . AssetData   data    :    sharedAssets )     {", "descriptors . add ( new   AssetDescriptor < T >  ( data . filename ,    data . type )  )  ;", "}", "return   descriptors ;", "}", "METHOD_END"], "methodName": ["getAssetDescriptors"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ResourceData"}, {"methodBody": ["METHOD_START", "{", "return   sharedAssets ;", "}", "METHOD_END"], "methodName": ["getAssets"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ResourceData"}, {"methodBody": ["METHOD_START", "{", "return   data . get (  (  ( currentLoadIndex )  +  +  )  )  ;", "}", "METHOD_END"], "methodName": ["getSaveData"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ResourceData"}, {"methodBody": ["METHOD_START", "{", "return   uniqueData . get ( key )  ;", "}", "METHOD_END"], "methodName": ["getSaveData"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.ResourceData"}, {"methodBody": ["METHOD_START", "{", "int   indicesCount    =     ( BillboardParticleBatch . MAX _ PARTICLES _ PER _ MESH )     *     6  ;", "indices    =    new   short [ indicesCount ]  ;", "for    ( int   i    =     0  ,    vertex    =     0  ;    i    <    indicesCount ;    i    +  =     6     ,    vertex    +  =     4  )     {", "indices [ i ]     =     (  ( short )     ( vertex )  )  ;", "indices [  ( i    +     1  )  ]     =     (  ( short )     ( vertex    +     1  )  )  ;", "indices [  ( i    +     2  )  ]     =     (  ( short )     ( vertex    +     2  )  )  ;", "indices [  ( i    +     3  )  ]     =     (  ( short )     ( vertex    +     2  )  )  ;", "indices [  ( i    +     4  )  ]     =     (  ( short )     ( vertex    +     3  )  )  ;", "indices [  ( i    +     5  )  ]     =     (  ( short )     ( vertex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["allocIndices"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "Renderable   renderable    =    new   Renderable (  )  ;", "renderable . meshPart . primitiveType    =    GL 2  0  . GL _ TRIANGLES ;", "renderable . meshPart . offset    =     0  ;", "renderable . material    =    new   Material ( this . blendingAttribute ,    this . depthTestAttribute ,    TextureAttribute . createDiffuse ( texture )  )  ;", "renderable . meshPart . mesh    =    new   Mesh ( false ,     . MAX _ VERTICES _ PER _ MESH ,     (  (  . MAX _ PARTICLES _ PER _ MESH )     *     6  )  ,    currentAttributes )  ;", "renderable . meshPart . mesh . setIndices ( indices )  ;", "renderable . shader    =    shader ;", "return   renderable ;", "}", "METHOD_END"], "methodName": ["allocRenderable"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "int   meshCount    =    MathUtils . ceil (  ( capacity    /     ( BillboardParticleBatch . MAX _ PARTICLES _ PER _ MESH )  )  )  ;", "int   free    =    renderablePool . getFree (  )  ;", "if    ( free    <    meshCount )     {", "for    ( int   i    =     0  ,    left    =    meshCount    -    free ;    i    <    left ;     +  + i )", "renderablePool . free ( renderablePool . newObject (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["allocRenderables"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "Renderable   newRenderable    =    allocRenderable (  )  ;", "shader    =    newRenderable . shader    =    getShader ( newRenderable )  ;", "renderablePool . free ( newRenderable )  ;", "}", "METHOD_END"], "methodName": ["allocShader"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "renderablePool . freeAll ( renderables )  ;", "for    ( int   i    =     0  ,    free    =    renderablePool . getFree (  )  ;    i    <    free ;     +  + i )     {", "Renderable   renderable    =    renderablePool . obtain (  )  ;", "renderable . mesh . mesh . dispose (  )  ;", "}", "renderables . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearRenderablesPool"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "int   tp    =     0  ;", "for    ( BillboardControllerRenderData   data    :    renderData )     {", "ParallelArray . FloatChannel   scaleChannel    =    data . scaleChannel ;", "ParallelArray . FloatChannel   regionChannel    =    data . regionChannel ;", "ParallelArray . FloatChannel   positionChannel    =    data . positionChannel ;", "ParallelArray . FloatChannel   colorChannel    =    data . colorChannel ;", "ParallelArray . FloatChannel   rotationChannel    =    data . rotationChannel ;", "for    ( int   p    =     0  ,    c    =    data . controller . particles . size ;    p    <    c ;     +  + p    ,     +  + tp )     {", "int   baseOffset    =     (  ( particlesOffset [ tp ]  )     *     ( currentVertexSize )  )     *     4  ;", "float   scale    =    scaleChannel . data [  ( p    *     ( scaleChannel . strideSize )  )  ]  ;", "int   regionOffset    =    p    *     ( regionChannel . strideSize )  ;", "int   positionOffset    =    p    *     ( positionChannel . strideSize )  ;", "int   colorOffset    =    p    *     ( colorChannel . strideSize )  ;", "int   rotationOffset    =    p    *     ( rotationChannel . strideSize )  ;", "float   px    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . XOffset )  )  ]  ;", "float   py    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . YOffset )  )  ]  ;", "float   pz    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . ZOffset )  )  ]  ;", "float   u    =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . UOffset )  )  ]  ;", "float   v    =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . VOffset )  )  ]  ;", "float   u 2     =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . U 2 Offset )  )  ]  ;", "float   v 2     =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . V 2 Offset )  )  ]  ;", "float   sx    =     ( regionChannel . data [  ( regionOffset    +     ( ParticleChannels . HalfWidthOffset )  )  ]  )     *    scale ;", "float   sy    =     ( regionChannel . data [  ( regionOffset    +     ( ParticleChannels . HalfHeightOffset )  )  ]  )     *    scale ;", "float   r    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . RedOffset )  )  ]  ;", "float   g    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . GreenOffset )  )  ]  ;", "float   b    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . BlueOffset )  )  ]  ;", "float   a    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . AlphaOffset )  )  ]  ;", "float   cosRotation    =    rotationChannel . data [  ( rotationOffset    +     ( ParticleChannels . CosineOffset )  )  ]  ;", "float   sinRotation    =    rotationChannel . data [  ( rotationOffset    +     ( ParticleChannels . SineOffset )  )  ]  ;", ". putVertex ( vertices ,    baseOffset ,    px ,    py ,    pz ,    u ,    v 2  ,     (  - sx )  ,     (  - sy )  ,    cosRotation ,    sinRotation ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,    px ,    py ,    pz ,    u 2  ,    v 2  ,    sx ,     (  - sy )  ,    cosRotation ,    sinRotation ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,    px ,    py ,    pz ,    u 2  ,    v ,    sx ,    sy ,    cosRotation ,    sinRotation ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,    px ,    py ,    pz ,    u ,    v ,     (  - sx )  ,    sy ,    cosRotation ,    sinRotation ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", "}", "}", "}", "METHOD_END"], "methodName": ["fillVerticesGPU"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "Vector 3    look    =    BillboardParticleBatch . TMP _ V 3  . set ( camera . direction )  . scl (  (  -  1  )  )  ;", "Vector 3    right    =    BillboardParticleBatch . TMP _ V 4  . set ( camera . up )  . crs ( look )  . nor (  )  ;", "Vector 3    up    =    camera . up ;", "int   tp    =     0  ;", "for    ( BillboardControllerRenderData   data    :    renderData )     {", "ParallelArray . FloatChannel   scaleChannel    =    data . scaleChannel ;", "ParallelArray . FloatChannel   regionChannel    =    data . regionChannel ;", "ParallelArray . FloatChannel   positionChannel    =    data . positionChannel ;", "ParallelArray . FloatChannel   colorChannel    =    data . colorChannel ;", "ParallelArray . FloatChannel   rotationChannel    =    data . rotationChannel ;", "for    ( int   p    =     0  ,    c    =    data . controller . particles . size ;    p    <    c ;     +  + p    ,     +  + tp )     {", "int   baseOffset    =     (  ( particlesOffset [ tp ]  )     *     ( currentVertexSize )  )     *     4  ;", "float   scale    =    scaleChannel . data [  ( p    *     ( scaleChannel . strideSize )  )  ]  ;", "int   regionOffset    =    p    *     ( regionChannel . strideSize )  ;", "int   positionOffset    =    p    *     ( positionChannel . strideSize )  ;", "int   colorOffset    =    p    *     ( colorChannel . strideSize )  ;", "int   rotationOffset    =    p    *     ( rotationChannel . strideSize )  ;", "float   px    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . XOffset )  )  ]  ;", "float   py    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . YOffset )  )  ]  ;", "float   pz    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . ZOffset )  )  ]  ;", "float   u    =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . UOffset )  )  ]  ;", "float   v    =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . VOffset )  )  ]  ;", "float   u 2     =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . U 2 Offset )  )  ]  ;", "float   v 2     =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . V 2 Offset )  )  ]  ;", "float   sx    =     ( regionChannel . data [  ( regionOffset    +     ( ParticleChannels . HalfWidthOffset )  )  ]  )     *    scale ;", "float   sy    =     ( regionChannel . data [  ( regionOffset    +     ( ParticleChannels . HalfHeightOffset )  )  ]  )     *    scale ;", "float   r    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . RedOffset )  )  ]  ;", "float   g    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . GreenOffset )  )  ]  ;", "float   b    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . BlueOffset )  )  ]  ;", "float   a    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . AlphaOffset )  )  ]  ;", "float   cosRotation    =    rotationChannel . data [  ( rotationOffset    +     ( ParticleChannels . CosineOffset )  )  ]  ;", "float   sinRotation    =    rotationChannel . data [  ( rotationOffset    +     ( ParticleChannels . SineOffset )  )  ]  ;", "BillboardParticleBatch . TMP _ V 1  . set ( right )  . scl ( sx )  ;", "BillboardParticleBatch . TMP _ V 2  . set ( up )  . scl ( sy )  ;", "if    ( cosRotation    !  =     1  )     {", "BillboardParticleBatch . TMP _ M 3  . setToRotation ( look ,    cosRotation ,    sinRotation )  ;", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . x )  )     -     ( BillboardParticleBatch . TMP _ V 2  . x )  )  ,     (  (  -  ( BillboardParticleBatch . TMP _ V 1  . y )  )     -     ( BillboardParticleBatch . TMP _ V 2  . y )  )  ,     (  (  -  ( BillboardParticleBatch . TMP _ V 1  . z )  )     -     ( BillboardParticleBatch . TMP _ V 2  . z )  )  )  . mul ( BillboardParticleBatch . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  ( BillboardParticleBatch . TMP _ V 1  . x )     -     ( BillboardParticleBatch . TMP _ V 2  . x )  )  ,     (  ( BillboardParticleBatch . TMP _ V 1  . y )     -     ( BillboardParticleBatch . TMP _ V 2  . y )  )  ,     (  ( BillboardParticleBatch . TMP _ V 1  . z )     -     ( BillboardParticleBatch . TMP _ V 2  . z )  )  )  . mul ( BillboardParticleBatch . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u 2  ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  ( BillboardParticleBatch . TMP _ V 1  . x )     +     ( BillboardParticleBatch . TMP _ V 2  . x )  )  ,     (  ( BillboardParticleBatch . TMP _ V 1  . y )     +     ( BillboardParticleBatch . TMP _ V 2  . y )  )  ,     (  ( BillboardParticleBatch . TMP _ V 1  . z )     +     ( BillboardParticleBatch . TMP _ V 2  . z )  )  )  . mul ( BillboardParticleBatch . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u 2  ,    v ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . x )  )     +     ( BillboardParticleBatch . TMP _ V 2  . x )  )  ,     (  (  -  ( BillboardParticleBatch . TMP _ V 1  . y )  )     +     ( BillboardParticleBatch . TMP _ V 2  . y )  )  ,     (  (  -  ( BillboardParticleBatch . TMP _ V 1  . z )  )     +     ( BillboardParticleBatch . TMP _ V 2  . z )  )  )  . mul ( BillboardParticleBatch . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u ,    v ,    r ,    g ,    b ,    a )  ;", "} else    {", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . x )  )     -     ( BillboardParticleBatch . TMP _ V 2  . x )  )     +    px )  ,     (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . y )  )     -     ( BillboardParticleBatch . TMP _ V 2  . y )  )     +    py )  ,     (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . z )  )     -     ( BillboardParticleBatch . TMP _ V 2  . z )  )     +    pz )  )  ,    u ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  (  ( BillboardParticleBatch . TMP _ V 1  . x )     -     ( BillboardParticleBatch . TMP _ V 2  . x )  )     +    px )  ,     (  (  ( BillboardParticleBatch . TMP _ V 1  . y )     -     ( BillboardParticleBatch . TMP _ V 2  . y )  )     +    py )  ,     (  (  ( BillboardParticleBatch . TMP _ V 1  . z )     -     ( BillboardParticleBatch . TMP _ V 2  . z )  )     +    pz )  )  ,    u 2  ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  (  ( BillboardParticleBatch . TMP _ V 1  . x )     +     ( BillboardParticleBatch . TMP _ V 2  . x )  )     +    px )  ,     (  (  ( BillboardParticleBatch . TMP _ V 1  . y )     +     ( BillboardParticleBatch . TMP _ V 2  . y )  )     +    py )  ,     (  (  ( BillboardParticleBatch . TMP _ V 1  . z )     +     ( BillboardParticleBatch . TMP _ V 2  . z )  )     +    pz )  )  ,    u 2  ,    v ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", "BillboardParticleBatch . putVertex ( vertices ,    baseOffset ,    BillboardParticleBatch . TMP _ V 6  . set (  (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . x )  )     +     ( BillboardParticleBatch . TMP _ V 2  . x )  )     +    px )  ,     (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . y )  )     +     ( BillboardParticleBatch . TMP _ V 2  . y )  )     +    py )  ,     (  (  (  -  ( BillboardParticleBatch . TMP _ V 1  . z )  )     +     ( BillboardParticleBatch . TMP _ V 2  . z )  )     +    pz )  )  ,    u ,    v ,    r ,    g ,    b ,    a )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["fillVerticesToScreenCPU"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "int   tp    =     0  ;", "for    ( BillboardControllerRenderData   data    :    renderData )     {", "ParallelArray . FloatChannel   scaleChannel    =    data . scaleChannel ;", "ParallelArray . FloatChannel   regionChannel    =    data . regionChannel ;", "ParallelArray . FloatChannel   positionChannel    =    data . positionChannel ;", "ParallelArray . FloatChannel   colorChannel    =    data . colorChannel ;", "ParallelArray . FloatChannel   rotationChannel    =    data . rotationChannel ;", "for    ( int   p    =     0  ,    c    =    data . controller . particles . size ;    p    <    c ;     +  + p    ,     +  + tp )     {", "int   baseOffset    =     (  ( particlesOffset [ tp ]  )     *     ( currentVertexSize )  )     *     4  ;", "float   scale    =    scaleChannel . data [  ( p    *     ( scaleChannel . strideSize )  )  ]  ;", "int   regionOffset    =    p    *     ( regionChannel . strideSize )  ;", "int   positionOffset    =    p    *     ( positionChannel . strideSize )  ;", "int   colorOffset    =    p    *     ( colorChannel . strideSize )  ;", "int   rotationOffset    =    p    *     ( rotationChannel . strideSize )  ;", "float   px    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . XOffset )  )  ]  ;", "float   py    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . YOffset )  )  ]  ;", "float   pz    =    positionChannel . data [  ( positionOffset    +     ( ParticleChannels . ZOffset )  )  ]  ;", "float   u    =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . UOffset )  )  ]  ;", "float   v    =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . VOffset )  )  ]  ;", "float   u 2     =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . U 2 Offset )  )  ]  ;", "float   v 2     =    regionChannel . data [  ( regionOffset    +     ( ParticleChannels . V 2 Offset )  )  ]  ;", "float   sx    =     ( regionChannel . data [  ( regionOffset    +     ( ParticleChannels . HalfWidthOffset )  )  ]  )     *    scale ;", "float   sy    =     ( regionChannel . data [  ( regionOffset    +     ( ParticleChannels . HalfHeightOffset )  )  ]  )     *    scale ;", "float   r    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . RedOffset )  )  ]  ;", "float   g    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . GreenOffset )  )  ]  ;", "float   b    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . BlueOffset )  )  ]  ;", "float   a    =    colorChannel . data [  ( colorOffset    +     ( ParticleChannels . AlphaOffset )  )  ]  ;", "float   cosRotation    =    rotationChannel . data [  ( rotationOffset    +     ( ParticleChannels . CosineOffset )  )  ]  ;", "float   sinRotation    =    rotationChannel . data [  ( rotationOffset    +     ( ParticleChannels . SineOffset )  )  ]  ;", "Vector 3    look    =     . TMP _ V 3  . set ( camera . position )  . sub ( px ,    py ,    pz )  . nor (  )  ;", "Vector 3    right    =     . TMP _ V 1  . set ( camera . up )  . crs ( look )  . nor (  )  ;", "Vector 3    up    =     . TMP _ V 2  . set ( look )  . crs ( right )  ;", "right . scl ( sx )  ;", "up . scl ( sy )  ;", "if    ( cosRotation    !  =     1  )     {", ". TMP _ M 3  . setToRotation ( look ,    cosRotation ,    sinRotation )  ;", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  -  (  . TMP _ V 1  . x )  )     -     (  . TMP _ V 2  . x )  )  ,     (  (  -  (  . TMP _ V 1  . y )  )     -     (  . TMP _ V 2  . y )  )  ,     (  (  -  (  . TMP _ V 1  . z )  )     -     (  . TMP _ V 2  . z )  )  )  . mul (  . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  . TMP _ V 1  . x )     -     (  . TMP _ V 2  . x )  )  ,     (  (  . TMP _ V 1  . y )     -     (  . TMP _ V 2  . y )  )  ,     (  (  . TMP _ V 1  . z )     -     (  . TMP _ V 2  . z )  )  )  . mul (  . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u 2  ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  . TMP _ V 1  . x )     +     (  . TMP _ V 2  . x )  )  ,     (  (  . TMP _ V 1  . y )     +     (  . TMP _ V 2  . y )  )  ,     (  (  . TMP _ V 1  . z )     +     (  . TMP _ V 2  . z )  )  )  . mul (  . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u 2  ,    v ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  -  (  . TMP _ V 1  . x )  )     +     (  . TMP _ V 2  . x )  )  ,     (  (  -  (  . TMP _ V 1  . y )  )     +     (  . TMP _ V 2  . y )  )  ,     (  (  -  (  . TMP _ V 1  . z )  )     +     (  . TMP _ V 2  . z )  )  )  . mul (  . TMP _ M 3  )  . add ( px ,    py ,    pz )  ,    u ,    v ,    r ,    g ,    b ,    a )  ;", "} else    {", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  (  -  (  . TMP _ V 1  . x )  )     -     (  . TMP _ V 2  . x )  )     +    px )  ,     (  (  (  -  (  . TMP _ V 1  . y )  )     -     (  . TMP _ V 2  . y )  )     +    py )  ,     (  (  (  -  (  . TMP _ V 1  . z )  )     -     (  . TMP _ V 2  . z )  )     +    pz )  )  ,    u ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  (  . TMP _ V 1  . x )     -     (  . TMP _ V 2  . x )  )     +    px )  ,     (  (  (  . TMP _ V 1  . y )     -     (  . TMP _ V 2  . y )  )     +    py )  ,     (  (  (  . TMP _ V 1  . z )     -     (  . TMP _ V 2  . z )  )     +    pz )  )  ,    u 2  ,    v 2  ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  (  . TMP _ V 1  . x )     +     (  . TMP _ V 2  . x )  )     +    px )  ,     (  (  (  . TMP _ V 1  . y )     +     (  . TMP _ V 2  . y )  )     +    py )  ,     (  (  (  . TMP _ V 1  . z )     +     (  . TMP _ V 2  . z )  )     +    pz )  )  ,    u 2  ,    v ,    r ,    g ,    b ,    a )  ;", "baseOffset    +  =    currentVertexSize ;", ". putVertex ( vertices ,    baseOffset ,     . TMP _ V 6  . set (  (  (  (  -  (  . TMP _ V 1  . x )  )     +     (  . TMP _ V 2  . x )  )     +    px )  ,     (  (  (  -  (  . TMP _ V 1  . y )  )     +     (  . TMP _ V 2  . y )  )     +    py )  ,     (  (  (  -  (  . TMP _ V 1  . z )  )     +     (  . TMP _ V 2  . z )  )     +    pz )  )  ,    u ,    v ,    r ,    g ,    b ,    a )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["fillVerticesToViewPointCPU"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "return   mode ;", "}", "METHOD_END"], "methodName": ["getAlignMode"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "Shader   shader    =     ( useGPU )     ?    new   ParticleShader ( renderable ,    new   ParticleShader . Config ( mode )  )     :    new   DefaultShader ( renderable )  ;", "shader . init (  )  ;", "return   shader ;", "}", "METHOD_END"], "methodName": ["getShader"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "return   texture ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "setVertexData (  )  ;", "arRenderablesPool (  )  ;", "allocShader (  )  ;", "resetCapacity (  )  ;", "}", "METHOD_END"], "methodName": ["initRenderData"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "return   useGPU ;", "}", "METHOD_END"], "methodName": ["isUseGPU"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( offset    +     ( BillboardParticleBatch . CPU _ POSITION _ OFFSET )  )  ]     =    p . x ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . CPU _ POSITION _ OFFSET )  )     +     1  )  ]     =    p . y ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . CPU _ POSITION _ OFFSET )  )     +     2  )  ]     =    p . z ;", "vertices [  ( offset    +     ( BillboardParticleBatch . CPU _ UV _ OFFSET )  )  ]     =    u ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . CPU _ UV _ OFFSET )  )     +     1  )  ]     =    v ;", "vertices [  ( offset    +     ( BillboardParticleBatch . CPU _ COLOR _ OFFSET )  )  ]     =    r ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . CPU _ COLOR _ OFFSET )  )     +     1  )  ]     =    g ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . CPU _ COLOR _ OFFSET )  )     +     2  )  ]     =    b ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . CPU _ COLOR _ OFFSET )  )     +     3  )  ]     =    a ;", "}", "METHOD_END"], "methodName": ["putVertex"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "vertices [  ( offset    +     ( BillboardParticleBatch . GPU _ POSITION _ OFFSET )  )  ]     =    x ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ POSITION _ OFFSET )  )     +     1  )  ]     =    y ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ POSITION _ OFFSET )  )     +     2  )  ]     =    z ;", "vertices [  ( offset    +     ( BillboardParticleBatch . GPU _ UV _ OFFSET )  )  ]     =    u ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ UV _ OFFSET )  )     +     1  )  ]     =    v ;", "vertices [  ( offset    +     ( BillboardParticleBatch . GPU _ SIZE _ ROTATION _ OFFSET )  )  ]     =    scaleX ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ SIZE _ ROTATION _ OFFSET )  )     +     1  )  ]     =    scaleY ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ SIZE _ ROTATION _ OFFSET )  )     +     2  )  ]     =    cosRotation ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ SIZE _ ROTATION _ OFFSET )  )     +     3  )  ]     =    sinRotation ;", "vertices [  ( offset    +     ( BillboardParticleBatch . GPU _ COLOR _ OFFSET )  )  ]     =    r ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ COLOR _ OFFSET )  )     +     1  )  ]     =    g ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ COLOR _ OFFSET )  )     +     2  )  ]     =    b ;", "vertices [  (  ( offset    +     ( BillboardParticleBatch . GPU _ COLOR _ OFFSET )  )     +     3  )  ]     =    a ;", "}", "METHOD_END"], "methodName": ["putVertex"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "if    ( mode    !  =     ( this . mode )  )     {", "this . mode    =    mode ;", "if    ( useGPU )     {", "initRenderData (  )  ;", "allocRenderables ( bufferesCount )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setAlignMode"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "renderablePool . freeAll ( renderab ;", "renderabclear (  )  ;", "for    ( int   i    =     0  ,    free    =    renderablePool . getFree (  )  ;    i    <    free ;     +  + i )     {", "Renderable   renderable    =    renderablePool . obtain (  )  ;", "TextureAttribute   attribute    =     (  ( TextureAttribute )     ( renderable . material . get ( TextureAttribute . Diffuse )  )  )  ;", "attribute . textureDescription . texture    =    texture ;", "}", "this . texture    =    texture ;", "}", "METHOD_END"], "methodName": ["setTexture"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . useGPU )     !  =    useGPU )     {", "this . useGPU    =    useGPU ;", "initRenderData (  )  ;", "allocRenderables ( bufferesCount )  ;", "}", "}", "METHOD_END"], "methodName": ["setUseGpu"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "if    ( useGPU )     {", "currentAttributes    =     . GPU _ ATTRIBUTES ;", "currentVertexSize    =     . GPU _ VERTEX _ SIZE ;", "} else    {", "currentAttributes    =     . CPU _ ATTRIBUTES ;", "currentVertexSize    =     . CPU _ VERTEX _ SIZE ;", "}", "}", "METHOD_END"], "methodName": ["setVertexData"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch"}, {"methodBody": ["METHOD_START", "{", "renderData . clear (  )  ;", "bsCount    =     0  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bufferedParticlesCount )     >     0  )     {", "ensureCapacity ( bufferedParticlesCount )  ;", "flush ( sorter . sort ( renderData )  )  ;", "}", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentCapacity )     >  =    capacity )", "return ;", "sorter . ensureCapacity ( capacity )  ;", "allocsData ( capacity )  ;", "currentCapacity    =    capacity ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "return   bufferedParticlesCount ;", "}", "METHOD_END"], "methodName": ["getBufferedCount"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "return   sorter ;", "}", "METHOD_END"], "methodName": ["getSorter"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "currentCapacity    =    bufferedParticlesCount    =     0  ;", "}", "METHOD_END"], "methodName": ["resetCapacity"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "this . camera    =    camera ;", "sorter . setCamera ( camera )  ;", "}", "METHOD_END"], "methodName": ["setCamera"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "this . sorter    =    sorter ;", "sorter . setCamera ( camera )  ;", "sorter . ensureCapacity ( currentCapacity )  ;", "}", "METHOD_END"], "methodName": ["setSorter"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.BufferedParticleBatch"}, {"methodBody": ["METHOD_START", "{", "return   bufferedParticlesCount ;", "}", "METHOD_END"], "methodName": ["getBufferedCount"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.ModelInstanceParticleBatch"}, {"methodBody": ["METHOD_START", "{", "renderable    =    new   Renderable (  )  ;", "renderable . mesh . primitiveType    =    GL 2  0  . GL _ POINTS ;", "renderable . mesh . offset    =     0  ;", "renderable . material    =    new   Material ( new   BlendingAttribute ( GL 2  0  . GL _ ONE ,    GL 2  0  . GL _ ONE _ MINUS _ SRC _ ALPHA ,     1  .  0 F )  ,    new   DepthTestAttribute ( GL 2  0  . GL _ LEQUAL ,    false )  ,    TextureAttribute . createDiffuse (  (  ( Texture )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["allocRenderable"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.PointSpriteParticleBatch"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glEnable ( GL 2  0  . GL _ VERTEX _ PROGRAM _ POINT _ SIZE )  ;", "if    (  ( Gdx . app . getType (  )  )     =  =     ( Application . ApplicationType . Desktop )  )     {", "Gdx . gl . glEnable (  3  4  9  1  3  )  ;", "}", ". pointSpritesEnabled    =    true ;", "}", "METHOD_END"], "methodName": ["enablePointSprites"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.PointSpriteParticleBatch"}, {"methodBody": ["METHOD_START", "{", "TextureAttribute   attribute    =     (  ( TextureAttribute )     ( renderable . material . get ( TextureAttribute . Diffuse )  )  )  ;", "return   attribute . textureDescription . texture ;", "}", "METHOD_END"], "methodName": ["getTexture"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.PointSpriteParticleBatch"}, {"methodBody": ["METHOD_START", "{", "TextureAttribute   attribute    =     (  ( TextureAttribute )     ( renderable . material . get ( TextureAttribute . Diffuse )  )  )  ;", "attribute . textureDescription . texture    =    texture ;", "}", "METHOD_END"], "methodName": ["setTexture"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.batches.PointSpriteParticleBatch"}, {"methodBody": ["METHOD_START", "{", "return   maxParticleCount ;", "}", "METHOD_END"], "methodName": ["getMaxParticleCount"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter"}, {"methodBody": ["METHOD_START", "{", "return   minParticleCount ;", "}", "METHOD_END"], "methodName": ["getMinParticleCount"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter"}, {"methodBody": ["METHOD_START", "{", "return    ( percent )     >  =     1  .  0 F ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter"}, {"methodBody": ["METHOD_START", "{", "minParticleCount    =    emitter . minParticleCount ;", "maxParticleCount    =    emitter . maxParticleCount ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter"}, {"methodBody": ["METHOD_START", "{", "this . maxParticleCount    =    maxParticleCount ;", "}", "METHOD_END"], "methodName": ["setMaxParticleCount"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter"}, {"methodBody": ["METHOD_START", "{", "this . minParticleCount    =    minParticleCount ;", "}", "METHOD_END"], "methodName": ["setMinParticleCount"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter"}, {"methodBody": ["METHOD_START", "{", "setMinParticleCount ( aMin )  ;", "setMaxParticleCount ( aMax )  ;", "}", "METHOD_END"], "methodName": ["setParticleCount"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter"}, {"methodBody": ["METHOD_START", "{", "int   currentTotaLife    =     ( life )     +     (  ( int )     (  ( lifeDiff )     *     ( lifeValue . getScale ( percent )  )  )  )  ;", "int   currentLife    =    currentTotaLife ;", "int   offsetTime    =     (  ( int )     (  ( lifeOffset )     +     (  ( lifeOffsetDiff )     *     ( lifeOffsetValue . getScale ( percent )  )  )  )  )  ;", "if    ( offsetTime    >     0  )     {", "if    ( offsetTime    >  =    currentLife )", "offsetTime    =    currentLife    -     1  ;", "currentLife    -  =    offsetTime ;", "}", "float   lifePercent    =     1     -     ( currentLife    /     (  ( float )     ( currentTotaLife )  )  )  ;", "for    ( int   i    =    startIndex    *     ( lifeChannel . strideSize )  ,    c    =    i    +     ( count    *     ( lifeChannel . strideSize )  )  ;    i    <    c ;    i    +  =    lifeChannel . strideSize )     {", "lifeChannel . data [  ( i    +     ( PChannels . CurrentLifeOffset )  )  ]     =    currentLife ;", "lifeChannel . data [  ( i    +     ( PChannels . TotalLifeOffset )  )  ]     =    currentTotaLife ;", "lifeChannel . data [  ( i    +     ( PChannels . LifePercentOffset )  )  ]     =    lifePercent ;", "}", "}", "METHOD_END"], "methodName": ["activateParticles"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "count    =    Math . min ( count ,     (  ( maxParticleCount )     -     ( controller . particles . size )  )  )  ;", "if    ( count    <  =     0  )", "return ;", "controller . activateParticles ( controller . particles . size ,    count )  ;", "controller . particles . size    +  =    count ;", "}", "METHOD_END"], "methodName": ["addParticles"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "return   delayValue ;", "}", "METHOD_END"], "methodName": ["getDelay"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "return   durationValue ;", "}", "METHOD_END"], "methodName": ["getDuration"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "return   emissionValue ;", "}", "METHOD_END"], "methodName": ["getEmission"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "return   emissionMode ;", "}", "METHOD_END"], "methodName": ["getEmissionMode"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "return   lifeValue ;", "}", "METHOD_END"], "methodName": ["getLife"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "return   lifeOffsetValue ;", "}", "METHOD_END"], "methodName": ["getLifeOffset"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( delayTimer )     <     ( delay )  )", "return    0  ;", "return   Math . min (  1  ,     (  ( durationTimer )     /     (  ( float )     ( duration )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPercentComplete"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "super . init (  )  ;", "ssionDelta    =     0  ;", "durationTimer    =    duration ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "return   continuous ;", "}", "METHOD_END"], "methodName": ["isContinuous"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "super . set ( emitter )  ;", "delayValue . load ( emitter . delayValue )  ;", "durationValue . load ( emitter . durationValue )  ;", "lifeOffsetValue . load ( emitter . lifeOffsetValue )  ;", "lifeValue . load ( emitter . lifeValue )  ;", "emissionValue . load ( emitter . emissionValue )  ;", "emission    =    emitter . emission ;", "emissionDiff    =    emitter . emissionDiff ;", "emissionDelta    =    emitter . emissionDelta ;", "lifeOffset    =    emitter . lifeOffset ;", "lifeOffsetDiff    =    emitter . lifeOffsetDiff ;", "life    =    emitter . life ;", "lifeDiff    =    emitter . lifeDiff ;", "duration    =    emitter . duration ;", "delay    =    emitter . delay ;", "durationTimer    =    emitter . durationTimer ;", "delayTimer    =    emitter . delayTimer ;", "continuous    =    emitter . continuous ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "this . continuous    =    continuous ;", "}", "METHOD_END"], "methodName": ["setContinuous"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "this . emissionMode    =    emissionMode ;", "}", "METHOD_END"], "methodName": ["setEmissionMode"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "float   deltaMillis    =     ( controller . deltaTime )     *     1  0  0  0  ;", "if    (  ( delayTimer )     <     ( delay )  )     {", "delayTimer    +  =    deltaMillis ;", "} else    {", "boolean   emit    =     ( emissionMode )     !  =     (  . EmissionMode . Disabled )  ;", "if    (  ( durationTimer )     <     ( duration )  )     {", "durationTimer    +  =    deltaMillis ;", "percent    =     ( durationTimer )     /     (  ( float )     ( duration )  )  ;", "} else    {", "if    (  (  ( continuous )     &  &    emit )     &  &     (  ( emissionMode )     =  =     (  . EmissionMode . Enabled )  )  )", "controller . start (  )  ;", "else", "emit    =    false ;", "}", "if    ( emit )     {", "emissionDelta    +  =    deltaMillis ;", "float   emissionTime    =     ( emission )     +     (  ( emissionDiff )     *     ( emissionValue . getScale ( percent )  )  )  ;", "if    ( emissionTime    >     0  )     {", "emissionTime    =     1  0  0  0     /    emissionTime ;", "if    (  ( emissionDelta )     >  =    emissionTime )     {", "int   emitCount    =     (  ( int )     (  ( emissionDelta )     /    emissionTime )  )  ;", "emitCount    =    Math . min ( emitCount ,     (  ( maxParticleCount )     -     ( controller . particles . size )  )  )  ;", "emissionDelta    -  =    emitCount    *    emissionTime ;", "emissionDelta    %  =    emissionTime ;", "addParticles ( emitCount )  ;", "}", "}", "if    (  ( controller . particles . size )     <     ( minParticleCount )  )", "addParticles (  (  ( minParticleCount )     -     ( controller . particles . size )  )  )  ;", "}", "}", "int   activeParticles    =    controller . particles . size ;", "for    ( int   i    =     0  ,    k    =     0  ;    i    <     ( controller . particles . size )  ;  )     {", "if    (  ( lifeChannel . data [  ( k    +     ( ParticleChannels . CurrentLifeOffset )  )  ]     -  =    deltaMillis )     <  =     0  )     {", "controller . particles . removeElement ( i )  ;", "continue ;", "} else    {", "lifeChannel . data [  ( k    +     ( ParticleChannels . LifePercentOffset )  )  ]     =     1     -     (  ( lifeChannel . data [  ( k    +     ( ParticleChannels . CurrentLifeOffset )  )  ]  )     /     ( lifeChannel . data [  ( k    +     ( ParticleChannels . TotalLifeOffset )  )  ]  )  )  ;", "}", "+  + i ;", "k    +  =    lifeChannel . strideSize ;", "}", "if    (  ( controller . particles . size )     <    activeParticles )     {", "controller . killParticles ( controller . particles . size ,     ( activeParticles    -     ( controller . particles . size )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter"}, {"methodBody": ["METHOD_START", "{", "if    ( hasAcceleration )     {", "for    ( int   i    =    startIndex    *     ( positionChannel . strideSize )  ,    c    =    i    +     ( count    *     ( positionChannel . strideSize )  )  ;    i    <    c ;    i    +  =    positionChannel . strideSize )     {", "previousPositionChannel . data [  ( i    +     ( ParticleChannels . XOffset )  )  ]     =    positionChannel . data [  ( i    +     ( ParticleChannels . XOffset )  )  ]  ;", "previousPositionChannel . data [  ( i    +     ( ParticleChannels . YOffset )  )  ]     =    positionChannel . data [  ( i    +     ( ParticleChannels . YOffset )  )  ]  ;", "previousPositionChannel . data [  ( i    +     ( ParticleChannels . ZOffset )  )  ]     =    positionChannel . data [  ( i    +     ( ParticleChannels . ZOffset )  )  ]  ;", "}", "}", "if    ( has 2 dAngularVelocity )     {", "for    ( int   i    =    startIndex    *     ( rotationChannel . strideSize )  ,    c    =    i    +     ( count    *     ( rotationChannel . strideSize )  )  ;    i    <    c ;    i    +  =    rotationChannel . strideSize )     {", "rotationChannel . data [  ( i    +     ( ParticleChannels . CosineOffset )  )  ]     =     1  ;", "rotationChannel . data [  ( i    +     ( ParticleChannels . SineOffset )  )  ]     =     0  ;", "}", "} else", "if    ( has 3 dAngularVelocity )     {", "for    ( int   i    =    startIndex    *     ( rotationChannel . strideSize )  ,    c    =    i    +     ( count    *     ( rotationChannel . strideSize )  )  ;    i    <    c ;    i    +  =    rotationChannel . strideSize )     {", "rotationChannel . data [  ( i    +     ( ParticleChannels . XOffset )  )  ]     =     0  ;", "rotationChannel . data [  ( i    +     ( ParticleChannels . YOffset )  )  ]     =     0  ;", "rotationChannel . data [  ( i    +     ( ParticleChannels . ZOffset )  )  ]     =     0  ;", "rotationChannel . data [  ( i    +     ( ParticleChannels . WOffset )  )  ]     =     1  ;", "}", "}", "for    ( int   k    =     0  ;    k    <     ( velocities . size )  ;     +  + k )     {", "velocities . items [ k ]  . activateP ( startIndex ,    count )  ;", "}", "}", "METHOD_END"], "methodName": ["activateParticles"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsInfluencer"}, {"methodBody": ["METHOD_START", "{", "if    ( hasAcceleration )", "fill ( accellerationChannel . data ,     0  ,     (  ( controller . particles . size )     *     ( accellerationChannel . strideSize )  )  ,     0  )  ;", "if    (  ( has 2 dAngularVelocity )     |  |     ( has 3 dAngularVelocity )  )", "fill ( angularVelocityChannel . data ,     0  ,     (  ( controller . particles . size )     *     ( angularVelocityChannel . strideSize )  )  ,     0  )  ;", "for    ( int   k    =     0  ;    k    <     ( velocities . size )  ;     +  + k )     {", "velocities . items [ k ]  . update (  )  ;", "}", "if    ( hasAcceleration )     {", "for    ( int   i    =     0  ,    offset    =     0  ;    i    <     ( controller . particles . size )  ;     +  + i    ,    offset    +  =    positionChannel . strideSize )     {", "float   x    =    positionChannel . data [  ( offset    +     ( ParticleChannels . XOffset )  )  ]  ;", "float   y    =    positionChannel . data [  ( offset    +     ( ParticleChannels . YOffset )  )  ]  ;", "float   z    =    positionChannel . data [  ( offset    +     ( ParticleChannels . ZOffset )  )  ]  ;", "positionChannel . data [  ( offset    +     ( ParticleChannels . XOffset )  )  ]     =     (  (  2     *    x )     -     ( previousPositionChannel . data [  ( offset    +     ( ParticleChannels . XOffset )  )  ]  )  )     +     (  ( accellerationChannel . data [  ( offset    +     ( ParticleChannels . XOffset )  )  ]  )     *     ( controller . deltaTimeSqr )  )  ;", "positionChannel . data [  ( offset    +     ( ParticleChannels . YOffset )  )  ]     =     (  (  2     *    y )     -     ( previousPositionChannel . data [  ( offset    +     ( ParticleChannels . YOffset )  )  ]  )  )     +     (  ( accellerationChannel . data [  ( offset    +     ( ParticleChannels . YOffset )  )  ]  )     *     ( controller . deltaTimeSqr )  )  ;", "positionChannel . data [  ( offset    +     ( ParticleChannels . ZOffset )  )  ]     =     (  (  2     *    z )     -     ( previousPositionChannel . data [  ( offset    +     ( ParticleChannels . ZOffset )  )  ]  )  )     +     (  ( accellerationChannel . data [  ( offset    +     ( ParticleChannels . ZOffset )  )  ]  )     *     ( controller . deltaTimeSqr )  )  ;", "previousPositionChannel . data [  ( offset    +     ( ParticleChannels . XOffset )  )  ]     =    x ;", "previousPositionChannel . data [  ( offset    +     ( ParticleChannels . YOffset )  )  ]     =    y ;", "previousPositionChannel . data [  ( offset    +     ( ParticleChannels . ZOffset )  )  ]     =    z ;", "}", "}", "if    ( has 2 dAngularVelocity )     {", "for    ( int   i    =     0  ,    offset    =     0  ;    i    <     ( controller . particles . size )  ;     +  + i    ,    offset    +  =    rotationChannel . strideSize )     {", "float   rotation    =     ( angularVelocityChannel . data [ i ]  )     *     ( controller . deltaTime )  ;", "if    ( rotation    !  =     0  )     {", "float   cosBeta    =    MathUtils . cosDeg ( rotation )  ;", "float   sinBeta    =    MathUtils . sinDeg ( rotation )  ;", "float   currentCosine    =    rotationChannel . data [  ( offset    +     ( ParticleChannels . CosineOffset )  )  ]  ;", "float   currentSine    =    rotationChannel . data [  ( offset    +     ( ParticleChannels . SineOffset )  )  ]  ;", "float   newCosine    =     ( currentCosine    *    cosBeta )     -     ( currentSine    *    sinBeta )  ;", "float   newSine    =     ( currentSine    *    cosBeta )     +     ( currentCosine    *    sinBeta )  ;", "rotationChannel . data [  ( offset    +     ( ParticleChannels . CosineOffset )  )  ]     =    newCosine ;", "rotationChannel . data [  ( offset    +     ( ParticleChannels . SineOffset )  )  ]     =    newSine ;", "}", "}", "} else", "if    ( has 3 dAngularVelocity )     {", "for    ( int   i    =     0  ,    offset    =     0  ,    angularOffset    =     0  ;    i    <     ( controller . particles . size )  ;     +  + i    ,    offset    +  =    rotationChannel . strideSize    ,    angularOffset    +  =    angularVelocityChannel . strideSize )     {", "float   wx    =    angularVelocityChannel . data [  ( angularOffset    +     ( ParticleChannels . XOffset )  )  ]  ;", "float   wy    =    angularVelocityChannel . data [  ( angularOffset    +     ( ParticleChannels . YOffset )  )  ]  ;", "float   wz    =    angularVelocityChannel . data [  ( angularOffset    +     ( ParticleChannels . ZOffset )  )  ]  ;", "float   qx    =    rotationChannel . data [  ( offset    +     ( ParticleChannels . XOffset )  )  ]  ;", "float   qy    =    rotationChannel . data [  ( offset    +     ( ParticleChannels . YOffset )  )  ]  ;", "float   qz    =    rotationChannel . data [  ( offset    +     ( ParticleChannels . ZOffset )  )  ]  ;", "float   qw    =    rotationChannel . data [  ( offset    +     ( ParticleChannels . WOffset )  )  ]  ;", "ParticleControllerComponent . TMP _ Q . set ( wx ,    wy ,    wz ,     0  )  . mul ( qx ,    qy ,    qz ,    qw )  . mul (  (  0  .  5 F    *     ( controller . deltaTime )  )  )  . add ( qx ,    qy ,    qz ,    qw )  . nor (  )  ;", "rotationChannel . data [  ( offset    +     ( ParticleChannels . XOffset )  )  ]     =     . TMP _ Q . x ;", "rotationChannel . data [  ( offset    +     ( ParticleChannels . YOffset )  )  ]     =     . TMP _ Q . y ;", "rotationChannel . data [  ( offset    +     ( ParticleChannels . ZOffset )  )  ]     =     . TMP _ Q . z ;", "rotationChannel . data [  ( offset    +     ( ParticleChannels . WOffset )  )  ]     =     . TMP _ Q . w ;", "}", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsInfluencer"}, {"methodBody": ["METHOD_START", "{", "this . regions . ensureCapacity ( regions . length )  ;", "for    ( TextureRegion   region    :    regions )     {", "this . regions . add ( new    . AspectTextureRegion ( region )  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.influencers.RegionInfluencer"}, {"methodBody": ["METHOD_START", "{", "regions . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.influencers.RegionInfluencer"}, {"methodBody": ["METHOD_START", "{", "value . load ( scaleInfluencer . value )  ;", "valueChannelDescriptor    =    scaleInfluencer . valueChannelDescriptor ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.influencers.SimpleInfluencer"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompatibletch )  )     {", "thistch    =     (  ( T )    tch )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["setBatch"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderer"}, {"methodBody": ["METHOD_START", "{", "return   side ;", "}", "METHOD_END"], "methodName": ["getSide"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.EllipseSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "this . side    =    side ;", "}", "METHOD_END"], "methodName": ["setSide"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.EllipseSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "getColor ( percent ,    GradientColorValue . temp ,     0  )  ;", "return   GradientColorValue . temp ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue"}, {"methodBody": ["METHOD_START", "{", "int   startIndex    =     0  ;", "int   endIndex    =     -  1  ;", "float [  ]    timeline    =    this . timeline ;", "int   n    =    timeline . length ;", "for    ( int   i    =     1  ;    i    <    n ;    i +  +  )     {", "float   t    =    timeline [ i ]  ;", "if    ( t    >    percent )     {", "endIndex    =    i ;", "break ;", "}", "startIndex    =    i ;", "}", "float   startTime    =    timeline [ startIndex ]  ;", "startIndex    *  =     3  ;", "float   r 1     =    cs [ startIndex ]  ;", "float   g 1     =    cs [  ( startIndex    +     1  )  ]  ;", "float   b 1     =    cs [  ( startIndex    +     2  )  ]  ;", "if    ( endIndex    =  =     (  -  1  )  )     {", "out [ index ]     =    r 1  ;", "out [  ( index    +     1  )  ]     =    g 1  ;", "out [  ( index    +     2  )  ]     =    b 1  ;", "return ;", "}", "float   factor    =     ( percent    -    startTime )     /     (  ( timeline [ endIndex ]  )     -    startTime )  ;", "endIndex    *  =     3  ;", "out [ index ]     =    r 1     +     (  (  ( cs [ endIndex ]  )     -    r 1  )     *    factor )  ;", "out [  ( index    +     1  )  ]     =    g 1     +     (  (  ( cs [  ( endIndex    +     1  )  ]  )     -    g 1  )     *    factor )  ;", "out [  ( index    +     2  )  ]     =    b 1     +     (  (  ( cs [  ( endIndex    +     2  )  ]  )     -    b 1  )     *    factor )  ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue"}, {"methodBody": ["METHOD_START", "{", "return   colors ;", "}", "METHOD_END"], "methodName": ["getColors"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue"}, {"methodBody": ["METHOD_START", "{", "return   timeline ;", "}", "METHOD_END"], "methodName": ["getTimeline"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue"}, {"methodBody": ["METHOD_START", "{", "super . load ( value )  ;", "colors    =    new   float [ value . colors . length ]  ;", "System . arraycopy ( value . colors ,     0  ,    colors ,     0  ,    colors . length )  ;", "timeline    =    new   float [ value . timeline . length ]  ;", "System . arraycopy ( value . timeline ,     0  ,    timeline ,     0  ,    timeline . length )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue"}, {"methodBody": ["METHOD_START", "{", "this . colors    =    colors ;", "}", "METHOD_END"], "methodName": ["setColors"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue"}, {"methodBody": ["METHOD_START", "{", "this . timeline    =    timeline ;", "}", "METHOD_END"], "methodName": ["setTimeline"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue"}, {"methodBody": ["METHOD_START", "{", "this . setMesh ( mesh ,    null )  ;", "}", "METHOD_END"], "methodName": ["setMesh"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.MeshSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mesh . getVertexAttribute ( VertexAttributes . Usage . Position )  )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Mesh   vertices   must   have   Usage . Position \"  )  ;", "this . model    =    model ;", "this . mesh    =    mesh ;", "}", "METHOD_END"], "methodName": ["setMesh"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.MeshSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.NumericValue"}, {"methodBody": ["METHOD_START", "{", "super . load ( value )  ;", "thi    =    value . value ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.NumericValue"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.NumericValue"}, {"methodBody": ["METHOD_START", "{", "return   active ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ParticleValue"}, {"methodBody": ["METHOD_START", "{", "active    =    value . active ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ParticleValue"}, {"methodBody": ["METHOD_START", "{", "this . active    =    active ;", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ParticleValue"}, {"methodBody": ["METHOD_START", "{", "return   spawnDepthValue ;", "}", "METHOD_END"], "methodName": ["getSpawnDepth"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "return   spawnHeightValue ;", "}", "METHOD_END"], "methodName": ["getSpawnHeight"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "return   spawnWidthValue ;", "}", "METHOD_END"], "methodName": ["getSpawnWidth"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "return   edges ;", "}", "METHOD_END"], "methodName": ["isEdges"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "spawnWidthValue . setHigh ( width )  ;", "spawnHeightValue . setHigh ( height )  ;", "spawnDepthValue . setHigh ( depth )  ;", "}", "METHOD_END"], "methodName": ["setDimensions"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "this . edges    =    edges ;", "}", "METHOD_END"], "methodName": ["setEdges"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "return   lowMax ;", "}", "METHOD_END"], "methodName": ["getLowMax"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "return   lowMin ;", "}", "METHOD_END"], "methodName": ["getLowMin"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "super . load ( value )  ;", "lowMax    =    value . lowMax ;", "lowMin    =    value . lowMin ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "return    ( lowMin )     +     (  (  ( lowMax )     -     ( lowMin )  )     *     ( MathUtils . random (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newLowValue"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "lowMin    =    value ;", "lowMax    =    value ;", "}", "METHOD_END"], "methodName": ["setLow"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "lowMin    =    min ;", "lowMax    =    max ;", "}", "METHOD_END"], "methodName": ["setLow"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "this . lowMax    =    lowMax ;", "}", "METHOD_END"], "methodName": ["setLowMax"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "this . lowMin    =    lowMin ;", "}", "METHOD_END"], "methodName": ["setLowMin"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue"}, {"methodBody": ["METHOD_START", "{", "return   highMax ;", "}", "METHOD_END"], "methodName": ["getHighMax"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "return   highMin ;", "}", "METHOD_END"], "methodName": ["getHighMin"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "int   endIndex    =     -  1  ;", "int   n    =    timeline . length ;", "for    ( int   i    =     1  ;    i    <    n ;    i +  +  )     {", "float   t    =    timeline [ i ]  ;", "if    ( t    >    percent )     {", "endIndex    =    i ;", "break ;", "}", "}", "if    ( endIndex    =  =     (  -  1  )  )", "return   scaling [  ( n    -     1  )  ]  ;", "int   startIndex    =    endIndex    -     1  ;", "float   start    =    scaling [ startIndex ]  ;", "float   startTime    =    timeline [ startIndex ]  ;", "return   start    +     (  (  ( scaling [ endIndex ]  )     -    start )     *     (  ( percent    -    startTime )     /     (  ( timeline [ endIndex ]  )     -    startTime )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "return   scaling ;", "}", "METHOD_END"], "methodName": ["getScaling"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "return   timeline ;", "}", "METHOD_END"], "methodName": ["getTimeline"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "return   relative ;", "}", "METHOD_END"], "methodName": ["isRelative"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "super . load ( value )  ;", "highMax    =    value . highMax ;", "highMin    =    value . highMin ;", "scaling    =    new   float [ value . scaling . length ]  ;", "System . arraycopy ( value . scaling ,     0  ,    scaling ,     0  ,    scaling . length )  ;", "timeline    =    new   float [ value . timeline . length ]  ;", "System . arraycopy ( value . timeline ,     0  ,    timeline ,     0  ,    timeline . length )  ;", "relative    =    value . relative ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "return    ( highMin )     +     (  (  ( highMax )     -     ( highMin )  )     *     ( MathUtils . random (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newHighValue"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "highMin    =    value ;", "highMax    =    value ;", "}", "METHOD_END"], "methodName": ["setHigh"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "highMin    =    min ;", "highMax    =    max ;", "}", "METHOD_END"], "methodName": ["setHigh"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "this . highMax    =    highMax ;", "}", "METHOD_END"], "methodName": ["setHighMax"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "this . highMin    =    highMin ;", "}", "METHOD_END"], "methodName": ["setHighMin"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "this . relative    =    relative ;", "}", "METHOD_END"], "methodName": ["setRelative"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "this . scaling    =    values ;", "}", "METHOD_END"], "methodName": ["setScaling"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "this . timeline    =    timeline ;", "}", "METHOD_END"], "methodName": ["setTimeline"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue"}, {"methodBody": ["METHOD_START", "{", "spawnAux ( vector ,    percent )  ;", "if    ( xOffset . active )", "vector . x    +  =    xOffset . newLow (  )  ;", "if    ( yOffset . active )", "vector . y    +  =    yOffset . newLow (  )  ;", "if    ( zOffset . active )", "vector . z    +  =    zOffset . newLow (  )  ;", "return   vector ;", "}", "METHOD_END"], "methodName": ["spawn"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.SpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "distribution . clear (  )  ;", "VertexAttributes   attributes    =    mesh . getVertexAttributes (  )  ;", "int   indicesCount    =    mesh . getNumIndices (  )  ;", "int   vertexCount    =    mesh . getNumVertices (  )  ;", "int   vertexSize    =     (  ( short )     (  ( attributes . vertexSize )     /     4  )  )  ;", "int   positionOffset    =     (  ( short )     (  ( attributes . findByUsage ( VertexAttributes . Usage . Position )  . offset )     /     4  )  )  ;", "float [  ]    vertices    =    new   float [ vertexCount    *    vertexSize ]  ;", "mesh . getVertices ( vertices )  ;", "if    ( indicesCount    >     0  )     {", "short [  ]    indices    =    new   short [ indicesCount ]  ;", "mesh . getIndices ( indices )  ;", "for    ( int   i    =     0  ;    i    <    indicesCount ;    i    +  =     3  )     {", "int   p 1 Offset    =     (  ( indices [ i ]  )     *    vertexSize )     +    positionOffset ;", "int   p 2 Offset    =     (  ( indices [  ( i    +     1  )  ]  )     *    vertexSize )     +    positionOffset ;", "int   p 3 Offset    =     (  ( indices [  ( i    +     2  )  ]  )     *    vertexSize )     +    positionOffset ;", "float   x 1     =    vertices [ p 1 Offset ]  ;", "float   y 1     =    vertices [  ( p 1 Offset    +     1  )  ]  ;", "float   z 1     =    vertices [  ( p 1 Offset    +     2  )  ]  ;", "float   x 2     =    vertices [ p 2 Offset ]  ;", "float   y 2     =    vertices [  ( p 2 Offset    +     1  )  ]  ;", "float   z 2     =    vertices [  ( p 2 Offset    +     2  )  ]  ;", "float   x 3     =    vertices [ p 3 Offset ]  ;", "float   y 3     =    vertices [  ( p 3 Offset    +     1  )  ]  ;", "float   z 3     =    vertices [  ( p 3 Offset    +     2  )  ]  ;", "float   area    =    Math . abs (  (  (  (  ( x 1     *     ( y 2     -    y 3  )  )     +     ( x 2     *     ( y 3     -    y 1  )  )  )     +     ( x 3     *     ( y 1     -    y 2  )  )  )     /     2  .  0 F )  )  ;", "distribution . add ( new    . Triangle ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  ,    x 3  ,    y 3  ,    z 3  )  ,    area )  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i    +  =    vertexSize )     {", "int   p 1 Offset    =    i    +    positionOffset ;", "int   p 2 Offset    =    p 1 Offset    +    vertexSize ;", "int   p 3 Offset    =    p 2 Offset    +    vertexSize ;", "float   x 1     =    vertices [ p 1 Offset ]  ;", "float   y 1     =    vertices [  ( p 1 Offset    +     1  )  ]  ;", "float   z 1     =    vertices [  ( p 1 Offset    +     2  )  ]  ;", "float   x 2     =    vertices [ p 2 Offset ]  ;", "float   y 2     =    vertices [  ( p 2 Offset    +     1  )  ]  ;", "float   z 2     =    vertices [  ( p 2 Offset    +     2  )  ]  ;", "float   x 3     =    vertices [ p 3 Offset ]  ;", "float   y 3     =    vertices [  ( p 3 Offset    +     1  )  ]  ;", "float   z 3     =    vertices [  ( p 3 Offset    +     2  )  ]  ;", "float   area    =    Math . abs (  (  (  (  ( x 1     *     ( y 2     -    y 3  )  )     +     ( x 2     *     ( y 3     -    y 1  )  )  )     +     ( x 3     *     ( y 1     -    y 2  )  )  )     /     2  .  0 F )  )  ;", "distribution . add ( new    . Triangle ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  ,    x 3  ,    y 3  ,    z 3  )  ,    area )  ;", "}", "}", "distribution . generateNormalized (  )  ;", "}", "METHOD_END"], "methodName": ["calculateWeights"], "fileName": "com.badlogic.gdx.graphics.g3d.particles.values.WeightMeshSpawnShapeValue"}, {"methodBody": ["METHOD_START", "{", "tempArray . clear (  )  ;", "final   int   n    =    attsize (  )  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "tempArray . add ( attributes . get ( attget ( i )  . getKey (  )  ,     (  -  1  )  )  )  ;", "}", "tempArray . shrink (  )  ;", "return   tempArray . items ;", "}", "METHOD_END"], "methodName": ["getAttributeLocations"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return   uniforms . get ( id )  ;", "}", "METHOD_END"], "methodName": ["getUniformAlias"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    uniforms . size ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    ( uniformet ( i )  . equals ( alias )  )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getUniformID"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( inputID    >  =     0  )     &  &     ( inputID    <     ( locations . length )  )  )     &  &     (  ( locations [ inputID ]  )     >  =     0  )  ;", "}", "METHOD_END"], "methodName": ["has"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations )     !  =    null )", "throw   new   utils . GdxRuntimeException (  \" Already   initialized \"  )  ;", "if    (  !  ( program . isCompiled (  )  )  )", "throw   new   utils . GdxRuntimeException ( program . getLog (  )  )  ;", "this . program    =    program ;", "final   int   n    =    uniforms . size ;", "locations    =    new   int [ n ]  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "final   String   input    =    uniforms . get ( i )  ;", "final   BaseShader . Validator   validator    =    validators . get ( i )  ;", "final   BaseShader . Setter   setter    =    setters . get ( i )  ;", "if    (  ( validator    !  =    null )     &  &     (  !  ( validator . validate ( this ,    i ,    renderable )  )  )  )", "locations [ i ]     =     -  1  ;", "else    {", "locations [ i ]     =    program . fetchUniformLocation ( input ,    false )  ;", "if    (  (  ( locations [ i ]  )     >  =     0  )     &  &     ( setter    !  =    null )  )     {", "if    ( setter . isGlobal ( this ,    i )  )", "globalUniforms . add ( i )  ;", "else", "localUniforms . add ( i )  ;", "}", "}", "if    (  ( locations [ i ]  )     <     0  )     {", "validators . set ( i ,    null )  ;", "setters . set ( i ,    null )  ;", "}", "}", "if    ( renderable    !  =    null )     {", "final   VertexAttributes   attrs    =    renderable . meshPart . mesh . getVertexAttributes (  )  ;", "final   int   c    =    attrs . size (  )  ;", "for    ( int   i    =     0  ;    i    <    c ;    i +  +  )     {", "final   VertexAttribute   attr    =    attrs . get ( i )  ;", "final   int   location    =    program . getAttributeLocation ( attr . alias )  ;", "if    ( location    >  =     0  )", "attributes . put ( attr . getKey (  )  ,    location )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return    ( inputID    >  =     0  )     &  &     ( inputID    <     ( locations . length )  )     ?    locations [ inputID ]     :     -  1  ;", "}", "METHOD_END"], "methodName": ["loc"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return   register ( uniform ,    null )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return   register ( uniform . alias ,    uniform ,    setter )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return   register ( alias ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return   register ( alias ,    null ,    setter )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return   register ( alias ,    validator ,    null )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations )     !  =    null )", "throw   new   utils . GdxRuntimeException (  \" Cannot   register   an   uniform   after   initialization \"  )  ;", "final   int   existing    =    getUniformID ( alias )  ;", "if    ( existing    >  =     0  )     {", "validators . set ( existing ,    validator )  ;", "setters . set ( existing ,    setter )  ;", "return   existing ;", "}", "uniforms . add ( alias )  ;", "validators . add ( validator )  ;", "setters . add ( setter )  ;", "return    ( uniforms . size )     -     1  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "for    ( int   u ,    i    =     0  ;    i    <     ( localUniforms . size )  ;     +  + i )", "if    (  ( settget (  ( u    =    localUniforms . get ( i )  )  )  )     !  =    null )", "settget ( u )  . set ( this ,    u ,    renderable ,    combinedAttributes )  ;", "if    (  ( currentMesh )     !  =     ( renderable . meshPart . mesh )  )     {", "if    (  ( currentMesh )     !  =    null )", "currentMesh . unbind ( program ,    tempArray . items )  ;", "currentMesh    =    renderable . meshPart . mesh ;", "currentMesh . bind ( program ,    getAttributeLocations ( renderable . meshPart . mesh . getVertexAttributes (  )  )  )  ;", "}", "renderable . meshPart . render ( program ,    false )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformf ( locations [ uniform ]  ,    value )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformi ( locations [ uniform ]  ,    context . textureBinder . bind ( texture )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformi ( locations [ uniform ]  ,    context . textureBinder . bind ( textureDesc )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformMatrix ( locations [ uniform ]  ,    value )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformMatrix ( locations [ uniform ]  ,    value )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformf ( locations [ uniform ]  ,    value )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformf ( locations [ uniform ]  ,    value )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformf ( locations [ uniform ]  ,    value )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformf ( locations [ uniform ]  ,    v 1  ,    v 2  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformf ( locations [ uniform ]  ,    v 1  ,    v 2  ,    v 3  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformf ( locations [ uniform ]  ,    v 1  ,    v 2  ,    v 3  ,    v 4  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformi ( locations [ uniform ]  ,    value )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformi ( locations [ uniform ]  ,    v 1  ,    v 2  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformi ( locations [ uniform ]  ,    v 1  ,    v 2  ,    v 3  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( locations [ uniform ]  )     <     0  )", "return   false ;", "prom . setUniformi ( locations [ uniform ]  ,    v 1  ,    v 2  ,    v 3  ,    v 4  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.BaseShader"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &    flag )     =  =    flag ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "final   Environment   lights    =    renderable . environment ;", "final   DirectionalLightsAttribute   dla    =    attributes . get ( DirectionalLightsAttribute . class ,    DirectionalLightsAttribute . Type )  ;", "final   Array < DirectionalLight >    dirs    =     ( dla    =  =    null )     ?    null    :    dla . lights ;", "final   PointLightsAttribute   pla    =    attributes . get ( PointLightsAttribute . class ,    PointLightsAttribute . Type )  ;", "final   Array < PointLight >    points    =     ( pla    =  =    null )     ?    null    :    pla . lights ;", "final   SpotLightsAttribute   sla    =    attributes . get ( SpotLightsAttribute . class ,    SpotLightsAttribute . Type )  ;", "final   Array < SpotLight >    spots    =     ( sla    =  =    null )     ?    null    :    sla . lights ;", "if    (  ( dirLightsLoc )     >  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( directionalLights . length )  ;    i +  +  )     {", "if    (  ( dirs    =  =    null )     |  |     ( i    >  =     ( dirs . size )  )  )     {", "if    (  (  (  ( lightsSet )     &  &     (  ( directionalLights [ i ]  . color . r )     =  =     0  .  0 F )  )     &  &     (  ( directionalLights [ i ]  . color . g )     =  =     0  .  0 F )  )     &  &     (  ( directionalLights [ i ]  . color . b )     =  =     0  .  0 F )  )", "continue ;", "directionalLights [ i ]  . color . set (  0  ,     0  ,     0  ,     1  )  ;", "} else", "if    (  ( lightsSet )     &  &     ( directionalLights [ i ]  . equals ( dirs . get ( i )  )  )  )", "continue ;", "else", "directionalLights [ i ]  . set ( dirs . get ( i )  )  ;", "int   idx    =     ( dirLightsLoc )     +     ( i    *     ( dirLightsSize )  )  ;", "program . setUniformf (  ( idx    +     ( dirLightsColorOffset )  )  ,    directionalLights [ i ]  . color . r ,    directionalLights [ i ]  . color . g ,    directionalLights [ i ]  . color . b )  ;", "program . setUniformf (  ( idx    +     ( dirLightsDirectionOffset )  )  ,    directionalLights [ i ]  . direction . x ,    directionalLights [ i ]  . direction . y ,    directionalLights [ i ]  . direction . z )  ;", "if    (  ( dirLightsSize )     <  =     0  )", "break ;", "}", "}", "if    (  ( pointLightsLoc )     >  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( pointLights . length )  ;    i +  +  )     {", "if    (  ( points    =  =    null )     |  |     ( i    >  =     ( points . size )  )  )     {", "if    (  ( lightsSet )     &  &     (  ( pointLights [ i ]  . intensity )     =  =     0  .  0 F )  )", "continue ;", "pointLights [ i ]  . intensity    =     0  .  0 F ;", "} else", "if    (  ( lightsSet )     &  &     ( pointLights [ i ]  . equals ( points . get ( i )  )  )  )", "continue ;", "else", "pointLights [ i ]  . set ( points . get ( i )  )  ;", "int   idx    =     ( pointLightsLoc )     +     ( i    *     ( pointLightsSize )  )  ;", "program . setUniformf (  ( idx    +     ( pointLightsColorOffset )  )  ,     (  ( pointLights [ i ]  . color . r )     *     ( pointLights [ i ]  . intensity )  )  ,     (  ( pointLights [ i ]  . color . g )     *     ( pointLights [ i ]  . intensity )  )  ,     (  ( pointLights [ i ]  . color . b )     *     ( pointLights [ i ]  . intensity )  )  )  ;", "program . setUniformf (  ( idx    +     ( pointLightsPositionOffset )  )  ,    pointLights [ i ]  . position . x ,    pointLights [ i ]  . position . y ,    pointLights [ i ]  . position . z )  ;", "if    (  ( pointLightsIntensityOffset )     >  =     0  )", "program . setUniformf (  ( idx    +     ( pointLightsIntensityOffset )  )  ,    pointLights [ i ]  . intensity )  ;", "if    (  ( pointLightsSize )     <  =     0  )", "break ;", "}", "}", "if    (  ( spotLightsLoc )     >  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( spotLights . length )  ;    i +  +  )     {", "if    (  ( spots    =  =    null )     |  |     ( i    >  =     ( spots . size )  )  )     {", "if    (  ( lightsSet )     &  &     (  ( spotLights [ i ]  . intensity )     =  =     0  .  0 F )  )", "continue ;", "spotLights [ i ]  . intensity    =     0  .  0 F ;", "} else", "if    (  ( lightsSet )     &  &     ( spotLights [ i ]  . equals ( spots . get ( i )  )  )  )", "continue ;", "else", "spotLights [ i ]  . set ( spots . get ( i )  )  ;", "int   idx    =     ( spotLightsLoc )     +     ( i    *     ( spotLightsSize )  )  ;", "program . setUniformf (  ( idx    +     ( spotLightsColorOffset )  )  ,     (  ( spotLights [ i ]  . color . r )     *     ( spotLights [ i ]  . intensity )  )  ,     (  ( spotLights [ i ]  . color . g )     *     ( spotLights [ i ]  . intensity )  )  ,     (  ( spotLights [ i ]  . color . b )     *     ( spotLights [ i ]  . intensity )  )  )  ;", "program . setUniformf (  ( idx    +     ( spotLightsPositionOffset )  )  ,    spotLights [ i ]  . position )  ;", "program . setUniformf (  ( idx    +     ( spotLightsDirectionOffset )  )  ,    spotLights [ i ]  . direction )  ;", "program . setUniformf (  ( idx    +     ( spotLightsCutoffAngleOffset )  )  ,    spotLights [ i ]  . cutoffAngle )  ;", "program . setUniformf (  ( idx    +     ( spotLightsExponentOffset )  )  ,    spotLights [ i ]  . exponent )  ;", "if    (  ( spotLightsIntensityOffset )     >  =     0  )", "program . setUniformf (  ( idx    +     ( spotLightsIntensityOffset )  )  ,    spotLights [ i ]  . intensity )  ;", "if    (  ( spotLightsSize )     <  =     0  )", "break ;", "}", "}", "if    ( attributes . has ( ColorAttribute . Fog )  )     {", "set ( u _ fogColor ,     (  ( ColorAttribute )     ( attributes . get ( ColorAttribute . Fog )  )  )  . color )  ;", "}", "if    (  ( lights    !  =    null )     &  &     (  ( lightsowMap )     !  =    null )  )     {", "set ( uowMapProjViewTrans ,    lightsowMap . getProjViewTrans (  )  )  ;", "set ( uowTexture ,    lightsowMap . getDepthMap (  )  )  ;", "set ( uowPCFOffset ,     (  1  .  0 F    /     (  2  .  0 F    *     ( lightsowMap . getDepthMap (  )  . texture . getWidth (  )  )  )  )  )  ;", "}", "lightsSet    =    true ;", "}", "METHOD_END"], "methodName": ["bindLights"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "int   cullFace    =     (  ( config . defaultCullFace )     =  =     (  -  1  )  )     ?    DefaultShader . defaultCullFace    :    config . defaultCullFace ;", "int   depthFunc    =     (  ( config . defaultDepthFunc )     =  =     (  -  1  )  )     ?    DefaultShader . defaultDepthFunc    :    config . defaultDepthFunc ;", "float   depthRangeNear    =     0  .  0 F ;", "float   depthRangeFar    =     1  .  0 F ;", "boolean   depthMask    =    true ;", "for    ( final   Attribute   attr    :    attributes )     {", "final   long   t    =    attr . type ;", "if    ( BlendingAttribute . is ( t )  )     {", "context . setBlending ( true ,     (  ( BlendingAttribute )     ( attr )  )  . sourceFunction ,     (  ( BlendingAttribute )     ( attr )  )  . destFunction )  ;", "set ( u _ opacity ,     (  ( BlendingAttribute )     ( attr )  )  . opacity )  ;", "} else", "if    (  ( t    &     ( attributes . IntAttribute . CullFace )  )     =  =     ( attributes . IntAttribute . CullFace )  )", "cullFace    =     (  ( attributes . IntAttribute )     ( attr )  )  . value ;", "else", "if    (  ( t    &     ( attributes . FloatAttribute . AlphaTest )  )     =  =     ( attributes . FloatAttribute . AlphaTest )  )", "set ( u _ alphaTest ,     (  ( attributes . FloatAttribute )     ( attr )  )  . value )  ;", "else", "if    (  ( t    &     ( attributes . DepthTestAttribute . Type )  )     =  =     ( attributes . DepthTestAttribute . Type )  )     {", "attributes . DepthTestAttribute   dta    =     (  ( attributes . DepthTestAttribute )     ( attr )  )  ;", "depthFunc    =    dta . depthFunc ;", "depthRangeNear    =    dta . depthRangeNear ;", "depthRangeFar    =    dta . depthRangeFar ;", "depthMask    =    dta . depthMask ;", "} else", "if    (  !  ( config . ignoreUnimplemented )  )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  \" Unknown   material   attribute :     \"     +     ( attr . toString (  )  )  )  )  ;", "}", "context . setCullFace ( cullFace )  ;", "context . setDepthTest ( depthFunc ,    depthRangeNear ,    depthRangeFar )  ;", "context . setDepthMask ( depthMask )  ;", "}", "METHOD_END"], "methodName": ["bindMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "long   mask    =     0  ;", "if    (  ( renable . environment )     !  =    null )", "mask    |  =    renable . environment . getMask (  )  ;", "if    (  ( renable . material )     !  =    null )", "mask    |  =    renable . material . getMask (  )  ;", "return   mask ;", "}", "METHOD_END"], "methodName": ["combineAttributeMasks"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "DefaultShader . tmpAttributes . clear (  )  ;", "if    (  ( renderable . environment )     !  =    null )", "DefaultShader . tmpAttributes . set ( renderable . environment )  ;", "if    (  ( renderable . material )     !  =    null )", "DefaultShader . tmpAttributes . set ( renderable . material )  ;", "return   DefaultShader . tmpAttributes ;", "}", "METHOD_END"], "methodName": ["combineAttributes"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "final   Attributes   attributes    =    DefaultShader . combineAttributes ( renderable )  ;", "String   prefix    =     \"  \"  ;", "final   long   attributesMask    =    attributes . getMask (  )  ;", "final   long   vertexMask    =    renderable . meshPart . mesh . getVertexAttributes (  )  . getMask (  )  ;", "if    ( DefaultShader . and ( vertexMask ,    VertexAttributes . Usage . Position )  )", "prefix    +  =     \"  # define   positionFlag \\ n \"  ;", "if    ( DefaultShader . or ( vertexMask ,     (  ( VertexAttributes . Usage . ColorUnpacked )     |     ( VertexAttributes . Usage . ColorPacked )  )  )  )", "prefix    +  =     \"  # define   colorFlag \\ n \"  ;", "if    ( DefaultShader . and ( vertexMask ,    VertexAttributes . Usage . BiNormal )  )", "prefix    +  =     \"  # define   binormalFlag \\ n \"  ;", "if    ( DefaultShader . and ( vertexMask ,    VertexAttributes . Usage . Tangent )  )", "prefix    +  =     \"  # define   tangentFlag \\ n \"  ;", "if    ( DefaultShader . and ( vertexMask ,    VertexAttributes . Usage . Normal )  )", "prefix    +  =     \"  # define   normalFlag \\ n \"  ;", "if    (  ( DefaultShader . and ( vertexMask ,    VertexAttributes . Usage . Normal )  )     |  |     ( DefaultShader . and ( vertexMask ,     (  ( VertexAttributes . Usage . Tangent )     |     ( VertexAttributes . Usage . BiNormal )  )  )  )  )     {", "if    (  ( renderable . environment )     !  =    null )     {", "prefix    +  =     \"  # define   lightingFlag \\ n \"  ;", "prefix    +  =     \"  # define   ambientCubemapFlag \\ n \"  ;", "prefix    +  =     (  \"  # define   numDirectionalLights    \"     +     ( config . numDirectionalLights )  )     +     \"  \\ n \"  ;", "prefix    +  =     (  \"  # define   numPointLights    \"     +     ( config . numPointLights )  )     +     \"  \\ n \"  ;", "prefix    +  =     (  \"  # define   numSpotLights    \"     +     ( config . numSpotLights )  )     +     \"  \\ n \"  ;", "if    ( attributes . has ( ColorAttribute . Fog )  )     {", "prefix    +  =     \"  # define   fogFlag \\ n \"  ;", "}", "if    (  ( renderable . environment . shadowMap )     !  =    null )", "prefix    +  =     \"  # define   shadowMapFlag \\ n \"  ;", "if    ( attributes . has ( CubemapAttribute . EnvironmentMap )  )", "prefix    +  =     \"  # define   environmentCubemapFlag \\ n \"  ;", "}", "}", "final   int   n    =    renderable . meshPart . mesh . getVertexAttributes (  )  . size (  )  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "final   VertexAttribute   attr    =    renderable . meshPart . mesh . getVertexAttributes (  )  . get ( i )  ;", "if    (  ( attr . usage )     =  =     ( VertexAttributes . Usage . BoneWeight )  )", "prefix    +  =     (  \"  # define   boneWeight \"     +     ( attr . unit )  )     +     \" Flag \\ n \"  ;", "else", "if    (  ( attr . usage )     =  =     ( VertexAttributes . Usage . TextureCoordinates )  )", "prefix    +  =     (  \"  # define   texCoord \"     +     ( attr . unit )  )     +     \" Flag \\ n \"  ;", "}", "if    (  ( attributesMask    &     ( BlendingAttribute . Type )  )     =  =     ( BlendingAttribute . Type )  )", "prefix    +  =     (  \"  # define    \"     +     ( BlendingAttribute . Alias )  )     +     \" Flag \\ n \"  ;", "if    (  ( attributesMask    &     ( TextureAttribute . Diffuse )  )     =  =     ( TextureAttribute . Diffuse )  )     {", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . DiffuseAlias )  )     +     \" Flag \\ n \"  ;", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . DiffuseAlias )  )     +     \" Coord   texCoord 0  \\ n \"  ;", "}", "if    (  ( attributesMask    &     ( TextureAttribute . Specular )  )     =  =     ( TextureAttribute . Specular )  )     {", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . SpecularAlias )  )     +     \" Flag \\ n \"  ;", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . SpecularAlias )  )     +     \" Coord   texCoord 0  \\ n \"  ;", "}", "if    (  ( attributesMask    &     ( TextureAttribute . Normal )  )     =  =     ( TextureAttribute . Normal )  )     {", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . NormalAlias )  )     +     \" Flag \\ n \"  ;", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . NormalAlias )  )     +     \" Coord   texCoord 0  \\ n \"  ;", "}", "if    (  ( attributesMask    &     ( TextureAttribute . Emissive )  )     =  =     ( TextureAttribute . Emissive )  )     {", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . EmissiveAlias )  )     +     \" Flag \\ n \"  ;", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . EmissiveAlias )  )     +     \" Coord   texCoord 0  \\ n \"  ;", "}", "if    (  ( attributesMask    &     ( TextureAttribute . Reflection )  )     =  =     ( TextureAttribute . Reflection )  )     {", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . ReflectionAlias )  )     +     \" Flag \\ n \"  ;", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . ReflectionAlias )  )     +     \" Coord   texCoord 0  \\ n \"  ;", "}", "if    (  ( attributesMask    &     ( TextureAttribute . Ambient )  )     =  =     ( TextureAttribute . Ambient )  )     {", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . AmbientAlias )  )     +     \" Flag \\ n \"  ;", "prefix    +  =     (  \"  # define    \"     +     ( TextureAttribute . AmbientAlias )  )     +     \" Coord   texCoord 0  \\ n \"  ;", "}", "if    (  ( attributesMask    &     ( ColorAttribute . Diffuse )  )     =  =     ( ColorAttribute . Diffuse )  )", "prefix    +  =     (  \"  # define    \"     +     ( ColorAttribute . DiffuseAlias )  )     +     \" Flag \\ n \"  ;", "if    (  ( attributesMask    &     ( ColorAttribute . Specular )  )     =  =     ( ColorAttribute . Specular )  )", "prefix    +  =     (  \"  # define    \"     +     ( ColorAttribute . SpecularAlias )  )     +     \" Flag \\ n \"  ;", "if    (  ( attributesMask    &     ( ColorAttribute . Emissive )  )     =  =     ( ColorAttribute . Emissive )  )", "prefix    +  =     (  \"  # define    \"     +     ( ColorAttribute . EmissiveAlias )  )     +     \" Flag \\ n \"  ;", "if    (  ( attributesMask    &     ( ColorAttribute . Reflection )  )     =  =     ( ColorAttribute . Reflection )  )", "prefix    +  =     (  \"  # define    \"     +     ( ColorAttribute . ReflectionAlias )  )     +     \" Flag \\ n \"  ;", "if    (  ( attributesMask    &     ( FloatAttribute . Shininess )  )     =  =     ( FloatAttribute . Shininess )  )", "prefix    +  =     (  \"  # define    \"     +     ( FloatAttribute . ShininessAlias )  )     +     \" Flag \\ n \"  ;", "if    (  ( attributesMask    &     ( FloatAttribute . AlphaTest )  )     =  =     ( FloatAttribute . AlphaTest )  )", "prefix    +  =     (  \"  # define    \"     +     ( FloatAttribute . AlphaTestAlias )  )     +     \" Flag \\ n \"  ;", "if    (  (  ( renderable . bones )     !  =    null )     &  &     (  ( config . numBones )     >     0  )  )", "prefix    +  =     (  \"  # define   numBones    \"     +     ( config . numBones )  )     +     \"  \\ n \"  ;", "return   prefix ;", "}", "METHOD_END"], "methodName": ["createPrefix"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "return   obj    =  =     ( this )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "return    ( config . defaultCullFace )     =  =     (  -  1  )     ?    DefaultShader . defaultCullFace    :    config . defaultCullFace ;", "}", "METHOD_END"], "methodName": ["getDefaultCullFace"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "return    ( config . defaultDepthFunc )     =  =     (  -  1  )     ?    DefaultShader . defaultDepthFunc    :    config . defaultDepthFunc ;", "}", "METHOD_END"], "methodName": ["getDefaultDepthFunc"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DefaultShader . defaultFragmentShader )     =  =    null )", "DefaultShader . defaultFragmentShader    =    Gdx . files . classpath (  \" graphics / g 3 d / shaders / default . fragment . glsl \"  )  . readString (  )  ;", "return   DefaultShader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DefaultShader . defaultVertexShader )     =  =    null )", "DefaultShader . defaultVertexShader    =    Gdx . files . classpath (  \" graphics / g 3 d / shaders / default . vertex . glsl \"  )  . readString (  )  ;", "return   DefaultShader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "return    ( mask    &    flag )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["or"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "config . defaultCullFace    =    cullFace ;", "}", "METHOD_END"], "methodName": ["setDefaultCullFace"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "config . defaultDepthFunc    =    depthFunc ;", "}", "METHOD_END"], "methodName": ["setDefaultDepthFunc"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DefaultShader"}, {"methodBody": ["METHOD_START", "{", "DepthShader . tmpAttributes . clear (  )  ;", "if    (  ( renderable . environment )     !  =    null )", "DepthShader . tmpAttributes . set ( renderable . environment )  ;", "if    (  ( renderable . material )     !  =    null )", "DepthShader . tmpAttributes . set ( renderable . material )  ;", "return   DepthShader . tmpAttributes ;", "}", "METHOD_END"], "methodName": ["combineAttributes"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DepthShader"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =    DefaultShader . createPrefix ( renderable ,    config )  ;", "if    (  !  ( config . depthBufferOnly )  )", "prefix    +  =     \"  # define   PackedDepthFlag \\ n \"  ;", "return   prefix ;", "}", "METHOD_END"], "methodName": ["createPrefix"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DepthShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DepthShader . defaultFragmentShader )     =  =    null )", "DepthShader . defaultFragmentShader    =    Gdx . files . classpath (  \" graphics / g 3 d / shaders / depth . fragment . glsl \"  )  . readString (  )  ;", "return   DepthShader . defaultFragmentShader ;", "}", "METHOD_END"], "methodName": ["getDefaultFragmentShader"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DepthShader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DepthShader . defaultVertexShader )     =  =    null )", "DepthShader . defaultVertexShader    =    Gdx . files . classpath (  \" graphics / g 3 d / shaders / depth . vertex . glsl \"  )  . readString (  )  ;", "return   DepthShader . defaultVertexShader ;", "}", "METHOD_END"], "methodName": ["getDefaultVertexShader"], "fileName": "com.badlogic.gdx.graphics.g3d.shaders.DepthShader"}, {"methodBody": ["METHOD_START", "{", "return   action ( obtain ( anim ,    offset ,    duration ,    loopCount ,    speed ,    listener )  ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( anim . loopCount )     <     0  )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" An   action   cannot   be   continuous \"  )  ;", "if    (  (  ( current )     =  =    null )     |  |     (  ( current . loopCount )     =  =     0  )  )", "animate ( anim ,    transitionTime )  ;", "else    {", ". AnimationDesc   toQueue    =     ( inAction )     ?    null    :    obtain ( current )  ;", "inAction    =    false ;", "animate ( anim ,    transitionTime )  ;", "inAction    =    true ;", "if    ( toQueue    !  =    null )", "queue ( toQueue ,    transitionTime )  ;", "}", "return   anim ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   action ( obtain ( id ,    offset ,    duration ,    loopCount ,    speed ,    listener )  ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   action ( id ,     0  ,     (  -  1  .  0 F )  ,    loopCount ,    speed ,    listener ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   animate ( obtain ( anim ,    offset ,    duration ,    loopCount ,    speed ,    listener )  ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     =  =    null )", "current    =    anim ;", "else", "if    ( inAction )", "queue ( anim ,    transitionTime )  ;", "else", "if    (  (  (  !  ( allowSame )  )     &  &     ( anim    !  =    null )  )     &  &     (  ( current . animation )     =  =     ( anim . animation )  )  )     {", "anim . time    =    current . time ;", "animationPool . free ( current )  ;", "current    =    anim ;", "} else    {", "if    (  ( previous )     !  =    null )     {", "remove ( previous . animation )  ;", "animationPool . free ( previous )  ;", "}", "previous    =    current ;", "current    =    anim ;", "transitionCurrentTime    =     0  .  0 F ;", "transitionTargetTime    =    transitionTime ;", "}", "return   anim ;", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   animate ( id ,     1  ,     1  .  0 F ,    listener ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   animate ( id ,     1  ,     1  .  0 F ,    null ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   animate ( obtain ( id ,    offset ,    duration ,    loopCount ,    speed ,    listener )  ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   animate ( id ,    loopCount ,     1  .  0 F ,    listener ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   animate ( id ,     0  .  0 F ,     (  -  1  .  0 F )  ,    loopCount ,    speed ,    listener ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["animate"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    ( anim    =  =    null )", "return   null ;", "final    . AnimationDesc   result    =    animationPool . obtain (  )  ;", "result . animation    =    anim ;", "result . listener    =    listener ;", "result . loopCount    =    loopCount ;", "result . speed    =    speed ;", "result . offset    =    offset ;", "result . duration    =     ( duration    <     0  )     ?     ( anim . duration )     -    offset    :    duration ;", "result . time    =     ( speed    <     0  )     ?    result . duration    :     0  .  0 F ;", "return   result ;", "}", "METHOD_END"], "methodName": ["obtain"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   obtain ( anim . animation ,    anim . offset ,    anim . duration ,    anim . loopCount ,    anim . speed ,    anim . listener )  ;", "}", "METHOD_END"], "methodName": ["obtain"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    ( id    =  =    null )", "return   null ;", "final   Animation   anim    =    target . getAnimation ( id )  ;", "if    ( anim    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Unknown   animation :     \"     +    id )  )  ;", "return   obtain ( anim ,    offset ,    duration ,    loopCount ,    speed ,    listener )  ;", "}", "METHOD_END"], "methodName": ["obtain"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   queue ( obtain ( anim ,    offset ,    duration ,    loopCount ,    speed ,    listener )  ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["queue"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( current )     =  =    null )     |  |     (  ( current . loopCount )     =  =     0  )  )", "animate ( anim ,    transitionTime )  ;", "else    {", "if    (  ( queued )     !  =    null )", "aPool . free ( queued )  ;", "queued    =    anim ;", "queuedTransitionTime    =    transitionTime ;", "if    (  ( current . loopCount )     <     0  )", "current . loopCount    =     1  ;", "}", "return   anim ;", "}", "METHOD_END"], "methodName": ["queue"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   queue ( obtain ( id ,    offset ,    duration ,    loopCount ,    speed ,    listener )  ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["queue"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   queue ( id ,     0  .  0 F ,     (  -  1  .  0 F )  ,    loopCount ,    speed ,    listener ,    transitionTime )  ;", "}", "METHOD_END"], "methodName": ["queue"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   setAnimation ( obtain ( anim ,    offset ,    duration ,    loopCount ,    speed ,    listener )  )  ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     =  =    null )", "current    =    anim ;", "else    {", "if    (  (  (  !  ( allowSame )  )     &  &     ( anim    !  =    null )  )     &  &     (  ( current . animation )     =  =     ( anim . animation )  )  )", "anim . time    =    current . time ;", "else", "remove ( current . animation )  ;", "animationPool . free ( current )  ;", "current    =    anim ;", "}", "justChanged    =    true ;", "return   anim ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   setAnimation ( id ,     1  ,     1  .  0 F ,    null )  ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   setAnimation ( id ,     1  ,     1  .  0 F ,    listener )  ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   setAnimation ( obtain ( id ,    offset ,    duration ,    loopCount ,    speed ,    listener )  )  ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   setAnimation ( id ,    loopCount ,     1  .  0 F ,    null )  ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   setAnimation ( id ,    loopCount ,     1  .  0 F ,    listener )  ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "return   setAnimation ( id ,     0  .  0 F ,     (  -  1  .  0 F )  ,    loopCount ,    speed ,    listener )  ;", "}", "METHOD_END"], "methodName": ["setAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    ( paused )", "return ;", "if    (  (  ( previous )     !  =    null )     &  &     (  ( transitionCurrentTime    +  =    delta )     >  =     ( transitionTargetTime )  )  )     {", "remove ( previous . animation )  ;", "justChanged    =    true ;", "animationPool . free ( previous )  ;", "previous    =    null ;", "}", "if    ( justChanged )     {", "target . calculateTransforms (  )  ;", "justChanged    =    false ;", "}", "if    (  (  (  ( current )     =  =    null )     |  |     (  ( current . loopCount )     =  =     0  )  )     |  |     (  ( current . animation )     =  =    null )  )", "return ;", "final   float   remain    =    current . update ( delta )  ;", "if    (  ( remain    !  =     0  .  0 F )     &  &     (  ( queued )     !  =    null )  )     {", "inAction    =    false ;", "animate ( queued ,    queuedTransitionTime )  ;", "queued    =    null ;", "update ( remain )  ;", "return ;", "}", "if    (  ( previous )     !  =    null )", "applys ( previous . animation ,     (  ( previous . offset )     +     ( previous . time )  )  ,    current . animation ,     (  ( current . offset )     +     ( current . time )  )  ,     (  ( transitionCurrentTime )     /     ( transitionTargetTime )  )  )  ;", "else", "apply ( current . animation ,     (  ( current . offset )     +     ( current . time )  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.AnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( applying )  )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" You   must   call   begin (  )    before   adding   an   animation \"  )  ;", ". applyAnimation (  . transforms ,    transformPool ,    weight ,    animation ,    time )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    ( applying )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" Call   end (  )    first \"  )  ;", ". applyAnimation ( null ,    null ,     1  .  0 F ,    animation ,    time )  ;", "target . calculateTransforms (  )  ;", "}", "METHOD_END"], "methodName": ["applyAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    ( out    =  =    null )     {", "for    ( final   NodeAnimation   nodeAnim    :    animation . nodeAnimations )", ". applyNodeAnimationDirectly ( nodeAnim ,    time )  ;", "} else    {", "for    ( final   Node   node    :    out . keys (  )  )", "node . isAnimated    =    false ;", "for    ( final   NodeAnimation   nodeAnim    :    animation . nodeAnimations )", ". applyNodeAnimationBlending ( nodeAnim ,    out ,    pool ,    alpha ,    time )  ;", "for    ( final   ObjectMap . Entry < Node ,     . Transform >    e    :    out . entries (  )  )     {", "if    (  !  ( e . key . isAnimated )  )     {", "e . key . isAnimated    =    true ;", "e . value . lerp ( e . key . translation ,    e . key . rotation ,    e . key . scale ,    alpha )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["applyAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( anim 2     =  =    null )     |  |     ( weight    =  =     0  .  0 F )  )", "applyAnimation ( anim 1  ,    time 1  )  ;", "else", "if    (  ( anim 1     =  =    null )     |  |     ( weight    =  =     1  .  0 F )  )", "applyAnimation ( anim 2  ,    time 2  )  ;", "else", "if    ( applying )", "throw   new   utils . GdxRuntimeException (  \" Call   end (  )    first \"  )  ;", "else    {", "begin (  )  ;", "apply ( anim 1  ,    time 1  ,     1  .  0 F )  ;", "apply ( anim 2  ,    time 2  ,    weight )  ;", "end (  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyAnimations"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "final   Node   node    =    nodeAnim . node ;", "node . isAnimated    =    true ;", "final    . Transform   transform    =     . getNodeAnimationTransform ( nodeAnim ,    time )  ;", ". Transform   t    =    out . get ( node ,    null )  ;", "if    ( t    !  =    null )     {", "if    ( alpha    >     0  .  9  9  9  9  9  9 F )", "t . set ( transform )  ;", "else", "t . lerp ( transform ,    alpha )  ;", "} else    {", "if    ( alpha    >     0  .  9  9  9  9  9  9 F )", "out . put ( node ,    pool . obtain (  )  . set ( transform )  )  ;", "else", "out . put ( node ,    pool . obtain (  )  . set ( node . translation ,    node . rotation ,    node . scale )  . lerp ( transform ,    alpha )  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyNodeAnimationBlending"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "final   Node   node    =    nodeAnim . node ;", "node . isAnimated    =    true ;", "final    . Transform   transform    =     . getNodeAnimationTransform ( nodeAnim ,    time )  ;", "transform . toMatrix 4  ( node . localTransform )  ;", "}", "METHOD_END"], "methodName": ["applyNodeAnimationDirectly"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    ( applying )", "throw   new   utils . GdxRuntimeException (  \" You   must   call   end (  )    after   each   call   to   being (  )  \"  )  ;", "applying    =    true ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( applying )  )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" You   must   call   begin (  )    first \"  )  ;", "for    ( ObjectMap . Entry < Node ,     . Transform >    entry    :     . transforms . entries (  )  )     {", "entry . value . toMatrix 4  ( entry . key . localTransform )  ;", "transformPool . free ( entry . value )  ;", "}", ". transforms . clear (  )  ;", "target . calculateTransforms (  )  ;", "applying    =    false ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =     ( arr . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "if    (  ( time    >  =     ( arr . get ( i )  . keytime )  )     &  &     ( time    <  =     ( arr . get (  ( i    +     1  )  )  . keytime )  )  )     {", "return   i ;", "}", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["getFirstKeyframeIndexAtTime"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "final   BaseAnimationController . Transform   transform    =    BaseAnimationController . tmpT ;", "BaseAnimationController . getTranslationAtTime ( nodeAnim ,    time ,    transform . translation )  ;", "BaseAnimationController . getRotationAtTime ( nodeAnim ,    time ,    transform . rotation )  ;", "BaseAnimationController . getScalingAtTime ( nodeAnim ,    time ,    transform . scale )  ;", "return   transform ;", "}", "METHOD_END"], "methodName": ["getNodeAnimationTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nodeAnim . rotation )     =  =    null )", "return   out . set ( nodeAnim . node . rotation )  ;", "if    (  ( nodeAnim . rotation . size )     =  =     1  )", "return   out . set ( nodeAnim . rotation . get (  0  )  . value )  ;", "int   index    =     . getFirstKeyframeIndexAtTime ( nodeAnim . rotation ,    time )  ;", "final   NodeKeyframe   firstKeyframe    =    nodeAnim . rotation . get ( index )  ;", "out . set (  (  ( Quaternion )     ( firstKeyframe . value )  )  )  ;", "if    (  (  +  + index )     <     ( nodeAnim . rotation . size )  )     {", "final   NodeKeyframe < Quaternion >    secondKeyframe    =    nodeAnim . rotation . get ( index )  ;", "final   float   t    =     ( time    -     ( firstKeyframe . keytime )  )     /     (  ( secondKeyframe . keytime )     -     ( firstKeyframe . keytime )  )  ;", "out . slerp ( secondKeyframe . value ,    t )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["getRotationAtTime"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nodeAnim . scaling )     =  =    null )", "return   out . set ( nodeAnim . node . scale )  ;", "if    (  ( nodeAnim . scaling . size )     =  =     1  )", "return   out . set ( nodeAnim . scaling . get (  0  )  . value )  ;", "int   index    =     . getFirstKeyframeIndexAtTime ( nodeAnim . scaling ,    time )  ;", "final   NodeKeyframe   firstKeyframe    =    nodeAnim . scaling . get ( index )  ;", "out . set (  (  ( Vector 3  )     ( firstKeyframe . value )  )  )  ;", "if    (  (  +  + index )     <     ( nodeAnim . scaling . size )  )     {", "final   NodeKeyframe < Vector 3  >    secondKeyframe    =    nodeAnim . scaling . get ( index )  ;", "final   float   t    =     ( time    -     ( firstKeyframe . keytime )  )     /     (  ( secondKeyframe . keytime )     -     ( firstKeyframe . keytime )  )  ;", "out . lerp ( secondKeyframe . value ,    t )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["getScalingAtTime"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nodeAnim . translation )     =  =    null )", "return   out . set ( nodeAnim . node . translation )  ;", "if    (  ( nodeAnim . translation . size )     =  =     1  )", "return   out . set ( nodeAnim . translation . get (  0  )  . value )  ;", "int   index    =     . getFirstKeyframeIndexAtTime ( nodeAnim . translation ,    time )  ;", "final   NodeKeyframe   firstKeyframe    =    nodeAnim . translation . get ( index )  ;", "out . set (  (  ( Vector 3  )     ( firstKeyframe . value )  )  )  ;", "if    (  (  +  + index )     <     ( nodeAnim . translation . size )  )     {", "final   NodeKeyframe < Vector 3  >    secondKeyframe    =    nodeAnim . translation . get ( index )  ;", "final   float   t    =     ( time    -     ( firstKeyframe . keytime )  )     /     (  ( secondKeyframe . keytime )     -     ( firstKeyframe . keytime )  )  ;", "out . lerp ( secondKeyframe . value ,    t )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["getTranslationAtTime"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "for    ( final   NodeAnimation   nodeAnim    :    animation . nodeAnimations )     {", "nodeAnim . node . isAnimated    =    false ;", "}", "}", "METHOD_END"], "methodName": ["removeAnimation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.BaseAnimationController"}, {"methodBody": ["METHOD_START", "{", "return   zoom (  (  ( pinchZoomFactor )     *    amount )  )  ;", "}", "METHOD_END"], "methodName": ["pinchZoom"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.CameraInputController"}, {"methodBody": ["METHOD_START", "{", "if    ( button    =  =     ( rotateButton )  )     {", "tmpV 1  . set ( c . direction )  . crs ( c . up )  . y    =     0  .  0 F ;", "c . rotateAround ( target ,    tmpV 1  . nor (  )  ,     ( deltaY    *     ( rotateAngle )  )  )  ;", "c . rotateAround ( target ,    Vector 3  . Y ,     ( deltaX    *     (  -  ( rotateAngle )  )  )  )  ;", "} else", "if    ( button    =  =     ( translateButton )  )     {", "c . translate ( tmpV 1  . set ( c . direction )  . crs ( c . up )  . nor (  )  . scl (  (  (  - deltaX )     *     ( translateUnits )  )  )  )  ;", "c . translate ( tmpV 2  . set ( c . up )  . scl (  (  (  - deltaY )     *     ( translateUnits )  )  )  )  ;", "if    ( translateTarget )", "target . add ( tmpV 1  )  . add ( tmpV 2  )  ;", "} else", "if    ( button    =  =     ( forwardButton )  )     {", "c . translate ( tmpV 1  . set ( c . direction )  . scl (  ( deltaY    *     ( translateUnits )  )  )  )  ;", "if    ( forwardTarget )", "target . add ( tmpV 1  )  ;", "}", "if    ( autoUpdate )", "c . update (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.CameraInputController"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( rotateRightPressed )     |  |     ( rotateLeftPressed )  )     |  |     ( forwardPressed )  )     |  |     ( backwardPressed )  )     {", "final   float   delta    =    GetDeltaTime (  )  ;", "if    ( rotateRightPressed )", "camera . rotate ( camera . up ,     (  (  - delta )     *     ( rotateAngle )  )  )  ;", "if    ( rotateLeftPressed )", "camera . rotate ( camera . up ,     ( delta    *     ( rotateAngle )  )  )  ;", "if    ( forwardPressed )     {", "camera . translate ( tmpV 1  . set ( camera . direction )  . scl (  ( delta    *     ( translateUnits )  )  )  )  ;", "if    ( forwardTarget )", "target . add ( tmpV 1  )  ;", "}", "if    ( backwardPressed )     {", "camera . translate ( tmpV 1  . set ( camera . direction )  . scl (  (  (  - delta )     *     ( translateUnits )  )  )  )  ;", "if    ( forwardTarget )", "target . add ( tmpV 1  )  ;", "}", "if    ( autoUpdate )", "camera . update (  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.CameraInputController"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( alwaysScroll )  )     &  &     (  ( activateKey )     !  =     0  )  )     &  &     (  !  ( activatePressed )  )  )", "return   false ;", "c . translate ( tmpV 1  . set ( c . direction )  . scl ( amount )  )  ;", "if    ( scrollTarget )", "target . add ( tmpV 1  )  ;", "if    ( autoUpdate )", "c . update (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["zoom"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.CameraInputController"}, {"methodBody": ["METHOD_START", "{", "if    ( center . isZero (  )  )", "worldTransform . getTranslation ( output )  ;", "else", "if    (  !  ( worldTransform . hasRotationOrScaling (  )  )  )", "worldTransform . getTranslation ( output )  . add ( center )  ;", "else", "output . set ( center )  . mul ( worldTransform )  ;", "return   output ;", "}", "METHOD_END"], "methodName": ["getTranslation"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.DefaultRenderableSorter"}, {"methodBody": ["METHOD_START", "{", "final   int   idx ;", "final   int   result ;", "final   GLTexture   texture    =    textureDesc . texture ;", "reused    =    false ;", "switch    ( method )     {", "case   DefaultTextureBinder . ROUNDROBIN    :", "result    =     ( offset )     +     ( idx    =    bindTextureRoundRobin ( texture )  )  ;", "break ;", "case   DefaultTextureBinder . WEIGHTED    :", "result    =     ( offset )     +     ( idx    =    bindTextureWeighted ( texture )  )  ;", "break ;", "default    :", "return    -  1  ;", "}", "if    ( reused )     {", "( reuseCount )  +  +  ;", "if    ( rebind )", "texture . bind ( result )  ;", "else", "com . badlogic . gdx . Gdx . gl . glActiveTexture (  (  ( GL 2  0  . GL _ TEXTURE 0  )     +    result )  )  ;", "} else", "( bindCount )  +  +  ;", "texture . unsafeSetWrap ( textureDesc . uWrap ,    textureDesc . vWrap )  ;", "texture . unsafeSetFilter ( textureDesc . minFilter ,    textureDesc . magFilter )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["bindTexture"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.DefaultTextureBinder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "final   int   idx    =     (  ( curren )     +    i )     %     ( count )  ;", "if    (  ( textures [ idx ]  )     =  =    texture )     {", "reused    =    true ;", "return   idx ;", "}", "}", "curren    =     (  ( curren )     +     1  )     %     ( count )  ;", "textures [ curren ]     =    texture ;", "texture . bind (  (  ( offset )     +     ( curren )  )  )  ;", "return   curren ;", "}", "METHOD_END"], "methodName": ["bindTextureRoundRobin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.DefaultTextureBinder"}, {"methodBody": ["METHOD_START", "{", "int   result    =     -  1  ;", "int   weight    =    weights [  0  ]  ;", "int   windex    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "if    (  ( ts [ i ]  )     =  =    t )     {", "result    =    i ;", "weights [ i ]     +  =    reuseWeight ;", "} else", "if    (  (  ( weights [ i ]  )     <     0  )     |  |     (  (  -  -  ( weights [ i ]  )  )     <    weight )  )     {", "weight    =    weights [ i ]  ;", "windex    =    i ;", "}", "}", "if    ( result    <     0  )     {", "ts [ windex ]     =    t ;", "weights [ windex ]     =     1  0  0  ;", "t . bind (  (  ( offset )     +     ( result    =    windex )  )  )  ;", "} else", "reused    =    true ;", "return   result ;", "}", "METHOD_END"], "methodName": ["bindTextureWeighted"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.DefaultTextureBinder"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   buffer    =    BufferUtils . newIntBuffer (  1  6  )  ;", "Gdx . gl . glGetIntegerv ( GL 2  0  . GL _ MAX _ TEXTURE _ IMAGE _ UNITS ,    buffer )  ;", "return   buffer . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getMaxTextureUnits"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.DefaultTextureBinder"}, {"methodBody": ["METHOD_START", "{", "this . degreesPerPixel    =    degreesPerPixel ;", "}", "METHOD_END"], "methodName": ["setDegreesPerPixel"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.FirstPersonCameraController"}, {"methodBody": ["METHOD_START", "{", "this . velocity    =    velocity ;", "}", "METHOD_END"], "methodName": ["setVelocity"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.FirstPersonCameraController"}, {"methodBody": ["METHOD_START", "{", "update ( Gdx . graphics . getDeltaTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.FirstPersonCameraController"}, {"methodBody": ["METHOD_START", "{", "if    ( keys . containsKey ( FORWARD )  )     {", "tmp . set ( c . direction )  . nor (  )  . scl (  ( deltaTime    *     ( velocity )  )  )  ;", "c . position . add ( tmp )  ;", "}", "if    ( keys . containsKey ( BACKWARD )  )     {", "tmp . set ( c . direction )  . nor (  )  . scl (  (  (  - deltaTime )     *     ( velocity )  )  )  ;", "c . position . add ( tmp )  ;", "}", "if    ( keys . containsKey ( STRAFE _ LEFT )  )     {", "tmp . set ( c . direction )  . crs ( c . up )  . nor (  )  . scl (  (  (  - deltaTime )     *     ( velocity )  )  )  ;", "c . position . add ( tmp )  ;", "}", "if    ( keys . containsKey ( STRAFE _ RIGHT )  )     {", "tmp . set ( c . direction )  . crs ( c . up )  . nor (  )  . scl (  ( deltaTime    *     ( velocity )  )  )  ;", "c . position . add ( tmp )  ;", "}", "if    ( keys . containsKey ( UP )  )     {", "tmp . set ( c . up )  . nor (  )  . scl (  ( deltaTime    *     ( velocity )  )  )  ;", "c . position . add ( tmp )  ;", "}", "if    ( keys . containsKey ( DOWN )  )     {", "tmp . set ( c . up )  . nor (  )  . scl (  (  (  - deltaTime )     *     ( velocity )  )  )  ;", "c . position . add ( tmp )  ;", "}", "c . update ( true )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.FirstPersonCameraController"}, {"methodBody": ["METHOD_START", "{", "final   int   o    =    vertices . size ;", "vertices . addAll ( values ,    offset ,    stride )  ;", "lastIndex    =     (  ( short )     (  ( vindex )  +  +  )  )  ;", "if    ( vertexTransformationEnabled )     {", "MeshBuilder . transformPosition ( vertices . items ,     ( o    +     ( posOffset )  )  ,    posSize ,    positionTransform )  ;", "if    (  ( norOffset )     >  =     0  )", "MeshBuilder . transformNormal ( vertices . items ,     ( o    +     ( norOffset )  )  ,     3  ,    normalTransform )  ;", "if    (  ( biNorOffset )     >  =     0  )", "MeshBuilder . transformNormal ( vertices . items ,     ( o    +     ( biNorOffset )  )  ,     3  ,    normalTransform )  ;", "if    (  ( tangentOffset )     >  =     0  )", "MeshBuilder . transformNormal ( vertices . items ,     ( o    +     ( tangentOffset )  )  ,     3  ,    normalTransform )  ;", "}", "final   float   x    =    vertices . items [  ( o    +     ( posOffset )  )  ]  ;", "final   float   y    =     (  ( posSize )     >     1  )     ?    vertices . items [  (  ( o    +     ( posOffset )  )     +     1  )  ]     :     0  .  0 F ;", "final   float   z    =     (  ( posSize )     >     2  )     ?    vertices . items [  (  ( o    +     ( posOffset )  )     +     2  )  ]     :     0  .  0 F ;", "bounds . ext ( x ,    y ,    z )  ;", "if    ( hasColor )     {", "if    (  ( colOffset )     >  =     0  )     {", "vertices . items [  ( o    +     ( colOffset )  )  ]     *  =    color . r ;", "vertices . items [  (  ( o    +     ( colOffset )  )     +     1  )  ]     *  =    color . g ;", "vertices . items [  (  ( o    +     ( colOffset )  )     +     2  )  ]     *  =    color . b ;", "if    (  ( colSize )     >     3  )", "vertices . items [  (  ( o    +     ( colOffset )  )     +     3  )  ]     *  =    color . a ;", "} else", "if    (  ( cpOffset )     >  =     0  )     {", "vertices . items [  ( o    +     ( cpOffset )  )  ]     =    tempC 1  . set ( utils . NumberUtils . floatToIntColor ( vertices . items [  ( o    +     ( cpOffset )  )  ]  )  )  . mul ( color )  . toFloatBits (  )  ;", "}", "}", "if    (  ( hasUVTransform )     &  &     (  ( uvOffset )     >  =     0  )  )     {", "vertices . items [  ( o    +     ( uvOffset )  )  ]     =     ( uOffset )     +     (  ( uScale )     *     ( vertices . items [  ( o    +     ( uvOffset )  )  ]  )  )  ;", "vertices . items [  (  ( o    +     ( uvOffset )  )     +     1  )  ]     =     ( vOffset )     +     (  ( vScale )     *     ( vertices . items [  (  ( o    +     ( uvOffset )  )     +     1  )  ]  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addVertex"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "begin ( attributes ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . attributes )     !  =    null )", "throw   new   RuntimeException (  \" Call   end (  )    first \"  )  ;", "this . attributes    =    attributes ;", "this . vertices . clear (  )  ;", "this . indices . clear (  )  ;", "this . parts . clear (  )  ;", "this . vindex    =     0  ;", "this . lastIndex    =     -  1  ;", "this . istart    =     0  ;", "this . part    =    null ;", "this . stride    =     ( attributes . vertexSize )     /     4  ;", "if    (  (  ( this . vertex )     =  =    null )     |  |     (  ( this . vertex . length )     <     ( stride )  )  )", "this . vertex    =    new   float [ stride ]  ;", "VertexAttribute   a    =    attributes . findByUsage ( VertexAttributes . Usage . Position )  ;", "if    ( a    =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Cannot   build   mesh   without   position   attribute \"  )  ;", "posOffset    =     ( a . offset )     /     4  ;", "posSize    =    a . numComponents ;", "a    =    attributes . findByUsage ( VertexAttributes . Usage . Normal )  ;", "norOffset    =     ( a    =  =    null )     ?     -  1     :     ( a . offset )     /     4  ;", "a    =    attributes . findByUsage ( VertexAttributes . Usage . BiNormal )  ;", "biNorOffset    =     ( a    =  =    null )     ?     -  1     :     ( a . offset )     /     4  ;", "a    =    attributes . findByUsage ( VertexAttributes . Usage . Tangent )  ;", "tangentOffset    =     ( a    =  =    null )     ?     -  1     :     ( a . offset )     /     4  ;", "a    =    attributes . findByUsage ( VertexAttributes . Usage . ColorUnpacked )  ;", "colOffset    =     ( a    =  =    null )     ?     -  1     :     ( a . offset )     /     4  ;", "colSize    =     ( a    =  =    null )     ?     0     :    a . numComponents ;", "a    =    attributes . findByUsage ( VertexAttributes . Usage . ColorPacked )  ;", "cpOffset    =     ( a    =  =    null )     ?     -  1     :     ( a . offset )     /     4  ;", "a    =    attributes . findByUsage ( VertexAttributes . Usage . TextureCoordinates )  ;", "uvOffset    =     ( a    =  =    null )     ?     -  1     :     ( a . offset )     /     4  ;", "setColor ( null )  ;", "setVertexTransform ( null )  ;", "setUVRange ( null )  ;", "this . primitiveType    =    primitiveType ;", "bounds . inf (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "begin ( MeshBuilder . createAttributes ( attributes )  ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "begin ( MeshBuilder . createAttributes ( attributes )  ,    primitiveType )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "this . vertices . clear (  )  ;", "this . indices . clear (  )  ;", "this . parts . clear (  )  ;", "this . vindex    =     0  ;", "this . lastIndex    =     -  1  ;", "this . istart    =     0  ;", "this . part    =    null ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Array < VertexAttribute >    attrs    =    new   Array < VertexAttribute >  (  )  ;", "if    (  ( usage    &     ( VertexAttributes . Usage . Position )  )     =  =     ( VertexAttributes . Usage . Position )  )", "attrs . add ( new   VertexAttribute ( VertexAttributes . Usage . Position ,     3  ,    lutils . ShaderProgram . POSITION _ ATTRIBUTE )  )  ;", "if    (  ( usage    &     ( VertexAttributes . Usage . ColorUnpacked )  )     =  =     ( VertexAttributes . Usage . ColorUnpacked )  )", "attrs . add ( new   VertexAttribute ( VertexAttributes . Usage . ColorUnpacked ,     4  ,    lutils . ShaderProgram . COLOR _ ATTRIBUTE )  )  ;", "if    (  ( usage    &     ( VertexAttributes . Usage . ColorPacked )  )     =  =     ( VertexAttributes . Usage . ColorPacked )  )", "attrs . add ( new   VertexAttribute ( VertexAttributes . Usage . ColorPacked ,     4  ,    lutils . ShaderProgram . COLOR _ ATTRIBUTE )  )  ;", "if    (  ( usage    &     ( VertexAttributes . Usage . Normal )  )     =  =     ( VertexAttributes . Usage . Normal )  )", "attrs . add ( new   VertexAttribute ( VertexAttributes . Usage . Normal ,     3  ,    lutils . ShaderProgram . NORMAL _ ATTRIBUTE )  )  ;", "if    (  ( usage    &     ( VertexAttributes . Usage . TextureCoordinates )  )     =  =     ( VertexAttributes . Usage . TextureCoordinates )  )", "attrs . add ( new   VertexAttribute ( VertexAttributes . Usage . TextureCoordinates ,     2  ,     (  ( lutils . ShaderProgram . TEXCOORD _ ATTRIBUTE )     +     \"  0  \"  )  )  )  ;", "final   VertexAttribute [  ]    attributes    =    new   VertexAttribute [ attrs . size ]  ;", "for    ( int   i    =     0  ;    i    <     ( attributes . length )  ;    i +  +  )", "attributes [ i ]     =    attrs . get ( i )  ;", "return   new   VertexAttributes ( attributes )  ;", "}", "METHOD_END"], "methodName": ["createAttributes"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "return   end ( new   Mesh ( true ,     (  ( vertices . size )     /     ( stride )  )  ,    indices . size ,    attributes )  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "endpart (  )  ;", "if    (  ( attributes )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Call   begin (  )    first \"  )  ;", "if    (  !  ( attributes . equals ( mesh . getVertexAttributes (  )  )  )  )", "throw   new   utils . GdxRuntimeException (  \" Mesh   attributes   don ' t   match \"  )  ;", "if    (  (  ( mesh . getMaxVertices (  )  )     *     ( stride )  )     <     ( vertices . size )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  (  \" Mesh   can ' t   hold   enough   vertices :     \"     +     ( mesh . getMaxVertices (  )  )  )     +     \"     *     \"  )     +     ( stride )  )     +     \"     <     \"  )     +     ( vertices . size )  )  )  ;", "if    (  ( mesh . getMaxIndices (  )  )     <     ( indices . size )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" Mesh   can ' t   hold   enough   indices :     \"     +     ( mesh . getMaxIndices (  )  )  )     +     \"     <     \"  )     +     ( indices . size )  )  )  ;", "mesh . setVertices ( vertices . items ,     0  ,    vertices . size )  ;", "mesh . setIndices ( indices . items ,     0  ,    indices . size )  ;", "for    ( MeshPart   p    :    parts )", "p . mesh    =    mesh ;", "parts . clear (  )  ;", "attributes    =    null ;", "vertices . clear (  )  ;", "indices . clear (  )  ;", "return   mesh ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( part )     !  =    null )     {", "boundetCenter ( part . center )  ;", "boundetDimensions ( part . halfExtents )  . scl (  0  .  5 F )  ;", "part . radius    =    part . halfExtents . len (  )  ;", "bounds . inf (  )  ;", "part . offset    =    istart ;", "part . size    =     ( indices . size )     -     ( istart )  ;", "istart    =    indices . size ;", "part    =    null ;", "}", "}", "METHOD_END"], "methodName": ["endpart"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "ensureVertices (  (  4     *    numRectangles )  )  ;", "ensureRectangleIndices ( numRectangles )  ;", "}", "METHOD_END"], "methodName": ["ensureRectangles"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "ensureVertices ( numVertices )  ;", "ensureRectangleIndices ( numRectangles )  ;", "}", "METHOD_END"], "methodName": ["ensureRectangles"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "ensureVertices (  (  3     *    numTriangles )  )  ;", "ensureTriangleIndices ( numTriangles )  ;", "}", "METHOD_END"], "methodName": ["ensureTriangles"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "ensureVertices ( numVertices )  ;", "ensureTriangleIndices ( numTriangles )  ;", "}", "METHOD_END"], "methodName": ["ensureTriangles"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "return   stride ;", "}", "METHOD_END"], "methodName": ["getFloatsPerVertex"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "return   indices . items ;", "}", "METHOD_END"], "methodName": ["getIndices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( attributes )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Must   be   called   in   between    # begin   and    # end \"  )  ;", "if    (  ( destOffset    <     0  )     |  |     ( destOffset    >     (  ( out . length )     -     ( indices . size )  )  )  )", "throw   new   utils . GdxRuntimeException (  \" Array   to   small   or   offset   out   of   range \"  )  ;", "System . arraycopy ( indices . items ,     0  ,    out ,    destOffset ,    indices . size )  ;", "}", "METHOD_END"], "methodName": ["getIndices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "return   indices . size ;", "}", "METHOD_END"], "methodName": ["getNumIndices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( vertices . size )     /     ( stride )  ;", "}", "METHOD_END"], "methodName": ["getNumVertices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "return   vertices . items ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( attributes )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Must   be   called   in   between    # begin   and    # end \"  )  ;", "if    (  ( destOffset    <     0  )     |  |     ( destOffset    >     (  ( out . length )     -     ( vertices . size )  )  )  )", "throw   new   utils . GdxRuntimeException (  \" Array   to   small   or   offset   out   of   range \"  )  ;", "System . arraycopy ( vertices . items ,     0  ,    out ,    destOffset ,    vertices . size )  ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "return   part ( id ,    primitiveType ,    new   MeshPart (  )  )  ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . attributes )     =  =    null )", "throw   new   RuntimeException (  \" Call   begin (  )    first \"  )  ;", "endpart (  )  ;", "part    =    mPart ;", "part . id    =    id ;", "this . primitiveType    =    part . primitiveType    =    primitiveType ;", "parts . add ( part )  ;", "setColor ( null )  ;", "setVertexTransform ( null )  ;", "setUVRange ( null )  ;", "return   part ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( size    >     2  )     {", ". vTmp . set ( values [ offset ]  ,    values [  ( offset    +     1  )  ]  ,    values [  ( offset    +     2  )  ]  )  . mul ( transform )  . nor (  )  ;", "values [ offset ]     =     . vTmp . x ;", "values [  ( offset    +     1  )  ]     =     . vTmp . y ;", "values [  ( offset    +     2  )  ]     =     . vTmp . z ;", "} else", "if    ( size    >     1  )     {", ". vTmp . set ( values [ offset ]  ,    values [  ( offset    +     1  )  ]  ,     0  )  . mul ( transform )  . nor (  )  ;", "values [ offset ]     =     . vTmp . x ;", "values [  ( offset    +     1  )  ]     =     . vTmp . y ;", "} else", "values [ offset ]     =     . vTmp . set ( values [ offset ]  ,     0  ,     0  )  . mul ( transform )  . nor (  )  . x ;", "}", "METHOD_END"], "methodName": ["transformNormal"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( size    >     2  )     {", ". vTmp . set ( values [ offset ]  ,    values [  ( offset    +     1  )  ]  ,    values [  ( offset    +     2  )  ]  )  . mul ( transform )  ;", "values [ offset ]     =     . vTmp . x ;", "values [  ( offset    +     1  )  ]     =     . vTmp . y ;", "values [  ( offset    +     2  )  ]     =     . vTmp . z ;", "} else", "if    ( size    >     1  )     {", ". vTmp . set ( values [ offset ]  ,    values [  ( offset    +     1  )  ]  ,     0  )  . mul ( transform )  ;", "values [ offset ]     =     . vTmp . x ;", "values [  ( offset    +     1  )  ]     =     . vTmp . y ;", "} else", "values [ offset ]     =     . vTmp . set ( values [ offset ]  ,     0  ,     0  )  . mul ( transform )  . x ;", "}", "METHOD_END"], "methodName": ["transformPosition"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.MeshBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( model )     !  =    null )", "throw   new   utils . GdxRuntimeException (  \" Call   end (  )    first \"  )  ;", "node    =    null ;", "model    =    new   Model (  )  ;", "builders . clear (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createArrow ( from . x ,    from . y ,    from . z ,    to . x ,    to . y ,    to . z ,     0  .  1 F ,     0  .  1 F ,     5  ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createArrow"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "part (  \" arrow \"  ,    primitiveType ,    attributes ,    material )  . arrow ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  ,    capLength ,    stemTkness ,    divisions )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createArrow"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createBox ( width ,    height ,    depth ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createBox"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "part (  \" box \"  ,    primitiveType ,    attributes ,    material )  . box ( width ,    height ,    depth )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createBox"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createCapsule ( radius ,    height ,    divisions ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createCapsule"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "part (  \" capsule \"  ,    primitiveType ,    attributes ,    material )  . capsule ( radius ,    height ,    divisions )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createCapsule"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createCone ( width ,    height ,    depth ,    divisions ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createCone"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createCone ( width ,    height ,    depth ,    divisions ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["createCone"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createCone ( width ,    height ,    depth ,    divisions ,    primitiveType ,    material ,    attributes ,     0  ,     3  6  0  )  ;", "}", "METHOD_END"], "methodName": ["createCone"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "part (  \" cone \"  ,    primitiveType ,    attributes ,    material )  . cone ( width ,    height ,    depth ,    divisions ,    angleFrom ,    angleTo )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createCone"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createCylinder ( width ,    height ,    depth ,    divisions ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createCylinder"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createCylinder ( width ,    height ,    depth ,    divisions ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["createCylinder"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createCylinder ( width ,    height ,    depth ,    divisions ,    primitiveType ,    material ,    attributes ,     0  ,     3  6  0  )  ;", "}", "METHOD_END"], "methodName": ["createCylinder"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "part (  \" cylin \"  ,    primitiveType ,    attributes ,    material )  . cylin ( width ,    height ,    depth ,    divisions ,    angleFrom ,    angleTo )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createCylinder"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "MeshPart   part    =    part (  \" lines \"  ,    GL 2  0  . GL _ LINES ,    attributes ,    material )  ;", "float   xlength    =    xDivisions    *    xSize ;", "float   zlength    =    zDivisions    *    zSize ;", "float   hxlength    =    xlength    /     2  ;", "float   hzlength    =    zlength    /     2  ;", "float   x 1     =     - hxlength ;", "float   y 1     =     0  ;", "float   z 1     =    hzlength ;", "float   x 2     =     - hxlength ;", "float   y 2     =     0  ;", "float   z 2     =     - hzlength ;", "for    ( int   i    =     0  ;    i    <  =    xDivisions ;     +  + i )     {", "part . line ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  )  ;", "x 1     +  =    xSize ;", "x 2     +  =    xSize ;", "}", "x 1     =     - hxlength ;", "y 1     =     0  ;", "z 1     =     - hzlength ;", "x 2     =    hxlength ;", "y 2     =     0  ;", "z 2     =     - hzlength ;", "for    ( int   j    =     0  ;    j    <  =    zDivisions ;     +  + j )     {", "part . line ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  )  ;", "z 1     +  =    zSize ;", "z 2     +  =    zSize ;", "}", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createLineGrid"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createRect ( x 0  0  ,    y 0  0  ,    z 0  0  ,    x 1  0  ,    y 1  0  ,    z 1  0  ,    x 1  1  ,    y 1  1  ,    z 1  1  ,    x 0  1  ,    y 0  1  ,    z 0  1  ,    normalX ,    normalY ,    normalZ ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createRect"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "part (  \" rect \"  ,    primitiveType ,    attributes ,    material )  . rect ( x 0  0  ,    y 0  0  ,    z 0  0  ,    x 1  0  ,    y 1  0  ,    z 1  0  ,    x 1  1  ,    y 1  1  ,    z 1  1  ,    x 0  1  ,    y 0  1  ,    z 0  1  ,    normalX ,    normalY ,    normalZ )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createRect"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createSphere ( width ,    height ,    depth ,    divisionsU ,    divisionsV ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createSphere"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createSphere ( width ,    height ,    depth ,    divisionsU ,    divisionsV ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes ,    angleUFrom ,    angleUTo ,    angleVFrom ,    angleVTo )  ;", "}", "METHOD_END"], "methodName": ["createSphere"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createSphere ( width ,    height ,    depth ,    divisionsU ,    divisionsV ,    primitiveType ,    material ,    attributes ,     0  ,     3  6  0  ,     0  ,     1  8  0  )  ;", "}", "METHOD_END"], "methodName": ["createSphere"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "part (  \" cylin \"  ,    primitiveType ,    attributes ,    material )  . sphere ( width ,    height ,    depth ,    divisionsU ,    divisionsV ,    angleUFrom ,    angleUTo ,    angleVFrom ,    angleVTo )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createSphere"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   createXYZCoordinates ( axisLength ,     0  .  1 F ,     0  .  1 F ,     5  ,    GL 2  0  . GL _ TRIANGLES ,    material ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["createXYZCoordinates"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "begin (  )  ;", "MeshPart   part ;", "Node   node    =    node (  )  ;", "part    =    part (  \" xyz \"  ,    primitiveType ,    attributes ,    material )  ;", "part . setColor ( Color . RED )  ;", "part . arrow (  0  ,     0  ,     0  ,    axisLength ,     0  ,     0  ,    capLength ,    stemThickness ,    divisions )  ;", "part . setColor ( Color . GREEN )  ;", "part . arrow (  0  ,     0  ,     0  ,     0  ,    axisLength ,     0  ,    capLength ,    stemThickness ,    divisions )  ;", "part . setColor ( Color . BLUE )  ;", "part . arrow (  0  ,     0  ,     0  ,     0  ,     0  ,    axisLength ,    capLength ,    stemThickness ,    divisions )  ;", "return   end (  )  ;", "}", "METHOD_END"], "methodName": ["createXYZCoordinates"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( model )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Call   begin (  )    first \"  )  ;", "final   Model   result    =    model ;", "endnode (  )  ;", "model    =    null ;", "for    ( final   MeshBuilder   mb    :    builders )", "mb . end (  )  ;", "builders . clear (  )  ;", "ModelBuilder . rebuildReferences ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node )     !  =    null )     {", "node    =    null ;", "}", "}", "METHOD_END"], "methodName": ["endnode"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( final   MeshBuilder   mb    :    builders )", "if    (  ( mb . getAttributes (  )  . equals ( attributes )  )     &  &     (  ( mb . lastIndex (  )  )     <     (  ( Short . MAX _ VALUE )     /     2  )  )  )", "return   mb ;", "final   MeshBuilder   result    =    new   MeshBuilder (  )  ;", "result . begin ( attributes )  ;", "builders . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getBuilder"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( model )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Call   begin (  )    first \"  )  ;", "model . manageDisposable ( disposable )  ;", "}", "METHOD_END"], "methodName": ["manage"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Node   node    =    new   Node (  )  ;", "node ( node )  ;", "node . id    =     \" node \"     +     ( m . nodes . size )  ;", "return   node ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( model )     =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Call   begin (  )    first \"  )  ;", "endnode (  )  ;", "model . nodes . add ( node )  ;", "this . node    =    node ;", "return   node ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Node   node    =    new   Node (  )  ;", "node . id    =    id ;", "node . addChildren ( m . nodes )  ;", "node ( node )  ;", "for    ( final   Disposable   disposable    :    m . getManagedDisposables (  )  )", "manage ( disposable )  ;", "return   node ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node )     =  =    null )", "node (  )  ;", "node . parts . add ( new   NodePart ( meshpart ,    material )  )  ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   part ( id ,    mesh ,    primitiveType ,     0  ,    mesh . getNumIndices (  )  ,    material )  ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "final   MeshPart   meshPart    =    new   MeshPart (  )  ;", "meshPart . id    =    id ;", "meshPart . primiveType    =    primiveType ;", "meshPart . mesh    =    mesh ;", "meshPart . offset    =    offset ;", "meshPart . size    =    size ;", "part ( meshPart ,    material )  ;", "return   meshPart ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "final   MeshBuilder   builder    =    getBuilder ( attributes )  ;", "part ( builder . part ( id ,    primitiveType )  ,    material )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   part ( id ,    primitiveType ,    MeshBuilder . createAttributes ( attributes )  ,    material )  ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "model . materials . clear (  )  ;", "model . meshes . clear (  )  ;", "model . meshParts . clear (  )  ;", "for    ( final   Node   node    :    model . nodes )", ". rebuildReferences ( model ,    node )  ;", "}", "METHOD_END"], "methodName": ["rebuildReferences"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( final   NodePart   mpm    :    node . parts )     {", "if    (  !  ( model . materials . contains ( mpm . material ,    true )  )  )", "model . materials . add ( mpm . material )  ;", "if    (  !  ( model . meshParts . contains ( mpm . meshPart ,    true )  )  )     {", "model . meshParts . add ( mpm . meshPart )  ;", "if    (  !  ( model . meshes . contains ( mpm . meshPart . mesh ,    true )  )  )", "model . meshes . add ( mpm . meshPart . mesh )  ;", "model . manageDisposable ( mpm . meshPart . mesh )  ;", "}", "}", "for    ( final   Node   child    :    node . getChildren (  )  )", ". rebuildReferences ( model ,    child )  ;", "}", "METHOD_END"], "methodName": ["rebuildReferences"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ModelBuilder"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glDisable ( GL 2  0  . GL _ DEPTH _ TEST )  ;", "depthFunc    =     0  ;", "Gdx . gl . glDepthMask ( true )  ;", "depthMask    =    true ;", "Gdx . gl . glDisable ( GL 2  0  . GL _ BLEND )  ;", "blending    =    false ;", "Gdx . gl . glDisable ( GL 2  0  . GL _ CULL _ FACE )  ;", "cullFace    =    blendSFactor    =    blendDFactor    =     0  ;", "textureBinder . begin (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.RenderContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( depthFunc )     !  =     0  )", "com . badlogic . gdx . Gdx . gl . glDisable ( GL 2  0  . GL _ DEPTH _ TEST )  ;", "if    (  !  ( depthMask )  )", "com . badlogic . gdx . Gdx . gl . glDepthMask ( true )  ;", "if    ( blending )", "com . badlogic . gdx . Gdx . gl . glDisable ( GL 2  0  . GL _ BLEND )  ;", "if    (  ( cullFace )     >     0  )", "com . badlogic . gdx . Gdx . gl . glDisable ( GL 2  0  . GL _ CULL _ FACE )  ;", "textureBinder . end (  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.RenderContext"}, {"methodBody": ["METHOD_START", "{", "if    ( enabled    !  =     ( blending )  )     {", "blending    =    enabled ;", "if    ( enabled )", "Gdx . gl . glEnable ( GL 2  0  . GL _ BLEND )  ;", "else", "Gdx . gl . glDisable ( GL 2  0  . GL _ BLEND )  ;", "}", "if    ( enabled    &  &     (  (  ( blendSFactor )     !  =    sFactor )     |  |     (  ( blendDFactor )     !  =    dFactor )  )  )     {", "Gdx . gl . glBlendFunc ( sFactor ,    dFactor )  ;", "blendSFactor    =    sFactor ;", "blendDFactor    =    dFactor ;", "}", "}", "METHOD_END"], "methodName": ["setBlending"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.RenderContext"}, {"methodBody": ["METHOD_START", "{", "if    ( face    !  =     ( cullFace )  )     {", "cullFace    =    face ;", "if    (  (  ( face    =  =     ( GL 2  0  . GL _ FRONT )  )     |  |     ( face    =  =     ( GL 2  0  . GL _ BACK )  )  )     |  |     ( face    =  =     ( GL 2  0  . GL _ FRONT _ AND _ BACK )  )  )     {", "Gl . glEnable ( GL 2  0  . GL _ CULL _ FACE )  ;", "Gl . glCullFace ( face )  ;", "} else", "Gl . glDisable ( GL 2  0  . GL _ CULL _ FACE )  ;", "}", "}", "METHOD_END"], "methodName": ["setCullFace"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.RenderContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . depthMask )     !  =    depthMask )", "Gdx . gl . glDepthMask (  ( this . depthMask    =    depthMask )  )  ;", "}", "METHOD_END"], "methodName": ["setDepthMask"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.RenderContext"}, {"methodBody": ["METHOD_START", "{", "setDepthTest ( depthFunction ,     0  .  0 F ,     1  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["setDepthTest"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.RenderContext"}, {"methodBody": ["METHOD_START", "{", "final   boolean   wasEnabled    =     ( depthFunc )     !  =     0  ;", "final   boolean   enabled    =    depthFunction    !  =     0  ;", "if    (  ( depthFunc )     !  =    depthFunction )     {", "depthFunc    =    depthFunction ;", "if    ( enabled )     {", "Gl . glEnable ( GL 2  0  . GL _ DEPTH _ TEST )  ;", "Gl . glDepthFunc ( depthFunction )  ;", "} else", "Gl . glDisable ( GL 2  0  . GL _ DEPTH _ TEST )  ;", "}", "if    ( enabled )     {", "if    (  (  ! wasEnabled )     |  |     (  ( depthFunc )     !  =    depthFunction )  )", "Gl . glDepthFunc (  ( depthFunc    =    depthFunction )  )  ;", "if    (  (  (  ! wasEnabled )     |  |     (  ( this . depthRangeNear )     !  =    depthRangeNear )  )     |  |     (  ( this . depthRangeFar )     !  =    depthRangeFar )  )", "Gl . glDepthRangef (  ( this . depthRangeNear    =    depthRangeNear )  ,     ( this . depthRangeFar    =    depthRangeFar )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDepthTest"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.RenderContext"}, {"methodBody": ["METHOD_START", "{", "return   begin ( GL 2  0  . GL _ LINES )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ShapeCache"}, {"methodBody": ["METHOD_START", "{", "if    ( building )", "throw   new   utils . GdxRuntimeException (  \" Call   end (  )    after   calling   begin (  )  \"  )  ;", "building    =    true ;", "builder . begin ( mesh . getVertexAttributes (  )  )  ;", "builder . part ( id ,    primitiveType ,    renderable . meshPart )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ShapeCache"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( building )  )", "throw   new   utils . GdxRuntimeException (  \" Call   begin (  )    prior   to   calling   end (  )  \"  )  ;", "building    =    false ;", "builder . end ( mesh )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ShapeCache"}, {"methodBody": ["METHOD_START", "{", "return   renderable . material ;", "}", "METHOD_END"], "methodName": ["getMaterial"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ShapeCache"}, {"methodBody": ["METHOD_START", "{", "return   renderable . worldTransform ;", "}", "METHOD_END"], "methodName": ["getWorldTransform"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.ShapeCache"}, {"methodBody": ["METHOD_START", "{", "this . texture    =    texture ;", "this . minFilter    =    minFilter ;", "this . magFilter    =    magFilter ;", "this . uWrap    =    uWrap ;", "this . vWrap    =    vWrap ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor"}, {"methodBody": ["METHOD_START", "{", "texture    =    other . texture ;", "minFilter    =    other . minFilter ;", "magFilter    =    other . magFilter ;", "uWrap    =    other . uWrap ;", "vWrap    =    other . vWrap ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor"}, {"methodBody": ["METHOD_START", "{", "Vector 3    begin    =    BaseShapeBuilder . obtainV 3  (  )  . set ( x 1  ,    y 1  ,    z 1  )  ;", "Vector 3    end    =    BaseShapeBuilder . obtainV 3  (  )  . set ( x 2  ,    y 2  ,    z 2  )  ;", "float   length    =    begin . dst ( end )  ;", "float   coneHeight    =    length    *    capLength ;", "float   coneDiameter    =     2     *     (  ( float )     ( coneHeight    *     ( Math . sqrt (  (  1  .  0 F    /     3  )  )  )  )  )  ;", "float   stemLength    =    length    -    coneHeight ;", "float   stemDiameter    =    coneDiameter    *    stemThickness ;", "Vector 3    up    =    BaseShapeBuilder . obtainV 3  (  )  . set ( end )  . sub ( begin )  . nor (  )  ;", "Vector 3    forward    =    BaseShapeBuilder . obtainV 3  (  )  . set ( up )  . crs ( Vector 3  . Z )  ;", "if    ( forward . isZero (  )  )", "forward . set ( Vector 3  . X )  ;", "forward . crs ( up )  . nor (  )  ;", "Vector 3    left    =    BaseShapeBuilder . obtainV 3  (  )  . set ( up )  . crs ( forward )  . nor (  )  ;", "Vector 3    direction    =    BaseShapeBuilder . obtainV 3  (  )  . set ( end )  . sub ( begin )  . nor (  )  ;", "Matrix 4    userTransform    =    builder . getVertexTransform ( BaseShapeBuilder . obtainM 4  (  )  )  ;", "Matrix 4    transform    =    BaseShapeBuilder . obtainM 4  (  )  ;", "float [  ]    val    =    transform . val ;", "val [ Matrix 4  . M 0  0  ]     =    left . x ;", "val [ Matrix 4  . M 0  1  ]     =    up . x ;", "val [ Matrix 4  . M 0  2  ]     =    forward . x ;", "val [ Matrix 4  . M 1  0  ]     =    left . y ;", "val [ Matrix 4  . M 1  1  ]     =    up . y ;", "val [ Matrix 4  . M 1  2  ]     =    forward . y ;", "val [ Matrix 4  . M 2  0  ]     =    left . z ;", "val [ Matrix 4  . M 2  1  ]     =    up . z ;", "val [ Matrix 4  . M 2  2  ]     =    forward . z ;", "Matrix 4    temp    =    BaseShapeBuilder . obtainM 4  (  )  ;", "transform . setTranslation ( BaseShapeBuilder . obtainV 3  (  )  . set ( direction )  . scl (  ( stemLength    /     2  )  )  . add ( x 1  ,    y 1  ,    z 1  )  )  ;", "builder . setVertexTransform ( temp . set ( transform )  . mul ( userTransform )  )  ;", "CylinderShapeBuilder . build ( builder ,    stemDiameter ,    stemLength ,    stemDiameter ,    divisions )  ;", "transform . setTranslation ( BaseShapeBuilder . obtainV 3  (  )  . set ( direction )  . scl ( stemLength )  . add ( x 1  ,    y 1  ,    z 1  )  )  ;", "builder . setVertexTransform ( temp . set ( transform )  . mul ( userTransform )  )  ;", "ConeShapeBuilder . build ( builder ,    coneDiameter ,    coneHeight ,    coneDiameter ,    divisions )  ;", "builder . setVertexTransform ( userTransform )  ;", "BaseShapeBuilder . freeAll (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.ArrowShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "BaseShapeBuilder . vectorPool . flush (  )  ;", "BaseShapeBuilder . matrices 4 Pool . flush (  )  ;", "}", "METHOD_END"], "methodName": ["freeAll"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BaseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   Matrix 4    result    =    BaseShapeBuilder . matrices 4 Pool . obtain (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["obtainM4"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BaseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "return   BaseShapeBuilder . vectorPool . obtain (  )  ;", "}", "METHOD_END"], "methodName": ["obtainV3"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BaseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "builder . ensureVertices (  8  )  ;", "final   short   i 0  0  0     =    builder . vertex ( corner 0  0  0  )  ;", "final   short   i 1  0  0     =    builder . vertex ( corner 1  0  0  )  ;", "final   short   i 1  1  0     =    builder . vertex ( corner 1  1  0  )  ;", "final   short   i 0  1  0     =    builder . vertex ( corner 0  1  0  )  ;", "final   short   i 0  0  1     =    builder . vertex ( corner 0  0  1  )  ;", "final   short   i 1  0  1     =    builder . vertex ( corner 1  0  1  )  ;", "final   short   i 1  1  1     =    builder . vertex ( corner 1  1  1  )  ;", "final   short   i 0  1  1     =    builder . vertex ( corner 0  1  1  )  ;", "final   int   primitiveType    =    builder . getPrimitiveType (  )  ;", "if    ( primitiveType    =  =     ( GL 2  0  . GL _ LINES )  )     {", "builder . ensureIndices (  2  4  )  ;", "builder . rect ( i 0  0  0  ,    i 1  0  0  ,    i 1  1  0  ,    i 0  1  0  )  ;", "builder . rect ( i 1  0  1  ,    i 0  0  1  ,    i 0  1  1  ,    i 1  1  1  )  ;", "builder . index ( i 0  0  0  ,    i 0  0  1  ,    i 0  1  0  ,    i 0  1  1  ,    i 1  1  0  ,    i 1  1  1  ,    i 1  0  0  ,    i 1  0  1  )  ;", "} else", "if    ( primitiveType    =  =     ( GL 2  0  . GL _ POINTS )  )     {", "builder . ensureRectangleIndices (  2  )  ;", "builder . rect ( i 0  0  0  ,    i 1  0  0  ,    i 1  1  0  ,    i 0  1  0  )  ;", "builder . rect ( i 1  0  1  ,    i 0  0  1  ,    i 0  1  1  ,    i 1  1  1  )  ;", "} else    {", "builder . ensureRectangleIndices (  6  )  ;", "builder . rect ( i 0  0  0  ,    i 1  0  0  ,    i 1  1  0  ,    i 0  1  0  )  ;", "builder . rect ( i 1  0  1  ,    i 0  0  1  ,    i 0  1  1  ,    i 1  1  1  )  ;", "builder . rect ( i 0  0  0  ,    i 0  1  0  ,    i 0  1  1  ,    i 0  0  1  )  ;", "builder . rect ( i 1  0  1  ,    i 1  1  1  ,    i 1  1  0  ,    i 1  0  0  )  ;", "builder . rect ( i 1  0  1  ,    i 1  0  0  ,    i 0  0  0  ,    i 0  0  1  )  ;", "builder . rect ( i 1  1  0  ,    i 1  1  1  ,    i 0  1  1  ,    i 0  1  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BoxShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "BoxShapeBuilder . build ( builder ,    BaseShapeBuilder . obtainV 3  (  )  . set (  (  -  0  .  5 F )  ,     (  -  0  .  5 F )  ,     (  -  0  .  5 F )  )  . mul ( transform )  ,    BaseShapeBuilder . obtainV 3  (  )  . set (  (  -  0  .  5 F )  ,     0  .  5 F ,     (  -  0  .  5 F )  )  . mul ( transform )  ,    BaseShapeBuilder . obtainV 3  (  )  . set (  0  .  5 F ,     (  -  0  .  5 F )  ,     (  -  0  .  5 F )  )  . mul ( transform )  ,    BaseShapeBuilder . obtainV 3  (  )  . set (  0  .  5 F ,     0  .  5 F ,     (  -  0  .  5 F )  )  . mul ( transform )  ,    BaseShapeBuilder . obtainV 3  (  )  . set (  (  -  0  .  5 F )  ,     (  -  0  .  5 F )  ,     0  .  5 F )  . mul ( transform )  ,    BaseShapeBuilder . obtainV 3  (  )  . set (  (  -  0  .  5 F )  ,     0  .  5 F ,     0  .  5 F )  . mul ( transform )  ,    BaseShapeBuilder . obtainV 3  (  )  . set (  0  .  5 F ,     (  -  0  .  5 F )  ,     0  .  5 F )  . mul ( transform )  ,    BaseShapeBuilder . obtainV 3  (  )  . set (  0  .  5 F ,     0  .  5 F ,     0  .  5 F )  . mul ( transform )  )  ;", "BaseShapeBuilder . freeAll (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BoxShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( builder . getAttributes (  )  . getMask (  )  )     &     (  (  (  ( VertexAttributes . Usage . Normal )     |     ( VertexAttributes . Usage . BiNormal )  )     |     ( VertexAttributes . Usage . Tangent )  )     |     ( VertexAttributes . Usage . TextureCoordinates )  )  )     =  =     0  )     {", ". build ( builder ,    BaseShapeBuilder . vertTmp 1  . set ( corner 0  0  0  ,    null ,    null ,    null )  ,    BaseShapeBuilder . vertTmp 2  . set ( corner 0  1  0  ,    null ,    null ,    null )  ,    BaseShapeBuilder . vertTmp 3  . set ( corner 1  0  0  ,    null ,    null ,    null )  ,    BaseShapeBuilder . vertTmp 4  . set ( corner 1  1  0  ,    null ,    null ,    null )  ,    BaseShapeBuilder . vertTmp 5  . set ( corner 0  0  1  ,    null ,    null ,    null )  ,    BaseShapeBuilder . vertTmp 6  . set ( corner 0  1  1  ,    null ,    null ,    null )  ,    BaseShapeBuilder . vertTmp 7  . set ( corner 1  0  1  ,    null ,    null ,    null )  ,    BaseShapeBuilder . vertTmp 8  . set ( corner 1  1  1  ,    null ,    null ,    null )  )  ;", "} else    {", "builder . ensureVertices (  2  4  )  ;", "builder . ensureRectangleIndices (  6  )  ;", "Vector 3    nor    =    BaseShapeBuilder . tmpV 1  . set ( corner 0  0  0  )  . lerp ( corner 1  1  0  ,     0  .  5 F )  . sub ( BaseShapeBuilder . tmpV 2  . set ( corner 0  0  1  )  . lerp ( corner 1  1  1  ,     0  .  5 F )  )  . nor (  )  ;", "builder . rect ( corner 0  0  0  ,    corner 0  1  0  ,    corner 1  1  0  ,    corner 1  0  0  ,    nor )  ;", "builder . rect ( corner 0  1  1  ,    corner 0  0  1  ,    corner 1  0  1  ,    corner 1  1  1  ,    nor . scl (  (  -  1  )  )  )  ;", "nor    =    BaseShapeBuilder . tmpV 1  . set ( corner 0  0  0  )  . lerp ( corner 1  0  1  ,     0  .  5 F )  . sub ( BaseShapeBuilder . tmpV 2  . set ( corner 0  1  0  )  . lerp ( corner 1  1  1  ,     0  .  5 F )  )  . nor (  )  ;", "builder . rect ( corner 0  0  1  ,    corner 0  0  0  ,    corner 1  0  0  ,    corner 1  0  1  ,    nor )  ;", "builder . rect ( corner 0  1  0  ,    corner 0  1  1  ,    corner 1  1  1  ,    corner 1  1  0  ,    nor . scl (  (  -  1  )  )  )  ;", "nor    =    BaseShapeBuilder . tmpV 1  . set ( corner 0  0  0  )  . lerp ( corner 0  1  1  ,     0  .  5 F )  . sub ( BaseShapeBuilder . tmpV 2  . set ( corner 1  0  0  )  . lerp ( corner 1  1  1  ,     0  .  5 F )  )  . nor (  )  ;", "builder . rect ( corner 0  0  1  ,    corner 0  1  1  ,    corner 0  1  0  ,    corner 0  0  0  ,    nor )  ;", "builder . rect ( corner 1  0  0  ,    corner 1  1  0  ,    corner 1  1  1  ,    corner 1  0  1  ,    nor . scl (  (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BoxShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "builder . box ( box . getCorner 0  0  0  ( BaseShapeBuilder . obtainV 3  (  )  )  ,    box . getCorner 0  1  0  ( BaseShapeBuilder . obtainV 3  (  )  )  ,    box . getCorner 1  0  0  ( BaseShapeBuilder . obtainV 3  (  )  )  ,    box . getCorner 1  1  0  ( BaseShapeBuilder . obtainV 3  (  )  )  ,    box . getCorner 0  0  1  ( BaseShapeBuilder . obtainV 3  (  )  )  ,    box . getCorner 0  1  1  ( BaseShapeBuilder . obtainV 3  (  )  )  ,    box . getCorner 1  0  1  ( BaseShapeBuilder . obtainV 3  (  )  )  ,    box . getCorner 1  1  1  ( BaseShapeBuilder . obtainV 3  (  )  )  )  ;", "BaseShapeBuilder . freeAll (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BoxShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "BoxShapeBuilder . build ( builder ,     0  ,     0  ,     0  ,    width ,    height ,    depth )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BoxShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   float   hw    =    width    *     0  .  5 F ;", "final   float   hh    =    height    *     0  .  5 F ;", "final   float   hd    =    depth    *     0  .  5 F ;", "final   float   x 0     =    x    -    hw ;", "final   float   y 0     =    y    -    hh ;", "final   float   z 0     =    z    -    hd ;", "final   float   x 1     =    x    +    hw ;", "final   float   y 1     =    y    +    hh ;", "final   float   z 1     =    z    +    hd ;", ". build ( builder ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 0  ,    y 0  ,    z 0  )  ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 0  ,    y 1  ,    z 0  )  ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 1  ,    y 0  ,    z 0  )  ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 1  ,    y 1  ,    z 0  )  ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 0  ,    y 0  ,    z 1  )  ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 0  ,    y 1  ,    z 1  )  ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 1  ,    y 0  ,    z 1  )  ,    BaseShapeBuilder . obtainV 3  (  )  . set ( x 1  ,    y 1  ,    z 1  )  )  ;", "BaseShapeBuilder . freeAll (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.BoxShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( height    <     (  2  .  0 F    *    radius )  )", "throw   new   utils . GdxRuntimeException (  \" Height   must   be   at   least   twice   the   radius \"  )  ;", "final   float   d    =     2  .  0 F    *    radius ;", "CylinderShapeBuilder . build ( builder ,    d ,     ( height    -    d )  ,    d ,    divisions ,     0  ,     3  6  0  ,    false )  ;", "SphereShapeBuilder . build ( builder ,    BaseShapeBuilder . matTmp 1  . setToTranslation (  0  ,     (  0  .  5 F    *     ( height    -    d )  )  ,     0  )  ,    d ,    d ,    d ,    divisions ,    divisions ,     0  ,     3  6  0  ,     0  ,     9  0  )  ;", "SphereShapeBuilder . build ( builder ,    BaseShapeBuilder . matTmp 1  . setToTranslation (  0  ,     (  (  -  0  .  5 F )     *     ( height    -    d )  )  ,     0  )  ,    d ,    d ,    d ,    divisions ,    divisions ,     0  ,     3  6  0  ,     9  0  ,     1  8  0  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.CapsuleShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "ConeShapeBuilder . build ( builder ,    width ,    height ,    depth ,    divisions ,     0  ,     3  6  0  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.ConeShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "ConeShapeBuilder . build ( builder ,    width ,    height ,    depth ,    divisions ,    angleFrom ,    angleTo ,    true )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.ConeShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "builder . ensureVertices (  ( divisions    +     2  )  )  ;", "builder . ensureTriangleIndices ( divisions )  ;", "final   float   hw    =    width    *     0  .  5 F ;", "final   float   hh    =    height    *     0  .  5 F ;", "final   float   hd    =    depth    *     0  .  5 F ;", "final   float   ao    =     ( MathUtils . degreesToRadians )     *    angleFrom ;", "final   float   step    =     (  ( MathUtils . degreesToRadians )     *     ( angleTo    -    angleFrom )  )     /    divisions ;", "final   float   us    =     1  .  0 F    /    divisions ;", "float   u    =     0  .  0 F ;", "float   angle    =     0  .  0 F ;", "MeshPartBuilder . VertexInfo   curr 1     =    Bas . vertTmp 3  . set ( null ,    null ,    null ,    null )  ;", "curr 1  . hasUV    =    curr 1  . hasPosition    =    curr 1  . hasNormal    =    true ;", "MeshPartBuilder . VertexInfo   curr 2     =    Bas . vertTmp 4  . set ( null ,    null ,    null ,    null )  . setPos (  0  ,    hh ,     0  )  . setNor (  0  ,     1  ,     0  )  . setUV (  0  .  5 F ,     0  )  ;", "final   short   base    =    builder . vertex ( curr 2  )  ;", "short   i 1  ;", "short   i 2     =     0  ;", "for    ( int   i    =     0  ;    i    <  =    divisions ;    i +  +  )     {", "angle    =    ao    +     ( step    *    i )  ;", "u    =     1  .  0 F    -     ( us    *    i )  ;", "curr 1  . position . set (  (  ( MathUtils . cos ( angle )  )     *    hw )  ,     0  .  0 F ,     (  ( MathUtils . sin ( angle )  )     *    hd )  )  ;", "curr 1  . normal . set ( curr 1  . position )  . nor (  )  ;", "curr 1  . position . y    =     - hh ;", "curr 1  . uv . set ( u ,     1  )  ;", "i 1     =    builder . vertex ( curr 1  )  ;", "if    ( i    !  =     0  )", "builder . triangle ( base ,    i 1  ,    i 2  )  ;", "i 2     =    i 1  ;", "}", "if    ( close )", "Ellips . build ( builder ,    width ,    depth ,     0  ,     0  ,    divisions ,     0  ,     (  - hh )  ,     0  ,     0  ,     (  -  1  )  ,     0  ,     (  -  1  )  ,     0  ,     0  ,     0  ,     0  ,     1  ,     (  1  8  0  .  0 F    -    angleTo )  ,     (  1  8  0  .  0 F    -    angleFrom )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.ConeShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "CylinderShapeBuilder . build ( builder ,    width ,    height ,    depth ,    divisions ,     0  ,     3  6  0  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.CylinderShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "CylinderShapeBuilder . build ( builder ,    width ,    height ,    depth ,    divisions ,    angleFrom ,    angleTo ,    true )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.CylinderShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   float   hw    =    width    *     0  .  5 F ;", "final   float   hh    =    height    *     0  .  5 F ;", "final   float   hd    =    depth    *     0  .  5 F ;", "final   float   ao    =     ( MathUtils . degreesToRadians )     *    angleFrom ;", "final   float   step    =     (  ( MathUtils . degreesToRadians )     *     ( angleTo    -    angleFrom )  )     /    divisions ;", "final   float   us    =     1  .  0 F    /    divisions ;", "float   u    =     0  .  0 F ;", "float   angle    =     0  .  0 F ;", "MeshPartBuilder . VertexInfo   curr 1     =    Base . vertTmp 3  . set ( null ,    null ,    null ,    null )  ;", "curr 1  . hasUV    =    curr 1  . hasPosition    =    curr 1  . hasNormal    =    true ;", "MeshPartBuilder . VertexInfo   curr 2     =    Base . vertTmp 4  . set ( null ,    null ,    null ,    null )  ;", "curr 2  . hasUV    =    curr 2  . hasPosition    =    curr 2  . hasNormal    =    true ;", "short   i 1  ;", "short   i 2  ;", "short   i 3     =     0  ;", "short   i 4     =     0  ;", "builder . ensureVertices (  (  2     *     ( divisions    +     1  )  )  )  ;", "builder . ensureRectangleIndices ( divisions )  ;", "for    ( int   i    =     0  ;    i    <  =    divisions ;    i +  +  )     {", "angle    =    ao    +     ( step    *    i )  ;", "u    =     1  .  0 F    -     ( us    *    i )  ;", "curr 1  . position . set (  (  ( MathUtils . cos ( angle )  )     *    hw )  ,     0  .  0 F ,     (  ( MathUtils . sin ( angle )  )     *    hd )  )  ;", "curr 1  . normal . set ( curr 1  . position )  . nor (  )  ;", "curr 1  . position . y    =     - hh ;", "curr 1  . uv . set ( u ,     1  )  ;", "curr 2  . position . set ( curr 1  . position )  ;", "curr 2  . normal . set ( curr 1  . normal )  ;", "curr 2  . position . y    =    hh ;", "curr 2  . uv . set ( u ,     0  )  ;", "i 2     =    builder . vertex ( curr 1  )  ;", "i 1     =    builder . vertex ( curr 2  )  ;", "if    ( i    !  =     0  )", "builder . rect ( i 3  ,    i 1  ,    i 2  ,    i 4  )  ;", "i 4     =    i 2  ;", "i 3     =    i 1  ;", "}", "if    ( close )     {", "Ellipse . build ( builder ,    width ,    depth ,     0  ,     0  ,    divisions ,     0  ,    hh ,     0  ,     0  ,     1  ,     0  ,     1  ,     0  ,     0  ,     0  ,     0  ,     1  ,    angleFrom ,    angleTo )  ;", "Ellipse . build ( builder ,    width ,    depth ,     0  ,     0  ,    divisions ,     0  ,     (  - hh )  ,     0  ,     0  ,     (  -  1  )  ,     0  ,     (  -  1  )  ,     0  ,     0  ,     0  ,     0  ,     1  ,     (  1  8  0  .  0 F    -    angleTo )  ,     (  1  8  0  .  0 F    -    angleFrom )  )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.CylinderShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,    innerWidth ,    innerHeight ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z ,     0  .  0 F ,     3  6  0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,    innerWidth ,    innerHeight ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,     0  .  0 F ,     3  6  0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "BaseShapeBuilder . tmpV 1  . set ( normalX ,    normalY ,    normalZ )  . crs (  0  ,     0  ,     1  )  ;", "BaseShapeBuilder . tmpV 2  . set ( normalX ,    normalY ,    normalZ )  . crs (  0  ,     1  ,     0  )  ;", "if    (  ( BaseShapeBuilder . tmpV 2  . len 2  (  )  )     >     ( BaseShapeBuilder . tmpV 1  . len 2  (  )  )  )", "BaseShapeBuilder . tmpV 1  . set ( BaseShapeBuilder . tmpV 2  )  ;", "BaseShapeBuilder . tmpV 2  . set ( BaseShapeBuilder . tmpV 1  . nor (  )  )  . crs ( normalX ,    normalY ,    normalZ )  . nor (  )  ;", ". build ( builder ,    width ,    height ,    innerWidth ,    innerHeight ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,     . tmpV 1  . x ,     . tmpV 1  . y ,     . tmpV 1  . z ,     . tmpV 2  . x ,     . tmpV 2  . y ,     . tmpV 2  . z ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( innerWidth    <  =     0  )     |  |     ( innerHeight    <  =     0  )  )     {", "builder . ensureVertices (  ( divisions    +     2  )  )  ;", "builder . ensureTriangleIndices ( divisions )  ;", "} else", "if    (  ( innerWidth    =  =    width )     &  &     ( innerHeight    =  =    height )  )     {", "builder . ensureVertices (  ( divisions    +     1  )  )  ;", "builder . ensureIndices (  ( divisions    +     1  )  )  ;", "if    (  ( builder . getPrimitiveType (  )  )     !  =     ( GL 2  0  . GL _ LINES )  )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  \" Incorrect   primitive   type    :    expect   GL _ LINES   because   innerWidth    =  =    width    &  &    innerHeight    =  =    height \"  )  ;", "} else    {", "builder . ensureVertices (  (  ( divisions    +     1  )     *     2  )  )  ;", "builder . ensureRectangleIndices (  ( divisions    +     1  )  )  ;", "}", "final   float   ao    =     ( MathUtils . degreesToRadians )     *    angleFrom ;", "final   float   step    =     (  ( MathUtils . degreesToRadians )     *     ( angleTo    -    angleFrom )  )     /    divisions ;", "final   Vector 3    sxEx    =    BaseShapeBuilder . tmpV 1  . set ( tangentX ,    tangentY ,    tangentZ )  . scl (  ( width    *     0  .  5 F )  )  ;", "final   Vector 3    syEx    =    BaseShapeBuilder . tmpV 2  . set ( binormalX ,    binormalY ,    binormalZ )  . scl (  ( height    *     0  .  5 F )  )  ;", "final   Vector 3    sxIn    =    BaseShapeBuilder . tmpV 3  . set ( tangentX ,    tangentY ,    tangentZ )  . scl (  ( innerWidth    *     0  .  5 F )  )  ;", "final   Vector 3    syIn    =    BaseShapeBuilder . tmpV 4  . set ( binormalX ,    binormalY ,    binormalZ )  . scl (  ( innerHeight    *     0  .  5 F )  )  ;", "MeshPartBuilder . VertexInfo   currIn    =    BaseShapeBuilder . vertTmp 3  . set ( null ,    null ,    null ,    null )  ;", "currIn . hasUV    =    currIn . hasPosition    =    currIn . hasNormal    =    true ;", "currIn . uv . set (  0  .  5 F ,     0  .  5 F )  ;", "currIn . position . set ( centerX ,    centerY ,    centerZ )  ;", "currIn . normal . set ( normalX ,    normalY ,    normalZ )  ;", "MeshPartBuilder . VertexInfo   currEx    =    BaseShapeBuilder . vertTmp 4  . set ( null ,    null ,    null ,    null )  ;", "currEx . hasUV    =    currEx . hasPosition    =    currEx . hasNormal    =    true ;", "currEx . uv . set (  0  .  5 F ,     0  .  5 F )  ;", "currEx . position . set ( centerX ,    centerY ,    centerZ )  ;", "currEx . normal . set ( normalX ,    normalY ,    normalZ )  ;", "final   short   center    =    builder . vertex ( currEx )  ;", "float   angle    =     0  .  0 F ;", "final   float   us    =     0  .  5 F    *     ( innerWidth    /    width )  ;", "final   float   vs    =     0  .  5 F    *     ( innerHeight    /    height )  ;", "short   i 1  ;", "short   i 2     =     0  ;", "short   i 3     =     0  ;", "short   i 4     =     0  ;", "for    ( int   i    =     0  ;    i    <  =    divisions ;    i +  +  )     {", "angle    =    ao    +     ( step    *    i )  ;", "final   float   x    =    MathUtils . cos ( angle )  ;", "final   float   y    =    MathUtils . sin ( angle )  ;", "currEx . position . set ( centerX ,    centerY ,    centerZ )  . add (  (  (  ( sxEx . x )     *    x )     +     (  ( syEx . x )     *    y )  )  ,     (  (  ( sxEx . y )     *    x )     +     (  ( syEx . y )     *    y )  )  ,     (  (  ( sxEx . z )     *    x )     +     (  ( syEx . z )     *    y )  )  )  ;", "currEx . uv . set (  (  0  .  5 F    +     (  0  .  5 F    *    x )  )  ,     (  0  .  5 F    +     (  0  .  5 F    *    y )  )  )  ;", "i 1     =    builder . vertex ( currEx )  ;", "if    (  ( innerWidth    <  =     0  .  0 F )     |  |     ( innerHeight    <  =     0  .  0 F )  )     {", "if    ( i    !  =     0  )", "builder . triangle ( i 1  ,    i 2  ,    center )  ;", "i 2     =    i 1  ;", "} else", "if    (  ( innerWidth    =  =    width )     &  &     ( innerHeight    =  =    height )  )     {", "if    ( i    !  =     0  )", "builder . line ( i 1  ,    i 2  )  ;", "i 2     =    i 1  ;", "} else    {", "currIn . position . set ( centerX ,    centerY ,    centerZ )  . add (  (  (  ( sxIn . x )     *    x )     +     (  ( syIn . x )     *    y )  )  ,     (  (  ( sxIn . y )     *    x )     +     (  ( syIn . y )     *    y )  )  ,     (  (  ( sxIn . z )     *    x )     +     (  ( syIn . z )     *    y )  )  )  ;", "currIn . uv . set (  (  0  .  5 F    +     ( us    *    x )  )  ,     (  0  .  5 F    +     ( vs    *    y )  )  )  ;", "i 2     =    i 1  ;", "i 1     =    builder . vertex ( currIn )  ;", "if    ( i    !  =     0  )", "builder . rect ( i 1  ,    i 2  ,    i 4  ,    i 3  )  ;", "i 4     =    i 2  ;", "i 3     =    i 1  ;", "}", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z ,    tangent . x ,    tangent . y ,    tangent . z ,    binormal . x ,    binormal . y ,    binormal . z )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,     0  .  0 F ,     0  .  0 F ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z ,    tangent . x ,    tangent . y ,    tangent . z ,    binormal . x ,    binormal . y ,    binormal . z ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,     0  .  0 F ,     0  .  0 F ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,     0  .  0 F ,     3  6  0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,     0  .  0 F ,     0  .  0 F ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,    tangentX ,    tangentY ,    tangentZ ,    binormalX ,    binormalY ,    binormalZ ,     0  .  0 F ,     3  6  0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    width ,    height ,     0  .  0 F ,     0  .  0 F ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,    tangentX ,    tangentY ,    tangentZ ,    binormalX ,    binormalY ,    binormalZ ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    radius ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    radius ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z ,    tangent . x ,    tangent . y ,    tangent . z ,    binormal . x ,    binormal . y ,    binormal . z )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    radius ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z ,    tangent . x ,    tangent . y ,    tangent . z ,    binormal . x ,    binormal . y ,    binormal . z ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    radius ,    divisions ,    center . x ,    center . y ,    center . z ,    normal . x ,    normal . y ,    normal . z ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    radius ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,     0  .  0 F ,     3  6  0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,     ( radius    *     2  .  0 F )  ,     ( radius    *     2  .  0 F )  ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,    radius ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,    tangentX ,    tangentY ,    tangentZ ,    binormalX ,    binormalY ,    binormalZ ,     0  .  0 F ,     3  6  0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "EllipseShapeBuilder . build ( builder ,     ( radius    *     2  )  ,     ( radius    *     2  )  ,     0  ,     0  ,    divisions ,    centerX ,    centerY ,    centerZ ,    normalX ,    normalY ,    normalZ ,    tangentX ,    tangentY ,    tangentZ ,    binormalX ,    binormalY ,    binormalZ ,    angleFrom ,    angleTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.EllipseShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "FrustumShapeBuilder . build ( builder ,    camera ,    BaseShapeBuilder . tmpColor 0  . set (  1  ,     0  .  6  6 F ,     0  ,     1  )  ,    BaseShapeBuilder . tmpColor 1  . set (  1  ,     0  ,     0  ,     1  )  ,    BaseShapeBuilder . tmpColor 2  . set (  0  ,     0  .  6  6 F ,     1  ,     1  )  ,    BaseShapeBuilder . tmpColor 3  . set (  1  ,     1  ,     1  ,     1  )  ,    BaseShapeBuilder . tmpColor 4  . set (  0  .  2 F ,     0  .  2 F ,     0  .  2 F ,     1  )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.FrustumShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "Vector 3  [  ]    planePoints    =    camera . frustum . planePoints ;", ". build ( builder ,    camera . frustum ,    frustumColor ,    crossColor )  ;", "builder . line ( planePoints [  0  ]  ,    coneColor ,    camera . position ,    coneColor )  ;", "builder . line ( planePoints [  1  ]  ,    coneColor ,    camera . position ,    coneColor )  ;", "builder . line ( planePoints [  2  ]  ,    coneColor ,    camera . position ,    coneColor )  ;", "builder . line ( planePoints [  3  ]  ,    coneColor ,    camera . position ,    coneColor )  ;", "builder . line ( camera . position ,    targetColor ,     . centerPoint ( planePoints [  4  ]  ,    planePoints [  5  ]  ,    planePoints [  6  ]  )  ,    targetColor )  ;", "float   halfNearSize    =    BaseShapeBuilder . tmpV 0  . set ( planePoints [  1  ]  )  . sub ( planePoints [  0  ]  )  . scl (  0  .  5 F )  . len (  )  ;", "Vector 3    centerNear    =     . centerPoint ( planePoints [  0  ]  ,    planePoints [  1  ]  ,    planePoints [  2  ]  )  ;", "BaseShapeBuilder . tmpV 0  . set ( camera . up )  . scl (  ( halfNearSize    *     2  )  )  ;", "centerNear . add ( BaseShapeBuilder . tmpV 0  )  ;", "builder . line ( centerNear ,    upColor ,    planePoints [  2  ]  ,    upColor )  ;", "builder . line ( planePoints [  2  ]  ,    upColor ,    planePoints [  3  ]  ,    upColor )  ;", "builder . line ( planePoints [  3  ]  ,    upColor ,    centerNear ,    upColor )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.FrustumShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "Vector 3  [  ]    planePoints    =    frustum . planePoints ;", "builder . line ( planePoints [  0  ]  ,    frustumColor ,    planePoints [  1  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  1  ]  ,    frustumColor ,    planePoints [  2  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  2  ]  ,    frustumColor ,    planePoints [  3  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  3  ]  ,    frustumColor ,    planePoints [  0  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  4  ]  ,    frustumColor ,    planePoints [  5  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  5  ]  ,    frustumColor ,    planePoints [  6  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  6  ]  ,    frustumColor ,    planePoints [  7  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  7  ]  ,    frustumColor ,    planePoints [  4  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  0  ]  ,    frustumColor ,    planePoints [  4  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  1  ]  ,    frustumColor ,    planePoints [  5  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  2  ]  ,    frustumColor ,    planePoints [  6  ]  ,    frustumColor )  ;", "builder . line ( planePoints [  3  ]  ,    frustumColor ,    planePoints [  7  ]  ,    frustumColor )  ;", "builder . line (  . middlePoint ( planePoints [  1  ]  ,    planePoints [  0  ]  )  ,    crossColor ,     . middlePoint ( planePoints [  3  ]  ,    planePoints [  2  ]  )  ,    crossColor )  ;", "builder . line (  . middlePoint ( planePoints [  2  ]  ,    planePoints [  1  ]  )  ,    crossColor ,     . middlePoint ( planePoints [  3  ]  ,    planePoints [  0  ]  )  ,    crossColor )  ;", "builder . line (  . middlePoint ( planePoints [  5  ]  ,    planePoints [  4  ]  )  ,    crossColor ,     . middlePoint ( planePoints [  7  ]  ,    planePoints [  6  ]  )  ,    crossColor )  ;", "builder . line (  . middlePoint ( planePoints [  6  ]  ,    planePoints [  5  ]  )  ,    crossColor ,     . middlePoint ( planePoints [  7  ]  ,    planePoints [  4  ]  )  ,    crossColor )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.FrustumShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "BaseShapeBuilder . tmpV 0  . set ( point 1  )  . sub ( point 0  )  . scl (  0  .  5 F )  ;", "BaseShapeBuilder . tmpV 1  . set ( point 0  )  . add ( BaseShapeBuilder . tmpV 0  )  ;", "BaseShapeBuilder . tmpV 0  . set ( point 2  )  . sub ( point 1  )  . scl (  0  .  5 F )  ;", "return   BaseShapeBuilder . tmpV 1  . add ( BaseShapeBuilder . tmpV 0  )  ;", "}", "METHOD_END"], "methodName": ["centerPoint"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.FrustumShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "BaseShapeBuilder . tmpV 0  . set ( point 1  )  . sub ( point 0  )  . scl (  0  .  5 F )  ;", "return   BaseShapeBuilder . tmpV 1  . set ( point 0  )  . add ( BaseShapeBuilder . tmpV 0  )  ;", "}", "METHOD_END"], "methodName": ["middlePoint"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.FrustumShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( divisionsU    <     1  )     |  |     ( divisionsV    <     1  )  )     {", "throw   new   GdxRuntimeException (  (  (  (  \" divisionsU   and   divisionV   must   be    >     0  ,    u , v :     \"     +    divisionsU )     +     \"  ,     \"  )     +    divisionsV )  )  ;", "}", "builder . ensureVertices (  (  ( divisionsV    +     1  )     *     ( divisionsU    +     1  )  )  )  ;", "builder . ensureRectangleIndices (  ( divisionsV    *    divisionsU )  )  ;", "for    ( int   u    =     0  ;    u    <  =    divisionsU ;    u +  +  )     {", "final   float   alphaU    =     (  ( float )     ( u )  )     /     (  ( float )     ( divisionsU )  )  ;", "Base . vertTmp 5  . set ( corner 0  0  )  . lerp ( corner 1  0  ,    alphaU )  ;", "Base . vertTmp 6  . set ( corner 0  1  )  . lerp ( corner 1  1  ,    alphaU )  ;", "for    ( int   v    =     0  ;    v    <  =    divisionsV ;    v +  +  )     {", "final   short   idx    =    builder . vertex ( Base . vertTmp 7  . set ( Base . vertTmp 5  )  . lerp ( Base . vertTmp 6  ,     (  (  ( float )     ( v )  )     /     (  ( float )     ( divisionsV )  )  )  )  )  ;", "if    (  ( u    >     0  )     &  &     ( v    >     0  )  )", "builder . rect (  (  ( short )     (  ( idx    -    divisionsV )     -     2  )  )  ,     (  ( short )     ( idx    -     1  )  )  ,    idx ,     (  ( short )     (  ( idx    -    divisionsV )     -     1  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.PatchShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "PatchShapeBuilder . build ( builder ,    BaseShapeBuilder . vertTmp 1  . set ( corner 0  0  ,    normal ,    null ,    null )  . setUV (  0  .  0 F ,     1  .  0 F )  ,    BaseShapeBuilder . vertTmp 2  . set ( corner 1  0  ,    normal ,    null ,    null )  . setUV (  1  .  0 F ,     1  .  0 F )  ,    BaseShapeBuilder . vertTmp 3  . set ( corner 1  1  ,    normal ,    null ,    null )  . setUV (  1  .  0 F ,     0  .  0 F )  ,    BaseShapeBuilder . vertTmp 4  . set ( corner 0  1  ,    normal ,    null ,    null )  . setUV (  0  .  0 F ,     0  .  0 F )  ,    divisionsU ,    divisionsV )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.PatchShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "PatchShapeBuilder . build ( builder ,    BaseShapeBuilder . vertTmp 1  . set ( null )  . setPos ( x 0  0  ,    y 0  0  ,    z 0  0  )  . setNor ( normalX ,    normalY ,    normalZ )  . setUV (  0  .  0 F ,     1  .  0 F )  ,    BaseShapeBuilder . vertTmp 2  . set ( null )  . setPos ( x 1  0  ,    y 1  0  ,    z 1  0  )  . setNor ( normalX ,    normalY ,    normalZ )  . setUV (  1  .  0 F ,     1  .  0 F )  ,    BaseShapeBuilder . vertTmp 3  . set ( null )  . setPos ( x 1  1  ,    y 1  1  ,    z 1  1  )  . setNor ( normalX ,    normalY ,    normalZ )  . setUV (  1  .  0 F ,     0  .  0 F )  ,    BaseShapeBuilder . vertTmp 4  . set ( null )  . setPos ( x 0  1  ,    y 0  1  ,    z 0  1  )  . setNor ( normalX ,    normalY ,    normalZ )  . setUV (  0  .  0 F ,     0  .  0 F )  ,    divisionsU ,    divisionsV )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.PatchShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "Mesh   mesh    =    renderable . meshPart . mesh ;", "int   positionOffset    =     -  1  ;", "if    (  ( mesh . getVertexAttribute ( VertexAttributes . Usage . Position )  )     !  =    null )", "positionOffset    =     ( mesh . getVertexAttribute ( VertexAttributes . Usage . Position )  . offset )     /     (  . FLOAT _ BYTES )  ;", "int   normalOffset    =     -  1  ;", "if    (  ( mesh . getVertexAttribute ( VertexAttributes . Usage . Normal )  )     !  =    null )", "normalOffset    =     ( mesh . getVertexAttribute ( VertexAttributes . Usage . Normal )  . offset )     /     (  . FLOAT _ BYTES )  ;", "int   tangentOffset    =     -  1  ;", "if    (  ( mesh . getVertexAttribute ( VertexAttributes . Usage . Tangent )  )     !  =    null )", "tangentOffset    =     ( mesh . getVertexAttribute ( VertexAttributes . Usage . Tangent )  . offset )     /     (  . FLOAT _ BYTES )  ;", "int   binormalOffset    =     -  1  ;", "if    (  ( mesh . getVertexAttribute ( VertexAttributes . Usage . BiNormal )  )     !  =    null )", "binormalOffset    =     ( mesh . getVertexAttribute ( VertexAttributes . Usage . BiNormal )  . offset )     /     (  . FLOAT _ BYTES )  ;", "int   attributesSize    =     ( mesh . getVertexSize (  )  )     /     (  . FLOAT _ BYTES )  ;", "int   verticesOffset    =     0  ;", "int   verticesQuantity    =     0  ;", "if    (  ( mesh . getNumIndices (  )  )     >     0  )     {", ". ensureIndicesCapacity ( mesh . getNumIndices (  )  )  ;", "mesh . getIndices ( renderable . meshPart . offset ,    renderable . meshPart . size ,     . indices ,     0  )  ;", "short   minVertice    =     . minVerticeInIndices (  )  ;", "short   maxVertice    =     . maxVerticeInIndices (  )  ;", "verticesOffset    =    minVertice ;", "verticesQuantity    =    maxVertice    -    minVertice ;", "} else    {", "verticesOffset    =    renderable . meshPart . offset ;", "verticesQuantity    =    renderable . meshPart . size ;", "}", ". ensureVerticesCapacity (  ( verticesQuantity    *    attributesSize )  )  ;", "mesh . getVertices (  ( verticesOffset    *    attributesSize )  ,     ( verticesQuantity    *    attributesSize )  ,     . vertices ,     0  )  ;", "for    ( int   i    =    verticesOffset ;    i    <    verticesQuantity ;    i +  +  )     {", "int   id    =    i    *    attributesSize ;", "BaseShapeBuilder . tmpV 0  . set (  . vertices [  ( id    +    positionOffset )  ]  ,     . vertices [  (  ( id    +    positionOffset )     +     1  )  ]  ,     . vertices [  (  ( id    +    positionOffset )     +     2  )  ]  )  ;", "if    ( normalOffset    !  =     (  -  1  )  )     {", "BaseShapeBuilder . tmpV 1  . set (  . vertices [  ( id    +    normalOffset )  ]  ,     . vertices [  (  ( id    +    normalOffset )     +     1  )  ]  ,     . vertices [  (  ( id    +    normalOffset )     +     2  )  ]  )  ;", "BaseShapeBuilder . tmpV 2  . set ( BaseShapeBuilder . tmpV 0  )  . add ( BaseShapeBuilder . tmpV 1  . scl ( vectorSize )  )  ;", "}", "if    ( tangentOffset    !  =     (  -  1  )  )     {", "BaseShapeBuilder . tmpV 3  . set (  . vertices [  ( id    +    tangentOffset )  ]  ,     . vertices [  (  ( id    +    tangentOffset )     +     1  )  ]  ,     . vertices [  (  ( id    +    tangentOffset )     +     2  )  ]  )  ;", "BaseShapeBuilder . tmpV 4  . set ( BaseShapeBuilder . tmpV 0  )  . add ( BaseShapeBuilder . tmpV 3  . scl ( vectorSize )  )  ;", "}", "if    ( binormalOffset    !  =     (  -  1  )  )     {", "BaseShapeBuilder . tmpV 5  . set (  . vertices [  ( id    +    binormalOffset )  ]  ,     . vertices [  (  ( id    +    binormalOffset )     +     1  )  ]  ,     . vertices [  (  ( id    +    binormalOffset )     +     2  )  ]  )  ;", "BaseShapeBuilder . tmpV 6  . set ( BaseShapeBuilder . tmpV 0  )  . add ( BaseShapeBuilder . tmpV 5  . scl ( vectorSize )  )  ;", "}", "BaseShapeBuilder . tmpV 0  . mul ( renderable . worldTransform )  ;", "BaseShapeBuilder . tmpV 2  . mul ( renderable . worldTransform )  ;", "BaseShapeBuilder . tmpV 4  . mul ( renderable . worldTransform )  ;", "BaseShapeBuilder . tmpV 6  . mul ( renderable . worldTransform )  ;", "if    ( normalOffset    !  =     (  -  1  )  )     {", "builder . setColor ( normalColor )  ;", "builder . line ( BaseShapeBuilder . tmpV 0  ,    BaseShapeBuilder . tmpV 2  )  ;", "}", "if    ( tangentOffset    !  =     (  -  1  )  )     {", "builder . setColor ( tangentColor )  ;", "builder . line ( BaseShapeBuilder . tmpV 0  ,    BaseShapeBuilder . tmpV 4  )  ;", "}", "if    ( binormalOffset    !  =     (  -  1  )  )     {", "builder . setColor ( binormalColor )  ;", "builder . line ( BaseShapeBuilder . tmpV 0  ,    BaseShapeBuilder . tmpV 6  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["buildNormals"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.RenderableShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "RenderableShapeBuilder . buildNormals ( builder ,    renderableProvider ,    vectorSize ,    BaseShapeBuilder . tmpColor 0  . set (  0  ,     0  ,     1  ,     1  )  ,    BaseShapeBuilder . tmpColor 1  . set (  1  ,     0  ,     0  ,     1  )  ,    BaseShapeBuilder . tmpColor 2  . set (  0  ,     1  ,     0  ,     1  )  )  ;", "}", "METHOD_END"], "methodName": ["buildNormals"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.RenderableShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "renderableProvider . getRenderables ( RenderableShapeBuilder . renderables ,    RenderableShapeBuilder . renderablesPool )  ;", "for    ( Renderable   renderable    :    RenderableShapeBuilder . renderables )     {", "RenderableShapeBuilder . buildNormals ( builder ,    renderable ,    vectorSize ,    normalColor ,    tangentColor ,    binormalColor )  ;", "}", "RenderableShapeBuilder . renderablesPool . flush (  )  ;", "RenderableShapeBuilder . renderables . clear (  )  ;", "}", "METHOD_END"], "methodName": ["buildNormals"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.RenderableShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( RenderableShapeBuilder . indices )     =  =    null )     |  |     (  ( RenderableShapeBuilder . indices . length )     <    capacity )  )", "RenderableShapeBuilder . indices    =    new   short [ capacity ]  ;", "}", "METHOD_END"], "methodName": ["ensureIndicesCapacity"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.RenderableShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( RenderableShapeBuilder . vertices )     =  =    null )     |  |     (  ( RenderableShapeBuilder . vertices . length )     <    capacity )  )", "RenderableShapeBuilder . vertices    =    new   float [ capacity ]  ;", "}", "METHOD_END"], "methodName": ["ensureVerticesCapacity"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.RenderableShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "short   max    =     (  ( short )     (  -  3  2  7  6  8  )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . indices . length )  ;    i +  +  )", "if    (  (  . indices [ i ]  )     >    max )", "max    =     . indices [ i ]  ;", "return   max ;", "}", "METHOD_END"], "methodName": ["maxVerticeInIndices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.RenderableShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "short   min    =     (  ( short )     (  3  2  7  6  7  )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . indices . length )  ;    i +  +  )", "if    (  (  . indices [ i ]  )     <    min )", "min    =     . indices [ i ]  ;", "return   min ;", "}", "METHOD_END"], "methodName": ["minVerticeInIndices"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.RenderableShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "SphereShapeBuilder . build ( builder ,    transform ,    width ,    height ,    depth ,    divisionsU ,    divisionsV ,     0  ,     3  6  0  ,     0  ,     1  8  0  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.SphereShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "final   float   hw    =    width    *     0  .  5 F ;", "final   float   hh    =    height    *     0  .  5 F ;", "final   float   hd    =    depth    *     0  .  5 F ;", "final   float   auo    =     ( MathUtils . degreesToRadians )     *    angleUFrom ;", "final   float   stepU    =     (  ( MathUtils . degreesToRadians )     *     ( angleUTo    -    angleUFrom )  )     /    divisionsU ;", "final   float   avo    =     ( MathUtils . degreesToRadians )     *    angleVFrom ;", "final   float   stepV    =     (  ( MathUtils . degreesToRadians )     *     ( angleVTo    -    angleVFrom )  )     /    divisionsV ;", "final   float   us    =     1  .  0 F    /    divisionsU ;", "final   float   vs    =     1  .  0 F    /    divisionsV ;", "float   u    =     0  .  0 F ;", "float   v    =     0  .  0 F ;", "float   angleU    =     0  .  0 F ;", "float   angleV    =     0  .  0 F ;", "MeshPartBuilder . VertexInfo   curr 1     =    BaseShapeBuilder . vertTmp 3  . set ( null ,    null ,    null ,    null )  ;", "curr 1  . hasUV    =    curr 1  . hasPosition    =    curr 1  . hasNormal    =    true ;", "final   int   s    =    divisionsU    +     3  ;", ". tmpIndices . clear (  )  ;", ". tmpIndices . ensureCapacity (  ( divisionsU    *     2  )  )  ;", ". tmpIndices . size    =    s ;", "int   tempOffset    =     0  ;", "builder . ensureVertices (  (  ( divisionsV    +     1  )     *     ( divisionsU    +     1  )  )  )  ;", "builder . ensureRectangleIndices ( divisionsU )  ;", "for    ( int   iv    =     0  ;    iv    <  =    divisionsV ;    iv +  +  )     {", "angleV    =    avo    +     ( stepV    *    iv )  ;", "v    =    vs    *    iv ;", "final   float   t    =    MathUtils . sin ( angleV )  ;", "final   float   h    =     ( MathUtils . cos ( angleV )  )     *    hh ;", "for    ( int   iu    =     0  ;    iu    <  =    divisionsU ;    iu +  +  )     {", "angleU    =    auo    +     ( stepU    *    iu )  ;", "u    =     1  .  0 F    -     ( us    *    iu )  ;", "curr 1  . position . set (  (  (  ( MathUtils . cos ( angleU )  )     *    hw )     *    t )  ,    h ,     (  (  ( MathUtils . sin ( angleU )  )     *    hd )     *    t )  )  . mul ( transform )  ;", "curr 1  . normal . set ( curr 1  . position )  . nor (  )  ;", "curr 1  . uv . set ( u ,    v )  ;", ". tmpIndices . set ( tempOffset ,    builder . vertex ( curr 1  )  )  ;", "final   int   o    =    tempOffset    +    s ;", "if    (  ( iv    >     0  )     &  &     ( iu    >     0  )  )", "builder . rect (  . tmpIndices . get ( tempOffset )  ,     . tmpIndices . get (  (  ( o    -     1  )     %    s )  )  ,     . tmpIndices . get (  (  ( o    -     ( divisionsU    +     2  )  )     %    s )  )  ,     . tmpIndices . get (  (  ( o    -     ( divisionsU    +     1  )  )     %    s )  )  )  ;", "tempOffset    =     ( tempOffset    +     1  )     %     (  . tmpIndices . size )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.SphereShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "SphereShapeBuilder . build ( builder ,    width ,    height ,    depth ,    divisionsU ,    divisionsV ,     0  ,     3  6  0  ,     0  ,     1  8  0  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.SphereShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "SphereShapeBuilder . build ( builder ,    BaseShapeBuilder . matTmp 1  . idt (  )  ,    width ,    height ,    depth ,    divisionsU ,    divisionsV ,    angleUFrom ,    angleUTo ,    angleVFrom ,    angleVTo )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.g3d.utils.shapebuilders.SphereShapeBuilder"}, {"methodBody": ["METHOD_START", "{", "int   dataOffset    =     0  ;", "int   width    =     0  ;", "int   height    =     0  ;", "if    ( etc 1 Data . hasPKMHeader (  )  )     {", "dataOffset    =     1  6  ;", "width    =     . getWidthPKM ( etc 1 Data . compressedData ,     0  )  ;", "height    =     . getHeightPKM ( etc 1 Data . compressedData ,     0  )  ;", "} else    {", "dataOffset    =     0  ;", "width    =    etc 1 Data . width ;", "height    =    etc 1 Data . height ;", "}", "int   pixelSize    =     . getPixelSize ( format )  ;", "Pixmap   pixmap    =    new   Pixmap ( width ,    height ,    format )  ;", ". decodeImage ( etc 1 Data . compressedData ,    dataOffset ,    pixmap . getPixels (  )  ,     0  ,    width ,    height ,    pixelSize )  ;", "return   pixmap ;", "}", "METHOD_END"], "methodName": ["decodeImage"], "fileName": "com.badlogic.gdx.graphics.glutils.ETC1"}, {"methodBody": ["METHOD_START", "{", "int   pixelSize    =    ETC 1  . getPixelSize ( pixmap . getFormat (  )  )  ;", "ByteBuffer   compressedData    =    ETC 1  . encodeImage ( pixmap . getPixels (  )  ,     0  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    pixelSize )  ;", "BufferUnewUnsafeByteBuffer ( compressedData )  ;", "return   new   ETC 1  . ETC 1 Data ( pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    compressedData ,     0  )  ;", "}", "METHOD_END"], "methodName": ["encodeImage"], "fileName": "com.badlogic.gdx.graphics.glutils.ETC1"}, {"methodBody": ["METHOD_START", "{", "int   pixelSize    =    ETC 1  . getPixelSize ( pixmap . getFormat (  )  )  ;", "ByteBuffer   compressedData    =    ETC 1  . encodeImagePKM ( pixmap . getPixels (  )  ,     0  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    pixelSize )  ;", "BufferUnewUnsafeByteBuffer ( compressedData )  ;", "return   new   ETC 1  . ETC 1 Data ( pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    compressedData ,     1  6  )  ;", "}", "METHOD_END"], "methodName": ["encodeImagePKM"], "fileName": "com.badlogic.gdx.graphics.glutils.ETC1"}, {"methodBody": ["METHOD_START", "{", "if    ( format    =  =     ( Pixmap . Format . RGB 5  6  5  )  )", "return    2  ;", "if    ( format    =  =     ( Pixmap . Format . RGB 8  8  8  )  )", "return    3  ;", "throw   new   GdxRuntimeException (  \" Can   only   handle   RGB 5  6  5    or   RGB 8  8  8    images \"  )  ;", "}", "METHOD_END"], "methodName": ["getPixelSize"], "fileName": "com.badlogic.gdx.graphics.glutils.ETC1"}, {"methodBody": ["METHOD_START", "{", "return   data [ side . index ]  ;", "}", "METHOD_END"], "methodName": ["getTextureData"], "fileName": "com.badlogic.gdx.graphics.glutils.FacedCubemapData"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( data . length )  ;    i +  +  )", "if    (  ( data [ i ]  )     =  =    null )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "com.badlogic.gdx.graphics.glutils.FacedCubemapData"}, {"methodBody": ["METHOD_START", "{", "data [ side . index ]     =    TextureData . Factory . loadFromFile ( file ,    false )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.glutils.FacedCubemapData"}, {"methodBody": ["METHOD_START", "{", "data [ side . index ]     =     ( pixmap    =  =    null )     ?    null    :    new   PixmapTextureData ( pixmap ,    null ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.graphics.glutils.FacedCubemapData"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFileHandle"], "fileName": "com.badlogic.gdx.graphics.glutils.FileTextureData"}, {"methodBody": ["METHOD_START", "{", "return   buffer ;", "}", "METHOD_END"], "methodName": ["getBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.FloatTextureData"}, {"methodBody": ["METHOD_START", "{", "GLFrameBuffer . unbind (  )  ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "com.badlogic.gdx.graphics.glutils.FrameBuffer"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl 2  0  . glFramebufferTexture 2 D ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 2  0  . GL _ COLOR _ ATTACHMENT 0  ,    side . glEnum ,    getColorBufferTexture (  )  . getTextureObjectHandle (  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["bindSide"], "fileName": "com.badlogic.gdx.graphics.glutils.FrameBufferCubemap"}, {"methodBody": ["METHOD_START", "{", "return    ( currentSide )     <     0     ?    null    :    FrameBufferCubemap . cubemapSides [ currentSide ]  ;", "}", "METHOD_END"], "methodName": ["getSide"], "fileName": "com.badlogic.gdx.graphics.glutils.FrameBufferCubemap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentSide )     >     5  )     {", "throw   new   GdxRuntimeException (  \" No   rining   sides .  \"  )  ;", "} else", "if    (  ( currentSide )     =  =     5  )     {", "return   false ;", "}", "( currentSide )  +  +  ;", "bindSide ( getSide (  )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["nextSide"], "fileName": "com.badlogic.gdx.graphics.glutils.FrameBufferCubemap"}, {"methodBody": ["METHOD_START", "{", "Array < GLFrameBuffer >    managedResources    =    GLFrameBuffer . buffers . get ( app )  ;", "if    ( managedResources    =  =    null )", "managedResources    =    new   Array < GLFrameBuffer >  (  )  ;", "managedResources . add ( frameBuffer )  ;", "GLFrameBuffer . buffers . put ( app ,    managedResources )  ;", "}", "METHOD_END"], "methodName": ["addManagedFrameBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "bind (  )  ;", "setViewport (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl 2  0  . glBindFramebuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    framebufferHandle )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkValidBuilder (  )  ;", "if    (  !  (  . defaultFramebufferHandleInitialized )  )     {", ". defaultFramebufferHandleInitialized    =    true ;", "if    (  ( Gdx . app . getType (  )  )     =  =     ( Application . ApplicationType . iOS )  )     {", "IntBuffer   intbuf    =    ByteBuffer . allocateDirect (  (  (  1  6     *     ( Integer . SIZE )  )     /     8  )  )  . order ( ByteOrder . nativeOrder (  )  )  . asIntBuffer (  )  ;", "gl . glGetIntegerv ( GL 2  0  . GL _ FRAMEBUFFER _ BINDING ,    intbuf )  ;", ". defaultFramebufferHandle    =    intbuf . get (  0  )  ;", "} else    {", ". defaultFramebufferHandle    =     0  ;", "}", "}", "framebufferHandle    =    gl . glGenFramebuffer (  )  ;", "gl . glBindFramebuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    framebufferHandle )  ;", "int   width    =    bufferBuilder . width ;", "int   height    =    bufferBuilder . height ;", "if    ( bufferBuilder . hasDepthRenderBuffer )     {", "depthbufferHandle    =    gl . glGenRenderbuffer (  )  ;", "gl . glBindRenderbuffer ( GL 2  0  . GL _ RENDERBUFFER ,    depthbufferHandle )  ;", "gl . glRenderbufferStorage ( GL 2  0  . GL _ RENDERBUFFER ,    bufferBuilder . depthRenderBufferSpec . internalFormat ,    width ,    height )  ;", "}", "if    ( bufferBuilder . hasStencilRenderBuffer )     {", "stencilbufferHandle    =    gl . glGenRenderbuffer (  )  ;", "gl . glBindRenderbuffer ( GL 2  0  . GL _ RENDERBUFFER ,    stencilbufferHandle )  ;", "gl . glRenderbufferStorage ( GL 2  0  . GL _ RENDERBUFFER ,    bufferBuilder . stencilRenderBufferSpec . internalFormat ,    width ,    height )  ;", "}", "if    ( bufferBuilder . hasPackedStencilDepthRenderBuffer )     {", "depthStencilPackedBufferHandle    =    gl . glGenRenderbuffer (  )  ;", "gl . glBindRenderbuffer ( GL 2  0  . GL _ RENDERBUFFER ,    depthStencilPackedBufferHandle )  ;", "gl . glRenderbufferStorage ( GL 2  0  . GL _ RENDERBUFFER ,    bufferBuilder . packedStencilDepthRenderBufferSpec . internalFormat ,    width ,    height )  ;", "}", "isMRT    =     ( bufferBuilder . textureAttachmentSpecs . size )     >     1  ;", "int   colorTextureCounter    =     0  ;", "if    ( isMRT )     {", "for    (  . FrameBufferTextureAttachmentSpec   attachmentSpec    :    bufferBuilder . textureAttachmentSpecs )     {", "T   texture    =    createTexture ( attachmentSpec )  ;", "textureAttachments . add ( texture )  ;", "if    ( attachmentSpec . isColorTexture (  )  )     {", "gl . glFramebufferTexture 2 D ( GL 2  0  . GL _ FRAMEBUFFER ,     (  ( GL 3  0  . GL _ COLOR _ ATTACHMENT 0  )     +    colorTextureCounter )  ,    GL 3  0  . GL _ TEXTURE _  2 D ,    texture . getTextureObjectHandle (  )  ,     0  )  ;", "colorTextureCounter +  +  ;", "} else", "if    ( attachmentSpec . isDepth )     {", "gl . glFramebufferTexture 2 D ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 2  0  . GL _ DEPTH _ ATTACHMENT ,    GL 2  0  . GL _ TEXTURE _  2 D ,    texture . getTextureObjectHandle (  )  ,     0  )  ;", "} else", "if    ( attachmentSpec . isStencil )     {", "gl . glFramebufferTexture 2 D ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 2  0  . GL _ STENCIL _ ATTACHMENT ,    GL 2  0  . GL _ TEXTURE _  2 D ,    texture . getTextureObjectHandle (  )  ,     0  )  ;", "}", "}", "} else    {", "T   texture    =    createTexture ( bufferBuilder . textureAttachmentSpecs . first (  )  )  ;", "textureAttachments . add ( texture )  ;", "gl . glBindTexture ( texture . glTarget ,    texture . getTextureObjectHandle (  )  )  ;", "}", "if    ( isMRT )     {", "IntBuffer   buffer    =    BufferUtils . newIntBuffer ( colorTextureCounter )  ;", "for    ( int   i    =     0  ;    i    <    colorTextureCounter ;    i +  +  )     {", "buffer . put (  (  ( GL 3  0  . GL _ COLOR _ ATTACHMENT 0  )     +    i )  )  ;", "}", "buffer . position (  0  )  ;", "Gdx . gl 3  0  . glDrawBuffers ( colorTextureCounter ,    buffer )  ;", "} else    {", "attachFrameBufferColorTexture ( textureAttachments . first (  )  )  ;", "}", "if    ( bufferBuilder . hasDepthRenderBuffer )     {", "gl . glFramebufferRenderbuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 2  0  . GL _ DEPTH _ ATTACHMENT ,    GL 2  0  . GL _ RENDERBUFFER ,    depthbufferHandle )  ;", "}", "if    ( bufferBuilder . hasStencilRenderBuffer )     {", "gl . glFramebufferRenderbuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 2  0  . GL _ STENCIL _ ATTACHMENT ,    GL 2  0  . GL _ RENDERBUFFER ,    stencilbufferHandle )  ;", "}", "if    ( bufferBuilder . hasPackedStencilDepthRenderBuffer )     {", "gl . glFramebufferRenderbuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 3  0  . GL _ DEPTH _ STENCIL _ ATTACHMENT ,    GL 2  0  . GL _ RENDERBUFFER ,    depthStencilPackedBufferHandle )  ;", "}", "gl . glBindRenderbuffer ( GL 2  0  . GL _ RENDERBUFFER ,     0  )  ;", "for    ( T   texture    :    textureAttachments )     {", "gl . glBindTexture ( texture . glTarget ,     0  )  ;", "}", "int   result    =    gl . glCheckFramebufferStatus ( GL 2  0  . GL _ FRAMEBUFFER )  ;", "if    (  (  (  ( result    =  =     ( GL 2  0  . GL _ FRAMEBUFFER _ UNSUPPORTED )  )     &  &     ( bufferBuilder . hasDepthRenderBuffer )  )     &  &     ( bufferBuilder . hasStencilRenderBuffer )  )     &  &     (  ( Gdx . graphics . supportsExtension (  \" GL _ OES _ packed _ depth _ stencil \"  )  )     |  |     ( Gdx . graphics . supportsExtension (  \" GL _ EXT _ packed _ depth _ stencil \"  )  )  )  )     {", "if    ( bufferBuilder . hasDepthRenderBuffer )     {", "gl . glDeleteRenderbuffer ( depthbufferHandle )  ;", "depthbufferHandle    =     0  ;", "}", "if    ( bufferBuilder . hasStencilRenderBuffer )     {", "gl . glDeleteRenderbuffer ( stencilbufferHandle )  ;", "stencilbufferHandle    =     0  ;", "}", "if    ( bufferBuilder . hasPackedStencilDepthRenderBuffer )     {", "gl . glDeleteRenderbuffer ( depthStencilPackedBufferHandle )  ;", "depthStencilPackedBufferHandle    =     0  ;", "}", "depthStencilPackedBufferHandle    =    gl . glGenRenderbuffer (  )  ;", "hasDepthStencilPackedBuffer    =    true ;", "gl . glBindRenderbuffer ( GL 2  0  . GL _ RENDERBUFFER ,    depthStencilPackedBufferHandle )  ;", "gl . glRenderbufferStorage ( GL 2  0  . GL _ RENDERBUFFER ,     . GL _ DEPTH 2  4  _ STENCIL 8  _ OES ,    width ,    height )  ;", "gl . glBindRenderbuffer ( GL 2  0  . GL _ RENDERBUFFER ,     0  )  ;", "gl . glFramebufferRenderbuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 2  0  . GL _ DEPTH _ ATTACHMENT ,    GL 2  0  . GL _ RENDERBUFFER ,    depthStencilPackedBufferHandle )  ;", "gl . glFramebufferRenderbuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    GL 2  0  . GL _ STENCIL _ ATTACHMENT ,    GL 2  0  . GL _ RENDERBUFFER ,    depthStencilPackedBufferHandle )  ;", "result    =    gl . glCheckFramebufferStatus ( GL 2  0  . GL _ FRAMEBUFFER )  ;", "}", "gl . glBindFramebuffer ( GL 2  0  . GL _ FRAMEBUFFER ,     . defaultFramebufferHandle )  ;", "if    ( result    !  =     ( GL 2  0  . GL _ FRAMEBUFFER _ COMPLETE )  )     {", "for    ( T   texture    :    textureAttachments )     {", "disposeColorTexture ( texture )  ;", "}", "if    ( hasDepthStencilPackedBuffer )     {", "gl . glDeleteBuffer ( depthStencilPackedBufferHandle )  ;", "} else    {", "if    ( bufferBuilder . hasDepthRenderBuffer )", "gl . glDeleteRenderbuffer ( depthbufferHandle )  ;", "if    ( bufferBuilder . hasStencilRenderBuffer )", "gl . glDeleteRenderbuffer ( stencilbufferHandle )  ;", "}", "gl . glDeleteFramebuffer ( framebufferHandle )  ;", "if    ( result    =  =     ( GL 2  0  . GL _ FRAMEBUFFER _ INCOMPLETE _ ATTACHMENT )  )", "throw   new   IllegalStateException (  \" frame   buffer   couldn ' t   be   constructed :    incomplete   attachment \"  )  ;", "if    ( result    =  =     ( GL 2  0  . GL _ FRAMEBUFFER _ INCOMPLETE _ DIMENSIONS )  )", "throw   new   IllegalStateException (  \" frame   buffer   couldn ' t   be   constructed :    incomplete   dimensions \"  )  ;", "if    ( result    =  =     ( GL 2  0  . GL _ FRAMEBUFFER _ INCOMPLETE _ MISSING _ ATTACHMENT )  )", "throw   new   IllegalStateException (  \" frame   buffer   couldn ' t   be   constructed :    missing   attachment \"  )  ;", "if    ( result    =  =     ( GL 2  0  . GL _ FRAMEBUFFER _ UNSUPPORTED )  )", "throw   new   IllegalStateException (  \" frame   buffer   couldn ' t   be   constructed :    unsupported   combination   of   formats \"  )  ;", "throw   new   IllegalStateException (  (  \" frame   buffer   couldn ' t   be   constructed :    unknown   error    \"     +    result )  )  ;", "}", ". addManagedFrameBuffer ( Gdx . app ,    this )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "boolean   runningGL 3  0     =    Gdx . graphics . isGL 3  0 Available (  )  ;", "if    (  ! runningGL 3  0  )     {", "if    ( bufferBuilder . hasPackedStencilDepthRenderBuffer )     {", "throw   new   GdxRuntimeException (  \" Packed   Stencil / Render   render   buffers   are   not   available   on   GLES    2  .  0  \"  )  ;", "}", "if    (  ( bufferBuilder . textureAttachmentSpecs . size )     >     1  )     {", "throw   new   GdxRuntimeException (  \" Multiple   render   targets   not   available   on   GLES    2  .  0  \"  )  ;", "}", "for    (  . FrameBufferTextureAttachmentSpec   spec    :    bufferBuilder . textureAttachmentSpecs )     {", "if    ( spec . isDepth )", "throw   new   GdxRuntimeException (  \" Depth   texture   FrameBuffer   Attachment   not   available   on   GLES    2  .  0  \"  )  ;", "if    ( spec . isStencil )", "throw   new   GdxRuntimeException (  \" Stencil   texture   FrameBuffer   Attachment   not   available   on   GLES    2  .  0  \"  )  ;", "if    ( spec . isFloat )     {", "if    (  !  ( Gdx . graphics . supportsExtension (  \" OES _ texture _ float \"  )  )  )     {", "throw   new   GdxRuntimeException (  \" Float   texture   FrameBuffer   Attachment   not   available   on   GLES    2  .  0  \"  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkValidBuilder"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "GLFrameBuffer . buffers . remove ( app )  ;", "}", "METHOD_END"], "methodName": ["clearAllFrameBuffers"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "end (  0  ,     0  ,    Gdx . graphics . getBackBufferWidth (  )  ,    Gdx . graphics . getBackBufferHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "GLFrameBuffer . unbind (  )  ;", "Gdx . gl 2  0  . glViewport ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   textureAttachments . first (  )  ;", "}", "METHOD_END"], "methodName": ["getColorBufferTexture"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   depthbufferHandle ;", "}", "METHOD_END"], "methodName": ["getDepthBufferHandle"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   depthStencilPackedBufferHandle ;", "}", "METHOD_END"], "methodName": ["getDepthStencilPackedBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   framebufferHandle ;", "}", "METHOD_END"], "methodName": ["getFramebufferHandle"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   bufferBuilder . height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   GLFrameBuffer . getManagedStatus ( new   StringBuilder (  )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getManagedStatus"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "builder . append (  \" Managed   buffers / app :     {     \"  )  ;", "for    ( Application   app    :     . buffers . keySet (  )  )     {", "builder . append (  . buffers . get ( app )  . size )  ;", "builder . append (  \"     \"  )  ;", "}", "builder . append (  \"  }  \"  )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["getManagedStatus"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   stencilbufferHandle ;", "}", "METHOD_END"], "methodName": ["getStencilBufferHandle"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   textureAttachments ;", "}", "METHOD_END"], "methodName": ["getTextureAttachments"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "return   bufferBuilder . width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Gdx . gl 2  0  )     =  =    null )", "return ;", "Array <  >    bufferArray    =     . buffers . get ( app )  ;", "if    ( bufferArray    =  =    null )", "return ;", "for    ( int   i    =     0  ;    i    <     ( bufferArray . size )  ;    i +  +  )     {", "bufferArray . get ( i )  . build (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidateAllFrameBuffers"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl 2  0  . glViewport (  0  ,     0  ,    bufferBuilder . width ,    bufferBuilder . height )  ;", "}", "METHOD_END"], "methodName": ["setFrameBufferViewport"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl 2  0  . glBindFramebuffer ( GL 2  0  . GL _ FRAMEBUFFER ,    GLFrameBuffer . defaultFramebufferHandle )  ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "com.badlogic.gdx.graphics.glutils.GLFrameBuffer"}, {"methodBody": ["METHOD_START", "{", "Pattern   pattern    =    Pattern . compile ( patternString )  ;", "Matcher   matcher    =    pattern . matcher ( versionString )  ;", "boolean   found    =    matcher . find (  )  ;", "if    ( found )     {", "String   result    =    matcher . group (  1  )  ;", "String [  ]    resultSplit    =    result . split (  \"  \\  \\  .  \"  )  ;", "major    =    parseInt ( resultSplit [  0  ]  ,     2  )  ;", "minor    =     (  ( resultSplit . length )     <     2  )     ?     0     :    parseInt ( resultSplit [  1  ]  ,     0  )  ;", "release    =     (  ( resultSplit . length )     <     3  )     ?     0     :    parseInt ( resultSplit [  2  ]  ,     0  )  ;", "} else    {", "Gdx . app . log ( TAG ,     (  \" Invalid   version   string :     \"     +    versionString )  )  ;", "major    =     2  ;", "minor    =     0  ;", "release    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["extractVersion"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  \" Type :     \"     +     ( type )  )     +     \"  \\ n \"  )     +     \" Version :     \"  )     +     ( majorVersion )  )     +     \"  :  \"  )     +     ( minorVersion )  )     +     \"  :  \"  )     +     ( releaseVersion )  )     +     \"  \\ n \"  )     +     \" Vendor :     \"  )     +     ( vendorString )  )     +     \"  \\ n \"  )     +     \" Renderer :     \"  )     +     ( rendererString )  ;", "}", "METHOD_END"], "methodName": ["getDebugVersionString"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return   majorVersion ;", "}", "METHOD_END"], "methodName": ["getMajorVersion"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return   minorVersion ;", "}", "METHOD_END"], "methodName": ["getMinorVersion"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return   releaseVersion ;", "}", "METHOD_END"], "methodName": ["getReleaseVersion"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return   rendererString ;", "}", "METHOD_END"], "methodName": ["getRendererString"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return   vendorString ;", "}", "METHOD_END"], "methodName": ["getVendorString"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "return    (  ( majorVersion )     >    testMajorVersion )     |  |     (  (  ( majorVersion )     =  =    testMajorVersion )     &  &     (  ( minorVersion )     >  =    testMinorVersion )  )  ;", "}", "METHOD_END"], "methodName": ["isVersionEqualToOrHigher"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Integer . parseInt ( v )  ;", "}    catch    ( NumberFormatExcept   nfe )     {", "Gdx . app . error (  \" LibGDX   GL \"  ,     (  (  (  \" Error   parsing   number :     \"     +    v )     +     \"  ,    assuming :     \"  )     +    defaultValue )  )  ;", "return   defaultValue ;", "}", "}", "METHOD_END"], "methodName": ["parseInt"], "fileName": "com.badlogic.gdx.graphics.glutils.GLVersion"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( Gdx . graphics . getWidth (  )  )     !  =     ( Gdx . graphics . getBackBufferWidth (  )  )  )     |  |     (  ( Gdx . graphics . getHeight (  )  )     !  =     ( Gdx . graphics . getBackBufferHeight (  )  )  )  )     {", "Gdx . gl . glScissor ( HdpiUtils . toBackBufferX ( x )  ,    HdpiUtils . toBackBufferY ( y )  ,    HdpiUtils . toBackBufferX ( width )  ,    HdpiUtils . toBackBufferY ( height )  )  ;", "} else    {", "Gdx . gl . glScissor ( x ,    y ,    width ,    height )  ;", "}", "}", "METHOD_END"], "methodName": ["glScissor"], "fileName": "com.badlogic.gdx.graphics.glutils.HdpiUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( Gdx . graphics . getWidth (  )  )     !  =     ( Gdx . graphics . getBackBufferWidth (  )  )  )     |  |     (  ( Gdx . graphics . getHeight (  )  )     !  =     ( Gdx . graphics . getBackBufferHeight (  )  )  )  )     {", "Gdx . gl . glViewport ( HdpiUtils . toBackBufferX ( x )  ,    HdpiUtils . toBackBufferY ( y )  ,    HdpiUtils . toBackBufferX ( width )  ,    HdpiUtils . toBackBufferY ( height )  )  ;", "} else    {", "Gdx . gl . glViewport ( x ,    y ,    width ,    height )  ;", "}", "}", "METHOD_END"], "methodName": ["glViewport"], "fileName": "com.badlogic.gdx.graphics.glutils.HdpiUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  ( logicalX    *     ( Gdx . graphics . getBackBufferWidth (  )  )  )     /     (  ( float )     ( Gdx . graphics . getWidth (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toBackBufferX"], "fileName": "com.badlogic.gdx.graphics.glutils.HdpiUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  ( logicalY    *     ( Gdx . graphics . getBackBufferHeight (  )  )  )     /     (  ( float )     ( Gdx . graphics . getHeight (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toBackBufferY"], "fileName": "com.badlogic.gdx.graphics.glutils.HdpiUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  ( backBufferX    *     ( Gdx . graphics . getWidth (  )  )  )     /     (  ( float )     ( Gdx . graphics . getBackBufferWidth (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toLogicalX"], "fileName": "com.badlogic.gdx.graphics.glutils.HdpiUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  ( backBufferY    *     ( Gdx . graphics . getHeight (  )  )  )     /     (  ( float )     ( Gdx . graphics . getBackBufferHeight (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toLogicalY"], "fileName": "com.badlogic.gdx.graphics.glutils.HdpiUtils"}, {"methodBody": ["METHOD_START", "{", "this . projModelView . set ( projModelView )  ;", "this . primitiveType    =    primitiveType ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "Array < VertexAttribute >    attribs    =    new   Array < VertexAttribute >  (  )  ;", "attribs . add ( new   VertexAttribute ( VertexAttributes . Usage . Position ,     3  ,    ShaderProm . POSITION _ ATTRIBUTE )  )  ;", "if    ( hasNormals )", "attribs . add ( new   VertexAttribute ( VertexAttributes . Usage . Normal ,     3  ,    ShaderProm . NORMAL _ ATTRIBUTE )  )  ;", "if    ( hasColor )", "attribs . add ( new   VertexAttribute ( VertexAttributes . Usage . ColorPacked ,     4  ,    ShaderProm . COLOR _ ATTRIBUTE )  )  ;", "for    ( int   i    =     0  ;    i    <    numTexCoords ;    i +  +  )     {", "attribs . add ( new   VertexAttribute ( VertexAttributes . Usage . TextureCoordinates ,     2  ,     (  ( ShaderProm . TEXCOORD _ ATTRIBUTE )     +    i )  )  )  ;", "}", "VertexAttribute [  ]    array    =    new   VertexAttribute [ attribs . size ]  ;", "for    ( int   i    =     0  ;    i    <     ( attribs . size )  ;    i +  +  )", "array [ i ]     =    attribs . get ( i )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["buildVertexAttributes"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "vertices [  (  ( vertexIdx )     +     ( colorOffset )  )  ]     =    color . toFloatBits (  )  ;", "}", "METHOD_END"], "methodName": ["color"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "vertices [  (  ( vertexIdx )     +     ( colorOffset )  )  ]     =    colorBits ;", "}", "METHOD_END"], "methodName": ["color"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "vertices [  (  ( vertexIdx )     +     ( colorOffset )  )  ]     =    Color . toFloatBits ( r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["color"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "String   vertexShader    =    ImmediateModeRenderer 2  0  . createVertexShader ( hasNormals ,    hasColors ,    numTexCoords )  ;", "String   fragmentShader    =    ImmediateModeRenderer 2  0  . createFragmentShader ( hasNormals ,    hasColors ,    numTexCoords )  ;", "ShaderProgram   program    =    new   ShaderProgram ( vertexShader ,    fragmentShader )  ;", "return   program ;", "}", "METHOD_END"], "methodName": ["createDefaultShader"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "String   shader    =     \"  # ifdef   GL _ ES \\ n \"     +     (  \" precision   mediump   float ;  \\ n \"     +     \"  # endif \\ n \"  )  ;", "if    ( hasColors )", "shader    +  =     \" varying   vec 4    v _ col ;  \\ n \"  ;", "for    ( int   i    =     0  ;    i    <    numTexCoords ;    i +  +  )     {", "shader    +  =     (  \" varying   vec 2    v _ tex \"     +    i )     +     \"  ;  \\ n \"  ;", "shader    +  =     (  \" uniform   sampler 2 D   u _ sampler \"     +    i )     +     \"  ;  \\ n \"  ;", "}", "shader    +  =     (  \" void   main (  )     {  \\ n \"     +     \"          gl _ FragColor    =     \"  )     +     ( hasColors    ?     \" v _ col \"     :     \" vec 4  (  1  ,     1  ,     1  ,     1  )  \"  )  ;", "if    ( numTexCoords    >     0  )", "shader    +  =     \"     *     \"  ;", "for    ( int   i    =     0  ;    i    <    numTexCoords ;    i +  +  )     {", "if    ( i    =  =     ( numTexCoords    -     1  )  )     {", "shader    +  =     (  (  (  \"    texture 2 D ( u _ sampler \"     +    i )     +     \"  ,       v _ tex \"  )     +    i )     +     \"  )  \"  ;", "} else    {", "shader    +  =     (  (  (  \"    texture 2 D ( u _ sampler \"     +    i )     +     \"  ,       v _ tex \"  )     +    i )     +     \"  )     *  \"  ;", "}", "}", "shader    +  =     \"  ;  \\ n }  \"  ;", "return   shader ;", "}", "METHOD_END"], "methodName": ["createFragmentShader"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "String   shader    =     (  (  (  \" attribute   vec 4     \"     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     ( hasNormals    ?     (  \" attribute   vec 3     \"     +     ( ShaderProgram . NORMAL _ ATTRIBUTE )  )     +     \"  ;  \\ n \"     :     \"  \"  )  )     +     ( hasColors    ?     (  \" attribute   vec 4     \"     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"     :     \"  \"  )  ;", "for    ( int   i    =     0  ;    i    <    numTexCoords ;    i +  +  )     {", "shader    +  =     (  (  \" attribute   vec 2     \"     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +    i )     +     \"  ;  \\ n \"  ;", "}", "shader    +  =     \" uniform   mat 4    u _ projlView ;  \\ n \"  ;", "shader    +  =     ( hasColors )     ?     \" varying   vec 4    v _ col ;  \\ n \"     :     \"  \"  ;", "for    ( int   i    =     0  ;    i    <    numTexCoords ;    i +  +  )     {", "shader    +  =     (  \" varying   vec 2    v _ tex \"     +    i )     +     \"  ;  \\ n \"  ;", "}", "shader    +  =     (  (  (  \" void   main (  )     {  \\ n \"     +     \"          gl _ Position    =    u _ projlView    *     \"  )     +     ( ShaderProgram . POSITION _ ATTRIBUTE )  )     +     \"  ;  \\ n \"  )     +     ( hasColors    ?     (  \"          v _ col    =     \"     +     ( ShaderProgram . COLOR _ ATTRIBUTE )  )     +     \"  ;  \\ n \"     :     \"  \"  )  ;", "for    ( int   i    =     0  ;    i    <    numTexCoords ;    i +  +  )     {", "shader    +  =     (  (  (  (  \"          v _ tex \"     +    i )     +     \"     =     \"  )     +     ( ShaderProgram . TEXCOORD _ ATTRIBUTE )  )     +    i )     +     \"  ;  \\ n \"  ;", "}", "shader    +  =     \"          gl _ PointSize    =     1  .  0  ;  \\ n \"  ;", "shader    +  =     \"  }  \\ n \"  ;", "return   shader ;", "}", "METHOD_END"], "methodName": ["createVertexShader"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ownsShader )     &  &     (  ( shader )     !  =    null )  )", "shader . dispose (  )  ;", "mesh . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "flush (  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "if    (  ( numVertices )     =  =     0  )", "return ;", "shader . begin (  )  ;", "shader . setUniformMatrix (  \" u _ projModelView \"  ,    projModelView )  ;", "for    ( int   i    =     0  ;    i    <     ( numTexCoords )  ;    i +  +  )", "shader . setUniformi ( shaderUniformNames [ i ]  ,    i )  ;", "mesh . setVertices ( vertices ,     0  ,    vertexIdx )  ;", "mesh . r ( shader ,    primitiveType )  ;", "shader . end (  )  ;", "numSetTexCoords    =     0  ;", "vertexIdx    =     0  ;", "numVertices    =     0  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "return   numVertices ;", "}", "METHOD_END"], "methodName": ["getNumVertices"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "final   int   idx    =     ( vertexIdx )     +     ( normalOffset )  ;", "vertices [ idx ]     =    x ;", "vertices [  ( idx    +     1  )  ]     =    y ;", "vertices [  ( idx    +     2  )  ]     =    z ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "if    ( ownsShader )", "this . shader . dispose (  )  ;", "this . shader    =    shader ;", "ownsShader    =    false ;", "}", "METHOD_END"], "methodName": ["setShader"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "final   int   idx    =     ( vertexIdx )     +     ( texCoordOffset )  ;", "vertices [  ( idx    +     ( numSetTexCoords )  )  ]     =    u ;", "vertices [  (  ( idx    +     ( numSetTexCoords )  )     +     1  )  ]     =    v ;", "numSetTexCoords    +  =     2  ;", "}", "METHOD_END"], "methodName": ["texCoord"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "final   int   idx    =    vertexIdx ;", "vertices [ idx ]     =    x ;", "vertices [  ( idx    +     1  )  ]     =    y ;", "vertices [  ( idx    +     2  )  ]     =    z ;", "numSetTexCoords    =     0  ;", "vertexIdx    +  =    vertexSize ;", "( numVertices )  +  +  ;", "}", "METHOD_END"], "methodName": ["vertex"], "fileName": "com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . disposeUnsafeByteBuffer ( byteBuffer )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexArray"}, {"methodBody": ["METHOD_START", "{", "return   buffer ;", "}", "METHOD_END"], "methodName": ["getBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexArray"}, {"methodBody": ["METHOD_START", "{", "return   empty    ?     0     :    buffer . limit (  )  ;", "}", "METHOD_END"], "methodName": ["getNumIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexArray"}, {"methodBody": ["METHOD_START", "{", "return   empty    ?     0     :    buffer . capacity (  )  ;", "}", "METHOD_END"], "methodName": ["getNumMaxIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexArray"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    indices . position (  )  ;", "buffer . clear (  )  ;", "buffer . limit ( indices . remaining (  )  )  ;", "buffer . put ( indices )  ;", "buffer . flip (  )  ;", "indices . position ( pos )  ;", "byteBuffer . position (  0  )  ;", "byteBuffer . limit (  (  ( buffer . limit (  )  )     <  <     1  )  )  ;", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexArray"}, {"methodBody": ["METHOD_START", "{", "buffer . clear (  )  ;", "buffer . p ( indices ,    offset ,    count )  ;", "buffer . flip (  )  ;", "byteBuffer . position (  0  )  ;", "byteBuffer . limit (  ( count    <  <     1  )  )  ;", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bufferHandle )     =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" No   buffer   allocated !  \"  )  ;", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,    bufferHandle )  ;", "if    ( isDirty )     {", "byteBuffer . limit (  (  ( buffer . limit (  )  )     *     2  )  )  ;", "Gdx . gl 2  0  . glBufferData ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,    byteBuffer . limit (  )  ,    byteBuffer ,    usage )  ;", "isDirty    =    false ;", "}", "isBound    =    true ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  )  ;", "Gdx . gl 2  0  . glDeleteBuffer ( bufferHandle )  ;", "bufferHandle    =     0  ;", "BufferUtils . disposeUnsafeByteBuffer ( byteBuffer )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "return   b ;", "}", "METHOD_END"], "methodName": ["getBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "return   empty    ?     0     :    buffer . limit (  )  ;", "}", "METHOD_END"], "methodName": ["getNumIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "return   empty    ?     0     :    buffer . capacity (  )  ;", "}", "METHOD_END"], "methodName": ["getNumMaxIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "bufferHandle    =    Gdx . gl 2  0  . glGenBuffer (  )  ;", "isDirty    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "int   pos    =    indices . position (  )  ;", "buffer . clear (  )  ;", "buffer . put ( indices )  ;", "buffer . flip (  )  ;", "indices . position ( pos )  ;", "byte . position (  0  )  ;", "byte . limit (  (  ( buffer . limit (  )  )     <  <     1  )  )  ;", "if    ( isBound )     {", "Gdx . gl 2  0  . glData ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,    byte . limit (  )  ,    byte ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "buffer . clear (  )  ;", "buffer . put ( indices ,    offset ,    count )  ;", "buffer . flip (  )  ;", "byte . position (  0  )  ;", "byte . limit (  ( count    <  <     1  )  )  ;", "if    ( isBound )     {", "Gdx . gl 2  0  . glData ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,    byte . limit (  )  ,    byte ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  )  ;", "isBound    =    false ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bufferHandle )     =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" IndexBufferObject   cannot   be   used   after   it   has   been   disposed .  \"  )  ;", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,    bufferHandle )  ;", "if    ( isDirty )     {", "byteBuffer . limit (  (  ( buffer . limit (  )  )     *     2  )  )  ;", "Gdx . gl 2  0  . glBufferSubData ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  ,    byteBuffer . limit (  )  ,    byteBuffer )  ;", "isDirty    =    false ;", "}", "isBound    =    true ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "int   result    =    Gdx . gl 2  0  . glGenBuffer (  )  ;", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,    result )  ;", "Gdx . gl 2  0  . glBufferData ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,    byteBuffer . capacity (  )  ,    null ,    usage )  ;", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createBufferObject"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "gl . glBind ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  )  ;", "gl . glDelete ( bufferHandle )  ;", "bufferHandle    =     0  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "return   b ;", "}", "METHOD_END"], "methodName": ["getBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "return   buffer . limit (  )  ;", "}", "METHOD_END"], "methodName": ["getNumIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "return   buffer . capacity (  )  ;", "}", "METHOD_END"], "methodName": ["getNumMaxIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "bufferHandle    =    createBufferObject (  )  ;", "isDirty    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    indices . position (  )  ;", "isDirty    =    true ;", "buffer . clear (  )  ;", "buffer . put ( indices )  ;", "buffer . flip (  )  ;", "indices . position ( pos )  ;", "byteBuffer . position (  0  )  ;", "byteBuffer . limit (  (  ( buffer . limit (  )  )     <  <     1  )  )  ;", "if    ( isBound )     {", "Gdx . gl 2  0  . glBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  ,    byteBuffer . limit (  )  ,    byteBuffer )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "buffer . clear (  )  ;", "buffer . put ( indices ,    offset ,    count )  ;", "buffer . flip (  )  ;", "byteBuffer . position (  0  )  ;", "byteBuffer . limit (  ( count    <  <     1  )  )  ;", "if    ( isBound )     {", "Gdx . gl 2  0  . glBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  ,    byteBuffer . limit (  )  ,    byteBuffer )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ELEMENT _ ARRAY _ BUFFER ,     0  )  ;", "isBound    =    false ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compressedData )     !  =    null )", "utils . BufferUtils . disposeUnsafeByteBuffer ( compressedData )  ;", "compressedData    =    null ;", "}", "METHOD_END"], "methodName": ["disposePreparedData"], "fileName": "com.badlogic.gdx.graphics.glutils.KTXTextureData"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    imagePos ;", "for    ( int   level    =     0  ;    level    <     ( numberOfMipmapLevels )  ;    level +  +  )     {", "int   faceLodSize    =    compressed . getInt ( pos )  ;", "int   faceLodSizeRounded    =     ( faceLodSize    +     3  )     &     (  ~  3  )  ;", "pos    +  =     4  ;", "if    ( level    =  =    requestedLevel )     {", "for    ( int   face    =     0  ;    face    <     ( numberOfFaces )  ;    face +  +  )     {", "if    ( face    =  =    requestedFace )     {", "compressed . position ( pos )  ;", "ByteBuffer   data    =    compressed . slice (  )  ;", "data . limit ( faceLodSizeRounded )  ;", "return   data ;", "}", "pos    +  =    faceLodSizeRounded ;", "}", "} else    {", "pos    +  =    faceLodSizeRounded    *     ( numberOfFaces )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "com.badlogic.gdx.graphics.glutils.KTXTextureData"}, {"methodBody": ["METHOD_START", "{", "return   glInternalFormat ;", "}", "METHOD_END"], "methodName": ["getGlInternalFormat"], "fileName": "com.badlogic.gdx.graphics.glutils.KTXTextureData"}, {"methodBody": ["METHOD_START", "{", "return   numberOfFaces ;", "}", "METHOD_END"], "methodName": ["getNumberOfFaces"], "fileName": "com.badlogic.gdx.graphics.glutils.KTXTextureData"}, {"methodBody": ["METHOD_START", "{", "return   numberOfMipmapLevels ;", "}", "METHOD_END"], "methodName": ["getNumberOfMipMapLevels"], "fileName": "com.badlogic.gdx.graphics.glutils.KTXTextureData"}, {"methodBody": ["METHOD_START", "{", "MipMapGenerator . generateMipMap ( GL 2  0  . GL _ TEXTURE _  2 D ,    pixmap ,    textureWidth ,    textureHeight )  ;", "}", "METHOD_END"], "methodName": ["generateMipMap"], "fileName": "com.badlogic.gdx.graphics.glutils.MipMapGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( MipMapGenerator . useHWMipMap )  )     {", "MipMapGenerator . generateMipMapCPU ( target ,    pixmap ,    textureWidth ,    textureHeight )  ;", "return ;", "}", "if    (  (  (  ( Gdx . app . getType (  )  )     =  =     ( Application . ApplicationType . Android )  )     |  |     (  ( Gdx . app . getType (  )  )     =  =     ( Application . ApplicationType . WebGL )  )  )     |  |     (  ( Gdx . app . getType (  )  )     =  =     ( Application . ApplicationType . iOS )  )  )     {", "MipMapGenerator . generateMipMapGLES 2  0  ( target ,    pixmap )  ;", "} else    {", "MipMapGenerator . generateMipMapDesktop ( target ,    pixmap ,    textureWidth ,    textureHeight )  ;", "}", "}", "METHOD_END"], "methodName": ["generateMipMap"], "fileName": "com.badlogic.gdx.graphics.glutils.MipMapGenerator"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glTexImage 2 D ( target ,     0  ,    pixmap . getGLInternalFormat (  )  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,     0  ,    pixmap . getGLFormat (  )  ,    pixmap . getGLType (  )  ,    pixmap . getPixels (  )  )  ;", "if    (  (  ( Gdx . gl 2  0  )     =  =    null )     &  &     ( textureWidth    !  =    textureHeight )  )", "throw   new   utils . GdxRuntimeException (  \" texture   width   and   height   must   be   square   when   using   mipmapping .  \"  )  ;", "int   width    =     ( pixmap . getWidth (  )  )     /     2  ;", "int   height    =     ( pixmap . getHeight (  )  )     /     2  ;", "int   level    =     1  ;", "while    (  ( width    >     0  )     &  &     ( height    >     0  )  )     {", "Pixmap   tmp    =    new   Pixmap ( width ,    height ,    pixmap . getFormat (  )  )  ;", "tmp . setBlending ( Pixmap . Blending . None )  ;", "tmp . drawPixmap ( pixmap ,     0  ,     0  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,     0  ,     0  ,    width ,    height )  ;", "if    ( level    >     1  )", "pixmap . dispose (  )  ;", "pixmap    =    tmp ;", "Gdx . gl . glTexImage 2 D ( target ,    level ,    pixmap . getGLInternalFormat (  )  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,     0  ,    pixmap . getGLFormat (  )  ,    pixmap . getGLType (  )  ,    pixmap . getPixels (  )  )  ;", "width    =     ( pixmap . getWidth (  )  )     /     2  ;", "height    =     ( pixmap . getHeight (  )  )     /     2  ;", "level +  +  ;", "}", "}", "METHOD_END"], "methodName": ["generateMipMapCPU"], "fileName": "com.badlogic.gdx.graphics.glutils.MipMapGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( Gdx . graphics . supportsExtension (  \" GL _ ARB _ framebuffer _ object \"  )  )     |  |     ( Gdx . graphics . supportsExtension (  \" GL _ EXT _ framebuffer _ object \"  )  )  )     |  |     (  ( Gdx . gl 3  0  )     !  =    null )  )     {", "Gdx . gl . glTexImage 2 D ( target ,     0  ,    pixmap . getGLInternalFormat (  )  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,     0  ,    pixmap . getGLFormat (  )  ,    pixmap . getGLType (  )  ,    pixmap . getPixels (  )  )  ;", "Gdx . gl 2  0  . glGenerateMipmap ( target )  ;", "} else    {", ". generateMipMapCPU ( target ,    pixmap ,    textureWidth ,    textureHeight )  ;", "}", "}", "METHOD_END"], "methodName": ["generateMipMapDesktop"], "fileName": "com.badlogic.gdx.graphics.glutils.MipMapGenerator"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glTexImage 2 D ( target ,     0  ,    pixmap . getGLInternalFormat (  )  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,     0  ,    pixmap . getGLFormat (  )  ,    pixmap . getGLType (  )  ,    pixmap . getPixels (  )  )  ;", "Gdx . gl 2  0  . gleMipmap ( target )  ;", "}", "METHOD_END"], "methodName": ["generateMipMapGLES20"], "fileName": "com.badlogic.gdx.graphics.glutils.MipMapGenerator"}, {"methodBody": ["METHOD_START", "{", "MipMapGenerator . useHWMipMap    =    useHWMipMap ;", "}", "METHOD_END"], "methodName": ["setUseHardwareMipMap"], "fileName": "com.badlogic.gdx.graphics.glutils.MipMapGenerator"}, {"methodBody": ["METHOD_START", "{", "Array < ShaderProgram >    managedResources    =    ShaderProgram . shaders . get ( app )  ;", "if    ( managedResources    =  =    null )", "managedResources    =    new   Array < ShaderProgram >  (  )  ;", "managedResources . add ( shaderProgram )  ;", "ShaderProgram . shaders . put ( app ,    managedResources )  ;", "}", "METHOD_END"], "methodName": ["addManagedShader"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUse ( program )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "if    ( invalidated )     {", "compiles ( vertexSource ,    fragmentSource )  ;", "invalidated    =    false ;", "}", "}", "METHOD_END"], "methodName": ["checkManaged"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "ShaderProgram . shaders . remove ( app )  ;", "}", "METHOD_END"], "methodName": ["clearAllShaderPrograms"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "vertexShaderHandle    =    loadShader ( GL 2  0  . GL _ VERTEX _ SHADER ,    vertexShader )  ;", "fragmentShaderHandle    =    loadShader ( GL 2  0  . GL _ FRAGMENT _ SHADER ,    fragmentShader )  ;", "if    (  (  ( vertexShaderHandle )     =  =     (  -  1  )  )     |  |     (  ( fragmentShaderHandle )     =  =     (  -  1  )  )  )     {", "isCompiled    =    false ;", "return ;", "}", "program    =    link ( create (  )  )  ;", "if    (  ( program )     =  =     (  -  1  )  )     {", "isCompiled    =    false ;", "return ;", "}", "isCompiled    =    true ;", "}", "METHOD_END"], "methodName": ["compileShaders"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "int   program    =    gl . glCreate (  )  ;", "return   program    !  =     0     ?    program    :     -  1  ;", "}", "METHOD_END"], "methodName": ["createProgram"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glDisableVertexAttribArray ( location )  ;", "}", "METHOD_END"], "methodName": ["disableVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchAttributeLocation ( name )  ;", "if    ( location    =  =     (  -  1  )  )", "return ;", "gl . glDisableVertexAttribArray ( location )  ;", "}", "METHOD_END"], "methodName": ["disableVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "gl . glUseProgram (  0  )  ;", "gl . glDeleteShader ( vertexShaderHandle )  ;", "gl . glDeleteShader ( fragmentShaderHandle )  ;", "gl . glDeleteProgram ( program )  ;", "if    (  (  . shaders . get ( Gdx . app )  )     !  =    null )", ". shaders . get ( Gdx . app )  . removeValue ( this ,    true )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glEnableVertexAttribArray ( location )  ;", "}", "METHOD_END"], "methodName": ["enableVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchAttributeLocation ( name )  ;", "if    ( location    =  =     (  -  1  )  )", "return ;", "gl . glEnableVertexAttribArray ( location )  ;", "}", "METHOD_END"], "methodName": ["enableVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "gl . glUse (  0  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "int   location ;", "if    (  ( location    =    attributes . get ( name ,     (  -  2  )  )  )     =  =     (  -  2  )  )     {", "location    =    gl . glGetAttribLocation ( p ,    name )  ;", "attributes . put ( name ,    location )  ;", "}", "return   location ;", "}", "METHOD_END"], "methodName": ["fetchAttributeLocation"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "params . clear (  )  ;", "Gdx . gl 2  0  . glGetiv ( program ,    GL 2  0  . GL _ ACTIVE _ ATTRIBUTES ,    params )  ;", "int   numAttributes    =    params . get (  0  )  ;", "attributeNames    =    new   String [ numAttributes ]  ;", "for    ( int   i    =     0  ;    i    <    numAttributes ;    i +  +  )     {", "params . clear (  )  ;", "params . put (  0  ,     1  )  ;", "type . clear (  )  ;", "String   name    =    Gdx . gl 2  0  . glGetActiveAttrib ( program ,    i ,    params ,    type )  ;", "int   location    =    Gdx . gl 2  0  . glGetAttribLocation ( program ,    name )  ;", "attributes . put ( name ,    location )  ;", "attributeTypes . put ( name ,    type . get (  0  )  )  ;", "attributeSizes . put ( name ,    params . get (  0  )  )  ;", "attributeNames [ i ]     =    name ;", "}", "}", "METHOD_END"], "methodName": ["fetchAttributes"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   fetchUniformLocation ( name ,    ShaderProgram . pedantic )  ;", "}", "METHOD_END"], "methodName": ["fetchUniformLocation"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "int   location ;", "if    (  ( location    =    uniforms . get ( name ,     (  -  2  )  )  )     =  =     (  -  2  )  )     {", "location    =    gl . glGetUniformLocation ( p ,    name )  ;", "if    (  ( location    =  =     (  -  1  )  )     &  &    pedantic )", "throw   new   IllegalArgumentException (  (  (  \" no   uniform   with   name    '  \"     +    name )     +     \"  '    in   shader \"  )  )  ;", "uniforms . put ( name ,    location )  ;", "}", "return   location ;", "}", "METHOD_END"], "methodName": ["fetchUniformLocation"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "params . clear (  )  ;", "Gdx . gl 2  0  . glGetiv ( program ,    GL 2  0  . GL _ ACTIVE _ UNIFORMS ,    params )  ;", "int   numUniforms    =    params . get (  0  )  ;", "uniformNames    =    new   String [ numUniforms ]  ;", "for    ( int   i    =     0  ;    i    <    numUniforms ;    i +  +  )     {", "params . clear (  )  ;", "params . put (  0  ,     1  )  ;", "type . clear (  )  ;", "String   name    =    Gdx . gl 2  0  . glGetActiveUniform ( program ,    i ,    params ,    type )  ;", "int   location    =    Gdx . gl 2  0  . glGetUniformLocation ( program ,    name )  ;", "uniforms . put ( name ,    location )  ;", "uniformTypes . put ( name ,    type . get (  0  )  )  ;", "uniformSizes . put ( name ,    params . get (  0  )  )  ;", "uniformNames [ i ]     =    name ;", "}", "}", "METHOD_END"], "methodName": ["fetchUniforms"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   attributes . get ( name ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeLocation"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   attributeSizes . get ( name ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeSize"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   attributeTypes . get ( name ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeType"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   attributeNames ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   fragmentShaderSource ;", "}", "METHOD_END"], "methodName": ["getFragmentShaderSource"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled )     {", "log    =    Gdx . gl 2  0  . glGetInfoLog ( program )  ;", "return   log ;", "} else    {", "return   log ;", "}", "}", "METHOD_END"], "methodName": ["getLog"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "int   i    =     0  ;", "builder . append (  \" Managed   shaders / app :     {     \"  )  ;", "for    ( Application   app    :     . shaders . keys (  )  )     {", "builder . append (  . shaders . get ( app )  . size )  ;", "builder . append (  \"     \"  )  ;", "}", "builder . append (  \"  }  \"  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getManagedStatus"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   ShaderProgram . shaders . get ( Gdx . app )  . size ;", "}", "METHOD_END"], "methodName": ["getNumManagedShaderPrograms"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   uniforms . get ( name ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["getUniformLocation"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   uniformSizes . get ( name ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getUniformSize"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   uniformTypes . get ( name ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getUniformType"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   uniformNames ;", "}", "METHOD_END"], "methodName": ["getUniforms"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   vertexShaderSource ;", "}", "METHOD_END"], "methodName": ["getVertexShaderSource"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   attributes . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["hasAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   uniforms . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["hasUniform"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Gdx . gl 2  0  )     =  =    null )", "return ;", "Array <  >    shaderArray    =     . shaders . get ( app )  ;", "if    ( shaderArray    =  =    null )", "return ;", "for    ( int   i    =     0  ;    i    <     ( shaderArray . size )  ;    i +  +  )     {", "shaderArray . get ( i )  . invalidated    =    true ;", "shaderArray . get ( i )  . checkManaged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidateAllShaderPrograms"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "return   isCompiled ;", "}", "METHOD_END"], "methodName": ["isCompiled"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "if    ( program    =  =     (  -  1  )  )", "return    -  1  ;", "gl . glAttachShader ( program ,    vertexShaderHandle )  ;", "gl . glAttachShader ( program ,    fragmentShaderHandle )  ;", "gl . glLink ( program )  ;", "ByteBuffer   tmp    =    ByteBuffer . allocateDirect (  4  )  ;", "tmp . order ( ByteOrder . nativeOrder (  )  )  ;", "IntBuffer   intbuf    =    tmp . asIntBuffer (  )  ;", "gl . glGetiv ( program ,    GL 2  0  . GL _ LINK _ STATUS ,    intbuf )  ;", "int   linked    =    intbuf . get (  0  )  ;", "if    ( linked    =  =     0  )     {", "log    =    Gdx . gl 2  0  . glGetInfoLog ( program )  ;", "return    -  1  ;", "}", "return   program ;", "}", "METHOD_END"], "methodName": ["linkProgram"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "IntBuffer   intbuf    =    BufferUtils . newIntBuffer (  1  )  ;", "int   shader    =    gl . glCreate ( type )  ;", "if    ( shader    =  =     0  )", "return    -  1  ;", "gl . glSource ( shader ,    source )  ;", "gl . glCompile ( shader )  ;", "gl . glGetiv ( shader ,    GL 2  0  . GL _ COMPILE _ STATUS ,    intbuf )  ;", "int   compiled    =    intbuf . get (  0  )  ;", "if    ( compiled    =  =     0  )     {", "String   infoLog    =    gl . glGetInfoLog ( shader )  ;", "log    +  =     ( type    =  =     ( GL 2  0  . GL _ VERTEX _ SHADER )  )     ?     \" Vertex   shader \\ n \"     :     \" Fragment   shader :  \\ n \"  ;", "log    +  =    infoLog ;", "return    -  1  ;", "}", "return   shader ;", "}", "METHOD_END"], "methodName": ["loadShader"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "int   location    =    fetchAttributeLocation ( name )  ;", "gl . glVertexAttrib 4 f ( location ,    value 1  ,    value 2  ,    value 3  ,    value 4  )  ;", "}", "METHOD_END"], "methodName": ["setAttributef"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 1 fv ( location ,    length ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform1fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 1 fv ( location ,    length ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform1fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 2 fv ( location ,     ( length    /     2  )  ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform2fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 2 fv ( location ,     ( length    /     2  )  ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform2fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 3 fv ( location ,     ( length    /     3  )  ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform3fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 3 fv ( location ,     ( length    /     3  )  ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform3fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 4 fv ( location ,     ( length    /     4  )  ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform4fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 4 fv ( location ,     ( length    /     4  )  ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniform4fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformMatrix ( location ,    matrix ,    false )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniformMatrix 3 fv ( location ,     1  ,    transpose ,    matrix . val ,     0  )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformMatrix ( location ,    matrix ,    false )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniformMatrix 4 fv ( location ,     1  ,    transpose ,    matrix . val ,     0  )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformMatrix ( name ,    matrix ,    false )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformMatrix ( fetchUniformLocation ( name )  ,    matrix ,    transpose )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformMatrix ( name ,    matrix ,    false )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformMatrix ( fetchUniformLocation ( name )  ,    matrix ,    transpose )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "buffer . position (  0  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniformMatrix 3 fv ( location ,    count ,    transpose ,    buffer )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix3fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniformMatrix 4 fv ( location ,     ( length    /     1  6  )  ,    false ,    values ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix4fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformMatrix 4 fv ( fetchUniformLocation ( name )  ,    values ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix4fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "buffer . position (  0  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniformMatrix 4 fv ( location ,    count ,    transpose ,    buffer )  ;", "}", "METHOD_END"], "methodName": ["setUniformMatrix4fv"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformf ( location ,    values . r ,    values . g ,    values . b ,    values . a )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformf ( location ,    values . x ,    values . y )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformf ( location ,    values . x ,    values . y ,    values . z )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 1 f ( location ,    value )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 2 f ( location ,    value 1  ,    value 2  )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 3 f ( location ,    value 1  ,    value 2  ,    value 3  )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 4 f ( location ,    value 1  ,    value 2  ,    value 3  ,    value 4  )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformf ( name ,    values . r ,    values . g ,    values . b ,    values . a )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformf ( name ,    values . x ,    values . y )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "setUniformf ( name ,    values . x ,    values . y ,    values . z )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 1 f ( location ,    value )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 2 f ( location ,    value 1  ,    value 2  )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 3 f ( location ,    value 1  ,    value 2  ,    value 3  )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 4 f ( location ,    value 1  ,    value 2  ,    value 3  ,    value 4  )  ;", "}", "METHOD_END"], "methodName": ["setUniformf"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 1 i ( location ,    value )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 2 i ( location ,    value 1  ,    value 2  )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 3 i ( location ,    value 1  ,    value 2  ,    value 3  )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glUniform 4 i ( location ,    value 1  ,    value 2  ,    value 3  ,    value 4  )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 1 i ( location ,    value )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 2 i ( location ,    value 1  ,    value 2  )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 3 i ( location ,    value 1  ,    value 2  ,    value 3  )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchUniformLocation ( name )  ;", "gl . glUniform 4 i ( location ,    value 1  ,    value 2  ,    value 3  ,    value 4  )  ;", "}", "METHOD_END"], "methodName": ["setUniformi"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glVertexAttribPointer ( location ,    size ,    type ,    normalize ,    stride ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "gl . glVertexAttribPointer ( location ,    size ,    type ,    normalize ,    stride ,    buffer )  ;", "}", "METHOD_END"], "methodName": ["setVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchAttributeLocation ( name )  ;", "if    ( location    =  =     (  -  1  )  )", "return ;", "gl . glVertexAttribPointer ( location ,    size ,    type ,    normalize ,    stride ,    offset )  ;", "}", "METHOD_END"], "methodName": ["setVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "checkManaged (  )  ;", "int   location    =    fetchAttributeLocation ( name )  ;", "if    ( location    =  =     (  -  1  )  )", "return ;", "gl . glVertexAttribPointer ( location ,    size ,    type ,    normalize ,    stride ,    buffer )  ;", "}", "METHOD_END"], "methodName": ["setVertexAttribute"], "fileName": "com.badlogic.gdx.graphics.glutils.ShaderProgram"}, {"methodBody": ["METHOD_START", "{", "arc ( x ,    y ,    radius ,    start ,    degrees ,    Math . max (  1  ,     (  ( int )     (  (  6     *     (  ( float )     ( Math . cbrt ( radius )  )  )  )     *     ( degrees    /     3  6  0  .  0 F )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["arc"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( segments    <  =     0  )", "throw   new   IllegalArgumentException (  \" segments   must   be    >     0  .  \"  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "float   theta    =     (  (  2     *     ( MathUtils . PI )  )     *     ( degrees    /     3  6  0  .  0 F )  )     /    segments ;", "float   cos    =    MathUtils . cos ( theta )  ;", "float   sin    =    MathUtils . sin ( theta )  ;", "float   cx    =    radius    *     ( MathUtils . cos (  ( start    *     ( MathUtils . degreesToRadians )  )  )  )  ;", "float   cy    =    radius    *     ( MathUtils . sin (  ( start    *     ( MathUtils . degreesToRadians )  )  )  )  ;", "if    (  ( shapeType )     =  =     (  . ShapeType . Line )  )     {", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     (  ( segments    *     2  )     +     2  )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "float   temp    =    cx ;", "cx    =     ( cos    *    cx )     -     ( sin    *    cy )  ;", "cy    =     ( sin    *    temp )     +     ( cos    *    cy )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "} else    {", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     (  ( segments    *     3  )     +     3  )  )  ;", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "float   temp    =    cx ;", "cx    =     ( cos    *    cx )     -     ( sin    *    cy )  ;", "cy    =     ( sin    *    temp )     +     ( cos    *    cy )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "float   temp    =    cx ;", "cx    =     0  ;", "cy    =     0  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["arc"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( autoShapeType )  )", "throw   new   IllegalStateException (  \" autoShapeType   must   be   true   to   use   this   method .  \"  )  ;", "begin (  . ShapeType . Line )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shapeType )     !  =    null )", "throw   new   IllegalStateException (  \" Call   end (  )    before   beginning   a   new   shape   batch .  \"  )  ;", "shapeType    =    type ;", "if    ( matrixDirty )     {", "combinedMatrix . set ( projectionMatrix )  ;", "Matrix 4  . mul ( combinedMatrix . val ,    transformMatrix . val )  ;", "matrixDirty    =    false ;", "}", "r . begin ( combinedMatrix ,    shapeType . getGlType (  )  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "depth    =     - depth ;", "float   colorBits    =    color . toFloatBits (  )  ;", "if    (  ( shapeType )     =  =     (  . ShapeType . Line )  )     {", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     2  4  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "} else    {", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     3  6  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    depth )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "}", "}", "METHOD_END"], "methodName": ["box"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shapeType )     =  =    null )", "throw   new   IllegalStateException (  \" begin   must   be   called   first .  \"  )  ;", "if    (  (  ( shapeType )     !  =    preferred )     &  &     (  ( shapeType )     !  =    other )  )     {", "if    (  !  ( autoShapeType )  )     {", "if    ( other    =  =    null )", "throw   new   IllegalStateException (  (  (  \" Must   call   begin ( ShapeType .  \"     +    preferred )     +     \"  )  .  \"  )  )  ;", "else", "throw   new   IllegalStateException (  (  (  (  (  \" Must   call   begin ( ShapeType .  \"     +    preferred )     +     \"  )    or   begin ( ShapeType .  \"  )     +    other )     +     \"  )  .  \"  )  )  ;", "}", "end (  )  ;", "begin ( preferred )  ;", "} else", "if    ( matrixDirty )     {", ". ShapeType   type    =    shapeType ;", "end (  )  ;", "begin ( type )  ;", "} else", "if    (  (  ( renderer . getMaxVertices (  )  )     -     ( renderer . getNumVertices (  )  )  )     <    newVertices )     {", ". ShapeType   type    =    shapeType ;", "end (  )  ;", "begin ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "circle ( x ,    y ,    radius ,    Math . max (  1  ,     (  ( int )     (  6     *     (  ( float )     ( Math . cbrt ( radius )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["circle"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( segments    <  =     0  )", "throw   new   IllegalArgumentException (  \" segments   must   be    >     0  .  \"  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "float   angle    =     (  2     *     ( MathUtils . PI )  )     /    segments ;", "float   cos    =    MathUtils . cos ( angle )  ;", "float   sin    =    MathUtils . sin ( angle )  ;", "float   cx    =    radius ;", "float   cy    =     0  ;", "if    (  ( shapeType )     =  =     (  . ShapeType . Line )  )     {", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     (  ( segments    *     2  )     +     2  )  )  ;", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "float   temp    =    cx ;", "cx    =     ( cos    *    cx )     -     ( sin    *    cy )  ;", "cy    =     ( sin    *    temp )     +     ( cos    *    cy )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "} else    {", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     (  ( segments    *     3  )     +     3  )  )  ;", "segments -  -  ;", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "float   temp    =    cx ;", "cx    =     ( cos    *    cx )     -     ( sin    *    cy )  ;", "cy    =     ( sin    *    temp )     +     ( cos    *    cy )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "float   temp    =    cx ;", "cx    =    radius ;", "cy    =     0  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["circle"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "cone ( x ,    y ,    z ,    radius ,    height ,    Math . max (  1  ,     (  ( int )     (  4     *     (  ( float )     ( Math . sqrt ( radius )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["cone"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( segments    <  =     0  )", "throw   new   IllegalArgumentException (  \" segments   must   be    >     0  .  \"  )  ;", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     (  ( segments    *     4  )     +     2  )  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "float   angle    =     (  2     *     ( MathUtils . PI )  )     /    segments ;", "float   cos    =    MathUtils . cos ( angle )  ;", "float   sin    =    MathUtils . sin ( angle )  ;", "float   cx    =    radius ;", "float   cy    =     0  ;", "if    (  ( shapeType )     =  =     (  . ShapeType . Line )  )     {", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    height )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "float   temp    =    cx ;", "cx    =     ( cos    *    cx )     -     ( sin    *    cy )  ;", "cy    =     ( sin    *    temp )     +     ( cos    *    cy )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "} else    {", "segments -  -  ;", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "float   temp    =    cx ;", "float   temp 2     =    cy ;", "cx    =     ( cos    *    cx )     -     ( sin    *    cy )  ;", "cy    =     ( sin    *    temp )     +     ( cos    *    cy )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    temp )  ,     ( y    +    temp 2  )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    height )  )  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "}", "float   temp    =    cx ;", "float   temp 2     =    cy ;", "cx    =    radius ;", "cy    =     0  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "if    (  ( shapeType )     !  =     (  . ShapeType . Line )  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    temp )  ,     ( y    +    temp 2  )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    cx )  ,     ( y    +    cy )  ,    z )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     ( z    +    height )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cone"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    null ,     (  ( segments    *     2  )     +     2  )  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "float   subdiv _ step    =     1  .  0 F    /    segments ;", "float   subdiv _ step 2     =    subdiv _ step    *    subdiv _ step ;", "float   subdiv _ step 3     =     ( subdiv _ step    *    subdiv _ step )     *    subdiv _ step ;", "float   pre 1     =     3     *    subdiv _ step ;", "float   pre 2     =     3     *    subdiv _ step 2  ;", "float   pre 4     =     6     *    subdiv _ step 2  ;", "float   pre 5     =     6     *    subdiv _ step 3  ;", "float   tmp 1 x    =     ( x 1     -     ( cx 1     *     2  )  )     +    cx 2  ;", "float   tmp 1 y    =     ( y 1     -     ( cy 1     *     2  )  )     +    cy 2  ;", "float   tmp 2 x    =     (  (  ( cx 1     -    cx 2  )     *     3  )     -    x 1  )     +    x 2  ;", "float   tmp 2 y    =     (  (  ( cy 1     -    cy 2  )     *     3  )     -    y 1  )     +    y 2  ;", "float   fx    =    x 1  ;", "float   fy    =    y 1  ;", "float   dfx    =     (  (  ( cx 1     -    x 1  )     *    pre 1  )     +     ( tmp 1 x    *    pre 2  )  )     +     ( tmp 2 x    *    subdiv _ step 3  )  ;", "float   dfy    =     (  (  ( cy 1     -    y 1  )     *    pre 1  )     +     ( tmp 1 y    *    pre 2  )  )     +     ( tmp 2 y    *    subdiv _ step 3  )  ;", "float   ddfx    =     ( tmp 1 x    *    pre 4  )     +     ( tmp 2 x    *    pre 5  )  ;", "float   ddfy    =     ( tmp 1 y    *    pre 4  )     +     ( tmp 2 y    *    pre 5  )  ;", "float   dddfx    =    tmp 2 x    *    pre 5  ;", "float   dddfy    =    tmp 2 y    *    pre 5  ;", "while    (  ( segments -  -  )     >     0  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex ( fx ,    fy ,     0  )  ;", "fx    +  =    dfx ;", "fy    +  =    dfy ;", "dfx    +  =    ddfx ;", "dfy    +  =    ddfy ;", "ddfx    +  =    dddfx ;", "ddfy    +  =    dddfy ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( fx ,    fy ,     0  )  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex ( fx ,    fy ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["curve"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "ellipse ( x ,    y ,    width ,    height ,    Math . max (  1  ,     (  ( int )     (  1  2     *     (  ( float )     ( Math . cbrt ( Math . max (  ( width    *     0  .  5 F )  ,     ( height    *     0  .  5 F )  )  )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ellipse"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "ellipse ( x ,    y ,    width ,    height ,    rotation ,    Math . max (  1  ,     (  ( int )     (  1  2     *     (  ( float )     ( Math . cbrt ( Math . max (  ( width    *     0  .  5 F )  ,     ( height    *     0  .  5 F )  )  )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ellipse"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( segments    <  =     0  )", "throw   new   IllegalArgumentException (  \" segments   must   be    >     0  .  \"  )  ;", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     ( segments    *     3  )  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "float   angle    =     (  2     *     ( MathUtils . PI )  )     /    segments ;", "rotation    =     (  ( MathUtils . PI )     *    rotation )     /     1  8  0  .  0 F ;", "float   sin    =    MathUtils . sin ( rotation )  ;", "float   cos    =    MathUtils . cos ( rotation )  ;", "float   cx    =    x    +     ( width    /     2  )  ;", "float   cy    =    y    +     ( height    /     2  )  ;", "float   x 1     =    width    *     0  .  5 F ;", "float   y 1     =     0  ;", "if    (  ( shapeType )     =  =     (  . ShapeType . Line )  )     {", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  (  ( cx    +     ( cos    *    x 1  )  )     -     ( sin    *    y 1  )  )  ,     (  ( cy    +     ( sin    *    x 1  )  )     +     ( cos    *    y 1  )  )  ,     0  )  ;", "x 1     =     ( width    *     0  .  5 F )     *     ( MathUtils . cos (  (  ( i    +     1  )     *    angle )  )  )  ;", "y 1     =     ( height    *     0  .  5 F )     *     ( MathUtils . sin (  (  ( i    +     1  )     *    angle )  )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  (  ( cx    +     ( cos    *    x 1  )  )     -     ( sin    *    y 1  )  )  ,     (  ( cy    +     ( sin    *    x 1  )  )     +     ( cos    *    y 1  )  )  ,     0  )  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  (  ( cx    +     ( cos    *    x 1  )  )     -     ( sin    *    y 1  )  )  ,     (  ( cy    +     ( sin    *    x 1  )  )     +     ( cos    *    y 1  )  )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( cx ,    cy ,     0  )  ;", "x 1     =     ( width    *     0  .  5 F )     *     ( MathUtils . cos (  (  ( i    +     1  )     *    angle )  )  )  ;", "y 1     =     ( height    *     0  .  5 F )     *     ( MathUtils . sin (  (  ( i    +     1  )     *    angle )  )  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  (  ( cx    +     ( cos    *    x 1  )  )     -     ( sin    *    y 1  )  )  ,     (  ( cy    +     ( sin    *    x 1  )  )     +     ( cos    *    y 1  )  )  ,     0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["ellipse"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( segments    <  =     0  )", "throw   new   IllegalArgumentException (  \" segments   must   be    >     0  .  \"  )  ;", "check (  . ShapeType . Line ,     . ShapeType . Filled ,     ( segments    *     3  )  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "float   angle    =     (  2     *     ( MathUtils . PI )  )     /    segments ;", "float   cx    =    x    +     ( width    /     2  )  ;", "float   cy    =    y    +     ( height    /     2  )  ;", "if    (  ( shapeType )     =  =     (  . ShapeType . Line )  )     {", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( cx    +     (  ( width    *     0  .  5 F )     *     ( MathUtils . cos (  ( i    *    angle )  )  )  )  )  ,     ( cy    +     (  ( height    *     0  .  5 F )     *     ( MathUtils . sin (  ( i    *    angle )  )  )  )  )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( cx    +     (  ( width    *     0  .  5 F )     *     ( MathUtils . cos (  (  ( i    +     1  )     *    angle )  )  )  )  )  ,     ( cy    +     (  ( height    *     0  .  5 F )     *     ( MathUtils . sin (  (  ( i    +     1  )     *    angle )  )  )  )  )  ,     0  )  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <    segments ;    i +  +  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( cx    +     (  ( width    *     0  .  5 F )     *     ( MathUtils . cos (  ( i    *    angle )  )  )  )  )  ,     ( cy    +     (  ( height    *     0  .  5 F )     *     ( MathUtils . sin (  ( i    *    angle )  )  )  )  )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( cx ,    cy ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( cx    +     (  ( width    *     0  .  5 F )     *     ( MathUtils . cos (  (  ( i    +     1  )     *    angle )  )  )  )  )  ,     ( cy    +     (  ( height    *     0  .  5 F )     *     ( MathUtils . sin (  (  ( i    +     1  )     *    angle )  )  )  )  )  ,     0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["ellipse"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . end (  )  ;", "shapeType    =    null ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "ShapeRenderer . ShapeType   type    =    shapeType ;", "end (  )  ;", "begin ( type )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "return   shapeType ;", "}", "METHOD_END"], "methodName": ["getCurrentType"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "return   projectionMatrix ;", "}", "METHOD_END"], "methodName": ["getProjectionMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "return   renderer ;", "}", "METHOD_END"], "methodName": ["getRenderer"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "return   transformMatrix ;", "}", "METHOD_END"], "methodName": ["getTransformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "transformMatrix . idt (  )  ;", "matrixDirty    =    true ;", "}", "METHOD_END"], "methodName": ["identity"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "return    ( shapeType )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isDrawing"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "line ( v 0  . x ,    v 0  . y ,     0  .  0 F ,    v 1  . x ,    v 1  . y ,     0  .  0 F ,    color ,    color )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "line ( v 0  . x ,    v 0  . y ,    v 0  . z ,    v 1  . x ,    v 1  . y ,    v 1  . z ,    color ,    color )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "line ( x ,    y ,     0  .  0 F ,    x 2  ,    y 2  ,     0  .  0 F ,    color ,    color )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "line ( x ,    y ,     0  .  0 F ,    x 2  ,    y 2  ,     0  .  0 F ,    c 1  ,    c 2  )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "line ( x ,    y ,    z ,    x 2  ,    y 2  ,    z 2  ,    color ,    color )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Filled )  )     {", "rectLine ( x ,    y ,    x 2  ,    y 2  ,    defaultRectLineWidth ,    c 1  ,    c 2  )  ;", "return ;", "}", "check ( ShapeRenderer . ShapeType . Line ,    null ,     2  )  ;", "renderer . color ( c 1  . r ,    c 1  . g ,    c 1  . b ,    c 1  . a )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "renderer . color ( c 2  . r ,    c 2  . g ,    c 2  . b ,    c 2  . a )  ;", "renderer . vertex ( x 2  ,    y 2  ,    z 2  )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "float   size    =     ( defaultRectLineWidth )     *     0  .  5 F ;", "line (  ( x    -    size )  ,     ( y    -    size )  ,    z ,     ( x    +    size )  ,     ( y    +    size )  ,    z )  ;", "return ;", "} else", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Filled )  )     {", "float   size    =     ( defaultRectLineWidth )     *     0  .  5 F ;", "box (  ( x    -    size )  ,     ( y    -    size )  ,     ( z    -    size )  ,    defaultRectLineWidth ,    defaultRectLineWidth ,    defaultRectLineWidth )  ;", "return ;", "}", "check ( ShapeRenderer . ShapeType . Point ,    null ,     1  )  ;", "renderer . color ( color )  ;", "renderer . vertex ( x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["point"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "polygon ( vertices ,     0  ,    vertices . length )  ;", "}", "METHOD_END"], "methodName": ["polygon"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( count    <     6  )", "throw   new   IllegalArgumentException (  \" Polygons   must   contain   at   least    3    points .  \"  )  ;", "if    (  ( count    %     2  )     !  =     0  )", "throw   new   IllegalArgumentException (  \" Polygons   must   have   an   even   number   of   vertices .  \"  )  ;", "check (  . ShapeType . Line ,    null ,    count )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "float   firstX    =    vertices [  0  ]  ;", "float   firstY    =    vertices [  1  ]  ;", "for    ( int   i    =    offset ,    n    =    offset    +    count ;    i    <    n ;    i    +  =     2  )     {", "float   x 1     =    vertices [ i ]  ;", "float   y 1     =    vertices [  ( i    +     1  )  ]  ;", "float   x 2  ;", "float   y 2  ;", "if    (  ( i    +     2  )     >  =    count )     {", "x 2     =    firstX ;", "y 2     =    firstY ;", "} else    {", "x 2     =    vertices [  ( i    +     2  )  ]  ;", "y 2     =    vertices [  ( i    +     3  )  ]  ;", "}", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["polygon"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "polyline ( vertices ,     0  ,    vertices . length )  ;", "}", "METHOD_END"], "methodName": ["polyline"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( count    <     4  )", "throw   new   IllegalArgumentException (  \" Polylines   must   contain   at   least    2    points .  \"  )  ;", "if    (  ( count    %     2  )     !  =     0  )", "throw   new   IllegalArgumentException (  \" Polylines   must   have   an   even   number   of   vertices .  \"  )  ;", "check (  . ShapeType . Line ,    null ,    count )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "for    ( int   i    =    offset ,    n    =     ( offset    +    count )     -     2  ;    i    <    n ;    i    +  =     2  )     {", "float   x 1     =    vertices [ i ]  ;", "float   y 1     =    vertices [  ( i    +     1  )  ]  ;", "float   x 2  ;", "float   y 2  ;", "x 2     =    vertices [  ( i    +     2  )  ]  ;", "y 2     =    vertices [  ( i    +     3  )  ]  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["polyline"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    ShapeRenderer . ShapeType . Filled ,     8  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "} else    {", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["rect"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    ShapeRenderer . ShapeType . Filled ,     8  )  ;", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( col 4  . r ,    col 4  . g ,    col 4  . b ,    col 4  . a )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( col 4  . r ,    col 4  . g ,    col 4  . b ,    col 4  . a )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "} else    {", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex (  ( x    +    width )  ,    y ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex (  ( x    +    width )  ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( col 4  . r ,    col 4  . g ,    col 4  . b ,    col 4  . a )  ;", "renderer . vertex ( x ,     ( y    +    height )  ,     0  )  ;", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x ,    y ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["rect"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "rect ( x ,    y ,    originX ,    originY ,    width ,    height ,    scaleX ,    scaleY ,    degrees ,    color ,    color ,    color ,    color )  ;", "}", "METHOD_END"], "methodName": ["rect"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    ShapeRenderer . ShapeType . Filled ,     8  )  ;", "float   cos    =    MathUtils . cosDeg ( degrees )  ;", "float   sin    =    MathUtils . sinDeg ( degrees )  ;", "float   fx    =     - originX ;", "float   fy    =     - originY ;", "float   fx 2     =    width    -    originX ;", "float   fy 2     =    height    -    originY ;", "if    (  ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  )     {", "fx    *  =    scaleX ;", "fy    *  =    scaleY ;", "fx 2     *  =    scaleX ;", "fy 2     *  =    scaleY ;", "}", "float   worldOriginX    =    x    +    originX ;", "float   worldOriginY    =    y    +    originY ;", "float   x 1     =     (  ( cos    *    fx )     -     ( sin    *    fy )  )     +    worldOriginX ;", "float   y 1     =     (  ( sin    *    fx )     +     ( cos    *    fy )  )     +    worldOriginY ;", "float   x 2     =     (  ( cos    *    fx 2  )     -     ( sin    *    fy )  )     +    worldOriginX ;", "float   y 2     =     (  ( sin    *    fx 2  )     +     ( cos    *    fy )  )     +    worldOriginY ;", "float   x 3     =     (  ( cos    *    fx 2  )     -     ( sin    *    fy 2  )  )     +    worldOriginX ;", "float   y 3     =     (  ( sin    *    fx 2  )     +     ( cos    *    fy 2  )  )     +    worldOriginY ;", "float   x 4     =    x 1     +     ( x 3     -    x 2  )  ;", "float   y 4     =    y 3     -     ( y 2     -    y 1  )  ;", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( col 4  . r ,    col 4  . g ,    col 4  . b ,    col 4  . a )  ;", "renderer . vertex ( x 4  ,    y 4  ,     0  )  ;", "renderer . color ( col 4  . r ,    col 4  . g ,    col 4  . b ,    col 4  . a )  ;", "renderer . vertex ( x 4  ,    y 4  ,     0  )  ;", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "} else    {", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( col 4  . r ,    col 4  . g ,    col 4  . b ,    col 4  . a )  ;", "renderer . vertex ( x 4  ,    y 4  ,     0  )  ;", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["rect"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "rectLine ( p 1  . x ,    p 1  . y ,    p 2  . x ,    p 2  . y ,    width )  ;", "}", "METHOD_END"], "methodName": ["rectLine"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    ShapeRenderer . ShapeType . Filled ,     8  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "Vector 2    t    =    tmp . set (  ( y 2     -    y 1  )  ,     ( x 1     -    x 2  )  )  . nor (  )  ;", "width    *  =     0  .  5 F ;", "float   tx    =     ( t . x )     *    width ;", "float   ty    =     ( t . y )     *    width ;", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 1     +    tx )  ,     ( y 1     +    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 2     -    tx )  ,     ( y 2     -    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 1     +    tx )  ,     ( y 1     +    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 2     -    tx )  ,     ( y 2     -    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "} else    {", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 1     +    tx )  ,     ( y 1     +    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 2     -    tx )  ,     ( y 2     -    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["rectLine"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    ShapeRenderer . ShapeType . Filled ,     8  )  ;", "float   col 1 Bits    =    c 1  . toFloatBits (  )  ;", "float   col 2 Bits    =    c 2  . toFloatBits (  )  ;", "Vector 2    t    =    tmp . set (  ( y 2     -    y 1  )  ,     ( x 1     -    x 2  )  )  . nor (  )  ;", "width    *  =     0  .  5 F ;", "float   tx    =     ( t . x )     *    width ;", "float   ty    =     ( t . y )     *    width ;", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "renderer . color ( col 1 Bits )  ;", "renderer . vertex (  ( x 1     +    tx )  ,     ( y 1     +    ty )  ,     0  )  ;", "renderer . color ( col 1 Bits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "renderer . color ( col 2 Bits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( col 2 Bits )  ;", "renderer . vertex (  ( x 2     -    tx )  ,     ( y 2     -    ty )  ,     0  )  ;", "renderer . color ( col 2 Bits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( col 1 Bits )  ;", "renderer . vertex (  ( x 1     +    tx )  ,     ( y 1     +    ty )  ,     0  )  ;", "renderer . color ( col 2 Bits )  ;", "renderer . vertex (  ( x 2     -    tx )  ,     ( y 2     -    ty )  ,     0  )  ;", "renderer . color ( col 1 Bits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "} else    {", "renderer . color ( col 1 Bits )  ;", "renderer . vertex (  ( x 1     +    tx )  ,     ( y 1     +    ty )  ,     0  )  ;", "renderer . color ( col 1 Bits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "renderer . color ( col 2 Bits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( col 2 Bits )  ;", "renderer . vertex (  ( x 2     -    tx )  ,     ( y 2     -    ty )  ,     0  )  ;", "renderer . color ( col 2 Bits )  ;", "renderer . vertex (  ( x 2     +    tx )  ,     ( y 2     +    ty )  ,     0  )  ;", "renderer . color ( col 1 Bits )  ;", "renderer . vertex (  ( x 1     -    tx )  ,     ( y 1     -    ty )  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["rectLine"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "transformMatrix . rotate ( axisX ,    axisY ,    axisZ ,    degrees )  ;", "matrixDirty    =    true ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "transformMatrix . scale ( scaleX ,    scaleY ,    scaleZ )  ;", "matrixDirty    =    true ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shapeType )     =  =    type )", "return ;", "if    (  ( shapeType )     =  =    null )", "throw   new   IllegalStateException (  \" begin   must   be   called   first .  \"  )  ;", "if    (  !  ( autoType )  )", "throw   new   IllegalStateException (  \" autoType   must   be   enabled .  \"  )  ;", "end (  )  ;", "begin ( type )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "this . autoShapeType    =    autoShapeType ;", "}", "METHOD_END"], "methodName": ["setAutoShapeType"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "projectionMatrix . set ( matrix )  ;", "matrixDirty    =    true ;", "}", "METHOD_END"], "methodName": ["setProjectionMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "transformMatrix . set ( matrix )  ;", "matrixDirty    =    true ;", "}", "METHOD_END"], "methodName": ["setTransformMatrix"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "transformMatrix . translate ( x ,    y ,    z )  ;", "matrixDirty    =    true ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    ShapeRenderer . ShapeType . Filled ,     6  )  ;", "float   colorBits    =    color . toFloatBits (  )  ;", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "} else    {", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( colorBits )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["triangle"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "check ( ShapeRenderer . ShapeType . Line ,    ShapeRenderer . ShapeType . Filled ,     6  )  ;", "if    (  ( shapeType )     =  =     ( ShapeRenderer . ShapeType . Line )  )     {", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "} else    {", "renderer . color ( col 1  . r ,    col 1  . g ,    col 1  . b ,    col 1  . a )  ;", "renderer . vertex ( x 1  ,    y 1  ,     0  )  ;", "renderer . color ( col 2  . r ,    col 2  . g ,    col 2  . b ,    col 2  . a )  ;", "renderer . vertex ( x 2  ,    y 2  ,     0  )  ;", "renderer . color ( col 3  . r ,    col 3  . g ,    col 3  . b ,    col 3  . a )  ;", "renderer . vertex ( x 3  ,    y 3  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["triangle"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "matrixDirty    =    true ;", "}", "METHOD_END"], "methodName": ["updateMatrices"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "x ( p . x ,    p . y ,    size )  ;", "}", "METHOD_END"], "methodName": ["x"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "line (  ( x    -    size )  ,     ( y    -    size )  ,     ( x    +    size )  ,     ( y    +    size )  )  ;", "line (  ( x    -    size )  ,     ( y    +    size )  ,     ( x    +    size )  ,     ( y    -    size )  )  ;", "}", "METHOD_END"], "methodName": ["x"], "fileName": "com.badlogic.gdx.graphics.glutils.ShapeRenderer"}, {"methodBody": ["METHOD_START", "{", "return    ( byteBuffer . capacity (  )  )     /     ( attributes . vertexSize )  ;", "}", "METHOD_END"], "methodName": ["getNumMaxVertices"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexArray"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound )     {", "Gdx . gl 2  0  . glData ( GL 2  0  . GL _ ARRAY _ BUFFER ,    byte . limit (  )  ,    byte ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["bufferChanged"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObject"}, {"methodBody": ["METHOD_START", "{", "return   usage ;", "}", "METHOD_END"], "methodName": ["getUsage"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObject"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound )", "throw   new   utils . GdxRuntimeException (  \" Cannot   change   attributes   while   VBO   is   bound \"  )  ;", "if    (  ( this . ownsBuffer )     &  &     (  ( byteBuffer )     !  =    null )  )", "utils . BufferUtils . disposeUnsafeByteBuffer ( byteBuffer )  ;", "attributes    =    value ;", "if    ( data   instanceof   ByteBuffer )", "byteBuffer    =     (  ( ByteBuffer )     ( data )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  \" Only   ByteBuffer   is   currently   supported \"  )  ;", "this . ownsBuffer    =    ownsBuffer ;", "final   int   l    =    byteBuffer . limit (  )  ;", "byteBuffer . limit ( byteBuffer . capacity (  )  )  ;", "buffer    =    byteBuffer . asFloatBuffer (  )  ;", "byteBuffer . limit ( l )  ;", "buffer . limit (  ( l    /     4  )  )  ;", "}", "METHOD_END"], "methodName": ["setBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObject"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound )", "throw   new   utils . GdxRuntimeException (  \" Cannot   change   usage   while   VBO   is   bound \"  )  ;", "usage    =    value ;", "}", "METHOD_END"], "methodName": ["setUsage"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObject"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound )     {", "Gdx . gl 2  0  . glBuffer ( GL 2  0  . GL _ ARRAY _ BUFFER ,     0  ,    byteBuffer . limit (  )  ,    byteBuffer )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["bufferChanged"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "int   result    =    Gdx . gl 2  0  . glGenBuffer (  )  ;", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ARRAY _ BUFFER ,    result )  ;", "Gdx . gl 2  0  . glBufferData ( GL 2  0  . GL _ ARRAY _ BUFFER ,    byteBuffer . capacity (  )  ,    null ,    usage )  ;", "Gdx . gl 2  0  . glBindBuffer ( GL 2  0  . GL _ ARRAY _ BUFFER ,     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createBufferObject"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "return   bufferHandle ;", "}", "METHOD_END"], "methodName": ["getBufferHandle"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "bufferHandle    =    createBufferObject (  )  ;", "isDirty    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData"}, {"methodBody": ["METHOD_START", "{", "boolean   stillValid    =     ( this . cachedLocations . size )     !  =     0  ;", "final   int   numAttributes    =    attributes . size (  )  ;", "if    ( stillValid )     {", "if    ( locations    =  =    null )     {", "for    ( int   i    =     0  ;    stillValid    &  &     ( i    <    numAttributes )  ;    i +  +  )     {", "Attribute   attribute    =    attributes . get ( i )  ;", "int   location    =    shader . getAttributeLocation ( attribute . alias )  ;", "stillValid    =    location    =  =     ( this . cachedLocations . get ( i )  )  ;", "}", "} else    {", "stillValid    =     ( locations . length )     =  =     ( this . cachedLocations . size )  ;", "for    ( int   i    =     0  ;    stillValid    &  &     ( i    <    numAttributes )  ;    i +  +  )     {", "stillValid    =     ( locations [ i ]  )     =  =     ( this . cachedLocations . get ( i )  )  ;", "}", "}", "}", "if    (  ! stillValid )     {", "Gdx . gl . glBindBuffer ( GL 2  0  . GL _ ARRAY _ BUFFER ,    bufferHandle )  ;", "unbindAttributes ( shader )  ;", "this . cachedLocations . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    numAttributes ;    i +  +  )     {", "Attribute   attribute    =    attributes . get ( i )  ;", "if    ( locations    =  =    null )     {", "this . cachedLocations . add ( shader . getAttributeLocation ( attribute . alias )  )  ;", "} else    {", "this . cachedLocations . add ( locations [ i ]  )  ;", "}", "int   location    =    this . cachedLocations . get ( i )  ;", "if    ( location    <     0  )     {", "continue ;", "}", "shader . enableAttribute ( location )  ;", "shader . setAttribute ( location ,    attribute . numComponents ,    attribute . type ,    attribute . normalized ,    attributes . vertexSize ,    attribute . offset )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["bindAttributes"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    ( isDirty )     {", "gl . glBind ( GL 2  0  . GL _ ARRAY _ BUFFER ,    bufferHandle )  ;", "byte . limit (  (  ( buffer . limit (  )  )     *     4  )  )  ;", "gl . glData ( GL 2  0  . GL _ ARRAY _ BUFFER ,    byte . limit (  )  ,    byte ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["bindData"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound )     {", "Gdx . gl 2  0  . glData ( GL 2  0  . GL _ ARRAY _ BUFFER ,    byte . limit (  )  ,    byte ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["bufferChanged"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "VertexBufferObjectWithVAO . tmpHandle . clear (  )  ;", "Gdx . gl 3  0  . glGenVertexArrays (  1  ,    VertexBufferObjectWithVAO . tmpHandle )  ;", "vaoHandle    =    VertexBufferObjectWithVAO . tmpHandle . get (  )  ;", "}", "METHOD_END"], "methodName": ["createVAO"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    (  ( vaoHandle )     !  =     (  -  1  )  )     {", ". tmpHandle . clear (  )  ;", ". tmpHandle . put ( vaoHandle )  ;", ". tmpHandle . flip (  )  ;", "Gdx . gl 3  0  . glDeleteVertexArrays (  1  ,     . tmpHandle )  ;", "vaoHandle    =     -  1  ;", "}", "}", "METHOD_END"], "methodName": ["deleteVAO"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cachedLocations . size )     =  =     0  )     {", "return ;", "}", "int   numAttributes    =    attributes . size (  )  ;", "for    ( int   i    =     0  ;    i    <    numAttributes ;    i +  +  )     {", "int   location    =    cachedLocations . get ( i )  ;", "if    ( location    <     0  )     {", "continue ;", "}", "shaderProgram . disableAttribute ( location )  ;", "}", "}", "METHOD_END"], "methodName": ["unbindAttributes"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "int   error    =    gl 2  0  . glGetError (  )  ;", "while    ( error    !  =     ( GL 2  0  . GL _ NO _ ERROR )  )     {", "glPer . getListener (  )  . onError ( error )  ;", "error    =    gl 2  0  . glGetError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.graphics.profiling.GL20Interceptor"}, {"methodBody": ["METHOD_START", "{", "int   error    =    gl 3  0  . glGetError (  )  ;", "while    ( error    !  =     ( GL 2  0  . GL _ NO _ ERROR )  )     {", "glPer . getListener (  )  . onError ( error )  ;", "error    =    gl 3  0  . glGetError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["check"], "fileName": "com.badlogic.gdx.graphics.profiling.GL30Interceptor"}, {"methodBody": ["METHOD_START", "{", "return   calls ;", "}", "METHOD_END"], "methodName": ["getCalls"], "fileName": "com.badlogic.gdx.graphics.profiling.GLInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   drawCalls ;", "}", "METHOD_END"], "methodName": ["getDrawCalls"], "fileName": "com.badlogic.gdx.graphics.profiling.GLInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   shaderSwitches ;", "}", "METHOD_END"], "methodName": ["getShaderSwitches"], "fileName": "com.badlogic.gdx.graphics.profiling.GLInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   textureBindings ;", "}", "METHOD_END"], "methodName": ["getTextureBindings"], "fileName": "com.badlogic.gdx.graphics.profiling.GLInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   vertexCount ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "com.badlogic.gdx.graphics.profiling.GLInterceptor"}, {"methodBody": ["METHOD_START", "{", "calls    =     0  ;", "textureBinds    =     0  ;", "drawCalls    =     0  ;", "shaderSwitches    =     0  ;", "vertexCount . reset (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.profiling.GLInterceptor"}, {"methodBody": ["METHOD_START", "{", "switch    ( error )     {", "case 2  0  _ INVALID _ VALUE    :", "return    _ INVALID _ VALUE \"  ;", "case 2  0  _ INVALID _ OPERATION    :", "return    _ INVALID _ OPERATION \"  ;", "case 2  0  _ INVALID _ FRAMEBUFFER _ OPERATION    :", "return    _ INVALID _ FRAMEBUFFER _ OPERATION \"  ;", "case 2  0  _ INVALID _ ENUM    :", "return    _ INVALID _ ENUM \"  ;", "case 2  0  _ OUT _ OF _ MEMORY    :", "return    _ OUT _ OF _ MEMORY \"  ;", "default    :", "return    \" number    \"     +    error ;", "}", "}", "METHOD_END"], "methodName": ["resolveErrorNumber"], "fileName": "com.badlogic.gdx.graphics.profiling.GLInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( enabled )  )", "return ;", "GL 3  0    gl 3  0     =    getGL 3  0  (  )  ;", "if    ( gl 3  0     !  =    null )", "setGL 3  0  (  (  ( GL 3  0 Interceptor )     ( getGL 3  0  (  )  )  )  . gl 3  0  )  ;", "else", "setGL 2  0  (  (  ( GL 2  0 Interceptor )     ( getGL 2  0  (  )  )  )  . gl 2  0  )  ;", "enabled    =    false ;", "}", "METHOD_END"], "methodName": ["disable"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "if    ( enabled )", "return ;", "GL 3  0    gl 3  0     =    getGL 3  0  (  )  ;", "if    ( gl 3  0     !  =    null )     {", "setGL 3  0  (  (  ( GL 3  0  )     ( glInterceptor )  )  )  ;", "} else    {", "setGL 2  0  ( glInterceptor )  ;", "}", "enabled    =    true ;", "}", "METHOD_END"], "methodName": ["enable"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "return   glInterceptor . getCalls (  )  ;", "}", "METHOD_END"], "methodName": ["getCalls"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "return   glInterceptor . getDrawCalls (  )  ;", "}", "METHOD_END"], "methodName": ["getDrawCalls"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "return   listener ;", "}", "METHOD_END"], "methodName": ["getListener"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "return   glInterceptor . getShaderSwitches (  )  ;", "}", "METHOD_END"], "methodName": ["getShaderSwitches"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "return   glInterceptor . getTextureBindings (  )  ;", "}", "METHOD_END"], "methodName": ["getTextureBindings"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "return   glInterceptor . getVertexCount (  )  ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "return   enabled ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "glInterceptor . reset (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    errorListener ;", "}", "METHOD_END"], "methodName": ["setListener"], "fileName": "com.badlogic.gdx.graphics.profiling.GLProfiler"}, {"methodBody": ["METHOD_START", "{", "longPressTask . cancel (  )  ;", "longPressFired    =    true ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "inTapSquare    =    false ;", "}", "METHOD_END"], "methodName": ["invalidateTapSquare"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "return   isLongPressed ( longPressSeconds )  ;", "}", "METHOD_END"], "methodName": ["isLongPressed"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "if    (  ( gestureStartTime )     =  =     0  )", "return   false ;", "return    (  ( TimeUtils . nanoTime (  )  )     -     ( gestureStartTime )  )     >     (  ( long )     ( duration    *     1  0  0  0  0  0  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["isLongPressed"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "return   panning ;", "}", "METHOD_END"], "methodName": ["isPanning"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Math . abs (  ( x    -    centerX )  )  )     <     ( tapSquareSize )  )     &  &     (  ( Math . abs (  ( y    -    centerY )  )  )     <     ( tapSquareSize )  )  ;", "}", "METHOD_END"], "methodName": ["isWithinTapSquare"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "gestureStartTime    =     0  ;", "panning    =    false ;", "inTapSquare    =    false ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "this . longPressSeconds    =    longPressSeconds ;", "}", "METHOD_END"], "methodName": ["setLongPressSeconds"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "this . maxFlingDelay    =    maxFlingDelay ;", "}", "METHOD_END"], "methodName": ["setMaxFlingDelay"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "this . tapCountInterval    =     (  ( long )     ( tapCountInterval    *     1  0  0  0  0  0  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["setTapCountInterval"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "this . tapSquareSize    =    halfTapSquareSize ;", "}", "METHOD_END"], "methodName": ["setTapSquareSize"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    >     1  )", "return   false ;", "if    ( pointer    =  =     0  )     {", "pointer 1  . set ( x ,    y )  ;", "gestureStartTime    =    Gdx . input . getCurrentEventTime (  )  ;", "tracker . start ( x ,    y ,    gestureStartTime )  ;", "if    ( Gdx . input . isTouched (  1  )  )     {", "inTapSquare    =    false ;", "pinching    =    true ;", "initialPointer 1  . set ( pointer 1  )  ;", "initialPointer 2  . set ( pointer 2  )  ;", "longPressTask . cancel (  )  ;", "} else    {", "inTapSquare    =    true ;", "pinching    =    false ;", "longPressFired    =    false ;", "tapSquareCenterX    =    x ;", "tapSquareCenterY    =    y ;", "if    (  !  ( longPressTask . isScheduled (  )  )  )", "utils . Timer . schedule ( longPressTask ,    longPressSeconds )  ;", "}", "} else    {", "pointer 2  . set ( x ,    y )  ;", "inTapSquare    =    false ;", "pinching    =    true ;", "initialPointer 1  . set ( pointer 1  )  ;", "initialPointer 2  . set ( pointer 2  )  ;", "longPressTask . cancel (  )  ;", "}", "return   listener . touchDown ( x ,    y ,    pointer ,    button )  ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    >     1  )", "return   false ;", "if    ( longPressFired )", "return   false ;", "if    ( pointer    =  =     0  )", "pointer 1  . set ( x ,    y )  ;", "else", "pointer 2  . set ( x ,    y )  ;", "if    ( pinching )     {", "if    (  ( listener )     !  =    null )     {", "boolean   result    =    listener . pinch ( initialPointer 1  ,    initialPointer 2  ,    pointer 1  ,    pointer 2  )  ;", "return    ( listener . zoom ( initialPointer 1  . dst ( initialPointer 2  )  ,    pointer 1  . dst ( pointer 2  )  )  )     |  |    result ;", "}", "return   false ;", "}", "tracker . update ( x ,    y ,    GgetCurrentEventTime (  )  )  ;", "if    (  ( inTapSquare )     &  &     (  !  ( isWithinTapSquare ( x ,    y ,    tapSquareCenterX ,    tapSquareCenterY )  )  )  )     {", "longPressTask . cancel (  )  ;", "inTapSquare    =    false ;", "}", "if    (  !  ( inTapSquare )  )     {", "panning    =    true ;", "return   listener . pan ( x ,    y ,    tracker . deltaX ,    tracker . deltaY )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDragged"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    >     1  )", "return   false ;", "if    (  ( inTapSquare )     &  &     (  !  ( isWithinTapSquare ( x ,    y ,    tapSquareCenterX ,    tapSquareCenterY )  )  )  )", "inTapSquare    =    false ;", "boolean   wasPanning    =    panning ;", "panning    =    false ;", "longPressTask . cancel (  )  ;", "if    ( longPressFired )", "return   false ;", "if    ( inTapSquare )     {", "if    (  (  (  (  ( lastTapButton )     !  =    button )     |  |     (  ( lastTapPointer )     !  =    pointer )  )     |  |     (  (  ( TimeUtils . nanoTime (  )  )     -     ( lastTapTime )  )     >     ( tapCountInterval )  )  )     |  |     (  !  ( isWithinTapSquare ( x ,    y ,    lastTapX ,    lastTapY )  )  )  )", "tapCount    =     0  ;", "( tapCount )  +  +  ;", "lastTapTime    =    TimeUtils . nanoTime (  )  ;", "lastTapX    =    x ;", "lastTapY    =    y ;", "lastTapButton    =    button ;", "lastTapPointer    =    pointer ;", "gestureStartTime    =     0  ;", "return   listener . tap ( x ,    y ,    tapCount ,    button )  ;", "}", "if    ( pinching )     {", "pinching    =    false ;", "listener . pinchStop (  )  ;", "panning    =    true ;", "if    ( pointer    =  =     0  )     {", "tracker . start ( pointer 2  . x ,    pointer 2  . y ,    GgetCurrentEventTime (  )  )  ;", "} else    {", "tracker . start ( pointer 1  . x ,    pointer 1  . y ,    GgetCurrentEventTime (  )  )  ;", "}", "return   false ;", "}", "boolean   handled    =    false ;", "if    ( wasPanning    &  &     (  !  ( panning )  )  )", "handled    =    listener . panStop ( x ,    y ,    pointer ,    button )  ;", "gestureStartTime    =     0  ;", "long   time    =    GgetCurrentEventTime (  )  ;", "if    (  ( time    -     ( tracker . lastTime )  )     <     ( maxFlingDelay )  )     {", "tracker . update ( x ,    y ,    time )  ;", "handled    =     ( listener . fling ( tracker . getVelocityX (  )  ,    tracker . getVelocityY (  )  ,    button )  )     |  |    handled ;", "}", "return   handled ;", "}", "METHOD_END"], "methodName": ["touchUp"], "fileName": "com.badlogic.gdx.input.GestureDetector"}, {"methodBody": ["METHOD_START", "{", "return   ips ;", "}", "METHOD_END"], "methodName": ["getIPs"], "fileName": "com.badlogic.gdx.input.RemoteInput"}, {"methodBody": ["METHOD_START", "{", "return   connected ;", "}", "METHOD_END"], "methodName": ["isConnected"], "fileName": "com.badlogic.gdx.input.RemoteInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "return   nnected ;", "}", "}", "METHOD_END"], "methodName": ["isConnected"], "fileName": "com.badlogic.gdx.input.RemoteSender"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  !  ( connected )  )", "return ;", "}", "try    {", "out . writeInt (  . ACCEL )  ;", "out . writeFloat ( Gdx . input . getAccelerometerX (  )  )  ;", "out . writeFloat ( Gdx . input . getAccelerometerY (  )  )  ;", "out . writeFloat ( Gdx . input . getAccelerometerZ (  )  )  ;", "out . writeInt (  . COMPASS )  ;", "out . writeFloat ( Gdx . input . getAzimuth (  )  )  ;", "out . writeFloat ( Gdx . input . getPitch (  )  )  ;", "out . writeFloat ( Gdx . input . getRoll (  )  )  ;", "out . writeInt (  . SIZE )  ;", "out . writeFloat ( Gdx . graphics . getWidth (  )  )  ;", "out . writeFloat ( Gdx . graphics . getHeight (  )  )  ;", "out . writeInt (  . GYRO )  ;", "out . writeFloat ( Gdx . input . getGyroscopeX (  )  )  ;", "out . writeFloat ( Gdx . input . getGyroscopeY (  )  )  ;", "out . writeFloat ( Gdx . input . getGyroscopeZ (  )  )  ;", "}    catch    ( Throwable   t )     {", "out    =    null ;", "connected    =    false ;", "}", "}", "METHOD_END"], "methodName": ["sendUpdate"], "fileName": "com.badlogic.gdx.input.RemoteSender"}, {"methodBody": ["METHOD_START", "{", "return   layers ;", "}", "METHOD_END"], "methodName": ["getLayers"], "fileName": "com.badlogic.gdx.maps.Map"}, {"methodBody": ["METHOD_START", "{", "return   properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "com.badlogic.gdx.maps.Map"}, {"methodBody": ["METHOD_START", "{", "return   layers ;", "}", "METHOD_END"], "methodName": ["getLayers"], "fileName": "com.badlogic.gdx.maps.MapGroupLayer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     !  =    null )     {", "parent . calculateRendOffsets (  )  ;", "rendOffsetX    =     ( parent . getRendOffsetX (  )  )     +     ( offsetX )  ;", "rendOffsetY    =     ( parent . getRendOffsetY (  )  )     +     ( offsetY )  ;", "} else    {", "rendOffsetX    =    offsetX ;", "rendOffsetY    =    offsetY ;", "}", "rendOffsetDirty    =    false ;", "}", "METHOD_END"], "methodName": ["calculateRenderOffsets"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   objects ;", "}", "METHOD_END"], "methodName": ["getObjects"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   offsetX ;", "}", "METHOD_END"], "methodName": ["getOffsetX"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   offsetY ;", "}", "METHOD_END"], "methodName": ["getOffsetY"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   opacity ;", "}", "METHOD_END"], "methodName": ["getOpacity"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "if    ( renderOffsetDirty )", "calculateRenderOffsets (  )  ;", "return   renderOffsetX ;", "}", "METHOD_END"], "methodName": ["getRenderOffsetX"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "if    ( renderOffsetDirty )", "calculateRenderOffsets (  )  ;", "return   renderOffsetY ;", "}", "METHOD_END"], "methodName": ["getRenderOffsetY"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "renderOffsetDirty    =    true ;", "}", "METHOD_END"], "methodName": ["invalidateRenderOffset"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "return   visible ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "this . offsetX    =    offsetX ;", "invalidateRenderOffset (  )  ;", "}", "METHOD_END"], "methodName": ["setOffsetX"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "this . offsetY    =    offsetY ;", "invalidateRenderOffset (  )  ;", "}", "METHOD_END"], "methodName": ["setOffsetY"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "this . opacity    =    opacity ;", "}", "METHOD_END"], "methodName": ["setOpacity"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "if    ( parent    =  =     ( this )  )", "throw   new   utils . GdxRuntimeException (  \" Can ' t   set   self   as   the   parent \"  )  ;", "this . parent    =    parent ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "this . visible    =    visible ;", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.maps.MapLayer"}, {"methodBody": ["METHOD_START", "{", "this . layers . add ( layer )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "return   layers . get ( index )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    layers . size ;    i    <    n ;    i +  +  )     {", "layer    =    layers . get ( i )  ;", "if    ( name . equals ( layer . getName (  )  )  )     {", "return   layer ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "return   getByType ( type ,    new   Array < T >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["getByType"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "fill . clear (  )  ;", "for    ( int   i    =     0  ,    n    =    layers . size ;    i    <    n ;    i +  +  )     {", "layer    =    layers . get ( i )  ;", "if    ( ClassReflection . isInstance ( type ,    layer )  )     {", "fill . add (  (  ( T )     ( layer )  )  )  ;", "}", "}", "return   fill ;", "}", "METHOD_END"], "methodName": ["getByType"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "return   layers . size ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "return   layers . indexOf ( layer ,    true )  ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "return   getIndex ( get ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "layers . removeValue ( layer ,    true )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "layers . removeIndex ( index )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "return   layers . size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.maps.MapLayers"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "return   opacity ;", "}", "METHOD_END"], "methodName": ["getOpacity"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "return   properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "return   visible ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "this . opacity    =    opacity ;", "}", "METHOD_END"], "methodName": ["setOpacity"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "this . visible    =    visible ;", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.maps.MapObject"}, {"methodBody": ["METHOD_START", "{", "this . objects . add ( object )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "return   objects . get ( index )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    objects . size ;    i    <    n ;    i +  +  )     {", "object    =    objects . get ( i )  ;", "if    ( name . equals ( object . getName (  )  )  )     {", "return   object ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "return   getByType ( type ,    new   Array < T >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["getByType"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "fill . clear (  )  ;", "for    ( int   i    =     0  ,    n    =    objects . size ;    i    <    n ;    i +  +  )     {", "object    =    objects . get ( i )  ;", "if    ( ClassReflection . isInstance ( type ,    object )  )     {", "fill . add (  (  ( T )     ( object )  )  )  ;", "}", "}", "return   fill ;", "}", "METHOD_END"], "methodName": ["getByType"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "return   objects . size ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "return   objects . indexOf ( object ,    true )  ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "return   getIndex ( get ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "objects . removeValue ( object ,    true )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "objects . removeIndex ( index )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.maps.MapObjects"}, {"methodBody": ["METHOD_START", "{", "properties . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "return   properties . containsKey ( key )  ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "return   properties . get ( key )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "Object   object    =    get ( key )  ;", "return   object    =  =    null    ?    defaultValue    :     (  ( T )     ( object )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( get ( key )  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "return   properties . keys (  )  ;", "}", "METHOD_END"], "methodName": ["getKeys"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "return   properties . values (  )  ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "properties . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "this . properties . putAll ( properties . properties )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "properties . remove ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.maps.MapProperties"}, {"methodBody": ["METHOD_START", "{", "return   circle ;", "}", "METHOD_END"], "methodName": ["getCircle"], "fileName": "com.badlogic.gdx.maps.objects.CircleMapObject"}, {"methodBody": ["METHOD_START", "{", "return   ellipse ;", "}", "METHOD_END"], "methodName": ["getEllipse"], "fileName": "com.badlogic.gdx.maps.objects.EllipseMapObject"}, {"methodBody": ["METHOD_START", "{", "return   polygon ;", "}", "METHOD_END"], "methodName": ["getPolygon"], "fileName": "com.badlogic.gdx.maps.objects.PolygonMapObject"}, {"methodBody": ["METHOD_START", "{", "this . polygon    =    polygon ;", "}", "METHOD_END"], "methodName": ["setPolygon"], "fileName": "com.badlogic.gdx.maps.objects.PolygonMapObject"}, {"methodBody": ["METHOD_START", "{", "return   polyline ;", "}", "METHOD_END"], "methodName": ["getPolyline"], "fileName": "com.badlogic.gdx.maps.objects.PolylineMapObject"}, {"methodBody": ["METHOD_START", "{", "this . polyline    =    polyline ;", "}", "METHOD_END"], "methodName": ["setPolyline"], "fileName": "com.badlogic.gdx.maps.objects.PolylineMapObject"}, {"methodBody": ["METHOD_START", "{", "return   rectangle ;", "}", "METHOD_END"], "methodName": ["getRectangle"], "fileName": "com.badlogic.gdx.maps.objects.RectangleMapObject"}, {"methodBody": ["METHOD_START", "{", "return   originX ;", "}", "METHOD_END"], "methodName": ["getOriginX"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   originY ;", "}", "METHOD_END"], "methodName": ["getOriginY"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   rotation ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   scaleX ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   scaleY ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   textureRegion ;", "}", "METHOD_END"], "methodName": ["getTextureRegion"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "this . originX    =    x ;", "}", "METHOD_END"], "methodName": ["setOriginX"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "this . originY    =    y ;", "}", "METHOD_END"], "methodName": ["setOriginY"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "this . rotation    =    rotation ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    x ;", "}", "METHOD_END"], "methodName": ["setScaleX"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "this . scaleY    =    y ;", "}", "METHOD_END"], "methodName": ["setScaleY"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "textureRegion    =    region ;", "}", "METHOD_END"], "methodName": ["setTextureRegion"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "this . y    =    y ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.maps.objects.TextureMapObject"}, {"methodBody": ["METHOD_START", "{", "return   load ( fileName ,    new   AtlasTmxMapLoader . AtlasTiledMapLoaderParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.maps.tiled.AtlasTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( parameter    !  =    null )     {", "convertObjectToTileSpace    =    parameter . convertObjectToTileSpace ;", "flipY    =    parameter . flipY ;", "} else    {", "convertObjectToTileSpace    =    false ;", "flipY    =    true ;", "}", "FileHandle   tmxFile    =    resolve ( fileName )  ;", "root    =    xml . parse ( tmxFile )  ;", "ObjectMap < String ,    TextureAtlas >    atlases    =    new   ObjectMap < String ,    TextureAtlas >  (  )  ;", "FileHandle   atlasFile    =    loadAtlas ( root ,    tmxFile )  ;", "if    ( atlasFile    =  =    null )     {", "throw   new   GdxRuntimeException (  \" Couldn ' t   load   atlas \"  )  ;", "}", "TextureAtlas   atlas    =    new   TextureAtlas ( atlasFile )  ;", "atlases . put ( atlasFile . path (  )  ,    atlas )  ;", ". AtlasResolver . DirectAtlasResolver   atlasResolver    =    new    . AtlasResolver . DirectAtlasResolver ( atlases )  ;", "TiledMap   map    =    loadMap ( root ,    tmxFile ,    atlasResolver )  ;", "map . setOwnedResources ( atlases . values (  )  . toArray (  )  )  ;", "setTextureFilters ( parameter . textureMinFilter ,    parameter . textureMagFilter )  ;", "return   map ;", "}    catch    ( IOException   e )     {", "throw   new   GdxRuntimeException (  (  (  \" Couldn ' t   load   tilemap    '  \"     +    fileName )     +     \"  '  \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.maps.tiled.AtlasTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "XmlReader . Element   e    =    root . getChildByName (  \" properties \"  )  ;", "if    ( e    !  =    null )     {", "for    ( XmlReader . Element   property    :    e . getChildrenByName (  \" property \"  )  )     {", "String   name    =    property . getAttribute (  \" name \"  ,    null )  ;", "String   value    =    property . getAttribute (  \" value \"  ,    null )  ;", "if    ( name . equals (  \" atlas \"  )  )     {", "if    ( value    =  =    null )     {", "value    =    property . getText (  )  ;", "}", "if    (  ( value    =  =    null )     |  |     (  ( value . length (  )  )     =  =     0  )  )     {", "continue ;", "}", "return   Base . getRelativeFileHandle ( tmxFile ,    value )  ;", "}", "}", "}", "FileHandle   atlasFile    =    tmxFile . sibling (  (  ( tmxFile . nameWithoutExtension (  )  )     +     \"  . atlas \"  )  )  ;", "return   atlasFile . exists (  )     ?    atlasFile    :    null ;", "}", "METHOD_END"], "methodName": ["loadAtlas"], "fileName": "com.badlogic.gdx.maps.tiled.AtlasTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "TiledMap   map    =    new   TiledMap (  )  ;", "String   mapOrientation    =    root . getAttribute (  \" orientation \"  ,    null )  ;", "int   mapWidth    =    root . getIntAttribute (  \" width \"  ,     0  )  ;", "int   mapHeight    =    root . getIntAttribute (  \" height \"  ,     0  )  ;", "int   tileWidth    =    root . getIntAttribute (  \" tilewidth \"  ,     0  )  ;", "int   tileHeight    =    root . getIntAttribute (  \" tileheight \"  ,     0  )  ;", "String   mapBackgroundColor    =    root . getAttribute (  \" backgroundcolor \"  ,    null )  ;", "MapProperties   mapProperties    =    map . getProperties (  )  ;", "if    ( mapOrientation    !  =    null )     {", "mapProperties . put (  \" orientation \"  ,    mapOrientation )  ;", "}", "mapProperties . put (  \" width \"  ,    mapWidth )  ;", "mapProperties . put (  \" height \"  ,    mapHeight )  ;", "mapProperties . put (  \" tilewidth \"  ,    tileWidth )  ;", "mapProperties . put (  \" tileheight \"  ,    tileHeight )  ;", "if    ( mapBackgroundColor    !  =    null )     {", "mapProperties . put (  \" backgroundcolor \"  ,    mapBackgroundColor )  ;", "}", "mapTileWidth    =    tileWidth ;", "mapTileHeight    =    tileHeight ;", "mapWidthInPixels    =    mapWidth    *    tileWidth ;", "mapHeightInPixels    =    mapHeight    *    tileHeight ;", "if    ( mapOrientation    !  =    null )     {", "if    (  \" staggered \"  . equals ( mapOrientation )  )     {", "if    ( mapHeight    >     1  )     {", "mapWidthInPixels    +  =    tileWidth    /     2  ;", "mapHeightInPixels    =     (  ( mapHeightInPixels )     /     2  )     +     ( tileHeight    /     2  )  ;", "}", "}", "}", "for    ( int   i    =     0  ,    j    =    root . getChildCount (  )  ;    i    <    j ;    i +  +  )     {", "XmlReader . Element   element    =    root . getChild ( i )  ;", "String   elementName    =    element . getName (  )  ;", "if    ( elementName . equals (  \" properties \"  )  )     {", "loadProperties ( map . getProperties (  )  ,    element )  ;", "} else", "if    ( elementName . equals (  \" tileset \"  )  )     {", "loadTileset ( map ,    element ,    tmxFile ,    resolver )  ;", "} else", "if    ( elementName . equals (  \" layer \"  )  )     {", "loadTileLayer ( map ,    map . getLayers (  )  ,    element )  ;", "} else", "if    ( elementName . equals (  \" objectgroup \"  )  )     {", "loadObjectGroup ( map ,    map . getLayers (  )  ,    element )  ;", "}", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["loadMap"], "fileName": "com.badlogic.gdx.maps.tiled.AtlasTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" tileset \"  )  )     {", "String   name    =    element . get (  \" name \"  ,    null )  ;", "int   firstgid    =    element . getIntAttribute (  \" firstgid \"  ,     1  )  ;", "int   tilewidth    =    element . getIntAttribute (  \" tilewidth \"  ,     0  )  ;", "int   tileheight    =    element . getIntAttribute (  \" tileheight \"  ,     0  )  ;", "int   spacing    =    element . getIntAttribute (  \" spacing \"  ,     0  )  ;", "int   margin    =    element . getIntAttribute (  \" margin \"  ,     0  )  ;", "String   source    =    element . getAttribute (  \" source \"  ,    null )  ;", "int   offsetX    =     0  ;", "int   offsetY    =     0  ;", "String   imageSource    =     \"  \"  ;", "int   imageWidth    =     0  ;", "int   imageHeight    =     0  ;", "FileHandle   image    =    null ;", "if    ( source    !  =    null )     {", "FileHandle   tsx    =    Base . getRelativeFileHandle ( tmxFile ,    source )  ;", "try    {", "element    =    xml . parse ( tsx )  ;", "name    =    element . get (  \" name \"  ,    null )  ;", "tilewidth    =    element . getIntAttribute (  \" tilewidth \"  ,     0  )  ;", "tileheight    =    element . getIntAttribute (  \" tileheight \"  ,     0  )  ;", "spacing    =    element . getIntAttribute (  \" spacing \"  ,     0  )  ;", "margin    =    element . getIntAttribute (  \" margin \"  ,     0  )  ;", "XmlReader . Element   offset    =    element . getChildByName (  \" tileoffset \"  )  ;", "if    ( offset    !  =    null )     {", "offsetX    =    offset . getIntAttribute (  \" x \"  ,     0  )  ;", "offsetY    =    offset . getIntAttribute (  \" y \"  ,     0  )  ;", "}", "XmlReader . Element   imageElement    =    element . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "imageSource    =    imageElement . getAttribute (  \" source \"  )  ;", "imageWidth    =    imageElement . getIntAttribute (  \" width \"  ,     0  )  ;", "imageHeight    =    imageElement . getIntAttribute (  \" height \"  ,     0  )  ;", "image    =    Base . getRelativeFileHandle ( tsx ,    imageSource )  ;", "}", "}    catch    ( SerializationException   e )     {", "throw   new   GdxRuntimeException (  \" Error   parsing   external   tileset .  \"  )  ;", "}", "} else    {", "XmlReader . Element   offset    =    element . getChildByName (  \" tileoffset \"  )  ;", "if    ( offset    !  =    null )     {", "offsetX    =    offset . getIntAttribute (  \" x \"  ,     0  )  ;", "offsetY    =    offset . getIntAttribute (  \" y \"  ,     0  )  ;", "}", "XmlReader . Element   imageElement    =    element . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "imageSource    =    imageElement . getAttribute (  \" source \"  )  ;", "imageWidth    =    imageElement . getIntAttribute (  \" width \"  ,     0  )  ;", "imageHeight    =    imageElement . getIntAttribute (  \" height \"  ,     0  )  ;", "image    =    Base . getRelativeFileHandle ( tmxFile ,    imageSource )  ;", "}", "}", "String   atlasFilePath    =    map . getProperties (  )  . get (  \" atlas \"  ,    String . class )  ;", "if    ( atlasFilePath    =  =    null )     {", "FileHandle   atlasFile    =    tmxFile . sibling (  (  ( tmxFile . nameWithoutExtension (  )  )     +     \"  . atlas \"  )  )  ;", "if    ( atlasFile . exists (  )  )", "atlasFilePath    =    atlasFile . name (  )  ;", "}", "if    ( atlasFilePath    =  =    null )     {", "throw   new   GdxRuntimeException (  \" The   map   is   missing   the    ' atlas '    property \"  )  ;", "}", "FileHandle   atlasHandle    =    Base . getRelativeFileHandle ( tmxFile ,    atlasFilePath )  ;", "atlasHandle    =    resolve ( atlasHandle . path (  )  )  ;", "TextureAtlas   atlas    =    resolver . getAtlas ( atlasHandle . path (  )  )  ;", "String   regionsName    =    name ;", "for    ( Texture   texture    :    atlas . getTextures (  )  )     {", "trackedTextures . add ( texture )  ;", "}", "TiledMapTileSet   tileset    =    new   TiledMapTileSet (  )  ;", "MapProperties   props    =    tileset . getProperties (  )  ;", "tileset . setName ( name )  ;", "props . put (  \" firstgid \"  ,    firstgid )  ;", "props . put (  \" imagesource \"  ,    imageSource )  ;", "props . put (  \" imagewidth \"  ,    imageWidth )  ;", "props . put (  \" imageheight \"  ,    imageHeight )  ;", "props . put (  \" tilewidth \"  ,    tilewidth )  ;", "props . put (  \" tileheight \"  ,    tileheight )  ;", "props . put (  \" margin \"  ,    margin )  ;", "props . put (  \" spacing \"  ,    spacing )  ;", "if    (  ( imageSource    !  =    null )     &  &     (  ( imageSource . length (  )  )     >     0  )  )     {", "int   lastgid    =     ( firstgid    +     (  ( imageWidth    /    tilewidth )     *     ( imageHeight    /    tileheight )  )  )     -     1  ;", "for    ( TextureAtlas . AtlasRegion   region    :    atlas . findRegions ( regionsName )  )     {", "if    ( region    !  =    null )     {", "int   tileid    =     ( region . index )     +    firstgid ;", "if    (  ( tileid    >  =    firstgid )     &  &     ( tileid    <  =    lastgid )  )     {", "StaticTiledMapTile   tile    =    new   StaticTiledMapTile ( region )  ;", "tile . setId ( tileid )  ;", "tile . setOffsetX ( offsetX )  ;", "tile . setOffsetY (  ( flipY    ?     - offsetY    :    offsetY )  )  ;", "tileset . putTile ( tileid ,    tile )  ;", "}", "}", "}", "}", "for    ( XmlReader . Element   tileElement    :    element . getChildrenByName (  \" tile \"  )  )     {", "int   tileid    =    firstgid    +     ( tileElement . getIntAttribute (  \" id \"  ,     0  )  )  ;", "TiledMapTile   tile    =    tileset . getTile ( tileid )  ;", "if    ( tile    =  =    null )     {", "XmlReader . Element   imageElement    =    tileElement . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "String   regionName    =    imageElement . getAttribute (  \" source \"  )  ;", "regionName    =    regionName . substring (  0  ,    regionName . lastIndexOf (  '  .  '  )  )  ;", "TextureAtlas . AtlasRegion   region    =    atlas . findRegion ( regionName )  ;", "if    ( region    =  =    null )", "throw   new   GdxRuntimeException (  (  \" Tileset   region   not   found :     \"     +    regionName )  )  ;", "tile    =    new   StaticTiledMapTile ( region )  ;", "tile . setId ( tileid )  ;", "tile . setOffsetX ( offsetX )  ;", "tile . setOffsetY (  ( flipY    ?     - offsetY    :    offsetY )  )  ;", "tileset . putTile ( tileid ,    tile )  ;", "}", "}", "if    ( tile    !  =    null )     {", "String   terrain    =    tileElement . getAttribute (  \" terrain \"  ,    null )  ;", "if    ( terrain    !  =    null )     {", "tile . getProperties (  )  . put (  \" terrain \"  ,    terrain )  ;", "}", "String   probability    =    tileElement . getAttribute (  \" probability \"  ,    null )  ;", "if    ( probability    !  =    null )     {", "tile . getProperties (  )  . put (  \" probability \"  ,    probability )  ;", "}", "XmlReader . Element   properties    =    tileElement . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( tile . getProperties (  )  ,    properties )  ;", "}", "}", "}", "Array < XmlReader . Element >    tileElements    =    element . getChildrenByName (  \" tile \"  )  ;", "Array < AnimatedTiledMapTile >    animatedTiles    =    new   Array < AnimatedTiledMapTile >  (  )  ;", "for    ( XmlReader . Element   tileElement    :    tileElements )     {", "int   localtid    =    tileElement . getIntAttribute (  \" id \"  ,     0  )  ;", "TiledMapTile   tile    =    tileset . getTile (  ( firstgid    +    localtid )  )  ;", "if    ( tile    !  =    null )     {", "XmlReader . Element   animationElement    =    tileElement . getChildByName (  \" animation \"  )  ;", "if    ( animationElement    !  =    null )     {", "Array < StaticTiledMapTile >    staticTiles    =    new   Array < StaticTiledMapTile >  (  )  ;", "IntArray   intervals    =    new   IntArray (  )  ;", "for    ( XmlReader . Element   frameElement    :    animationElement . getChildrenByName (  \" frame \"  )  )     {", "staticTiles . add (  (  ( StaticTiledMapTile )     ( tileset . getTile (  ( firstgid    +     ( frameElement . getIntAttribute (  \" tileid \"  )  )  )  )  )  )  )  ;", "intervals . add ( frameElement . getIntAttribute (  \" duration \"  )  )  ;", "}", "AnimatedTiledMapTile   animatedTile    =    new   AnimatedTiledMapTile ( intervals ,    staticTiles )  ;", "animatedTile . setId ( tile . getId (  )  )  ;", "animatedTiles . add ( animatedTile )  ;", "tile    =    animatedTile ;", "}", "XmlReader . Element   objectgroupElement    =    tileElement . getChildByName (  \" objectgroup \"  )  ;", "if    ( objectgroupElement    !  =    null )     {", "for    ( XmlReader . Element   objectElement    :    objectgroupElement . getChildrenByName (  \" object \"  )  )     {", "loadObject ( map ,    tile ,    objectElement )  ;", "}", "}", "String   terrain    =    tileElement . getAttribute (  \" terrain \"  ,    null )  ;", "if    ( terrain    !  =    null )     {", "tile . getProperties (  )  . put (  \" terrain \"  ,    terrain )  ;", "}", "String   probability    =    tileElement . getAttribute (  \" probability \"  ,    null )  ;", "if    ( probability    !  =    null )     {", "tile . getProperties (  )  . put (  \" probability \"  ,    probability )  ;", "}", "XmlReader . Element   properties    =    tileElement . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( tile . getProperties (  )  ,    properties )  ;", "}", "}", "}", "for    ( AnimatedTiledMapTile   tile    :    animatedTiles )     {", "tileset . putTile ( tile . getId (  )  ,    tile )  ;", "}", "XmlReader . Element   properties    =    element . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( tileset . getProperties (  )  ,    properties )  ;", "}", "map . getTileSets (  )  . addTileSet ( tileset )  ;", "}", "}", "METHOD_END"], "methodName": ["loadTileset"], "fileName": "com.badlogic.gdx.maps.tiled.AtlasTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "for    ( Texture   texture    :    trackedTextures )     {", "texture . setFilter ( min ,    mag )  ;", "}", "trackedTextures . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setTextureFilters"], "fileName": "com.badlogic.gdx.maps.tiled.AtlasTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )     {", "return   value ;", "} else", "if    ( type . equals (  \" int \"  )  )     {", "return   Integer . valueOf ( value )  ;", "} else", "if    ( type . equals (  \" float \"  )  )     {", "return   Float . valueOf ( value )  ;", "} else", "if    ( type . equals (  \" bool \"  )  )     {", "return   Boolean . valueOf ( value )  ;", "} else", "if    ( type . equals (  \" color \"  )  )     {", "String   opaqueColor    =    value . substring (  3  )  ;", "String   alpha    =    value . substring (  1  ,     3  )  ;", "return   graphics . Color . valueOf (  ( opaqueColor    +    alpha )  )  ;", "} else    {", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Wrong   type   given   for   property    \"     +    name )     +     \"  ,    given    :     \"  )     +    type )     +     \"  ,    supported    :    string ,    bool ,    int ,    float ,    color \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["castProperty"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "TiledMapTileLayer . Cell   cell    =    new   TiledMapTileLayer . Cell (  )  ;", "if    ( flipDiagonally )     {", "if    ( flipHorizontally    &  &    flipVertically )     {", "cell . setFlipHorizontally ( true )  ;", "cell . setRotation ( TiledMapTileLayer . Cell . ROTATE _  2  7  0  )  ;", "} else", "if    ( flipHorizontally )     {", "cell . setRotation ( TiledMapTileLayer . Cell . ROTATE _  2  7  0  )  ;", "} else", "if    ( flipVertically )     {", "cell . setRotation ( TiledMapTileLayer . Cell . ROTATE _  9  0  )  ;", "} else    {", "cell . setFlipVertically ( true )  ;", "cell . setRotation ( TiledMapTileLayer . Cell . ROTATE _  2  7  0  )  ;", "}", "} else    {", "cell . setFlipHorizontally ( flipHorizontally )  ;", "cell . setFlipVertically ( flipVertically )  ;", "}", "return   cell ;", "}", "METHOD_END"], "methodName": ["createTileLayerCell"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "StringTokenizer   tokenizer    =    new   StringTokenizer ( path ,     \"  \\  \\  /  \"  )  ;", "FHandle   result    =    f . parent (  )  ;", "wh    ( tokenizer . hasMoreElements (  )  )     {", "String   token    =    tokenizer . nextToken (  )  ;", "if    ( token . equals (  \"  .  .  \"  )  )", "result    =    result . parent (  )  ;", "else    {", "result    =    result . child ( token )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getRelativeFileHandle"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "XmlReader . Element   data    =    element . getChildByName (  \" data \"  )  ;", "String   encoding    =    data . getAttribute (  \" encoding \"  ,    null )  ;", "if    ( encoding    =  =    null )     {", "throw   new   GdxRuntimeException (  \" Unsupported   encoding    ( XML )    for   TMX   Layer   Data \"  )  ;", "}", "int [  ]    ids    =    new   int [ width    *    height ]  ;", "if    ( encoding . equals (  \" csv \"  )  )     {", "String [  ]    array    =    data . getText (  )  . split (  \"  ,  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )", "ids [ i ]     =     (  ( int )     ( Long . parseLong ( array [ i ]  . trim (  )  )  )  )  ;", "} else    {", "if    ( true )", "if    ( encoding . equals (  \" base 6  4  \"  )  )     {", "InputStream   is    =    null ;", "try    {", "String   compression    =    data . getAttribute (  \" compression \"  ,    null )  ;", "byte [  ]    bytes    =    utils . Base 6  4 Coder . decode ( data . getText (  )  )  ;", "if    ( compression    =  =    null )", "is    =    new   ByteArrayInputStream ( bytes )  ;", "else", "if    ( compression . equals (  \" gzip \"  )  )", "is    =    new   BufferedInputStream ( new   GZIPInputStream ( new   ByteArrayInputStream ( bytes )  ,    bytes . length )  )  ;", "else", "if    ( compression . equals (  \" zlib \"  )  )", "is    =    new   BufferedInputStream ( new   InflaterInputStream ( new   ByteArrayInputStream ( bytes )  )  )  ;", "else", "throw   new   GdxRuntimeException (  (  (  \" Unrecognised   compression    (  \"     +    compression )     +     \"  )    for   TMX   Layer   Data \"  )  )  ;", "byte [  ]    temp    =    new   byte [  4  ]  ;", "for    ( int   y    =     0  ;    y    <    height ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <    width ;    x +  +  )     {", "int   read    =    is . read ( temp )  ;", "while    ( read    <     ( temp . length )  )     {", "int   curr    =    is . read ( temp ,    read ,     (  ( temp . length )     -    read )  )  ;", "if    ( curr    =  =     (  -  1  )  )", "break ;", "read    +  =    curr ;", "}", "if    ( read    !  =     ( temp . length )  )", "throw   new   GdxRuntimeException (  \" Error   Reading   TMX   Layer   Data :    Premature   end   of   tile   data \"  )  ;", "ids [  (  ( y    *    width )     +    x )  ]     =     (  (  ( BaseTmxMapLoader . unsignedByteToInt ( temp [  0  ]  )  )     |     (  ( BaseTmxMapLoader . unsignedByteToInt ( temp [  1  ]  )  )     <  <     8  )  )     |     (  ( BaseTmxMapLoader . unsignedByteToInt ( temp [  2  ]  )  )     <  <     1  6  )  )     |     (  ( BaseTmxMapLoader . unsignedByteToInt ( temp [  3  ]  )  )     <  <     2  4  )  ;", "}", "}", "}    catch    ( IOException   e )     {", "throw   new   GdxRuntimeException (  (  \" Error   Reading   TMX   Layer   Data    -    IOException :     \"     +     ( e . getMessage (  )  )  )  )  ;", "}    finally    {", "utils . StreamUtils . closeQuietly ( is )  ;", "}", "} else    {", "throw   new   GdxRuntimeException (  (  (  \" Unrecognised   encoding    (  \"     +    encoding )     +     \"  )    for   TMX   Layer   Data \"  )  )  ;", "}", "}", "return   ids ;", "}", "METHOD_END"], "methodName": ["getTileIds"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    element . getAttribute (  \" name \"  ,    null )  ;", "float   opacity    =    Float . parseFloat ( element . getAttribute (  \" opacity \"  ,     \"  1  .  0  \"  )  )  ;", "boolean   visible    =     ( element . getIntAttribute (  \" visible \"  ,     1  )  )     =  =     1  ;", "float   offsetX    =    element . getFloatAttribute (  \" offsetx \"  ,     0  )  ;", "float   offsetY    =    element . getFloatAttribute (  \" offsety \"  ,     0  )  ;", "layer . setName ( name )  ;", "layer . setOpacity ( opacity )  ;", "layer . setVisible ( visible )  ;", "layer . setOffsetX ( offsetX )  ;", "layer . setOffsetY ( offsetY )  ;", "}", "METHOD_END"], "methodName": ["loadBasicLayerInfo"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" imagelayer \"  )  )     {", "int   x    =     0  ;", "int   y    =     0  ;", "if    ( element . hasAttribute (  \" offsetx \"  )  )     {", "x    =    Integer . parseInt ( element . getAttribute (  \" offsetx \"  ,     \"  0  \"  )  )  ;", "} else    {", "x    =    Integer . parseInt ( element . getAttribute (  \" x \"  ,     \"  0  \"  )  )  ;", "}", "if    ( element . hasAttribute (  \" offsety \"  )  )     {", "y    =    Integer . parseInt ( element . getAttribute (  \" offsety \"  ,     \"  0  \"  )  )  ;", "} else    {", "y    =    Integer . parseInt ( element . getAttribute (  \" y \"  ,     \"  0  \"  )  )  ;", "}", "if    ( flipY )", "y    =     ( mapHeightInPixels )     -    y ;", "TextureRegion   texture    =    null ;", "XmlReader . Element   image    =    element . getChildByName (  \" image \"  )  ;", "if    ( image    !  =    null )     {", "String   source    =    image . getAttribute (  \" source \"  )  ;", "FileHandle   handle    =     . getRelativeFileHandle ( tmxFile ,    source )  ;", "texture    =    imageResolver . getImage ( handle . path (  )  )  ;", "y    -  =    texture . getRegionHeight (  )  ;", "}", "TiledMapImageLayer   layer    =    new   TiledMapImageLayer ( texture ,    x ,    y )  ;", "loadBasicLayerInfo ( layer ,    element )  ;", "XmlReader . Element   properties    =    element . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( layer . getProperties (  )  ,    properties )  ;", "}", "parentLayers . add ( layer )  ;", "}", "}", "METHOD_END"], "methodName": ["loadImageLayer"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    element . getName (  )  ;", "if    ( name . equals (  \" group \"  )  )     {", "loadTileGroup (  ,    parentLayers ,    element ,    tmxFile ,    imageResolver )  ;", "} else", "if    ( name . equals (  \" layer \"  )  )     {", "loadTileLayer (  ,    parentLayers ,    element )  ;", "} else", "if    ( name . equals (  \" objectgroup \"  )  )     {", "loadObjectGroup (  ,    parentLayers ,    element )  ;", "} else", "if    ( name . equals (  \" imagelayer \"  )  )     {", "loadImageLayer (  ,    parentLayers ,    element ,    tmxFile ,    imageResolver )  ;", "}", "}", "METHOD_END"], "methodName": ["loadLayer"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "loadObject ( map ,    layer . getObjects (  )  ,    element ,    mapHeightInPixels )  ;", "}", "METHOD_END"], "methodName": ["loadObject"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" object \"  )  )     {", "MapObject   object    =    null ;", "float   scaleX    =     ( convertObjectToTileSpace )     ?     1  .  0 F    /     ( mapTileWidth )     :     1  .  0 F ;", "float   scaleY    =     ( convertObjectToTileSpace )     ?     1  .  0 F    /     ( mapTileHeight )     :     1  .  0 F ;", "float   x    =     ( element . getFloatAttribute (  \" x \"  ,     0  )  )     *    scaleX ;", "float   y    =     ( flipY    ?    heightInPixels    -     ( element . getFloatAttribute (  \" y \"  ,     0  )  )     :    element . getFloatAttribute (  \" y \"  ,     0  )  )     *    scaleY ;", "float   width    =     ( element . getFloatAttribute (  \" width \"  ,     0  )  )     *    scaleX ;", "float   height    =     ( element . getFloatAttribute (  \" height \"  ,     0  )  )     *    scaleY ;", "if    (  ( element . getChildCount (  )  )     >     0  )     {", "XmlReader . Element   child    =    null ;", "if    (  ( child    =    element . getChildByName (  \" polygon \"  )  )     !  =    null )     {", "String [  ]    points    =    child . getAttribute (  \" points \"  )  . split (  \"     \"  )  ;", "float [  ]    vertices    =    new   float [  ( points . length )     *     2  ]  ;", "for    ( int   i    =     0  ;    i    <     ( points . length )  ;    i +  +  )     {", "String [  ]    point    =    points [ i ]  . split (  \"  ,  \"  )  ;", "vertices [  ( i    *     2  )  ]     =     ( Float . parseFloat ( point [  0  ]  )  )     *    scaleX ;", "vertices [  (  ( i    *     2  )     +     1  )  ]     =     (  ( Float . parseFloat ( point [  1  ]  )  )     *    scaleY )     *     ( flipY    ?     -  1     :     1  )  ;", "}", "Polygon   polygon    =    new   Polygon ( vertices )  ;", "polygon . setPosition ( x ,    y )  ;", "object    =    new   PolygonMapObject ( polygon )  ;", "} else", "if    (  ( child    =    element . getChildByName (  \" polyline \"  )  )     !  =    null )     {", "String [  ]    points    =    child . getAttribute (  \" points \"  )  . split (  \"     \"  )  ;", "float [  ]    vertices    =    new   float [  ( points . length )     *     2  ]  ;", "for    ( int   i    =     0  ;    i    <     ( points . length )  ;    i +  +  )     {", "String [  ]    point    =    points [ i ]  . split (  \"  ,  \"  )  ;", "vertices [  ( i    *     2  )  ]     =     ( Float . parseFloat ( point [  0  ]  )  )     *    scaleX ;", "vertices [  (  ( i    *     2  )     +     1  )  ]     =     (  ( Float . parseFloat ( point [  1  ]  )  )     *    scaleY )     *     ( flipY    ?     -  1     :     1  )  ;", "}", "com . badlogic . gdx . math . Polyline   polyline    =    new   com . badlogic . gdx . math . Polyline ( vertices )  ;", "polyline . setPosition ( x ,    y )  ;", "object    =    new   objects . PolylineMapObject ( polyline )  ;", "} else", "if    (  ( child    =    element . getChildByName (  \" ellipse \"  )  )     !  =    null )     {", "object    =    new   objects . EllipseMapObject ( x ,     ( flipY    ?    y    -    height    :    y )  ,    width ,    height )  ;", "}", "}", "if    ( object    =  =    null )     {", "String   gid    =    null ;", "if    (  ( gid    =    element . getAttribute (  \" gid \"  ,    null )  )     !  =    null )     {", "int   id    =     (  ( int )     ( Long . parseLong ( gid )  )  )  ;", "boolean   flipHorizontally    =     ( id    &     ( BaseTmxMapLoader . FLAG _ FLIP _ HORIZONTALLY )  )     !  =     0  ;", "boolean   flipVertically    =     ( id    &     ( BaseTmxMapLoader . FLAG _ FLIP _ VERTICALLY )  )     !  =     0  ;", "TiledMapTile   tile    =    map . getTileSets (  )  . getTile (  ( id    &     (  ~  ( BaseTmxMapLoader . MASK _ CLEAR )  )  )  )  ;", "TiledMapTileMapObject   tiledMapTileMapObject    =    new   TiledMapTileMapObject ( tile ,    flipHorizontally ,    flipVertically )  ;", "TextureRegion   textureRegion    =    tiledMapTileMapObject . getTextureRegion (  )  ;", "tiledMapTileMapObject . getProperties (  )  . put (  \" gid \"  ,    id )  ;", "tiledMapTileMapObject . setX ( x )  ;", "tiledMapTileMapObject . setY (  ( flipY    ?    y    :    y    -    height )  )  ;", "float   objectWidth    =    element . getFloatAttribute (  \" width \"  ,    textureRegion . getRegionWidth (  )  )  ;", "float   objectHeight    =    element . getFloatAttribute (  \" height \"  ,    textureRegion . getRegionHeight (  )  )  ;", "tiledMapTileMapObject . setScaleX (  ( scaleX    *     ( objectWidth    /     ( textureRegion . getRegionWidth (  )  )  )  )  )  ;", "tiledMapTileMapObject . setScaleY (  ( scaleY    *     ( objectHeight    /     ( textureRegion . getRegionHeight (  )  )  )  )  )  ;", "tiledMapTileMapObject . setRotation ( element . getFloatAttribute (  \" rotation \"  ,     0  )  )  ;", "object    =    tiledMapTileMapObject ;", "} else    {", "object    =    new   RectangleMapObject ( x ,     ( flipY    ?    y    -    height    :    y )  ,    width ,    height )  ;", "}", "}", "object . setName ( element . getAttribute (  \" name \"  ,    null )  )  ;", "String   rotation    =    element . getAttribute (  \" rotation \"  ,    null )  ;", "if    ( rotation    !  =    null )     {", "object . getProperties (  )  . put (  \" rotation \"  ,    Float . parseFloat ( rotation )  )  ;", "}", "String   type    =    element . getAttribute (  \" type \"  ,    null )  ;", "if    ( type    !  =    null )     {", "object . getProperties (  )  . put (  \" type \"  ,    type )  ;", "}", "int   id    =    element . getIntAttribute (  \" id \"  ,     0  )  ;", "if    ( id    !  =     0  )     {", "object . getProperties (  )  . put (  \" id \"  ,    id )  ;", "}", "object . getProperties (  )  . put (  \" x \"  ,    x )  ;", "if    ( object   instanceof   TiledMapTileMapObject )     {", "object . getProperties (  )  . put (  \" y \"  ,    y )  ;", "} else    {", "object . getProperties (  )  . put (  \" y \"  ,     ( flipY    ?    y    -    height    :    y )  )  ;", "}", "object . getProperties (  )  . put (  \" width \"  ,    width )  ;", "object . getProperties (  )  . put (  \" height \"  ,    height )  ;", "object . setVisible (  (  ( element . getIntAttribute (  \" visible \"  ,     1  )  )     =  =     1  )  )  ;", "XmlReader . Element   properties    =    element . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( object . getProperties (  )  ,    properties )  ;", "}", "objects . add ( object )  ;", "}", "}", "METHOD_END"], "methodName": ["loadObject"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "loadObject ( map ,    tile . getObjects (  )  ,    element ,    tile . getTextureRegion (  )  . getRegionHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadObject"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" objectgroup \"  )  )     {", "ayer   layer    =    new   ayer (  )  ;", "loadBasicLayerInfo ( layer ,    element )  ;", "XmlReader . Element   properties    =    element . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( layer . getProperties (  )  ,    properties )  ;", "}", "for    ( XmlReader . Element   objectElement    :    element . getChildrenByName (  \" object \"  )  )     {", "loadObject ( map ,    layer ,    objectElement )  ;", "}", "parentLayers . add ( layer )  ;", "}", "}", "METHOD_END"], "methodName": ["loadObjectGroup"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )", "return ;", "if    ( element . getName (  )  . equals (  \" properties \"  )  )     {", "for    ( XmlRe . Element   property    :    element . getChildrenByName (  \" property \"  )  )     {", "String   name    =    property . getAttribute (  \" name \"  ,    null )  ;", "String   value    =    property . getAttribute (  \" value \"  ,    null )  ;", "String   type    =    property . getAttribute (  \" type \"  ,    null )  ;", "if    ( value    =  =    null )     {", "value    =    property . getText (  )  ;", "}", "Object   castValue    =    castProperty ( name ,    value ,    type )  ;", "properties . put ( name ,    castValue )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" group \"  )  )     {", "MapGroupLayer   groupLayer    =    new   MapGroupLayer (  )  ;", "loadBasicLayerInfo ( groupLayer ,    element )  ;", "XmlRe . Element   properties    =    element . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( groupLayer . getProperties (  )  ,    properties )  ;", "}", "for    ( int   i    =     0  ,    j    =    element . getChildCount (  )  ;    i    <    j ;    i +  +  )     {", "XmlRe . Element   child    =    element . getChild ( i )  ;", "loadLayer ( map ,    groupLayer . getLayers (  )  ,    child ,    tmxFile ,    imageResolver )  ;", "}", "for    ( MapLayer   layer    :    groupLayer . getLayers (  )  )     {", "layer . setParent ( groupLayer )  ;", "}", "parentLayers . add ( groupLayer )  ;", "}", "}", "METHOD_END"], "methodName": ["loadTileGroup"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" layer \"  )  )     {", "int   width    =    element . getIntAttribute (  \" width \"  ,     0  )  ;", "int   height    =    element . getIntAttribute (  \" height \"  ,     0  )  ;", "int   tileWidth    =    map . getProperties (  )  . get (  \" tilewidth \"  ,    Integer . class )  ;", "int   tileHeight    =    map . getProperties (  )  . get (  \" tileheight \"  ,    Integer . class )  ;", "TiledMapTileLayer   layer    =    new   TiledMapTileLayer ( width ,    height ,    tileWidth ,    tileHeight )  ;", "loadBasicLayerInfo ( layer ,    element )  ;", "int [  ]    ids    =     . getTileIds ( element ,    width ,    height )  ;", "TiledMapTileSets   tilesets    =    map . getTileSets (  )  ;", "for    ( int   y    =     0  ;    y    <    height ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <    width ;    x +  +  )     {", "int   id    =    ids [  (  ( y    *    width )     +    x )  ]  ;", "boolean   flipHorizontally    =     ( id    &     (  . FLAG _ FLIP _ HORIZONTALLY )  )     !  =     0  ;", "boolean   flipVertically    =     ( id    &     (  . FLAG _ FLIP _ VERTICALLY )  )     !  =     0  ;", "boolean   flipDiagonally    =     ( id    &     (  . FLAG _ FLIP _ DIAGONALLY )  )     !  =     0  ;", "TiledMapTile   tile    =    tilesets . getTile (  ( id    &     (  ~  (  . MASK _ CLEAR )  )  )  )  ;", "if    ( tile    !  =    null )     {", "TiledMapTileLayer . Cell   cell    =    createTileLayerCell ( flipHorizontally ,    flipVertically ,    flipDiagonally )  ;", "cell . setTile ( tile )  ;", "layer . setCell ( x ,     ( flipY    ?     ( height    -     1  )     -    y    :    y )  ,    cell )  ;", "}", "}", "}", "XmlReader . Element   properties    =    element . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( layer . getProperties (  )  ,    properties )  ;", "}", "parentLayers . add ( layer )  ;", "}", "}", "METHOD_END"], "methodName": ["loadTileLayer"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "return   b    &     2  5  5  ;", "}", "METHOD_END"], "methodName": ["unsignedByteToInt"], "fileName": "com.badlogic.gdx.maps.tiled.BaseTmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "StringTokenizer   tokenizer    =    new   StringTokenizer ( path ,     \"  \\  \\  /  \"  )  ;", "FHandle   result    =    f . parent (  )  ;", "wh    ( tokenizer . hasMoreElements (  )  )     {", "String   token    =    tokenizer . nextToken (  )  ;", "if    ( token . equals (  \"  .  .  \"  )  )", "result    =    result . parent (  )  ;", "else    {", "result    =    result . child ( token )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getRelativeFileHandle"], "fileName": "com.badlogic.gdx.maps.tiled.TideMapLoader"}, {"methodBody": ["METHOD_START", "{", "try    {", "FileHandle   tideFile    =    resolve ( fileName )  ;", "root    =    xml . parse ( tideFile )  ;", "ObjectMap < String ,    Texture >    textures    =    new   ObjectMap < String ,    Texture >  (  )  ;", "for    ( FileHandle   textureFile    :    loadTileSheets ( root ,    tideFile )  )     {", "textures . put ( textureFile . path (  )  ,    new   Texture ( textureFile )  )  ;", "}", "ImageResolver . DirectImageResolver   imageResolver    =    new   ImageResolver . DirectImageResolver ( textures )  ;", "TMap   map    =    loadMap ( root ,    tideFile ,    imageResolver )  ;", "map . setOwnedResources ( textures . values (  )  . toArray (  )  )  ;", "return   map ;", "}    catch    ( IOException   e )     {", "throw   new   GdxRuntimeException (  (  (  \" Couldn ' t   load   tilemap    '  \"     +    fileName )     +     \"  '  \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.maps.tiled.TideMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" Layer \"  )  )     {", "String   id    =    element . getAttribute (  \" Id \"  )  ;", "String   visible    =    element . getAttribute (  \" Visible \"  )  ;", "XmlReader . Element   dimensions    =    element . getChildByName (  \" Dimensions \"  )  ;", "String   layerSize    =    dimensions . getAttribute (  \" LayerSize \"  )  ;", "String   tileSize    =    dimensions . getAttribute (  \" TileSize \"  )  ;", "String [  ]    layerSizeParts    =    layerSize . split (  \"    x    \"  )  ;", "int   layerSizeX    =    Integer . parseInt ( layerSizeParts [  0  ]  )  ;", "int   layerSizeY    =    Integer . parseInt ( layerSizeParts [  1  ]  )  ;", "String [  ]    tileSizeParts    =    tileSize . split (  \"    x    \"  )  ;", "int   tileSizeX    =    Integer . parseInt ( tileSizeParts [  0  ]  )  ;", "int   tileSizeY    =    Integer . parseInt ( tileSizeParts [  1  ]  )  ;", "TiledMapTileLayer   layer    =    new   TiledMapTileLayer ( layerSizeX ,    layerSizeY ,    tileSizeX ,    tileSizeY )  ;", "layer . setName ( id )  ;", "layer . setVisible ( visible . equalsIgnoreCase (  \" True \"  )  )  ;", "XmlReader . Element   tileArray    =    element . getChildByName (  \" TileArray \"  )  ;", "Array < XmlReader . Element >    rows    =    tileArray . getChildrenByName (  \" Row \"  )  ;", "TiledMapTileSets   tilesets    =    map . getTileSets (  )  ;", "TiledMapTileSet   currentTileSet    =    null ;", "int   firstgid    =     0  ;", "int   x ;", "int   y ;", "for    ( int   row    =     0  ,    rowCount    =    rows . size ;    row    <    rowCount ;    row +  +  )     {", "XmlReader . Element   currentRow    =    rows . get ( row )  ;", "y    =     ( rowCount    -     1  )     -    row ;", "x    =     0  ;", "for    ( int   child    =     0  ,    childCount    =    currentRow . getChildCount (  )  ;    child    <    childCount ;    child +  +  )     {", "XmlReader . Element   currentChild    =    currentRow . getChild ( child )  ;", "String   name    =    currentChild . getName (  )  ;", "if    ( name . equals (  \" TileSheet \"  )  )     {", "currentTileSet    =    tilesets . getTileSet ( currentChild . getAttribute (  \" Ref \"  )  )  ;", "firstgid    =    currentTileSet . getProperties (  )  . get (  \" firstgid \"  ,    Integer . class )  ;", "} else", "if    ( name . equals (  \" Null \"  )  )     {", "x    +  =    currentChild . getIntAttribute (  \" Count \"  )  ;", "} else", "if    ( name . equals (  \" Static \"  )  )     {", "TiledMapTileLayer . Cell   cell    =    new   TiledMapTileLayer . Cell (  )  ;", "cell . setTile ( currentTileSet . getTile (  ( firstgid    +     ( currentChild . getIntAttribute (  \" Index \"  )  )  )  )  )  ;", "layer . setCell (  ( x +  +  )  ,    y ,    cell )  ;", "} else", "if    ( name . equals (  \" Animated \"  )  )     {", "int   interval    =    currentChild . getInt (  \" Interval \"  )  ;", "XmlReader . Element   frames    =    currentChild . getChildByName (  \" Frames \"  )  ;", "Array < tiles . StaticTiledMapTile >    frameTiles    =    new   Array < tiles . StaticTiledMapTile >  (  )  ;", "for    ( int   frameChild    =     0  ,    frameChildCount    =    frames . getChildCount (  )  ;    frameChild    <    frameChildCount ;    frameChild +  +  )     {", "XmlReader . Element   frame    =    frames . getChild ( frameChild )  ;", "String   frameName    =    frame . getName (  )  ;", "if    ( frameName . equals (  \" TileSheet \"  )  )     {", "currentTileSet    =    tilesets . getTileSet ( frame . getAttribute (  \" Ref \"  )  )  ;", "firstgid    =    currentTileSet . getProperties (  )  . get (  \" firstgid \"  ,    Integer . class )  ;", "} else", "if    ( frameName . equals (  \" Static \"  )  )     {", "frameTiles . add (  (  ( tiles . StaticTiledMapTile )     ( currentTileSet . getTile (  ( firstgid    +     ( frame . getIntAttribute (  \" Index \"  )  )  )  )  )  )  )  ;", "}", "}", "TiledMapTileLayer . Cell   cell    =    new   TiledMapTileLayer . Cell (  )  ;", "cell . setTile ( new   tiles . AnimatedTiledMapTile (  ( interval    /     1  0  0  0  .  0 F )  ,    frameTiles )  )  ;", "layer . setCell (  ( x +  +  )  ,    y ,    cell )  ;", "}", "}", "}", "XmlReader . Element   properties    =    element . getChildByName (  \" Properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( layer . getProperties (  )  ,    properties )  ;", "}", "map . getLayers (  )  . add ( layer )  ;", "}", "}", "METHOD_END"], "methodName": ["loadLayer"], "fileName": "com.badlogic.gdx.maps.tiled.TideMapLoader"}, {"methodBody": ["METHOD_START", "{", "TiledMap   map    =    new   TiledMap (  )  ;", "XmlReader . Element   properties    =    root . getChildByName (  \" Properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( map . getProperties (  )  ,    properties )  ;", "}", "XmlReader . Element   tilesheets    =    root . getChildByName (  \" TileSheets \"  )  ;", "for    ( XmlReader . Element   tilesheet    :    tilesheets . getChildrenByName (  \" TileSheet \"  )  )     {", "loadTileSheet ( map ,    tilesheet ,    tmxFile ,    imageResolver )  ;", "}", "XmlReader . Element   layers    =    root . getChildByName (  \" Layers \"  )  ;", "for    ( XmlReader . Element   layer    :    layers . getChildrenByName (  \" Layer \"  )  )     {", "loadLayer ( map ,    layer )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["loadMap"], "fileName": "com.badlogic.gdx.maps.tiled.TideMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" Properties \"  )  )     {", "for    ( XmlRe . Element   property    :    element . getChildrenByName (  \" Property \"  )  )     {", "String   key    =    property . getAttribute (  \" Key \"  ,    null )  ;", "String   type    =    property . getAttribute (  \" Type \"  ,    null )  ;", "String   value    =    property . getText (  )  ;", "if    ( type . equals (  \" Int 3  2  \"  )  )     {", "properties . put ( key ,    Integer . parseInt ( value )  )  ;", "} else", "if    ( type . equals (  \" String \"  )  )     {", "properties . put ( key ,    value )  ;", "} else", "if    ( type . equals (  \" Boolean \"  )  )     {", "properties . put ( key ,    value . equalsIgnoreCase (  \" true \"  )  )  ;", "} else    {", "properties . put ( key ,    value )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "com.badlogic.gdx.maps.tiled.TideMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" TileSheet \"  )  )     {", "String   id    =    element . getAttribute (  \" Id \"  )  ;", "String   description    =    element . getChildByName (  \" Description \"  )  . getText (  )  ;", "String   imageSource    =    element . getChildByName (  \" ImageSource \"  )  . getText (  )  ;", "XmlReader . Element   alignment    =    element . getChildByName (  \" Alignment \"  )  ;", "String   sheetSize    =    alignment . getAttribute (  \" SheetSize \"  )  ;", "String   tileSize    =    alignment . getAttribute (  \" TileSize \"  )  ;", "String   margin    =    alignment . getAttribute (  \" Margin \"  )  ;", "String   spacing    =    alignment . getAttribute (  \" Spacing \"  )  ;", "String [  ]    sheetSizeParts    =    sheetSize . split (  \"    x    \"  )  ;", "int   sheetSizeX    =    Integer . parseInt ( sheetSizeParts [  0  ]  )  ;", "int   sheetSizeY    =    Integer . parseInt ( sheetSizeParts [  1  ]  )  ;", "String [  ]    tileSizeParts    =    tileSize . split (  \"    x    \"  )  ;", "int   tileSizeX    =    Integer . parseInt ( tileSizeParts [  0  ]  )  ;", "int   tileSizeY    =    Integer . parseInt ( tileSizeParts [  1  ]  )  ;", "String [  ]    marginParts    =    margin . split (  \"    x    \"  )  ;", "int   marginX    =    Integer . parseInt ( marginParts [  0  ]  )  ;", "int   marginY    =    Integer . parseInt ( marginParts [  1  ]  )  ;", "String [  ]    spacingParts    =    margin . split (  \"    x    \"  )  ;", "int   spacingX    =    Integer . parseInt ( spacingParts [  0  ]  )  ;", "int   spacingY    =    Integer . parseInt ( spacingParts [  1  ]  )  ;", "FileHandle   image    =     . getRelativeFileHandle ( tideFile ,    imageSource )  ;", "TextureRegion   texture    =    imageResolver . getImage ( image . path (  )  )  ;", "TiledMapTileSets   tilesets    =    map . getTileSets (  )  ;", "int   firstgid    =     1  ;", "for    ( TiledMapTileSet   tileset    :    tilesets )     {", "firstgid    +  =    tileset . size (  )  ;", "}", "TiledMapTileSet   tileset    =    new   TiledMapTileSet (  )  ;", "tileset . setName ( id )  ;", "tileset . getProperties (  )  . put (  \" firstgid \"  ,    firstgid )  ;", "int   gid    =    firstgid ;", "int   stopWidth    =     ( texture . getRegionWidth (  )  )     -    tileSizeX ;", "int   stopHeight    =     ( texture . getRegionHeight (  )  )     -    tileSizeY ;", "for    ( int   y    =    marginY ;    y    <  =    stopHeight ;    y    +  =    tileSizeY    +    spacingY )     {", "for    ( int   x    =    marginX ;    x    <  =    stopWidth ;    x    +  =    tileSizeX    +    spacingX )     {", "TiledMapTile   tile    =    new   StaticTiledMapTile ( new   TextureRegion ( texture ,    x ,    y ,    tileSizeX ,    tileSizeY )  )  ;", "tile . setId ( gid )  ;", "tileset . putTile (  ( gid +  +  )  ,    tile )  ;", "}", "}", "XmlReader . Element   properties    =    element . getChildByName (  \" Properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( tileset . getProperties (  )  ,    properties )  ;", "}", "tilesets . addTileSet ( tileset )  ;", "}", "}", "METHOD_END"], "methodName": ["loadTileSheet"], "fileName": "com.badlogic.gdx.maps.tiled.TideMapLoader"}, {"methodBody": ["METHOD_START", "{", "Array < FileHandle >    images    =    new   Array < FileHandle >  (  )  ;", "XmlReader . Element   tilesheets    =    root . getChildByName (  \" TileSheets \"  )  ;", "for    ( XmlReader . Element   tileset    :    tilesheets . getChildrenByName (  \" TileSheet \"  )  )     {", "XmlReader . Element   imageSource    =    tileset . getChildByName (  \" ImageSource \"  )  ;", "FileHandle   image    =     . getRelativeFileHandle ( tideFile ,    imageSource . getText (  )  )  ;", "images . add ( image )  ;", "}", "return   images ;", "}", "METHOD_END"], "methodName": ["loadTileSheets"], "fileName": "com.badlogic.gdx.maps.tiled.TideMapLoader"}, {"methodBody": ["METHOD_START", "{", "return   tilesets ;", "}", "METHOD_END"], "methodName": ["getTileSets"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMap"}, {"methodBody": ["METHOD_START", "{", "this . ownedResources    =    resources ;", "}", "METHOD_END"], "methodName": ["setOwnedResources"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMap"}, {"methodBody": ["METHOD_START", "{", "return   region ;", "}", "METHOD_END"], "methodName": ["getTextureRegion"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapImageLayer"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapImageLayer"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapImageLayer"}, {"methodBody": ["METHOD_START", "{", "this . region    =    region ;", "}", "METHOD_END"], "methodName": ["setTextureRegion"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapImageLayer"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapImageLayer"}, {"methodBody": ["METHOD_START", "{", "this . y    =    y ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapImageLayer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( x    <     0  )     |  |     ( x    >  =     ( width )  )  )", "return   null ;", "if    (  ( y    <     0  )     |  |     ( y    >  =     ( height )  )  )", "return   null ;", "return   cells [ x ]  [ y ]  ;", "}", "METHOD_END"], "methodName": ["getCell"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileLayer"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileLayer"}, {"methodBody": ["METHOD_START", "{", "return   tileHeight ;", "}", "METHOD_END"], "methodName": ["getTileHeight"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileLayer"}, {"methodBody": ["METHOD_START", "{", "return   tileWidth ;", "}", "METHOD_END"], "methodName": ["getTileWidth"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileLayer"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileLayer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( x    <     0  )     |  |     ( x    >  =     ( width )  )  )", "return ;", "if    (  ( y    <     0  )     |  |     ( y    >  =     ( height )  )  )", "return ;", "cells [ x ]  [ y ]     =    cell ;", "}", "METHOD_END"], "methodName": ["setCell"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileLayer"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSet"}, {"methodBody": ["METHOD_START", "{", "return   properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSet"}, {"methodBody": ["METHOD_START", "{", "return   tiles . get ( id )  ;", "}", "METHOD_END"], "methodName": ["getTile"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSet"}, {"methodBody": ["METHOD_START", "{", "tiles . put ( id ,    tile )  ;", "}", "METHOD_END"], "methodName": ["putTile"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSet"}, {"methodBody": ["METHOD_START", "{", "tiles . remove ( id )  ;", "}", "METHOD_END"], "methodName": ["removeTile"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSet"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSet"}, {"methodBody": ["METHOD_START", "{", "return   tiles . size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSet"}, {"methodBody": ["METHOD_START", "{", "tilesets . add ( tileset )  ;", "}", "METHOD_END"], "methodName": ["addTileSet"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSets"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( tilesets . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "tileset    =    tilesets . get ( i )  ;", "TiledMapTile   tile    =    tileset . getTile ( id )  ;", "if    ( tile    !  =    null )     {", "return   tile ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getTile"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSets"}, {"methodBody": ["METHOD_START", "{", "return   tilesets . get ( index )  ;", "}", "METHOD_END"], "methodName": ["getTileSet"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSets"}, {"methodBody": ["METHOD_START", "{", "for    ( TiledMapTileSet   tileset    :    tilesets )     {", "if    ( name . equals ( tileset . getName (  )  )  )     {", "return   tileset ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getTileSet"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSets"}, {"methodBody": ["METHOD_START", "{", "tilesets . removeValue ( tileset ,    true )  ;", "}", "METHOD_END"], "methodName": ["removeTileSet"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSets"}, {"methodBody": ["METHOD_START", "{", "tilesets . removeIndex ( index )  ;", "}", "METHOD_END"], "methodName": ["removeTileSet"], "fileName": "com.badlogic.gdx.maps.tiled.TiledMapTileSets"}, {"methodBody": ["METHOD_START", "{", "return   load ( fileName ,    new   TmxMapLoader . Parameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.maps.tiled.TmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . convertObjectToTileSpace    =    parameters . convertObjectToTileSpace ;", "this . flipY    =    parameters . flipY ;", "FileHandle   tmxFile    =    resolve ( fileName )  ;", "root    =    xml . parse ( tmxFile )  ;", "ObjectMap < String ,    Texture >    textures    =    new   ObjectMap < String ,    Texture >  (  )  ;", "Array < FileHandle >    textureFiles    =    loadTilesets ( root ,    tmxFile )  ;", "textureFiles . addAll ( loadImages ( root ,    tmxFile )  )  ;", "for    ( FileHandle   textureFile    :    textureFiles )     {", "Texture   texture    =    new   Texture ( textureFile ,    parameters . generateMipMaps )  ;", "texture . setFilter ( parameters . textureMinFilter ,    parameters . textureMagFilter )  ;", "textures . put ( textureFile . path (  )  ,    texture )  ;", "}", "ImageResolver . DirectImageResolver   imageResolver    =    new   ImageResolver . DirectImageResolver ( textures )  ;", "TMap   map    =    loadTilemap ( root ,    tmxFile ,    imageResolver )  ;", "map . setOwnedResources ( textures . values (  )  . toArray (  )  )  ;", "return   map ;", "}    catch    ( IOException   e )     {", "throw   new   GdxRuntimeException (  (  (  \" Couldn ' t   load   tilemap    '  \"     +    fileName )     +     \"  '  \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.maps.tiled.TmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "Array < FileHandle >    images    =    new   Array < FileHandle >  (  )  ;", "for    ( XmlReader . Element   imageLayer    :    root . getChildrenByName (  \" imagelayer \"  )  )     {", "XmlReader . Element   image    =    imageLayer . getChildByName (  \" image \"  )  ;", "String   source    =    image . getAttribute (  \" source \"  ,    null )  ;", "if    ( source    !  =    null )     {", "FileHandle   handle    =    Base . getRelativeFileHandle ( tmxFile ,    source )  ;", "if    (  !  ( images . contains ( handle ,    false )  )  )     {", "images . add ( handle )  ;", "}", "}", "}", "return   images ;", "}", "METHOD_END"], "methodName": ["loadImages"], "fileName": "com.badlogic.gdx.maps.tiled.TmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( element . getName (  )  . equals (  \" tileset \"  )  )     {", "String   name    =    element . get (  \" name \"  ,    null )  ;", "int   firstgid    =    element . getIntAttribute (  \" firstgid \"  ,     1  )  ;", "int   tilewidth    =    element . getIntAttribute (  \" tilewidth \"  ,     0  )  ;", "int   tileheight    =    element . getIntAttribute (  \" tileheight \"  ,     0  )  ;", "int   spacing    =    element . getIntAttribute (  \" spacing \"  ,     0  )  ;", "int   margin    =    element . getIntAttribute (  \" margin \"  ,     0  )  ;", "String   source    =    element . getAttribute (  \" source \"  ,    null )  ;", "int   offsetX    =     0  ;", "int   offsetY    =     0  ;", "String   imageSource    =     \"  \"  ;", "int   imageWidth    =     0  ;", "int   imageHeight    =     0  ;", "FileHandle   image    =    null ;", "if    ( source    !  =    null )     {", "FileHandle   tsx    =    Base . getRelativeFileHandle ( tmxFile ,    source )  ;", "try    {", "element    =    xml . parse ( tsx )  ;", "name    =    element . get (  \" name \"  ,    null )  ;", "tilewidth    =    element . getIntAttribute (  \" tilewidth \"  ,     0  )  ;", "tileheight    =    element . getIntAttribute (  \" tileheight \"  ,     0  )  ;", "spacing    =    element . getIntAttribute (  \" spacing \"  ,     0  )  ;", "margin    =    element . getIntAttribute (  \" margin \"  ,     0  )  ;", "XmlReader . Element   offset    =    element . getChildByName (  \" tileoffset \"  )  ;", "if    ( offset    !  =    null )     {", "offsetX    =    offset . getIntAttribute (  \" x \"  ,     0  )  ;", "offsetY    =    offset . getIntAttribute (  \" y \"  ,     0  )  ;", "}", "XmlReader . Element   imageElement    =    element . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "imageSource    =    imageElement . getAttribute (  \" source \"  )  ;", "imageWidth    =    imageElement . getIntAttribute (  \" width \"  ,     0  )  ;", "imageHeight    =    imageElement . getIntAttribute (  \" height \"  ,     0  )  ;", "image    =    Base . getRelativeFileHandle ( tsx ,    imageSource )  ;", "}", "}    catch    ( SerializationException   e )     {", "throw   new   GdxRuntimeException (  \" Error   parsing   external   tileset .  \"  )  ;", "}", "} else    {", "XmlReader . Element   offset    =    element . getChildByName (  \" tileoffset \"  )  ;", "if    ( offset    !  =    null )     {", "offsetX    =    offset . getIntAttribute (  \" x \"  ,     0  )  ;", "offsetY    =    offset . getIntAttribute (  \" y \"  ,     0  )  ;", "}", "XmlReader . Element   imageElement    =    element . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "imageSource    =    imageElement . getAttribute (  \" source \"  )  ;", "imageWidth    =    imageElement . getIntAttribute (  \" width \"  ,     0  )  ;", "imageHeight    =    imageElement . getIntAttribute (  \" height \"  ,     0  )  ;", "image    =    Base . getRelativeFileHandle ( tmxFile ,    imageSource )  ;", "}", "}", "TiledMapTileSet   tileset    =    new   TiledMapTileSet (  )  ;", "tileset . setName ( name )  ;", "tileset . getProperties (  )  . put (  \" firstgid \"  ,    firstgid )  ;", "if    ( image    !  =    null )     {", "TextureRegion   texture    =    imageResolver . getImage ( image . path (  )  )  ;", "MapProperties   props    =    tileset . getProperties (  )  ;", "props . put (  \" imagesource \"  ,    imageSource )  ;", "props . put (  \" imagewidth \"  ,    imageWidth )  ;", "props . put (  \" imageheight \"  ,    imageHeight )  ;", "props . put (  \" tilewidth \"  ,    tilewidth )  ;", "props . put (  \" tileheight \"  ,    tileheight )  ;", "props . put (  \" margin \"  ,    margin )  ;", "props . put (  \" spacing \"  ,    spacing )  ;", "int   stopWidth    =     ( texture . getRegionWidth (  )  )     -    tilewidth ;", "int   stopHeight    =     ( texture . getRegionHeight (  )  )     -    tileheight ;", "int   id    =    firstgid ;", "for    ( int   y    =    margin ;    y    <  =    stopHeight ;    y    +  =    tileheight    +    spacing )     {", "for    ( int   x    =    margin ;    x    <  =    stopWidth ;    x    +  =    tilewidth    +    spacing )     {", "TextureRegion   tileRegion    =    new   TextureRegion ( texture ,    x ,    y ,    tilewidth ,    tileheight )  ;", "TiledMapTile   tile    =    new   StaticTiledMapTile ( tileRegion )  ;", "tile . setId ( id )  ;", "tile . setOffsetX ( offsetX )  ;", "tile . setOffsetY (  ( flipY    ?     - offsetY    :    offsetY )  )  ;", "tileset . putTile (  ( id +  +  )  ,    tile )  ;", "}", "}", "} else    {", "Array < XmlReader . Element >    tileElements    =    element . getChildrenByName (  \" tile \"  )  ;", "for    ( XmlReader . Element   tileElement    :    tileElements )     {", "XmlReader . Element   imageElement    =    tileElement . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "imageSource    =    imageElement . getAttribute (  \" source \"  )  ;", "imageWidth    =    imageElement . getIntAttribute (  \" width \"  ,     0  )  ;", "imageHeight    =    imageElement . getIntAttribute (  \" height \"  ,     0  )  ;", "if    ( source    !  =    null )     {", "image    =    Base . getRelativeFileHandle ( Base . getRelativeFileHandle ( tmxFile ,    source )  ,    imageSource )  ;", "} else    {", "image    =    Base . getRelativeFileHandle ( tmxFile ,    imageSource )  ;", "}", "}", "TextureRegion   texture    =    imageResolver . getImage ( image . path (  )  )  ;", "TiledMapTile   tile    =    new   StaticTiledMapTile ( texture )  ;", "tile . setId (  ( firstgid    +     ( tileElement . getIntAttribute (  \" id \"  )  )  )  )  ;", "tile . setOffsetX ( offsetX )  ;", "tile . setOffsetY (  ( flipY    ?     - offsetY    :    offsetY )  )  ;", "tileset . putTile ( tile . getId (  )  ,    tile )  ;", "}", "}", "Array < XmlReader . Element >    tileElements    =    element . getChildrenByName (  \" tile \"  )  ;", "Array < AnimatedTiledMapTile >    animatedTiles    =    new   Array < AnimatedTiledMapTile >  (  )  ;", "for    ( XmlReader . Element   tileElement    :    tileElements )     {", "int   localtid    =    tileElement . getIntAttribute (  \" id \"  ,     0  )  ;", "TiledMapTile   tile    =    tileset . getTile (  ( firstgid    +    localtid )  )  ;", "if    ( tile    !  =    null )     {", "XmlReader . Element   animationElement    =    tileElement . getChildByName (  \" animation \"  )  ;", "if    ( animationElement    !  =    null )     {", "Array < StaticTiledMapTile >    staticTiles    =    new   Array < StaticTiledMapTile >  (  )  ;", "IntArray   intervals    =    new   IntArray (  )  ;", "for    ( XmlReader . Element   frameElement    :    animationElement . getChildrenByName (  \" frame \"  )  )     {", "staticTiles . add (  (  ( StaticTiledMapTile )     ( tileset . getTile (  ( firstgid    +     ( frameElement . getIntAttribute (  \" tileid \"  )  )  )  )  )  )  )  ;", "intervals . add ( frameElement . getIntAttribute (  \" duration \"  )  )  ;", "}", "AnimatedTiledMapTile   animatedTile    =    new   AnimatedTiledMapTile ( intervals ,    staticTiles )  ;", "animatedTile . setId ( tile . getId (  )  )  ;", "animatedTiles . add ( animatedTile )  ;", "tile    =    animatedTile ;", "}", "XmlReader . Element   objectgroupElement    =    tileElement . getChildByName (  \" objectgroup \"  )  ;", "if    ( objectgroupElement    !  =    null )     {", "for    ( XmlReader . Element   objectElement    :    objectgroupElement . getChildrenByName (  \" object \"  )  )     {", "loadObject ( map ,    tile ,    objectElement )  ;", "}", "}", "String   terrain    =    tileElement . getAttribute (  \" terrain \"  ,    null )  ;", "if    ( terrain    !  =    null )     {", "tile . getProperties (  )  . put (  \" terrain \"  ,    terrain )  ;", "}", "String   probability    =    tileElement . getAttribute (  \" probability \"  ,    null )  ;", "if    ( probability    !  =    null )     {", "tile . getProperties (  )  . put (  \" probability \"  ,    probability )  ;", "}", "XmlReader . Element   properties    =    tileElement . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( tile . getProperties (  )  ,    properties )  ;", "}", "}", "}", "for    ( AnimatedTiledMapTile   tile    :    animatedTiles )     {", "tileset . putTile ( tile . getId (  )  ,    tile )  ;", "}", "XmlReader . Element   properties    =    element . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( tileset . getProperties (  )  ,    properties )  ;", "}", "map . getTileSets (  )  . addTileSet ( tileset )  ;", "}", "}", "METHOD_END"], "methodName": ["loadTileSet"], "fileName": "com.badlogic.gdx.maps.tiled.TmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "TiledMap   map    =    new   TiledMap (  )  ;", "String   mapOrientation    =    root . getAttribute (  \" orientation \"  ,    null )  ;", "int   mapWidth    =    root . getIntAttribute (  \" width \"  ,     0  )  ;", "int   mapHeight    =    root . getIntAttribute (  \" height \"  ,     0  )  ;", "int   tileWidth    =    root . getIntAttribute (  \" tilewidth \"  ,     0  )  ;", "int   tileHeight    =    root . getIntAttribute (  \" tileheight \"  ,     0  )  ;", "int   hexSideLength    =    root . getIntAttribute (  \" hexsidelength \"  ,     0  )  ;", "String   staggerAxis    =    root . getAttribute (  \" staggeraxis \"  ,    null )  ;", "String   staggerIndex    =    root . getAttribute (  \" staggerindex \"  ,    null )  ;", "String   mapBackgroundColor    =    root . getAttribute (  \" backgroundcolor \"  ,    null )  ;", "MapProperties   mapProperties    =    map . getProperties (  )  ;", "if    ( mapOrientation    !  =    null )     {", "mapProperties . put (  \" orientation \"  ,    mapOrientation )  ;", "}", "mapProperties . put (  \" width \"  ,    mapWidth )  ;", "mapProperties . put (  \" height \"  ,    mapHeight )  ;", "mapProperties . put (  \" tilewidth \"  ,    tileWidth )  ;", "mapProperties . put (  \" tileheight \"  ,    tileHeight )  ;", "mapProperties . put (  \" hexsidelength \"  ,    hexSideLength )  ;", "if    ( staggerAxis    !  =    null )     {", "mapProperties . put (  \" staggeraxis \"  ,    staggerAxis )  ;", "}", "if    ( staggerIndex    !  =    null )     {", "mapProperties . put (  \" staggerindex \"  ,    staggerIndex )  ;", "}", "if    ( mapBackgroundColor    !  =    null )     {", "mapProperties . put (  \" backgroundcolor \"  ,    mapBackgroundColor )  ;", "}", "mapTileWidth    =    tileWidth ;", "mapTileHeight    =    tileHeight ;", "mapWidthInPixels    =    mapWidth    *    tileWidth ;", "mapHeightInPixels    =    mapHeight    *    tileHeight ;", "if    ( mapOrientation    !  =    null )     {", "if    (  \" staggered \"  . equals ( mapOrientation )  )     {", "if    ( mapHeight    >     1  )     {", "mapWidthInPixels    +  =    tileWidth    /     2  ;", "mapHeightInPixels    =     (  ( mapHeightInPixels )     /     2  )     +     ( tileHeight    /     2  )  ;", "}", "}", "}", "XmlReader . Element   properties    =    root . getChildByName (  \" properties \"  )  ;", "if    ( properties    !  =    null )     {", "loadProperties ( map . getProperties (  )  ,    properties )  ;", "}", "Array < XmlReader . Element >    tilesets    =    root . getChildrenByName (  \" tileset \"  )  ;", "for    ( XmlReader . Element   element    :    tilesets )     {", "loadTileSet ( map ,    element ,    tmxFile ,    imageResolver )  ;", "root . removeChild ( element )  ;", "}", "for    ( int   i    =     0  ,    j    =    root . getChildCount (  )  ;    i    <    j ;    i +  +  )     {", "XmlReader . Element   element    =    root . getChild ( i )  ;", "loadLayer ( map ,    map . getLayers (  )  ,    element ,    tmxFile ,    imageResolver )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["loadTilemap"], "fileName": "com.badlogic.gdx.maps.tiled.TmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "Array < FileHandle >    images    =    new   Array < FileHandle >  (  )  ;", "for    ( XmlReader . Element   tileset    :    root . getChildrenByName (  \" tileset \"  )  )     {", "String   source    =    tileset . getAttribute (  \" source \"  ,    null )  ;", "if    ( source    !  =    null )     {", "FileHandle   tsxFile    =    Base . getRelativeFileHandle ( tmxFile ,    source )  ;", "tileset    =    xml . parse ( tsxFile )  ;", "XmlReader . Element   imageElement    =    tileset . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "String   imageSource    =    tileset . getChildByName (  \" image \"  )  . getAttribute (  \" source \"  )  ;", "FileHandle   image    =    Base . getRelativeFileHandle ( tsxFile ,    imageSource )  ;", "images . add ( image )  ;", "} else    {", "for    ( XmlReader . Element   tile    :    tileset . getChildrenByName (  \" tile \"  )  )     {", "String   imageSource    =    tile . getChildByName (  \" image \"  )  . getAttribute (  \" source \"  )  ;", "FileHandle   image    =    Base . getRelativeFileHandle ( tsxFile ,    imageSource )  ;", "images . add ( image )  ;", "}", "}", "} else    {", "XmlReader . Element   imageElement    =    tileset . getChildByName (  \" image \"  )  ;", "if    ( imageElement    !  =    null )     {", "String   imageSource    =    tileset . getChildByName (  \" image \"  )  . getAttribute (  \" source \"  )  ;", "FileHandle   image    =    Base . getRelativeFileHandle ( tmxFile ,    imageSource )  ;", "images . add ( image )  ;", "} else    {", "for    ( XmlReader . Element   tile    :    tileset . getChildrenByName (  \" tile \"  )  )     {", "String   imageSource    =    tile . getChildByName (  \" image \"  )  . getAttribute (  \" source \"  )  ;", "FileHandle   image    =    Base . getRelativeFileHandle ( tmxFile ,    imageSource )  ;", "images . add ( image )  ;", "}", "}", "}", "}", "return   images ;", "}", "METHOD_END"], "methodName": ["loadTilesets"], "fileName": "com.badlogic.gdx.maps.tiled.TmxMapLoader"}, {"methodBody": ["METHOD_START", "{", "return   tile ;", "}", "METHOD_END"], "methodName": ["getTile"], "fileName": "com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject"}, {"methodBody": ["METHOD_START", "{", "return   flipHorizontally ;", "}", "METHOD_END"], "methodName": ["isFlipHorizontally"], "fileName": "com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject"}, {"methodBody": ["METHOD_START", "{", "return   flipVertically ;", "}", "METHOD_END"], "methodName": ["isFlipVertically"], "fileName": "com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject"}, {"methodBody": ["METHOD_START", "{", "this . flipHorizontally    =    flipHorizontally ;", "}", "METHOD_END"], "methodName": ["setFlipHorizontally"], "fileName": "com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject"}, {"methodBody": ["METHOD_START", "{", "this . flipVertically    =    flipVertically ;", "}", "METHOD_END"], "methodName": ["setFlipVertically"], "fileName": "com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject"}, {"methodBody": ["METHOD_START", "{", "this . tile    =    tile ;", "}", "METHOD_END"], "methodName": ["setTile"], "fileName": "com.badlogic.gdx.maps.tiled.objects.TiledMapTileMapObject"}, {"methodBody": ["METHOD_START", "{", "AnimatedTiledMapTile . updateAnimationBaseTime (  )  ;", "batch . begin (  )  ;", "}", "METHOD_END"], "methodName": ["beginRender"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "batch . end (  )  ;", "}", "METHOD_END"], "methodName": ["endRender"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "return   batch ;", "}", "METHOD_END"], "methodName": ["getBatch"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "return   map ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "return   unitScale ;", "}", "METHOD_END"], "methodName": ["getUnitScale"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "return   viewBounds ;", "}", "METHOD_END"], "methodName": ["getViewBounds"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( layer . isVisible (  )  )  )", "return ;", "if    ( layer   instanceof   MapGroupLayer )     {", "MapLayers   childLayers    =     (  ( MapGroupLayer )     ( layer )  )  . getLayers (  )  ;", "for    ( int   i    =     0  ;    i    <     ( childLayers . size (  )  )  ;    i +  +  )     {", "MapLayer   childLayer    =    childLayers . get ( i )  ;", "if    (  !  ( childLayer . isVisible (  )  )  )", "continue ;", "renderMapLayer ( childLayer )  ;", "}", "} else    {", "if    ( layer   instanceof   TiledMapTileLayer )     {", "renderTileLayer (  (  ( TiledMapTileLayer )     ( layer )  )  )  ;", "} else", "if    ( layer   instanceof   TiledMapImageLayer )     {", "renderImageLayer (  (  ( TiledMapImageLayer )     ( layer )  )  )  ;", "} else    {", "renderObjects ( layer )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["renderMapLayer"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "this . map    =    map ;", "}", "METHOD_END"], "methodName": ["setMap"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.BatchTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "String   axis    =    map . getProperties (  )  . get (  \" staggeraxis \"  ,    String . class )  ;", "if    ( axis    !  =    null )     {", "if    ( axis . equals (  \" x \"  )  )     {", "staggerAxisX    =    true ;", "} else    {", "staggerAxisX    =    false ;", "}", "}", "String   index    =    map . getProperties (  )  . get (  \" staggerindex \"  ,    String . class )  ;", "if    ( index    !  =    null )     {", "if    ( index . equals (  \" even \"  )  )     {", "staggerIndexEven    =    true ;", "} else    {", "staggerIndexEven    =    false ;", "}", "}", "Integer   length    =    map . getProperties (  )  . get (  \" hexsidelength \"  ,    Integer . class )  ;", "if    ( length    !  =    null )     {", "hexSideLength    =    length . intValue (  )  ;", "} else    {", "if    ( staggerAxisX )     {", "length    =    map . getProperties (  )  . get (  \" tilewidth \"  ,    Integer . class )  ;", "if    ( length    !  =    null )     {", "hexSideLength    =     0  .  5 F    *     ( length . intValue (  )  )  ;", "} else    {", "TileLayer   tmtl    =     (  ( TileLayer )     ( map . getLayers (  )  . get (  0  )  )  )  ;", "hexSideLength    =     0  .  5 F    *     ( tmtl . getTileWidth (  )  )  ;", "}", "} else    {", "length    =    map . getProperties (  )  . get (  \" tileheight \"  ,    Integer . class )  ;", "if    ( length    !  =    null )     {", "hexSideLength    =     0  .  5 F    *     ( length . intValue (  )  )  ;", "} else    {", "TileLayer   tmtl    =     (  ( TileLayer )     ( map . getLayers (  )  . get (  0  )  )  )  ;", "hexSideLength    =     0  .  5 F    *     ( tmtl . getTileHeight (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.HexagonalTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( cell    !  =    null )     {", "final   TiledMapTile   tile    =    cell . getTile (  )  ;", "if    ( tile    !  =    null )     {", "if    ( tile   instanceof   AnimatedTiledMapTile )", "return ;", "final   boolean   flipX    =    cell . getFlipHorizontally (  )  ;", "final   boolean   flipY    =    cell . getFlipVertically (  )  ;", "final   int   rotations    =    cell . getRotation (  )  ;", "TextureRegion   region    =    tile . getTextureRegion (  )  ;", "float   x 1     =    x    +     (  ( tile . getOffsetX (  )  )     *     ( unitScale )  )  ;", "float   y 1     =    y    +     (  ( tile . getOffsetY (  )  )     *     ( unitScale )  )  ;", "float   x 2     =    x 1     +     (  ( region . getRegionWidth (  )  )     *     ( unitScale )  )  ;", "float   y 2     =    y 1     +     (  ( region . getRegionHeight (  )  )     *     ( unitScale )  )  ;", "float   u 1     =    region . getU (  )  ;", "float   v 1     =    region . getV 2  (  )  ;", "float   u 2     =    region . getU 2  (  )  ;", "float   v 2     =    region . getV (  )  ;", "vertices [ Batch . X 1  ]     =    x 1  ;", "vertices [ Batch . Y 1  ]     =    y 1  ;", "vertices [ Batch . C 1  ]     =    color ;", "vertices [ Batch . U 1  ]     =    u 1  ;", "vertices [ Batch . V 1  ]     =    v 1  ;", "vertices [ Batch . X 2  ]     =    x 1  ;", "vertices [ Batch . Y 2  ]     =    y 2  ;", "vertices [ Batch . C 2  ]     =    color ;", "vertices [ Batch . U 2  ]     =    u 1  ;", "vertices [ Batch . V 2  ]     =    v 2  ;", "vertices [ Batch . X 3  ]     =    x 2  ;", "vertices [ Batch . Y 3  ]     =    y 2  ;", "vertices [ Batch . C 3  ]     =    color ;", "vertices [ Batch . U 3  ]     =    u 2  ;", "vertices [ Batch . V 3  ]     =    v 2  ;", "vertices [ Batch . X 4  ]     =    x 2  ;", "vertices [ Batch . Y 4  ]     =    y 1  ;", "vertices [ Batch . C 4  ]     =    color ;", "vertices [ Batch . U 4  ]     =    u 2  ;", "vertices [ Batch . V 4  ]     =    v 1  ;", "if    ( flipX )     {", "float   temp    =    vertices [ Batch . U 1  ]  ;", "vertices [ Batch . U 1  ]     =    vertices [ Batch . U 3  ]  ;", "vertices [ Batch . U 3  ]     =    temp ;", "temp    =    vertices [ Batch . U 2  ]  ;", "vertices [ Batch . U 2  ]     =    vertices [ Batch . U 4  ]  ;", "vertices [ Batch . U 4  ]     =    temp ;", "}", "if    ( flipY )     {", "float   temp    =    vertices [ Batch . V 1  ]  ;", "vertices [ Batch . V 1  ]     =    vertices [ Batch . V 3  ]  ;", "vertices [ Batch . V 3  ]     =    temp ;", "temp    =    vertices [ Batch . V 2  ]  ;", "vertices [ Batch . V 2  ]     =    vertices [ Batch . V 4  ]  ;", "vertices [ Batch . V 4  ]     =    temp ;", "}", "if    ( rotations    =  =     2  )     {", "float   tempU    =    vertices [ Batch . U 1  ]  ;", "vertices [ Batch . U 1  ]     =    vertices [ Batch . U 3  ]  ;", "vertices [ Batch . U 3  ]     =    tempU ;", "tempU    =    vertices [ Batch . U 2  ]  ;", "vertices [ Batch . U 2  ]     =    vertices [ Batch . U 4  ]  ;", "vertices [ Batch . U 4  ]     =    tempU ;", "float   tempV    =    vertices [ Batch . V 1  ]  ;", "vertices [ Batch . V 1  ]     =    vertices [ Batch . V 3  ]  ;", "vertices [ Batch . V 3  ]     =    tempV ;", "tempV    =    vertices [ Batch . V 2  ]  ;", "vertices [ Batch . V 2  ]     =    vertices [ Batch . V 4  ]  ;", "vertices [ Batch . V 4  ]     =    tempV ;", "}", "batch . draw ( region . getTexture (  )  ,    vertices ,     0  ,    Batch . NUM _ VERTICES )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["renderCell"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.HexagonalTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "isoTransform    =    new   Matrix 4  (  )  ;", "isoTransform . idt (  )  ;", "isoTransform . scale (  (  ( float )     (  ( Math . sqrt (  2  .  0  )  )     /     2  .  0  )  )  ,     (  ( float )     (  ( Math . sqrt (  2  .  0  )  )     /     4  .  0  )  )  ,     1  .  0 F )  ;", "isoTransform . rotate (  0  .  0 F ,     0  .  0 F ,     1  .  0 F ,     (  -  4  5  )  )  ;", "invIsotransform    =    new   Matrix 4  ( isoTransform )  ;", "invIsotransform . inv (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.IsometricTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "screenPos . set ( vec . x ,    vec . y ,     0  )  ;", "screenPos . mul ( invtransform )  ;", "return   screenPos ;", "}", "METHOD_END"], "methodName": ["translateScreenToIso"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.IsometricTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "return   spriteCache ;", "}", "METHOD_END"], "methodName": ["getSpriteCache"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.OrthoCachedTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "cached    =    false ;", "}", "METHOD_END"], "methodName": ["invalidateCache"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.OrthoCachedTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "return   cached ;", "}", "METHOD_END"], "methodName": ["isCached"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.OrthoCachedTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "this . blending    =    blending ;", "}", "METHOD_END"], "methodName": ["setBlending"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.OrthoCachedTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "this . maxTileWidth    =    maxPixelWidth ;", "this . maxTileHeight    =    maxPixelHeight ;", "}", "METHOD_END"], "methodName": ["setMaxTileSize"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.OrthoCachedTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "this . overCache    =    overCache ;", "}", "METHOD_END"], "methodName": ["setOverCache"], "fileName": "com.badlogic.gdx.maps.tiled.renderers.OrthoCachedTiledMapRenderer"}, {"methodBody": ["METHOD_START", "{", "return   animationIntervals ;", "}", "METHOD_END"], "methodName": ["getAnimationIntervals"], "fileName": "com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile"}, {"methodBody": ["METHOD_START", "{", "return   frameTiles [ getCurrentFrameIndex (  )  ]  ;", "}", "METHOD_END"], "methodName": ["getCurrentFrame"], "fileName": "com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile"}, {"methodBody": ["METHOD_START", "{", "int   currentTime    =     (  ( int )     (  ( AnimatedTiledMapTile . lastTiledMapRenderTime )     %     ( loopDuration )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( animationIntervals . length )  ;     +  + i )     {", "int   animationInterval    =    animationIntervals [ i ]  ;", "if    ( currentTime    <  =    animationInterval )", "return   i ;", "currentTime    -  =    animationInterval ;", "}", "throw   new   GdxRuntimeException (  \" Could   not   determine   current   animation   frame   in   AnimatedTiledMapTile .       This   should   never   happen .  \"  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentFrameIndex"], "fileName": "com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile"}, {"methodBody": ["METHOD_START", "{", "return   frameTiles ;", "}", "METHOD_END"], "methodName": ["getFrameTiles"], "fileName": "com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile"}, {"methodBody": ["METHOD_START", "{", "if    (  ( intervals . length )     =  =     ( animationIntervals . length )  )     {", "this . animationIntervals    =    intervals ;", "loopDuration    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( intervals . length )  ;    i +  +  )     {", "loopDuration    +  =    intervals [ i ]  ;", "}", "} else    {", "throw   new   GdxRuntimeException (  (  (  (  (  \" Cannot   set    \"     +     ( intervals . length )  )     +     \"    frame   intervals .    The   given   int [  ]    must   have   a   size   of    \"  )     +     ( animationIntervals . length )  )     +     \"  .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAnimationIntervals"], "fileName": "com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile"}, {"methodBody": ["METHOD_START", "{", "AnimatedTiledMapTile . lastTiledMapRenderTime    =     ( TimeUtils . millis (  )  )     -     ( AnimatedTiledMapTile . initialTimeOffset )  ;", "}", "METHOD_END"], "methodName": ["updateAnimationBaseTime"], "fileName": "com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile"}, {"methodBody": ["METHOD_START", "{", "float   x    =    point . x ;", "float   y    =    point . y ;", "point . x    =     (  (  ( m 0  0  )     *    x )     +     (  ( m 0  1  )     *    y )  )     +     ( m 0  2  )  ;", "point . y    =     (  (  ( m 1  0  )     *    x )     +     (  ( m 1  1  )     *    y )  )     +     ( m 1  2  )  ;", "}", "METHOD_END"], "methodName": ["applyTo"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m 0  0  )     *     ( m 1  1  )  )     -     (  ( m 0  1  )     *     ( m 1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["det"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "position . x    =    m 0  2  ;", "position . y    =    m 1  2  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getTranslation"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =     1  ;", "m 0  1     =     0  ;", "m 0  2     =     0  ;", "m 1  0     =     0  ;", "m 1  1     =     1  ;", "m 1  2     =     0  ;", "return   is ;", "}", "METHOD_END"], "methodName": ["idt"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float   det    =    det (  )  ;", "if    ( det    =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" Can ' t   invert   a   singular   affine   matrix \"  )  ;", "float   invDet    =     1  .  0 F    /    det ;", "float   tmp 0  0     =    m 1  1  ;", "float   tmp 0  1     =     -  ( m 0  1  )  ;", "float   tmp 0  2     =     (  ( m 0  1  )     *     ( m 1  2  )  )     -     (  ( m 1  1  )     *     ( m 0  2  )  )  ;", "float   tmp 1  0     =     -  ( m 1  0  )  ;", "float   tmp 1  1     =    m 0  0  ;", "float   tmp 1  2     =     (  ( m 1  0  )     *     ( m 0  2  )  )     -     (  ( m 0  0  )     *     ( m 1  2  )  )  ;", "m 0  0     =    invDet    *    tmp 0  0  ;", "m 0  1     =    invDet    *    tmp 0  1  ;", "m 0  2     =    invDet    *    tmp 0  2  ;", "m 1  0     =    invDet    *    tmp 1  0  ;", "m 1  1     =    invDet    *    tmp 1  1  ;", "m 1  2     =    invDet    *    tmp 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["inv"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  ( m 0  0  )     =  =     1  )     &  &     (  ( m 0  2  )     =  =     0  )  )     &  &     (  ( m 1  2  )     =  =     0  )  )     &  &     (  ( m 1  1  )     =  =     1  )  )     &  &     (  ( m 0  1  )     =  =     0  )  )     &  &     (  ( m 1  0  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isIdt"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( m 0  0  )     =  =     1  )     &  &     (  ( m 1  1  )     =  =     1  )  )     &  &     (  ( m 0  1  )     =  =     0  )  )     &  &     (  ( m 1  0  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isTranslation"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float   tmp 0  0     =     (  ( m 0  0  )     *     ( other . m 0  0  )  )     +     (  ( m 0  1  )     *     ( other . m 1  0  )  )  ;", "float   tmp 0  1     =     (  ( m 0  0  )     *     ( other . m 0  1  )  )     +     (  ( m 0  1  )     *     ( other . m 1  1  )  )  ;", "float   tmp 0  2     =     (  (  ( m 0  0  )     *     ( other . m 0  2  )  )     +     (  ( m 0  1  )     *     ( other . m 1  2  )  )  )     +     ( m 0  2  )  ;", "float   tmp 1  0     =     (  ( m 1  0  )     *     ( other . m 0  0  )  )     +     (  ( m 1  1  )     *     ( other . m 1  0  )  )  ;", "float   tmp 1  1     =     (  ( m 1  0  )     *     ( other . m 0  1  )  )     +     (  ( m 1  1  )     *     ( other . m 1  1  )  )  ;", "float   tmp 1  2     =     (  (  ( m 1  0  )     *     ( other . m 0  2  )  )     +     (  ( m 1  1  )     *     ( other . m 1  2  )  )  )     +     ( m 1  2  )  ;", "m 0  0     =    tmp 0  0  ;", "m 0  1     =    tmp 0  1  ;", "m 0  2     =    tmp 0  2  ;", "m 1  0     =    tmp 1  0  ;", "m 1  1     =    tmp 1  1  ;", "m 1  2     =    tmp 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float   tmp 0  0     =     (  ( other . m 0  0  )     *     ( m 0  0  )  )     +     (  ( other . m 0  1  )     *     ( m 1  0  )  )  ;", "float   tmp 0  1     =     (  ( other . m 0  0  )     *     ( m 0  1  )  )     +     (  ( other . m 0  1  )     *     ( m 1  1  )  )  ;", "float   tmp 0  2     =     (  (  ( other . m 0  0  )     *     ( m 0  2  )  )     +     (  ( other . m 0  1  )     *     ( m 1  2  )  )  )     +     ( other . m 0  2  )  ;", "float   tmp 1  0     =     (  ( other . m 1  0  )     *     ( m 0  0  )  )     +     (  ( other . m 1  1  )     *     ( m 1  0  )  )  ;", "float   tmp 1  1     =     (  ( other . m 1  0  )     *     ( m 0  1  )  )     +     (  ( other . m 1  1  )     *     ( m 1  1  )  )  ;", "float   tmp 1  2     =     (  (  ( other . m 1  0  )     *     ( m 0  2  )  )     +     (  ( other . m 1  1  )     *     ( m 1  2  )  )  )     +     ( other . m 1  2  )  ;", "m 0  0     =    tmp 0  0  ;", "m 0  1     =    tmp 0  1  ;", "m 0  2     =    tmp 0  2  ;", "m 1  0     =    tmp 1  0  ;", "m 1  1     =    tmp 1  1  ;", "m 1  2     =    tmp 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["preMul"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )", "return   this ;", "float   cos    =    MUtils . cosDeg ( degrees )  ;", "float   sin    =    MUtils . sinDeg ( degrees )  ;", "float   tmp 0  0     =     ( cos    *     ( m 0  0  )  )     -     ( sin    *     ( m 1  0  )  )  ;", "float   tmp 0  1     =     ( cos    *     ( m 0  1  )  )     -     ( sin    *     ( m 1  1  )  )  ;", "float   tmp 0  2     =     ( cos    *     ( m 0  2  )  )     -     ( sin    *     ( m 1  2  )  )  ;", "float   tmp 1  0     =     ( sin    *     ( m 0  0  )  )     +     ( cos    *     ( m 1  0  )  )  ;", "float   tmp 1  1     =     ( sin    *     ( m 0  1  )  )     +     ( cos    *     ( m 1  1  )  )  ;", "float   tmp 1  2     =     ( sin    *     ( m 0  2  )  )     +     ( cos    *     ( m 1  2  )  )  ;", "m 0  0     =    tmp 0  0  ;", "m 0  1     =    tmp 0  1  ;", "m 0  2     =    tmp 0  2  ;", "m 1  0     =    tmp 1  0  ;", "m 1  1     =    tmp 1  1  ;", "m 1  2     =    tmp 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["preRotate"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )", "return   this ;", "float   cos    =    MUtils . cos ( radians )  ;", "float   sin    =    MUtils . sin ( radians )  ;", "float   tmp 0  0     =     ( cos    *     ( m 0  0  )  )     -     ( sin    *     ( m 1  0  )  )  ;", "float   tmp 0  1     =     ( cos    *     ( m 0  1  )  )     -     ( sin    *     ( m 1  1  )  )  ;", "float   tmp 0  2     =     ( cos    *     ( m 0  2  )  )     -     ( sin    *     ( m 1  2  )  )  ;", "float   tmp 1  0     =     ( sin    *     ( m 0  0  )  )     +     ( cos    *     ( m 1  0  )  )  ;", "float   tmp 1  1     =     ( sin    *     ( m 0  1  )  )     +     ( cos    *     ( m 1  1  )  )  ;", "float   tmp 1  2     =     ( sin    *     ( m 0  2  )  )     +     ( cos    *     ( m 1  2  )  )  ;", "m 0  0     =    tmp 0  0  ;", "m 0  1     =    tmp 0  1  ;", "m 0  2     =    tmp 0  2  ;", "m 1  0     =    tmp 1  0  ;", "m 1  1     =    tmp 1  1  ;", "m 1  2     =    tmp 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["preRotateRad"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   preScale ( scale . x ,    scale . y )  ;", "}", "METHOD_END"], "methodName": ["preScale"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     *  =    scaleX ;", "m 0  1     *  =    scaleX ;", "m 0  2     *  =    scaleX ;", "m 1  0     *  =    scaleY ;", "m 1  1     *  =    scaleY ;", "m 1  2     *  =    scaleY ;", "return   is ;", "}", "METHOD_END"], "methodName": ["preScale"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   preShear ( shear . x ,    shear . y )  ;", "}", "METHOD_END"], "methodName": ["preShear"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float   tmp 0  0     =     ( m 0  0  )     +     ( shearX    *     ( m 1  0  )  )  ;", "float   tmp 0  1     =     ( m 0  1  )     +     ( shearX    *     ( m 1  1  )  )  ;", "float   tmp 0  2     =     ( m 0  2  )     +     ( shearX    *     ( m 1  2  )  )  ;", "float   tmp 1  0     =     ( m 1  0  )     +     ( shearY    *     ( m 0  0  )  )  ;", "float   tmp 1  1     =     ( m 1  1  )     +     ( shearY    *     ( m 0  1  )  )  ;", "float   tmp 1  2     =     ( m 1  2  )     +     ( shearY    *     ( m 0  2  )  )  ;", "m 0  0     =    tmp 0  0  ;", "m 0  1     =    tmp 0  1  ;", "m 0  2     =    tmp 0  2  ;", "m 1  0     =    tmp 1  0  ;", "m 1  1     =    tmp 1  1  ;", "m 1  2     =    tmp 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["preShear"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   preTranslate ( trn . x ,    trn . y )  ;", "}", "METHOD_END"], "methodName": ["preTranslate"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  2     +  =    x ;", "m 1  2     +  =    y ;", "return   is ;", "}", "METHOD_END"], "methodName": ["preTranslate"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )", "return   this ;", "float   cos    =    MUtils . cosDeg ( degrees )  ;", "float   sin    =    MUtils . sinDeg ( degrees )  ;", "float   tmp 0  0     =     (  ( m 0  0  )     *    cos )     +     (  ( m 0  1  )     *    sin )  ;", "float   tmp 0  1     =     (  ( m 0  0  )     *     (  - sin )  )     +     (  ( m 0  1  )     *    cos )  ;", "float   tmp 1  0     =     (  ( m 1  0  )     *    cos )     +     (  ( m 1  1  )     *    sin )  ;", "float   tmp 1  1     =     (  ( m 1  0  )     *     (  - sin )  )     +     (  ( m 1  1  )     *    cos )  ;", "m 0  0     =    tmp 0  0  ;", "m 0  1     =    tmp 0  1  ;", "m 1  0     =    tmp 1  0  ;", "m 1  1     =    tmp 1  1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )", "return   this ;", "float   cos    =    MUtils . cos ( radians )  ;", "float   sin    =    MUtils . sin ( radians )  ;", "float   tmp 0  0     =     (  ( m 0  0  )     *    cos )     +     (  ( m 0  1  )     *    sin )  ;", "float   tmp 0  1     =     (  ( m 0  0  )     *     (  - sin )  )     +     (  ( m 0  1  )     *    cos )  ;", "float   tmp 1  0     =     (  ( m 1  0  )     *    cos )     +     (  ( m 1  1  )     *    sin )  ;", "float   tmp 1  1     =     (  ( m 1  0  )     *     (  - sin )  )     +     (  ( m 1  1  )     *    cos )  ;", "m 0  0     =    tmp 0  0  ;", "m 0  1     =    tmp 0  1  ;", "m 1  0     =    tmp 1  0  ;", "m 1  1     =    tmp 1  1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   scale ( scale . x ,    scale . y )  ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     *  =    scaleX ;", "m 0  1     *  =    scaleY ;", "m 1  0     *  =    scaleX ;", "m 1  1     *  =    scaleY ;", "return   is ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =    other . m 0  0  ;", "m 0  1     =    other . m 0  1  ;", "m 0  2     =    other . m 0  2  ;", "m 1  0     =    other . m 1  0  ;", "m 1  1     =    other . m 1  1  ;", "m 1  2     =    other . m 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float [  ]    other    =    matrix . val ;", "m 0  0     =    other [ Matrix 3  . M 0  0  ]  ;", "m 0  1     =    other [ Matrix 3  . M 0  1  ]  ;", "m 0  2     =    other [ Matrix 3  . M 0  2  ]  ;", "m 1  0     =    other [ Matrix 3  . M 1  0  ]  ;", "m 1  1     =    other [ Matrix 3  . M 1  1  ]  ;", "m 1  2     =    other [ Matrix 3  . M 1  2  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float [  ]    other    =    matrix . val ;", "m 0  0     =    other [ Matrix 4  . M 0  0  ]  ;", "m 0  1     =    other [ Matrix 4  . M 0  1  ]  ;", "m 0  2     =    other [ Matrix 4  . M 0  3  ]  ;", "m 1  0     =    other [ Matrix 4  . M 1  0  ]  ;", "m 1  1     =    other [ Matrix 4  . M 1  1  ]  ;", "m 1  2     =    other [ Matrix 4  . M 1  3  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =     (  ( l . m 0  0  )     *     ( r . m 0  0  )  )     +     (  ( l . m 0  1  )     *     ( r . m 1  0  )  )  ;", "m 0  1     =     (  ( l . m 0  0  )     *     ( r . m 0  1  )  )     +     (  ( l . m 0  1  )     *     ( r . m 1  1  )  )  ;", "m 0  2     =     (  (  ( l . m 0  0  )     *     ( r . m 0  2  )  )     +     (  ( l . m 0  1  )     *     ( r . m 1  2  )  )  )     +     ( l . m 0  2  )  ;", "m 1  0     =     (  ( l . m 1  0  )     *     ( r . m 0  0  )  )     +     (  ( l . m 1  1  )     *     ( r . m 1  0  )  )  ;", "m 1  1     =     (  ( l . m 1  0  )     *     ( r . m 0  1  )  )     +     (  ( l . m 1  1  )     *     ( r . m 1  1  )  )  ;", "m 1  2     =     (  (  ( l . m 1  0  )     *     ( r . m 0  2  )  )     +     (  ( l . m 1  1  )     *     ( r . m 1  2  )  )  )     +     ( l . m 1  2  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToProduct"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float   cos    =    MathUtils . cosDeg ( degrees )  ;", "float   sin    =    MathUtils . sinDeg ( degrees )  ;", "m 0  0     =    cos ;", "m 0  1     =     - sin ;", "m 0  2     =     0  ;", "m 1  0     =    sin ;", "m 1  1     =    cos ;", "m 1  2     =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =    cos ;", "m 0  1     =     - sin ;", "m 0  2     =     0  ;", "m 1  0     =    sin ;", "m 1  1     =    cos ;", "m 1  2     =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float   cos    =    MathUtils . cos ( radians )  ;", "float   sin    =    MathUtils . sin ( radians )  ;", "m 0  0     =    cos ;", "m 0  1     =     - sin ;", "m 0  2     =     0  ;", "m 1  0     =    sin ;", "m 1  1     =    cos ;", "m 1  2     =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToRotationRad"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   setToScaling ( scale . x ,    scale . y )  ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =    scaleX ;", "m 0  1     =     0  ;", "m 0  2     =     0  ;", "m 1  0     =     0  ;", "m 1  1     =    scaleY ;", "m 1  2     =     0  ;", "return   is ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   setToShearing ( shear . x ,    shear . y )  ;", "}", "METHOD_END"], "methodName": ["setToShearing"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =     1  ;", "m 0  1     =    shearX ;", "m 0  2     =     0  ;", "m 1  0     =    shearY ;", "m 1  1     =     1  ;", "m 1  2     =     0  ;", "return   is ;", "}", "METHOD_END"], "methodName": ["setToShearing"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   setToTranslation ( trn . x ,    trn . y )  ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =     1  ;", "m 0  1     =     0  ;", "m 0  2     =    x ;", "m 1  0     =     0  ;", "m 1  1     =     1  ;", "m 1  2     =    y ;", "return   is ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   setToTrnRotRadScl ( trn . x ,    trn . y ,    radians ,    scale . x ,    scale . y )  ;", "}", "METHOD_END"], "methodName": ["setToTrnRotRadScl"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  2     =    x ;", "m 1  2     =    y ;", "if    ( radians    =  =     0  )     {", "m 0  0     =    scaleX ;", "m 0  1     =     0  ;", "m 1  0     =     0  ;", "m 1  1     =    scaleY ;", "} else    {", "float   sin    =    MUtils . sin ( radians )  ;", "float   cos    =    MUtils . cos ( radians )  ;", "m 0  0     =    cos    *    scaleX ;", "m 0  1     =     (  - sin )     *    scaleY ;", "m 1  0     =    sin    *    scaleX ;", "m 1  1     =    cos    *    scaleY ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTrnRotRadScl"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   setToTrnRotScl ( trn . x ,    trn . y ,    degrees ,    scale . x ,    scale . y )  ;", "}", "METHOD_END"], "methodName": ["setToTrnRotScl"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  2     =    x ;", "m 1  2     =    y ;", "if    ( degrees    =  =     0  )     {", "m 0  0     =    scaleX ;", "m 0  1     =     0  ;", "m 1  0     =     0  ;", "m 1  1     =    scaleY ;", "} else    {", "float   sin    =    MUtils . sinDeg ( degrees )  ;", "float   cos    =    MUtils . cosDeg ( degrees )  ;", "m 0  0     =    cos    *    scaleX ;", "m 0  1     =     (  - sin )     *    scaleY ;", "m 1  0     =    sin    *    scaleX ;", "m 1  1     =    cos    *    scaleY ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTrnRotScl"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   setToTrnScl ( trn . x ,    trn . y ,    scale . x ,    scale . y )  ;", "}", "METHOD_END"], "methodName": ["setToTrnScl"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  0     =    scaleX ;", "m 0  1     =     0  ;", "m 0  2     =    x ;", "m 1  0     =     0  ;", "m 1  1     =    scaleY ;", "m 1  2     =    y ;", "return   is ;", "}", "METHOD_END"], "methodName": ["setToTrnScl"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   shear ( shear . x ,    shear . y )  ;", "}", "METHOD_END"], "methodName": ["shear"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "float   tmp 0     =     ( m 0  0  )     +     ( shearY    *     ( m 0  1  )  )  ;", "float   tmp 1     =     ( m 0  1  )     +     ( shearX    *     ( m 0  0  )  )  ;", "m 0  0     =    tmp 0  ;", "m 0  1     =    tmp 1  ;", "tmp 0     =     ( m 1  0  )     +     ( shearY    *     ( m 1  1  )  )  ;", "tmp 1     =     ( m 1  1  )     +     ( shearX    *     ( m 1  0  )  )  ;", "m 1  0     =    tmp 0  ;", "m 1  1     =    tmp 1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["shear"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "return   translate ( trn . x ,    trn . y )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "m 0  2     +  =     (  ( m 0  0  )     *    x )     +     (  ( m 0  1  )     *    y )  ;", "m 1  2     +  =     (  ( m 1  0  )     *    x )     +     (  ( m 1  1  )     *    y )  ;", "return   is ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Affine2"}, {"methodBody": ["METHOD_START", "{", "int   n    =    near ;", "final   T   nearest    =    knots . get ( n )  ;", "final   T   previous    =    knots . get (  ( n    >     0     ?    n    -     1     :     ( spanCount )     -     1  )  )  ;", "final   T   next    =    knots . get (  (  ( n    +     1  )     %     ( spanCount )  )  )  ;", "final   float   dstPrev 2     =    in . dst 2  ( previous )  ;", "final   float   dstNext 2     =    in . dst 2  ( next )  ;", "T   P 1  ;", "T   P 2  ;", "T   P 3  ;", "if    ( dstNext 2     <    dstPrev 2  )     {", "P 1     =    nearest ;", "P 2     =    next ;", "P 3     =    in ;", "} else    {", "P 1     =    previous ;", "P 2     =    nearest ;", "P 3     =    in ;", "n    =     ( n    >     0  )     ?    n    -     1     :     ( spanCount )     -     1  ;", "}", "float   L 1 Sqr    =    P 1  . dst 2  ( P 2  )  ;", "float   L 2 Sqr    =    P 3  . dst 2  ( P 2  )  ;", "float   L 3 Sqr    =    P 3  . dst 2  ( P 1  )  ;", "float   L 1     =     (  ( float )     ( Msqrt ( L 1 Sqr )  )  )  ;", "float   s    =     (  ( L 2 Sqr    +    L 1 Sqr )     -    L 3 Sqr )     /     (  2     *    L 1  )  ;", "float   u    =    Mtils . clamp (  (  ( L 1     -    s )     /    L 1  )  ,     0  .  0 F ,     1  .  0 F )  ;", "return    ( n    +    u )     /     ( spanCount )  ;", "}", "METHOD_END"], "methodName": ["approximate"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "return   approximate ( in ,    nearest ( in ,    start ,    count )  )  ;", "}", "METHOD_END"], "methodName": ["approximate"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =     ( continuous )     ?    points . length    :     ( points . length )     -    degree ;", "float   u    =    t    *    n ;", "int   i    =     ( t    >  =     1  .  0 F )     ?    n    -     1     :     (  ( int )     ( u )  )  ;", "u    -  =    i ;", "return    . calculate ( out ,    i ,    u ,    points ,    degree ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "switch    ( degree )     {", "case    3     :", "return    . cubic ( out ,    i ,    u ,    points ,    continuous ,    tmp )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =     ( continuous )     ?    points . length    :     ( points . length )     -     3  ;", "float   u    =    t    *    n ;", "int   i    =     ( t    >  =     1  .  0 F )     ?    n    -     1     :     (  ( int )     ( u )  )  ;", "u    -  =    i ;", "return    . cubic ( out ,    i ,    u ,    points ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["cubic"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    points . length ;", "final   float   dt    =     1  .  0 F    -    u ;", "final   float   t 2     =    u    *    u ;", "final   float   t 3     =    t 2     *    u ;", "out . set ( points [ i ]  )  . scl (  (  (  (  (  3  .  0 F    *    t 3  )     -     (  6  .  0 F    *    t 2  )  )     +     4  .  0 F )     *     (  . d 6  )  )  )  ;", "if    ( continuous    |  |     ( i    >     0  )  )", "out . add ( tmp . set ( points [  (  (  ( n    +    i )     -     1  )     %    n )  ]  )  . scl (  (  (  ( dt    *    dt )     *    dt )     *     (  . d 6  )  )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     1  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     1  )     %    n )  ]  )  . scl (  (  (  (  (  (  (  -  3  .  0 F )     *    t 3  )     +     (  3  .  0 F    *    t 2  )  )     +     (  3  .  0 F    *    u )  )     +     1  .  0 F )     *     (  . d 6  )  )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     2  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     2  )     %    n )  ]  )  . scl (  ( t 3     *     (  . d 6  )  )  )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["cubic"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =     ( continuous )     ?    points . length    :     ( points . length )     -     3  ;", "float   u    =    t    *    n ;", "int   i    =     ( t    >  =     1  .  0 F )     ?    n    -     1     :     (  ( int )     ( u )  )  ;", "u    -  =    i ;", "return    . cubic ( out ,    i ,    u ,    points ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["cubic_derivative"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    points . length ;", "final   float   dt    =     1  .  0 F    -    u ;", "final   float   t 2     =    u    *    u ;", "final   float   t 3     =    t 2     *    u ;", "out . set ( points [ i ]  )  . scl (  (  (  1  .  5 F    *    t 2  )     -     (  2     *    u )  )  )  ;", "if    ( continuous    |  |     ( i    >     0  )  )", "out . add ( tmp . set ( points [  (  (  ( n    +    i )     -     1  )     %    n )  ]  )  . scl (  (  (  (  -  0  .  5 F )     *    dt )     *    dt )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     1  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     1  )     %    n )  ]  )  . scl (  (  (  (  (  -  1  .  5 F )     *    t 2  )     +    u )     +     0  .  5 F )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     2  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     2  )     %    n )  ]  )  . scl (  (  0  .  5 F    *    t 2  )  )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["cubic_derivative"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =     ( continuous )     ?    points . length    :     ( points . length )     -    degree ;", "float   u    =    t    *    n ;", "int   i    =     ( t    >  =     1  .  0 F )     ?    n    -     1     :     (  ( int )     ( u )  )  ;", "u    -  =    i ;", "return    . derivative ( out ,    i ,    u ,    points ,    degree ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["derivative"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "switch    ( degree )     {", "case    3     :", "return    . cubic _ derivative ( out ,    i ,    u ,    points ,    continuous ,    tmp )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["derivative"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "return   BSpline . derivative ( out ,     ( continuous    ?    span    :    span    +     (  ( int )     (  ( degree )     *     0  .  5 F )  )  )  ,    u ,    controlPoints ,    degree ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["derivativeAt"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "return   nearest ( in ,     0  ,    spanCount )  ;", "}", "METHOD_END"], "methodName": ["nearest"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "while    ( start    <     0  )", "start    +  =    spanCount ;", "t   result    =    start    %     ( spanCount )  ;", "float   dst    =     . dst 2  ( knots . get ( result )  )  ;", "for    ( t   i    =     1  ;    i    <    count ;    i +  +  )     {", "fal   t   idx    =     ( start    +    i )     %     ( spanCount )  ;", "fal   float   d    =     . dst 2  ( knots . get ( idx )  )  ;", "if    ( d    <    dst )     {", "dst    =    d ;", "result    =    idx ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["nearest"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tmp )     =  =    null )", "tmp    =    controlPoints [  0  ]  . cpy (  )  ;", "if    (  ( tmp 2  )     =  =    null )", "tmp 2     =    controlPoints [  0  ]  . cpy (  )  ;", "if    (  ( tmp 3  )     =  =    null )", "tmp 3     =    controlPoints [  0  ]  . cpy (  )  ;", "this . controlPoints    =    controlPoints ;", "this . degree    =    degree ;", "this . continuous    =    continuous ;", "this . spanCount    =     ( continuous )     ?    controlPoints . length    :     ( controlPoints . length )     -    degree ;", "if    (  ( knots )     =  =    null )", "knots    =    new   utils . Array < T >  ( spanCount )  ;", "else    {", "knots . clear (  )  ;", "knots . ensureCapacity ( spanCount )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( spanCount )  ;    i +  +  )", "knots . add ( BSpline . calculate ( controlPoints [  0  ]  . cpy (  )  ,     ( continuous    ?    i    :     (  ( int )     ( i    +     (  0  .  5 F    *    degree )  )  )  )  ,     0  .  0 F ,    controlPoints ,    degree ,    continuous ,    tmp )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "return   BSpline . calculate ( out ,     ( continuous    ?    span    :    span    +     (  ( int )     (  ( degree )     *     0  .  5 F )  )  )  ,    u ,    controlPoints ,    degree ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["valueAt"], "fileName": "com.badlogic.gdx.math.BSpline"}, {"methodBody": ["METHOD_START", "{", "final   float   dt    =     1  .  0 F    -    t ;", "final   float   dt 2     =    dt    *    dt ;", "final   float   t 2     =    t    *    t ;", "return   out . set ( p 0  )  . scl (  ( dt 2     *    dt )  )  . add ( tmp . set ( p 1  )  . scl (  (  (  3     *    dt 2  )     *    t )  )  )  . add ( tmp . set ( p 2  )  . scl (  (  (  3     *    dt )     *    t 2  )  )  )  . add ( tmp . set ( p 3  )  . scl (  ( t 2     *    t )  )  )  ;", "}", "METHOD_END"], "methodName": ["cubic"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "final   float   dt    =     1  .  0 F    -    t ;", "final   float   dt 2     =    dt    *    dt ;", "final   float   t 2     =    t    *    t ;", "return   out . set ( p 1  )  . sub ( p 0  )  . scl (  ( dt 2     *     3  )  )  . add ( tmp . set ( p 2  )  . sub ( p 1  )  . scl (  (  ( dt    *    t )     *     6  )  )  )  . add ( tmp . set ( p 3  )  . sub ( p 2  )  . scl (  ( t 2     *     3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["cubic_derivative"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( p 0  )  . scl (  (  1  .  0 F    -    t )  )  . add ( tmp . set ( p 1  )  . scl ( t )  )  ;", "}", "METHOD_END"], "methodName": ["linear"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( p 1  )  . sub ( p 0  )  ;", "}", "METHOD_END"], "methodName": ["linear_derivative"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "final   float   dt    =     1  .  0 F    -    t ;", "return   out . set ( p 0  )  . scl (  ( dt    *    dt )  )  . add ( tmp . set ( p 1  )  . scl (  (  (  2     *    dt )     *    t )  )  )  . add ( tmp . set ( p 2  )  . scl (  ( t    *    t )  )  )  ;", "}", "METHOD_END"], "methodName": ["quadratic"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "final   float   dt    =     1  .  0 F    -    t ;", "return   out . set ( p 1  )  . sub ( p 0  )  . scl (  2  )  . scl (  (  1     -    t )  )  . add ( tmp . set ( p 2  )  . sub ( p 1  )  . scl ( t )  . scl (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["quadratic_derivative"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "return   set ( points ,     0  ,    points . length )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "if    (  ( length    <     2  )     |  |     ( length    >     4  )  )", "throw   new   utils . GdxRuntimeException (  \" Only   first ,    second   and   third   degree   Bezier   curves   are   supported .  \"  )  ;", "if    (  ( tmp )     =  =    null )", "tmp    =    points [  0  ]  . cpy (  )  ;", "if    (  ( tmp 2  )     =  =    null )", "tmp 2     =    points [  0  ]  . cpy (  )  ;", "if    (  ( tmp 3  )     =  =    null )", "tmp 3     =    points [  0  ]  . cpy (  )  ;", "this . points . clear (  )  ;", "this . points . addAll ( points ,    offset ,    length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "if    (  ( length    <     2  )     |  |     ( length    >     4  )  )", "throw   new   utils . GdxRuntimeException (  \" Only   first ,    second   and   third   degree   Bezier   curves   are   supported .  \"  )  ;", "if    (  ( tmp )     =  =    null )", "tmp    =    points . get (  0  )  . cpy (  )  ;", "if    (  ( tmp 2  )     =  =    null )", "tmp 2     =    points . get (  0  )  . cpy (  )  ;", "if    (  ( tmp 3  )     =  =    null )", "tmp 3     =    points . get (  0  )  . cpy (  )  ;", "this . points . clear (  )  ;", "this . points . addAll ( points ,    offset ,    length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Bezier"}, {"methodBody": ["METHOD_START", "{", "if    ( useSetter )     {", "bezier    =    new   Bezier < Vector 2  >  (  )  ;", "if    (  ( type )     =  =     (  . ImportType . LibGDXArrays )  )     {", "bezier . set ( new   Array < Vector 2  >  ( points )  ,     0  ,    points . length )  ;", "} else", "if    (  ( type )     =  =     (  . ImportType . JavaArrays )  )     {", "bezier . set ( points ,     0  ,    points . length )  ;", "} else    {", "bezier . set ( points )  ;", "}", "} else    {", "if    (  ( type )     =  =     (  . ImportType . LibGDXArrays )  )     {", "bezier    =    new   Bezier < Vector 2  >  ( new   Array < Vector 2  >  ( points )  ,     0  ,    points . length )  ;", "} else", "if    (  ( type )     =  =     (  . ImportType . JavaArrays )  )     {", "bezier    =    new   Bezier < Vector 2  >  ( points ,     0  ,    points . length )  ;", "} else    {", "bezier    =    new   Bezier < Vector 2  >  ( points )  ;", "}", "}", "return   points ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.math.BezierTest"}, {"methodBody": ["METHOD_START", "{", "Collection < Object [  ]  >    parameters    =    new   ArrayList < Object [  ]  >  (  )  ;", "for    (  . ImportType   type    :     . ImportType . values (  )  )     {", "parameters . add ( new   Object [  ]  {    type ,    true    }  )  ;", "parameters . add ( new   Object [  ]  {    type ,    false    }  )  ;", "}", "return   parameters ;", "}", "METHOD_END"], "methodName": ["parameters"], "fileName": "com.badlogic.gdx.math.BezierTest"}, {"methodBody": ["METHOD_START", "{", "bezier    =    null ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "com.badlogic.gdx.math.BezierTest"}, {"methodBody": ["METHOD_START", "{", "Vector 2  [  ]    points    =    create ( new   Vector 2  [  ]  {    new   Vector 2  (  0  ,     0  )  ,    new   Vector 2  (  1  ,     1  )     }  )  ;", "float   len    =    bezier . approxLength (  2  )  ;", "Assert . assertEquals ( Math . sqrt (  2  )  ,    len ,     . epsilonApprimations )  ;", "Vector 2    d    =    bezier . derivativeAt ( new   Vector 2  (  )  ,     0  .  5 F )  ;", "Assert . assertEquals (  1  ,    d . x ,     . epsilon )  ;", "Assert . assertEquals (  1  ,    d . y ,     . epsilon )  ;", "Vector 2    v    =    bezier . valueAt ( new   Vector 2  (  )  ,     0  .  5 F )  ;", "Assert . assertEquals (  0  .  5 F ,    v . x ,     . epsilon )  ;", "Assert . assertEquals (  0  .  5 F ,    v . y ,     . epsilon )  ;", "float   t    =    bezier . approximate ( new   Vector 2  (  0  .  5 F ,     0  .  5 F )  )  ;", "Assert . assertEquals (  0  .  5 F ,    t ,     . epsilonApprimations )  ;", "float   l    =    bezier . locate ( new   Vector 2  (  0  .  5 F ,     0  .  5 F )  )  ;", "Assert . assertEquals (  0  .  5 F ,    t ,     . epsilon )  ;", "}", "METHOD_END"], "methodName": ["testLinear2D"], "fileName": "com.badlogic.gdx.math.BezierTest"}, {"methodBody": ["METHOD_START", "{", "return   line ( start . x ,    start . y ,    end . x ,    end . y )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.math.Bresenham2"}, {"methodBody": ["METHOD_START", "{", "pool . freeAll ( points )  ;", "points . clear (  )  ;", "return   line ( startX ,    startY ,    endX ,    endY ,    pool ,    points )  ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.math.Bresenham2"}, {"methodBody": ["METHOD_START", "{", "int   w    =    endX    -    startX ;", "int   h    =    endY    -    startY ;", "int   dx 1     =     0  ;", "int   dy 1     =     0  ;", "int   dx 2     =     0  ;", "int   dy 2     =     0  ;", "if    ( w    <     0  )     {", "dx 1     =     -  1  ;", "dx 2     =     -  1  ;", "} else", "if    ( w    >     0  )     {", "dx 1     =     1  ;", "dx 2     =     1  ;", "}", "if    ( h    <     0  )", "dy 1     =     -  1  ;", "else", "if    ( h    >     0  )", "dy 1     =     1  ;", "int   longest    =    Mabs ( w )  ;", "int   shortest    =    Mabs ( h )  ;", "if    ( longest    <  =    shortest )     {", "longest    =    Mabs ( h )  ;", "shortest    =    Mabs ( w )  ;", "if    ( h    <     0  )", "dy 2     =     -  1  ;", "else", "if    ( h    >     0  )", "dy 2     =     1  ;", "dx 2     =     0  ;", "}", "int   numerator    =    longest    >  >     1  ;", "for    ( int   i    =     0  ;    i    <  =    longest ;    i +  +  )     {", "GridPoint 2    point    =    pool . obtain (  )  ;", "point . set ( startX ,    startY )  ;", "output . add ( point )  ;", "numerator    +  =    shortest ;", "if    ( numerator    >    longest )     {", "numerator    -  =    longest ;", "startX    +  =    dx 1  ;", "startY    +  =    dy 1  ;", "} else    {", "startX    +  =    dx 2  ;", "startY    +  =    dy 2  ;", "}", "}", "return   output ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.math.Bresenham2"}, {"methodBody": ["METHOD_START", "{", "int   n    =    near ;", "final   T   nearest    =    controlPoints [ n ]  ;", "final   T   previous    =    controlPoints [  ( n    >     0     ?    n    -     1     :     ( spanCount )     -     1  )  ]  ;", "final   T   next    =    controlPoints [  (  ( n    +     1  )     %     ( spanCount )  )  ]  ;", "final   float   dstPrev 2     =    in . dst 2  ( previous )  ;", "final   float   dstNext 2     =    in . dst 2  ( next )  ;", "T   P 1  ;", "T   P 2  ;", "T   P 3  ;", "if    ( dstNext 2     <    dstPrev 2  )     {", "P 1     =    nearest ;", "P 2     =    next ;", "P 3     =    in ;", "} else    {", "P 1     =    previous ;", "P 2     =    nearest ;", "P 3     =    in ;", "n    =     ( n    >     0  )     ?    n    -     1     :     ( spanCount )     -     1  ;", "}", "float   L 1 Sqr    =    P 1  . dst 2  ( P 2  )  ;", "float   L 2 Sqr    =    P 3  . dst 2  ( P 2  )  ;", "float   L 3 Sqr    =    P 3  . dst 2  ( P 1  )  ;", "float   L 1     =     (  ( float )     ( Msqrt ( L 1 Sqr )  )  )  ;", "float   s    =     (  ( L 2 Sqr    +    L 1 Sqr )     -    L 3 Sqr )     /     (  2  .  0 F    *    L 1  )  ;", "float   u    =    Mtils . clamp (  (  ( L 1     -    s )     /    L 1  )  ,     0  .  0 F ,     1  .  0 F )  ;", "return    ( n    +    u )     /     ( spanCount )  ;", "}", "METHOD_END"], "methodName": ["approximate"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "return   approximate ( in ,    nearest ( in ,    start ,    count )  )  ;", "}", "METHOD_END"], "methodName": ["approximate"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =     ( continuous )     ?    points . length    :     ( points . length )     -     3  ;", "float   u    =    t    *    n ;", "int   i    =     ( t    >  =     1  .  0 F )     ?    n    -     1     :     (  ( int )     ( u )  )  ;", "u    -  =    i ;", "return    . calculate ( out ,    i ,    u ,    points ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    points . length ;", "final   float   u 2     =    u    *    u ;", "final   float   u 3     =    u 2     *    u ;", "out . set ( points [ i ]  )  . scl (  (  (  (  1  .  5 F    *    u 3  )     -     (  2  .  5 F    *    u 2  )  )     +     1  .  0 F )  )  ;", "if    ( continuous    |  |     ( i    >     0  )  )", "out . add ( tmp . set ( points [  (  (  ( n    +    i )     -     1  )     %    n )  ]  )  . scl (  (  (  (  (  -  0  .  5 F )     *    u 3  )     +    u 2  )     -     (  0  .  5 F    *    u )  )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     1  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     1  )     %    n )  ]  )  . scl (  (  (  (  (  -  1  .  5 F )     *    u 3  )     +     (  2  .  0 F    *    u 2  )  )     +     (  0  .  5 F    *    u )  )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     2  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     2  )     %    n )  ]  )  . scl (  (  (  0  .  5 F    *    u 3  )     -     (  0  .  5 F    *    u 2  )  )  )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =     ( continuous )     ?    points . length    :     ( points . length )     -     3  ;", "float   u    =    t    *    n ;", "int   i    =     ( t    >  =     1  .  0 F )     ?    n    -     1     :     (  ( int )     ( u )  )  ;", "u    -  =    i ;", "return    . derivative ( out ,    i ,    u ,    points ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["derivative"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "final   int   n    =    points . length ;", "final   float   u 2     =    u    *    u ;", "out . set ( points [ i ]  )  . scl (  (  (  (  - u )     *     5  )     +     ( u 2     *     4  .  5 F )  )  )  ;", "if    ( continuous    |  |     ( i    >     0  )  )", "out . add ( tmp . set ( points [  (  (  ( n    +    i )     -     1  )     %    n )  ]  )  . scl (  (  (  (  -  0  .  5 F )     +     ( u    *     2  )  )     -     ( u 2     *     1  .  5 F )  )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     1  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     1  )     %    n )  ]  )  . scl (  (  (  0  .  5 F    +     ( u    *     4  )  )     -     ( u 2     *     4  .  5 F )  )  )  )  ;", "if    ( continuous    |  |     ( i    <     ( n    -     2  )  )  )", "out . add ( tmp . set ( points [  (  ( i    +     2  )     %    n )  ]  )  . scl (  (  (  - u )     +     ( u 2     *     1  .  5 F )  )  )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["derivative"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "return   CatmullRomSpline . derivative ( out ,     ( continuous    ?    span    :    span    +     1  )  ,    u ,    controlPoints ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["derivativeAt"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "return   nearest ( in ,     0  ,    spanCount )  ;", "}", "METHOD_END"], "methodName": ["nearest"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "while    ( start    <     0  )", "start    +  =    spanCount ;", "t   result    =    start    %     ( spanCount )  ;", "float   dst    =     . dst 2  ( controlPots [ result ]  )  ;", "for    ( t   i    =     1  ;    i    <    count ;    i +  +  )     {", "fal   t   idx    =     ( start    +    i )     %     ( spanCount )  ;", "fal   float   d    =     . dst 2  ( controlPots [ idx ]  )  ;", "if    ( d    <    dst )     {", "dst    =    d ;", "result    =    idx ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["nearest"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tmp )     =  =    null )", "tmp    =    controlPoints [  0  ]  . cpy (  )  ;", "if    (  ( tmp 2  )     =  =    null )", "tmp 2     =    controlPoints [  0  ]  . cpy (  )  ;", "if    (  ( tmp 3  )     =  =    null )", "tmp 3     =    controlPoints [  0  ]  . cpy (  )  ;", "this . controlPoints    =    controlPoints ;", "this . continuous    =    continuous ;", "this . spanCount    =     ( continuous )     ?    controlPoints . length    :     ( controlPoints . length )     -     3  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "return   CatmullRomSpline . calculate ( out ,     ( continuous    ?    span    :    span    +     1  )  ,    u ,    controlPoints ,    continuous ,    tmp )  ;", "}", "METHOD_END"], "methodName": ["valueAt"], "fileName": "com.badlogic.gdx.math.CatmullRomSpline"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . radius )     *     ( this . radius )  )     *     ( MathUtils . PI )  ;", "}", "METHOD_END"], "methodName": ["area"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "return    ( this . radius )     *     ( MathUtils . PI 2  )  ;", "}", "METHOD_END"], "methodName": ["circumference"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "final   float   radiusDiff    =     ( radius )     -     ( c . radius )  ;", "if    ( radiusDiff    <     0  .  0 F )", "return   false ;", "final   float   dx    =     ( x )     -     ( c . x )  ;", "final   float   dy    =     ( y )     -     ( c . y )  ;", "final   float   dst    =     ( dx    *    dx )     +     ( dy    *    dy )  ;", "final   float   radiusSum    =     ( radius )     +     ( c . radius )  ;", "return    (  !  (  ( radiusDiff    *    radiusDiff )     <    dst )  )     &  &     ( dst    <     ( radiusSum    *    radiusSum )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "float   dx    =     ( x )     -     ( point . x )  ;", "float   dy    =     ( y )     -     ( point . y )  ;", "return    (  ( dx    *    dx )     +     ( dy    *    dy )  )     <  =     (  ( radius )     *     ( radius )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "x    =     ( this . x )     -    x ;", "y    =     ( this . y )     -    y ;", "return    (  ( x    *    x )     +     ( y    *    y )  )     <  =     (  ( radius )     *     ( radius )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "float   dx    =     ( x )     -     ( c . x )  ;", "float   dy    =     ( y )     -     ( c . y )  ;", "float   distance    =     ( dx    *    dx )     +     ( dy    *    dy )  ;", "float   radiusSum    =     ( radius )     +     ( c . radius )  ;", "return   distance    <     ( radiusSum    *    radiusSum )  ;", "}", "METHOD_END"], "methodName": ["overlaps"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    circle . x ;", "this . y    =    circle . y ;", "this . radius    =    circle . radius ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    center . x ;", "this . y    =    center . y ;", "this . radius    =    Vector 2  . len (  (  ( center . x )     -     ( edge . x )  )  ,     (  ( center . y )     -     ( edge . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    position . x ;", "this . y    =    position . y ;", "this . radius    =    radius ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . radius    =    radius ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    position . x ;", "this . y    =    position . y ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . radius    =    radius ;", "}", "METHOD_END"], "methodName": ["setRadius"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "this . y    =    y ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.math.Circle"}, {"methodBody": ["METHOD_START", "{", "FloatArray   hull    =    this . hull ;", "int   size    =    hull . size ;", "float   p 1 x    =    hull . get (  ( size    -     4  )  )  ;", "float   p 1 y    =    hull . get (  ( size    -     3  )  )  ;", "float   p 2 x    =    hull . get (  ( size    -     2  )  )  ;", "float   p 2 y    =    hull . peek (  )  ;", "return    (  ( p 2 x    -    p 1 x )     *     ( p 3 y    -    p 1 y )  )     -     (  ( p 2 y    -    p 1 y )     *     ( p 3 x    -    p 1 x )  )  ;", "}", "METHOD_END"], "methodName": ["ccw"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "return   computeIndices ( points . items ,     0  ,    points . size ,    sorted ,    yDown )  ;", "}", "METHOD_END"], "methodName": ["computeIndices"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "return   computeIndices ( polygon ,     0  ,    polygon . length ,    sorted ,    yDown )  ;", "}", "METHOD_END"], "methodName": ["computeIndices"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "int   end    =    offset    +    count ;", "if    (  ! sorted )     {", "if    (  (  ( sortedPoints )     =  =    n )     |  |     (  ( sortedPoints . length )     <    count )  )", "sortedPoints    =    new   float [ count ]  ;", "System . arraycopy ( points ,    offset ,    sortedPoints ,     0  ,    count )  ;", "points    =    sortedPoints ;", "offset    =     0  ;", "sortWithIndices ( points ,    count ,    yDown )  ;", "}", "IntArray   indices    =    this . indices ;", "indices . clear (  )  ;", "FloatArray   h    =    this . h ;", "h . clear (  )  ;", "for    ( int   i    =    offset ,    index    =    i    /     2  ;    i    <    end ;    i    +  =     2     ,    index +  +  )     {", "float   x    =    points [ i ]  ;", "float   y    =    points [  ( i    +     1  )  ]  ;", "while    (  (  ( h . size )     >  =     4  )     &  &     (  ( ccw ( x ,    y )  )     <  =     0  )  )     {", "h . size    -  =     2  ;", "( indices . size )  -  -  ;", "}", "h . add ( x )  ;", "h . add ( y )  ;", "indices . add ( index )  ;", "}", "for    ( int   i    =    end    -     4  ,    index    =    i    /     2  ,    t    =     ( h . size )     +     2  ;    i    >  =    offset ;    i    -  =     2     ,    index -  -  )     {", "float   x    =    points [ i ]  ;", "float   y    =    points [  ( i    +     1  )  ]  ;", "while    (  (  ( h . size )     >  =    t )     &  &     (  ( ccw ( x ,    y )  )     <  =     0  )  )     {", "h . size    -  =     2  ;", "( indices . size )  -  -  ;", "}", "h . add ( x )  ;", "h . add ( y )  ;", "indices . add ( index )  ;", "}", "if    (  ! sorted )     {", "short [  ]    originalIndicesArray    =    originalIndices . items ;", "int [  ]    indicesArray    =    indices . items ;", "for    ( int   i    =     0  ,    n    =    indices . size ;    i    <    n ;    i +  +  )", "indicesArray [ i ]     =    originalIndicesArray [ indicesArray [ i ]  ]  ;", "}", "return   indices ;", "}", "METHOD_END"], "methodName": ["computeIndices"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "return   computePolygon ( points . items ,     0  ,    points . size ,    sorted )  ;", "}", "METHOD_END"], "methodName": ["computePolygon"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "return   computePolygon ( polygon ,     0  ,    polygon . length ,    sorted )  ;", "}", "METHOD_END"], "methodName": ["computePolygon"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "int   end    =    offset    +    count ;", "if    (  ! sorted )     {", "if    (  (  ( sortedPoints )     =  =    n )     |  |     (  ( sortedPoints . length )     <    count )  )", "sortedPoints    =    new   float [ count ]  ;", "System . arraycopy ( points ,    offset ,    sortedPoints ,     0  ,    count )  ;", "points    =    sortedPoints ;", "offset    =     0  ;", "sort ( points ,    count )  ;", "}", "FloatArray   h    =    this . h ;", "h . clear (  )  ;", "for    ( int   i    =    offset ;    i    <    end ;    i    +  =     2  )     {", "float   x    =    points [ i ]  ;", "float   y    =    points [  ( i    +     1  )  ]  ;", "while    (  (  ( h . size )     >  =     4  )     &  &     (  ( ccw ( x ,    y )  )     <  =     0  )  )", "h . size    -  =     2  ;", "h . add ( x )  ;", "h . add ( y )  ;", "}", "for    ( int   i    =    end    -     4  ,    t    =     ( h . size )     +     2  ;    i    >  =    offset ;    i    -  =     2  )     {", "float   x    =    points [ i ]  ;", "float   y    =    points [  ( i    +     1  )  ]  ;", "while    (  (  ( h . size )     >  =    t )     &  &     (  ( ccw ( x ,    y )  )     <  =     0  )  )", "h . size    -  =     2  ;", "h . add ( x )  ;", "h . add ( y )  ;", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["computePolygon"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "float   x    =    values [ lower ]  ;", "float   y    =    values [  ( lower    +     1  )  ]  ;", "int   up    =    upper ;", "int   down    =    lower ;", "float   temp ;", "short   tempIndex ;", "while    ( down    <    up )     {", "while    (  ( down    <    up )     &  &     (  ( values [ down ]  )     <  =    x )  )", "down    =    down    +     2  ;", "while    (  (  ( values [ up ]  )     >    x )     |  |     (  (  ( values [ up ]  )     =  =    x )     &  &     (  ( values [  ( up    +     1  )  ]  )     <    y )  )  )", "up    =    up    -     2  ;", "if    ( down    <    up )     {", "temp    =    values [ down ]  ;", "values [ down ]     =    values [ up ]  ;", "values [ up ]     =    temp ;", "temp    =    values [  ( down    +     1  )  ]  ;", "values [  ( down    +     1  )  ]     =    values [  ( up    +     1  )  ]  ;", "values [  ( up    +     1  )  ]     =    temp ;", "}", "}", "values [ lower ]     =    values [ up ]  ;", "values [ up ]     =    x ;", "values [  ( lower    +     1  )  ]     =    values [  ( up    +     1  )  ]  ;", "values [  ( up    +     1  )  ]     =    y ;", "return   up ;", "}", "METHOD_END"], "methodName": ["quicksortPartition"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "float   x    =    values [ lower ]  ;", "float   y    =    values [  ( lower    +     1  )  ]  ;", "int   up    =    upper ;", "int   down    =    lower ;", "float   temp ;", "short   tempIndex ;", "while    ( down    <    up )     {", "while    (  ( down    <    up )     &  &     (  ( values [ down ]  )     <  =    x )  )", "down    =    down    +     2  ;", "if    ( yDown )     {", "while    (  (  ( values [ up ]  )     >    x )     |  |     (  (  ( values [ up ]  )     =  =    x )     &  &     (  ( values [  ( up    +     1  )  ]  )     <    y )  )  )", "up    =    up    -     2  ;", "} else    {", "while    (  (  ( values [ up ]  )     >    x )     |  |     (  (  ( values [ up ]  )     =  =    x )     &  &     (  ( values [  ( up    +     1  )  ]  )     >    y )  )  )", "up    =    up    -     2  ;", "}", "if    ( down    <    up )     {", "temp    =    values [ down ]  ;", "values [ down ]     =    values [ up ]  ;", "values [ up ]     =    temp ;", "temp    =    values [  ( down    +     1  )  ]  ;", "values [  ( down    +     1  )  ]     =    values [  ( up    +     1  )  ]  ;", "values [  ( up    +     1  )  ]     =    temp ;", "tempIndex    =    originalIndices [  ( down    /     2  )  ]  ;", "originalIndices [  ( down    /     2  )  ]     =    originalIndices [  ( up    /     2  )  ]  ;", "originalIndices [  ( up    /     2  )  ]     =    tempIndex ;", "}", "}", "values [ lower ]     =    values [ up ]  ;", "values [ up ]     =    x ;", "values [  ( lower    +     1  )  ]     =    values [  ( up    +     1  )  ]  ;", "values [  ( up    +     1  )  ]     =    y ;", "tempIndex    =    originalIndices [  ( lower    /     2  )  ]  ;", "originalIndices [  ( lower    /     2  )  ]     =    originalIndices [  ( up    /     2  )  ]  ;", "originalIndices [  ( up    /     2  )  ]     =    tempIndex ;", "return   up ;", "}", "METHOD_END"], "methodName": ["quicksortPartitionWithIndices"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "int   lower    =     0  ;", "int   upper    =    count    -     1  ;", "IntArray   stack    =    quicksortStack ;", "stack . add ( lower )  ;", "stack . add (  ( upper    -     1  )  )  ;", "while    (  ( stack . size )     >     0  )     {", "upper    =    stack . pop (  )  ;", "lower    =    stack . pop (  )  ;", "if    ( upper    <  =    lower )", "continue ;", "int   i    =    quicksortPartition ( values ,    lower ,    upper )  ;", "if    (  ( i    -    lower )     >     ( upper    -    i )  )     {", "stack . add ( lower )  ;", "stack . add (  ( i    -     2  )  )  ;", "}", "stack . add (  ( i    +     2  )  )  ;", "stack . add ( upper )  ;", "if    (  ( upper    -    i )     >  =     ( i    -    lower )  )     {", "stack . add ( lower )  ;", "stack . add (  ( i    -     2  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "int   pointCount    =    count    /     2  ;", "originalIndices . clear (  )  ;", "originalIndices . ensureCapacity ( pointCount )  ;", "short [  ]    originalIndicesArray    =    originalIndices . items ;", "for    ( short   i    =     0  ;    i    <    pointCount ;    i +  +  )", "originalIndicesArray [ i ]     =    i ;", "int   lower    =     0  ;", "int   upper    =    count    -     1  ;", "IntArray   stack    =    quicksortStack ;", "stack . add ( lower )  ;", "stack . add (  ( upper    -     1  )  )  ;", "while    (  ( stack . size )     >     0  )     {", "upper    =    stack . pop (  )  ;", "lower    =    stack . pop (  )  ;", "if    ( upper    <  =    lower )", "continue ;", "int   i    =    quicksortPartitionWithIndices ( values ,    lower ,    upper ,    yDown ,    originalIndicesArray )  ;", "if    (  ( i    -    lower )     >     ( upper    -    i )  )     {", "stack . add ( lower )  ;", "stack . add (  ( i    -     2  )  )  ;", "}", "stack . add (  ( i    +     2  )  )  ;", "stack . add ( upper )  ;", "if    (  ( upper    -    i )     >  =     ( i    -    lower )  )     {", "stack . add ( lower )  ;", "stack . add (  ( i    -     2  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["sortWithIndices"], "fileName": "com.badlogic.gdx.math.ConvexHull"}, {"methodBody": ["METHOD_START", "{", "values . add ( new   CumulativeValue ( value ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "values . add ( new   CumulativeValue ( value ,     0  ,    intervalSize )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "values . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "float   sum    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( values . size )  ;     +  + i )     {", "sum    +  =    values . items [ i ]  . interval ;", "values . items [ i ]  . frequency    =    sum ;", "}", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "float   sum    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( values . size )  ;     +  + i )     {", "sum    +  =    values . items [ i ]  . interval ;", "}", "float   intervalSum    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( values . size )  ;     +  + i )     {", "intervalSum    +  =     ( values . items [ i ]  . interval )     /    sum ;", "values . items [ i ]  . frequency    =    intervalSum ;", "}", "}", "METHOD_END"], "methodName": ["generateNormalized"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "float   freq    =     1  .  0 F    /     ( values . size )  ;", "for    ( int   i    =     0  ;    i    <     ( values . size )  ;     +  + i )     {", "values . items [ i ]  . interval    =    freq ;", "values . items [ i ]  . frequency    =     ( i    +     1  )     *    freq ;", "}", "}", "METHOD_END"], "methodName": ["generateUniform"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "return   values . items [ index ]  . interval ;", "}", "METHOD_END"], "methodName": ["getInterval"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "return   values . items [ index ]  . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "for    ( CumulativeDistribution < T >  . CumulativeValue   value    :    values )", "if    (  ( value . value )     =  =    obj )     {", "value . interval    =    intervalSize ;", "return ;", "}", "}", "METHOD_END"], "methodName": ["setInterval"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "values . items [ index ]  . interval    =    intervalSize ;", "}", "METHOD_END"], "methodName": ["setInterval"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "return   values . size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "return   value ( MathUtils . random (  )  )  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "CumulativeDistribution < T >  . CumulativeValue   value    =    null ;", "int   imax    =     ( values . size )     -     1  ;", "int   imin    =     0  ;", "int   imid ;", "while    ( imin    <  =    imax )     {", "imid    =    imin    +     (  ( imax    -    imin )     /     2  )  ;", "value    =    values . items [ imid ]  ;", "if    ( probability    <     ( value . frequency )  )", "imax    =    imid    -     1  ;", "else", "if    ( probability    >     ( value . frequency )  )", "imin    =    imid    +     1  ;", "else", "break ;", "}", "return   values . items [ imin ]  . value ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.math.CumulativeDistribution"}, {"methodBody": ["METHOD_START", "{", "float   xc ;", "float   yc ;", "float   y 1 y 2     =    Math . abs (  ( y 1     -    y 2  )  )  ;", "float   y 2 y 3     =    Math . abs (  ( y 2     -    y 3  )  )  ;", "if    ( y 1 y 2     <     (  . EPSILON )  )     {", "if    ( y 2 y 3     <     (  . EPSILON )  )", "return    . INCOMPLETE ;", "float   m 2     =     (  -  ( x 3     -    x 2  )  )     /     ( y 3     -    y 2  )  ;", "float   mx 2     =     ( x 2     +    x 3  )     /     2  .  0 F ;", "float   my 2     =     ( y 2     +    y 3  )     /     2  .  0 F ;", "xc    =     ( x 2     +    x 1  )     /     2  .  0 F ;", "yc    =     ( m 2     *     ( xc    -    mx 2  )  )     +    my 2  ;", "} else    {", "float   m 1     =     (  -  ( x 2     -    x 1  )  )     /     ( y 2     -    y 1  )  ;", "float   mx 1     =     ( x 1     +    x 2  )     /     2  .  0 F ;", "float   my 1     =     ( y 1     +    y 2  )     /     2  .  0 F ;", "if    ( y 2 y 3     <     (  . EPSILON )  )     {", "xc    =     ( x 3     +    x 2  )     /     2  .  0 F ;", "yc    =     ( m 1     *     ( xc    -    mx 1  )  )     +    my 1  ;", "} else    {", "float   m 2     =     (  -  ( x 3     -    x 2  )  )     /     ( y 3     -    y 2  )  ;", "float   mx 2     =     ( x 2     +    x 3  )     /     2  .  0 F ;", "float   my 2     =     ( y 2     +    y 3  )     /     2  .  0 F ;", "xc    =     (  (  (  ( m 1     *    mx 1  )     -     ( m 2     *    mx 2  )  )     +    my 2  )     -    my 1  )     /     ( m 1     -    m 2  )  ;", "yc    =     ( m 1     *     ( xc    -    mx 1  )  )     +    my 1  ;", "}", "}", "float   dx    =    x 2     -    xc ;", "float   dy    =    y 2     -    yc ;", "float   rsqr    =     ( dx    *    dx )     +     ( dy    *    dy )  ;", "dx    =    xp    -    xc ;", "dx    *  =    dx ;", "dy    =    yp    -    yc ;", "if    (  (  ( dx    +     ( dy    *    dy )  )     -    rsqr )     <  =     (  . EPSILON )  )", "return    . INSIDE ;", "return    ( xp    >    xc )     &  &     ( dx    >    rsqr )     ?     . COMPLETE    :     . INCOMPLETE ;", "}", "METHOD_END"], "methodName": ["circumCircle"], "fileName": "com.badlogic.gdx.math.DelaunayTriangulator"}, {"methodBody": ["METHOD_START", "{", "return   computeTriangles ( points . items ,     0  ,    points . size ,    sorted )  ;", "}", "METHOD_END"], "methodName": ["computeTriangles"], "fileName": "com.badlogic.gdx.math.DelaunayTriangulator"}, {"methodBody": ["METHOD_START", "{", "return   computeTriangles ( polygon ,     0  ,    polygon . length ,    sorted )  ;", "}", "METHOD_END"], "methodName": ["computeTriangles"], "fileName": "com.badlogic.gdx.math.DelaunayTriangulator"}, {"methodBody": ["METHOD_START", "{", "ShortArray   triangles    =    this . triangles ;", "triangles . clear (  )  ;", "if    ( count    <     6  )", "return   triangles ;", "triangles . ensureCapacity ( count )  ;", "if    (  ! sorted )     {", "if    (  (  ( sortedPoints )     =  =    null )     |  |     (  ( sortedPoints . length )     <    count )  )", "sortedPoints    =    new   float [ count ]  ;", "System . arraycopy ( points ,    offset ,    sortedPoints ,     0  ,    count )  ;", "points    =    sortedPoints ;", "offset    =     0  ;", "sort ( points ,    count )  ;", "}", "int   end    =    offset    +    count ;", "float   xmin    =    points [  0  ]  ;", "float   ymin    =    points [  1  ]  ;", "float   xmax    =    xmin ;", "float   ymax    =    ymin ;", "for    ( int   i    =    offset    +     2  ;    i    <    end ;    i +  +  )     {", "float   value    =    points [ i ]  ;", "if    ( value    <    xmin )", "xmin    =    value ;", "if    ( value    >    xmax )", "xmax    =    value ;", "i +  +  ;", "value    =    points [ i ]  ;", "if    ( value    <    ymin )", "ymin    =    value ;", "if    ( value    >    ymax )", "ymax    =    value ;", "}", "float   dx    =    xmax    -    xmin ;", "float   dy    =    ymax    -    ymin ;", "float   dmax    =     ( dx    >    dy    ?    dx    :    dy )     *     2  0  .  0 F ;", "float   xmid    =     ( xmax    +    xmin )     /     2  .  0 F ;", "float   ymid    =     ( ymax    +    ymin )     /     2  .  0 F ;", "float [  ]    superTriangle    =    this . superTriangle ;", "superTriangle [  0  ]     =    xmid    -    dmax ;", "superTriangle [  1  ]     =    ymid    -    dmax ;", "superTriangle [  2  ]     =    xmid ;", "superTriangle [  3  ]     =    ymid    +    dmax ;", "superTriangle [  4  ]     =    xmid    +    dmax ;", "superTriangle [  5  ]     =    ymid    -    dmax ;", "IntArray   edges    =    this . edges ;", "edges . ensureCapacity (  ( count    /     2  )  )  ;", "BooleanArray   complete    =    this . complete ;", "complete . clear (  )  ;", "complete . ensureCapacity ( count )  ;", "triangles . add ( end )  ;", "triangles . add (  ( end    +     2  )  )  ;", "triangles . add (  ( end    +     4  )  )  ;", "complete . add ( false )  ;", "for    ( int   pointIndex    =    offset ;    pointIndex    <    end ;    pointIndex    +  =     2  )     {", "float   x    =    points [ pointIndex ]  ;", "float   y    =    points [  ( pointIndex    +     1  )  ]  ;", "short [  ]    trianglesArray    =    triangles . items ;", "boolean [  ]    completeArray    =    complete . items ;", "for    ( int   triangleIndex    =     ( triangles . size )     -     1  ;    triangleIndex    >  =     0  ;    triangleIndex    -  =     3  )     {", "int   completeIndex    =    triangleIndex    /     3  ;", "if    ( completeArray [ completeIndex ]  )", "continue ;", "int   p 1     =    trianglesArray [  ( triangleIndex    -     2  )  ]  ;", "int   p 2     =    trianglesArray [  ( triangleIndex    -     1  )  ]  ;", "int   p 3     =    trianglesArray [ triangleIndex ]  ;", "float   x 1  ;", "float   y 1  ;", "float   x 2  ;", "float   y 2  ;", "float   x 3  ;", "float   y 3  ;", "if    ( p 1     >  =    end )     {", "int   i    =    p 1     -    end ;", "x 1     =    superTriangle [ i ]  ;", "y 1     =    superTriangle [  ( i    +     1  )  ]  ;", "} else    {", "x 1     =    points [ p 1  ]  ;", "y 1     =    points [  ( p 1     +     1  )  ]  ;", "}", "if    ( p 2     >  =    end )     {", "int   i    =    p 2     -    end ;", "x 2     =    superTriangle [ i ]  ;", "y 2     =    superTriangle [  ( i    +     1  )  ]  ;", "} else    {", "x 2     =    points [ p 2  ]  ;", "y 2     =    points [  ( p 2     +     1  )  ]  ;", "}", "if    ( p 3     >  =    end )     {", "int   i    =    p 3     -    end ;", "x 3     =    superTriangle [ i ]  ;", "y 3     =    superTriangle [  ( i    +     1  )  ]  ;", "} else    {", "x 3     =    points [ p 3  ]  ;", "y 3     =    points [  ( p 3     +     1  )  ]  ;", "}", "switch    ( circumCircle ( x ,    y ,    x 1  ,    y 1  ,    x 2  ,    y 2  ,    x 3  ,    y 3  )  )     {", "case    . COMPLETE    :", "completeArray [ completeIndex ]     =    true ;", "break ;", "case    . INSIDE    :", "edges . add ( p 1  )  ;", "edges . add ( p 2  )  ;", "edges . add ( p 2  )  ;", "edges . add ( p 3  )  ;", "edges . add ( p 3  )  ;", "edges . add ( p 1  )  ;", "triangles . removeIndex ( triangleIndex )  ;", "triangles . removeIndex (  ( triangleIndex    -     1  )  )  ;", "triangles . removeIndex (  ( triangleIndex    -     2  )  )  ;", "complete . removeIndex ( completeIndex )  ;", "break ;", "}", "}", "int [  ]    edgesArray    =    edges . items ;", "for    ( int   i    =     0  ,    n    =    edges . size ;    i    <    n ;    i    +  =     2  )     {", "int   p 1     =    edgesArray [ i ]  ;", "if    ( p 1     =  =     (  -  1  )  )", "continue ;", "int   p 2     =    edgesArray [  ( i    +     1  )  ]  ;", "boolean   skip    =    false ;", "for    ( int   ii    =    i    +     2  ;    ii    <    n ;    ii    +  =     2  )     {", "if    (  ( p 1     =  =     ( edgesArray [  ( ii    +     1  )  ]  )  )     &  &     ( p 2     =  =     ( edgesArray [ ii ]  )  )  )     {", "skip    =    true ;", "edgesArray [ ii ]     =     -  1  ;", "}", "}", "if    ( skip )", "continue ;", "triangles . add ( p 1  )  ;", "triangles . add ( edgesArray [  ( i    +     1  )  ]  )  ;", "triangles . add ( pointIndex )  ;", "complete . add ( false )  ;", "}", "edges . clear (  )  ;", "}", "short [  ]    trianglesArray    =    triangles . items ;", "for    ( int   i    =     ( triangles . size )     -     1  ;    i    >  =     0  ;    i    -  =     3  )     {", "if    (  (  (  ( trianglesArray [ i ]  )     >  =    end )     |  |     (  ( trianglesArray [  ( i    -     1  )  ]  )     >  =    end )  )     |  |     (  ( trianglesArray [  ( i    -     2  )  ]  )     >  =    end )  )     {", "triangles . removeIndex ( i )  ;", "triangles . removeIndex (  ( i    -     1  )  )  ;", "triangles . removeIndex (  ( i    -     2  )  )  ;", "}", "}", "if    (  ! sorted )     {", "short [  ]    originalIndicesArray    =    originalIndices . items ;", "for    ( int   i    =     0  ,    n    =    triangles . size ;    i    <    n ;    i +  +  )", "trianglesArray [ i ]     =     (  ( short )     (  ( originalIndicesArray [  (  ( trianglesArray [ i ]  )     /     2  )  ]  )     *     2  )  )  ;", "}", "if    ( offset    =  =     0  )     {", "for    ( int   i    =     0  ,    n    =    triangles . size ;    i    <    n ;    i +  +  )", "trianglesArray [ i ]     =     (  ( short )     (  ( trianglesArray [ i ]  )     /     2  )  )  ;", "} else    {", "for    ( int   i    =     0  ,    n    =    triangles . size ;    i    <    n ;    i +  +  )", "trianglesArray [ i ]     =     (  ( short )     (  (  ( trianglesArray [ i ]  )     -    offset )     /     2  )  )  ;", "}", "return   triangles ;", "}", "METHOD_END"], "methodName": ["computeTriangles"], "fileName": "com.badlogic.gdx.math.DelaunayTriangulator"}, {"methodBody": ["METHOD_START", "{", "float   value    =    values [ lower ]  ;", "int   up    =    upper ;", "int   down    =    lower    +     2  ;", "float   tempValue ;", "short   tempIndex ;", "while    ( down    <    up )     {", "while    (  ( down    <    up )     &  &     (  ( values [ down ]  )     <  =    value )  )", "down    =    down    +     2  ;", "while    (  ( values [ up ]  )     >    value )", "up    =    up    -     2  ;", "if    ( down    <    up )     {", "tempValue    =    values [ down ]  ;", "values [ down ]     =    values [ up ]  ;", "values [ up ]     =    tempValue ;", "tempValue    =    values [  ( down    +     1  )  ]  ;", "values [  ( down    +     1  )  ]     =    values [  ( up    +     1  )  ]  ;", "values [  ( up    +     1  )  ]     =    tempValue ;", "tempIndex    =    originalIndices [  ( down    /     2  )  ]  ;", "originalIndices [  ( down    /     2  )  ]     =    originalIndices [  ( up    /     2  )  ]  ;", "originalIndices [  ( up    /     2  )  ]     =    tempIndex ;", "}", "}", "values [ lower ]     =    values [ up ]  ;", "values [ up ]     =    value ;", "tempValue    =    values [  ( lower    +     1  )  ]  ;", "values [  ( lower    +     1  )  ]     =    values [  ( up    +     1  )  ]  ;", "values [  ( up    +     1  )  ]     =    tempValue ;", "tempIndex    =    originalIndices [  ( lower    /     2  )  ]  ;", "originalIndices [  ( lower    /     2  )  ]     =    originalIndices [  ( up    /     2  )  ]  ;", "originalIndices [  ( up    /     2  )  ]     =    tempIndex ;", "return   up ;", "}", "METHOD_END"], "methodName": ["quicksortPartition"], "fileName": "com.badlogic.gdx.math.DelaunayTriangulator"}, {"methodBody": ["METHOD_START", "{", "int   pointCount    =    count    /     2  ;", "originalIndices . clear (  )  ;", "originalIndices . ensureCapacity ( pointCount )  ;", "short [  ]    originalIndicesArray    =    originalIndices . items ;", "for    ( short   i    =     0  ;    i    <    pointCount ;    i +  +  )", "originalIndicesArray [ i ]     =    i ;", "int   lower    =     0  ;", "int   upper    =    count    -     1  ;", "IntArray   stack    =    quicksortStack ;", "stack . add ( lower )  ;", "stack . add (  ( upper    -     1  )  )  ;", "while    (  ( stack . size )     >     0  )     {", "upper    =    stack . pop (  )  ;", "lower    =    stack . pop (  )  ;", "if    ( upper    <  =    lower )", "continue ;", "int   i    =    quicksortPartition ( values ,    lower ,    upper ,    originalIndicesArray )  ;", "if    (  ( i    -    lower )     >     ( upper    -    i )  )     {", "stack . add ( lower )  ;", "stack . add (  ( i    -     2  )  )  ;", "}", "stack . add (  ( i    +     2  )  )  ;", "stack . add ( upper )  ;", "if    (  ( upper    -    i )     >  =     ( i    -    lower )  )     {", "stack . add ( lower )  ;", "stack . add (  ( i    -     2  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.math.DelaunayTriangulator"}, {"methodBody": ["METHOD_START", "{", "short [  ]    trianglesArray    =    triangles . items ;", "for    ( int   i    =     ( triangles . size )     -     1  ;    i    >  =     0  ;    i    -  =     3  )     {", "int   p 1     =     ( trianglesArray [  ( i    -     2  )  ]  )     *     2  ;", "int   p 2     =     ( trianglesArray [  ( i    -     1  )  ]  )     *     2  ;", "int   p 3     =     ( trianglesArray [ i ]  )     *     2  ;", "GeometryUtils . triangleCentroid ( points [ p 1  ]  ,    points [  ( p 1     +     1  )  ]  ,    points [ p 2  ]  ,    points [  ( p 2     +     1  )  ]  ,    points [ p 3  ]  ,    points [  ( p 3     +     1  )  ]  ,    centroid )  ;", "if    (  !  ( Intersector . isPointInPolygon ( hull ,    offset ,    count ,    centroid . x ,    centroid . y )  )  )     {", "triangles . removeIndex ( i )  ;", "triangles . removeIndex (  ( i    -     1  )  )  ;", "triangles . removeIndex (  ( i    -     2  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["trim"], "fileName": "com.badlogic.gdx.math.DelaunayTriangulator"}, {"methodBody": ["METHOD_START", "{", "if    ( count    <  =     2  )", "return   false ;", "float   area    =     0  ;", "float   p 1 x ;", "float   p 1 y ;", "float   p 2 x ;", "float   p 2 y ;", "for    ( int   i    =    offset ,    n    =     ( offset    +    count )     -     3  ;    i    <    n ;    i    +  =     2  )     {", "p 1 x    =    vertices [ i ]  ;", "p 1 y    =    vertices [  ( i    +     1  )  ]  ;", "p 2 x    =    vertices [  ( i    +     2  )  ]  ;", "p 2 y    =    vertices [  ( i    +     3  )  ]  ;", "area    +  =     ( p 1 x    *    p 2 y )     -     ( p 2 x    *    p 1 y )  ;", "}", "p 1 x    =    vertices [  (  ( offset    +    count )     -     2  )  ]  ;", "p 1 y    =    vertices [  (  ( offset    +    count )     -     1  )  ]  ;", "p 2 x    =    vertices [ offset ]  ;", "p 2 y    =    vertices [  ( offset    +     1  )  ]  ;", "return    (  ( area    +     ( p 1 x    *    p 2 y )  )     -     ( p 2 x    *    p 1 y )  )     <     0  ;", "}", "METHOD_END"], "methodName": ["areVerticesClockwise"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "short [  ]    indices    =    this . indices ;", "int   previous    =     ( indices [ previousIndex ( index )  ]  )     *     2  ;", "int   current    =     ( indices [ index ]  )     *     2  ;", "int   next    =     ( indices [ nextIndex ( index )  ]  )     *     2  ;", "float [  ]    vertices    =    this . vertices ;", "return    . computeSpannedAreaSign ( vertices [ previous ]  ,    vertices [  ( previous    +     1  )  ]  ,    vertices [ current ]  ,    vertices [  ( current    +     1  )  ]  ,    vertices [ next ]  ,    vertices [  ( next    +     1  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["classifyVertex"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "float   area    =    p 1 x    *     ( p 3 y    -    p 2 y )  ;", "area    +  =    p 2 x    *     ( p 1 y    -    p 3 y )  ;", "area    +  =    p 3 x    *     ( p 2 y    -    p 1 y )  ;", "return    (  ( int )     ( Msignum ( area )  )  )  ;", "}", "METHOD_END"], "methodName": ["computeSpannedAreaSign"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "return   computeTriangles ( vertices . items ,     0  ,    vertices . size )  ;", "}", "METHOD_END"], "methodName": ["computeTriangles"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "return   computeTriangles ( vertices ,     0  ,    vertices . length )  ;", "}", "METHOD_END"], "methodName": ["computeTriangles"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "this . vertices    =    vertices ;", "int   vertexCount    =    this . vertexCount    =    count    /     2  ;", "int   vertexOffset    =    offset    /     2  ;", "ShortArray   indicesArray    =    this . indicesArray ;", "indicesArray . clear (  )  ;", "indicesArray . ensureCapacity ( vertexCount )  ;", "indicesArray . size    =    vertexCount ;", "short [  ]    indices    =    this . indices    =    indicesArray . items ;", "if    (  . areVerticesClockwise ( vertices ,    offset ,    count )  )     {", "for    ( short   i    =     0  ;    i    <    vertexCount ;    i +  +  )", "indices [ i ]     =     (  ( short )     ( vertexOffset    +    i )  )  ;", "} else    {", "for    ( int   i    =     0  ,    n    =    vertexCount    -     1  ;    i    <    vertexCount ;    i +  +  )", "indices [ i ]     =     (  ( short )     (  ( vertexOffset    +    n )     -    i )  )  ;", "}", "IntArray   vertexTypes    =    this . vertexTypes ;", "vertexTypes . clear (  )  ;", "vertexTypes . ensureCapacity ( vertexCount )  ;", "for    ( int   i    =     0  ,    n    =    vertexCount ;    i    <    n ;     +  + i )", "vertexTypes . add ( classifyVertex ( i )  )  ;", "ShortArray   triangles    =    this . triangles ;", "triangles . clear (  )  ;", "triangles . ensureCapacity (  (  ( Math . max (  0  ,     ( vertexCount    -     2  )  )  )     *     3  )  )  ;", "triangulate (  )  ;", "return   triangles ;", "}", "METHOD_END"], "methodName": ["computeTriangles"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "short [  ]    indices    =    this . indices ;", "ShortArray   tles    =    this . tles ;", "tles . add ( indices [ previousIndex ( earTipIndex )  ]  )  ;", "tles . add ( indices [ earTipIndex ]  )  ;", "tles . add ( indices [ nextIndex ( earTipIndex )  ]  )  ;", "indicesArray . removeIndex ( earTipIndex )  ;", "vertexTypes . removeIndex ( earTipIndex )  ;", "( vertexCount )  -  -  ;", "}", "METHOD_END"], "methodName": ["cutEarTip"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "int   vertexCount    =    this . vertexCount ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )", "if    ( isEarTip ( i )  )", "return   i ;", "int [  ]    vertexTypes    =    this . vertexTypes . items ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )", "if    (  ( vertexTypes [ i ]  )     !  =     (  . CONCAVE )  )", "return   i ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["findEarTip"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "int [  ]    vertexTypes    =    this . vertexTypes . items ;", "if    (  ( vertexTypes [ earTipIndex ]  )     =  =     (  . CONCAVE )  )", "return   false ;", "int   previousIndex    =    previousIndex ( earTipIndex )  ;", "int   nextIndex    =    nextIndex ( earTipIndex )  ;", "short [  ]    indices    =    this . indices ;", "int   p 1     =     ( indices [ previousIndex ]  )     *     2  ;", "int   p 2     =     ( indices [ earTipIndex ]  )     *     2  ;", "int   p 3     =     ( indices [ nextIndex ]  )     *     2  ;", "float [  ]    vertices    =    this . vertices ;", "float   p 1 x    =    vertices [ p 1  ]  ;", "float   p 1 y    =    vertices [  ( p 1     +     1  )  ]  ;", "float   p 2 x    =    vertices [ p 2  ]  ;", "float   p 2 y    =    vertices [  ( p 2     +     1  )  ]  ;", "float   p 3 x    =    vertices [ p 3  ]  ;", "float   p 3 y    =    vertices [  ( p 3     +     1  )  ]  ;", "for    ( int   i    =    nextIndex ( nextIndex )  ;    i    !  =    previousIndex ;    i    =    nextIndex ( i )  )     {", "if    (  ( vertexTypes [ i ]  )     !  =     (  . CONVEX )  )     {", "int   v    =     ( indices [ i ]  )     *     2  ;", "float   vx    =    vertices [ v ]  ;", "float   vy    =    vertices [  ( v    +     1  )  ]  ;", "if    (  (  . computeSpannedAreaSign ( p 3 x ,    p 3 y ,    p 1 x ,    p 1 y ,    vx ,    vy )  )     >  =     0  )     {", "if    (  (  . computeSpannedAreaSign ( p 1 x ,    p 1 y ,    p 2 x ,    p 2 y ,    vx ,    vy )  )     >  =     0  )     {", "if    (  (  . computeSpannedAreaSign ( p 2 x ,    p 2 y ,    p 3 x ,    p 3 y ,    vx ,    vy )  )     >  =     0  )", "return   false ;", "}", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isEarTip"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "return    ( index    +     1  )     %     ( vertexCount )  ;", "}", "METHOD_END"], "methodName": ["nextIndex"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "return    ( index    =  =     0     ?    vertexCount    :    index )     -     1  ;", "}", "METHOD_END"], "methodName": ["previousIndex"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "int [  ]    vertexTypes    =    this . vertexTypes . items ;", "while    (  ( vertexCount )     >     3  )     {", "int   earTipIndex    =    findEarTip (  )  ;", "cutEarTip ( earTipIndex )  ;", "int   previousIndex    =    previousIndex ( earTipIndex )  ;", "int   nextIndex    =     ( earTipIndex    =  =     ( vertexCount )  )     ?     0     :    earTipIndex ;", "vertexTypes [ previousIndex ]     =    classifyVertex ( previousIndex )  ;", "vertexTypes [ nextIndex ]     =    classifyVertex ( nextIndex )  ;", "}", "if    (  ( vertexCount )     =  =     3  )     {", "ShortArray   tles    =    this . tles ;", "short [  ]    indices    =    this . indices ;", "tles . add ( indices [  0  ]  )  ;", "tles . add ( indices [  1  ]  )  ;", "tles . add ( indices [  2  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["triangulate"], "fileName": "com.badlogic.gdx.math.EarClippingTriangulator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( MathUtils . PI )     *     (  ( this . width )     *     ( this . height )  )  )     /     4  ;", "}", "METHOD_END"], "methodName": ["area"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "float   a    =     ( this . width )     /     2  ;", "float   b    =     ( this . height )     /     2  ;", "if    (  (  ( a    *     3  )     >    b )     |  |     (  ( b    *     3  )     >    a )  )     {", "return    (  ( float )     (  ( Mtils . PI )     *     (  (  3     *     ( a    +    b )  )     -     ( Msqrt (  (  (  (  3     *    a )     +    b )     *     ( a    +     (  3     *    b )  )  )  )  )  )  )  )  ;", "} else    {", "return    (  ( float )     (  ( Mtils . PI 2  )     *     ( Msqrt (  (  (  ( a    *    a )     +     ( b    *    b )  )     /     2  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["circumference"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "return   contains ( point . x ,    point . y )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "x    =    x    -     ( this . x )  ;", "y    =    y    -     ( this . y )  ;", "return    (  (  ( x    *    x )     /     (  (  (  ( width )     *     0  .  5 F )     *     ( width )  )     *     0  .  5 F )  )     +     (  ( y    *    y )     /     (  (  (  ( height )     *     0  .  5 F )     *     ( height )  )     *     0  .  5 F )  )  )     <  =     1  .  0 F ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "this . x    =    circle . x ;", "this . y    =    circle . y ;", "this . width    =    circle . radius ;", "this . height    =    circle . radius ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "x    =    ellipse . x ;", "y    =    ellipse . y ;", "width    =    ellipse . width ;", "height    =    ellipse . height ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "this . x    =    position . x ;", "this . y    =    position . y ;", "this . width    =    size . x ;", "this . height    =    size . y ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . width    =    width ;", "this . height    =    height ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "this . x    =    position . x ;", "this . y    =    position . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "this . height    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.math.Ellipse"}, {"methodBody": ["METHOD_START", "{", "latest    =    value ;", "total    +  =    value ;", "( c )  +  +  ;", "average    =     ( total )     /     ( c )  ;", "if    (  ( mean )     !  =    null )     {", "mean . addValue ( value )  ;", "this . value    =    mean . getMean (  )  ;", "} else", "this . value    =    latest ;", "if    (  (  ( mean )     =  =    null )     |  |     ( mean . hasEnoughData (  )  )  )     {", "if    (  ( this . value )     <     ( min )  )", "min    =    this . value ;", "if    (  ( this . value )     >     ( max )  )", "max    =    this . value ;", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.math.FloatCounter"}, {"methodBody": ["METHOD_START", "{", "count    =     0  ;", "total    =     0  .  0 F ;", "min    =     . MAX _ VALUE ;", "max    =     . MIN _ VALUE ;", "average    =     0  .  0 F ;", "latest    =     0  .  0 F ;", "value    =     0  .  0 F ;", "if    (  ( mean )     !  =    null )", "mean . clear (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.math.FloatCounter"}, {"methodBody": ["METHOD_START", "{", "return   boundsInFrustum ( center . x ,    center . y ,    center . z ,     (  ( dimensions . x )     /     2  )  ,     (  ( dimensions . y )     /     2  )  ,     (  ( dimensions . z )     /     2  )  )  ;", "}", "METHOD_END"], "methodName": ["boundsInFrustum"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    len 2     =    planes . length ;    i    <    len 2  ;    i +  +  )     {", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 0  0  0  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 0  0  1  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 0  1  0  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 0  1  1  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 1  0  0  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 1  0  1  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 1  1  0  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint ( bounds . getCorner 1  1  1  (  . tmpV )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["boundsInFrustum"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    len 2     =    planes . length ;    i    <    len 2  ;    i +  +  )     {", "if    (  ( planes [ i ]  . testPoint (  ( x    +    halfWidth )  ,     ( y    +    halfHeight )  ,     ( z    +    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint (  ( x    +    halfWidth )  ,     ( y    +    halfHeight )  ,     ( z    -    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint (  ( x    +    halfWidth )  ,     ( y    -    halfHeight )  ,     ( z    +    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint (  ( x    +    halfWidth )  ,     ( y    -    halfHeight )  ,     ( z    -    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint (  ( x    -    halfWidth )  ,     ( y    +    halfHeight )  ,     ( z    +    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint (  ( x    -    halfWidth )  ,     ( y    +    halfHeight )  ,     ( z    -    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint (  ( x    -    halfWidth )  ,     ( y    -    halfHeight )  ,     ( z    +    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "if    (  ( planes [ i ]  . testPoint (  ( x    -    halfWidth )  ,     ( y    -    halfHeight )  ,     ( z    -    halfDepth )  )  )     !  =     ( Plane . PlaneSide . Back )  )", "continue ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["boundsInFrustum"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( planes . length )  ;    i +  +  )     {", "Plane . PlaneSide   result    =    planes [ i ]  . testPoint ( point )  ;", "if    ( result    =  =     ( Plane . PlaneSide . Back )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["pointInFrustum"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( planes . length )  ;    i +  +  )     {", "Plane . PlaneSide   result    =    planes [ i ]  . testPoint ( x ,    y ,    z )  ;", "if    ( result    =  =     ( Plane . PlaneSide . Back )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["pointInFrustum"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     6  ;    i +  +  )", "if    (  (  (  (  ( planes [ i ]  . normal . x )     *     ( center . x )  )     +     (  ( planes [ i ]  . normal . y )     *     ( center . y )  )  )     +     (  ( planes [ i ]  . normal . z )     *     ( center . z )  )  )     <     (  (  - rius )     -     ( planes [ i ]  . d )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["sphereInFrustum"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     6  ;    i +  +  )", "if    (  (  (  (  ( planes [ i ]  . normal . x )     *    x )     +     (  ( planes [ i ]  . normal . y )     *    y )  )     +     (  ( planes [ i ]  . normal . z )     *    z )  )     <     (  (  - rius )     -     ( planes [ i ]  . d )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["sphereInFrustum"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     2  ;    i    <     6  ;    i +  +  )", "if    (  (  (  (  ( planes [ i ]  . normal . x )     *     ( center . x )  )     +     (  ( planes [ i ]  . normal . y )     *     ( center . y )  )  )     +     (  ( planes [ i ]  . normal . z )     *     ( center . z )  )  )     <     (  (  - rius )     -     ( planes [ i ]  . d )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["sphereInFrustumWithoutNearFar"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     2  ;    i    <     6  ;    i +  +  )", "if    (  (  (  (  ( planes [ i ]  . normal . x )     *    x )     +     (  ( planes [ i ]  . normal . y )     *    y )  )     +     (  ( planes [ i ]  . normal . z )     *    z )  )     <     (  (  - rius )     -     ( planes [ i ]  . d )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["sphereInFrustumWithoutNearFar"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( Frustum . clipSpacePlanePointsArray ,     0  ,    planePointsArray ,     0  ,    Frustum . clipSpacePlanePointsArray . length )  ;", "Matrix 4  . prj ( inverseProjectionView . val ,    planePointsArray ,     0  ,     8  ,     3  )  ;", "for    ( int   i    =     0  ,    j    =     0  ;    i    <     8  ;    i +  +  )     {", "Vector 3    v    =    planePoints [ i ]  ;", "v . x    =    planePointsArray [  ( j +  +  )  ]  ;", "v . y    =    planePointsArray [  ( j +  +  )  ]  ;", "v . z    =    planePointsArray [  ( j +  +  )  ]  ;", "}", "planes [  0  ]  . set ( planePoints [  1  ]  ,    planePoints [  0  ]  ,    planePoints [  2  ]  )  ;", "planes [  1  ]  . set ( planePoints [  4  ]  ,    planePoints [  5  ]  ,    planePoints [  7  ]  )  ;", "planes [  2  ]  . set ( planePoints [  0  ]  ,    planePoints [  4  ]  ,    planePoints [  3  ]  )  ;", "planes [  3  ]  . set ( planePoints [  5  ]  ,    planePoints [  1  ]  ,    planePoints [  6  ]  )  ;", "planes [  4  ]  . set ( planePoints [  2  ]  ,    planePoints [  3  ]  ,    planePoints [  6  ]  )  ;", "planes [  5  ]  . set ( planePoints [  4  ]  ,    planePoints [  0  ]  ,    planePoints [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.math.Frustum"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( barycentric . x )     >  =     0  )     &  &     (  ( barycentric . y )     >  =     0  )  )     &  &     (  (  ( barycentric . x )     +     ( barycentric . y )  )     <  =     1  )  ;", "}", "METHOD_END"], "methodName": ["barycoordInsideTriangle"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   dx 2  1     =    x 2     -    x 1  ;", "float   dy 2  1     =    y 2     -    y 1  ;", "float   dx 3  2     =    x 3     -    x 2  ;", "float   dy 3  2     =    y 3     -    y 2  ;", "float   det    =     ( dx 3  2     *    dy 2  1  )     -     ( dx 2  1     *    dy 3  2  )  ;", "return    ( Math . abs ( det )  )     <     ( Math . FLOAT _ ROUNDING _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["colinear"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "GeometryUtils . ensureCCW ( polygon ,     0  ,    polygon . length )  ;", "}", "METHOD_END"], "methodName": ["ensureCCW"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( GeometryUtils . isClockwise ( polygon ,    offset ,    count )  )  )", "return ;", "int   lastX    =     ( offset    +    count )     -     2  ;", "for    ( int   i    =    offset ,    n    =    offset    +     ( count    /     2  )  ;    i    <    n ;    i    +  =     2  )     {", "int   other    =    lastX    -    i ;", "float   x    =    polygon [ i ]  ;", "float   y    =    polygon [  ( i    +     1  )  ]  ;", "polygon [ i ]     =    polygon [ other ]  ;", "polygon [  ( i    +     1  )  ]     =    polygon [  ( other    +     1  )  ]  ;", "polygon [ other ]     =    x ;", "polygon [  ( other    +     1  )  ]     =    y ;", "}", "}", "METHOD_END"], "methodName": ["ensureCCW"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   u    =     (  1     -     ( barycentric . x )  )     -     ( barycentric . y )  ;", "interpolatedOut . x    =     (  ( u    *     ( a . x )  )     +     (  ( barycentric . x )     *     ( b . x )  )  )     +     (  ( barycentric . y )     *     ( c . x )  )  ;", "interpolatedOut . y    =     (  ( u    *     ( a . y )  )     +     (  ( barycentric . x )     *     ( b . y )  )  )     +     (  ( barycentric . y )     *     ( c . y )  )  ;", "return   interpolatedOut ;", "}", "METHOD_END"], "methodName": ["fromBarycoord"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   u    =     (  1     -     ( barycentric . x )  )     -     ( barycentric . y )  ;", "return    (  ( u    *    a )     +     (  ( barycentric . x )     *    b )  )     +     (  ( barycentric . y )     *    c )  ;", "}", "METHOD_END"], "methodName": ["fromBarycoord"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( count    <  =     2  )", "return   false ;", "float   area    =     0  ;", "float   p 1 x ;", "float   p 1 y ;", "float   p 2 x ;", "float   p 2 y ;", "for    ( int   i    =    offset ,    n    =     ( offset    +    count )     -     3  ;    i    <    n ;    i    +  =     2  )     {", "p 1 x    =    polygon [ i ]  ;", "p 1 y    =    polygon [  ( i    +     1  )  ]  ;", "p 2 x    =    polygon [  ( i    +     2  )  ]  ;", "p 2 y    =    polygon [  ( i    +     3  )  ]  ;", "area    +  =     ( p 1 x    *    p 2 y )     -     ( p 2 x    *    p 1 y )  ;", "}", "p 1 x    =    polygon [  (  ( offset    +    count )     -     2  )  ]  ;", "p 1 y    =    polygon [  (  ( offset    +    count )     -     1  )  ]  ;", "p 2 x    =    polygon [ offset ]  ;", "p 2 y    =    polygon [  ( offset    +     1  )  ]  ;", "return    (  ( area    +     ( p 1 x    *    p 2 y )  )     -     ( p 2 x    *    p 1 y )  )     <     0  ;", "}", "METHOD_END"], "methodName": ["isClockwise"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   det    =     ( b    *    b )     -     (  (  4     *    a )     *    c )  ;", "if    ( det    <     0  )", "return   Float . NaN ;", "float   sqrtD    =     (  ( float )     ( Msqrt ( det )  )  )  ;", "float   invA    =     1     /     (  2     *    a )  ;", "float   r 1     =     (  (  - b )     -    sqrtD )     *    invA ;", "float   r 2     =     (  (  - b )     +    sqrtD )     *    invA ;", "if    ( r 1     >    r 2  )     {", "float   tmp    =    r 2  ;", "r 2     =    r 1  ;", "r 1     =    tmp ;", "}", "if    ( r 1     >     0  )", "return   r 1  ;", "if    ( r 2     >     0  )", "return   r 2  ;", "return   Float . NaN ;", "}", "METHOD_END"], "methodName": ["lowestPositiveRoot"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   area    =     0  ;", "for    ( int   i    =    offset ,    n    =    offset    +    count ;    i    <    n ;    i    +  =     2  )     {", "int   x 1     =    i ;", "int   y 1     =    i    +     1  ;", "int   x 2     =     ( i    +     2  )     %    n ;", "if    ( x 2     <    offset )", "x 2     +  =    offset ;", "int   y 2     =     ( i    +     3  )     %    n ;", "if    ( y 2     <    offset )", "y 2     +  =    offset ;", "area    +  =     ( polygon [ x 1  ]  )     *     ( polygon [ y 2  ]  )  ;", "area    -  =     ( polygon [ x 2  ]  )     *     ( polygon [ y 1  ]  )  ;", "}", "area    *  =     0  .  5 F ;", "return   area ;", "}", "METHOD_END"], "methodName": ["polygonArea"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( count    <     6  )", "throw   new   IllegalArgumentException (  \" A   polygon   must   have    3    or   more   coordinate   pairs .  \"  )  ;", "float   x    =     0  ;", "float   y    =     0  ;", "float   signedArea    =     0  ;", "int   i    =    offset ;", "for    ( int   n    =     ( offset    +    count )     -     2  ;    i    <    n ;    i    +  =     2  )     {", "float   x 0     =    polygon [ i ]  ;", "float   y 0     =    polygon [  ( i    +     1  )  ]  ;", "float   x 1     =    polygon [  ( i    +     2  )  ]  ;", "float   y 1     =    polygon [  ( i    +     3  )  ]  ;", "float   a    =     ( x 0     *    y 1  )     -     ( x 1     *    y 0  )  ;", "signedArea    +  =    a ;", "x    +  =     ( x 0     +    x 1  )     *    a ;", "y    +  =     ( y 0     +    y 1  )     *    a ;", "}", "float   x 0     =    polygon [ i ]  ;", "float   y 0     =    polygon [  ( i    +     1  )  ]  ;", "float   x 1     =    polygon [ offset ]  ;", "float   y 1     =    polygon [  ( offset    +     1  )  ]  ;", "float   a    =     ( x 0     *    y 1  )     -     ( x 1     *    y 0  )  ;", "signedArea    +  =    a ;", "x    +  =     ( x 0     +    x 1  )     *    a ;", "y    +  =     ( y 0     +    y 1  )     *    a ;", "if    ( signedArea    =  =     0  )     {", "centroid . x    =     0  ;", "centroid . y    =     0  ;", "} else    {", "signedArea    *  =     0  .  5 F ;", "centroid . x    =    x    /     (  6     *    signedArea )  ;", "centroid . y    =    y    /     (  6     *    signedArea )  ;", "}", "return   centroid ;", "}", "METHOD_END"], "methodName": ["polygonCentroid"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   avgX 1     =     (  ( x 1     +    x 2  )     +    x 3  )     /     3  ;", "float   avgY 1     =     (  ( y 1     +    y 2  )     +    y 3  )     /     3  ;", "float   avgX 2     =     (  ( x 1     +    x 4  )     +    x 3  )     /     3  ;", "float   avgY 2     =     (  ( y 1     +    y 4  )     +    y 3  )     /     3  ;", "centroid . x    =    avgX 1     -     (  ( avgX 1     -    avgX 2  )     /     2  )  ;", "centroid . y    =    avgY 1     -     (  ( avgY 1     -    avgY 2  )     /     2  )  ;", "return   centroid ;", "}", "METHOD_END"], "methodName": ["quadrilateralCentroid"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "Vector 2    v 0     =    GeometryUtils . tmp 1  . set ( b )  . sub ( a )  ;", "Vector 2    v 1     =    GeometryUtils . tmp 2  . set ( c )  . sub ( a )  ;", "Vector 2    v 2     =    GeometryUtils . tmp 3  . set ( p )  . sub ( a )  ;", "float   d 0  0     =    v 0  . dot ( v 0  )  ;", "float   d 0  1     =    v 0  . dot ( v 1  )  ;", "float   d 1  1     =    v 1  . dot ( v 1  )  ;", "float   d 2  0     =    v 2  . dot ( v 0  )  ;", "float   d 2  1     =    v 2  . dot ( v 1  )  ;", "float   denom    =     ( d 0  0     *    d 1  1  )     -     ( d 0  1     *    d 0  1  )  ;", "barycentricOut . x    =     (  ( d 1  1     *    d 2  0  )     -     ( d 0  1     *    d 2  1  )  )     /    denom ;", "barycentricOut . y    =     (  ( d 0  0     *    d 2  1  )     -     ( d 0  1     *    d 2  0  )  )     /    denom ;", "return   barycentricOut ;", "}", "METHOD_END"], "methodName": ["toBarycoord"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( Math . abs (  (  (  ( x 1     -    x 3  )     *     ( y 2     -    y 1  )  )     -     (  ( x 1     -    x 2  )     *     ( y 3     -    y 1  )  )  )  )  )     *     0  .  5 F ;", "}", "METHOD_END"], "methodName": ["triangleArea"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "centroid . x    =     (  ( x 1     +    x 2  )     +    x 3  )     /     3  ;", "centroid . y    =     (  ( y 1     +    y 2  )     +    y 3  )     /     3  ;", "return   centroid ;", "}", "METHOD_END"], "methodName": ["triangleCentroid"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   dx 2  1     =    x 2     -    x 1  ;", "float   dy 2  1     =    y 2     -    y 1  ;", "float   dx 3  2     =    x 3     -    x 2  ;", "float   dy 3  2     =    y 3     -    y 2  ;", "float   dx 1  3     =    x 1     -    x 3  ;", "float   dy 1  3     =    y 1     -    y 3  ;", "float   det    =     ( dx 3  2     *    dy 2  1  )     -     ( dx 2  1     *    dy 3  2  )  ;", "if    (  ( Math . abs ( det )  )     <     ( Math . FLOAT _ ROUNDING _ ERROR )  )", "throw   new   IllegalArgumentException (  \" Triangle   points   must   not   be   colinear .  \"  )  ;", "det    *  =     2  ;", "float   sqr 1     =     ( x 1     *    x 1  )     +     ( y 1     *    y 1  )  ;", "float   sqr 2     =     ( x 2     *    x 2  )     +     ( y 2     *    y 2  )  ;", "float   sqr 3     =     ( x 3     *    x 3  )     +     ( y 3     *    y 3  )  ;", "circumcenter . set (  (  (  (  ( sqr 1     *    dy 3  2  )     +     ( sqr 2     *    dy 1  3  )  )     +     ( sqr 3     *    dy 2  1  )  )     /    det )  ,     (  (  -  (  (  ( sqr 1     *    dx 3  2  )     +     ( sqr 2     *    dx 1  3  )  )     +     ( sqr 3     *    dx 2  1  )  )  )     /    det )  )  ;", "return   circumcenter ;", "}", "METHOD_END"], "methodName": ["triangleCircumcenter"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   m 1  ;", "float   m 2  ;", "float   mx 1  ;", "float   mx 2  ;", "float   my 1  ;", "float   my 2  ;", "float   x ;", "float   y ;", "if    (  ( Math . abs (  ( y 2     -    y 1  )  )  )     <     ( Math . FLOAT _ ROUNDING _ ERROR )  )     {", "m 2     =     (  -  ( x 3     -    x 2  )  )     /     ( y 3     -    y 2  )  ;", "mx 2     =     ( x 2     +    x 3  )     /     2  ;", "my 2     =     ( y 2     +    y 3  )     /     2  ;", "x    =     ( x 2     +    x 1  )     /     2  ;", "y    =     ( m 2     *     ( x    -    mx 2  )  )     +    my 2  ;", "} else", "if    (  ( Math . abs (  ( y 3     -    y 2  )  )  )     <     ( Math . FLOAT _ ROUNDING _ ERROR )  )     {", "m 1     =     (  -  ( x 2     -    x 1  )  )     /     ( y 2     -    y 1  )  ;", "mx 1     =     ( x 1     +    x 2  )     /     2  ;", "my 1     =     ( y 1     +    y 2  )     /     2  ;", "x    =     ( x 3     +    x 2  )     /     2  ;", "y    =     ( m 1     *     ( x    -    mx 1  )  )     +    my 1  ;", "} else    {", "m 1     =     (  -  ( x 2     -    x 1  )  )     /     ( y 2     -    y 1  )  ;", "m 2     =     (  -  ( x 3     -    x 2  )  )     /     ( y 3     -    y 2  )  ;", "mx 1     =     ( x 1     +    x 2  )     /     2  ;", "mx 2     =     ( x 2     +    x 3  )     /     2  ;", "my 1     =     ( y 1     +    y 2  )     /     2  ;", "my 2     =     ( y 2     +    y 3  )     /     2  ;", "x    =     (  (  (  ( m 1     *    mx 1  )     -     ( m 2     *    mx 2  )  )     +    my 2  )     -    my 1  )     /     ( m 1     -    m 2  )  ;", "y    =     ( m 1     *     ( x    -    mx 1  )  )     +    my 1  ;", "}", "float   dx    =    x 1     -    x ;", "float   dy    =    y 1     -    y ;", "return    (  ( float )     ( Math . sqrt (  (  ( dx    *    dx )     +     ( dy    *    dy )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["triangleCircumradius"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "float   length 1     =     (  ( float )     ( Math . sqrt (  (  ( x 1     *    x 1  )     +     ( y 1     *    y 1  )  )  )  )  )  ;", "float   length 2     =     (  ( float )     ( Math . sqrt (  (  ( x 2     *    x 2  )     +     ( y 2     *    y 2  )  )  )  )  )  ;", "float   length 3     =     (  ( float )     ( Math . sqrt (  (  ( x 3     *    x 3  )     +     ( y 3     *    y 3  )  )  )  )  )  ;", "return    ( Math . min ( length 1  ,    Math . min ( length 2  ,    length 3  )  )  )     /     (  . triangleCircumradius ( x 1  ,    y 1  ,    x 2  ,    y 2  ,    x 3  ,    y 3  )  )  ;", "}", "METHOD_END"], "methodName": ["triangleQuality"], "fileName": "com.badlogic.gdx.math.GeometryUtils"}, {"methodBody": ["METHOD_START", "{", "x    +  =    other . x ;", "y    +  =    other . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    x ;", "this . y    +  =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "return   new   GridPoint 2  ( this )  ;", "}", "METHOD_END"], "methodName": ["cpy"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "int   xd    =     ( other . x )     -     ( x )  ;", "int   yd    =     ( other . y )     -     ( y )  ;", "return    (  ( float )     ( Msqrt (  (  ( xd    *    xd )     +     ( yd    *    yd )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "int   xd    =    x    -     ( this . x )  ;", "int   yd    =    y    -     ( this . y )  ;", "return    (  ( float )     ( Msqrt (  (  ( xd    *    xd )     +     ( yd    *    yd )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "int   xd    =     ( other . x )     -     ( x )  ;", "int   yd    =     ( other . y )     -     ( y )  ;", "return    ( xd    *    xd )     +     ( yd    *    yd )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "int   xd    =    x    -     ( this . x )  ;", "int   yd    =    y    -     ( this . y )  ;", "return    ( xd    *    xd )     +     ( yd    *    yd )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "this . x    =    point . x ;", "this . y    =    point . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "x    -  =    other . x ;", "y    -  =    other . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "this . x    -  =    x ;", "this . y    -  =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.math.GridPoint2"}, {"methodBody": ["METHOD_START", "{", "x    +  =    other . x ;", "y    +  =    other . y ;", "z    +  =    other . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    x ;", "this . y    +  =    y ;", "this . z    +  =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "return   new   GridPoint 3  ( this )  ;", "}", "METHOD_END"], "methodName": ["cpy"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "int   xd    =     ( other . x )     -     ( x )  ;", "int   yd    =     ( other . y )     -     ( y )  ;", "int   zd    =     ( other . z )     -     ( z )  ;", "return    (  ( float )     ( Msqrt (  (  (  ( xd    *    xd )     +     ( yd    *    yd )  )     +     ( zd    *    zd )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "int   xd    =    x    -     ( this . x )  ;", "int   yd    =    y    -     ( this . y )  ;", "int   zd    =    z    -     ( this . z )  ;", "return    (  ( float )     ( Msqrt (  (  (  ( xd    *    xd )     +     ( yd    *    yd )  )     +     ( zd    *    zd )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "int   xd    =     ( other . x )     -     ( x )  ;", "int   yd    =     ( other . y )     -     ( y )  ;", "int   zd    =     ( other . z )     -     ( z )  ;", "return    (  ( xd    *    xd )     +     ( yd    *    yd )  )     +     ( zd    *    zd )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "int   xd    =    x    -     ( this . x )  ;", "int   yd    =    y    -     ( this . y )  ;", "int   zd    =    z    -     ( this . z )  ;", "return    (  ( xd    *    xd )     +     ( yd    *    yd )  )     +     ( zd    *    zd )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "this . x    =    point . x ;", "this . y    =    point . y ;", "this . z    =    point . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . z    =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "x    -  =    other . x ;", "y    -  =    other . y ;", "z    -  =    other . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "this . x    -  =    x ;", "this . y    -  =    y ;", "this . z    -  =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.math.GridPoint3"}, {"methodBody": ["METHOD_START", "{", "return   start    +     (  ( end    -    start )     *     ( apply ( a )  )  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.badlogic.gdx.math.Interpolation"}, {"methodBody": ["METHOD_START", "{", "return    ( a    *    d )     -     ( b    *    c )  ;", "}", "METHOD_END"], "methodName": ["det"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return    ( a    *    d )     -     ( b    *    c )  ;", "}", "METHOD_END"], "methodName": ["detd"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   normalLength    =     (  ( float )     ( Math . sqrt (  (  (  ( endX    -    startX )     *     ( endX    -    startX )  )     +     (  ( endY    -    startY )     *     ( endY    -    startY )  )  )  )  )  )  ;", "return    ( Math . abs (  (  (  ( pointX    -    startX )     *     ( endY    -    startY )  )     -     (  ( pointY    -    startY )     *     ( endX    -    startX )  )  )  )  )     /    normalLength ;", "}", "METHOD_END"], "methodName": ["distanceLinePoint"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   Intersector . nearestSegmentPoint ( start ,    end ,    point ,    Intersector . v 2 tmp )  . dst ( point )  ;", "}", "METHOD_END"], "methodName": ["distanceSegmentPoint"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   Intersector . nearestSegmentPoint ( startX ,    startY ,    endX ,    endY ,    pointX ,    pointY ,    Intersector . v 2 tmp )  . dst ( pointX ,    pointY )  ;", "}", "METHOD_END"], "methodName": ["distanceSegmentPoint"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Vector 3    direction    =    Intersector . tmp . set ( x 2  ,    y 2  ,    z 2  )  . sub ( x ,    y ,    z )  ;", "Vector 3    origin    =    Intersector . tmp 2  . set ( x ,    y ,    z )  ;", "float   denom    =    direction . dot ( plane . getNormal (  )  )  ;", "if    ( denom    !  =     0  )     {", "float   t    =     (  -  (  ( origin . dot ( plane . getNormal (  )  )  )     +     ( plane . getD (  )  )  )  )     /    denom ;", "if    ( intersection    !  =    null )", "intersection . set ( origin )  . add ( direction . scl ( t )  )  ;", "return   t ;", "} else", "if    (  ( plane . testPoint ( origin )  )     =  =     ( Plane . PlaneSide . OnPlane )  )     {", "if    ( intersection    !  =    null )", "intersection . set ( origin )  ;", "return    0  ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["intersectLinePlane"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float [  ]    vertices    =    polygon . getTransformedVertices (  )  ;", "float   x 1     =    p 1  . x ;", "float   y 1     =    p 1  . y ;", "float   x 2     =    p 2  . x ;", "float   y 2     =    p 2  . y ;", "int   n    =    vertices . length ;", "float   x 3     =    vertices [  ( n    -     2  )  ]  ;", "float   y 3     =    vertices [  ( n    -     1  )  ]  ;", "for    ( int   i    =     0  ;    i    <    n ;    i    +  =     2  )     {", "float   x 4     =    vertices [ i ]  ;", "float   y 4     =    vertices [  ( i    +     1  )  ]  ;", "float   d    =     (  ( y 4     -    y 3  )     *     ( x 2     -    x 1  )  )     -     (  ( x 4     -    x 3  )     *     ( y 2     -    y 1  )  )  ;", "if    ( d    !  =     0  )     {", "float   yd    =    y 1     -    y 3  ;", "float   xd    =    x 1     -    x 3  ;", "float   ua    =     (  (  ( x 4     -    x 3  )     *    yd )     -     (  ( y 4     -    y 3  )     *    xd )  )     /    d ;", "if    (  ( ua    >  =     0  )     &  &     ( ua    <  =     1  )  )     {", "return   true ;", "}", "}", "x 3     =    x 4  ;", "y 3     =    y 4  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["intersectLinePolygon"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   x 1     =    p 1  . x ;", "float   y 1     =    p 1  . y ;", "float   x 2     =    p 2  . x ;", "float   y 2     =    p 2  . y ;", "float   x 3     =    p 3  . x ;", "float   y 3     =    p 3  . y ;", "float   x 4     =    p 4  . x ;", "float   y 4     =    p 4  . y ;", "float   d    =     (  ( y 4     -    y 3  )     *     ( x 2     -    x 1  )  )     -     (  ( x 4     -    x 3  )     *     ( y 2     -    y 1  )  )  ;", "if    ( d    =  =     0  )", "return   false ;", "if    ( iion    !  =    null )     {", "float   ua    =     (  (  ( x 4     -    x 3  )     *     ( y 1     -    y 3  )  )     -     (  ( y 4     -    y 3  )     *     ( x 1     -    x 3  )  )  )     /    d ;", "iion . set (  ( x 1     +     (  ( x 2     -    x 1  )     *    ua )  )  ,     ( y 1     +     (  ( y 2     -    y 1  )     *    ua )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["intersectLines"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   d    =     (  ( y 4     -    y 3  )     *     ( x 2     -    x 1  )  )     -     (  ( x 4     -    x 3  )     *     ( y 2     -    y 1  )  )  ;", "if    ( d    =  =     0  )", "return   false ;", "if    ( iion    !  =    null )     {", "float   ua    =     (  (  ( x 4     -    x 3  )     *     ( y 1     -    y 3  )  )     -     (  ( y 4     -    y 3  )     *     ( x 1     -    x 3  )  )  )     /    d ;", "iion . set (  ( x 1     +     (  ( x 2     -    x 1  )     *    ua )  )  ,     ( y 1     +     (  ( y 2     -    y 1  )     *    ua )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["intersectLines"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Intersector . floatArray 2  . clear (  )  ;", "Intersector . floatArray . clear (  )  ;", "Intersector . floatArray 2  . addAll ( p 1  . getTransformedVertices (  )  )  ;", "if    (  (  ( p 1  . getVertices (  )  . length )     =  =     0  )     |  |     (  ( p 2  . getVertices (  )  . length )     =  =     0  )  )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <     ( p 2  . getTransformedVertices (  )  . length )  ;    i    +  =     2  )     {", "Intersector . ep 1  . set ( p 2  . getTransformedVertices (  )  [ i ]  ,    p 2  . getTransformedVertices (  )  [  ( i    +     1  )  ]  )  ;", "if    ( i    <     (  ( p 2  . getTransformedVertices (  )  . length )     -     2  )  )     {", "Intersector . ep 2  . set ( p 2  . getTransformedVertices (  )  [  ( i    +     2  )  ]  ,    p 2  . getTransformedVertices (  )  [  ( i    +     3  )  ]  )  ;", "} else    {", "Intersector . ep 2  . set ( p 2  . getTransformedVertices (  )  [  0  ]  ,    p 2  . getTransformedVertices (  )  [  1  ]  )  ;", "}", "if    (  ( Intersector . floatArray 2  . size )     =  =     0  )     {", "return   false ;", "}", "Intersector . s . set ( Intersector . floatArray 2  . get (  (  ( Intersector . floatArray 2  . size )     -     2  )  )  ,    Intersector . floatArray 2  . get (  (  ( Intersector . floatArray 2  . size )     -     1  )  )  )  ;", "for    ( int   j    =     0  ;    j    <     ( Intersector . floatArray 2  . size )  ;    j    +  =     2  )     {", "Intersector . e . set ( Intersector . floatArray 2  . get ( j )  ,    Intersector . floatArray 2  . get (  ( j    +     1  )  )  )  ;", "if    (  ( Intersector . pointLineSide ( Intersector . ep 2  ,    Intersector . ep 1  ,    Intersector . e )  )     >     0  )     {", "if    (  !  (  ( Intersector . pointLineSide ( Intersector . ep 2  ,    Intersector . ep 1  ,    Intersector . s )  )     >     0  )  )     {", "Intersector . intersectLines ( Intersector . s ,    Intersector . e ,    Intersector . ep 1  ,    Intersector . ep 2  ,    Intersector . ip )  ;", "if    (  (  (  ( Intersector . floatArray . size )     <     2  )     |  |     (  ( Intersector . floatArray . get (  (  ( Intersector . floatArray . size )     -     2  )  )  )     !  =     ( Intersector . ip . x )  )  )     |  |     (  ( Intersector . floatArray . get (  (  ( Intersector . floatArray . size )     -     1  )  )  )     !  =     ( Intersector . ip . y )  )  )     {", "Intersector . floatArray . add ( Intersector . ip . x )  ;", "Intersector . floatArray . add ( Intersector . ip . y )  ;", "}", "}", "Intersector . floatArray . add ( Intersector . e . x )  ;", "Intersector . floatArray . add ( Intersector . e . y )  ;", "} else", "if    (  ( Intersector . pointLineSide ( Intersector . ep 2  ,    Intersector . ep 1  ,    Intersector . s )  )     >     0  )     {", "Intersector . intersectLines ( Intersector . s ,    Intersector . e ,    Intersector . ep 1  ,    Intersector . ep 2  ,    Intersector . ip )  ;", "Intersector . floatArray . add ( Intersector . ip . x )  ;", "Intersector . floatArray . add ( Intersector . ip . y )  ;", "}", "Intersector . s . set ( Intersector . e . x ,    Intersector . e . y )  ;", "}", "Intersector . floatArray 2  . clear (  )  ;", "Intersector . floatArray 2  . addAll ( Intersector . floatArray )  ;", "Intersector . floatArray . clear (  )  ;", "}", "if    (  !  (  ( Intersector . floatArray 2  . size )     =  =     0  )  )     {", "overlap . setVertices ( Intersector . floatArray 2  . toArray (  )  )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["intersectPolygons"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "if    ( box . contains ( ray . origin )  )     {", "if    ( intersection    !  =    null )", "intersection . set ( ray . origin )  ;", "return   true ;", "}", "float   lowest    =     0  ;", "float   t ;", "boolean   hit    =    false ;", "if    (  (  ( ray . origin . x )     <  =     ( box . min . x )  )     &  &     (  ( ray . direction . x )     >     0  )  )     {", "t    =     (  ( box . min . x )     -     ( ray . origin . x )  )     /     ( ray . direction . x )  ;", "if    ( t    >  =     0  )     {", ". v 2  . set ( ray . direction )  . scl ( t )  . add ( ray . origin )  ;", "if    (  (  (  (  (  (  . v 2  . y )     >  =     ( box . min . y )  )     &  &     (  (  . v 2  . y )     <  =     ( box . max . y )  )  )     &  &     (  (  . v 2  . z )     >  =     ( box . min . z )  )  )     &  &     (  (  . v 2  . z )     <  =     ( box . max . z )  )  )     &  &     (  (  ! hit )     |  |     ( t    <    lowest )  )  )     {", "hit    =    true ;", "lowest    =    t ;", "}", "}", "}", "if    (  (  ( ray . origin . x )     >  =     ( box . max . x )  )     &  &     (  ( ray . direction . x )     <     0  )  )     {", "t    =     (  ( box . max . x )     -     ( ray . origin . x )  )     /     ( ray . direction . x )  ;", "if    ( t    >  =     0  )     {", ". v 2  . set ( ray . direction )  . scl ( t )  . add ( ray . origin )  ;", "if    (  (  (  (  (  (  . v 2  . y )     >  =     ( box . min . y )  )     &  &     (  (  . v 2  . y )     <  =     ( box . max . y )  )  )     &  &     (  (  . v 2  . z )     >  =     ( box . min . z )  )  )     &  &     (  (  . v 2  . z )     <  =     ( box . max . z )  )  )     &  &     (  (  ! hit )     |  |     ( t    <    lowest )  )  )     {", "hit    =    true ;", "lowest    =    t ;", "}", "}", "}", "if    (  (  ( ray . origin . y )     <  =     ( box . min . y )  )     &  &     (  ( ray . direction . y )     >     0  )  )     {", "t    =     (  ( box . min . y )     -     ( ray . origin . y )  )     /     ( ray . direction . y )  ;", "if    ( t    >  =     0  )     {", ". v 2  . set ( ray . direction )  . scl ( t )  . add ( ray . origin )  ;", "if    (  (  (  (  (  (  . v 2  . x )     >  =     ( box . min . x )  )     &  &     (  (  . v 2  . x )     <  =     ( box . max . x )  )  )     &  &     (  (  . v 2  . z )     >  =     ( box . min . z )  )  )     &  &     (  (  . v 2  . z )     <  =     ( box . max . z )  )  )     &  &     (  (  ! hit )     |  |     ( t    <    lowest )  )  )     {", "hit    =    true ;", "lowest    =    t ;", "}", "}", "}", "if    (  (  ( ray . origin . y )     >  =     ( box . max . y )  )     &  &     (  ( ray . direction . y )     <     0  )  )     {", "t    =     (  ( box . max . y )     -     ( ray . origin . y )  )     /     ( ray . direction . y )  ;", "if    ( t    >  =     0  )     {", ". v 2  . set ( ray . direction )  . scl ( t )  . add ( ray . origin )  ;", "if    (  (  (  (  (  (  . v 2  . x )     >  =     ( box . min . x )  )     &  &     (  (  . v 2  . x )     <  =     ( box . max . x )  )  )     &  &     (  (  . v 2  . z )     >  =     ( box . min . z )  )  )     &  &     (  (  . v 2  . z )     <  =     ( box . max . z )  )  )     &  &     (  (  ! hit )     |  |     ( t    <    lowest )  )  )     {", "hit    =    true ;", "lowest    =    t ;", "}", "}", "}", "if    (  (  ( ray . origin . z )     <  =     ( box . min . z )  )     &  &     (  ( ray . direction . z )     >     0  )  )     {", "t    =     (  ( box . min . z )     -     ( ray . origin . z )  )     /     ( ray . direction . z )  ;", "if    ( t    >  =     0  )     {", ". v 2  . set ( ray . direction )  . scl ( t )  . add ( ray . origin )  ;", "if    (  (  (  (  (  (  . v 2  . x )     >  =     ( box . min . x )  )     &  &     (  (  . v 2  . x )     <  =     ( box . max . x )  )  )     &  &     (  (  . v 2  . y )     >  =     ( box . min . y )  )  )     &  &     (  (  . v 2  . y )     <  =     ( box . max . y )  )  )     &  &     (  (  ! hit )     |  |     ( t    <    lowest )  )  )     {", "hit    =    true ;", "lowest    =    t ;", "}", "}", "}", "if    (  (  ( ray . origin . z )     >  =     ( box . max . z )  )     &  &     (  ( ray . direction . z )     <     0  )  )     {", "t    =     (  ( box . max . z )     -     ( ray . origin . z )  )     /     ( ray . direction . z )  ;", "if    ( t    >  =     0  )     {", ". v 2  . set ( ray . direction )  . scl ( t )  . add ( ray . origin )  ;", "if    (  (  (  (  (  (  . v 2  . x )     >  =     ( box . min . x )  )     &  &     (  (  . v 2  . x )     <  =     ( box . max . x )  )  )     &  &     (  (  . v 2  . y )     >  =     ( box . min . y )  )  )     &  &     (  (  . v 2  . y )     <  =     ( box . max . y )  )  )     &  &     (  (  ! hit )     |  |     ( t    <    lowest )  )  )     {", "hit    =    true ;", "lowest    =    t ;", "}", "}", "}", "if    ( hit    &  &     ( intersection    !  =    null )  )     {", "intersection . set ( ray . direction )  . scl ( lowest )  . add ( ray . origin )  ;", "if    (  ( intersection . x )     <     ( box . min . x )  )     {", "intersection . x    =    box . min . x ;", "} else", "if    (  ( intersection . x )     >     ( box . max . x )  )     {", "intersection . x    =    box . max . x ;", "}", "if    (  ( intersection . y )     <     ( box . min . y )  )     {", "intersection . y    =    box . min . y ;", "} else", "if    (  ( intersection . y )     >     ( box . max . y )  )     {", "intersection . y    =    box . max . y ;", "}", "if    (  ( intersection . z )     <     ( box . min . z )  )     {", "intersection . z    =    box . min . z ;", "} else", "if    (  ( intersection . z )     >     ( box . max . z )  )     {", "intersection . z    =    box . max . z ;", "}", "}", "return   hit ;", "}", "METHOD_END"], "methodName": ["intersectRayBounds"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "final   float   divX    =     1  .  0 F    /     ( ray . direction . x )  ;", "final   float   divY    =     1  .  0 F    /     ( ray . direction . y )  ;", "final   float   divZ    =     1  .  0 F    /     ( ray . direction . z )  ;", "float   minx    =     (  (  ( ce . x )     -     (  ( dimensions . x )     *     0  .  5 F )  )     -     ( ray . origin . x )  )     *    divX ;", "float   maxx    =     (  (  ( ce . x )     +     (  ( dimensions . x )     *     0  .  5 F )  )     -     ( ray . origin . x )  )     *    divX ;", "if    ( minx    >    maxx )     {", "final   float   t    =    minx ;", "minx    =    maxx ;", "maxx    =    t ;", "}", "float   miny    =     (  (  ( ce . y )     -     (  ( dimensions . y )     *     0  .  5 F )  )     -     ( ray . origin . y )  )     *    divY ;", "float   maxy    =     (  (  ( ce . y )     +     (  ( dimensions . y )     *     0  .  5 F )  )     -     ( ray . origin . y )  )     *    divY ;", "if    ( miny    >    maxy )     {", "final   float   t    =    miny ;", "miny    =    maxy ;", "maxy    =    t ;", "}", "float   minz    =     (  (  ( ce . z )     -     (  ( dimensions . z )     *     0  .  5 F )  )     -     ( ray . origin . z )  )     *    divZ ;", "float   maxz    =     (  (  ( ce . z )     +     (  ( dimensions . z )     *     0  .  5 F )  )     -     ( ray . origin . z )  )     *    divZ ;", "if    ( minz    >    maxz )     {", "final   float   t    =    minz ;", "minz    =    maxz ;", "maxz    =    t ;", "}", "float   min    =    Math . max ( Math . max ( minx ,    miny )  ,    minz )  ;", "float   max    =    Math . min ( Math . min ( maxx ,    maxy )  ,    maxz )  ;", "return    ( max    >  =     0  )     &  &     ( max    >  =    min )  ;", "}", "METHOD_END"], "methodName": ["intersectRayBoundsFast"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   Intersector . intersectRayBoundsFast ( ray ,    box . getCenter ( Intersector . tmp 1  )  ,    box . getDimensions ( Intersector . tmp 2  )  )  ;", "}", "METHOD_END"], "methodName": ["intersectRayBoundsFast"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   denom    =    ray . direction . dot ( plane . getNormal (  )  )  ;", "if    ( denom    !  =     0  )     {", "float   t    =     (  -  (  ( ray . origin . dot ( plane . getNormal (  )  )  )     +     ( plane . getD (  )  )  )  )     /    denom ;", "if    ( t    <     0  )", "return   false ;", "if    ( intersection    !  =    null )", "intersection . set ( ray . origin )  . add (  . v 0  . set ( ray . direction )  . scl ( t )  )  ;", "return   true ;", "} else", "if    (  ( plane . testPoint ( ray . origin )  )     =  =     ( Plane . PlaneSide . OnPlane )  )     {", "if    ( intersection    !  =    null )", "intersection . set ( ray . origin )  ;", "return   true ;", "} else", "return   false ;", "}", "METHOD_END"], "methodName": ["intersectRayPlane"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   difx    =     ( start 2  . x )     -     ( start 1  . x )  ;", "float   dify    =     ( start 2  . y )     -     ( start 1  . y )  ;", "float   d 1 xd 2     =     (  ( dirion 1  . x )     *     ( dirion 2  . y )  )     -     (  ( dirion 1  . y )     *     ( dirion 2  . x )  )  ;", "if    ( d 1 xd 2     =  =     0  .  0 F )     {", "return   Float . POSITIVE _ INFINITY ;", "}", "float   d 2 sx    =     ( dirion 2  . x )     /    d 1 xd 2  ;", "float   d 2 sy    =     ( dirion 2  . y )     /    d 1 xd 2  ;", "return    ( difx    *    d 2 sy )     -     ( dify    *    d 2 sx )  ;", "}", "METHOD_END"], "methodName": ["intersectRayRay"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "final   float   len    =    ray . direction . dot (  (  ( center . x )     -     ( ray . origin . x )  )  ,     (  ( center . y )     -     ( ray . origin . y )  )  ,     (  ( center . z )     -     ( ray . origin . z )  )  )  ;", "if    ( len    <     0  .  0 F )", "return   false ;", "final   float   dst 2     =    center . dst 2  (  (  ( ray . origin . x )     +     (  ( ray . direction . x )     *    len )  )  ,     (  ( ray . origin . y )     +     (  ( ray . direction . y )     *    len )  )  ,     (  ( ray . origin . z )     +     (  ( ray . direction . z )     *    len )  )  )  ;", "final   float   r 2     =    radius    *    radius ;", "if    ( dst 2     >    r 2  )", "return   false ;", "if    ( iion    !  =    null )", "iion . set ( ray . direction )  . scl (  ( len    -     (  ( float )     ( Math . sqrt (  ( r 2     -    dst 2  )  )  )  )  )  )  . add ( ray . origin )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["intersectRaySphere"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Vector 3    edge 1     =    Intersector . v 0  . set ( t 2  )  . sub ( t 1  )  ;", "Vector 3    edge 2     =    Intersector . v 1  . set ( t 3  )  . sub ( t 1  )  ;", "Vector 3    pvec    =    Intersector . v 2  . set ( ray . direction )  . crs ( edge 2  )  ;", "float   det    =    edge 1  . dot ( pvec )  ;", "if    ( MathUtils . isZero ( det )  )     {", "Intersector . p . set ( t 1  ,    t 2  ,    t 3  )  ;", "if    (  (  ( Intersector . p . testPoint ( ray . origin )  )     =  =     ( Plane . PlaneSide . OnPlane )  )     &  &     ( Intersector . isPointInTriangle ( ray . origin ,    t 1  ,    t 2  ,    t 3  )  )  )     {", "if    ( intersection    !  =    null )", "intersection . set ( ray . origin )  ;", "return   true ;", "}", "return   false ;", "}", "det    =     1  .  0 F    /    det ;", "Vector 3    tvec    =    Intersector . i . set ( ray . origin )  . sub ( t 1  )  ;", "float   u    =     ( tvec . dot ( pvec )  )     *    det ;", "if    (  ( u    <     0  .  0 F )     |  |     ( u    >     1  .  0 F )  )", "return   false ;", "Vector 3    qvec    =    tvec . crs ( edge 1  )  ;", "float   v    =     ( ray . direction . dot ( qvec )  )     *    det ;", "if    (  ( v    <     0  .  0 F )     |  |     (  ( u    +    v )     >     1  .  0 F )  )", "return   false ;", "float   t    =     ( edge 2  . dot ( qvec )  )     *    det ;", "if    ( t    <     0  )", "return   false ;", "if    ( intersection    !  =    null )     {", "if    ( t    <  =     ( MathUtils . FLOAT _ ROUNDING _ ERROR )  )     {", "intersection . set ( ray . origin )  ;", "} else    {", "ray . getEndPoint ( intersection ,    t )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["intersectRayTriangle"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   min _ dist    =    Float . MAX _ VALUE ;", "boolean   hit    =    false ;", "if    (  (  (  ( triangles . length )     /     3  )     %     3  )     !  =     0  )", "throw   new   RuntimeException (  \" triangle   list   size   is   not   a   multiple   of    3  \"  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( triangles . length )     -     6  )  ;    i    +  =     9  )     {", "boolean   result    =     . intersectRayTriangle ( ray ,     . tmp 1  . set ( triangles [ i ]  ,    triangles [  ( i    +     1  )  ]  ,    triangles [  ( i    +     2  )  ]  )  ,     . tmp 2  . set ( triangles [  ( i    +     3  )  ]  ,    triangles [  ( i    +     4  )  ]  ,    triangles [  ( i    +     5  )  ]  )  ,     . tmp 3  . set ( triangles [  ( i    +     6  )  ]  ,    triangles [  ( i    +     7  )  ]  ,    triangles [  ( i    +     8  )  ]  )  ,     . tmp )  ;", "if    ( result    =  =    true )     {", "float   dist    =    ray . origin . dst 2  (  . tmp )  ;", "if    ( dist    <    min _ dist )     {", "min _ dist    =    dist ;", ". best . set (  . tmp )  ;", "hit    =    true ;", "}", "}", "}", "if    ( hit    =  =    false )", "return   false ;", "else    {", "if    ( intersection    !  =    null )", "intersection . set (  . best )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["intersectRayTriangles"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   min _ dist    =    Float . MAX _ VALUE ;", "boolean   hit    =    false ;", "if    (  (  ( indices . length )     %     3  )     !  =     0  )", "throw   new   RuntimeException (  \" triangle   list   size   is   not   a   multiple   of    3  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( indices . length )  ;    i    +  =     3  )     {", "int   i 1     =     ( indices [ i ]  )     *    vertexSize ;", "int   i 2     =     ( indices [  ( i    +     1  )  ]  )     *    vertexSize ;", "int   i 3     =     ( indices [  ( i    +     2  )  ]  )     *    vertexSize ;", "boolean   result    =     . intersectRayTriangle ( ray ,     . tmp 1  . set ( vertices [ i 1  ]  ,    vertices [  ( i 1     +     1  )  ]  ,    vertices [  ( i 1     +     2  )  ]  )  ,     . tmp 2  . set ( vertices [ i 2  ]  ,    vertices [  ( i 2     +     1  )  ]  ,    vertices [  ( i 2     +     2  )  ]  )  ,     . tmp 3  . set ( vertices [ i 3  ]  ,    vertices [  ( i 3     +     1  )  ]  ,    vertices [  ( i 3     +     2  )  ]  )  ,     . tmp )  ;", "if    ( result    =  =    true )     {", "float   dist    =    ray . origin . dst 2  (  . tmp )  ;", "if    ( dist    <    min _ dist )     {", "min _ dist    =    dist ;", ". best . set (  . tmp )  ;", "hit    =    true ;", "}", "}", "}", "if    ( hit    =  =    false )", "return   false ;", "else    {", "if    ( intersection    !  =    null )", "intersection . set (  . best )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["intersectRayTriangles"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   min _ dist    =    Float . MAX _ VALUE ;", "boolean   hit    =    false ;", "if    (  (  ( triangles . size (  )  )     %     3  )     !  =     0  )", "throw   new   RuntimeException (  \" triangle   list   size   is   not   a   multiple   of    3  \"  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( triangles . size (  )  )     -     2  )  ;    i    +  =     3  )     {", "boolean   result    =     . intersectRayTriangle ( ray ,    triangles . get ( i )  ,    triangles . get (  ( i    +     1  )  )  ,    triangles . get (  ( i    +     2  )  )  ,     . tmp )  ;", "if    ( result    =  =    true )     {", "float   dist    =    ray . origin . dst 2  (  . tmp )  ;", "if    ( dist    <    min _ dist )     {", "min _ dist    =    dist ;", ". best . set (  . tmp )  ;", "hit    =    true ;", "}", "}", "}", "if    (  ! hit )", "return   false ;", "else    {", "if    ( intersection    !  =    null )", "intersection . set (  . best )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["intersectRayTriangles"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "if    ( rectangle 1  . overlaps ( rectangle 2  )  )     {", "iion . x    =    Math . max ( rectangle 1  . x ,    rectangle 2  . x )  ;", "iion . width    =     ( Math . min (  (  ( rectangle 1  . x )     +     ( rectangle 1  . width )  )  ,     (  ( rectangle 2  . x )     +     ( rectangle 2  . width )  )  )  )     -     ( iion . x )  ;", "iion . y    =    Math . max ( rectangle 1  . y ,    rectangle 2  . y )  ;", "iion . height    =     ( Math . min (  (  ( rectangle 1  . y )     +     ( rectangle 1  . height )  )  ,     (  ( rectangle 2  . y )     +     ( rectangle 2  . height )  )  )  )     -     ( iion . y )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["intersectRectangles"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Intersector . tmp . set (  (  ( end . x )     -     ( start . x )  )  ,     (  ( end . y )     -     ( start . y )  )  ,     0  )  ;", "Intersector . tmp 1  . set (  (  ( center . x )     -     ( start . x )  )  ,     (  ( center . y )     -     ( start . y )  )  ,     0  )  ;", "float   l    =    Intersector . tmp . len (  )  ;", "float   u    =    Intersector . tmp 1  . dot ( Intersector . tmp . nor (  )  )  ;", "if    ( u    <  =     0  )     {", "Intersector . tmp 2  . set ( start . x ,    start . y ,     0  )  ;", "} else", "if    ( u    >  =    l )     {", "Intersector . tmp 2  . set ( end . x ,    end . y ,     0  )  ;", "} else    {", "Intersector . tmp 3  . set ( Intersector . tmp . scl ( u )  )  ;", "Intersector . tmp 2  . set (  (  ( Intersector . tmp 3  . x )     +     ( start . x )  )  ,     (  ( Intersector . tmp 3  . y )     +     ( start . y )  )  ,     0  )  ;", "}", "float   x    =     ( center . x )     -     ( Intersector . tmp 2  . x )  ;", "float   y    =     ( center . y )     -     ( Intersector . tmp 2  . y )  ;", "return    (  ( x    *    x )     +     ( y    *    y )  )     <  =    squareRadius ;", "}", "METHOD_END"], "methodName": ["intersectSegmentCircle"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   u    =     (  (  ( point . x )     -     ( start . x )  )     *     (  ( end . x )     -     ( start . x )  )  )     +     (  (  ( point . y )     -     ( start . y )  )     *     (  ( end . y )     -     ( start . y )  )  )  ;", "float   d    =    start . dst ( end )  ;", "u    /  =    d    *    d ;", "if    (  ( u    <     0  )     |  |     ( u    >     1  )  )", "return   Float . POSITIVE _ INFINITY ;", ". tmp . set ( end . x ,    end . y ,     0  )  . sub ( start . x ,    start . y ,     0  )  ;", ". tmp 2  . set ( start . x ,    start . y ,     0  )  . add (  . tmp . scl ( u )  )  ;", "d    =     . tmp 2  . dst ( point . x ,    point . y ,     0  )  ;", "if    ( d    <    radius )     {", "displacement . set ( point )  . sub (  . tmp 2  . x ,     . tmp 2  . y )  . nor (  )  ;", "return   d ;", "} else", "return   Float . POSITIVE _ INFINITY ;", "}", "METHOD_END"], "methodName": ["intersectSegmentCircleDisplace"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Vector 3    dir    =    Intersector . v 0  . set ( end )  . sub ( start )  ;", "float   denom    =    dir . dot ( plane . getNormal (  )  )  ;", "float   t    =     (  -  (  ( start . dot ( plane . getNormal (  )  )  )     +     ( plane . getD (  )  )  )  )     /    denom ;", "if    (  ( t    <     0  )     |  |     ( t    >     1  )  )", "return   false ;", "intersection . set ( start )  . add ( dir . scl ( t )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["intersectSegmentPlane"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float [  ]    vertices    =    polygon . getTransformedVertices (  )  ;", "float   x 1     =    p 1  . x ;", "float   y 1     =    p 1  . y ;", "float   x 2     =    p 2  . x ;", "float   y 2     =    p 2  . y ;", "int   n    =    vertices . length ;", "float   x 3     =    vertices [  ( n    -     2  )  ]  ;", "float   y 3     =    vertices [  ( n    -     1  )  ]  ;", "for    ( int   i    =     0  ;    i    <    n ;    i    +  =     2  )     {", "float   x 4     =    vertices [ i ]  ;", "float   y 4     =    vertices [  ( i    +     1  )  ]  ;", "float   d    =     (  ( y 4     -    y 3  )     *     ( x 2     -    x 1  )  )     -     (  ( x 4     -    x 3  )     *     ( y 2     -    y 1  )  )  ;", "if    ( d    !  =     0  )     {", "float   yd    =    y 1     -    y 3  ;", "float   xd    =    x 1     -    x 3  ;", "float   ua    =     (  (  ( x 4     -    x 3  )     *    yd )     -     (  ( y 4     -    y 3  )     *    xd )  )     /    d ;", "if    (  ( ua    >  =     0  )     &  &     ( ua    <  =     1  )  )     {", "float   ub    =     (  (  ( x 2     -    x 1  )     *    yd )     -     (  ( y 2     -    y 1  )     *    xd )  )     /    d ;", "if    (  ( ub    >  =     0  )     &  &     ( ub    <  =     1  )  )     {", "return   true ;", "}", "}", "}", "x 3     =    x 4  ;", "y 3     =    y 4  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["intersectSegmentPolygon"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   x 1     =    p 1  . x ;", "float   y 1     =    p 1  . y ;", "float   x 2     =    p 2  . x ;", "float   y 2     =    p 2  . y ;", "float   x 3     =    p 3  . x ;", "float   y 3     =    p 3  . y ;", "float   x 4     =    p 4  . x ;", "float   y 4     =    p 4  . y ;", "float   d    =     (  ( y 4     -    y 3  )     *     ( x 2     -    x 1  )  )     -     (  ( x 4     -    x 3  )     *     ( y 2     -    y 1  )  )  ;", "if    ( d    =  =     0  )", "return   false ;", "float   yd    =    y 1     -    y 3  ;", "float   xd    =    x 1     -    x 3  ;", "float   ua    =     (  (  ( x 4     -    x 3  )     *    yd )     -     (  ( y 4     -    y 3  )     *    xd )  )     /    d ;", "if    (  ( ua    <     0  )     |  |     ( ua    >     1  )  )", "return   false ;", "float   ub    =     (  (  ( x 2     -    x 1  )     *    yd )     -     (  ( y 2     -    y 1  )     *    xd )  )     /    d ;", "if    (  ( ub    <     0  )     |  |     ( ub    >     1  )  )", "return   false ;", "if    ( iion    !  =    null )", "iion . set (  ( x 1     +     (  ( x 2     -    x 1  )     *    ua )  )  ,     ( y 1     +     (  ( y 2     -    y 1  )     *    ua )  )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["intersectSegments"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   d    =     (  ( y 4     -    y 3  )     *     ( x 2     -    x 1  )  )     -     (  ( x 4     -    x 3  )     *     ( y 2     -    y 1  )  )  ;", "if    ( d    =  =     0  )", "return   false ;", "float   yd    =    y 1     -    y 3  ;", "float   xd    =    x 1     -    x 3  ;", "float   ua    =     (  (  ( x 4     -    x 3  )     *    yd )     -     (  ( y 4     -    y 3  )     *    xd )  )     /    d ;", "if    (  ( ua    <     0  )     |  |     ( ua    >     1  )  )", "return   false ;", "float   ub    =     (  (  ( x 2     -    x 1  )     *    yd )     -     (  ( y 2     -    y 1  )     *    xd )  )     /    d ;", "if    (  ( ub    <     0  )     |  |     ( ub    >     1  )  )", "return   false ;", "if    ( iion    !  =    null )", "iion . set (  ( x 1     +     (  ( x 2     -    x 1  )     *    ua )  )  ,     ( y 1     +     (  ( y 2     -    y 1  )     *    ua )  )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["intersectSegments"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Vector 2    lastVertice    =    polygon . peek (  )  ;", "boolean   oddNodes    =    false ;", "for    ( int   i    =     0  ;    i    <     ( polygon . size )  ;    i +  +  )     {", "Vector 2    vertice    =    polygon . get ( i )  ;", "if    (  (  (  ( vertice . y )     <     ( point . y )  )     &  &     (  ( lastVertice . y )     >  =     ( point . y )  )  )     |  |     (  (  ( lastVertice . y )     <     ( point . y )  )     &  &     (  ( vertice . y )     >  =     ( point . y )  )  )  )     {", "if    (  (  ( vertice . x )     +     (  (  (  ( point . y )     -     ( vertice . y )  )     /     (  ( lastVertice . y )     -     ( vertice . y )  )  )     *     (  ( lastVertice . x )     -     ( vertice . x )  )  )  )     <     ( point . x )  )     {", "oddNodes    =     ! oddNodes ;", "}", "}", "lastVertice    =    vertice ;", "}", "return   oddNodes ;", "}", "METHOD_END"], "methodName": ["isPointInPolygon"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "boolean   oddNodes    =    false ;", "int   j    =     ( offset    +    count )     -     2  ;", "for    ( int   i    =    offset ,    n    =    j ;    i    <  =    n ;    i    +  =     2  )     {", "float   yi    =    polygon [  ( i    +     1  )  ]  ;", "float   yj    =    polygon [  ( j    +     1  )  ]  ;", "if    (  (  ( yi    <    y )     &  &     ( yj    >  =    y )  )     |  |     (  ( yj    <    y )     &  &     ( yi    >  =    y )  )  )     {", "float   xi    =    polygon [ i ]  ;", "if    (  ( xi    +     (  (  ( y    -    yi )     /     ( yj    -    yi )  )     *     (  ( polygon [ j ]  )     -    xi )  )  )     <    x )", "oddNodes    =     ! oddNodes ;", "}", "j    =    i ;", "}", "return   oddNodes ;", "}", "METHOD_END"], "methodName": ["isPointInPolygon"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   px 1     =     ( p . x )     -     ( a . x )  ;", "float   py 1     =     ( p . y )     -     ( a . y )  ;", "boolean   side 1  2     =     (  (  (  ( b . x )     -     ( a . x )  )     *    py 1  )     -     (  (  ( b . y )     -     ( a . y )  )     *    px 1  )  )     >     0  ;", "if    (  (  (  (  (  ( c . x )     -     ( a . x )  )     *    py 1  )     -     (  (  ( c . y )     -     ( a . y )  )     *    px 1  )  )     >     0  )     =  =    side 1  2  )", "return   false ;", "if    (  (  (  (  (  ( c . x )     -     ( b . x )  )     *     (  ( p . y )     -     ( b . y )  )  )     -     (  (  ( c . y )     -     ( b . y )  )     *     (  ( p . x )     -     ( b . x )  )  )  )     >     0  )     !  =    side 1  2  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isPointInTriangle"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Intersector . v 0  . set ( t 1  )  . sub ( point )  ;", "Intersector . v 1  . set ( t 2  )  . sub ( point )  ;", "Intersector . v 2  . set ( t 3  )  . sub ( point )  ;", "float   ab    =    Intersector . v 0  . dot ( Intersector . v 1  )  ;", "float   ac    =    Intersector . v 0  . dot ( Intersector . v 2  )  ;", "float   bc    =    Intersector . v 1  . dot ( Intersector . v 2  )  ;", "float   cc    =    Intersector . v 2  . dot ( Intersector . v 2  )  ;", "if    (  (  ( bc    *    ac )     -     ( cc    *    ab )  )     <     0  )", "return   false ;", "float   bb    =    Intersector . v 1  . dot ( Intersector . v 1  )  ;", "if    (  (  ( ab    *    bc )     -     ( ac    *    bb )  )     <     0  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isPointInTriangle"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   px 1     =    px    -    ax ;", "float   py 1     =    py    -    ay ;", "boolean   side 1  2     =     (  (  ( bx    -    ax )     *    py 1  )     -     (  ( by    -    ay )     *    px 1  )  )     >     0  ;", "if    (  (  (  (  ( cx    -    ax )     *    py 1  )     -     (  ( cy    -    ay )     *    px 1  )  )     >     0  )     =  =    side 1  2  )", "return   false ;", "if    (  (  (  (  ( cx    -    bx )     *     ( py    -    by )  )     -     (  ( cy    -    by )     *     ( px    -    bx )  )  )     >     0  )     !  =    side 1  2  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isPointInTriangle"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   length 2     =    start . dst 2  ( end )  ;", "if    ( length 2     =  =     0  )", "return   nearest . set ( start )  ;", "float   t    =     (  (  (  ( point . x )     -     ( start . x )  )     *     (  ( end . x )     -     ( start . x )  )  )     +     (  (  ( point . y )     -     ( start . y )  )     *     (  ( end . y )     -     ( start . y )  )  )  )     /    length 2  ;", "if    ( t    <     0  )", "return   nearest . set ( start )  ;", "if    ( t    >     1  )", "return   nearest . set ( end )  ;", "return   nearest . set (  (  ( start . x )     +     ( t    *     (  ( end . x )     -     ( start . x )  )  )  )  ,     (  ( start . y )     +     ( t    *     (  ( end . y )     -     ( start . y )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nearestSegmentPoint"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "final   float   xDiff    =    endX    -    startX ;", "final   float   yDiff    =    endY    -    startY ;", "float   length 2     =     ( xDiff    *    xDiff )     +     ( yDiff    *    yDiff )  ;", "if    ( length 2     =  =     0  )", "return   nearest . set ( startX ,    startY )  ;", "float   t    =     (  (  ( pointX    -    startX )     *     ( endX    -    startX )  )     +     (  ( pointY    -    startY )     *     ( endY    -    startY )  )  )     /    length 2  ;", "if    ( t    <     0  )", "return   nearest . set ( startX ,    startY )  ;", "if    ( t    >     1  )", "return   nearest . set ( endX ,    endY )  ;", "return   nearest . set (  ( startX    +     ( t    *     ( endX    -    startX )  )  )  ,     ( startY    +     ( t    *     ( endY    -    startY )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nearestSegmentPoint"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   Intersector . overlapConvexPolygons ( p 1  ,    p 2  ,    null )  ;", "}", "METHOD_END"], "methodName": ["overlapConvexPolygons"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   Intersector . overlapConvexPolygons ( p 1  . getTransformedVertices (  )  ,    p 2  . getTransformedVertices (  )  ,    mtv )  ;", "}", "METHOD_END"], "methodName": ["overlapConvexPolygons"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   Intersector . overlapConvexPolygons ( verts 1  ,     0  ,    verts 1  . length ,    verts 2  ,     0  ,    verts 2  . length ,    mtv )  ;", "}", "METHOD_END"], "methodName": ["overlapConvexPolygons"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   overlap    =    Float . MAX _ VALUE ;", "float   smallestAxisX    =     0  ;", "float   smallestAxisY    =     0  ;", "int   numInNormalDir ;", "int   end 1     =    offset 1     +    count 1  ;", "int   end 2     =    offset 2     +    count 2  ;", "for    ( int   i    =    offset 1  ;    i    <    end 1  ;    i    +  =     2  )     {", "float   x 1     =    verts 1  [ i ]  ;", "float   y 1     =    verts 1  [  ( i    +     1  )  ]  ;", "float   x 2     =    verts 1  [  (  ( i    +     2  )     %    count 1  )  ]  ;", "float   y 2     =    verts 1  [  (  ( i    +     3  )     %    count 1  )  ]  ;", "float   axisX    =    y 1     -    y 2  ;", "float   axisY    =     -  ( x 1     -    x 2  )  ;", "final   float   length    =     (  ( float )     ( Math . sqrt (  (  ( axisX    *    axisX )     +     ( axisY    *    axisY )  )  )  )  )  ;", "axisX    /  =    length ;", "axisY    /  =    length ;", "float   min 1     =     ( axisX    *     ( verts 1  [  0  ]  )  )     +     ( axisY    *     ( verts 1  [  1  ]  )  )  ;", "float   max 1     =    min 1  ;", "for    ( int   j    =    offset 1  ;    j    <    end 1  ;    j    +  =     2  )     {", "float   p    =     ( axisX    *     ( verts 1  [ j ]  )  )     +     ( axisY    *     ( verts 1  [  ( j    +     1  )  ]  )  )  ;", "if    ( p    <    min 1  )     {", "min 1     =    p ;", "} else", "if    ( p    >    max 1  )     {", "max 1     =    p ;", "}", "}", "numInNormalDir    =     0  ;", "float   min 2     =     ( axisX    *     ( verts 2  [  0  ]  )  )     +     ( axisY    *     ( verts 2  [  1  ]  )  )  ;", "float   max 2     =    min 2  ;", "for    ( int   j    =    offset 2  ;    j    <    end 2  ;    j    +  =     2  )     {", "numInNormalDir    -  =     . pointLineSide ( x 1  ,    y 1  ,    x 2  ,    y 2  ,    verts 2  [ j ]  ,    verts 2  [  ( j    +     1  )  ]  )  ;", "float   p    =     ( axisX    *     ( verts 2  [ j ]  )  )     +     ( axisY    *     ( verts 2  [  ( j    +     1  )  ]  )  )  ;", "if    ( p    <    min 2  )     {", "min 2     =    p ;", "} else", "if    ( p    >    max 2  )     {", "max 2     =    p ;", "}", "}", "if    (  !  (  (  ( min 1     <  =    min 2  )     &  &     ( max 1     >  =    min 2  )  )     |  |     (  ( min 2     <  =    min 1  )     &  &     ( max 2     >  =    min 1  )  )  )  )     {", "return   false ;", "} else    {", "float   o    =     ( Math . min ( max 1  ,    max 2  )  )     -     ( Math . max ( min 1  ,    min 2  )  )  ;", "if    (  (  ( min 1     <    min 2  )     &  &     ( max 1     >    max 2  )  )     |  |     (  ( min 2     <    min 1  )     &  &     ( max 2     >    max 1  )  )  )     {", "float   mins    =    Math . abs (  ( min 1     -    min 2  )  )  ;", "float   maxs    =    Math . abs (  ( max 1     -    max 2  )  )  ;", "if    ( mins    <    maxs )     {", "o    +  =    mins ;", "} else    {", "o    +  =    maxs ;", "}", "}", "if    ( o    <    overlap )     {", "overlap    =    o ;", "smallestAxisX    =     ( numInNormalDir    >  =     0  )     ?    axisX    :     - axisX ;", "smallestAxisY    =     ( numInNormalDir    >  =     0  )     ?    axisY    :     - axisY ;", "}", "}", "}", "for    ( int   i    =    offset 2  ;    i    <    end 2  ;    i    +  =     2  )     {", "float   x 1     =    verts 2  [ i ]  ;", "float   y 1     =    verts 2  [  ( i    +     1  )  ]  ;", "float   x 2     =    verts 2  [  (  ( i    +     2  )     %    count 2  )  ]  ;", "float   y 2     =    verts 2  [  (  ( i    +     3  )     %    count 2  )  ]  ;", "float   axisX    =    y 1     -    y 2  ;", "float   axisY    =     -  ( x 1     -    x 2  )  ;", "final   float   length    =     (  ( float )     ( Math . sqrt (  (  ( axisX    *    axisX )     +     ( axisY    *    axisY )  )  )  )  )  ;", "axisX    /  =    length ;", "axisY    /  =    length ;", "numInNormalDir    =     0  ;", "float   min 1     =     ( axisX    *     ( verts 1  [  0  ]  )  )     +     ( axisY    *     ( verts 1  [  1  ]  )  )  ;", "float   max 1     =    min 1  ;", "for    ( int   j    =    offset 1  ;    j    <    end 1  ;    j    +  =     2  )     {", "float   p    =     ( axisX    *     ( verts 1  [ j ]  )  )     +     ( axisY    *     ( verts 1  [  ( j    +     1  )  ]  )  )  ;", "numInNormalDir    -  =     . pointLineSide ( x 1  ,    y 1  ,    x 2  ,    y 2  ,    verts 1  [ j ]  ,    verts 1  [  ( j    +     1  )  ]  )  ;", "if    ( p    <    min 1  )     {", "min 1     =    p ;", "} else", "if    ( p    >    max 1  )     {", "max 1     =    p ;", "}", "}", "float   min 2     =     ( axisX    *     ( verts 2  [  0  ]  )  )     +     ( axisY    *     ( verts 2  [  1  ]  )  )  ;", "float   max 2     =    min 2  ;", "for    ( int   j    =    offset 2  ;    j    <    end 2  ;    j    +  =     2  )     {", "float   p    =     ( axisX    *     ( verts 2  [ j ]  )  )     +     ( axisY    *     ( verts 2  [  ( j    +     1  )  ]  )  )  ;", "if    ( p    <    min 2  )     {", "min 2     =    p ;", "} else", "if    ( p    >    max 2  )     {", "max 2     =    p ;", "}", "}", "if    (  !  (  (  ( min 1     <  =    min 2  )     &  &     ( max 1     >  =    min 2  )  )     |  |     (  ( min 2     <  =    min 1  )     &  &     ( max 2     >  =    min 1  )  )  )  )     {", "return   false ;", "} else    {", "float   o    =     ( Math . min ( max 1  ,    max 2  )  )     -     ( Math . max ( min 1  ,    min 2  )  )  ;", "if    (  (  ( min 1     <    min 2  )     &  &     ( max 1     >    max 2  )  )     |  |     (  ( min 2     <    min 1  )     &  &     ( max 2     >    max 1  )  )  )     {", "float   mins    =    Math . abs (  ( min 1     -    min 2  )  )  ;", "float   maxs    =    Math . abs (  ( max 1     -    max 2  )  )  ;", "if    ( mins    <    maxs )     {", "o    +  =    mins ;", "} else    {", "o    +  =    maxs ;", "}", "}", "if    ( o    <    overlap )     {", "overlap    =    o ;", "smallestAxisX    =     ( numInNormalDir    <     0  )     ?    axisX    :     - axisX ;", "smallestAxisY    =     ( numInNormalDir    <     0  )     ?    axisY    :     - axisY ;", "}", "}", "}", "if    ( mtv    !  =    null )     {", "mtv . normal . set ( smallestAxisX ,    smallestAxisY )  ;", "mtv . depth    =    overlap ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["overlapConvexPolygons"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   c 1  . overlaps ( c 2  )  ;", "}", "METHOD_END"], "methodName": ["overlaps"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   closestX    =    c . x ;", "float   closestY    =    c . y ;", "if    (  ( c . x )     <     ( r . x )  )     {", "closestX    =    r . x ;", "} else", "if    (  ( c . x )     >     (  ( r . x )     +     ( r . width )  )  )     {", "closestX    =     ( r . x )     +     ( r . width )  ;", "}", "if    (  ( c . y )     <     ( r . y )  )     {", "closestY    =    r . y ;", "} else", "if    (  ( c . y )     >     (  ( r . y )     +     ( r . height )  )  )     {", "closestY    =     ( r . y )     +     ( r . height )  ;", "}", "closestX    =    closestX    -     ( c . x )  ;", "closestX    *  =    closestX ;", "closestY    =    closestY    -     ( c . y )  ;", "closestY    *  =    closestY ;", "return    ( closestX    +    closestY )     <     (  ( c . radius )     *     ( c . radius )  )  ;", "}", "METHOD_END"], "methodName": ["overlaps"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return   r 1  . overlaps ( r 2  )  ;", "}", "METHOD_END"], "methodName": ["overlaps"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( Math . signum (  (  (  (  ( linePoint 2  . x )     -     ( linePoint 1  . x )  )     *     (  ( point . y )     -     ( linePoint 1  . y )  )  )     -     (  (  ( linePoint 2  . y )     -     ( linePoint 1  . y )  )     *     (  ( point . x )     -     ( linePoint 1  . x )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["pointLineSide"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( Math . signum (  (  (  ( linePoint 2 X    -    linePoint 1 X )     *     ( pointY    -    linePoint 1 Y )  )     -     (  ( linePoint 2 Y    -    linePoint 1 Y )     *     ( pointX    -    linePoint 1 X )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["pointLineSide"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "float   t    =    Intersector . intersectLinePlane ( vertices [ s ]  ,    vertices [  ( s    +     1  )  ]  ,    vertices [  ( s    +     2  )  ]  ,    vertices [ e ]  ,    vertices [  ( e    +     1  )  ]  ,    vertices [  ( e    +     2  )  ]  ,    plane ,    Intersector . intersection )  ;", "split [  ( offset    +     0  )  ]     =    Intersector . intersection . x ;", "split [  ( offset    +     1  )  ]     =    Intersector . intersection . y ;", "split [  ( offset    +     2  )  ]     =    Intersector . intersection . z ;", "for    ( int   i    =     3  ;    i    <    stride ;    i +  +  )     {", "float   a    =    vertices [  ( s    +    i )  ]  ;", "float   b    =    vertices [  ( e    +    i )  ]  ;", "split [  ( offset    +    i )  ]     =    a    +     ( t    *     ( b    -    a )  )  ;", "}", "}", "METHOD_END"], "methodName": ["splitEdge"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "int   stride    =     ( triangle . length )     /     3  ;", "boolean   r 1     =     ( plane . testPoint ( triangle [  0  ]  ,    triangle [  1  ]  ,    triangle [  2  ]  )  )     =  =     ( Plane . PlaneSide . Back )  ;", "boolean   r 2     =     ( plane . testPoint ( triangle [  (  0     +    stride )  ]  ,    triangle [  (  1     +    stride )  ]  ,    triangle [  (  2     +    stride )  ]  )  )     =  =     ( Plane . PlaneSide . Back )  ;", "boolean   r 3     =     ( plane . testPoint ( triangle [  (  0     +     ( stride    *     2  )  )  ]  ,    triangle [  (  1     +     ( stride    *     2  )  )  ]  ,    triangle [  (  2     +     ( stride    *     2  )  )  ]  )  )     =  =     ( Plane . PlaneSide . Back )  ;", "split . reset (  )  ;", "if    (  ( r 1     =  =    r 2  )     &  &     ( r 2     =  =    r 3  )  )     {", "split . total    =     1  ;", "if    ( r 1  )     {", "split . numBack    =     1  ;", "System . arraycopy ( triangle ,     0  ,    split . back ,     0  ,    triangle . length )  ;", "} else    {", "split . numFront    =     1  ;", "System . arraycopy ( triangle ,     0  ,    split . front ,     0  ,    triangle . length )  ;", "}", "return ;", "}", "split . total    =     3  ;", "split . numFront    =     (  ( r 1     ?     0     :     1  )     +     ( r 2     ?     0     :     1  )  )     +     ( r 3     ?     0     :     1  )  ;", "split . numBack    =     ( split . total )     -     ( split . numFront )  ;", "split . setSide (  (  ! r 1  )  )  ;", "int   first    =     0  ;", "int   second    =    stride ;", "if    ( r 1     !  =    r 2  )     {", ". splitEdge ( triangle ,    first ,    second ,    stride ,    plane ,    split . edgeSplit ,     0  )  ;", "split . add ( triangle ,    first ,    stride )  ;", "split . add ( split . edgeSplit ,     0  ,    stride )  ;", "split . setSide (  (  !  ( split . getSide (  )  )  )  )  ;", "split . add ( split . edgeSplit ,     0  ,    stride )  ;", "} else    {", "split . add ( triangle ,    first ,    stride )  ;", "}", "first    =    stride ;", "second    =    stride    +    stride ;", "if    ( r 2     !  =    r 3  )     {", ". splitEdge ( triangle ,    first ,    second ,    stride ,    plane ,    split . edgeSplit ,     0  )  ;", "split . add ( triangle ,    first ,    stride )  ;", "split . add ( split . edgeSplit ,     0  ,    stride )  ;", "split . setSide (  (  !  ( split . getSide (  )  )  )  )  ;", "split . add ( split . edgeSplit ,     0  ,    stride )  ;", "} else    {", "split . add ( triangle ,    first ,    stride )  ;", "}", "first    =    stride    +    stride ;", "second    =     0  ;", "if    ( r 3     !  =    r 1  )     {", ". splitEdge ( triangle ,    first ,    second ,    stride ,    plane ,    split . edgeSplit ,     0  )  ;", "split . add ( triangle ,    first ,    stride )  ;", "split . add ( split . edgeSplit ,     0  ,    stride )  ;", "split . setSide (  (  !  ( split . getSide (  )  )  )  )  ;", "split . add ( split . edgeSplit ,     0  ,    stride )  ;", "} else    {", "split . add ( triangle ,    first ,    stride )  ;", "}", "if    (  ( split . numFront )     =  =     2  )     {", "System . arraycopy ( split . front ,     ( stride    *     2  )  ,    split . front ,     ( stride    *     3  )  ,     ( stride    *     2  )  )  ;", "System . arraycopy ( split . front ,     0  ,    split . front ,     ( stride    *     5  )  ,    stride )  ;", "} else    {", "System . arraycopy ( split . back ,     ( stride    *     2  )  ,    split . back ,     ( stride    *     3  )  ,     ( stride    *     2  )  )  ;", "System . arraycopy ( split . back ,     0  ,    split . back ,     ( stride    *     5  )  ,    stride )  ;", "}", "}", "METHOD_END"], "methodName": ["splitTriangle"], "fileName": "com.badlogic.gdx.math.Intersector"}, {"methodBody": ["METHOD_START", "{", "Plane   plane    =    new   Plane ( new   Vector 3  (  1  ,     0  ,     0  )  ,     0  )  ;", "Intersector . SplitTriangle   split    =    new   Intersector . SplitTriangle (  3  )  ;", "{", "float [  ]    fTriangle    =    new   float [  ]  {     -  1  0  ,     0  ,     1  0  ,     -  1  ,     0  ,     0  ,     -  1  2  ,     0  ,     1  0     }  ;", "Intersector . splitTriangle ( fTriangle ,    plane ,    split )  ;", "assertTrue (  (  ( split . numBack )     =  =     1  )  )  ;", "assertTrue (  (  ( split . numFront )     =  =     0  )  )  ;", "assertTrue (  (  ( split . total )     =  =     1  )  )  ;", "assertTrue (  . triangleEquals ( split . back ,     0  ,     3  ,    fTriangle )  )  ;", "fTriangle [  4  ]     =     5  .  0 F ;", "assertFalse (  \" Test   is   broken \"  ,     . triangleEquals ( split . back ,     0  ,     3  ,    fTriangle )  )  ;", "}", "{", "float [  ]    fTriangle    =    new   float [  ]  {     1  0  ,     0  ,     1  0  ,     1  ,     0  ,     0  ,     1  2  ,     0  ,     1  0     }  ;", "Intersector . splitTriangle ( fTriangle ,    plane ,    split )  ;", "assertTrue (  (  ( split . numBack )     =  =     0  )  )  ;", "assertTrue (  (  ( split . numFront )     =  =     1  )  )  ;", "assertTrue (  (  ( split . total )     =  =     1  )  )  ;", "assertTrue (  . triangleEquals ( split . front ,     0  ,     3  ,    fTriangle )  )  ;", "}", "{", "float [  ]    triangle    =    new   float [  ]  {     -  1  0  ,     0  ,     1  0  ,     1  0  ,     0  ,     0  ,     -  1  0  ,     0  ,     -  1  0     }  ;", "Intersector . splitTriangle ( triangle ,    plane ,    split )  ;", "assertTrue (  (  ( split . numBack )     =  =     2  )  )  ;", "assertTrue (  (  ( split . numFront )     =  =     1  )  )  ;", "assertTrue (  (  ( split . total )     =  =     3  )  )  ;", "assertTrue (  . triangleEquals ( split . front ,     0  ,     3  ,    new   float [  ]  {     0  ,     0  ,     5  ,     1  0  ,     0  ,     0  ,     0  ,     0  ,     -  5     }  )  )  ;", "float [  ]  [  ]    firstWay    =    new   float [  ]  [  ]  {    new   float [  ]  {     -  1  0  ,     0  ,     1  0  ,     0  ,     0  ,     5  ,     0  ,     0  ,     -  5     }  ,    new   float [  ]  {     -  1  0  ,     0  ,     1  0  ,     0  ,     0  ,     -  5  ,     -  1  0  ,     0  ,     -  1  0     }     }  ;", "float [  ]  [  ]    secondWay    =    new   float [  ]  [  ]  {    new   float [  ]  {     -  1  0  ,     0  ,     1  0  ,     0  ,     0  ,     5  ,     -  1  0  ,     0  ,     -  1  0     }  ,    new   float [  ]  {     0  ,     0  ,     5  ,     0  ,     0  ,     -  5  ,     -  1  0  ,     0  ,     -  1  0     }     }  ;", "float [  ]    base    =    split . back ;", "boolean   first    =     (  (  . triangleEquals ( base ,     0  ,     3  ,    firstWay [  0  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    firstWay [  1  ]  )  )  )     |  |     (  (  . triangleEquals ( base ,     0  ,     3  ,    firstWay [  1  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    firstWay [  0  ]  )  )  )  ;", "boolean   second    =     (  (  . triangleEquals ( base ,     0  ,     3  ,    secondWay [  0  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    secondWay [  1  ]  )  )  )     |  |     (  (  . triangleEquals ( base ,     0  ,     3  ,    secondWay [  1  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    secondWay [  0  ]  )  )  )  ;", "assertTrue (  (  (  (  (  \" Either   first   or   second   way   must   be   right    ( first :     \"     +    first )     +     \"  ,    second :     \"  )     +    second )     +     \"  )  \"  )  ,     ( first    ^    second )  )  ;", "}", "{", "float [  ]    triangle    =    new   float [  ]  {     1  0  ,     0  ,     1  0  ,     -  1  0  ,     0  ,     0  ,     1  0  ,     0  ,     -  1  0     }  ;", "Intersector . splitTriangle ( triangle ,    plane ,    split )  ;", "assertTrue (  (  ( split . numBack )     =  =     1  )  )  ;", "assertTrue (  (  ( split . numFront )     =  =     2  )  )  ;", "assertTrue (  (  ( split . total )     =  =     3  )  )  ;", "assertTrue (  . triangleEquals ( split . back ,     0  ,     3  ,    new   float [  ]  {     0  ,     0  ,     5  ,     -  1  0  ,     0  ,     0  ,     0  ,     0  ,     -  5     }  )  )  ;", "float [  ]  [  ]    firstWay    =    new   float [  ]  [  ]  {    new   float [  ]  {     1  0  ,     0  ,     1  0  ,     0  ,     0  ,     5  ,     0  ,     0  ,     -  5     }  ,    new   float [  ]  {     1  0  ,     0  ,     1  0  ,     0  ,     0  ,     -  5  ,     1  0  ,     0  ,     -  1  0     }     }  ;", "float [  ]  [  ]    secondWay    =    new   float [  ]  [  ]  {    new   float [  ]  {     1  0  ,     0  ,     1  0  ,     0  ,     0  ,     5  ,     1  0  ,     0  ,     -  1  0     }  ,    new   float [  ]  {     0  ,     0  ,     5  ,     0  ,     0  ,     -  5  ,     1  0  ,     0  ,     -  1  0     }     }  ;", "float [  ]    base    =    split . front ;", "boolean   first    =     (  (  . triangleEquals ( base ,     0  ,     3  ,    firstWay [  0  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    firstWay [  1  ]  )  )  )     |  |     (  (  . triangleEquals ( base ,     0  ,     3  ,    firstWay [  1  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    firstWay [  0  ]  )  )  )  ;", "boolean   second    =     (  (  . triangleEquals ( base ,     0  ,     3  ,    secondWay [  0  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    secondWay [  1  ]  )  )  )     |  |     (  (  . triangleEquals ( base ,     0  ,     3  ,    secondWay [  1  ]  )  )     &  &     (  . triangleEquals ( base ,     9  ,     3  ,    secondWay [  0  ]  )  )  )  ;", "assertTrue (  (  (  (  (  \" Either   first   or   second   way   must   be   right    ( first :     \"     +    first )     +     \"  ,    second :     \"  )     +    second )     +     \"  )  \"  )  ,     ( first    ^    second )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSplitTriangle"], "fileName": "com.badlogic.gdx.math.IntersectorTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  ( stride    >  =     3  )  )  ;", "assertTrue (  (  (  ( base . length )     -    baseOffset )     >  =     9  )  )  ;", "assertTrue (  (  ( p . length )     =  =     9  )  )  ;", "int   offset    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "int   b    =    baseOffset    +     ( i    *    stride )  ;", "if    (  (  ( MathUtils . isEqual ( base [ b ]  ,    p [  0  ]  )  )     &  &     ( MathUtils . isEqual ( base [  ( b    +     1  )  ]  ,    p [  1  ]  )  )  )     &  &     ( MathUtils . isEqual ( base [  ( b    +     2  )  ]  ,    p [  2  ]  )  )  )     {", "offset    =    i ;", "break ;", "}", "}", "assertTrue (  \" Triangles   do   not   have   mon   first   vertex .  \"  ,     ( offset    !  =     (  -  1  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "int   b    =    baseOffset    +     (  (  ( offset    +    i )     *    stride )     %     (  3     *    stride )  )  ;", "int   c    =    i    *    stride ;", "if    (  (  (  !  ( MathUtils . isEqual ( base [ b ]  ,    p [ c ]  )  )  )     |  |     (  !  ( MathUtils . isEqual ( base [  ( b    +     1  )  ]  ,    p [  ( c    +     1  )  ]  )  )  )  )     |  |     (  !  ( MathUtils . isEqual ( base [  ( b    +     2  )  ]  ,    p [  ( c    +     2  )  ]  )  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["triangleEquals"], "fileName": "com.badlogic.gdx.math.IntersectorTest"}, {"methodBody": ["METHOD_START", "{", "if    ( x    =  =     0  .  0 F )     {", "if    ( y    >     0  .  0 F )", "return    (  . PI )     /     2  ;", "if    ( y    =  =     0  .  0 F )", "return    0  .  0 F ;", "return    (  -  (  . PI )  )     /     2  ;", "}", "final   float   atan ;", "final   float   z    =    y    /    x ;", "if    (  ( Math . abs ( z )  )     <     1  .  0 F )     {", "atan    =    z    /     (  1  .  0 F    +     (  (  0  .  2  8 F    *    z )     *    z )  )  ;", "if    ( x    <     0  .  0 F )", "return   atan    +     ( y    <     0  .  0 F    ?     -  (  . PI )     :     . PI )  ;", "return   atan ;", "}", "atan    =     (  (  . PI )     /     2  )     -     ( z    /     (  ( z    *    z )     +     0  .  2  8 F )  )  ;", "return   y    <     0  .  0 F    ?    atan    -     (  . PI )     :    atan ;", "}", "METHOD_END"], "methodName": ["atan2"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . BIG _ ENOUGH _ INT )     -     (  ( int )     (  ( MathUtils . BIG _ ENOUGH _ FLOOR )     -    value )  )  ;", "}", "METHOD_END"], "methodName": ["ceil"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( value    +     ( MathUtils . CEIL )  )  )  ;", "}", "METHOD_END"], "methodName": ["ceilPositive"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    <    min )", "return   min ;", "if    ( value    >    x )", "return   x ;", "return   value ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    <    min )", "return   min ;", "if    ( value    >    x )", "return   x ;", "return   value ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    <    min )", "return   min ;", "if    ( value    >    x )", "return   x ;", "return   value ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    <    min )", "return   min ;", "if    ( value    >    x )", "return   x ;", "return   value ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    <    min )", "return   min ;", "if    ( value    >    x )", "return   x ;", "return   value ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . Sin . table [  (  (  ( int )     (  ( radians    +     (  ( MathUtils . PI )     /     2  )  )     *     ( MathUtils . radToIndex )  )  )     &     ( MathUtils . SIN _ MASK )  )  ]  ;", "}", "METHOD_END"], "methodName": ["cos"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . Sin . table [  (  (  ( int )     (  ( degrees    +     9  0  )     *     ( MathUtils . degToIndex )  )  )     &     ( MathUtils . SIN _ MASK )  )  ]  ;", "}", "METHOD_END"], "methodName": ["cosDeg"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( value    +     ( MathUtils . BIG _ ENOUGH _ FLOOR )  )  )     -     ( MathUtils . BIG _ ENOUGH _ INT )  ;", "}", "METHOD_END"], "methodName": ["floor"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["floorPositive"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( Math . abs (  ( a    -    b )  )  )     <  =     ( MathUtils . FLOAT _ ROUNDING _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["isEqual"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( Math . abs (  ( a    -    b )  )  )     <  =    tolerance ;", "}", "METHOD_END"], "methodName": ["isEqual"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( value    !  =     0  )     &  &     (  ( value    &     ( value    -     1  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isPowerOfTwo"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( Math . abs ( value )  )     <  =     ( MathUtils . FLOAT _ ROUNDING _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["isZero"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( Math . abs ( value )  )     <  =    tolerance ;", "}", "METHOD_END"], "methodName": ["isZero"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   fromValue    +     (  ( toValue    -    fromValue )     *    progress )  ;", "}", "METHOD_END"], "methodName": ["lerp"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "float   delta    =     (  (  (  ( toRadians    -    fromRadians )     +     ( MathUtils . PI 2  )  )     +     ( MathUtils . PI )  )     %     ( MathUtils . PI 2  )  )     -     ( MathUtils . PI )  ;", "return    (  ( fromRadians    +     ( delta    *    progress )  )     +     ( MathUtils . PI 2  )  )     %     ( MathUtils . PI 2  )  ;", "}", "METHOD_END"], "methodName": ["lerpAngle"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "float   delta    =     (  (  (  ( toDegrees    -    fromDegrees )     +     3  6  0  )     +     1  8  0  )     %     3  6  0  )     -     1  8  0  ;", "return    (  ( fromDegrees    +     ( delta    *    progress )  )     +     3  6  0  )     %     3  6  0  ;", "}", "METHOD_END"], "methodName": ["lerpAngleDeg"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     (  ( Math . log ( value )  )     /     ( Math . log ( a )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["log"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . log (  2  ,    value )  ;", "}", "METHOD_END"], "methodName": ["log2"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =     0  )", "return    1  ;", "value -  -  ;", "value    |  =    value    >  >     1  ;", "value    |  =    value    >  >     2  ;", "value    |  =    value    >  >     4  ;", "value    |  =    value    >  >     8  ;", "value    |  =    value    >  >     1  6  ;", "return   value    +     1  ;", "}", "METHOD_END"], "methodName": ["nextPowerOfTwo"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . random . nextFloat (  )  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . random . nextFloat (  )  )     *    range ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   start    +     (  ( MathUtils . random . nextFloat (  )  )     *     ( end    -    start )  )  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . random . nextInt (  ( range    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   start    +     ( MathUtils . random . nextInt (  (  ( end    -    start )     +     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( long )     (  ( MathUtils . random . nextDouble (  )  )     *    range )  )  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   start    +     (  ( long )     (  ( MathUtils . random . nextDouble (  )  )     *     ( end    -    start )  )  )  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . random . nextBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["randomBoolean"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . random (  )  )     <    chance ;", "}", "METHOD_END"], "methodName": ["randomBoolean"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    1     |     (  ( MathUtils . random . nextInt (  )  )     >  >     3  1  )  ;", "}", "METHOD_END"], "methodName": ["randomSign"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . random . nextFloat (  )  )     -     ( MathUtils . random . nextFloat (  )  )  ;", "}", "METHOD_END"], "methodName": ["randomTriangular"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( MathUtils . random . nextFloat (  )  )     -     ( MathUtils . random . nextFloat (  )  )  )     *    max ;", "}", "METHOD_END"], "methodName": ["randomTriangular"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . randomTriangular ( min ,    max ,     (  ( min    +    max )     *     0  .  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["randomTriangular"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "float   u    =    MathUtils . random . nextFloat (  )  ;", "float   d    =    max    -    min ;", "if    ( u    <  =     (  ( mode    -    min )     /    d )  )", "return   min    +     (  ( float )     ( Math . sqrt (  (  ( u    *    d )     *     ( mode    -    min )  )  )  )  )  ;", "return   max    -     (  ( float )     ( Math . sqrt (  (  (  (  1     -    u )     *    d )     *     ( max    -    mode )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["randomTriangular"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( value    +     ( MathUtils . BIG _ ENOUGH _ ROUND )  )  )     -     ( MathUtils . BIG _ ENOUGH _ INT )  ;", "}", "METHOD_END"], "methodName": ["round"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( value    +     0  .  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["roundPositive"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . Sin . table [  (  (  ( int )     ( radians    *     ( MathUtils . radToIndex )  )  )     &     ( MathUtils . SIN _ MASK )  )  ]  ;", "}", "METHOD_END"], "methodName": ["sin"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . Sin . table [  (  (  ( int )     ( degrees    *     ( MathUtils . degToIndex )  )  )     &     ( MathUtils . SIN _ MASK )  )  ]  ;", "}", "METHOD_END"], "methodName": ["sinDeg"], "fileName": "com.badlogic.gdx.math.MathUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  0  ,    MathUtils . lerpAngleDeg (  1  0  ,     3  0  ,     0  .  0 F )  ,     0  .  0  1 F )  ;", "assertEquals (  2  0  ,    MathUtils . lerpAngleDeg (  1  0  ,     3  0  ,     0  .  5 F )  ,     0  .  0  1 F )  ;", "assertEquals (  3  0  ,    MathUtils . lerpAngleDeg (  1  0  ,     3  0  ,     1  .  0 F )  ,     0  .  0  1 F )  ;", "}", "METHOD_END"], "methodName": ["lerpAngleDeg"], "fileName": "com.badlogic.gdx.math.MathUtilsTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  3  5  0  ,    MathUtils . lerpAngleDeg (  3  5  0  ,     1  0  ,     0  .  0 F )  ,     0  .  0  1 F )  ;", "assertEquals (  0  ,    MathUtils . lerpAngleDeg (  3  5  0  ,     1  0  ,     0  .  5 F )  ,     0  .  0  1 F )  ;", "assertEquals (  1  0  ,    MathUtils . lerpAngleDeg (  3  5  0  ,     1  0  ,     1  .  0 F )  ,     0  .  0  1 F )  ;", "}", "METHOD_END"], "methodName": ["lerpAngleDegCrossingZero"], "fileName": "com.badlogic.gdx.math.MathUtilsTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  0  ,    MathUtils . lerpAngleDeg (  1  0  ,     3  5  0  ,     0  .  0 F )  ,     0  .  0  1 F )  ;", "assertEquals (  0  ,    MathUtils . lerpAngleDeg (  1  0  ,     3  5  0  ,     0  .  5 F )  ,     0  .  0  1 F )  ;", "assertEquals (  3  5  0  ,    MathUtils . lerpAngleDeg (  1  0  ,     3  5  0  ,     1  .  0 F )  ,     0  .  0  1 F )  ;", "}", "METHOD_END"], "methodName": ["lerpAngleDegCrossingZeroBackwards"], "fileName": "com.badlogic.gdx.math.MathUtilsTest"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "return    (  (  (  (  (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  2  ]  )  )     +     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  0  ]  )  )  )     +     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  1  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  1  ]  )  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  2  ]  )  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["det"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . radiansToDegrees )     *     (  ( float )     ( Math . atan 2  ( val [ Matrix 3  . M 1  0  ]  ,    val [ Matrix 3  . M 0  0  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . atan 2  ( val [ Matrix 3  . M 1  0  ]  ,    val [ Matrix 3  . M 0  0  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRotationRad"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "scale . x    =     (  ( float )     ( Math . sqrt (  (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 0  0  ]  )  )     +     (  ( val [  . M 0  1  ]  )     *     ( val [  . M 0  1  ]  )  )  )  )  )  )  ;", "scale . y    =     (  ( float )     ( Math . sqrt (  (  (  ( val [  . M 1  0  ]  )     *     ( val [  . M 1  0  ]  )  )     +     (  ( val [  . M 1  1  ]  )     *     ( val [  . M 1  1  ]  )  )  )  )  )  )  ;", "return   scale ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "position . x    =    val [ Matrix 3  . M 0  2  ]  ;", "position . y    =    val [ Matrix 3  . M 1  2  ]  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getTranslation"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "return   val ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =     1  ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =     1  ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["idt"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float   det    =    det (  )  ;", "if    ( det    =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" Can ' t   invert   a   singular   matrix \"  )  ;", "float   inv _ det    =     1  .  0 F    /    det ;", "float [  ]    tmp    =    this . tmp ;", "float [  ]    val    =    this . val ;", "tmp [ Matrix 3  . M 0  0  ]     =     (  ( val [ Matrix 3  . M 1  1  ]  )     *     ( val [ Matrix 3  . M 2  2  ]  )  )     -     (  ( val [ Matrix 3  . M 2  1  ]  )     *     ( val [ Matrix 3  . M 1  2  ]  )  )  ;", "tmp [ Matrix 3  . M 1  0  ]     =     (  ( val [ Matrix 3  . M 2  0  ]  )     *     ( val [ Matrix 3  . M 1  2  ]  )  )     -     (  ( val [ Matrix 3  . M 1  0  ]  )     *     ( val [ Matrix 3  . M 2  2  ]  )  )  ;", "tmp [ Matrix 3  . M 2  0  ]     =     (  ( val [ Matrix 3  . M 1  0  ]  )     *     ( val [ Matrix 3  . M 2  1  ]  )  )     -     (  ( val [ Matrix 3  . M 2  0  ]  )     *     ( val [ Matrix 3  . M 1  1  ]  )  )  ;", "tmp [ Matrix 3  . M 0  1  ]     =     (  ( val [ Matrix 3  . M 2  1  ]  )     *     ( val [ Matrix 3  . M 0  2  ]  )  )     -     (  ( val [ Matrix 3  . M 0  1  ]  )     *     ( val [ Matrix 3  . M 2  2  ]  )  )  ;", "tmp [ Matrix 3  . M 1  1  ]     =     (  ( val [ Matrix 3  . M 0  0  ]  )     *     ( val [ Matrix 3  . M 2  2  ]  )  )     -     (  ( val [ Matrix 3  . M 2  0  ]  )     *     ( val [ Matrix 3  . M 0  2  ]  )  )  ;", "tmp [ Matrix 3  . M 2  1  ]     =     (  ( val [ Matrix 3  . M 2  0  ]  )     *     ( val [ Matrix 3  . M 0  1  ]  )  )     -     (  ( val [ Matrix 3  . M 0  0  ]  )     *     ( val [ Matrix 3  . M 2  1  ]  )  )  ;", "tmp [ Matrix 3  . M 0  2  ]     =     (  ( val [ Matrix 3  . M 0  1  ]  )     *     ( val [ Matrix 3  . M 1  2  ]  )  )     -     (  ( val [ Matrix 3  . M 1  1  ]  )     *     ( val [ Matrix 3  . M 0  2  ]  )  )  ;", "tmp [ Matrix 3  . M 1  2  ]     =     (  ( val [ Matrix 3  . M 1  0  ]  )     *     ( val [ Matrix 3  . M 0  2  ]  )  )     -     (  ( val [ Matrix 3  . M 0  0  ]  )     *     ( val [ Matrix 3  . M 1  2  ]  )  )  ;", "tmp [ Matrix 3  . M 2  2  ]     =     (  ( val [ Matrix 3  . M 0  0  ]  )     *     ( val [ Matrix 3  . M 1  1  ]  )  )     -     (  ( val [ Matrix 3  . M 1  0  ]  )     *     ( val [ Matrix 3  . M 0  1  ]  )  )  ;", "val [ Matrix 3  . M 0  0  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 0  0  ]  )  ;", "val [ Matrix 3  . M 1  0  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 1  0  ]  )  ;", "val [ Matrix 3  . M 2  0  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 2  0  ]  )  ;", "val [ Matrix 3  . M 0  1  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 0  1  ]  )  ;", "val [ Matrix 3  . M 1  1  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 1  1  ]  )  ;", "val [ Matrix 3  . M 2  1  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 2  1  ]  )  ;", "val [ Matrix 3  . M 0  2  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 0  2  ]  )  ;", "val [ Matrix 3  . M 1  2  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 1  2  ]  )  ;", "val [ Matrix 3  . M 2  2  ]     =    inv _ det    *     ( tmp [ Matrix 3  . M 2  2  ]  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["inv"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "float   v 0  0     =     (  (  ( val [  . M 0  0  ]  )     *     ( m . val [  . M 0  0  ]  )  )     +     (  ( val [  . M 0  1  ]  )     *     ( m . val [  . M 1  0  ]  )  )  )     +     (  ( val [  . M 0  2  ]  )     *     ( m . val [  . M 2  0  ]  )  )  ;", "float   v 0  1     =     (  (  ( val [  . M 0  0  ]  )     *     ( m . val [  . M 0  1  ]  )  )     +     (  ( val [  . M 0  1  ]  )     *     ( m . val [  . M 1  1  ]  )  )  )     +     (  ( val [  . M 0  2  ]  )     *     ( m . val [  . M 2  1  ]  )  )  ;", "float   v 0  2     =     (  (  ( val [  . M 0  0  ]  )     *     ( m . val [  . M 0  2  ]  )  )     +     (  ( val [  . M 0  1  ]  )     *     ( m . val [  . M 1  2  ]  )  )  )     +     (  ( val [  . M 0  2  ]  )     *     ( m . val [  . M 2  2  ]  )  )  ;", "float   v 1  0     =     (  (  ( val [  . M 1  0  ]  )     *     ( m . val [  . M 0  0  ]  )  )     +     (  ( val [  . M 1  1  ]  )     *     ( m . val [  . M 1  0  ]  )  )  )     +     (  ( val [  . M 1  2  ]  )     *     ( m . val [  . M 2  0  ]  )  )  ;", "float   v 1  1     =     (  (  ( val [  . M 1  0  ]  )     *     ( m . val [  . M 0  1  ]  )  )     +     (  ( val [  . M 1  1  ]  )     *     ( m . val [  . M 1  1  ]  )  )  )     +     (  ( val [  . M 1  2  ]  )     *     ( m . val [  . M 2  1  ]  )  )  ;", "float   v 1  2     =     (  (  ( val [  . M 1  0  ]  )     *     ( m . val [  . M 0  2  ]  )  )     +     (  ( val [  . M 1  1  ]  )     *     ( m . val [  . M 1  2  ]  )  )  )     +     (  ( val [  . M 1  2  ]  )     *     ( m . val [  . M 2  2  ]  )  )  ;", "float   v 2  0     =     (  (  ( val [  . M 2  0  ]  )     *     ( m . val [  . M 0  0  ]  )  )     +     (  ( val [  . M 2  1  ]  )     *     ( m . val [  . M 1  0  ]  )  )  )     +     (  ( val [  . M 2  2  ]  )     *     ( m . val [  . M 2  0  ]  )  )  ;", "float   v 2  1     =     (  (  ( val [  . M 2  0  ]  )     *     ( m . val [  . M 0  1  ]  )  )     +     (  ( val [  . M 2  1  ]  )     *     ( m . val [  . M 1  1  ]  )  )  )     +     (  ( val [  . M 2  2  ]  )     *     ( m . val [  . M 2  1  ]  )  )  ;", "float   v 2  2     =     (  (  ( val [  . M 2  0  ]  )     *     ( m . val [  . M 0  2  ]  )  )     +     (  ( val [  . M 2  1  ]  )     *     ( m . val [  . M 1  2  ]  )  )  )     +     (  ( val [  . M 2  2  ]  )     *     ( m . val [  . M 2  2  ]  )  )  ;", "val [  . M 0  0  ]     =    v 0  0  ;", "val [  . M 1  0  ]     =    v 1  0  ;", "val [  . M 2  0  ]     =    v 2  0  ;", "val [  . M 0  1  ]     =    v 0  1  ;", "val [  . M 1  1  ]     =    v 1  1  ;", "val [  . M 2  1  ]     =    v 2  1  ;", "val [  . M 0  2  ]     =    v 0  2  ;", "val [  . M 1  2  ]     =    v 1  2  ;", "val [  . M 2  2  ]     =    v 2  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float   v 0  0     =     (  (  ( mata [ Matrix 3  . M 0  0  ]  )     *     ( matb [ Matrix 3  . M 0  0  ]  )  )     +     (  ( mata [ Matrix 3  . M 0  1  ]  )     *     ( matb [ Matrix 3  . M 1  0  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 0  2  ]  )     *     ( matb [ Matrix 3  . M 2  0  ]  )  )  ;", "float   v 0  1     =     (  (  ( mata [ Matrix 3  . M 0  0  ]  )     *     ( matb [ Matrix 3  . M 0  1  ]  )  )     +     (  ( mata [ Matrix 3  . M 0  1  ]  )     *     ( matb [ Matrix 3  . M 1  1  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 0  2  ]  )     *     ( matb [ Matrix 3  . M 2  1  ]  )  )  ;", "float   v 0  2     =     (  (  ( mata [ Matrix 3  . M 0  0  ]  )     *     ( matb [ Matrix 3  . M 0  2  ]  )  )     +     (  ( mata [ Matrix 3  . M 0  1  ]  )     *     ( matb [ Matrix 3  . M 1  2  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 0  2  ]  )     *     ( matb [ Matrix 3  . M 2  2  ]  )  )  ;", "float   v 1  0     =     (  (  ( mata [ Matrix 3  . M 1  0  ]  )     *     ( matb [ Matrix 3  . M 0  0  ]  )  )     +     (  ( mata [ Matrix 3  . M 1  1  ]  )     *     ( matb [ Matrix 3  . M 1  0  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 1  2  ]  )     *     ( matb [ Matrix 3  . M 2  0  ]  )  )  ;", "float   v 1  1     =     (  (  ( mata [ Matrix 3  . M 1  0  ]  )     *     ( matb [ Matrix 3  . M 0  1  ]  )  )     +     (  ( mata [ Matrix 3  . M 1  1  ]  )     *     ( matb [ Matrix 3  . M 1  1  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 1  2  ]  )     *     ( matb [ Matrix 3  . M 2  1  ]  )  )  ;", "float   v 1  2     =     (  (  ( mata [ Matrix 3  . M 1  0  ]  )     *     ( matb [ Matrix 3  . M 0  2  ]  )  )     +     (  ( mata [ Matrix 3  . M 1  1  ]  )     *     ( matb [ Matrix 3  . M 1  2  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 1  2  ]  )     *     ( matb [ Matrix 3  . M 2  2  ]  )  )  ;", "float   v 2  0     =     (  (  ( mata [ Matrix 3  . M 2  0  ]  )     *     ( matb [ Matrix 3  . M 0  0  ]  )  )     +     (  ( mata [ Matrix 3  . M 2  1  ]  )     *     ( matb [ Matrix 3  . M 1  0  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 2  2  ]  )     *     ( matb [ Matrix 3  . M 2  0  ]  )  )  ;", "float   v 2  1     =     (  (  ( mata [ Matrix 3  . M 2  0  ]  )     *     ( matb [ Matrix 3  . M 0  1  ]  )  )     +     (  ( mata [ Matrix 3  . M 2  1  ]  )     *     ( matb [ Matrix 3  . M 1  1  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 2  2  ]  )     *     ( matb [ Matrix 3  . M 2  1  ]  )  )  ;", "float   v 2  2     =     (  (  ( mata [ Matrix 3  . M 2  0  ]  )     *     ( matb [ Matrix 3  . M 0  2  ]  )  )     +     (  ( mata [ Matrix 3  . M 2  1  ]  )     *     ( matb [ Matrix 3  . M 1  2  ]  )  )  )     +     (  ( mata [ Matrix 3  . M 2  2  ]  )     *     ( matb [ Matrix 3  . M 2  2  ]  )  )  ;", "mata [ Matrix 3  . M 0  0  ]     =    v 0  0  ;", "mata [ Matrix 3  . M 1  0  ]     =    v 1  0  ;", "mata [ Matrix 3  . M 2  0  ]     =    v 2  0  ;", "mata [ Matrix 3  . M 0  1  ]     =    v 0  1  ;", "mata [ Matrix 3  . M 1  1  ]     =    v 1  1  ;", "mata [ Matrix 3  . M 2  1  ]     =    v 2  1  ;", "mata [ Matrix 3  . M 0  2  ]     =    v 0  2  ;", "mata [ Matrix 3  . M 1  2  ]     =    v 1  2  ;", "mata [ Matrix 3  . M 2  2  ]     =    v 2  2  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "float   v 0  0     =     (  (  ( m . val [  . M 0  0  ]  )     *     ( val [  . M 0  0  ]  )  )     +     (  ( m . val [  . M 0  1  ]  )     *     ( val [  . M 1  0  ]  )  )  )     +     (  ( m . val [  . M 0  2  ]  )     *     ( val [  . M 2  0  ]  )  )  ;", "float   v 0  1     =     (  (  ( m . val [  . M 0  0  ]  )     *     ( val [  . M 0  1  ]  )  )     +     (  ( m . val [  . M 0  1  ]  )     *     ( val [  . M 1  1  ]  )  )  )     +     (  ( m . val [  . M 0  2  ]  )     *     ( val [  . M 2  1  ]  )  )  ;", "float   v 0  2     =     (  (  ( m . val [  . M 0  0  ]  )     *     ( val [  . M 0  2  ]  )  )     +     (  ( m . val [  . M 0  1  ]  )     *     ( val [  . M 1  2  ]  )  )  )     +     (  ( m . val [  . M 0  2  ]  )     *     ( val [  . M 2  2  ]  )  )  ;", "float   v 1  0     =     (  (  ( m . val [  . M 1  0  ]  )     *     ( val [  . M 0  0  ]  )  )     +     (  ( m . val [  . M 1  1  ]  )     *     ( val [  . M 1  0  ]  )  )  )     +     (  ( m . val [  . M 1  2  ]  )     *     ( val [  . M 2  0  ]  )  )  ;", "float   v 1  1     =     (  (  ( m . val [  . M 1  0  ]  )     *     ( val [  . M 0  1  ]  )  )     +     (  ( m . val [  . M 1  1  ]  )     *     ( val [  . M 1  1  ]  )  )  )     +     (  ( m . val [  . M 1  2  ]  )     *     ( val [  . M 2  1  ]  )  )  ;", "float   v 1  2     =     (  (  ( m . val [  . M 1  0  ]  )     *     ( val [  . M 0  2  ]  )  )     +     (  ( m . val [  . M 1  1  ]  )     *     ( val [  . M 1  2  ]  )  )  )     +     (  ( m . val [  . M 1  2  ]  )     *     ( val [  . M 2  2  ]  )  )  ;", "float   v 2  0     =     (  (  ( m . val [  . M 2  0  ]  )     *     ( val [  . M 0  0  ]  )  )     +     (  ( m . val [  . M 2  1  ]  )     *     ( val [  . M 1  0  ]  )  )  )     +     (  ( m . val [  . M 2  2  ]  )     *     ( val [  . M 2  0  ]  )  )  ;", "float   v 2  1     =     (  (  ( m . val [  . M 2  0  ]  )     *     ( val [  . M 0  1  ]  )  )     +     (  ( m . val [  . M 2  1  ]  )     *     ( val [  . M 1  1  ]  )  )  )     +     (  ( m . val [  . M 2  2  ]  )     *     ( val [  . M 2  1  ]  )  )  ;", "float   v 2  2     =     (  (  ( m . val [  . M 2  0  ]  )     *     ( val [  . M 0  2  ]  )  )     +     (  ( m . val [  . M 2  1  ]  )     *     ( val [  . M 1  2  ]  )  )  )     +     (  ( m . val [  . M 2  2  ]  )     *     ( val [  . M 2  2  ]  )  )  ;", "val [  . M 0  0  ]     =    v 0  0  ;", "val [  . M 1  0  ]     =    v 1  0  ;", "val [  . M 2  0  ]     =    v 2  0  ;", "val [  . M 0  1  ]     =    v 0  1  ;", "val [  . M 1  1  ]     =    v 1  1  ;", "val [  . M 2  1  ]     =    v 2  1  ;", "val [  . M 0  2  ]     =    v 0  2  ;", "val [  . M 1  2  ]     =    v 1  2  ;", "val [  . M 2  2  ]     =    v 2  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mulLeft"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "return   rotateRad (  (  ( MathUtils . degreesToRadians )     *    degrees )  )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )", "return   this ;", "float   cos    =     (  ( float )     ( Math . cos ( radians )  )  )  ;", "float   sin    =     (  ( float )     ( Math . sin ( radians )  )  )  ;", "float [  ]    tmp    =    this . tmp ;", "tmp [  . M 0  0  ]     =    cos ;", "tmp [  . M 1  0  ]     =    sin ;", "tmp [  . M 2  0  ]     =     0  ;", "tmp [  . M 0  1  ]     =     - sin ;", "tmp [  . M 1  1  ]     =    cos ;", "tmp [  . M 2  1  ]     =     0  ;", "tmp [  . M 0  2  ]     =     0  ;", "tmp [  . M 1  2  ]     =     0  ;", "tmp [  . M 2  2  ]     =     1  ;", ". mul ( val ,    tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    tmp    =    this . tmp ;", "tmp [  . M 0  0  ]     =    scale . x ;", "tmp [  . M 1  0  ]     =     0  ;", "tmp [  . M 2  0  ]     =     0  ;", "tmp [  . M 0  1  ]     =     0  ;", "tmp [  . M 1  1  ]     =    scale . y ;", "tmp [  . M 2  1  ]     =     0  ;", "tmp [  . M 0  2  ]     =     0  ;", "tmp [  . M 1  2  ]     =     0  ;", "tmp [  . M 2  2  ]     =     1  ;", ". mul ( val ,    tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    tmp    =    this . tmp ;", "tmp [  . M 0  0  ]     =    scaleX ;", "tmp [  . M 1  0  ]     =     0  ;", "tmp [  . M 2  0  ]     =     0  ;", "tmp [  . M 0  1  ]     =     0  ;", "tmp [  . M 1  1  ]     =    scaleY ;", "tmp [  . M 2  1  ]     =     0  ;", "tmp [  . M 0  2  ]     =     0  ;", "tmp [  . M 1  2  ]     =     0  ;", "tmp [  . M 2  2  ]     =     1  ;", ". mul ( val ,    tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 3  . M 0  0  ]     *  =    scale . x ;", "val [ Matrix 3  . M 1  1  ]     *  =    scale . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 3  . M 0  0  ]     *  =    scale . x ;", "val [ Matrix 3  . M 1  1  ]     *  =    scale . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 3  . M 0  0  ]     *  =    scale ;", "val [ Matrix 3  . M 1  1  ]     *  =    scale ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =    affine . m 0  0  ;", "val [  . M 1  0  ]     =    affine . m 1  0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 0  1  ]     =    affine . m 0  1  ;", "val [  . M 1  1  ]     =    affine . m 1  1  ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 0  2  ]     =    affine . m 0  2  ;", "val [  . M 1  2  ]     =    affine . m 1  2  ;", "val [  . M 2  2  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( mat . val ,     0  ,    val ,     0  ,    val . length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =    mat . val [ Matrix 4  . M 0  0  ]  ;", "val [  . M 1  0  ]     =    mat . val [ Matrix 4  . M 1  0  ]  ;", "val [  . M 2  0  ]     =    mat . val [ Matrix 4  . M 2  0  ]  ;", "val [  . M 0  1  ]     =    mat . val [ Matrix 4  . M 0  1  ]  ;", "val [  . M 1  1  ]     =    mat . val [ Matrix 4  . M 1  1  ]  ;", "val [  . M 2  1  ]     =    mat . val [ Matrix 4  . M 2  1  ]  ;", "val [  . M 0  2  ]     =    mat . val [ Matrix 4  . M 0  2  ]  ;", "val [  . M 1  2  ]     =    mat . val [ Matrix 4  . M 1  2  ]  ;", "val [  . M 2  2  ]     =    mat . val [ Matrix 4  . M 2  2  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( values ,     0  ,    val ,     0  ,    val . length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "return   setToRotation ( axis ,    MathUtils . cosDeg ( degrees )  ,    MathUtils . sinDeg ( degrees )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "float   oc    =     1  .  0 F    -    cos ;", "val [  . M 0  0  ]     =     (  ( oc    *     ( axis . x )  )     *     ( axis . x )  )     +    cos ;", "val [  . M 1  0  ]     =     (  ( oc    *     ( axis . x )  )     *     ( axis . y )  )     -     (  ( axis . z )     *    sin )  ;", "val [  . M 2  0  ]     =     (  ( oc    *     ( axis . z )  )     *     ( axis . x )  )     +     (  ( axis . y )     *    sin )  ;", "val [  . M 0  1  ]     =     (  ( oc    *     ( axis . x )  )     *     ( axis . y )  )     +     (  ( axis . z )     *    sin )  ;", "val [  . M 1  1  ]     =     (  ( oc    *     ( axis . y )  )     *     ( axis . y )  )     +    cos ;", "val [  . M 2  1  ]     =     (  ( oc    *     ( axis . y )  )     *     ( axis . z )  )     -     (  ( axis . x )     *    sin )  ;", "val [  . M 0  2  ]     =     (  ( oc    *     ( axis . z )  )     *     ( axis . x )  )     -     (  ( axis . y )     *    sin )  ;", "val [  . M 1  2  ]     =     (  ( oc    *     ( axis . y )  )     *     ( axis . z )  )     +     (  ( axis . x )     *    sin )  ;", "val [  . M 2  2  ]     =     (  ( oc    *     ( axis . z )  )     *     ( axis . z )  )     +    cos ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "return   setToRotationRad (  (  ( MathUtils . degreesToRadians )     *    degrees )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float   cos    =     (  ( float )     ( Math . cos ( radians )  )  )  ;", "float   sin    =     (  ( float )     ( Math . sin ( radians )  )  )  ;", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =    cos ;", "val [  . M 1  0  ]     =    sin ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 0  1  ]     =     - sin ;", "val [  . M 1  1  ]     =    cos ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToRotationRad"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =    scale . x ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    scale . y ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =    scaleX ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    scaleY ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =     1  ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =     1  ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 0  2  ]     =    translation . x ;", "val [  . M 1  2  ]     =    translation . y ;", "val [  . M 2  2  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "val [  . M 0  0  ]     =     1  ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =     1  ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 0  2  ]     =    x ;", "val [  . M 1  2  ]     =    y ;", "val [  . M 2  2  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  [  \"     +     ( val [  . M 0  0  ]  )  )     +     \"  |  \"  )     +     ( val [  . M 0  1  ]  )  )     +     \"  |  \"  )     +     ( val [  . M 0  2  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [  . M 1  0  ]  )  )     +     \"  |  \"  )     +     ( val [  . M 1  1  ]  )  )     +     \"  |  \"  )     +     ( val [  . M 1  2  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [  . M 2  0  ]  )  )     +     \"  |  \"  )     +     ( val [  . M 2  1  ]  )  )     +     \"  |  \"  )     +     ( val [  . M 2  2  ]  )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "tmp [  . M 0  0  ]     =     1  ;", "tmp [  . M 1  0  ]     =     0  ;", "tmp [  . M 2  0  ]     =     0  ;", "tmp [  . M 0  1  ]     =     0  ;", "tmp [  . M 1  1  ]     =     1  ;", "tmp [  . M 2  1  ]     =     0  ;", "tmp [  . M 0  2  ]     =    translation . x ;", "tmp [  . M 1  2  ]     =    translation . y ;", "tmp [  . M 2  2  ]     =     1  ;", ". mul ( val ,    tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "tmp [  . M 0  0  ]     =     1  ;", "tmp [  . M 1  0  ]     =     0  ;", "tmp [  . M 2  0  ]     =     0  ;", "tmp [  . M 0  1  ]     =     0  ;", "tmp [  . M 1  1  ]     =     1  ;", "tmp [  . M 2  1  ]     =     0  ;", "tmp [  . M 0  2  ]     =    x ;", "tmp [  . M 1  2  ]     =    y ;", "tmp [  . M 2  2  ]     =     1  ;", ". mul ( val ,    tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "float [  ]    val    =    this . val ;", "float   v 0  1     =    val [  . M 1  0  ]  ;", "float   v 0  2     =    val [  . M 2  0  ]  ;", "float   v 1  0     =    val [  . M 0  1  ]  ;", "float   v 1  2     =    val [  . M 2  1  ]  ;", "float   v 2  0     =    val [  . M 0  2  ]  ;", "float   v 2  1     =    val [  . M 1  2  ]  ;", "val [  . M 0  1  ]     =    v 0  1  ;", "val [  . M 0  2  ]     =    v 0  2  ;", "val [  . M 1  0  ]     =    v 1  0  ;", "val [  . M 1  2  ]     =    v 1  2  ;", "val [  . M 2  0  ]     =    v 2  0  ;", "val [  . M 2  1  ]     =    v 2  1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["transpose"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 3  . M 0  2  ]     +  =    vector . x ;", "val [ Matrix 3  . M 1  2  ]     +  =    vector . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["trn"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 3  . M 0  2  ]     +  =    vector . x ;", "val [ Matrix 3  . M 1  2  ]     +  =    vector . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["trn"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 3  . M 0  2  ]     +  =    x ;", "val [ Matrix 3  . M 1  2  ]     +  =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["trn"], "fileName": "com.badlogic.gdx.math.Matrix3"}, {"methodBody": ["METHOD_START", "{", "getScale ( Matrix 4  . tmpVec )  ;", "other . getScale ( Matrix 4  . tmpForward )  ;", "getRotation ( Matrix 4  . quat )  ;", "other . getRotation ( Matrix 4  . quat 2  )  ;", "getTranslation ( Matrix 4  . tmpUp )  ;", "other . getTranslation ( Matrix 4  . right )  ;", "setToScaling ( Matrix 4  . tmpVec . scl ( w )  . add ( Matrix 4  . tmpForward . scl (  (  1     -    w )  )  )  )  ;", "rotate ( Matrix 4  . quat . slerp ( Matrix 4  . quat 2  ,     (  1     -    w )  )  )  ;", "setTranslation ( Matrix 4  . tmpUp . scl ( w )  . add ( Matrix 4  . right . scl (  (  1     -    w )  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["avg"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "final   float   w    =     1  .  0 F    /     ( t . length )  ;", ". tmpVec . set ( t [  0  ]  . getScale (  . tmpUp )  . scl ( w )  )  ;", ". quat . set ( t [  0  ]  . getRotation (  . quat 2  )  . exp ( w )  )  ;", ". tmpForward . set ( t [  0  ]  . getTranslation (  . tmpUp )  . scl ( w )  )  ;", "for    ( int   i    =     1  ;    i    <     ( t . length )  ;    i +  +  )     {", ". tmpVec . add ( t [ i ]  . getScale (  . tmpUp )  . scl ( w )  )  ;", ". quat . mul ( t [ i ]  . getRotation (  . quat 2  )  . exp ( w )  )  ;", ". tmpForward . add ( t [ i ]  . getTranslation (  . tmpUp )  . scl ( w )  )  ;", "}", ". quat . nor (  )  ;", "setToScaling (  . tmpVec )  ;", "rotate (  . quat )  ;", "setTranslation (  . tmpForward )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["avg"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmpVec . set ( t [  0  ]  . getScale ( Matrix 4  . tmpUp )  . scl ( w [  0  ]  )  )  ;", "Matrix 4  . quat . set ( t [  0  ]  . getRotation ( Matrix 4  . quat 2  )  . exp ( w [  0  ]  )  )  ;", "Matrix 4  . tmpForward . set ( t [  0  ]  . getTranslation ( Matrix 4  . tmpUp )  . scl ( w [  0  ]  )  )  ;", "for    ( int   i    =     1  ;    i    <     ( t . length )  ;    i +  +  )     {", "Matrix 4  . tmpVec . add ( t [ i ]  . getScale ( Matrix 4  . tmpUp )  . scl ( w [ i ]  )  )  ;", "Matrix 4  . quat . mul ( t [ i ]  . getRotation ( Matrix 4  . quat 2  )  . exp ( w [ i ]  )  )  ;", "Matrix 4  . tmpForward . add ( t [ i ]  . getTranslation ( Matrix 4  . tmpUp )  . scl ( w [ i ]  )  )  ;", "}", "Matrix 4  . quat . nor (  )  ;", "setToScaling ( Matrix 4  . tmpVec )  ;", "rotate ( Matrix 4  . quat )  ;", "setTranslation ( Matrix 4  . tmpForward )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["avg"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   new   Matrix 4  ( this )  ;", "}", "METHOD_END"], "methodName": ["cpy"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["det"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["det3x3"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "dst [  0  ]     =    val [ Matrix 4  . M 0  0  ]  ;", "dst [  1  ]     =    val [ Matrix 4  . M 1  0  ]  ;", "dst [  2  ]     =    val [ Matrix 4  . M 2  0  ]  ;", "dst [  3  ]     =    val [ Matrix 4  . M 0  1  ]  ;", "dst [  4  ]     =    val [ Matrix 4  . M 1  1  ]  ;", "dst [  5  ]     =    val [ Matrix 4  . M 2  1  ]  ;", "dst [  6  ]     =    val [ Matrix 4  . M 0  2  ]  ;", "dst [  7  ]     =    val [ Matrix 4  . M 1  2  ]  ;", "dst [  8  ]     =    val [ Matrix 4  . M 2  2  ]  ;", "dst [  9  ]     =    val [ Matrix 4  . M 0  3  ]  ;", "dst [  1  0  ]     =    val [ Matrix 4  . M 1  3  ]  ;", "dst [  1  1  ]     =    val [ Matrix 4  . M 2  3  ]  ;", "}", "METHOD_END"], "methodName": ["extract4x3Matrix"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   rotation . setFromMatrix ( this )  ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   rotation . setFromMatrix ( normalizeAxes ,    this )  ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   scale . set ( getScaleX (  )  ,    getScaleY (  )  ,    getScaleZ (  )  )  ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . isZero ( val [ Matrix 4  . M 0  1  ]  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 0  2  ]  )  )     ?    Math . abs ( val [ Matrix 4  . M 0  0  ]  )     :     (  ( float )     ( Math . sqrt ( getScaleXSquared (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleXSquared"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . isZero ( val [ Matrix 4  . M 1  0  ]  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 1  2  ]  )  )     ?    Math . abs ( val [ Matrix 4  . M 1  1  ]  )     :     (  ( float )     ( Math . sqrt ( getScaleYSquared (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     +     (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleYSquared"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . isZero ( val [ Matrix 4  . M 2  0  ]  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 2  1  ]  )  )     ?    Math . abs ( val [ Matrix 4  . M 2  2  ]  )     :     (  ( float )     ( Math . sqrt ( getScaleZSquared (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleZ"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     +     (  ( val [ Matrix 4  . M 2  1  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  2  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleZSquared"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "position . x    =    val [ Matrix 4  . M 0  3  ]  ;", "position . y    =    val [ Matrix 4  . M 1  3  ]  ;", "position . z    =    val [ Matrix 4  . M 2  3  ]  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   val ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    !  (  (  (  (  (  (  (  (  ( MathUtils . isEqual ( val [ Matrix 4  . M 0  0  ]  ,     1  )  )     &  &     ( MathUtils . isEqual ( val [ Matrix 4  . M 1  1  ]  ,     1  )  )  )     &  &     ( MathUtils . isEqual ( val [ Matrix 4  . M 2  2  ]  ,     1  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 0  1  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 0  2  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 1  0  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 1  2  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 2  0  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 2  1  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasRotationOrScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =     1  ;", "val [ Matrix 4  . M 0  1  ]     =     0  ;", "val [ Matrix 4  . M 0  2  ]     =     0  ;", "val [ Matrix 4  . M 0  3  ]     =     0  ;", "val [ Matrix 4  . M 1  0  ]     =     0  ;", "val [ Matrix 4  . M 1  1  ]     =     1  ;", "val [ Matrix 4  . M 1  2  ]     =     0  ;", "val [ Matrix 4  . M 1  3  ]     =     0  ;", "val [ Matrix 4  . M 2  0  ]     =     0  ;", "val [ Matrix 4  . M 2  1  ]     =     0  ;", "val [ Matrix 4  . M 2  2  ]     =     1  ;", "val [ Matrix 4  . M 2  3  ]     =     0  ;", "val [ Matrix 4  . M 3  0  ]     =     0  ;", "val [ Matrix 4  . M 3  1  ]     =     0  ;", "val [ Matrix 4  . M 3  2  ]     =     0  ;", "val [ Matrix 4  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["idt"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float   l _ det    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "if    ( l _ det    =  =     0  .  0 F )", "throw   new   RuntimeException (  \" non - invertible   matrix \"  )  ;", "float   inv _ det    =     1  .  0 F    /    l _ det ;", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  ;", "val [ Matrix 4  . M 0  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 0  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 0  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 0  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  3  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  3  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  3  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  3  ]  )     *    inv _ det ;", "return   this ;", "}", "METHOD_END"], "methodName": ["inv"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  6  ;    i +  +  )", "this . val [ i ]     =     (  ( this . val [ i ]  )     *     (  1     -    alpha )  )     +     (  ( m . val [ i ]  )     *    alpha )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["lerp"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . mul ( val ,    matrix . val )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmpMat . set ( matrix )  ;", "Matrix 4  . mul ( Matrix 4  . tmpMat . val ,    this . val )  ;", "return   set ( Matrix 4  . tmpMat )  ;", "}", "METHOD_END"], "methodName": ["mulLeft"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "rotation . toMatrix ( Matrix 4  . tmp )  ;", "Matrix 4  . mul ( val ,    Matrix 4  . tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   rotate ( Matrix 4  . quat . setFromCross ( v 1  ,    v 2  )  )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )", "return   this ;", ". quat . set ( axis ,    degrees )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )", "return   this ;", ". quat . setFromAxis ( axisX ,    axisY ,    axisZ ,    degrees )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )", "return   this ;", ". quat . setFromAxisRad ( axis ,    radians )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )", "return   this ;", ". quat . setFromAxisRad ( axisX ,    axisY ,    axisZ ,    radians )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =    scaleX ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =    scaleY ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =    scaleZ ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     1  ;", "Matrix 4  . mul ( val ,    Matrix 4  . tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     *  =    scale . x ;", "val [ Matrix 4  . M 1  1  ]     *  =    scale . y ;", "val [ Matrix 4  . M 2  2  ]     *  =    scale . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     *  =    scale ;", "val [ Matrix 4  . M 1  1  ]     *  =    scale ;", "val [ Matrix 4  . M 2  2  ]     *  =    scale ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     *  =    x ;", "val [ Matrix 4  . M 1  1  ]     *  =    y ;", "val [ Matrix 4  . M 2  2  ]     *  =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    affine . m 0  0  ;", "val [ Matrix 4  . M 1  0  ]     =    affine . m 1  0  ;", "val [ Matrix 4  . M 2  0  ]     =     0  ;", "val [ Matrix 4  . M 3  0  ]     =     0  ;", "val [ Matrix 4  . M 0  1  ]     =    affine . m 0  1  ;", "val [ Matrix 4  . M 1  1  ]     =    affine . m 1  1  ;", "val [ Matrix 4  . M 2  1  ]     =     0  ;", "val [ Matrix 4  . M 3  1  ]     =     0  ;", "val [ Matrix 4  . M 0  2  ]     =     0  ;", "val [ Matrix 4  . M 1  2  ]     =     0  ;", "val [ Matrix 4  . M 2  2  ]     =     1  ;", "val [ Matrix 4  . M 3  2  ]     =     0  ;", "val [ Matrix 4  . M 0  3  ]     =    affine . m 0  2  ;", "val [ Matrix 4  . M 1  3  ]     =    affine . m 1  2  ;", "val [ Matrix 4  . M 2  3  ]     =     0  ;", "val [ Matrix 4  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [  0  ]     =    mat . val [  0  ]  ;", "val [  1  ]     =    mat . val [  1  ]  ;", "val [  2  ]     =    mat . val [  2  ]  ;", "val [  3  ]     =     0  ;", "val [  4  ]     =    mat . val [  3  ]  ;", "val [  5  ]     =    mat . val [  4  ]  ;", "val [  6  ]     =    mat . val [  5  ]  ;", "val [  7  ]     =     0  ;", "val [  8  ]     =     0  ;", "val [  9  ]     =     0  ;", "val [  1  0  ]     =     1  ;", "val [  1  1  ]     =     0  ;", "val [  1  2  ]     =    mat . val [  6  ]  ;", "val [  1  3  ]     =    mat . val [  7  ]  ;", "val [  1  4  ]     =     0  ;", "val [  1  5  ]     =    mat . val [  8  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( matrix . val )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( quaternion . x ,    quaternion . y ,    quaternion . z ,    quaternion . w )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( position . x ,    position . y ,    position . z ,    orientation . x ,    orientation . y ,    orientation . z ,    orientation . w )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( position . x ,    position . y ,    position . z ,    orientation . x ,    orientation . y ,    orientation . z ,    orientation . w ,    scale . x ,    scale . y ,    scale . z )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    xAxis . x ;", "val [ Matrix 4  . M 0  1  ]     =    xAxis . y ;", "val [ Matrix 4  . M 0  2  ]     =    xAxis . z ;", "val [ Matrix 4  . M 1  0  ]     =    yAxis . x ;", "val [ Matrix 4  . M 1  1  ]     =    yAxis . y ;", "val [ Matrix 4  . M 1  2  ]     =    yAxis . z ;", "val [ Matrix 4  . M 2  0  ]     =    zAxis . x ;", "val [ Matrix 4  . M 2  1  ]     =    zAxis . y ;", "val [ Matrix 4  . M 2  2  ]     =    zAxis . z ;", "val [ Matrix 4  . M 0  3  ]     =    pos . x ;", "val [ Matrix 4  . M 1  3  ]     =    pos . y ;", "val [ Matrix 4  . M 2  3  ]     =    pos . z ;", "val [ Matrix 4  . M 3  0  ]     =     0  ;", "val [ Matrix 4  . M 3  1  ]     =     0  ;", "val [ Matrix 4  . M 3  2  ]     =     0  ;", "val [ Matrix 4  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set (  0  .  0 F ,     0  .  0 F ,     0  .  0 F ,    quaternionX ,    quaternionY ,    quaternionZ ,    quaternionW )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "final   float   xs    =    quaternionX    *     2  .  0 F ;", "final   float   ys    =    quaternionY    *     2  .  0 F ;", "final   float   zs    =    quaternionZ    *     2  .  0 F ;", "final   float   wx    =    quaternionW    *    xs ;", "final   float   wy    =    quaternionW    *    ys ;", "final   float   wz    =    quaternionW    *    zs ;", "final   float   xx    =    quaternionX    *    xs ;", "final   float   xy    =    quaternionX    *    ys ;", "final   float   xz    =    quaternionX    *    zs ;", "final   float   yy    =    quaternionY    *    ys ;", "final   float   yz    =    quaternionY    *    zs ;", "final   float   zz    =    quaternionZ    *    zs ;", "val [  . M 0  0  ]     =     1  .  0 F    -     ( yy    +    zz )  ;", "val [  . M 0  1  ]     =    xy    -    wz ;", "val [  . M 0  2  ]     =    xz    +    wy ;", "val [  . M 0  3  ]     =    translationX ;", "val [  . M 1  0  ]     =    xy    +    wz ;", "val [  . M 1  1  ]     =     1  .  0 F    -     ( xx    +    zz )  ;", "val [  . M 1  2  ]     =    yz    -    wx ;", "val [  . M 1  3  ]     =    translationY ;", "val [  . M 2  0  ]     =    xz    -    wy ;", "val [  . M 2  1  ]     =    yz    +    wx ;", "val [  . M 2  2  ]     =     1  .  0 F    -     ( xx    +    yy )  ;", "val [  . M 2  3  ]     =    translationZ ;", "val [  . M 3  0  ]     =     0  .  0 F ;", "val [  . M 3  1  ]     =     0  .  0 F ;", "val [  . M 3  2  ]     =     0  .  0 F ;", "val [  . M 3  3  ]     =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "final   float   xs    =    quaternionX    *     2  .  0 F ;", "final   float   ys    =    quaternionY    *     2  .  0 F ;", "final   float   zs    =    quaternionZ    *     2  .  0 F ;", "final   float   wx    =    quaternionW    *    xs ;", "final   float   wy    =    quaternionW    *    ys ;", "final   float   wz    =    quaternionW    *    zs ;", "final   float   xx    =    quaternionX    *    xs ;", "final   float   xy    =    quaternionX    *    ys ;", "final   float   xz    =    quaternionX    *    zs ;", "final   float   yy    =    quaternionY    *    ys ;", "final   float   yz    =    quaternionY    *    zs ;", "final   float   zz    =    quaternionZ    *    zs ;", "val [  . M 0  0  ]     =    scaleX    *     (  1  .  0 F    -     ( yy    +    zz )  )  ;", "val [  . M 0  1  ]     =    scaleY    *     ( xy    -    wz )  ;", "val [  . M 0  2  ]     =    scaleZ    *     ( xz    +    wy )  ;", "val [  . M 0  3  ]     =    translationX ;", "val [  . M 1  0  ]     =    scaleX    *     ( xy    +    wz )  ;", "val [  . M 1  1  ]     =    scaleY    *     (  1  .  0 F    -     ( xx    +    zz )  )  ;", "val [  . M 1  2  ]     =    scaleZ    *     ( yz    -    wx )  ;", "val [  . M 1  3  ]     =    translationY ;", "val [  . M 2  0  ]     =    scaleX    *     ( xz    -    wy )  ;", "val [  . M 2  1  ]     =    scaleY    *     ( yz    +    wx )  ;", "val [  . M 2  2  ]     =    scaleZ    *     (  1  .  0 F    -     ( xx    +    yy )  )  ;", "val [  . M 2  3  ]     =    translationZ ;", "val [  . M 3  0  ]     =     0  .  0 F ;", "val [  . M 3  1  ]     =     0  .  0 F ;", "val [  . M 3  2  ]     =     0  .  0 F ;", "val [  . M 3  3  ]     =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( values ,     0  ,    val ,     0  ,    val . length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    affine . m 0  0  ;", "val [ Matrix 4  . M 1  0  ]     =    affine . m 1  0  ;", "val [ Matrix 4  . M 0  1  ]     =    affine . m 0  1  ;", "val [ Matrix 4  . M 1  1  ]     =    affine . m 1  1  ;", "val [ Matrix 4  . M 0  3  ]     =    affine . m 0  2  ;", "val [ Matrix 4  . M 1  3  ]     =    affine . m 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAsAffine"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    mat . val [ Matrix 4  . M 0  0  ]  ;", "val [ Matrix 4  . M 1  0  ]     =    mat . val [ Matrix 4  . M 1  0  ]  ;", "val [ Matrix 4  . M 0  1  ]     =    mat . val [ Matrix 4  . M 0  1  ]  ;", "val [ Matrix 4  . M 1  1  ]     =    mat . val [ Matrix 4  . M 1  1  ]  ;", "val [ Matrix 4  . M 0  3  ]     =    mat . val [ Matrix 4  . M 0  3  ]  ;", "val [ Matrix 4  . M 1  3  ]     =    mat . val [ Matrix 4  . M 1  3  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAsAffine"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . quat . setEulerAngles ( yaw ,    pitch ,    roll )  ;", "return   set ( Matrix 4  . quat )  ;", "}", "METHOD_END"], "methodName": ["setFromEulerAngles"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . quat . setEulerAnglesRad ( yaw ,    pitch ,    roll )  ;", "return   set ( Matrix 4  . quat )  ;", "}", "METHOD_END"], "methodName": ["setFromEulerAnglesRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . l _ vez . set ( direction )  . nor (  )  ;", "Matrix 4  . l _ vex . set ( direction )  . nor (  )  ;", "Matrix 4  . l _ vex . crs ( up )  . nor (  )  ;", "Matrix 4  . l _ vey . set ( Matrix 4  . l _ vex )  . crs ( Matrix 4  . l _ vez )  . nor (  )  ;", "idt (  )  ;", "val [ Matrix 4  . M 0  0  ]     =    Matrix 4  . l _ vex . x ;", "val [ Matrix 4  . M 0  1  ]     =    Matrix 4  . l _ vex . y ;", "val [ Matrix 4  . M 0  2  ]     =    Matrix 4  . l _ vex . z ;", "val [ Matrix 4  . M 1  0  ]     =    Matrix 4  . l _ vey . x ;", "val [ Matrix 4  . M 1  1  ]     =    Matrix 4  . l _ vey . y ;", "val [ Matrix 4  . M 1  2  ]     =    Matrix 4  . l _ vey . z ;", "val [ Matrix 4  . M 2  0  ]     =     -  ( Matrix 4  . l _ vez . x )  ;", "val [ Matrix 4  . M 2  1  ]     =     -  ( Matrix 4  . l _ vez . y )  ;", "val [ Matrix 4  . M 2  2  ]     =     -  ( Matrix 4  . l _ vez . z )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToLookAt"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmpVec . set ( target )  . sub ( position )  ;", "setToLookAt ( Matrix 4  . tmpVec ,    up )  ;", "this . mul ( Matrix 4  . tmpMat . setToTranslation (  (  -  ( position . x )  )  ,     (  -  ( position . y )  )  ,     (  -  ( position . z )  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToLookAt"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "this . idt (  )  ;", "float   x _ orth    =     2     /     ( right    -    left )  ;", "float   y _ orth    =     2     /     ( top    -    bottom )  ;", "float   z _ orth    =     (  -  2  )     /     ( far    -    near )  ;", "float   tx    =     (  -  ( right    +    left )  )     /     ( right    -    left )  ;", "float   ty    =     (  -  ( top    +    bottom )  )     /     ( top    -    bottom )  ;", "float   tz    =     (  -  ( far    +    near )  )     /     ( far    -    near )  ;", "val [  . M 0  0  ]     =    x _ orth ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 3  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    y _ orth ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 3  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =    z _ orth ;", "val [  . M 3  2  ]     =     0  ;", "val [  . M 0  3  ]     =    tx ;", "val [  . M 1  3  ]     =    ty ;", "val [  . M 2  3  ]     =    tz ;", "val [  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToOrtho"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "setToOrtho ( x ,     ( x    +    width )  ,    y ,     ( y    +    height )  ,     0  ,     1  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToOrtho2D"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "setToOrtho ( x ,     ( x    +    width )  ,    y ,     ( y    +    height )  ,    near ,    far )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToOrtho2D"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "float   l _ fd    =     (  ( float )     (  1  .  0     /     ( Math . tan (  (  ( fovy    *     (  ( Math . PI )     /     1  8  0  )  )     /     2  .  0  )  )  )  )  )  ;", "float   l _ a 1     =     ( far    +    near )     /     ( near    -    far )  ;", "float   l _ a 2     =     (  (  2     *    far )     *    near )     /     ( near    -    far )  ;", "val [  . M 0  0  ]     =    l _ fd    /    aspectRatio ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 3  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    l _ fd ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 3  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =    l _ a 1  ;", "val [  . M 3  2  ]     =     -  1  ;", "val [  . M 0  3  ]     =     0  ;", "val [  . M 1  3  ]     =     0  ;", "val [  . M 2  3  ]     =    l _ a 2  ;", "val [  . M 3  3  ]     =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToProjection"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  2  .  0 F    *    near )     /     ( right    -    left )  ;", "float   y    =     (  2  .  0 F    *    near )     /     ( top    -    bottom )  ;", "float   a    =     ( right    +    left )     /     ( right    -    left )  ;", "float   b    =     ( top    +    bottom )     /     ( top    -    bottom )  ;", "float   l _ a 1     =     ( far    +    near )     /     ( near    -    far )  ;", "float   l _ a 2     =     (  (  2     *    far )     *    near )     /     ( near    -    far )  ;", "val [  . M 0  0  ]     =    x ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 3  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    y ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 3  1  ]     =     0  ;", "val [  . M 0  2  ]     =    a ;", "val [  . M 1  2  ]     =    b ;", "val [  . M 2  2  ]     =    l _ a 1  ;", "val [  . M 3  2  ]     =     -  1  ;", "val [  . M 0  3  ]     =     0  ;", "val [  . M 1  3  ]     =     0  ;", "val [  . M 2  3  ]     =    l _ a 2  ;", "val [  . M 3  3  ]     =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToProjection"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( Matrix 4  . quat . setFromCross ( v 1  ,    v 2  )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . set ( axis ,    degrees )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . setFromAxis ( axisX ,    axisY ,    axisZ ,    degrees )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( Matrix 4  . quat . setFromCross ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . setFromAxisRad ( axis ,    radians )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotationRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . setFromAxisRad ( axisX ,    axisY ,    axisZ ,    radians )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotationRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  0  ]     =    vector . x ;", "val [  . M 1  1  ]     =    vector . y ;", "val [  . M 2  2  ]     =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  0  ]     =    x ;", "val [  . M 1  1  ]     =    y ;", "val [  . M 2  2  ]     =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    vector . x ;", "val [  . M 1  3  ]     =    vector . y ;", "val [  . M 2  3  ]     =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    x ;", "val [  . M 1  3  ]     =    y ;", "val [  . M 2  3  ]     =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    translation . x ;", "val [  . M 1  3  ]     =    translation . y ;", "val [  . M 2  3  ]     =    translation . z ;", "val [  . M 0  0  ]     =    scaling . x ;", "val [  . M 1  1  ]     =    scaling . y ;", "val [  . M 2  2  ]     =    scaling . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslationAndScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    translationX ;", "val [  . M 1  3  ]     =    translationY ;", "val [  . M 2  3  ]     =    translationZ ;", "val [  . M 0  0  ]     =    scalingX ;", "val [  . M 1  1  ]     =    scalingY ;", "val [  . M 2  2  ]     =    scalingZ ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslationAndScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmpForward . set ( forward )  . nor (  )  ;", "Matrix 4  . right . set ( Matrix 4  . tmpForward )  . crs ( up )  . nor (  )  ;", "Matrix 4  . tmpUp . set ( Matrix 4  . right )  . crs ( Matrix 4  . tmpForward )  . nor (  )  ;", "this . set ( Matrix 4  . right ,    Matrix 4  . tmpUp ,    Matrix 4  . tmpForward . scl (  (  -  1  )  )  ,    position )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToWorld"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     =    vector . x ;", "val [ Matrix 4  . M 1  3  ]     =    vector . y ;", "val [ Matrix 4  . M 2  3  ]     =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     =    x ;", "val [ Matrix 4  . M 1  3  ]     =    y ;", "val [ Matrix 4  . M 2  3  ]     =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     =     0  ;", "val [ Matrix 4  . M 1  3  ]     =     0  ;", "val [ Matrix 4  . M 2  3  ]     =     0  ;", "return   inv (  )  . tra (  )  ;", "}", "METHOD_END"], "methodName": ["toNormalMatrix"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  [  \"     +     ( val [ Matrix 4  . M 0  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 0  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 0  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 0  3  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [ Matrix 4  . M 1  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 1  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 1  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 1  3  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [ Matrix 4  . M 2  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 2  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 2  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 2  3  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [ Matrix 4  . M 3  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 3  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 3  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 3  3  ]  )  )     +     \"  ]  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =    val [ Matrix 4  . M 0  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =    val [ Matrix 4  . M 1  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =    val [ Matrix 4  . M 2  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =    val [ Matrix 4  . M 3  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =    val [ Matrix 4  . M 0  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =    val [ Matrix 4  . M 1  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =    val [ Matrix 4  . M 2  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =    val [ Matrix 4  . M 3  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =    val [ Matrix 4  . M 0  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =    val [ Matrix 4  . M 1  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =    val [ Matrix 4  . M 2  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =    val [ Matrix 4  . M 3  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =    val [ Matrix 4  . M 0  3  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =    val [ Matrix 4  . M 1  3  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =    val [ Matrix 4  . M 2  3  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =    val [ Matrix 4  . M 3  3  ]  ;", "return   set ( Matrix 4  . tmp )  ;", "}", "METHOD_END"], "methodName": ["tra"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   translate ( translation . x ,    translation . y ,    translation . z )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =     1  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =    x ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =     1  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =    y ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =     1  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =    z ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     1  ;", "Matrix 4  . mul ( val ,    Matrix 4  . tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     +  =    vector . x ;", "val [ Matrix 4  . M 1  3  ]     +  =    vector . y ;", "val [ Matrix 4  . M 2  3  ]     +  =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["trn"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     +  =    x ;", "val [ Matrix 4  . M 1  3  ]     +  =    y ;", "val [ Matrix 4  . M 2  3  ]     +  =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["trn"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( normal . dot ( point )  )     +     ( d )  ;", "}", "METHOD_END"], "methodName": ["distance"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "return   d ;", "}", "METHOD_END"], "methodName": ["getD"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "return   normal ;", "}", "METHOD_END"], "methodName": ["getNormal"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "float   dot    =    normal . dot ( direction )  ;", "return   dot    <  =     0  ;", "}", "METHOD_END"], "methodName": ["isFrontFacing"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "this . normal . set ( plane . normal )  ;", "this . d    =    plane . d ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "this . normal . set ( normal )  ;", "d    =     -  ( point . dot ( normal )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "normal . set ( point 1  )  . sub ( point 2  )  . crs (  (  ( point 2  . x )     -     ( point 3  . x )  )  ,     (  ( point 2  . y )     -     ( point 3  . y )  )  ,     (  ( point 2  . z )     -     ( point 3  . z )  )  )  . nor (  )  ;", "d    =     -  ( point 1  . dot ( normal )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "normal . set ( nx ,    ny ,    nz )  ;", "this . d    =    d ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "this . normal . set ( norX ,    norY ,    norZ )  ;", "d    =     -  (  (  ( pointX    *    norX )     +     ( pointY    *    norY )  )     +     ( pointZ    *    norZ )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "float   dist    =     ( normal . dot ( point )  )     +     ( d )  ;", "if    ( dist    =  =     0  )", "returnSide . O ;", "else", "if    ( dist    <     0  )", "returnSide . Back ;", "else", "returnSide . Front ;", "}", "METHOD_END"], "methodName": ["testPoint"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "float   dist    =     ( normal . dot ( x ,    y ,    z )  )     +     ( d )  ;", "if    ( dist    =  =     0  )", "returnSide . O ;", "else", "if    ( dist    <     0  )", "returnSide . Back ;", "else", "returnSide . Front ;", "}", "METHOD_END"], "methodName": ["testPoint"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "return    (  ( normal . toString (  )  )     +     \"  ,     \"  )     +     ( d )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.math.Plane"}, {"methodBody": ["METHOD_START", "{", "float [  ]    vertices    =    getTransformedVertices (  )  ;", "return   GeometryUtils . pArea ( vertices ,     0  ,    vertices . length )  ;", "}", "METHOD_END"], "methodName": ["area"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["dirty"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "float [  ]    vertices    =    getTransformedVertices (  )  ;", "float   minX    =    vertices [  0  ]  ;", "float   minY    =    vertices [  1  ]  ;", "float   maxX    =    vertices [  0  ]  ;", "float   maxY    =    vertices [  1  ]  ;", "final   int   numFloats    =    vertices . length ;", "for    ( int   i    =     2  ;    i    <    numFloats ;    i    +  =     2  )     {", "minX    =     ( minX    >     ( vertices [ i ]  )  )     ?    vertices [ i ]     :    minX ;", "minY    =     ( minY    >     ( vertices [  ( i    +     1  )  ]  )  )     ?    vertices [  ( i    +     1  )  ]     :    minY ;", "maxX    =     ( maxX    <     ( vertices [ i ]  )  )     ?    vertices [ i ]     :    maxX ;", "maxY    =     ( maxY    <     ( vertices [  ( i    +     1  )  ]  )  )     ?    vertices [  ( i    +     1  )  ]     :    maxY ;", "}", "if    (  ( bounds )     =  =    null )", "bounds    =    new   Rectangle (  )  ;", "bounds . x    =    minX ;", "bounds . y    =    minY ;", "bounds . width    =    maxX    -    minX ;", "bounds . height    =    maxY    -    minY ;", "return   bounds ;", "}", "METHOD_END"], "methodName": ["getBoundingRectangle"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   originX ;", "}", "METHOD_END"], "methodName": ["getOriginX"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   originY ;", "}", "METHOD_END"], "methodName": ["getOriginY"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   rotation ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   scaleX ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   scaleY ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dirty )  )", "return   worldVertices ;", "dirty    =    false ;", "final   float [  ]    localVertices    =    this . localVertices ;", "if    (  (  ( worldVertices )     =  =    null )     |  |     (  ( worldVertices . length )     !  =     ( localVertices . length )  )  )", "worldVertices    =    new   float [ localVertices . length ]  ;", "final   float [  ]    worldVertices    =    this . worldVertices ;", "final   float   positionX    =    x ;", "final   float   positionY    =    y ;", "final   float   originX    =    this . originX ;", "final   float   originY    =    this . originY ;", "final   float   scaleX    =    this . scaleX ;", "final   float   scaleY    =    this . scaleY ;", "final   boolean   scale    =     ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  ;", "final   float   rotation    =    this . rotation ;", "final   float   cos    =    MUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MUtils . sinDeg ( rotation )  ;", "for    ( int   i    =     0  ,    n    =    localVertices . length ;    i    <    n ;    i    +  =     2  )     {", "float   x    =     ( localVertices [ i ]  )     -    originX ;", "float   y    =     ( localVertices [  ( i    +     1  )  ]  )     -    originY ;", "if    ( scale )     {", "x    *  =    scaleX ;", "y    *  =    scaleY ;", "}", "if    ( rotation    !  =     0  )     {", "float   oldX    =    x ;", "x    =     ( cos    *    x )     -     ( sin    *    y )  ;", "y    =     ( sin    *    oldX )     +     ( cos    *    y )  ;", "}", "worldVertices [ i ]     =     ( positionX    +    x )     +    originX ;", "worldVertices [  ( i    +     1  )  ]     =     ( positionY    +    y )     +    originY ;", "}", "return   worldVertices ;", "}", "METHOD_END"], "methodName": ["getTransformedVertices"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   localVertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "rotation    +  =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    +  =    amount ;", "this . scaleY    +  =    amount ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "this . originX    =    originX ;", "this . originY    =    originY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "this . rotation    =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleX ;", "this . scaleY    =    scaleY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "if    (  ( vertices . length )     <     6  )", "throw   new   IllegalArgumentException (  \" ps   must   contain   at   least    3    points .  \"  )  ;", "localVertices    =    vertices ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setVertices"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    x ;", "this . y    +  =    y ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Polygon"}, {"methodBody": ["METHOD_START", "{", "calculateLength    =    true ;", "}", "METHOD_END"], "methodName": ["calculateLength"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "calculateScaledLength    =    true ;", "}", "METHOD_END"], "methodName": ["calculateScaledLength"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["dirty"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( calculateLength )  )", "return   length ;", "calculateLength    =    false ;", "length    =     0  ;", "for    ( int   i    =     0  ,    n    =     ( localVertices . length )     -     2  ;    i    <    n ;    i    +  =     2  )     {", "float   x    =     ( localVertices [  ( i    +     2  )  ]  )     -     ( localVertices [ i ]  )  ;", "float   y    =     ( localVertices [  ( i    +     1  )  ]  )     -     ( localVertices [  ( i    +     3  )  ]  )  ;", "length    +  =     (  ( float )     ( Msqrt (  (  ( x    *    x )     +     ( y    *    y )  )  )  )  )  ;", "}", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   originX ;", "}", "METHOD_END"], "methodName": ["getOriginX"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   originY ;", "}", "METHOD_END"], "methodName": ["getOriginY"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   rotation ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   scaleX ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   scaleY ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( calculateScaledLength )  )", "return   scaledLength ;", "calculateScaledLength    =    false ;", "scaledLength    =     0  ;", "for    ( int   i    =     0  ,    n    =     ( localVertices . length )     -     2  ;    i    <    n ;    i    +  =     2  )     {", "float   x    =     (  ( localVertices [  ( i    +     2  )  ]  )     *     ( scaleX )  )     -     (  ( localVertices [ i ]  )     *     ( scaleX )  )  ;", "float   y    =     (  ( localVertices [  ( i    +     1  )  ]  )     *     ( scaleY )  )     -     (  ( localVertices [  ( i    +     3  )  ]  )     *     ( scaleY )  )  ;", "scaledLength    +  =     (  ( float )     ( Msqrt (  (  ( x    *    x )     +     ( y    *    y )  )  )  )  )  ;", "}", "return   scaledLength ;", "}", "METHOD_END"], "methodName": ["getScaledLength"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dirty )  )", "return   worldVertices ;", "dirty    =    false ;", "final   float [  ]    localVertices    =    this . localVertices ;", "if    (  (  ( worldVertices )     =  =    null )     |  |     (  ( worldVertices . length )     <     ( localVertices . length )  )  )", "worldVertices    =    new   float [ localVertices . length ]  ;", "final   float [  ]    worldVertices    =    this . worldVertices ;", "final   float   positionX    =    x ;", "final   float   positionY    =    y ;", "final   float   originX    =    this . originX ;", "final   float   originY    =    this . originY ;", "final   float   scaleX    =    this . scaleX ;", "final   float   scaleY    =    this . scaleY ;", "final   boolean   scale    =     ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  ;", "final   float   rotation    =    this . rotation ;", "final   float   cos    =    MUtils . cosDeg ( rotation )  ;", "final   float   sin    =    MUtils . sinDeg ( rotation )  ;", "for    ( int   i    =     0  ,    n    =    localVertices . length ;    i    <    n ;    i    +  =     2  )     {", "float   x    =     ( localVertices [ i ]  )     -    originX ;", "float   y    =     ( localVertices [  ( i    +     1  )  ]  )     -    originY ;", "if    ( scale )     {", "x    *  =    scaleX ;", "y    *  =    scaleY ;", "}", "if    ( rotation    !  =     0  )     {", "float   oldX    =    x ;", "x    =     ( cos    *    x )     -     ( sin    *    y )  ;", "y    =     ( sin    *    oldX )     +     ( cos    *    y )  ;", "}", "worldVertices [ i ]     =     ( positionX    +    x )     +    originX ;", "worldVertices [  ( i    +     1  )  ]     =     ( positionY    +    y )     +    originY ;", "}", "return   worldVertices ;", "}", "METHOD_END"], "methodName": ["getTransformedVertices"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   localVertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "rotation    +  =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    +  =    amount ;", "this . scaleY    +  =    amount ;", "dirty    =    true ;", "calculateScaledLength    =    true ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "this . originX    =    originX ;", "this . originY    =    originY ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "this . rotation    =    degrees ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleX ;", "this . scaleY    =    scaleY ;", "dirty    =    true ;", "calculateScaledLength    =    true ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "if    (  ( vertices . length )     <     4  )", "throw   new   IllegalArgumentException (  \" ps   must   contain   at   least    2    points .  \"  )  ;", "this . localVertices    =    vertices ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["setVertices"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    x ;", "this . y    +  =    y ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Polyline"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    quaternion . x ;", "this . y    +  =    quaternion . y ;", "this . z    +  =    quaternion . z ;", "this . w    +  =    quaternion . w ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    qx ;", "this . y    +  =    qy ;", "this . z    +  =    qz ;", "this . w    +  =    qw ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "x    =     -  ( x )  ;", "y    =     -  ( y )  ;", "z    =     -  ( z )  ;", "retu   this ;", "}", "METHOD_END"], "methodName": ["conjugate"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   new   Quaternion ( this )  ;", "}", "METHOD_END"], "methodName": ["cpy"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( this . x )     *     ( other . x )  )     +     (  ( this . y )     *     ( other . y )  )  )     +     (  ( this . z )     *     ( other . z )  )  )     +     (  ( this . w )     *     ( other . w )  )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( this . x )     *    x )     +     (  ( this . y )     *    y )  )     +     (  ( this . z )     *    z )  )     +     (  ( this . w )     *    w )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( x 1     *    x 2  )     +     ( y 1     *    y 2  )  )     +     ( z 1     *    z 2  )  )     +     ( w 1     *    w 2  )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "float   norm    =    len (  )  ;", "float   normExp    =     (  ( float )     ( Mpow ( norm ,    alpha )  )  )  ;", "float   theta    =     (  ( float )     ( Macos (  (  ( w )     /    norm )  )  )  )  ;", "float   coeff    =     0  ;", "if    (  ( Mabs ( theta )  )     <     0  .  0  0  1  )", "coeff    =     ( normExp    *    alpha )     /    norm ;", "else", "coeff    =     (  ( float )     (  ( normExp    *     ( Msin (  ( alpha    *    theta )  )  )  )     /     ( norm    *     ( Msin ( theta )  )  )  )  )  ;", "w    =     (  ( float )     ( normExp    *     ( Mcos (  ( alpha    *    theta )  )  )  )  )  ;", "x    *  =    coeff ;", "y    *  =    coeff ;", "z    *  =    coeff ;", "nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exp"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    ( getAngleRad (  )  )     *     ( MathUtils . radiansToDegrees )  ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   getAngleAround ( axis . x ,    axis . y ,    axis . z )  ;", "}", "METHOD_END"], "methodName": ["getAngleAround"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    ( getAngleAroundRad ( axisX ,    axisY ,    axisZ )  )     *     ( MathUtils . radiansToDegrees )  ;", "}", "METHOD_END"], "methodName": ["getAngleAround"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   getAngleAroundRad ( axis . x ,    axis . y ,    axis . z )  ;", "}", "METHOD_END"], "methodName": ["getAngleAroundRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   d    =    Vector 3  . dot ( this . x ,    this . y ,    this . z ,    axisX ,    axisY ,    axisZ )  ;", "final   float   l 2     =     . len 2  (  ( axisX    *    d )  ,     ( axisY    *    d )  ,     ( axisZ    *    d )  ,    this . w )  ;", "return   MathUtils . isZero ( l 2  )     ?     0  .  0 F    :     (  ( float )     (  2  .  0     *     ( Math . acos ( MathUtils . clamp (  (  ( float )     (  ( d    <     0     ?     -  ( this . w )     :    this . w )     /     ( Math . sqrt ( l 2  )  )  )  )  ,     (  -  1  .  0 F )  ,     1  .  0 F )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAngleAroundRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     (  2  .  0     *     ( Math . acos (  (  ( this . w )     >     1     ?     ( this . w )     /     ( len (  )  )     :    this . w )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAngleRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    ( getAxisAngleRad ( axis )  )     *     ( MathUtils . radiansToDegrees )  ;", "}", "METHOD_END"], "methodName": ["getAxisAngle"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . w )     >     1  )", "this . nor (  )  ;", "float   angle    =     (  ( float )     (  2  .  0     *     ( Macos ( this . w )  )  )  )  ;", "double   s    =    Msqrt (  (  1     -     (  ( this . w )     *     ( this . w )  )  )  )  ;", "if    ( s    <     ( Mtils . FLOAT _ ROUNDING _ ERROR )  )     {", "axis . x    =    this . x ;", "axis . y    =    this . y ;", "axis . z    =    this . z ;", "} else    {", "axis . x    =     (  ( float )     (  ( this . x )     /    s )  )  ;", "axis . y    =     (  ( float )     (  ( this . y )     /    s )  )  ;", "axis . z    =     (  ( float )     (  ( this . z )     /    s )  )  ;", "}", "return   angle ;", "}", "METHOD_END"], "methodName": ["getAxisAngleRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   t    =     (  ( y )     *     ( x )  )     +     (  ( z )     *     ( w )  )  ;", "return   t    >     0  .  4  9  9 F    ?     1     :    t    <     (  -  0  .  4  9  9 F )     ?     -  1     :     0  ;", "}", "METHOD_END"], "methodName": ["getGimbalPole"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    ( getPitchRad (  )  )     *     ( MathUtils . radiansToDegrees )  ;", "}", "METHOD_END"], "methodName": ["getPitch"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   int   pole    =    getGimbalPole (  )  ;", "return   pole    =  =     0     ?     (  ( float )     ( Masin ( Mtils . clamp (  (  2  .  0 F    *     (  (  ( w )     *     ( x )  )     -     (  ( z )     *     ( y )  )  )  )  ,     (  -  1  .  0 F )  ,     1  .  0 F )  )  )  )     :     (  (  ( float )     ( pole )  )     *     ( Mtils . PI )  )     *     0  .  5 F ;", "}", "METHOD_END"], "methodName": ["getPitchRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    ( getRollRad (  )  )     *     ( MathUtils . radiansToDegrees )  ;", "}", "METHOD_END"], "methodName": ["getRoll"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   int   pole    =    getGimbalPole (  )  ;", "return   pole    =  =     0     ?    MUtils . atan 2  (  (  2  .  0 F    *     (  (  ( w )     *     ( z )  )     +     (  ( y )     *     ( x )  )  )  )  ,     (  1  .  0 F    -     (  2  .  0 F    *     (  (  ( x )     *     ( x )  )     +     (  ( z )     *     ( z )  )  )  )  )  )     :     (  (  ( float )     ( pole )  )     *     2  .  0 F )     *     ( MUtils . atan 2  ( y ,    w )  )  ;", "}", "METHOD_END"], "methodName": ["getRollRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "getSwingTwist ( axis . x ,    axis . y ,    axis . z ,    swing ,    twist )  ;", "}", "METHOD_END"], "methodName": ["getSwingTwist"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   d    =    Vector 3  . dot ( this . x ,    this . y ,    this . z ,    axisX ,    axisY ,    axisZ )  ;", "twist . set (  ( axisX    *    d )  ,     ( axisY    *    d )  ,     ( axisZ    *    d )  ,    this . w )  . nor (  )  ;", "if    ( d    <     0  )", "twist . mul (  (  -  1  .  0 F )  )  ;", "swing . set ( twist )  . conjug (  )  . mulLeft ( this )  ;", "}", "METHOD_END"], "methodName": ["getSwingTwist"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    ( getYawRad (  )  )     *     ( MathUtils . radiansToDegrees )  ;", "}", "METHOD_END"], "methodName": ["getYaw"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    ( getGimbalPole (  )  )     =  =     0     ?    MathUtils . atan 2  (  (  2  .  0 F    *     (  (  ( y )     *     ( w )  )     +     (  ( x )     *     ( z )  )  )  )  ,     (  1  .  0 F    -     (  2  .  0 F    *     (  (  ( y )     *     ( y )  )     +     (  ( x )     *     ( x )  )  )  )  )  )     :     0  .  0 F ;", "}", "METHOD_END"], "methodName": ["getYawRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  0  ,     0  ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["idt"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( MathUtils . isZero ( x )  )     &  &     ( MathUtils . isZero ( y )  )  )     &  &     ( MathUtils . isZero ( z )  )  )     &  &     ( MathUtils . isEqual ( w ,     1  .  0 F )  )  ;", "}", "METHOD_END"], "methodName": ["isIdentity"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( MathUtils . isZero ( x ,    tolerance )  )     &  &     ( MathUtils . isZero ( y ,    tolerance )  )  )     &  &     ( MathUtils . isZero ( z ,    tolerance )  )  )     &  &     ( MathUtils . isEqual ( w ,     1  .  0 F ,    tolerance )  )  ;", "}", "METHOD_END"], "methodName": ["isIdentity"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . sqrt (  (  (  (  (  ( x )     *     ( x )  )     +     (  ( y )     *     ( y )  )  )     +     (  ( z )     *     ( z )  )  )     +     (  ( w )     *     ( w )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["len"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . sqrt (  (  (  (  ( x    *    x )     +     ( y    *    y )  )     +     ( z    *    z )  )     +     ( w    *    w )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["len"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( x )     *     ( x )  )     +     (  ( y )     *     ( y )  )  )     +     (  ( z )     *     ( z )  )  )     +     (  ( w )     *     ( w )  )  ;", "}", "METHOD_END"], "methodName": ["len2"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( x    *    x )     +     ( y    *    y )  )     +     ( z    *    z )  )     +     ( w    *    w )  ;", "}", "METHOD_END"], "methodName": ["len2"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   newX    =     (  (  (  ( this . w )     *     ( other . x )  )     +     (  ( this . x )     *     ( other . w )  )  )     +     (  ( this . y )     *     ( other . z )  )  )     -     (  ( this . z )     *     ( other . y )  )  ;", "final   float   newY    =     (  (  (  ( this . w )     *     ( other . y )  )     +     (  ( this . y )     *     ( other . w )  )  )     +     (  ( this . z )     *     ( other . x )  )  )     -     (  ( this . x )     *     ( other . z )  )  ;", "final   float   newZ    =     (  (  (  ( this . w )     *     ( other . z )  )     +     (  ( this . z )     *     ( other . w )  )  )     +     (  ( this . x )     *     ( other . y )  )  )     -     (  ( this . y )     *     ( other . x )  )  ;", "final   float   newW    =     (  (  (  ( this . w )     *     ( other . w )  )     -     (  ( this . x )     *     ( other . x )  )  )     -     (  ( this . y )     *     ( other . y )  )  )     -     (  ( this . z )     *     ( other . z )  )  ;", "this . x    =    newX ;", "this . y    =    newY ;", "this . z    =    newZ ;", "this . w    =    newW ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "this . x    *  =    scalar ;", "this . y    *  =    scalar ;", "this . z    *  =    scalar ;", "this . w    *  =    scalar ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   newX    =     (  (  (  ( this . w )     *    x )     +     (  ( this . x )     *    w )  )     +     (  ( this . y )     *    z )  )     -     (  ( this . z )     *    y )  ;", "final   float   newY    =     (  (  (  ( this . w )     *    y )     +     (  ( this . y )     *    w )  )     +     (  ( this . z )     *    x )  )     -     (  ( this . x )     *    z )  ;", "final   float   newZ    =     (  (  (  ( this . w )     *    z )     +     (  ( this . z )     *    w )  )     +     (  ( this . x )     *    y )  )     -     (  ( this . y )     *    x )  ;", "final   float   newW    =     (  (  (  ( this . w )     *    w )     -     (  ( this . x )     *    x )  )     -     (  ( this . y )     *    y )  )     -     (  ( this . z )     *    z )  ;", "this . x    =    newX ;", "this . y    =    newY ;", "this . z    =    newZ ;", "this . w    =    newW ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   newX    =     (  (  (  ( other . w )     *     ( this . x )  )     +     (  ( other . x )     *     ( this . w )  )  )     +     (  ( other . y )     *     ( this . z )  )  )     -     (  ( other . z )     *     ( this . y )  )  ;", "final   float   newY    =     (  (  (  ( other . w )     *     ( this . y )  )     +     (  ( other . y )     *     ( this . w )  )  )     +     (  ( other . z )     *     ( this . x )  )  )     -     (  ( other . x )     *     ( this . z )  )  ;", "final   float   newZ    =     (  (  (  ( other . w )     *     ( this . z )  )     +     (  ( other . z )     *     ( this . w )  )  )     +     (  ( other . x )     *     ( this . y )  )  )     -     (  ( other . y )     *     ( this . x )  )  ;", "final   float   newW    =     (  (  (  ( other . w )     *     ( this . w )  )     -     (  ( other . x )     *     ( this . x )  )  )     -     (  ( other . y )     *     ( this . y )  )  )     -     (  ( other . z )     *     ( this . z )  )  ;", "this . x    =    newX ;", "this . y    =    newY ;", "this . z    =    newZ ;", "this . w    =    newW ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mulLeft"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   newX    =     (  (  ( w    *     ( this . x )  )     +     ( x    *     ( this . w )  )  )     +     ( y    *     ( this . z )  )  )     -     ( z    *     ( this . y )  )  ;", "final   float   newY    =     (  (  ( w    *     ( this . y )  )     +     ( y    *     ( this . w )  )  )     +     ( z    *     ( this . x )  )  )     -     ( x    *     ( this . z )  )  ;", "final   float   newZ    =     (  (  ( w    *     ( this . z )  )     +     ( z    *     ( this . w )  )  )     +     ( x    *     ( this . y )  )  )     -     ( y    *     ( this . x )  )  ;", "final   float   newW    =     (  (  ( w    *     ( this . w )  )     -     ( x    *     ( this . x )  )  )     -     ( y    *     ( this . y )  )  )     -     ( z    *     ( this . z )  )  ;", "this . x    =    newX ;", "this . y    =    newY ;", "this . z    =    newZ ;", "this . w    =    newW ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mulLeft"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "float   len    =    len 2  (  )  ;", "if    (  ( len    !  =     0  .  0 F )     &  &     (  !  ( Mtils . isEqual ( len ,     1  .  0 F )  )  )  )     {", "len    =     (  ( float )     ( Msqrt ( len )  )  )  ;", "w    /  =    len ;", "x    /  =    len ;", "y    /  =    len ;", "z    /  =    len ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["nor"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( quaternion . x ,    quaternion . y ,    quaternion . z ,    quaternion . w )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromAxis ( axis . x ,    axis . y ,    axis . z ,    angle )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . z    =    z ;", "this . w    =    w ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setEulerAnglesRad (  ( yaw    *     ( MathUtils . degreesToRadians )  )  ,     ( pitch    *     ( MathUtils . degreesToRadians )  )  ,     ( roll    *     ( MathUtils . degreesToRadians )  )  )  ;", "}", "METHOD_END"], "methodName": ["setEulerAngles"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   hr    =    roll    *     0  .  5 F ;", "final   float   shr    =     (  ( float )     ( Msin ( hr )  )  )  ;", "final   float   chr    =     (  ( float )     ( Mcos ( hr )  )  )  ;", "final   float   hp    =    pitch    *     0  .  5 F ;", "final   float   shp    =     (  ( float )     ( Msin ( hp )  )  )  ;", "final   float   chp    =     (  ( float )     ( Mcos ( hp )  )  )  ;", "final   float   hy    =    yaw    *     0  .  5 F ;", "final   float   shy    =     (  ( float )     ( Msin ( hy )  )  )  ;", "final   float   chy    =     (  ( float )     ( Mcos ( hy )  )  )  ;", "final   float   chy _ shp    =    chy    *    shp ;", "final   float   shy _ chp    =    shy    *    chp ;", "final   float   chy _ chp    =    chy    *    chp ;", "final   float   shy _ shp    =    shy    *    shp ;", "x    =     ( chy _ shp    *    chr )     +     ( shy _ chp    *    shr )  ;", "y    =     ( shy _ chp    *    chr )     -     ( chy _ shp    *    shr )  ;", "z    =     ( chy _ chp    *    shr )     -     ( shy _ shp    *    chr )  ;", "w    =     ( chy _ chp    *    chr )     +     ( shy _ shp    *    shr )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setEulerAnglesRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "if    ( normalizeAxes )     {", "final   float   lx    =     1  .  0 F    /     ( Vector 3  . len ( xx ,    xy ,    xz )  )  ;", "final   float   ly    =     1  .  0 F    /     ( Vector 3  . len ( yx ,    yy ,    yz )  )  ;", "final   float   lz    =     1  .  0 F    /     ( Vector 3  . len ( zx ,    zy ,    zz )  )  ;", "xx    *  =    lx ;", "xy    *  =    lx ;", "xz    *  =    lx ;", "yx    *  =    ly ;", "yy    *  =    ly ;", "yz    *  =    ly ;", "zx    *  =    lz ;", "zy    *  =    lz ;", "zz    *  =    lz ;", "}", "final   float   t    =     ( xx    +    yy )     +    zz ;", "if    ( t    >  =     0  )     {", "float   s    =     (  ( float )     ( Msqrt (  ( t    +     1  )  )  )  )  ;", "w    =     0  .  5 F    *    s ;", "s    =     0  .  5 F    /    s ;", "x    =     ( zy    -    yz )     *    s ;", "y    =     ( xz    -    zx )     *    s ;", "z    =     ( yx    -    xy )     *    s ;", "} else", "if    (  ( xx    >    yy )     &  &     ( xx    >    zz )  )     {", "float   s    =     (  ( float )     ( Msqrt (  (  (  (  1  .  0     +    xx )     -    yy )     -    zz )  )  )  )  ;", "x    =    s    *     0  .  5 F ;", "s    =     0  .  5 F    /    s ;", "y    =     ( yx    +    xy )     *    s ;", "z    =     ( xz    +    zx )     *    s ;", "w    =     ( zy    -    yz )     *    s ;", "} else", "if    ( yy    >    zz )     {", "float   s    =     (  ( float )     ( Msqrt (  (  (  (  1  .  0     +    yy )     -    xx )     -    zz )  )  )  )  ;", "y    =    s    *     0  .  5 F ;", "s    =     0  .  5 F    /    s ;", "x    =     ( yx    +    xy )     *    s ;", "z    =     ( zy    +    yz )     *    s ;", "w    =     ( xz    -    zx )     *    s ;", "} else    {", "float   s    =     (  ( float )     ( Msqrt (  (  (  (  1  .  0     +    zz )     -    xx )     -    yy )  )  )  )  ;", "z    =    s    *     0  .  5 F ;", "s    =     0  .  5 F    /    s ;", "x    =     ( xz    +    zx )     *    s ;", "y    =     ( zy    +    yz )     *    s ;", "w    =     ( yx    -    xy )     *    s ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setFromAxes"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromAxes ( false ,    xx ,    xy ,    xz ,    yx ,    yy ,    yz ,    zx ,    zy ,    zz )  ;", "}", "METHOD_END"], "methodName": ["setFromAxes"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromAxis ( axis . x ,    axis . y ,    axis . z ,    degrees )  ;", "}", "METHOD_END"], "methodName": ["setFromAxis"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromAxisRad ( x ,    y ,    z ,     ( degrees    *     ( MathUtils . degreesToRadians )  )  )  ;", "}", "METHOD_END"], "methodName": ["setFromAxis"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromAxisRad ( axis . x ,    axis . y ,    axis . z ,    radians )  ;", "}", "METHOD_END"], "methodName": ["setFromAxisRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "float   d    =    Vector 3  . len ( x ,    y ,    z )  ;", "if    ( d    =  =     0  .  0 F )", "return   idt (  )  ;", "d    =     1  .  0 F    /    d ;", "float   l _ ang    =     ( radians    <     0  )     ?     ( Mtils . PI 2  )     -     (  (  - radians )     %     ( Mtils . PI 2  )  )     :    radians    %     ( Mtils . PI 2  )  ;", "float   l _ sin    =     (  ( float )     ( Msin (  ( l _ ang    /     2  )  )  )  )  ;", "float   l _ cos    =     (  ( float )     ( Mcos (  ( l _ ang    /     2  )  )  )  )  ;", "return   this . set (  (  ( d    *    x )     *    l _ sin )  ,     (  ( d    *    y )     *    l _ sin )  ,     (  ( d    *    z )     *    l _ sin )  ,    l _ cos )  . nor (  )  ;", "}", "METHOD_END"], "methodName": ["setFromAxisRad"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   dot    =    Mtils . clamp ( v 1  . dot ( v 2  )  ,     (  -  1  .  0 F )  ,     1  .  0 F )  ;", "final   float   angle    =     (  ( float )     ( Macos ( dot )  )  )  ;", "return   setFromAxisRad (  (  (  ( v 1  . y )     *     ( v 2  . z )  )     -     (  ( v 1  . z )     *     ( v 2  . y )  )  )  ,     (  (  ( v 1  . z )     *     ( v 2  . x )  )     -     (  ( v 1  . x )     *     ( v 2  . z )  )  )  ,     (  (  ( v 1  . x )     *     ( v 2  . y )  )     -     (  ( v 1  . y )     *     ( v 2  . x )  )  )  ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setFromCross"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   dot    =    Mtils . clamp ( Vector 3  . dot ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  )  ,     (  -  1  .  0 F )  ,     1  .  0 F )  ;", "final   float   angle    =     (  ( float )     ( Macos ( dot )  )  )  ;", "return   setFromAxisRad (  (  ( y 1     *    z 2  )     -     ( z 1     *    y 2  )  )  ,     (  ( z 1     *    x 2  )     -     ( x 1     *    z 2  )  )  ,     (  ( x 1     *    y 2  )     -     ( y 1     *    x 2  )  )  ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setFromCross"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromAxes ( normalizeAxes ,    matrix . val [ Matrix 3  . M 0  0  ]  ,    matrix . val [ Matrix 3  . M 0  1  ]  ,    matrix . val [ Matrix 3  . M 0  2  ]  ,    matrix . val [ Matrix 3  . M 1  0  ]  ,    matrix . val [ Matrix 3  . M 1  1  ]  ,    matrix . val [ Matrix 3  . M 1  2  ]  ,    matrix . val [ Matrix 3  . M 2  0  ]  ,    matrix . val [ Matrix 3  . M 2  1  ]  ,    matrix . val [ Matrix 3  . M 2  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["setFromMatrix"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromAxes ( normalizeAxes ,    matrix . val [ Matrix 4  . M 0  0  ]  ,    matrix . val [ Matrix 4  . M 0  1  ]  ,    matrix . val [ Matrix 4  . M 0  2  ]  ,    matrix . val [ Matrix 4  . M 1  0  ]  ,    matrix . val [ Matrix 4  . M 1  1  ]  ,    matrix . val [ Matrix 4  . M 1  2  ]  ,    matrix . val [ Matrix 4  . M 2  0  ]  ,    matrix . val [ Matrix 4  . M 2  1  ]  ,    matrix . val [ Matrix 4  . M 2  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["setFromMatrix"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromMatrix ( false ,    matrix )  ;", "}", "METHOD_END"], "methodName": ["setFromMatrix"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   setFromMatrix ( false ,    matrix )  ;", "}", "METHOD_END"], "methodName": ["setFromMatrix"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   d    =     (  (  (  ( this . x )     *     ( end . x )  )     +     (  ( this . y )     *     ( end . y )  )  )     +     (  ( this . z )     *     ( end . z )  )  )     +     (  ( this . w )     *     ( end . w )  )  ;", "float   absDot    =     ( d    <     0  .  0 F )     ?     - d    :    d ;", "float   scale 0     =     1  .  0 F    -    alpha ;", "float   scale 1     =    alpha ;", "if    (  (  1     -    absDot )     >     0  .  1  )     {", "final   float   angle    =     (  ( float )     ( Macos ( absDot )  )  )  ;", "final   float   invSinTheta    =     1  .  0 F    /     (  ( float )     ( Msin ( angle )  )  )  ;", "scale 0     =     (  ( float )     ( Msin (  (  (  1  .  0 F    -    alpha )     *    angle )  )  )  )     *    invSinTheta ;", "scale 1     =     (  ( float )     ( Msin (  ( alpha    *    angle )  )  )  )     *    invSinTheta ;", "}", "if    ( d    <     0  .  0 F )", "scale 1     =     - scale 1  ;", "x    =     ( scale 0     *     ( x )  )     +     ( scale 1     *     ( end . x )  )  ;", "y    =     ( scale 0     *     ( y )  )     +     ( scale 1     *     ( end . y )  )  ;", "z    =     ( scale 0     *     ( z )  )     +     ( scale 1     *     ( end . z )  )  ;", "w    =     ( scale 0     *     ( w )  )     +     ( scale 1     *     ( end . w )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["slerp"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   w    =     1  .  0 F    /     ( q . length )  ;", "set ( q [  0  ]  )  . exp ( w )  ;", "for    ( int   i    =     1  ;    i    <     ( q . length )  ;    i +  +  )", "mul (  . tmp 1  . set ( q [ i ]  )  . exp ( w )  )  ;", "nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["slerp"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "set ( q [  0  ]  )  . exp ( w [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( q . length )  ;    i +  +  )", "mul (  . tmp 1  . set ( q [ i ]  )  . exp ( w [ i ]  )  )  ;", "nor (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["slerp"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "final   float   xx    =     ( x )     *     ( x )  ;", "final   float   xy    =     ( x )     *     ( y )  ;", "final   float   xz    =     ( x )     *     ( z )  ;", "final   float   xw    =     ( x )     *     ( w )  ;", "final   float   yy    =     ( y )     *     ( y )  ;", "final   float   yz    =     ( y )     *     ( z )  ;", "final   float   yw    =     ( y )     *     ( w )  ;", "final   float   zz    =     ( z )     *     ( z )  ;", "final   float   zw    =     ( z )     *     ( w )  ;", "rix [ Matrix 4  . M 0  0  ]     =     1     -     (  2     *     ( yy    +    zz )  )  ;", "rix [ Matrix 4  . M 0  1  ]     =     2     *     ( xy    -    zw )  ;", "rix [ Matrix 4  . M 0  2  ]     =     2     *     ( xz    +    yw )  ;", "rix [ Matrix 4  . M 0  3  ]     =     0  ;", "rix [ Matrix 4  . M 1  0  ]     =     2     *     ( xy    +    zw )  ;", "rix [ Matrix 4  . M 1  1  ]     =     1     -     (  2     *     ( xx    +    zz )  )  ;", "rix [ Matrix 4  . M 1  2  ]     =     2     *     ( yz    -    xw )  ;", "rix [ Matrix 4  . M 1  3  ]     =     0  ;", "rix [ Matrix 4  . M 2  0  ]     =     2     *     ( xz    -    yw )  ;", "rix [ Matrix 4  . M 2  1  ]     =     2     *     ( yz    +    xw )  ;", "rix [ Matrix 4  . M 2  2  ]     =     1     -     (  2     *     ( xx    +    yy )  )  ;", "rix [ Matrix 4  . M 2  3  ]     =     0  ;", "rix [ Matrix 4  . M 3  0  ]     =     0  ;", "rix [ Matrix 4  . M 3  1  ]     =     0  ;", "rix [ Matrix 4  . M 3  2  ]     =     0  ;", "rix [ Matrix 4  . M 3  3  ]     =     1  ;", "}", "METHOD_END"], "methodName": ["toMatrix"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "Quaternion . tmp 2  . set ( this )  ;", "Quaternion . tmp 2  . conjugate (  )  ;", "Quaternion . tmp 2  . mulLeft ( Quaternion . tmp 1  . set ( v . x ,    v . y ,    v . z ,     0  )  )  . mulLeft ( this )  ;", "v . x    =    Quaternion . tmp 2  . x ;", "v . y    =    Quaternion . tmp 2  . y ;", "v . z    =    Quaternion . tmp 2  . z ;", "return   v ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.math.Quaternion"}, {"methodBody": ["METHOD_START", "{", "return   seed    =  =     0     ?    seed 0     :    seed 1  ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "com.badlogic.gdx.math.RandomXS128"}, {"methodBody": ["METHOD_START", "{", "x    ^  =    x    >  >  >     3  3  ;", "x    *  =     -  4  9  0  6  4  7  7  8  9  8  9  7  5  6  3 L ;", "x    ^  =    x    >  >  >     3  3  ;", "x    *  =     -  4  2  6  5  2  6  7  2  9  6  0  5  5  4  6  4  8  7  7 L ;", "x    ^  =    x    >  >  >     3  3  ;", "return   x ;", "}", "METHOD_END"], "methodName": ["murmurHash3"], "fileName": "com.badlogic.gdx.math.RandomXS128"}, {"methodBody": ["METHOD_START", "{", "if    ( n    <  =     0  )", "row   new   IllegalArgumentException (  \" n   must   be   positive \"  )  ;", "for    (  ;     ;  )     {", "final   long   bits    =     ( nextLong (  )  )     >  >  >     1  ;", "final   long   value    =    bits    %    n ;", "if    (  (  ( bits    -    value )     +     ( n    -     1  )  )     >  =     0  )", "return   value ;", "}", "}", "METHOD_END"], "methodName": ["nextLong"], "fileName": "com.badlogic.gdx.math.RandomXS128"}, {"methodBody": ["METHOD_START", "{", "this . seed 0     =    seed 0  ;", "this . seed 1     =    seed 1  ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "com.badlogic.gdx.math.RandomXS128"}, {"methodBody": ["METHOD_START", "{", "return    ( this . width )     *     ( this . height )  ;", "}", "METHOD_END"], "methodName": ["area"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( circle . x )     -     ( circle . radius )  )     >  =     ( x )  )     &  &     (  (  ( circle . x )     +     ( circle . radius )  )     <  =     (  ( x )     +     ( width )  )  )  )     &  &     (  (  ( circle . y )     -     ( circle . radius )  )     >  =     ( y )  )  )     &  &     (  (  ( circle . y )     +     ( circle . radius )  )     <  =     (  ( y )     +     ( height )  )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "float   xmin    =    rectangle . x ;", "float   xmax    =    xmin    +     ( rectangle . width )  ;", "float   ymin    =    rectangle . y ;", "float   ymax    =    ymin    +     ( rectangle . height )  ;", "return    (  (  ( xmin    >     ( x )  )     &  &     ( xmin    <     (  ( x )     +     ( width )  )  )  )     &  &     (  ( xmax    >     ( x )  )     &  &     ( xmax    <     (  ( x )     +     ( width )  )  )  )  )     &  &     (  (  ( ymin    >     ( y )  )     &  &     ( ymin    <     (  ( y )     +     ( height )  )  )  )     &  &     (  ( ymax    >     ( y )  )     &  &     ( ymax    <     (  ( y )     +     ( height )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   contains ( point . x ,    point . y )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( this . x )     <  =    x )     &  &     (  (  ( this . x )     +     ( this . width )  )     >  =    x )  )     &  &     (  ( this . y )     <  =    y )  )     &  &     (  (  ( this . y )     +     ( this . height )  )     >  =    y )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    obj )", "return   true ;", "if    ( obj    =  =    null )", "return   false ;", "if    (  ( getClass (  )  )     !  =     ( obj . getClass (  )  )  )", "return   false ;", "other    =     (  (  )     ( obj )  )  ;", "if    (  ( NumberUtils . floatToRawIntBits ( height )  )     !  =     ( NumberUtils . floatToRawIntBits ( other . height )  )  )", "return   false ;", "if    (  ( NumberUtils . floatToRawIntBits ( width )  )     !  =     ( NumberUtils . floatToRawIntBits ( other . width )  )  )", "return   false ;", "if    (  ( NumberUtils . floatToRawIntBits ( x )  )     !  =     ( NumberUtils . floatToRawIntBits ( other . x )  )  )", "return   false ;", "if    (  ( NumberUtils . floatToRawIntBits ( y )  )     !  =     ( NumberUtils . floatToRawIntBits ( other . y )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "float   ratio    =    getAspectRatio (  )  ;", "if    ( ratio    <     ( rect . getAspectRatio (  )  )  )     {", "setSize (  (  ( rect . height )     *    ratio )  ,    rect . height )  ;", "} else    {", "setSize ( rect . width ,     (  ( rect . width )     /    ratio )  )  ;", "}", "setPosition (  (  (  ( rect . x )     +     (  ( rect . width )     /     2  )  )     -     (  ( width )     /     2  )  )  ,     (  (  ( rect . y )     +     (  ( rect . height )     /     2  )  )     -     (  ( height )     /     2  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fitInside"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "float   ratio    =    getAspectRatio (  )  ;", "if    ( ratio    >     ( rect . getAspectRatio (  )  )  )     {", "setSize (  (  ( rect . height )     *    ratio )  ,    rect . height )  ;", "} else    {", "setSize ( rect . width ,     (  ( rect . width )     /    ratio )  )  ;", "}", "setPosition (  (  (  ( rect . x )     +     (  ( rect . width )     /     2  )  )     -     (  ( width )     /     2  )  )  ,     (  (  ( rect . y )     +     (  ( rect . height )     /     2  )  )     -     (  ( height )     /     2  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fitOutside"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "int   s 0     =    v . indexOf (  '  ,  '  ,     1  )  ;", "int   s 1     =    v . indexOf (  '  ,  '  ,     ( s 0     +     1  )  )  ;", "int   s 2     =    v . indexOf (  '  ,  '  ,     ( s 1     +     1  )  )  ;", "if    (  (  (  (  ( s 0     !  =     (  -  1  )  )     &  &     ( s 1     !  =     (  -  1  )  )  )     &  &     ( s 2     !  =     (  -  1  )  )  )     &  &     (  ( v . charAt (  0  )  )     =  =     '  [  '  )  )     &  &     (  ( v . charAt (  (  ( v . length (  )  )     -     1  )  )  )     =  =     '  ]  '  )  )     {", "try    {", "float   x    =    Float . parseFloat ( v . substring (  1  ,    s 0  )  )  ;", "float   y    =    Float . parseFloat ( v . substring (  ( s 0     +     1  )  ,    s 1  )  )  ;", "float   width    =    Float . parseFloat ( v . substring (  ( s 1     +     1  )  ,    s 2  )  )  ;", "float   height    =    Float . parseFloat ( v . substring (  ( s 2     +     1  )  ,     (  ( v . length (  )  )     -     1  )  )  )  ;", "return   this . set ( x ,    y ,    width ,    height )  ;", "}    catch    ( NumberFormatException   ex )     {", "}", "}", "throw   new   GdxRuntimeException (  (  \" Malformed    :     \"     +    v )  )  ;", "}", "METHOD_END"], "methodName": ["fromString"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return    ( height )     =  =     0     ?    Float . NaN    :     ( width )     /     ( height )  ;", "}", "METHOD_END"], "methodName": ["getAspectRatio"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "vector . x    =     ( x )     +     (  ( width )     /     2  )  ;", "vector . y    =     ( y )     +     (  ( height )     /     2  )  ;", "return   vector ;", "}", "METHOD_END"], "methodName": ["getCenter"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   position . set ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   size . set ( width ,    height )  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "final   int   prime    =     3  1  ;", "int   result    =     1  ;", "result    =     ( prime    *    result )     +     ( NumberUtils . fatToRawIntBits ( height )  )  ;", "result    =     ( prime    *    result )     +     ( NumberUtils . fatToRawIntBits ( width )  )  ;", "result    =     ( prime    *    result )     +     ( NumberUtils . fatToRawIntBits ( x )  )  ;", "result    =     ( prime    *    result )     +     ( NumberUtils . fatToRawIntBits ( y )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "float   minX    =    Math . min ( x ,    rect . x )  ;", "float   maxX    =    Math . max (  (  ( x )     +     ( width )  )  ,     (  ( rect . x )     +     ( rect . width )  )  )  ;", "x    =    minX ;", "width    =    maxX    -    minX ;", "float   minY    =    Math . min ( y ,    rect . y )  ;", "float   maxY    =    Math . max (  (  ( y )     +     ( height )  )  ,     (  ( rect . y )     +     ( rect . height )  )  )  ;", "y    =    minY ;", "height    =    maxY    -    minY ;", "return   this ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return   merge ( vec . x ,    vec . y )  ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "float   minX    =    x ;", "float   maxX    =     ( x )     +     ( width )  ;", "float   minY    =    y ;", "float   maxY    =     ( y )     +     ( height )  ;", "for    ( int   i    =     0  ;    i    <     ( vecs . length )  ;     +  + i )     {", "Vector 2    v    =    vecs [ i ]  ;", "minX    =    Mmin ( minX ,    v . x )  ;", "maxX    =    Mmax ( maxX ,    v . x )  ;", "minY    =    Mmin ( minY ,    v . y )  ;", "maxY    =    Mmax ( maxY ,    v . y )  ;", "}", "x    =    minX ;", "width    =    maxX    -    minX ;", "y    =    minY ;", "height    =    maxY    -    minY ;", "return   this ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "float   minX    =    Math . min ( this . x ,    x )  ;", "float   maxX    =    Math . max (  (  ( this . x )     +     ( width )  )  ,    x )  ;", "this . x    =    minX ;", "this . width    =    maxX    -    minX ;", "float   minY    =    Math . min ( this . y ,    y )  ;", "float   maxY    =    Math . max (  (  ( this . y )     +     ( height )  )  ,    y )  ;", "this . y    =    minY ;", "this . height    =    maxY    -    minY ;", "return   this ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( x )     <     (  ( r . x )     +     ( r . width )  )  )     &  &     (  (  ( x )     +     ( width )  )     >     ( r . x )  )  )     &  &     (  ( y )     <     (  ( r . y )     +     ( r . height )  )  )  )     &  &     (  (  ( y )     +     ( height )  )     >     ( r . y )  )  ;", "}", "METHOD_END"], "methodName": ["overlaps"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return    2     *     (  ( this . width )     +     ( this . height )  )  ;", "}", "METHOD_END"], "methodName": ["perimeter"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    rect . x ;", "this . y    =    rect . y ;", "this . width    =    rect . width ;", "this . height    =    rect . height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . width    =    width ;", "this . height    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "setPosition (  (  ( position . x )     -     (  ( width )     /     2  )  )  ,     (  ( position . y )     -     (  ( height )     /     2  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCenter"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "setPosition (  ( x    -     (  ( width )     /     2  )  )  ,     ( y    -     (  ( height )     /     2  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCenter"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . height    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHeight"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    position . x ;", "this . y    =    position . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . width    =    sizeXY ;", "this . height    =    sizeXY ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "this . height    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . width    =    width ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "this . y    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  \"  [  \"     +     ( x )  )     +     \"  ,  \"  )     +     ( y )  )     +     \"  ,  \"  )     +     ( width )  )     +     \"  ,  \"  )     +     ( height )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.math.Rectangle"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   Rectangle (  5  .  0 F ,     (  -  4  .  1 F )  ,     0  .  0  3 F ,     (  -  0  .  0  2 F )  )  ,    new   Rectangle (  )  . fromString (  \"  [  5  .  0  ,  -  4  .  1  ,  0  .  0  3  ,  -  0  .  0  2  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFromString"], "fileName": "com.badlogic.gdx.math.RectangleTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  [  5  .  0  ,  -  4  .  1  ,  0  .  0  3  ,  -  0  .  0  2  ]  \"  ,    new   Rectangle (  5  .  0 F ,     (  -  4  .  1 F )  ,     0  .  0  3 F ,     (  -  0  .  0  2 F )  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testToString"], "fileName": "com.badlogic.gdx.math.RectangleTest"}, {"methodBody": ["METHOD_START", "{", "Circle   c 1     =    new   Circle (  0  ,     0  ,     1  )  ;", "Circle   c 2     =    new   Circle (  0  ,     0  ,     1  )  ;", "Circle   c 3     =    new   Circle (  2  ,     0  ,     1  )  ;", "Circle   c 4     =    new   Circle (  0  ,     0  ,     2  )  ;", "assertTrue ( c 1  . overls ( c 1  )  )  ;", "assertTrue ( c 1  . overls ( c 2  )  )  ;", "assertFalse ( c 1  . overls ( c 3  )  )  ;", "assertTrue ( c 1  . overls ( c 4  )  )  ;", "assertTrue ( c 4  . overls ( c 1  )  )  ;", "assertTrue ( c 1  . contains (  0  ,     1  )  )  ;", "assertFalse ( c 1  . contains (  0  ,     2  )  )  ;", "assertTrue ( c 1  . contains ( c 1  )  )  ;", "assertFalse ( c 1  . contains ( c 4  )  )  ;", "assertTrue ( c 4  . contains ( c 1  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircle"], "fileName": "com.badlogic.gdx.math.Shape2DTest"}, {"methodBody": ["METHOD_START", "{", "Rectangle   r 1     =    new   Rectangle (  0  ,     0  ,     1  ,     1  )  ;", "Rectangle   r 2     =    new   Rectangle (  1  ,     0  ,     2  ,     1  )  ;", "assertTrue ( r 1  . overls ( r 1  )  )  ;", "assertFalse ( r 1  . overls ( r 2  )  )  ;", "assertTrue ( r 1  . contains (  0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testRectangle"], "fileName": "com.badlogic.gdx.math.Shape2DTest"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    x ;", "this . y    +  =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "float   angle    =     (  ( float )     ( Math . atan 2  ( y ,    x )  )  )     *     ( MathUtils . radiansToDegrees )  ;", "if    ( angle    <     0  )", "angle    +  =     3  6  0  ;", "return   angle ;", "}", "METHOD_END"], "methodName": ["angle"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . atan 2  ( crs ( reference )  ,    dot ( reference )  )  )  )     *     ( MathUtils . radiansToDegrees )  ;", "}", "METHOD_END"], "methodName": ["angle"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . atan 2  ( y ,    x )  )  )  ;", "}", "METHOD_END"], "methodName": ["angleRad"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . atan 2  ( crs ( reference )  ,    dot ( reference )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["angleRad"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . x )     *     ( v . y )  )     -     (  ( this . y )     *     ( v . x )  )  ;", "}", "METHOD_END"], "methodName": ["crs"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . x )     *    y )     -     (  ( this . y )     *    x )  ;", "}", "METHOD_END"], "methodName": ["crs"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( x )     *    ox )     +     (  ( y )     *    oy )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    ( x 1     *    x 2  )     +     ( y 1     *    y 2  )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "final   float   x _ d    =    x    -     ( this . x )  ;", "final   float   y _ d    =    y    -     ( this . y )  ;", "return    (  ( float )     ( Msqrt (  (  ( x _ d    *    x _ d )     +     ( y _ d    *    y _ d )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "final   float   x _ d    =    x 2     -    x 1  ;", "final   float   y _ d    =    y 2     -    y 1  ;", "return    (  ( float )     ( Msqrt (  (  ( x _ d    *    x _ d )     +     ( y _ d    *    y _ d )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "final   float   x _ d    =    x    -     ( this . x )  ;", "final   float   y _ d    =    y    -     ( this . y )  ;", "return    ( x _ d    *    x _ d )     +     ( y _ d    *    y _ d )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "final   float   x _ d    =    x 2     -    x 1  ;", "final   float   y _ d    =    y 2     -    y 1  ;", "return    ( x _ d    *    x _ d )     +     ( y _ d    *    y _ d )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return   epsilonEquals ( other ,    MathUtils . FLOAT _ ROUNDING _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["epsilonEquals"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return   epsilonEquals ( x ,    y ,    MathUtils . FLOAT _ ROUNDING _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["epsilonEquals"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Math . abs (  ( x    -     ( this . x )  )  )  )     >    epsilon )", "return   false ;", "if    (  ( Math . abs (  ( y    -     ( this . y )  )  )  )     >    epsilon )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["epsilonEquals"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "int   s    =    v . indexOf (  '  ,  '  ,     1  )  ;", "if    (  (  ( s    !  =     (  -  1  )  )     &  &     (  ( v . charAt (  0  )  )     =  =     '  (  '  )  )     &  &     (  ( v . charAt (  (  ( v . length (  )  )     -     1  )  )  )     =  =     '  )  '  )  )     {", "try    {", "float   x    =    Float . parseFloat ( v . substring (  1  ,    s )  )  ;", "float   y    =    Float . parseFloat ( v . substring (  ( s    +     1  )  ,     (  ( v . length (  )  )     -     1  )  )  )  ;", "return   this . set ( x ,    y )  ;", "}    catch    ( NumberFormatException   ex )     {", "}", "}", "throw   new   GdxRuntimeException (  (  \" Malformed    :     \"     +    v )  )  ;", "}", "METHOD_END"], "methodName": ["fromString"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . sqrt (  (  ( x    *    x )     +     ( y    *    y )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["len"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return    ( x    *    x )     +     ( y    *    y )  ;", "}", "METHOD_END"], "methodName": ["len2"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  (  ( this . x )     *     ( mat . val [  0  ]  )  )     +     (  ( this . y )     *     ( mat . val [  3  ]  )  )  )     +     ( mat . val [  6  ]  )  ;", "float   y    =     (  (  ( this . x )     *     ( mat . val [  1  ]  )  )     +     (  ( this . y )     *     ( mat . val [  4  ]  )  )  )     +     ( mat . val [  7  ]  )  ;", "this . x    =    x ;", "this . y    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return   rotateRad (  ( degrees    *     ( MathUtils . degreesToRadians )  )  )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "float   x    =    this . x ;", "if    ( dir    >  =     0  )     {", "this . x    =     -  ( y )  ;", "y    =    x ;", "} else    {", "this . x    =    y ;", "y    =     - x ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["rotate90"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return   this . sub ( reference )  . rotate ( degrees )  . add ( reference )  ;", "}", "METHOD_END"], "methodName": ["rotateAround"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return   this . sub ( reference )  . rotateRad ( radians )  . add ( reference )  ;", "}", "METHOD_END"], "methodName": ["rotateAroundRad"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "float   cos    =     (  ( float )     ( Math . cos ( radians )  )  )  ;", "float   sin    =     (  ( float )     ( Math . sin ( radians )  )  )  ;", "float   newX    =     (  ( this . x )     *    cos )     -     (  ( this . y )     *    sin )  ;", "float   newY    =     (  ( this . x )     *    sin )     +     (  ( this . y )     *    cos )  ;", "this . x    =    newX ;", "this . y    =    newY ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "this . x    *  =    x ;", "this . y    *  =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "return   setAngleRad (  ( degrees    *     ( MathUtils . degreesToRadians )  )  )  ;", "}", "METHOD_END"], "methodName": ["setAngle"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "this . set ( len (  )  ,     0  .  0 F )  ;", "this . rotateRad ( radians )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAngleRad"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "this . x    -  =    x ;", "this . y    -  =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.math.Vector2"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   Vector 2  (  (  -  5  .  0 F )  ,     4  2  .  0  0  0  5  5 F )  ,    new   Vector 2  (  )  . fromString (  \"  (  -  5  ,  4  2  .  0  0  0  5  5  )  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFromString"], "fileName": "com.badlogic.gdx.math.Vector2Test"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  (  -  5  .  0  ,  4  2  .  0  0  0  5  5  )  \"  ,    new   Vector 2  (  (  -  5  .  0 F )  ,     4  2  .  0  0  0  5  5 F )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testToString"], "fileName": "com.badlogic.gdx.math.Vector2Test"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  (  ( this . x )     +    values )  ,     (  ( this . y )     +    values )  ,     (  ( this . z )     +    values )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  (  ( this . x )     +    x )  ,     (  ( this . y )     +    y )  ,     (  ( this . z )     +    z )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  (  (  ( y )     *     ( vector . z )  )     -     (  ( z )     *     ( vector . y )  )  )  ,     (  (  ( z )     *     ( vector . x )  )     -     (  ( x )     *     ( vector . z )  )  )  ,     (  (  ( x )     *     ( vector . y )  )     -     (  ( y )     *     ( vector . x )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["crs"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  (  (  ( this . y )     *    z )     -     (  ( this . z )     *    y )  )  ,     (  (  ( this . z )     *    x )     -     (  ( this . x )     *    z )  )  ,     (  (  ( this . x )     *    y )     -     (  ( this . y )     *    x )  )  )  ;", "}", "METHOD_END"], "methodName": ["crs"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( this . x )     *    x )     +     (  ( this . y )     *    y )  )     +     (  ( this . z )     *    z )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return    (  ( x 1     *    x 2  )     +     ( y 1     *    y 2  )  )     +     ( z 1     *    z 2  )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float   a    =    x    -     ( this . x )  ;", "final   float   b    =    y    -     ( this . y )  ;", "final   float   c    =    z    -     ( this . z )  ;", "return    (  ( float )     ( Msqrt (  (  (  ( a    *    a )     +     ( b    *    b )  )     +     ( c    *    c )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float   a    =    x 2     -    x 1  ;", "final   float   b    =    y 2     -    y 1  ;", "final   float   c    =    z 2     -    z 1  ;", "return    (  ( float )     ( Msqrt (  (  (  ( a    *    a )     +     ( b    *    b )  )     +     ( c    *    c )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dst"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float   a    =    x    -     ( this . x )  ;", "final   float   b    =    y    -     ( this . y )  ;", "final   float   c    =    z    -     ( this . z )  ;", "return    (  ( a    *    a )     +     ( b    *    b )  )     +     ( c    *    c )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float   a    =    x 2     -    x 1  ;", "final   float   b    =    y 2     -    y 1  ;", "final   float   c    =    z 2     -    z 1  ;", "return    (  ( a    *    a )     +     ( b    *    b )  )     +     ( c    *    c )  ;", "}", "METHOD_END"], "methodName": ["dst2"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   epsilonEquals ( other ,    MathUtils . FLOAT _ ROUNDING _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["epsilonEquals"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   epsilonEquals ( x ,    y ,    z ,    MathUtils . FLOAT _ ROUNDING _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["epsilonEquals"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Math . abs (  ( x    -     ( this . x )  )  )  )     >    epsilon )", "return   false ;", "if    (  ( Math . abs (  ( y    -     ( this . y )  )  )  )     >    epsilon )", "return   false ;", "if    (  ( Math . abs (  ( z    -     ( this . z )  )  )  )     >    epsilon )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["epsilonEquals"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "int   s 0     =    v . indexOf (  '  ,  '  ,     1  )  ;", "int   s 1     =    v . indexOf (  '  ,  '  ,     ( s 0     +     1  )  )  ;", "if    (  (  (  ( s 0     !  =     (  -  1  )  )     &  &     ( s 1     !  =     (  -  1  )  )  )     &  &     (  ( v . charAt (  0  )  )     =  =     '  (  '  )  )     &  &     (  ( v . charAt (  (  ( v . length (  )  )     -     1  )  )  )     =  =     '  )  '  )  )     {", "try    {", "float   x    =    Float . parseFloat ( v . substring (  1  ,    s 0  )  )  ;", "float   y    =    Float . parseFloat ( v . substring (  ( s 0     +     1  )  ,    s 1  )  )  ;", "float   z    =    Float . parseFloat ( v . substring (  ( s 1     +     1  )  ,     (  ( v . length (  )  )     -     1  )  )  )  ;", "return   this . set ( x ,    y ,    z )  ;", "}    catch    ( NumberFormatException   ex )     {", "}", "}", "throw   new   GdxRuntimeException (  (  \" Malformed    :     \"     +    v )  )  ;", "}", "METHOD_END"], "methodName": ["fromString"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( x )     =  =     ( vector . x )  )     &  &     (  ( y )     =  =     ( vector . y )  )  )     &  &     (  ( z )     =  =     ( vector . z )  )  ;", "}", "METHOD_END"], "methodName": ["idt"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . sqrt (  (  (  ( x    *    x )     +     ( y    *    y )  )     +     ( z    *    z )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["len"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return    (  ( x    *    x )     +     ( y    *    y )  )     +     ( z    *    z )  ;", "}", "METHOD_END"], "methodName": ["len2"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "return   set (  (  (  (  ( x )     *     ( l _ mat [ Matrix 3  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 3  . M 0  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 3  . M 0  2  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 3  . M 1  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 3  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 3  . M 1  2  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 3  . M 2  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 3  . M 2  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 3  . M 2  2  ]  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "return   this . set (  (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 0  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 0  3  ]  )  )  ,     (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 1  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 1  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 1  3  ]  )  )  ,     (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 2  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 2  3  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   quat . transform ( this )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   set (  (  (  (  (  ( x )     *     ( matrix [  0  ]  )  )     +     (  ( y )     *     ( matrix [  3  ]  )  )  )     +     (  ( z )     *     ( matrix [  6  ]  )  )  )     +     ( matrix [  9  ]  )  )  ,     (  (  (  (  ( x )     *     ( matrix [  1  ]  )  )     +     (  ( y )     *     ( matrix [  4  ]  )  )  )     +     (  ( z )     *     ( matrix [  7  ]  )  )  )     +     ( matrix [  1  0  ]  )  )  ,     (  (  (  (  ( x )     *     ( matrix [  2  ]  )  )     +     (  ( y )     *     ( matrix [  5  ]  )  )  )     +     (  ( z )     *     ( matrix [  8  ]  )  )  )     +     ( matrix [  1  1  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul4x3"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "final   float   l _ w    =     1  .  0 F    /     (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 3  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 3  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 3  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 3  3  ]  )  )  ;", "return   this . set (  (  (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 0  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 0  3  ]  )  )     *    l _ w )  ,     (  (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 1  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 1  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 1  3  ]  )  )     *    l _ w )  ,     (  (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 2  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 2  3  ]  )  )     *    l _ w )  )  ;", "}", "METHOD_END"], "methodName": ["prj"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "return   this . set (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 0  2  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 1  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 1  2  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 2  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  2  ]  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["rot"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "Vector 3  . tmpMat . setToRotation ( axis ,    degrees )  ;", "return   this . mul ( Vector 3  . tmpMat )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . mul ( Vector 3  . tmpMat . setToRotation ( axisX ,    axisY ,    axisZ ,    degrees )  )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "Vector 3  . tmpMat . setToRotationRad ( axis ,    radians )  ;", "return   this . mul ( Vector 3  . tmpMat )  ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . mul ( Vector 3  . tmpMat . setToRotationRad ( axisX ,    axisY ,    axisZ ,    radians )  )  ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  (  ( this . x )     *    vx )  ,     (  ( this . y )     *    vy )  ,     (  ( this . z )     *    vz )  )  ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( vector . x ,    vector . y ,    z )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "this . z    =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( values [  0  ]  ,    values [  1  ]  ,    values [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "float   cosPolar    =    MathUtils . cos ( polarAngle )  ;", "float   sinPolar    =    MathUtils . sin ( polarAngle )  ;", "float   cosAzim    =    MathUtils . cos ( azimuthalAngle )  ;", "float   sinAzim    =    MathUtils . sin ( azimuthalAngle )  ;", "return   this . set (  ( cosAzim    *    sinPolar )  ,     ( sinAzim    *    sinPolar )  ,    cosPolar )  ;", "}", "METHOD_END"], "methodName": ["setFromSpherical"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float   dot    =    dot ( target )  ;", "if    (  ( dot    >     0  .  9  9  9  5  )     |  |     ( dot    <     (  -  0  .  9  9  9  5  )  )  )", "return   lerp ( target ,    alpha )  ;", "final   float   theta 0     =     (  ( float )     ( Macos ( dot )  )  )  ;", "final   float   theta    =    theta 0     *    alpha ;", "final   float   st    =     (  ( float )     ( Msin ( theta )  )  )  ;", "final   float   tx    =     ( target . x )     -     (  ( x )     *    dot )  ;", "final   float   ty    =     ( target . y )     -     (  ( y )     *    dot )  ;", "final   float   tz    =     ( target . z )     -     (  ( z )     *    dot )  ;", "final   float   l 2     =     (  ( tx    *    tx )     +     ( ty    *    ty )  )     +     ( tz    *    tz )  ;", "final   float   dl    =    st    *     ( l 2     <     1  .  0 E -  4 F    ?     1  .  0 F    :     1  .  0 F    /     (  ( float )     ( Msqrt ( l 2  )  )  )  )  ;", "return   scl (  (  ( float )     ( Mcos ( theta )  )  )  )  . add (  ( tx    *    dl )  ,     ( ty    *    dl )  ,     ( tz    *    dl )  )  . nor (  )  ;", "}", "METHOD_END"], "methodName": ["slerp"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  (  ( this . x )     -    value )  ,     (  ( this . y )     -    value )  ,     (  ( this . z )     -    value )  )  ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "return   this . set (  (  ( this . x )     -    x )  ,     (  ( this . y )     -    y )  ,     (  ( this . z )     -    z )  )  ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "return   set (  (  (  (  ( x )     *     ( l _ mat [ Matrix 3  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 3  . M 1  0  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 3  . M 2  0  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 3  . M 0  1  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 3  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 3  . M 2  1  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 3  . M 0  2  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 3  . M 1  2  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 3  . M 2  2  ]  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["traMul"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "return   this . set (  (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  0  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 3  0  ]  )  )  ,     (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  1  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  1  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 3  1  ]  )  )  ,     (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  2  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  2  ]  )  )  )     +     ( l _ mat [ Matrix 4  . M 3  2  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["traMul"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "return   this . set (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  0  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  1  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  1  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  2  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  2  ]  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["unrotate"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "final   float [  ]    l _ mat    =    matrix . val ;", "x    -  =    l _ mat [ Matrix 4  . M 0  3  ]  ;", "y    -  =    l _ mat [ Matrix 4  . M 0  3  ]  ;", "z    -  =    l _ mat [ Matrix 4  . M 0  3  ]  ;", "return   this . set (  (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  0  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  1  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  1  ]  )  )  )  ,     (  (  (  ( x )     *     ( l _ mat [ Matrix 4  . M 0  2  ]  )  )     +     (  ( y )     *     ( l _ mat [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( z )     *     ( l _ mat [ Matrix 4  . M 2  2  ]  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["untransform"], "fileName": "com.badlogic.gdx.math.Vector3"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   Vector 3  (  (  -  5  .  0 F )  ,     4  2  .  0  0  0  5  5 F ,     4  4  4  4  4  .  3  2 F )  ,    new   Vector 3  (  )  . fromString (  \"  (  -  5  ,  4  2  .  0  0  0  5  5  ,  4  4  4  4  4  .  3  2  )  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFromString"], "fileName": "com.badlogic.gdx.math.Vector3Test"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  (  -  5  .  0  ,  4  2  .  0  0  0  5  5  ,  4  4  4  4  4  .  3  2  )  \"  ,    new   Vector 3  (  (  -  5  .  0 F )  ,     4  2  .  0  0  0  5  5 F ,     4  4  4  4  4  .  3  2 F )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testToString"], "fileName": "com.badlogic.gdx.math.Vector3Test"}, {"methodBody": ["METHOD_START", "{", "if    (  ( added _ values )     <     ( values . length )  )", "( added _ values )  +  +  ;", "values [  (  ( last _ value )  +  +  )  ]     =    value ;", "if    (  ( last _ value )     >     (  ( values . length )     -     1  )  )", "last _ value    =     0  ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "added _ values    =     0  ;", "last _ value    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )", "values [ i ]     =     0  ;", "dirty    =    true ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "return   values [  (  (  ( last _ value )     -     1  )     =  =     (  -  1  )     ?     ( values . length )     -     1     :     ( last _ value )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["getLatest"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "if    ( hasEnoughData (  )  )     {", "if    (  ( dirty )     =  =    true )     {", "float   m    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )", "m    +  =    values [ i ]  ;", "this . m    =    m    /     ( values . length )  ;", "dirty    =    false ;", "}", "return   this . m ;", "} else", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMean"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "return    ( added _ values )     <     ( values . length )     ?    values [  0  ]     :    values [ last _ value ]  ;", "}", "METHOD_END"], "methodName": ["getOldest"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "return   values . length ;", "}", "METHOD_END"], "methodName": ["getWindowSize"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "float [  ]    windowValues    =    new   float [ added _ values ]  ;", "if    ( hasEnoughData (  )  )     {", "for    ( int   i    =     0  ;    i    <     ( windowValues . length )  ;    i +  +  )     {", "windowValues [ i ]     =    values [  (  ( i    +     ( last _ value )  )     %     ( values . length )  )  ]  ;", "}", "} else    {", "System . arraycopy ( values ,     0  ,    windowValues ,     0  ,    added _ values )  ;", "}", "return   windowValues ;", "}", "METHOD_END"], "methodName": ["getWindowValues"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "return    ( added _ values )     >  =     ( values . length )  ;", "}", "METHOD_END"], "methodName": ["hasEnoughData"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( hasEnoughData (  )  )  )", "return    0  ;", "float   mean    =    get (  )  ;", "float   sum    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )     {", "sum    +  =     (  ( values [ i ]  )     -    mean )     *     (  ( values [ i ]  )     -    mean )  ;", "}", "return    (  ( float )     ( Math . sqrt (  ( sum    /     ( values . length )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["standardDeviation"], "fileName": "com.badlogic.gdx.math.WindowedMean"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( min . set (  0  ,     0  ,     0  )  ,    max . set (  0  ,     0  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["clr"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  ( min . x )     <  =     ( v . x )  )     &  &     (  ( max . x )     >  =     ( v . x )  )  )     &  &     (  ( min . y )     <  =     ( v . y )  )  )     &  &     (  ( max . y )     >  =     ( v . y )  )  )     &  &     (  ( min . z )     <  =     ( v . z )  )  )     &  &     (  ( max . z )     >  =     ( v . z )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( isValid (  )  )  )     |  |     (  (  (  (  (  (  ( min . x )     <  =     ( b . min . x )  )     &  &     (  ( min . y )     <  =     ( b . min . y )  )  )     &  &     (  ( min . z )     <  =     ( b . min . z )  )  )     &  &     (  ( max . x )     >  =     ( b . max . x )  )  )     &  &     (  ( max . y )     >  =     ( b . max . y )  )  )     &  &     (  ( max . z )     >  =     ( b . max . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( min . set ( BoundingBox . min ( min . x ,    point . x )  ,    BoundingBox . min ( min . y ,    point . y )  ,    BoundingBox . min ( min . z ,    point . z )  )  ,    max . set ( Math . max ( max . x ,    point . x )  ,    Math . max ( max . y ,    point . y )  ,    Math . max ( max . z ,    point . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["ext"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( min . set ( BoundingBox . min ( min . x ,     (  ( center . x )     -    radius )  )  ,    BoundingBox . min ( min . y ,     (  ( center . y )     -    radius )  )  ,    BoundingBox . min ( min . z ,     (  ( center . z )     -    radius )  )  )  ,    max . set ( BoundingBox . max ( max . x ,     (  ( center . x )     +    radius )  )  ,    BoundingBox . max ( max . y ,     (  ( center . y )     +    radius )  )  ,    BoundingBox . max ( max . z ,     (  ( center . z )     +    radius )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ext"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( min . set ( BoundingBox . min ( min . x ,    a _ bounds . min . x )  ,    BoundingBox . min ( min . y ,    a _ bounds . min . y )  ,    BoundingBox . min ( min . z ,    a _ bounds . min . z )  )  ,    max . set ( BoundingBox . max ( max . x ,    a _ bounds . max . x )  ,    BoundingBox . max ( max . y ,    a _ bounds . max . y )  ,    BoundingBox . max ( max . z ,    a _ bounds . max . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["ext"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "ext ( BoundingBox . tmpVector . set ( bounds . min . x ,    bounds . min . y ,    bounds . min . z )  . mul ( transform )  )  ;", "ext ( BoundingBox . tmpVector . set ( bounds . min . x ,    bounds . min . y ,    bounds . max . z )  . mul ( transform )  )  ;", "ext ( BoundingBox . tmpVector . set ( bounds . min . x ,    bounds . max . y ,    bounds . min . z )  . mul ( transform )  )  ;", "ext ( BoundingBox . tmpVector . set ( bounds . min . x ,    bounds . max . y ,    bounds . max . z )  . mul ( transform )  )  ;", "ext ( BoundingBox . tmpVector . set ( bounds . max . x ,    bounds . min . y ,    bounds . min . z )  . mul ( transform )  )  ;", "ext ( BoundingBox . tmpVector . set ( bounds . max . x ,    bounds . min . y ,    bounds . max . z )  . mul ( transform )  )  ;", "ext ( BoundingBox . tmpVector . set ( bounds . max . x ,    bounds . max . y ,    bounds . min . z )  . mul ( transform )  )  ;", "ext ( BoundingBox . tmpVector . set ( bounds . max . x ,    bounds . max . y ,    bounds . max . z )  . mul ( transform )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["ext"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( min . set ( BoundingBox . min ( min . x ,    x )  ,    BoundingBox . min ( min . y ,    y )  ,    BoundingBox . min ( min . z ,    z )  )  ,    max . set ( BoundingBox . max ( max . x ,    x )  ,    BoundingBox . max ( max . y ,    y )  ,    BoundingBox . max ( max . z ,    z )  )  )  ;", "}", "METHOD_END"], "methodName": ["ext"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( cnt )  ;", "}", "METHOD_END"], "methodName": ["getCenter"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   cnt . x ;", "}", "METHOD_END"], "methodName": ["getCenterX"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   cnt . y ;", "}", "METHOD_END"], "methodName": ["getCenterY"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   cnt . z ;", "}", "METHOD_END"], "methodName": ["getCenterZ"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( min . x ,    min . y ,    min . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner000"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( min . x ,    min . y ,    max . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner001"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( min . x ,    max . y ,    min . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner010"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( min . x ,    max . y ,    max . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner011"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( max . x ,    min . y ,    min . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner100"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( max . x ,    min . y ,    max . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner101"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( max . x ,    max . y ,    min . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner110"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( max . x ,    max . y ,    max . z )  ;", "}", "METHOD_END"], "methodName": ["getCorner111"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   dim . z ;", "}", "METHOD_END"], "methodName": ["getDepth"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( dim )  ;", "}", "METHOD_END"], "methodName": ["getDimensions"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   dim . y ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( max )  ;", "}", "METHOD_END"], "methodName": ["getMax"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( min )  ;", "}", "METHOD_END"], "methodName": ["getMin"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   dim . x ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "min . set ( Float . POSITIVE _ INFINITY ,    Float . POSITIVE _ INFINITY ,    Float . POSITIVE _ INFINITY )  ;", "max . set ( Float . NEGATIVE _ INFINITY ,    Float . NEGATIVE _ INFINITY ,    Float . NEGATIVE _ INFINITY )  ;", "cnt . set (  0  ,     0  ,     0  )  ;", "dim . set (  0  ,     0  ,     0  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["inf"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isValid (  )  )  )", "return   false ;", "float   lx    =    Mabs (  (  ( this . cnt . x )     -     ( b . cnt . x )  )  )  ;", "float   sumx    =     (  ( this . dim . x )     /     2  .  0 F )     +     (  ( b . dim . x )     /     2  .  0 F )  ;", "float   ly    =    Mabs (  (  ( this . cnt . y )     -     ( b . cnt . y )  )  )  ;", "float   sumy    =     (  ( this . dim . y )     /     2  .  0 F )     +     (  ( b . dim . y )     /     2  .  0 F )  ;", "float   lz    =    Mabs (  (  ( this . cnt . z )     -     ( b . cnt . z )  )  )  ;", "float   sumz    =     (  ( this . dim . z )     /     2  .  0 F )     +     (  ( b . dim . z )     /     2  .  0 F )  ;", "return    (  ( lx    <  =    sumx )     &  &     ( ly    <  =    sumy )  )     &  &     ( lz    <  =    sumz )  ;", "}", "METHOD_END"], "methodName": ["intersects"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( min . x )     <  =     ( max . x )  )     &  &     (  ( min . y )     <  =     ( max . y )  )  )     &  &     (  ( min . z )     <  =     ( max . z )  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   a    >    b    ?    a    :    b ;", "}", "METHOD_END"], "methodName": ["max"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   a    >    b    ?    b    :    a ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "final   float   x 0     =    min . x ;", "final   float   y 0     =    min . y ;", "final   float   z 0     =    min . z ;", "final   float   x 1     =    max . x ;", "final   float   y 1     =    max . y ;", "final   float   z 1     =    max . z ;", "inf (  )  ;", "ext (  . tmpVector . set ( x 0  ,    y 0  ,    z 0  )  . mul ( transform )  )  ;", "ext (  . tmpVector . set ( x 0  ,    y 0  ,    z 1  )  . mul ( transform )  )  ;", "ext (  . tmpVector . set ( x 0  ,    y 1  ,    z 0  )  . mul ( transform )  )  ;", "ext (  . tmpVector . set ( x 0  ,    y 1  ,    z 1  )  . mul ( transform )  )  ;", "ext (  . tmpVector . set ( x 1  ,    y 0  ,    z 0  )  . mul ( transform )  )  ;", "ext (  . tmpVector . set ( x 1  ,    y 0  ,    z 1  )  . mul ( transform )  )  ;", "ext (  . tmpVector . set ( x 1  ,    y 1  ,    z 0  )  . mul ( transform )  )  ;", "ext (  . tmpVector . set ( x 1  ,    y 1  ,    z 1  )  . mul ( transform )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "min . set (  (  ( minimum . x )     <     ( maximum . x )     ?    minimum . x    :    maximum . x )  ,     (  ( minimum . y )     <     ( maximum . y )     ?    minimum . y    :    maximum . y )  ,     (  ( minimum . z )     <     ( maximum . z )     ?    minimum . z    :    maximum . z )  )  ;", "max . set (  (  ( minimum . x )     >     ( maximum . x )     ?    minimum . x    :    maximum . x )  ,     (  ( minimum . y )     >     ( maximum . y )     ?    minimum . y    :    maximum . y )  ,     (  ( minimum . z )     >     ( maximum . z )     ?    minimum . z    :    maximum . z )  )  ;", "cnt . set ( min )  . add ( max )  . scl (  0  .  5 F )  ;", "dim . set ( max )  . sub ( min )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "this . inf (  )  ;", "for    ( Vector 3    l _ point    :    points )", "this . ext ( l _ point )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( bounds . min ,    bounds . max )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "this . inf (  )  ;", "for    ( Vector 3    l _ point    :    points )", "this . ext ( l _ point )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.collision.BoundingBox"}, {"methodBody": ["METHOD_START", "{", "BoundingBox   b 1     =    new   BoundingBox ( Vector 3  . Zero ,    new   Vector 3  (  1  ,     1  ,     1  )  )  ;", "BoundingBox   b 2     =    new   BoundingBox ( new   Vector 3  (  1  ,     1  ,     1  )  ,    new   Vector 3  (  2  ,     2  ,     2  )  )  ;", "assertTrue ( b 1 ntains ( Vector 3  . Zero )  )  ;", "assertTrue ( b 1 ntains ( b 1  )  )  ;", "assertFalse ( b 1 ntains ( b 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testBoundingBox"], "fileName": "com.badlogic.gdx.math.collision.CollisionTest"}, {"methodBody": ["METHOD_START", "{", "return   new   Ray ( this . origin ,    this . direction )  ;", "}", "METHOD_END"], "methodName": ["cpy"], "fileName": "com.badlogic.gdx.math.collision.Ray"}, {"methodBody": ["METHOD_START", "{", "return   out . set ( direction )  . scl ( distance )  . add ( origin )  ;", "}", "METHOD_END"], "methodName": ["getEndPoint"], "fileName": "com.badlogic.gdx.math.collision.Ray"}, {"methodBody": ["METHOD_START", "{", "Ray . tmp . set ( origin )  . add ( direct ;", "Ray . tmp . mul ( matrix )  ;", "origin . mul ( matrix )  ;", "directset ( Ray . tmp . sub ( origin )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.collision.Ray"}, {"methodBody": ["METHOD_START", "{", "this . origin . set ( origin )  ;", "this . directset ( direct ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.collision.Ray"}, {"methodBody": ["METHOD_START", "{", "this . origin . set ( ray . origin )  ;", "this . directset ( ray . direct ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.collision.Ray"}, {"methodBody": ["METHOD_START", "{", "this . origin . set ( x ,    y ,    z )  ;", "this . directset ( dx ,    dy ,    dz )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.collision.Ray"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" ray    [  \"     +     ( origin )  )     +     \"  :  \"  )     +     ( direction )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.math.collision.Ray"}, {"methodBody": ["METHOD_START", "{", "return   a . dst ( b )  ;", "}", "METHOD_END"], "methodName": ["len"], "fileName": "com.badlogic.gdx.math.collision.Segment"}, {"methodBody": ["METHOD_START", "{", "return   a . dst 2  ( b )  ;", "}", "METHOD_END"], "methodName": ["len2"], "fileName": "com.badlogic.gdx.math.collision.Segment"}, {"methodBody": ["METHOD_START", "{", "return    ( center . dst 2  ( sphere . center )  )     <     (  (  ( radius )     +     ( sphere . radius )  )     *     (  ( radius )     +     ( sphere . radius )  )  )  ;", "}", "METHOD_END"], "methodName": ["overlaps"], "fileName": "com.badlogic.gdx.math.collision.Sphere"}, {"methodBody": ["METHOD_START", "{", "return    (  (  4     *     ( MathUtils . PI )  )     *     ( this . radius )  )     *     ( this . radius )  ;", "}", "METHOD_END"], "methodName": ["surfaceArea"], "fileName": "com.badlogic.gdx.math.collision.Sphere"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( Sphere . PI _  4  _  3  )     *     ( this . radius )  )     *     ( this . radius )  )     *     ( this . radius )  ;", "}", "METHOD_END"], "methodName": ["volume"], "fileName": "com.badlogic.gdx.math.collision.Sphere"}, {"methodBody": ["METHOD_START", "{", "Set < String >    keySet    =    parameters . keySet (  )  ;", "StringBuffer   convertedParameters    =    new   StringBuffer (  )  ;", "for    ( String   name    :    keySet )     {", "convertedParameters . append (  . encode ( name ,     . defaultEncoding )  )  ;", "convertedParameters . append (  . nameValueSeparator )  ;", "convertedParameters . append (  . encode ( parameters . get ( name )  ,     . defaultEncoding )  )  ;", "convertedParameters . append (  . parameterSeparator )  ;", "}", "if    (  ( convertedParameters . length (  )  )     >     0  )", "convertedParameters . deleteCharAt (  (  ( convertedParameters . length (  )  )     -     1  )  )  ;", "return   convertedParameters . toString (  )  ;", "}", "METHOD_END"], "methodName": ["convertHttpParameters"], "fileName": "com.badlogic.gdx.net.HttpParametersUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   URLEnder . ende ( ntent ,    ending )  ;", "}    catch    ( UnsupportedEndingException   e )     {", "throw   new   IllegalArgumentException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.badlogic.gdx.net.HttpParametersUtils"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "httpRequest . setHeader ( Header . Authorization ,     (  \" Basic    \"     +     ( Base 6  4 Coder . encodeString (  (  ( username    +     \"  :  \"  )     +    password )  )  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["basicAuthentication"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "N   request    =    httpRequest ;", "httpRequest    =    null ;", "return   request ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "h . setContent ( contentStream ,    contentLength )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["content"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "h . setContent ( content )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["content"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "h . setFollowRedirects ( followRedirects )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["followRedirects"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "httpRequest . setHeader ( Header . ContentType ,     \" application / x - www - form - urlencoded \"  )  ;", "String   formEncodedContent    =    HttpParametersUtils . convertHttpParameters ( content )  ;", "httpRequest . setContent ( formEncodedContent )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["formEncodedContent"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "h . setHeader ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "h . setIncludeCredentials ( includeCredentials )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["includeCredentials"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "httpRequest . setHeader ( HttpRequestHeader . ContentType ,     \" application / json \"  )  ;", "String   jsonContent    =     . json . toJson ( content )  ;", "httpRequest . setContent ( jsonContent )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["jsonContent"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "h . setMethod ( httpMethod )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( httpRequest )     !  =    null )     {", "throw   new   IllegalStateException (  \" A   new   request   has   already   been   started .    Call    . build (  )    first .  \"  )  ;", "}", "httpRequest    =    Pools . obtain ( Net . HttpRequest . class )  ;", "httpRequest . setTimeOut (  . defaultTimeout )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["newRequest"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "h . setTimeOut ( timeOut )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["timeout"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "httpRequest . setUrl (  (  (  . baseUrl )     +    url )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["url"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( httpRequest )     =  =    null )     {", "throw   new   IllegalStateException (  \" A   new   request   has   not   been   started   yet .    Call    . newRequest (  )    first .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.badlogic.gdx.net.HttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "return   statusCode ;", "}", "METHOD_END"], "methodName": ["getStatusCode"], "fileName": "com.badlogic.gdx.net.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "Net . HttpResponseListener   httpResponseListener    =    getFromListeners ( httpRequest )  ;", "if    ( httpResponseListener    !  =    null )     {", "httpResponseListener . cancelled (  )  ;", "removeFromConnectionsAndListeners ( httpRequest )  ;", "}", "}", "METHOD_END"], "methodName": ["cancelHttpRequest"], "fileName": "com.badlogic.gdx.net.NetJavaImpl"}, {"methodBody": ["METHOD_START", "{", "Net . HttpResponseListener   httpResponseListener    =    listeners . get ( httpRequest )  ;", "return   httpResponseListener ;", "}", "METHOD_END"], "methodName": ["getFromListeners"], "fileName": "com.badlogic.gdx.net.NetJavaImpl"}, {"methodBody": ["METHOD_START", "{", "connections . put ( httpRequest ,    connection )  ;", "listeners . put ( httpRequest ,    httpResponseListener )  ;", "}", "METHOD_END"], "methodName": ["putIntoConnectionsAndListeners"], "fileName": "com.badlogic.gdx.net.NetJavaImpl"}, {"methodBody": ["METHOD_START", "{", "connections . remove ( httpRequest )  ;", "listeners . remove ( httpRequest )  ;", "}", "METHOD_END"], "methodName": ["removeFromConnectionsAndListeners"], "fileName": "com.badlogic.gdx.net.NetJavaImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( httpRequest . getUrl (  )  )     =  =    null )     {", "httpResponseListener . failed ( new   GdxRuntimeException (  \" can ' t   process   a   HTTP   request   without   URL   set \"  )  )  ;", "return ;", "}", "try    {", "final   String   method    =    httpRequest . getMethod (  )  ;", "URL   url ;", "if    ( method . equalsIgnoreCase ( Net . HttpMethods . GET )  )     {", "String   queryString    =     \"  \"  ;", "String   value    =    httpRequest . getContent (  )  ;", "if    (  ( value    !  =    null )     &  &     (  !  (  \"  \"  . equals ( value )  )  )  )", "queryString    =     \"  ?  \"     +    value ;", "url    =    new   URL (  (  ( httpRequest . getUrl (  )  )     +    queryString )  )  ;", "} else    {", "url    =    new   URL ( httpRequest . getUrl (  )  )  ;", "}", "final   HttpURLConnection   connection    =     (  ( HttpURLConnection )     ( url . openConnection (  )  )  )  ;", "final   boolean   doingOutPut    =     ( method . equalsIgnoreCase ( Net . HttpMethods . POST )  )     |  |     ( method . equalsIgnoreCase ( Net . HttpMethods . PUT )  )  ;", "connection . setDoOutput ( doingOutPut )  ;", "connection . setDoInput ( true )  ;", "connection . setRequestMethod ( method )  ;", "HttpURLConnection . setFollowRedirects ( httpRequest . getFollowRedirects (  )  )  ;", "putIntoConnectionsAndListeners ( httpRequest ,    httpResponseListener ,    connection )  ;", "for    ( Map . Entry < String ,    String >    header    :    httpRequest . getHeaders (  )  . entrySet (  )  )", "connection . addRequestProperty ( header . getKey (  )  ,    header . getValue (  )  )  ;", "connection . setConnectTimeout ( httpRequest . getTimeOut (  )  )  ;", "connection . setReadTimeout ( httpRequest . getTimeOut (  )  )  ;", "asyncExecutor . submit ( new   AsyncTask < Void >  (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "try    {", "if    ( doingOutPut )     {", "String   contentAsString    =    httpRequest . getContent (  )  ;", "if    ( contentAsString    !  =    null )     {", "OutputStreamWriter   writer    =    new   OutputStreamWriter ( connection . getOutputStream (  )  )  ;", "try    {", "writer . write ( contentAsString )  ;", "}    finally    {", "StreamUtils . closeQuietly ( writer )  ;", "}", "} else    {", "InputStream   contentAsStream    =    httpRequest . getContentStream (  )  ;", "if    ( contentAsStream    !  =    null )     {", "OutputStream   os    =    connection . getOutputStream (  )  ;", "try    {", "StreamUtils . copyStream ( contentAsStream ,    os )  ;", "}    finally    {", "StreamUtils . closeQuietly ( os )  ;", "}", "}", "}", "}", "connection . connect (  )  ;", "final    . HttpClientResponse   clientResponse    =    new    . HttpClientResponse ( connection )  ;", "try    {", "Net . HttpResponseListener   listener    =    getFromListeners ( httpRequest )  ;", "if    ( listener    !  =    null )     {", "listener . handleHttpResponse ( clientResponse )  ;", "}", "removeFromConnectionsAndListeners ( httpRequest )  ;", "}    finally    {", "connection . disconnect (  )  ;", "}", "}    catch    ( final   Exception   e )     {", "connection . disconnect (  )  ;", "try    {", "httpResponseListener . failed ( e )  ;", "}    finally    {", "removeFromConnectionsAndListeners ( httpRequest )  ;", "}", "}", "return   null ;", "}", "}  )  ;", "}    catch    ( Exception   e )     {", "try    {", "httpResponseListener . failed ( e )  ;", "}    finally    {", "removeFromConnectionsAndListeners ( httpRequest )  ;", "}", "return ;", "}", "}", "METHOD_END"], "methodName": ["sendHttpRequest"], "fileName": "com.badlogic.gdx.net.NetJavaImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( hints    !  =    null )     {", "try    {", "s . setPerformancePreferences ( hints . performancePrefConnectionTime ,    hints . performancePrefLatency ,    hints . performancePrefBandwidth )  ;", "s . setTrafficClass ( hints . trafficClass )  ;", "s . setTcpNoDelay ( hints . tcpNoDelay )  ;", "s . setKeepAlive ( hints . keepAlive )  ;", "s . setSendBufferSize ( hints . sendBufferSize )  ;", "s . setReceiveBufferSize ( hints . receiveBufferSize )  ;", "s . setSoLinger ( hints . linger ,    hints . lingerDuration )  ;", "s . setSoTimeout ( hints . sTimeout )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  \" Error   setting   s   hints .  \"  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyHints"], "fileName": "com.badlogic.gdx.net.NetJavaSocketImpl"}, {"methodBody": ["METHOD_START", "{", "return   actor ;", "}", "METHOD_END"], "methodName": ["getActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "return   pool ;", "}", "METHOD_END"], "methodName": ["getPool"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "actor    =    null ;", "target    =    null ;", "pool    =    null ;", "restart (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "this . actor    =    actor ;", "if    (  ( target )     =  =    null )", "setTarget ( actor )  ;", "if    ( actor    =  =    null )     {", "if    (  ( pool )     !  =    null )     {", "pool . free ( this )  ;", "pool    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "this . pool    =    pool ;", "}", "METHOD_END"], "methodName": ["setPool"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "this . target    =    target ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getClass (  )  . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    !  =     (  -  1  )  )", "name    =    name . substring (  ( dotIndex    +     1  )  )  ;", "if    ( name . endsWith (  \"  \"  )  )", "name    =    name . substring (  0  ,     (  ( name . length (  )  )     -     6  )  )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.Action"}, {"methodBody": ["METHOD_START", "{", "Array < Action >    actions    =    this . actions ;", "if    (  ( actions . size )     >     0  )     {", "if    (  (  ( stage )     !  =    null )     &  &     ( stage . getActionsRequestRendering (  )  )  )", "Gdx . graphics . requestRendering (  )  ;", "for    ( int   i    =     0  ;    i    <     ( actions . size )  ;    i +  +  )     {", "Action   action    =    actions . get ( i )  ;", "if    (  ( action . act ( delta )  )     &  &     ( i    <     ( actions . size )  )  )     {", "Action   current    =    actions . get ( i )  ;", "int   actionIndex    =     ( current    =  =    action )     ?    i    :    actions . indexOf ( action ,    true )  ;", "if    ( actionIndex    !  =     (  -  1  )  )     {", "actions . removeIndex ( actionIndex )  ;", "action . setActor ( null )  ;", "i -  -  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "action . setActor ( this )  ;", "actions . add ( action )  ;", "if    (  (  ( stage )     !  =    null )     &  &     ( stage . getActionsRequestRendering (  )  )  )", "Gdx . graphics . requestRendering (  )  ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( listener    =  =    null )", "throw   new   IllegalArgumentException (  \" listener   cannot   be   null .  \"  )  ;", "if    (  !  ( captureListeners . contains ( listener ,    true )  )  )", "captureListeners . add ( listener )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["addCaptureListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( listener    =  =    null )", "throw   new   IllegalArgumentException (  \" listener   cannot   be   null .  \"  )  ;", "if    (  !  ( listeners . contains ( listener ,    true )  )  )     {", "listeners . add ( listener )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "clearActions (  )  ;", "clearListeners (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( actions . size )     -     1  ;    i    >  =     0  ;    i -  -  )", "actions . get ( i )  . set ( null )  ;", "actions . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearActions"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "listeners . clear (  )  ;", "captureListeners . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearListeners"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   clipBegin ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["clipBegin"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( width    <  =     0  )     |  |     ( height    <  =     0  )  )", "return   false ;", "Rectangle   tableBounds    =    Rectangle . tmp ;", "tableBounds . x    =    x ;", "tableBounds . y    =    y ;", "tableBounds . width    =    width ;", "tableBounds . height    =    height ;", "Stage   stage    =    thitage ;", "Rectangle   scissorBounds    =    Pools . obtain ( Rectangle . class )  ;", "stage . calculateScissors ( tableBounds ,    scissorBounds )  ;", "if    ( ScissorStack . pushScissorcissorBounds )  )", "return   true ;", "Pools . free ( scissorBounds )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["clipBegin"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "Pools . free ( ScissorStack . popScissors (  )  )  ;", "}", "METHOD_END"], "methodName": ["clipEnd"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "setDebug ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["debug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "drawDebugBounds ( shapes )  ;", "}", "METHOD_END"], "methodName": ["drawDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( debug )  )", "return ;", "shapet ( ShapeRenderer . ShapeType . Line )  ;", "shapetColor ( stage . getDebugColor (  )  )  ;", "shapes . rect ( x ,    y ,    originX ,    originY ,    width ,    height ,    scaleX ,    scaleY ,    rotation )  ;", "}", "METHOD_END"], "methodName": ["drawDebugBounds"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( event . getStage (  )  )     =  =    null )", "event . setStage ( getStage (  )  )  ;", "event . setTarget ( this )  ;", "Array < Group >    ancess    =    Pools . obtain ( Array . class )  ;", "Group   parent    =    this . parent ;", "while    ( parent    !  =    null )     {", "ancess . add ( parent )  ;", "parent    =    parent . parent ;", "}", "try    {", "Object [  ]    ancessArray    =    ancess . items ;", "for    ( int   i    =     ( ancess . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "Group   currentTarget    =     (  ( Group )     ( ancessArray [ i ]  )  )  ;", "currentTarget . notify ( event ,    true )  ;", "if    ( event . isStopped (  )  )", "return   event . isCancelled (  )  ;", "}", "notify ( event ,    true )  ;", "if    ( event . isStopped (  )  )", "return   event . isCancelled (  )  ;", "notify ( event ,    false )  ;", "if    (  !  ( event . getBubbles (  )  )  )", "return   event . isCancelled (  )  ;", "if    ( event . isStopped (  )  )", "return   event . isCancelled (  )  ;", "for    ( int   i    =     0  ,    n    =    ancess . size ;    i    <    n ;    i +  +  )     {", "(  ( Group )     ( ancessArray [ i ]  )  )  . notify ( event ,    false )  ;", "if    ( event . isStopped (  )  )", "return   event . isCancelled (  )  ;", "}", "return   event . isCancelled (  )  ;", "}    finally    {", "ancess . clear (  )  ;", "Pools . free ( ancess )  ;", "}", "}", "METHOD_END"], "methodName": ["fire"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   null .  \"  )  ;", "actor    =    this ;", "do    {", "if    ( ClassReflection . isInstance ( type ,    actor )  )", "return    (  ( T )     ( actor )  )  ;", "actor    =    actor . getParent (  )  ;", "}    while    ( actor    !  =    null    )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["firstAscendant"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   actions ;", "}", "METHOD_END"], "methodName": ["getActions"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   captureListeners ;", "}", "METHOD_END"], "methodName": ["getCaptureListeners"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   debug ;", "}", "METHOD_END"], "methodName": ["getDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   listeners ;", "}", "METHOD_END"], "methodName": ["getListeners"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   originX ;", "}", "METHOD_END"], "methodName": ["getOriginX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   originY ;", "}", "METHOD_END"], "methodName": ["getOriginY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return    ( x )     +     ( width )  ;", "}", "METHOD_END"], "methodName": ["getRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   rotation ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   scaleX ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   scaleY ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   stage ;", "}", "METHOD_END"], "methodName": ["getStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return    ( y )     +     ( height )  ;", "}", "METHOD_END"], "methodName": ["getTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   touchable ;", "}", "METHOD_END"], "methodName": ["getTouchable"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   userObject ;", "}", "METHOD_END"], "methodName": ["getUserObject"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "float   x    =    this . x ;", "if    (  ( alignment    &     ( Align . right )  )     !  =     0  )", "x    +  =    width ;", "else", "if    (  ( alignment    &     ( Align . left )  )     =  =     0  )", "x    +  =     ( width )     /     2  ;", "return   x ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "float   y    =    this . y ;", "if    (  ( alignment    &     ( Align . top )  )     !  =     0  )", "y    +  =    height ;", "else", "if    (  ( alignment    &     ( Align . bottom )  )     =  =     0  )", "y    +  =     ( height )     /     2  ;", "return   y ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "Group   parent    =    this . parent ;", "if    ( parent    =  =    null )", "return    -  1  ;", "return   parent . children . indexOf ( this ,    true )  ;", "}", "METHOD_END"], "methodName": ["getZIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return    ( actions . size )     >     0  ;", "}", "METHOD_END"], "methodName": ["hasActions"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return    ( parent )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasParent"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( touchable    &  &     (  ( this . touchable )     !  =     ( Touchable . enabled )  )  )", "return   null ;", "return    (  (  ( x    >  =     0  )     &  &     ( x    <     ( width )  )  )     &  &     ( y    >  =     0  )  )     &  &     ( y    <     ( height )  )     ?    this    :    null ;", "}", "METHOD_END"], "methodName": ["hit"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   null .  \"  )  ;", "while    ( true )     {", "if    ( actor    =  =    null )", "return   false ;", "if    ( actor    =  =     ( this )  )", "return   true ;", "actor    =    actor . parent ;", "}", "}", "METHOD_END"], "methodName": ["isAscendantOf"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   null .  \"  )  ;", "parent    =    this ;", "while    ( true )     {", "if    ( parent    =  =    null )", "return   false ;", "if    ( parent    =  =    actor )", "return   true ;", "parent    =    parent . parent ;", "}", "}", "METHOD_END"], "methodName": ["isDescendantOf"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return    ( touchable )     =  =     ( Touchable . enabled )  ;", "}", "METHOD_END"], "methodName": ["isTouchable"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   visible ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "localToStageCoordinates ( localCoords )  ;", "return   a . stageToLocalCoordinates ( localCoords )  ;", "}", "METHOD_END"], "methodName": ["localToActorCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "Actor   actor    =    this ;", "while    ( actor    !  =    null )     {", "actor . localToParentCoordinates ( localCoords )  ;", "actor    =    actor . parent ;", "if    ( actor    =  =    ascendant )", "break ;", "}", "return   localCoords ;", "}", "METHOD_END"], "methodName": ["localToAscendantCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "final   float   rotation    =     -  ( this . rotation )  ;", "final   float   scaleX    =    thialeX ;", "final   float   scaleY    =    thialeY ;", "final   float   x    =    this . x ;", "final   float   y    =    this . y ;", "if    ( rotation    =  =     0  )     {", "if    (  ( scaleX    =  =     1  )     &  &     ( scaleY    =  =     1  )  )     {", "localCoords . x    +  =    x ;", "localCoords . y    +  =    y ;", "} else    {", "final   float   originX    =    this . originX ;", "final   float   originY    =    this . originY ;", "localCoords . x    =     (  (  (  ( localCoords . x )     -    originX )     *    scaleX )     +    originX )     +    x ;", "localCoords . y    =     (  (  (  ( localCoords . y )     -    originY )     *    scaleY )     +    originY )     +    y ;", "}", "} else    {", "final   float   cos    =     (  ( float )     ( Math . cos (  ( rotation    *     ( MathUtils . degreesToRadians )  )  )  )  )  ;", "final   float   sin    =     (  ( float )     ( Math . sin (  ( rotation    *     ( MathUtils . degreesToRadians )  )  )  )  )  ;", "final   float   originX    =    this . originX ;", "final   float   originY    =    this . originY ;", "final   float   tox    =     (  ( localCoords . x )     -    originX )     *    scaleX ;", "final   float   toy    =     (  ( localCoords . y )     -    originY )     *    scaleY ;", "localCoords . x    =     (  (  ( tox    *    cos )     +     ( toy    *    sin )  )     +    originX )     +    x ;", "localCoords . y    =     (  (  ( tox    *     (  - sin )  )     +     ( toy    *    cos )  )     +    originY )     +    y ;", "}", "return   localCoords ;", "}", "METHOD_END"], "methodName": ["localToParentCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "Stage   stage    =    this . stage ;", "if    ( stage    =  =    null )", "return   localCoords ;", "return   stage . stageToScreenCoordinates ( localToAdantCoordinates ( null ,    localCoords )  )  ;", "}", "METHOD_END"], "methodName": ["localToScreenCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "return   localToAscendantCoordinates ( null ,    localCoords )  ;", "}", "METHOD_END"], "methodName": ["localToStageCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( x    !  =     0  )     |  |     ( y    !  =     0  )  )     {", "thix    +  =    x ;", "thiy    +  =    y ;", "potionChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["moveBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( event . getTarget (  )  )     =  =    null )", "throw   new   IllegalArgumentException (  \" The   event   target   cannot   be   null .  \"  )  ;", "DelayedRemovalArray < EventListener >    listeners    =     ( capture )     ?    captureListeners    :    this . listeners ;", "if    (  ( listeners . size )     =  =     0  )", "return   event . isCancelled (  )  ;", "event . setListener ( this )  ;", "event . setCapture ( capture )  ;", "if    (  ( event . getStage (  )  )     =  =    null )", "event . setStage ( stage )  ;", "listeners . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    listeners . size ;    i    <    n ;    i +  +  )     {", "EventListener   listener    =    listeners . get ( i )  ;", "if    ( listener . handle ( event )  )     {", "event . handle (  )  ;", "if    ( event   instanceof   InputEvent )     {", "InputEvent   inputEvent    =     (  ( InputEvent )     ( event )  )  ;", "if    (  ( inputEvent . getType (  )  )     =  =     ( InputEvent . Type . touchDown )  )     {", "event . getStage (  )  . addTouchFocus ( listener ,    this ,    inputEvent . getTarget (  )  ,    inputEvent . getPointer (  )  ,    inputEvent . getButton (  )  )  ;", "}", "}", "}", "}", "listeners . end (  )  ;", "return   event . isCancelled (  )  ;", "}", "METHOD_END"], "methodName": ["notify"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "final   float   rotation    =    this . rotation ;", "final   float   scaleX    =    thialeX ;", "final   float   scaleY    =    thialeY ;", "final   float   childX    =    x ;", "final   float   childY    =    y ;", "if    ( rotation    =  =     0  )     {", "if    (  ( scaleX    =  =     1  )     &  &     ( scaleY    =  =     1  )  )     {", "parentCoords . x    -  =    childX ;", "parentCoords . y    -  =    childY ;", "} else    {", "final   float   originX    =    this . originX ;", "final   float   originY    =    this . originY ;", "parentCoords . x    =     (  (  (  ( parentCoords . x )     -    childX )     -    originX )     /    scaleX )     +    originX ;", "parentCoords . y    =     (  (  (  ( parentCoords . y )     -    childY )     -    originY )     /    scaleY )     +    originY ;", "}", "} else    {", "final   float   cos    =     (  ( float )     ( Math . cos (  ( rotation    *     ( MathUtils . degreesToRadians )  )  )  )  )  ;", "final   float   sin    =     (  ( float )     ( Math . sin (  ( rotation    *     ( MathUtils . degreesToRadians )  )  )  )  )  ;", "final   float   originX    =    this . originX ;", "final   float   originY    =    this . originY ;", "final   float   tox    =     (  ( parentCoords . x )     -    childX )     -    originX ;", "final   float   toy    =     (  ( parentCoords . y )     -    childY )     -    originY ;", "parentCoords . x    =     (  (  ( tox    *    cos )     +     ( toy    *    sin )  )     /    scaleX )     +    originX ;", "parentCoords . y    =     (  (  ( tox    *     (  - sin )  )     +     ( toy    *    cos )  )     /    scaleY )     +    originY ;", "}", "return   parentCoords ;", "}", "METHOD_END"], "methodName": ["parentToLocalCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     !  =    null )", "return   parent . remove ( this ,    true )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( actions . removeValue ( action ,    true )  )", "action . set ( null )  ;", "}", "METHOD_END"], "methodName": ["removeAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( listener    =  =    null )", "throw   new   IllegalArgumentException (  \" listener   cannot   be   null .  \"  )  ;", "return   captureListeners . removeValue ( listener ,    true )  ;", "}", "METHOD_END"], "methodName": ["removeCaptureListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( listener    =  =    null )", "throw   new   IllegalArgumentException (  \" listener   cannot   be   null .  \"  )  ;", "return   listeners . removeValue ( listener ,    true )  ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( amountInDegrees    !  =     0  )     {", "rotation    +  =    amountInDegrees ;", "rotationChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["rotateBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "scaleX    +  =    scale ;", "scaleY    +  =    scale ;", "}", "METHOD_END"], "methodName": ["scaleBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    +  =    scaleX ;", "this . scaleY    +  =    scaleY ;", "}", "METHOD_END"], "methodName": ["scaleBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "Stage   stage    =    this . stage ;", "if    ( stage    =  =    null )", "return   screenCoords ;", "return   stageToLocalCoordinates ( stage . screenToStageCoordinates ( screenCoords )  )  ;", "}", "METHOD_END"], "methodName": ["screenToLocalCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . x )     !  =    x )     |  |     (  ( this . y )     !  =    y )  )     {", "this . x    =    x ;", "this . y    =    y ;", "positionChanged (  )  ;", "}", "if    (  (  ( this . width )     !  =    width )     |  |     (  ( this . height )     !  =    height )  )     {", "this . width    =    width ;", "this . height    =    height ;", "sizeChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setBounds"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . color . set ( color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "color . set ( r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "debug    =    enabled ;", "if    ( enabled )", "Stage . debug    =    true ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . height )     !  =    height )     {", "this . height    =    height ;", "sizeChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . originX    =    originX ;", "this . originY    =    originY ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( alignment    &     ( Align . left )  )     !  =     0  )", "originX    =     0  ;", "else", "if    (  ( alignment    &     ( Align . right )  )     !  =     0  )", "originX    =    width ;", "else", "originX    =     ( width )     /     2  ;", "if    (  ( alignment    &     ( Align . bottom )  )     !  =     0  )", "originY    =     0  ;", "else", "if    (  ( alignment    &     ( Align . top )  )     !  =     0  )", "originY    =    height ;", "else", "originY    =     ( height )     /     2  ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . originX    =    originX ;", "}", "METHOD_END"], "methodName": ["setOriginX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . originY    =    originY ;", "}", "METHOD_END"], "methodName": ["setOriginY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . parent    =    parent ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . x )     !  =    x )     |  |     (  ( this . y )     !  =    y )  )     {", "this . x    =    x ;", "this . y    =    y ;", "positionChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( alignment    &     ( Align . right )  )     !  =     0  )", "x    -  =    width ;", "else", "if    (  ( alignment    &     ( Align . left )  )     =  =     0  )", "x    -  =     ( width )     /     2  ;", "if    (  ( alignment    &     ( Align . top )  )     !  =     0  )", "y    -  =    height ;", "else", "if    (  ( alignment    &     ( Align . bottom )  )     =  =     0  )", "y    -  =     ( height )     /     2  ;", "if    (  (  ( this . x )     !  =    x )     |  |     (  ( this . y )     !  =    y )  )     {", "this . x    =    x ;", "this . y    =    y ;", "positionChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . rotation )     !  =    degrees )     {", "this . rotation    =    degrees ;", "rotationChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleXY ;", "this . scaleY    =    scaleXY ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleX ;", "this . scaleY    =    scaleY ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . scaleX    =    scaleX ;", "}", "METHOD_END"], "methodName": ["setScaleX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . scaleY    =    scaleY ;", "}", "METHOD_END"], "methodName": ["setScaleY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . width )     !  =    width )     |  |     (  ( this . height )     !  =    height )  )     {", "this . width    =    width ;", "this . height    =    height ;", "sizeChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . stage    =    stage ;", "}", "METHOD_END"], "methodName": ["setStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . touchable    =    touchable ;", "}", "METHOD_END"], "methodName": ["setTouchable"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . userObject    =    userObject ;", "}", "METHOD_END"], "methodName": ["setUserObject"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "this . visible    =    visible ;", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . width )     !  =    width )     {", "this . width    =    width ;", "sizeChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . x )     !  =    x )     {", "this . x    =    x ;", "positionChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( alignment    &     ( Align . right )  )     !  =     0  )", "x    -  =    width ;", "else", "if    (  ( alignment    &     ( Align . left )  )     =  =     0  )", "x    -  =     ( width )     /     2  ;", "if    (  ( this . x )     !  =    x )     {", "this . x    =    x ;", "positionChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . y )     !  =    y )     {", "this . y    =    y ;", "positionChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( alignment    &     ( Align . top )  )     !  =     0  )", "y    -  =    height ;", "else", "if    (  ( alignment    &     ( Align . bottom )  )     =  =     0  )", "y    -  =     ( height )     /     2  ;", "if    (  ( this . y )     !  =    y )     {", "this . y    =    y ;", "positionChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( index    <     0  )", "throw   new   IllegalArgumentException (  \" ZIndex   cannot   be    <     0  .  \"  )  ;", "Group   parent    =    this . parent ;", "if    ( parent    =  =    null )", "return ;", "Array <  >    children    =    parent . children ;", "if    (  ( children . size )     =  =     1  )", "return ;", "index    =    Math . min ( index ,     (  ( children . size )     -     1  )  )  ;", "if    (  ( children . get ( index )  )     =  =     ( this )  )", "return ;", "if    (  !  ( children . removeValue ( this ,    true )  )  )", "return ;", "children . insert ( index ,    this )  ;", "}", "METHOD_END"], "methodName": ["setZIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    ( size    !  =     0  )     {", "width    +  =    size ;", "height    +  =    size ;", "sizeChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sizeBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( width    !  =     0  )     |  |     ( height    !  =     0  )  )     {", "thiwidth    +  =    width ;", "thiheight    +  =    height ;", "zeChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sizeBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     !  =    null )", "parent . stageToLocalCoordinates ( stageCoords )  ;", "parentToLocalCoordinates ( stageCoords )  ;", "return   stageCoords ;", "}", "METHOD_END"], "methodName": ["stageToLocalCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "setZIndex (  0  )  ;", "}", "METHOD_END"], "methodName": ["toBack"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "setZIndex ( Integer . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["toFront"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "String   name    =    this . name ;", "if    ( name    =  =    null )     {", "name    =    getClass (  )  . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    !  =     (  -  1  )  )", "name    =    name . substring (  ( dotIndex    +     1  )  )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.Actor"}, {"methodBody": ["METHOD_START", "{", "cancelled    =    true ;", "stopped    =    true ;", "handled    =    true ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   bubbles ;", "}", "METHOD_END"], "methodName": ["getBubbles"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   listenerActor ;", "}", "METHOD_END"], "methodName": ["getListenerActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   stage ;", "}", "METHOD_END"], "methodName": ["getStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   targetActor ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "handled    =    true ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   cancelled ;", "}", "METHOD_END"], "methodName": ["isCancelled"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   capture ;", "}", "METHOD_END"], "methodName": ["isCapture"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   handled ;", "}", "METHOD_END"], "methodName": ["isHandled"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "return   stopped ;", "}", "METHOD_END"], "methodName": ["isStopped"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "stage    =    null ;", "targetActor    =    null ;", "listrActor    =    null ;", "capture    =    false ;", "bubbles    =    true ;", "handled    =    false ;", "stopped    =    false ;", "cancelled    =    false ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "this . bubbles    =    bubbles ;", "}", "METHOD_END"], "methodName": ["setBubbles"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "this . capture    =    capture ;", "}", "METHOD_END"], "methodName": ["setCapture"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "this . listenerActor    =    listenerActor ;", "}", "METHOD_END"], "methodName": ["setListenerActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "this . stage    =    stage ;", "}", "METHOD_END"], "methodName": ["setStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "this . targetActor    =    targetActor ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "stopped    =    true ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.scenes.scene2d.Event"}, {"methodBody": ["METHOD_START", "{", "super . act ( delta )  ;", "Actor [  ]    actors    =    children . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )", "actors [ i ]  . act ( delta )  ;", "children . end (  )  ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor . parent )     !  =    null )     {", "if    (  ( actor . parent )     =  =     ( this )  )", "return ;", "actor . parent . removeActor ( actor ,    false )  ;", "}", "children . add ( actor )  ;", "actor . setParent ( this )  ;", "actor . setStage ( getStage (  )  )  ;", "childrenChanged (  )  ;", "}", "METHOD_END"], "methodName": ["addActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor . parent )     !  =    null )     {", "if    (  ( actor . parent )     =  =     ( this )  )", "return ;", "actor . parent . removeActor ( actor ,    false )  ;", "}", "int   index    =    children . indexOf ( actorAfter ,    true )  ;", "if    ( index    =  =     ( children . size )  )", "children . add ( actor )  ;", "else", "children . insert (  ( index    +     1  )  ,    actor )  ;", "actor . setParent ( this )  ;", "actor . setStage ( getStage (  )  )  ;", "childrenChanged (  )  ;", "}", "METHOD_END"], "methodName": ["addActorAfter"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor . parent )     !  =    null )     {", "if    (  ( actor . parent )     =  =     ( this )  )", "return ;", "actor . parent . removeActor ( actor ,    false )  ;", "}", "if    ( index    >  =     ( children . size )  )", "children . add ( actor )  ;", "else", "children . insert ( index ,    actor )  ;", "actor . setParent ( this )  ;", "actor . setStage ( getStage (  )  )  ;", "childrenChanged (  )  ;", "}", "METHOD_END"], "methodName": ["addActorAt"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor . parent )     !  =    null )     {", "if    (  ( actor . parent )     =  =     ( this )  )", "return ;", "actor . parent . removeActor ( actor ,    false )  ;", "}", "int   index    =    children . indexOf ( actorBefore ,    true )  ;", "children . insert ( index ,    actor )  ;", "actor . setParent ( this )  ;", "actor . setStage ( getStage (  )  )  ;", "childrenChanged (  )  ;", "}", "METHOD_END"], "methodName": ["addActorBefore"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "oldTransform . set ( batch . getTransformMatrix (  )  )  ;", "batch . setTransformMatrix ( transform )  ;", "}", "METHOD_END"], "methodName": ["applyTransform"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "oldTransform . set ( shapes . getTransformMatrix (  )  )  ;", "shapetTransformMatrix ( transform )  ;", "}", "METHOD_END"], "methodName": ["applyTransform"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "super . clear (  )  ;", "clearChildren (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "Actor [  ]    actors    =    children . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    actors [ i ]  ;", "child . setStage ( null )  ;", "child . setParent ( null )  ;", "}", "children . end (  )  ;", "children . clear (  )  ;", "childrenChanged (  )  ;", "}", "METHOD_END"], "methodName": ["clearChildren"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "Affine 2    worldTransform    =    this . worldTransform ;", "float   originX    =    this . originX ;", "float   originY    =    this . originY ;", "worldTransform . setToTrnRotScl (  (  ( x )     +    originX )  ,     (  ( y )     +    originY )  ,    rotation ,    scaleX ,    scaleY )  ;", "if    (  ( originX    !  =     0  )     |  |     ( originY    !  =     0  )  )", "worldTransform . translate (  (  - originX )  ,     (  - originY )  )  ;", "parent    =    parent ;", "while    ( parent    !  =    null )     {", "if    ( parent . transform )", "break ;", "parent    =    parent . parent ;", "}", "if    ( parent    !  =    null )", "worldTransform . preMul ( parent . worldTransform )  ;", "computedTransform . set ( worldTransform )  ;", "return   computedTransform ;", "}", "METHOD_END"], "methodName": ["computeTransform"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "setDebug ( true ,    true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["debugAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "if    ( transform )", "applyTransform ( batch ,    puteTransform (  )  )  ;", "drawChildren ( batch ,    a )  ;", "if    ( transform )", "resetTransform ( batch )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "a    *  =    this . color . a ;", "SnapshotArray < Actor >    children    =    this . children ;", "Actor [  ]    actors    =    children . begin (  )  ;", "Rectangle   cullingArea    =    this . cullingArea ;", "if    ( cullingArea    !  =    null )     {", "float   cullLeft    =    cullingArea . x ;", "float   cullRight    =    cullLeft    +     ( cullingArea . width )  ;", "float   cullBottom    =    cullingArea . y ;", "float   cullTop    =    cullBottom    +     ( cullingArea . height )  ;", "if    ( transform )     {", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    actors [ i ]  ;", "if    (  !  ( child . isVisible (  )  )  )", "continue ;", "float   cx    =    child . x ;", "float   cy    =    child . y ;", "if    (  (  (  ( cx    <  =    cullRight )     &  &     ( cy    <  =    cullTop )  )     &  &     (  ( cx    +     ( child . width )  )     >  =    cullLeft )  )     &  &     (  ( cy    +     ( child . height )  )     >  =    cullBottom )  )", "child . draw ( batch ,    a )  ;", "}", "} else    {", "float   offsetX    =    x ;", "float   offsetY    =    y ;", "x    =     0  ;", "y    =     0  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    actors [ i ]  ;", "if    (  !  ( child . isVisible (  )  )  )", "continue ;", "float   cx    =    child . x ;", "float   cy    =    child . y ;", "if    (  (  (  ( cx    <  =    cullRight )     &  &     ( cy    <  =    cullTop )  )     &  &     (  ( cx    +     ( child . width )  )     >  =    cullLeft )  )     &  &     (  ( cy    +     ( child . height )  )     >  =    cullBottom )  )     {", "child . x    =    cx    +    offsetX ;", "child . y    =    cy    +    offsetY ;", "child . draw ( batch ,    a )  ;", "child . x    =    cx ;", "child . y    =    cy ;", "}", "}", "x    =    offsetX ;", "y    =    offsetY ;", "}", "} else    {", "if    ( transform )     {", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    actors [ i ]  ;", "if    (  !  ( child . isVisible (  )  )  )", "continue ;", "child . draw ( batch ,    a )  ;", "}", "} else    {", "float   offsetX    =    x ;", "float   offsetY    =    y ;", "x    =     0  ;", "y    =     0  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    actors [ i ]  ;", "if    (  !  ( child . isVisible (  )  )  )", "continue ;", "float   cx    =    child . x ;", "float   cy    =    child . y ;", "child . x    =    cx    +    offsetX ;", "child . y    =    cy    +    offsetY ;", "child . draw ( batch ,    a )  ;", "child . x    =    cx ;", "child . y    =    cy ;", "}", "x    =    offsetX ;", "y    =    offsetY ;", "}", "}", "children . end (  )  ;", "}", "METHOD_END"], "methodName": ["drawChildren"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "drawDebugBounds ( shapes )  ;", "if    ( transform )", "applyTransform ( shapes ,    puteTransform (  )  )  ;", "drawDebugChildren ( shapes )  ;", "if    ( transform )", "resetTransform ( shapes )  ;", "}", "METHOD_END"], "methodName": ["drawDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "SnapshotArray < Actor >    children    =    this . children ;", "Actor [  ]    actors    =    children . begin (  )  ;", "if    ( transform )     {", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    actors [ i ]  ;", "if    (  !  ( child . isVisible (  )  )  )", "continue ;", "if    (  (  !  ( child . getDebug (  )  )  )     &  &     (  !  ( child   instanceof    )  )  )", "continue ;", "child . drawDebug ( shapes )  ;", "}", "shapes . flush (  )  ;", "} else    {", "float   offsetX    =    x ;", "float   offsetY    =    y ;", "x    =     0  ;", "y    =     0  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    actors [ i ]  ;", "if    (  !  ( child . isVisible (  )  )  )", "continue ;", "if    (  (  !  ( child . getDebug (  )  )  )     &  &     (  !  ( child   instanceof    )  )  )", "continue ;", "float   cx    =    child . x ;", "float   cy    =    child . y ;", "child . x    =    cx    +    offsetX ;", "child . y    =    cy    +    offsetY ;", "child . drawDebug ( shapes )  ;", "child . x    =    cx ;", "child . y    =    cy ;", "}", "x    =    offsetX ;", "y    =    offsetY ;", "}", "children . end (  )  ;", "}", "METHOD_END"], "methodName": ["drawDebugChildren"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "Array < Actor >    children    =    this . children ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )", "if    ( name . equals ( children . get ( i )  . getName (  )  )  )", "return    (  ( T )     ( children . get ( i )  )  )  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    children . get ( i )  ;", "if    ( child   instanceof    )     {", "Actor   actor    =     (  (  )     ( child )  )  . findActor ( name )  ;", "if    ( actor    !  =    null )", "return    (  ( T )     ( actor )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "return   cullingArea ;", "}", "METHOD_END"], "methodName": ["getCullingArea"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "return    ( children . size )     >     0  ;", "}", "METHOD_END"], "methodName": ["hasChildren"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "if    ( touchable    &  &     (  ( getTouchable (  )  )     =  =     ( Touchable . disabled )  )  )", "return   null ;", "Vector 2    point    =     . tmp ;", "Actor [  ]    childrenArray    =    children . items ;", "for    ( int   i    =     ( children . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "Actor   child    =    childrenArray [ i ]  ;", "if    (  !  ( child . isVisible (  )  )  )", "continue ;", "child . parentToLocalCoordinates ( point . set ( x ,    y )  )  ;", "Actor   hit    =    child . hit ( point . x ,    point . y ,    touchable )  ;", "if    ( hit    !  =    null )", "return   hit ;", "}", "return   super . hit ( x ,    y ,    touchable )  ;", "}", "METHOD_END"], "methodName": ["hit"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "return   transform ;", "}", "METHOD_END"], "methodName": ["isTransform"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "Group   parent    =    descendant . parent ;", "if    ( parent    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Child   is   not   a   descendant :     \"     +    descendant )  )  ;", "if    ( parent    !  =     ( this )  )", "localToDescendantCoordinates ( parent ,    localCoords )  ;", "descendant . parentToLocalCoordinates ( localCoords )  ;", "return   localCoords ;", "}", "METHOD_END"], "methodName": ["localToDescendantCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "return   removeActor ( actor ,    true )  ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( children . removeValue ( actor ,    true )  )  )", "return   false ;", "if    ( unfocus )     {", "Stage   stage    =    getStage (  )  ;", "if    ( stage    !  =    null )", "stage . unfocus ( actor )  ;", "}", "actor . setParent ( null )  ;", "actor . setStage ( null )  ;", "childrenChanged (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "batch . setTransformMatrix ( oldTransform )  ;", "}", "METHOD_END"], "methodName": ["resetTransform"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "shapes . setTransformMatrix ( oldTransform )  ;", "}", "METHOD_END"], "methodName": ["resetTransform"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "this . cullingArea    =    cullingArea ;", "}", "METHOD_END"], "methodName": ["setCullingArea"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "setDebug ( enabled )  ;", "if    ( recursively )     {", "for    ( Actor   child    :    children )     {", "if    ( child   instanceof    )     {", "(  (  )     ( child )  )  . setDebug ( enabled ,    recursively )  ;", "} else    {", "child . setDebug ( enabled )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "super . setStage ( stage )  ;", "Actor [  ]    childrenArray    =    children . items ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )", "childrenArray [ i ]  . setStage ( stage )  ;", "}", "METHOD_END"], "methodName": ["setStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "this . transform    =    transform ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "int   firstIndex    =    children . indexOf ( first ,    true )  ;", "int   secondIndex    =    children . indexOf ( second ,    true )  ;", "if    (  ( firstIndex    =  =     (  -  1  )  )     |  |     ( secondIndex    =  =     (  -  1  )  )  )", "return   false ;", "children . swap ( firstIndex ,    secondIndex )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["swapActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "int   maxIndex    =    children . size ;", "if    (  ( first    <     0  )     |  |     ( first    >  =    maxIndex )  )", "return   false ;", "if    (  ( second    <     0  )     |  |     ( second    >  =    maxIndex )  )", "return   false ;", "children . swap ( first ,    second )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["swapActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buffer    =    new   StringBuilder (  1  2  8  )  ;", "toString ( buffer ,     1  )  ;", "buffer . setLength (  (  ( buffer . length (  )  )     -     1  )  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "buffer . append ( super . toString (  )  )  ;", "buffer . append (  '  \\ n '  )  ;", "Actor [  ]    actors    =    children . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "for    ( int   ii    =     0  ;    ii    <    indent ;    ii +  +  )", "buffer . append (  \"  |        \"  )  ;", "Actor   actor    =    actors [ i ]  ;", "if    ( actor   instanceof    )", "(  (  )     ( actor )  )  . toString ( buffer ,     ( indent    +     1  )  )  ;", "else    {", "buffer . append ( actor )  ;", "buffer . append (  '  \\ n '  )  ;", "}", "}", "children . end (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.Group"}, {"methodBody": ["METHOD_START", "{", "return   button ;", "}", "METHOD_END"], "methodName": ["getButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   character ;", "}", "METHOD_END"], "methodName": ["getCharacter"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   keyCode ;", "}", "METHOD_END"], "methodName": ["getKeyCode"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   pointer ;", "}", "METHOD_END"], "methodName": ["getPointer"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   relatedActor ;", "}", "METHOD_END"], "methodName": ["getRelatedActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   scrollAmount ;", "}", "METHOD_END"], "methodName": ["getScrollAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   stageX ;", "}", "METHOD_END"], "methodName": ["getStageX"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   stageY ;", "}", "METHOD_END"], "methodName": ["getStageY"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return    (  ( stageX )     =  =     ( Integer . MIN _ VALUE )  )     |  |     (  ( stageY )     =  =     ( Integer . MIN _ VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["isTouchFocusCancel"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "relatedActor    =    null ;", "button    =     -  1  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . button    =    button ;", "}", "METHOD_END"], "methodName": ["setButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . character    =    character ;", "}", "METHOD_END"], "methodName": ["setCharacter"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . keyCode    =    keyCode ;", "}", "METHOD_END"], "methodName": ["setKeyCode"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . pointer    =    pointer ;", "}", "METHOD_END"], "methodName": ["setPointer"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . relatedActor    =    relatedActor ;", "}", "METHOD_END"], "methodName": ["setRelatedActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . scrollAmount    =    scrollAmount ;", "}", "METHOD_END"], "methodName": ["setScrollAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . stageX    =    stageX ;", "}", "METHOD_END"], "methodName": ["setStageX"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . stageY    =    stageY ;", "}", "METHOD_END"], "methodName": ["setStageY"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "actorCoords . set ( stageX ,    stageY )  ;", "actor . stageToLocalCoordinates ( actorCoords )  ;", "return   actorCoords ;", "}", "METHOD_END"], "methodName": ["toCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "return   type . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputEvent"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( e   instanceof   InputEvent )  )", "return   false ;", "InputEvent   event    =     (  ( InputEvent )     ( e )  )  ;", "switch    ( event . getType (  )  )     {", "case   keyDown    :", "return   keyDown ( event ,    event . getKeyCode (  )  )  ;", "case   keyUp    :", "return   keyUp ( event ,    event . getKeyCode (  )  )  ;", "case   keyTyped    :", "return   keyTyped ( event ,    event . getCharacter (  )  )  ;", "}", "event . toCoordinates ( event . getListenerActor (  )  ,     . tmpCoords )  ;", "switch    ( event . getType (  )  )     {", "case   touchDown    :", "return   touchDown ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getPointer (  )  ,    event . getButton (  )  )  ;", "case   touchUp    :", "touchUp ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getPointer (  )  ,    event . getButton (  )  )  ;", "return   true ;", "case   touchDragged    :", "touchDragged ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getPointer (  )  )  ;", "return   true ;", "case   mouseMoved    :", "return   mouseMoved ( event ,     . tmpCoords . x ,     . tmpCoords . y )  ;", "case   scrolled    :", "return   scrolled ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getScrollAmount (  )  )  ;", "case   enter    :", "enter ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getPointer (  )  ,    event . getRelatedActor (  )  )  ;", "return   false ;", "case   exit    :", "exit ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getPointer (  )  ,    event . getRelatedActor (  )  )  ;", "return   false ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputListener"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["keyDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputListener"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["keyTyped"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputListener"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["keyUp"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputListener"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["mouseMoved"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputListener"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["scrolled"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputListener"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.InputListener"}, {"methodBody": ["METHOD_START", "{", "act ( Math . min ( Gdx . graphics . getDeltaTime (  )  ,     (  1     /     3  0  .  0 F )  )  )  ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "for    ( int   pointer    =     0  ,    n    =    pointerOverActors . length ;    pointer    <    n ;    pointer +  +  )     {", "Actor   overLast    =    pointerOverActors [ pointer ]  ;", "if    (  !  ( pointerTouched [ pointer ]  )  )     {", "if    ( overLast    !  =    null )     {", "pointerOverActors [ pointer ]     =    null ;", "screenToCoordinates ( tempCoords . set ( pointerScreenX [ pointer ]  ,    pointerScreenY [ pointer ]  )  )  ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . setType ( InputEvent . Type . exit )  ;", "event . set ( this )  ;", "event . setX ( tempCoords . x )  ;", "event . setY ( tempCoords . y )  ;", "event . setRelatedActor ( overLast )  ;", "event . setPointer ( pointer )  ;", "overLast . fire ( event )  ;", "Pools . free ( event )  ;", "}", "continue ;", "}", "pointerOverActors [ pointer ]     =    fireEnterAndExit ( overLast ,    pointerScreenX [ pointer ]  ,    pointerScreenY [ pointer ]  ,    pointer )  ;", "}", "Application . ApplicationType   type    =    Gdx . app . getType (  )  ;", "if    (  (  ( type    =  =     ( Application . ApplicationType . Desktop )  )     |  |     ( type    =  =     ( Application . ApplicationType . Applet )  )  )     |  |     ( type    =  =     ( Application . ApplicationType . WebGL )  )  )", "mouseOverActor    =    fireEnterAndExit ( mouseOverActor ,    mouseScreenX ,    mouseScreenY ,     (  -  1  )  )  ;", "root . act ( delta )  ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "root . addAction ( action )  ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "root . addActor ( actor )  ;", "}", "METHOD_END"], "methodName": ["addActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   root . addCaptureListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addCaptureListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   root . addListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "Stage . TouchFocus   focus    =    Pools . obtain ( Stage . TouchFocus . class )  ;", "focus . listenerActor    =    listenerActor ;", "focus . target    =    target ;", "focus . listener    =    listener ;", "focus . pointer    =    pointer ;", "focus . button    =    button ;", "touchFocuses . add ( focus )  ;", "}", "METHOD_END"], "methodName": ["addTouchFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "viewport . calculateScissors ( batch . getTransformMatrix (  )  ,    localRect ,    scissorRect )  ;", "Matrix 4    transformMatrix ;", "if    (  (  ( debugShap    !  =    null )     &  &     ( debugShapisDrawing (  )  )  )", "transformMatrix    =    debugShapgetTransformMatrix (  )  ;", "else", "transformMatrix    =    batch . getTransformMatrix (  )  ;", "viewport . calculateScissors ( transformMatrix ,    localRect ,    scissorRect )  ;", "}", "METHOD_END"], "methodName": ["calculateScissors"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "cancelTouchFocusExcept ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["cancelTouchFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . set ( this )  ;", "event . setType ( InputEvent . Type . touchUp )  ;", "event . setX ( Integer . MIN _ VALUE )  ;", "event . setY ( Integer . MIN _ VALUE )  ;", "SnapshotArray <  . TouchFocus >    touchFocuses    =    this . touchFocuses ;", ". TouchFocus [  ]    items    =    touchFocuses . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    touchFocuses . size ;    i    <    n ;    i +  +  )     {", ". TouchFocus   focus    =    items [ i ]  ;", "if    (  ( focus . listenerActor )     !  =    actor )", "continue ;", "if    (  !  ( touchFocuses . removeValue ( focus ,    true )  )  )", "continue ;", "event . setTarget ( focus . target )  ;", "event . setListenerActor ( focus . listenerActor )  ;", "event . setPointer ( focus . pointer )  ;", "event . setButton ( focus . button )  ;", "focus . listener . handle ( event )  ;", "}", "touchFocuses . end (  )  ;", "Pools . free ( event )  ;", "}", "METHOD_END"], "methodName": ["cancelTouchFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . set ( this )  ;", "event . setType ( InputEvent . Type . touchUp )  ;", "event . setX ( Integer . MIN _ VALUE )  ;", "event . setY ( Integer . MIN _ VALUE )  ;", "SnapshotArray <  . TouchFocus >    touchFocuses    =    this . touchFocuses ;", ". TouchFocus [  ]    items    =    touchFocuses . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    touchFocuses . size ;    i    <    n ;    i +  +  )     {", ". TouchFocus   focus    =    items [ i ]  ;", "if    (  (  ( focus . listener )     =  =    exceptListener )     &  &     (  ( focus . listenerActor )     =  =    exceptActor )  )", "continue ;", "if    (  !  ( touchFocuses . removeValue ( focus ,    true )  )  )", "continue ;", "event . setTarget ( focus . target )  ;", "event . setListenerActor ( focus . listenerActor )  ;", "event . setPointer ( focus . pointer )  ;", "event . setButton ( focus . button )  ;", "focus . listener . handle ( event )  ;", "}", "touchFocuses . end (  )  ;", "Pools . free ( event )  ;", "}", "METHOD_END"], "methodName": ["cancelTouchFocusExcept"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "unfocusAll (  )  ;", "root . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    except )", "return ;", "actor . setDebug ( false )  ;", "if    ( actor   instanceof   Group )     {", "SnapshotArray < Actor >    children    =     (  ( Group )     ( actor )  )  . children ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )", "disableDebug ( children . get ( i )  ,    except )  ;", "}", "}", "METHOD_END"], "methodName": ["disableDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "clear (  )  ;", "if    ( ownsBatch )", "tch . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "Camera   camera    =    viewport . getCamera (  )  ;", "camera . update (  )  ;", "if    (  !  ( root . isVisible (  )  )  )", "return ;", "Batch   batch    =    this . batch ;", "batch . setProjectionMatrix ( camera . combined )  ;", "batch . begin (  )  ;", "root . draw ( batch ,     1  )  ;", "batch . end (  )  ;", "if    (  . debug )", "drawDebug (  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    (  ( debugShapes )     =  =    null )     {", "debugShapes    =    new   ShapeRenderer (  )  ;", "debugShapes . setAutoShapeType ( true )  ;", "}", "if    (  (  ( debugUnderMouse )     |  |     ( debugParentUnderMouse )  )     |  |     (  ( debugTableUnderMouse )     !  =     ( Table . Debug . none )  )  )     {", "screenToCoordinates ( tempCoords . set ( Gdx . input . getX (  )  ,    Gdx . input . getY (  )  )  )  ;", "Actor   actor    =    hit ( tempCoords . x ,    tempCoords . y ,    true )  ;", "if    ( actor    =  =    null )", "return ;", "if    (  ( debugParentUnderMouse )     &  &     (  ( actor . parent )     !  =    null )  )", "actor    =    actor . parent ;", "if    (  ( debugTableUnderMouse )     =  =     ( Table . Debug . none )  )", "actor . setDebug ( true )  ;", "else    {", "while    ( actor    !  =    null )     {", "if    ( actor   instanceof   Table )", "break ;", "actor    =    actor . parent ;", "}", "if    ( actor    =  =    null )", "return ;", "(  ( Table )     ( actor )  )  . debug ( debugTableUnderMouse )  ;", "}", "if    (  ( debugAll )     &  &     ( actor   instanceof   Group )  )", "(  ( Group )     ( actor )  )  . debugAll (  )  ;", "disableDebug ( root ,    actor )  ;", "} else    {", "if    ( debugAll )", "root . debugAll (  )  ;", "}", "Gdx . gl . glEnable ( GL 2  0  . GL _ BLEND )  ;", "debugShapes . setProjectionMatrix ( viewport . getCamera (  )  . combined )  ;", "debugShapes . begin (  )  ;", "root . drawDebug ( debugShapes )  ;", "debugShapes . end (  )  ;", "}", "METHOD_END"], "methodName": ["drawDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "screenToStageCoordinates ( tempCoords . set ( screenX ,    screenY )  )  ;", "Actor   over    =    hit ( tempCoords . x ,    tempCoords . y ,    true )  ;", "if    ( over    =  =    overLast )", "return   overLast ;", "if    ( overLast    !  =    null )     {", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . setStage ( this )  ;", "event . setStageX ( tempCoords . x )  ;", "event . setStageY ( tempCoords . y )  ;", "event . setPointer ( pointer )  ;", "event . setType ( InputEvent . Type . exit )  ;", "event . setRelatedActor ( over )  ;", "overLast . fire ( event )  ;", "Pools . free ( event )  ;", "}", "if    ( over    !  =    null )     {", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . setStage ( this )  ;", "event . setStageX ( tempCoords . x )  ;", "event . setStageY ( tempCoords . y )  ;", "event . setPointer ( pointer )  ;", "event . setType ( InputEvent . Type . enter )  ;", "event . setRelatedActor ( overLast )  ;", "over . fire ( event )  ;", "Pools . free ( event )  ;", "}", "return   over ;", "}", "METHOD_END"], "methodName": ["fireEnterAndExit"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   actionsRequestRendering ;", "}", "METHOD_END"], "methodName": ["getActionsRequestRendering"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   root . children ;", "}", "METHOD_END"], "methodName": ["getActors"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   batch ;", "}", "METHOD_END"], "methodName": ["getBatch"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   viewport . getCamera (  )  ;", "}", "METHOD_END"], "methodName": ["getCamera"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   debugColor ;", "}", "METHOD_END"], "methodName": ["getDebugColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   viewport . getWorldHeight (  )  ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   keyboardFocus ;", "}", "METHOD_END"], "methodName": ["getKeyboardFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   scrollFocus ;", "}", "METHOD_END"], "methodName": ["getScrollFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   viewport ;", "}", "METHOD_END"], "methodName": ["getViewport"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   viewport . getWorldWidth (  )  ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "root . parentToLocalCoordinates ( tempCoords . set ( stageX ,    stageY )  )  ;", "return   root . hit ( tempCoords . x ,    tempCoords . y ,    touchable )  ;", "}", "METHOD_END"], "methodName": ["hit"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   debugAll ;", "}", "METHOD_END"], "methodName": ["isDebugAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "int   x 0     =    viewport . getScreenX (  )  ;", "int   x 1     =    x 0     +     ( viewport . getScreenWidth (  )  )  ;", "int   y 0     =    viewport . getScreenY (  )  ;", "int   y 1     =    y 0     +     ( viewport . getScreenHeight (  )  )  ;", "screenY    =     (  ( Ggraphics . getHeight (  )  )     -     1  )     -    screenY ;", "return    (  (  ( screenX    >  =    x 0  )     &  &     ( screenX    <    x 1  )  )     &  &     ( screenY    >  =    y 0  )  )     &  &     ( screenY    <    y 1  )  ;", "}", "METHOD_END"], "methodName": ["isInsideViewport"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "Actor   target    =     (  ( keyboardFocus )     =  =    null )     ?    root    :    keyboardFocus ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . set ( this )  ;", "event . setType ( InputEvent . Type . keyDown )  ;", "event . setKeyCode ( keyCode )  ;", "target . fire ( event )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["keyDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "Actor   target    =     (  ( keyboardFocus )     =  =    null )     ?    root    :    keyboardFocus ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . set ( this )  ;", "event . setType ( InputEvent . Type . keyTyped )  ;", "event . setCharacter ( character )  ;", "target . fire ( event )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["keyTyped"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "Actor   target    =     (  ( keyboardFocus )     =  =    null )     ?    root    :    keyboardFocus ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . set ( this )  ;", "event . setType ( InputEvent . Type . keyUp )  ;", "event . setKeyCode ( keyCode )  ;", "target . fire ( event )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["keyUp"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "mouseScreenX    =    screenX ;", "mouseScreenY    =    screenY ;", "if    (  !  ( isInsideViewport ( screenX ,    screenY )  )  )", "return   false ;", "screenToCoordinates ( tempCoords . set ( screenX ,    screenY )  )  ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . set ( this )  ;", "event . setType ( InputEvent . Type . mouseMoved )  ;", "event . setX ( tempCoords . x )  ;", "event . setY ( tempCoords . y )  ;", "Actor   target    =    hit ( tempCoords . x ,    tempCoords . y ,    true )  ;", "if    ( target    =  =    null )", "target    =    root ;", "target . fire ( event )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["mouseMoved"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   root . removeCaptureListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeCaptureListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   root . removeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "SnapshotArray < Stage . TouchFocus >    touchFocuses    =    this . touchFocuses ;", "for    ( int   i    =     ( touchFocuses . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "Stage . TouchFocus   focus    =    touchFocuses . get ( i )  ;", "if    (  (  (  (  (  ( focus . listener )     =  =    listener )     &  &     (  ( focus . listenerActor )     =  =    listenerActor )  )     &  &     (  ( focus . target )     =  =    target )  )     &  &     (  ( focus . pointer )     =  =    pointer )  )     &  &     (  ( focus . button )     =  =    button )  )     {", "touchFocuses . removeIndex ( i )  ;", "Pools . free ( focus )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeTouchFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "viewport . unproject ( screenCoords )  ;", "return   screenCoords ;", "}", "METHOD_END"], "methodName": ["screenToStageCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "Actor   target    =     (  ( scrollFocus )     =  =    null )     ?    root    :    scrollFocus ;", "screenToCoordinates ( tempCoords . set ( mouseScreenX ,    mouseScreenY )  )  ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . set ( this )  ;", "event . setType ( InputEvent . Type . scrolled )  ;", "event . setScrollAmount ( amount )  ;", "event . setX ( tempCoords . x )  ;", "event . setY ( tempCoords . y )  ;", "target . fire ( event )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["scrolled"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "this . actionsRequestRendering    =    actionsRequestRendering ;", "}", "METHOD_END"], "methodName": ["setActionsRequestRendering"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . debugAll )     =  =    debugAll )", "return ;", "this . debugAll    =    debugAll ;", "if    ( debugAll )", ". debug    =    true ;", "else", "root . setDebug ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["setDebugAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "this . debugInvisible    =    debugInvisible ;", "}", "METHOD_END"], "methodName": ["setDebugInvisible"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . debugParentUnderMouse )     =  =    debugParentUnderMouse )", "return ;", "this . debugParentUnderMouse    =    debugParentUnderMouse ;", "if    ( debugParentUnderMouse )", ". debug    =    true ;", "else", "root . setDebug ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["setDebugParentUnderMouse"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "setDebugTableUnderMouse (  ( debugTableUnderMouse    ?    Table . Debug . all    :    Table . Debug . none )  )  ;", "}", "METHOD_END"], "methodName": ["setDebugTableUnderMouse"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    ( debugTableUnderMouse    =  =    null )", "debugTableUnderMouse    =    Table . Debug . none ;", "if    (  ( this . debugTableUnderMouse )     =  =    debugTableUnderMouse )", "return ;", "this . debugTableUnderMouse    =    debugTableUnderMouse ;", "if    ( debugTableUnderMouse    !  =     ( Table . Debug . none )  )", ". debug    =    true ;", "else", "root . setDebug ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["setDebugTableUnderMouse"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . debugUnderMouse )     =  =    debugUnderMouse )", "return ;", "this . debugUnderMouse    =    debugUnderMouse ;", "if    ( debugUnderMouse )", ". debug    =    true ;", "else", "root . setDebug ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["setDebugUnderMouse"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keyboardFocus )     =  =    actor )", "return   true ;", "FocusListener . FocusEvent   event    =    Pools . obtain ( FocusListener . FocusEvent . class )  ;", "event . set ( this )  ;", "event . setType ( FocusListener . FocusEvent . Type . keyboard )  ;", "Actor   oldKeyboardFocus    =    keyboardFocus ;", "if    ( oldKeyboardFocus    !  =    null )     {", "event . setFocused ( false )  ;", "event . setRelatedActor ( actor )  ;", "oldKeyboardFocus . fire ( event )  ;", "}", "boolean   success    =     !  ( event . isCancelled (  )  )  ;", "if    ( success )     {", "keyboardFocus    =    actor ;", "if    ( actor    !  =    null )     {", "event . setFocused ( true )  ;", "event . setRelatedActor ( oldKeyboardFocus )  ;", "actor . fire ( event )  ;", "success    =     !  ( event . isCancelled (  )  )  ;", "if    (  ! success )", "keyboardFocus    =    oldKeyboardFocus ;", "}", "}", "Pools . free ( event )  ;", "return   success ;", "}", "METHOD_END"], "methodName": ["setKeyboardFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "this . root    =    root ;", "}", "METHOD_END"], "methodName": ["setRoot"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    (  ( scrollFocus )     =  =    actor )", "return   true ;", "FocusListener . FocusEvent   event    =    Pools . obtain ( FocusListener . FocusEvent . class )  ;", "event . set ( this )  ;", "event . setType ( FocusListener . FocusEvent . Type . scroll )  ;", "Actor   oldScrollFocus    =    scrollFocus ;", "if    ( oldScrollFocus    !  =    null )     {", "event . setFocused ( false )  ;", "event . setRelatedActor ( actor )  ;", "oldScrollFocus . fire ( event )  ;", "}", "boolean   success    =     !  ( event . isCancelled (  )  )  ;", "if    ( success )     {", "scrollFocus    =    actor ;", "if    ( actor    !  =    null )     {", "event . setFocused ( true )  ;", "event . setRelatedActor ( oldScrollFocus )  ;", "actor . fire ( event )  ;", "success    =     !  ( event . isCancelled (  )  )  ;", "if    (  ! success )", "scrollFocus    =    oldScrollFocus ;", "}", "}", "Pools . free ( event )  ;", "return   success ;", "}", "METHOD_END"], "methodName": ["setScrollFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "this . viewport    =    viewport ;", "}", "METHOD_END"], "methodName": ["setViewport"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "viewport . project ( stageCoords )  ;", "stageCoords . y    =     ( viewport . getScreenHeight (  )  )     -     ( stageCoords . y )  ;", "return   stageCoords ;", "}", "METHOD_END"], "methodName": ["stageToScreenCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "return   viewport . toScreenCoordinates ( coords ,    transformMatrix )  ;", "}", "METHOD_END"], "methodName": ["toScreenCoordinates"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isInsideViewport ( screenX ,    screenY )  )  )", "return   false ;", "pointerTouched [ pointer ]     =    true ;", "pointerScreenX [ pointer ]     =    screenX ;", "pointerScreenY [ pointer ]     =    screenY ;", "screenToCoordinates ( tempCoords . set ( screenX ,    screenY )  )  ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . setType ( InputEvent . Type . touchDown )  ;", "event . set ( this )  ;", "event . setX ( tempCoords . x )  ;", "event . setY ( tempCoords . y )  ;", "event . setPointer ( pointer )  ;", "event . setButton ( button )  ;", "Actor   target    =    hit ( tempCoords . x ,    tempCoords . y ,    true )  ;", "if    ( target    =  =    null )     {", "if    (  ( root . getTouchable (  )  )     =  =     ( Touchable . enabled )  )", "root . fire ( event )  ;", "} else", "target . fire ( event )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "pointerScreenX [ pointer ]     =    screenX ;", "pointerScreenY [ pointer ]     =    screenY ;", "mouseScreenX    =    screenX ;", "mouseScreenY    =    screenY ;", "if    (  ( touchFocuses . size )     =  =     0  )", "return   false ;", "screenToCoordinates ( tempCoords . set ( screenX ,    screenY )  )  ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . setType ( InputEvent . Type . touchDragged )  ;", "event . set ( this )  ;", "event . setX ( tempCoords . x )  ;", "event . setY ( tempCoords . y )  ;", "event . setPointer ( pointer )  ;", "SnapshotArray <  . TouchFocus >    touchFocuses    =    this . touchFocuses ;", ". TouchFocus [  ]    focuses    =    touchFocuses . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    touchFocuses . size ;    i    <    n ;    i +  +  )     {", ". TouchFocus   focus    =    focuses [ i ]  ;", "if    (  ( focus . pointer )     !  =    pointer )", "continue ;", "if    (  !  ( touchFocuses . contains ( focus ,    true )  )  )", "continue ;", "event . setTarget ( focus . target )  ;", "event . setListenerActor ( focus . listenerActor )  ;", "if    ( focus . listener . handle ( event )  )", "event . handle (  )  ;", "}", "touchFocuses . end (  )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["touchDragged"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "pointerTouched [ pointer ]     =    false ;", "pointerScreenX [ pointer ]     =    screenX ;", "pointerScreenY [ pointer ]     =    screenY ;", "if    (  ( touchFocuses . size )     =  =     0  )", "return   false ;", "screenToCoordinates ( tempCoords . set ( screenX ,    screenY )  )  ;", "InputEvent   event    =    Pools . obtain ( InputEvent . class )  ;", "event . setType ( InputEvent . Type . touchUp )  ;", "event . set ( this )  ;", "event . setX ( tempCoords . x )  ;", "event . setY ( tempCoords . y )  ;", "event . setPointer ( pointer )  ;", "event . setButton ( button )  ;", "SnapshotArray <  . TouchFocus >    touchFocuses    =    this . touchFocuses ;", ". TouchFocus [  ]    focuses    =    touchFocuses . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    touchFocuses . size ;    i    <    n ;    i +  +  )     {", ". TouchFocus   focus    =    focuses [ i ]  ;", "if    (  (  ( focus . pointer )     !  =    pointer )     |  |     (  ( focus . button )     !  =    button )  )", "continue ;", "if    (  !  ( touchFocuses . removeValue ( focus ,    true )  )  )", "continue ;", "event . setTarget ( focus . target )  ;", "event . setListenerActor ( focus . listenerActor )  ;", "if    ( focus . listener . handle ( event )  )", "event . handle (  )  ;", "Pools . free ( focus )  ;", "}", "touchFocuses . end (  )  ;", "boolean   handled    =    event . isHandled (  )  ;", "Pools . free ( event )  ;", "return   handled ;", "}", "METHOD_END"], "methodName": ["touchUp"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "cancelTouchFocus ( actor )  ;", "if    (  (  ( scrollFocus )     !  =    null )     &  &     ( scrollFocus . isDedantOf ( actor )  )  )", "setScrollFocus ( null )  ;", "if    (  (  ( keyboardFocus )     !  =    null )     &  &     ( keyboardFocus . isDedantOf ( actor )  )  )", "setKeyboardFocus ( null )  ;", "}", "METHOD_END"], "methodName": ["unfocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "setScrollFocus ( null )  ;", "setKeyboardFocus ( null )  ;", "canlTouchFocus (  )  ;", "}", "METHOD_END"], "methodName": ["unfocusAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.Stage"}, {"methodBody": ["METHOD_START", "{", "Pool < T >    pool    =    Pools . get ( type )  ;", "T       =    pool . obtain (  )  ;", ". setPool ( pool )  ;", "return    ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AddAction   addAction    =    Actions . action ( AddAction . class )  ;", "addAction . setAction ( action )  ;", "return   addAction ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AddAction   addAction    =    Actions . action ( AddAction . class )  ;", "addAction . setTarget ( targetActor )  ;", "addAction . setAction ( action )  ;", "return   addAction ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AddListenerAction   addAction    =    Actions . action ( AddListenerAction . class )  ;", "addAction . setListener ( listener )  ;", "addAction . setCapture ( capture )  ;", "return   addAction ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AddListenerAction   addAction    =    Actions . action ( AddListenerAction . class )  ;", "addAction . setTarget ( targetActor )  ;", "addAction . setListener ( listener )  ;", "addAction . setCapture ( capture )  ;", "return   addAction ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AfterAction   afterAction    =    Actions . action ( AfterAction . class )  ;", "afterAction . setAction ( action )  ;", "return   afterAction ;", "}", "METHOD_END"], "methodName": ["after"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . alpha ( a ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["alpha"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . alpha ( a ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["alpha"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AlphaAction   action    =    Actions . action ( AlphaAction . class )  ;", "action . setAlpha ( a )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["alpha"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . color ( color ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["color"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . color ( color ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["color"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ColorAction   action    =    Actions . action ( ColorAction . class )  ;", "action . setEndColor ( color )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["color"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "DelayAction   action    =    Actions . action ( DelayAction . class )  ;", "action . setDuration ( duration )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["delay"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "DelayAction   action    =    Actions . action ( DelayAction . class )  ;", "action . setDuration ( duration )  ;", "action . setAction ( delayedAction )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["delay"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . alpha (  1  ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["fadeIn"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AlphaAction   action    =    Actions . action ( AlphaAction . class )  ;", "action . setAlpha (  1  )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["fadeIn"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . alpha (  0  ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["fadeOut"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "AlphaAction   action    =    Actions . action ( AlphaAction . class )  ;", "action . setAlpha (  0  )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["fadeOut"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RepeatAction   action    =    Actions . action ( RepeatAction . class )  ;", "action . setCount ( RepeatAction . FOREVER )  ;", "action . setAction ( repeatedAction )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["forever"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . visible ( false )  ;", "}", "METHOD_END"], "methodName": ["hide"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "LayoutAction   action    =    Actions . action ( LayoutAction . class )  ;", "action . setLayoutEnabled ( enabled )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . moveBy ( amountX ,    amountY ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["moveBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . moveBy ( amountX ,    amountY ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["moveBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "MoveByAction   action    =    Actions . action ( MoveByAction . class )  ;", "action . setAmount ( amountX ,    amountY )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["moveBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . moveTo ( x ,    y ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . moveTo ( x ,    y ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "MoveToAction   action    =    Actions . action ( MoveToAction . class )  ;", "action . setPosition ( x ,    y )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . moveToAligned ( x ,    y ,    alignment ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["moveToAligned"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . moveToAligned ( x ,    y ,    alignment ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["moveToAligned"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "MoveToAction   action    =    Actions . action ( MoveToAction . class )  ;", "action . setPosition ( x ,    y ,    alignment )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["moveToAligned"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . action ( ParallelAction . class )  ;", "}", "METHOD_END"], "methodName": ["parallel"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ParallelAction   action    =    Actions . action ( ParallelAction . class )  ;", "action . addAction ( action 1  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["parallel"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ParallelAction   action    =    Actions . action ( ParallelAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["parallel"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ParallelAction   action    =    Actions . action ( ParallelAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "action . addAction ( action 3  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["parallel"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ParallelAction   action    =    Actions . action ( ParallelAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "action . addAction ( action 3  )  ;", "action . addAction ( action 4  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["parallel"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ParallelAction   action    =    Actions . action ( ParallelAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "action . addAction ( action 3  )  ;", "action . addAction ( action 4  )  ;", "action . addAction ( action 5  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["parallel"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ParallelAction   action    =    Actions . action ( ParallelAction . class )  ;", "for    ( int   i    =     0  ,    n    =    length ;    i    <    n ;    i +  +  )", "action . addAction ( i ]  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["parallel"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RemoveAction   removeAction    =    Actions . action ( RemoveAction . class )  ;", "removeAction . setAction ( action )  ;", "return   removeAction ;", "}", "METHOD_END"], "methodName": ["removeAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RemoveAction   removeAction    =    Actions . action ( RemoveAction . class )  ;", "removeAction . setTarget ( targetActor )  ;", "removeAction . setAction ( action )  ;", "return   removeAction ;", "}", "METHOD_END"], "methodName": ["removeAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . action ( RemoveActorAction . class )  ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RemoveActorAction   action    =    Actions . action ( RemoveActorAction . class )  ;", "action . setTarget ( removeActor )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RemoveListenerAction   addAction    =    Actions . action ( RemoveListenerAction . class )  ;", "addAction . setListener ( listener )  ;", "addAction . setCapture ( capture )  ;", "return   addAction ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RemoveListenerAction   addAction    =    Actions . action ( RemoveListenerAction . class )  ;", "addAction . setTarget ( targetActor )  ;", "addAction . setListener ( listener )  ;", "addAction . setCapture ( capture )  ;", "return   addAction ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RepeatAction   action    =    Actions . action ( RepeatAction . class )  ;", "action . setCount ( count )  ;", "action . setAction ( repeatedAction )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["repeat"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . rotateBy ( rotationAmount ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["rotateBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . rotateBy ( rotationAmount ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["rotateBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RotateByAction   action    =    Actions . action ( RotateByAction . class )  ;", "action . setAmount ( rotationAmount )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["rotateBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . rotateTo ( rotation ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["rotateTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . rotateTo ( rotation ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["rotateTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RotateToAction   action    =    Actions . action ( RotateToAction . class )  ;", "action . setRotation ( rotation )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["rotateTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "RunnableAction   action    =    Actions . action ( RunnableAction . class )  ;", "action . setRunnable ( runnable )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . scaleBy ( amountX ,    amountY ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["scaleBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . scaleBy ( amountX ,    amountY ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["scaleBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ScaleByAction   action    =    Actions . action ( ScaleByAction . class )  ;", "action . setAmount ( amountX ,    amountY )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["scaleBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . scaleTo ( x ,    y ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["scaleTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . scaleTo ( x ,    y ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["scaleTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "ScaleToAction   action    =    Actions . action ( ScaleToAction . class )  ;", "action . setScale ( x ,    y )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["scaleTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . action ( SequenceAction . class )  ;", "}", "METHOD_END"], "methodName": ["sequence"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SequenceAction   action    =    Actions . action ( SequenceAction . class )  ;", "action . addAction ( action 1  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sequence"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SequenceAction   action    =    Actions . action ( SequenceAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sequence"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SequenceAction   action    =    Actions . action ( SequenceAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "action . addAction ( action 3  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sequence"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SequenceAction   action    =    Actions . action ( SequenceAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "action . addAction ( action 3  )  ;", "action . addAction ( action 4  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sequence"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SequenceAction   action    =    Actions . action ( SequenceAction . class )  ;", "action . addAction ( action 1  )  ;", "action . addAction ( action 2  )  ;", "action . addAction ( action 3  )  ;", "action . addAction ( action 4  )  ;", "action . addAction ( action 5  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sequence"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SequenceAction   action    =    Actions . action ( SequenceAction . class )  ;", "for    ( int   i    =     0  ,    n    =    length ;    i    <    n ;    i +  +  )", "action . addAction ( i ]  )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sequence"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . visible ( true )  ;", "}", "METHOD_END"], "methodName": ["show"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . sizeBy ( amountX ,    amountY ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["sizeBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . sizeBy ( amountX ,    amountY ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["sizeBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SizeByAction   action    =    Actions . action ( SizeByAction . class )  ;", "action . setAmount ( amountX ,    amountY )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sizeBy"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . sizeTo ( x ,    y ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["sizeTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "return   Actions . sizeTo ( x ,    y ,    duration ,    null )  ;", "}", "METHOD_END"], "methodName": ["sizeTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "SizeToAction   action    =    Actions . action ( SizeToAction . class )  ;", "action . setSize ( x ,    y )  ;", "action . setDuration ( duration )  ;", "action . setInterpolation ( interpolation )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["sizeTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "TimeScaleAction   action    =    Actions . action ( TimeScaleAction . class )  ;", "action . setScale ( scale )  ;", "action . setAction ( scaledAction )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["timeScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "TouchableAction   action    =    Actions . action ( TouchableAction . class )  ;", "action . setTouchable ( touchable )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["touchable"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "VisibleAction   action    =    Actions . action ( VisibleAction . class )  ;", "action . setVisible ( visible )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["visible"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.Actions"}, {"methodBody": ["METHOD_START", "{", "target . addAction ( action )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddAction"}, {"methodBody": ["METHOD_START", "{", "return   action ;", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "=    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( action )     !  =    null )", "action . restart (  )  ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddAction"}, {"methodBody": ["METHOD_START", "{", "this . action    =    action ;", "}", "METHOD_END"], "methodName": ["setAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddAction"}, {"methodBody": ["METHOD_START", "{", "if    ( capture )", "target . addCaptureListener ( listener )  ;", "else", "target . a ( listener )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction"}, {"methodBody": ["METHOD_START", "{", "return   capture ;", "}", "METHOD_END"], "methodName": ["getCapture"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction"}, {"methodBody": ["METHOD_START", "{", "return   listener ;", "}", "METHOD_END"], "methodName": ["getListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "l    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction"}, {"methodBody": ["METHOD_START", "{", "this . capture    =    capture ;", "}", "METHOD_END"], "methodName": ["setCapture"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    listener ;", "}", "METHOD_END"], "methodName": ["setListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AddListenerAction"}, {"methodBody": ["METHOD_START", "{", "Array < Action >    currentA =    target . getA )  ;", "if    (  ( currentAsize )     =  =     1  )", "waitForAclear (  )  ;", "for    ( int   i    =     ( waitForAsize )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "Action   action    =    waitForAget ( i )  ;", "int   index    =    currentAindexOf ( action ,    true )  ;", "if    ( index    =  =     (  -  1  )  )", "waitForAremoveIndex ( i )  ;", "}", "if    (  ( waitForAsize )     >     0  )", "return   false ;", "return   action . act ( delta )  ;", "}", "METHOD_END"], "methodName": ["delegate"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AfterAction"}, {"methodBody": ["METHOD_START", "{", "super . restart (  )  ;", "waitFos . clear (  )  ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AfterAction"}, {"methodBody": ["METHOD_START", "{", "if    ( target    !  =    null )", "waitForAaddAll ( target . getA )  )  ;", "super . setTarget ( target )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AfterAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( color )     =  =    null )", "color    =    target . getColor (  )  ;", "start    =    color . a ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AlphaAction"}, {"methodBody": ["METHOD_START", "{", "return   end ;", "}", "METHOD_END"], "methodName": ["getAlpha"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AlphaAction"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AlphaAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "color    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AlphaAction"}, {"methodBody": ["METHOD_START", "{", "this . end    =    alpha ;", "}", "METHOD_END"], "methodName": ["setAlpha"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AlphaAction"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AlphaAction"}, {"methodBody": ["METHOD_START", "{", "color . a    =     ( start )     +     (  (  ( end )     -     ( start )  )     *    percent )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.AlphaAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( color )     =  =    null )", "color    =    target . get (  )  ;", "startR    =    color . r ;", "startG    =    color . g ;", "startB    =    color . b ;", "startA    =    color . a ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ColorAction"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ColorAction"}, {"methodBody": ["METHOD_START", "{", "return   end ;", "}", "METHOD_END"], "methodName": ["getEndColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ColorAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "c    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ColorAction"}, {"methodBody": ["METHOD_START", "{", "this . color    =    color ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ColorAction"}, {"methodBody": ["METHOD_START", "{", "end . set ( color )  ;", "}", "METHOD_END"], "methodName": ["setEndColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ColorAction"}, {"methodBody": ["METHOD_START", "{", "float   r    =     ( startR )     +     (  (  ( end . r )     -     ( startR )  )     *    percent )  ;", "float   g    =     ( startG )     +     (  (  ( end . g )     -     ( startG )  )     *    percent )  ;", "float   b    =     ( startB )     +     (  (  ( end . b )     -     ( startB )  )     *    percent )  ;", "float   a    =     ( startA )     +     (  (  ( end . a )     -     ( startA )  )     *    percent )  ;", "c . set ( r ,    g ,    b ,    a )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ColorAction"}, {"methodBody": ["METHOD_START", "{", "( current )  +  +  ;", "return    ( current )     >  =     ( c )  ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.CountdownEventAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( time )     <     ( duration )  )     {", "time    +  =    delta ;", "if    (  ( time )     <     ( duration )  )", "return   false ;", "delta    =     ( time )     -     ( duration )  ;", "}", "if    (  (  )     =  =    null )", "return   true ;", "return    . act ( delta )  ;", "}", "METHOD_END"], "methodName": ["delegate"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelayAction"}, {"methodBody": ["METHOD_START", "{", "time    =    duration ;", "}", "METHOD_END"], "methodName": ["finish"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelayAction"}, {"methodBody": ["METHOD_START", "{", "return   duration ;", "}", "METHOD_END"], "methodName": ["getDuration"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelayAction"}, {"methodBody": ["METHOD_START", "{", "return   time ;", "}", "METHOD_END"], "methodName": ["getTime"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelayAction"}, {"methodBody": ["METHOD_START", "{", "super . restart (  )  ;", "time    =     0  ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelayAction"}, {"methodBody": ["METHOD_START", "{", "this . duration    =    duration ;", "}", "METHOD_END"], "methodName": ["setDuration"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelayAction"}, {"methodBody": ["METHOD_START", "{", "this . time    =    time ;", "}", "METHOD_END"], "methodName": ["setTime"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelayAction"}, {"methodBody": ["METHOD_START", "{", "Pool   pool    =    getPool (  )  ;", "setPool ( null )  ;", "try    {", "return   d ( delta )  ;", "}    finally    {", "setPool ( pool )  ;", "}", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "return   action ;", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "=    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( action )     !  =    null )", "action . restart (  )  ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "this . action    =    action ;", "}", "METHOD_END"], "methodName": ["setAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( action )     !  =    null )", "action . setActor ( actor )  ;", "super . setActor ( actor )  ;", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( action )     !  =    null )", "action . setTarget ( target )  ;", "super . setTarget ( target )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "return    ( super . toString (  )  )     +     (  ( action )     =  =    null    ?     \"  \"     :     (  \"  (  \"     +     ( action )  )     +     \"  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.DelegateAction"}, {"methodBody": ["METHOD_START", "{", "active    =    true ;", "return   result ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.EventAction"}, {"methodBody": ["METHOD_START", "{", "return   active ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.EventAction"}, {"methodBody": ["METHOD_START", "{", "result    =    false ;", "ve    =    false ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.EventAction"}, {"methodBody": ["METHOD_START", "{", "this . active    =    active ;", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.EventAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( target )     !  =    null )", "target . removeListr ( listr )  ;", "super . setTarget ( newTarget )  ;", "if    ( newTarget    !  =    null )", "newTarget . addListr ( listr )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.EventAction"}, {"methodBody": ["METHOD_START", "{", "value    =    start ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "return   end ;", "}", "METHOD_END"], "methodName": ["getEnd"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "return   start ;", "}", "METHOD_END"], "methodName": ["getStart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "this . end    =    end ;", "}", "METHOD_END"], "methodName": ["setEnd"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "this . start    =    start ;", "}", "METHOD_END"], "methodName": ["setStart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "value    =     ( start )     +     (  (  ( end )     -     ( start )  )     *    percent )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.FloatAction"}, {"methodBody": ["METHOD_START", "{", "value    =    start ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "return   end ;", "}", "METHOD_END"], "methodName": ["getEnd"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "return   start ;", "}", "METHOD_END"], "methodName": ["getStart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "this . end    =    end ;", "}", "METHOD_END"], "methodName": ["setEnd"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "this . start    =    start ;", "}", "METHOD_END"], "methodName": ["setStart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "value    =     (  ( int )     (  ( start )     +     (  (  ( end )     -     ( start )  )     *    percent )  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.IntAction"}, {"methodBody": ["METHOD_START", "{", "(  ( Layout )     ( target )  )  . setLayoutEnabled ( enabled )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.LayoutAction"}, {"methodBody": ["METHOD_START", "{", "return   enabled ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.LayoutAction"}, {"methodBody": ["METHOD_START", "{", "this . enabled    =    enabled ;", "}", "METHOD_END"], "methodName": ["setLayoutEnabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.LayoutAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor    !  =    null )     &  &     (  !  ( actor   instanceof   Layout )  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Actor   must   implement   layout :     \"     +    actor )  )  ;", "super . setTarget ( actor )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.LayoutAction"}, {"methodBody": ["METHOD_START", "{", "return   amountX ;", "}", "METHOD_END"], "methodName": ["getAmountX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveByAction"}, {"methodBody": ["METHOD_START", "{", "return   amountY ;", "}", "METHOD_END"], "methodName": ["getAmountY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveByAction"}, {"methodBody": ["METHOD_START", "{", "amountX    =    x ;", "amountY    =    y ;", "}", "METHOD_END"], "methodName": ["setAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveByAction"}, {"methodBody": ["METHOD_START", "{", "amountX    =    x ;", "}", "METHOD_END"], "methodName": ["setAmountX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveByAction"}, {"methodBody": ["METHOD_START", "{", "amountY    =    y ;", "}", "METHOD_END"], "methodName": ["setAmountY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveByAction"}, {"methodBody": ["METHOD_START", "{", "target . moveBy (  (  ( amountX )     *    percentDelta )  ,     (  ( amountY )     *    percentDelta )  )  ;", "}", "METHOD_END"], "methodName": ["updateRelative"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveByAction"}, {"methodBody": ["METHOD_START", "{", "startX    =    target . getX ( alignment )  ;", "startY    =    target . getY ( alignment )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "return   alignment ;", "}", "METHOD_END"], "methodName": ["getAlignment"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "return   endX ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "return   endY ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "alignment    =    Align . bottomLeft ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "this . alignment    =    alignment ;", "}", "METHOD_END"], "methodName": ["setAlignment"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "endX    =    x ;", "endY    =    y ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "endX    =    x ;", "endY    =    y ;", "this . alignment    =    alignment ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "startX    =    x ;", "startY    =    y ;", "}", "METHOD_END"], "methodName": ["setStartPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "endX    =    x ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "endY    =    y ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "target . setPosition (  (  ( startX )     +     (  (  ( endX )     -     ( startX )  )     *    percent )  )  ,     (  ( startY )     +     (  (  ( endY )     -     ( startY )  )     *    percent )  )  ,    alignment )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.MoveToAction"}, {"methodBody": ["METHOD_START", "{", "if    ( complete )", "return   true ;", "complete    =    true ;", "Pool   pool    =    getPool (  )  ;", "setPool ( null )  ;", "try    {", "Array < Action >     =    this ;", "for    ( int   i    =     0  ,    n    =  . size ;     ( i    <    n )     &  &     (  ( actor )     !  =    null )  ;    i +  +  )     {", "Action   currentAction    =  . get ( i )  ;", "if    (  (  ( currentAction . getActor (  )  )     !  =    null )     &  &     (  !  ( currentAction . act ( delta )  )  )  )", "complete    =    false ;", "if    (  ( actor )     =  =    null )", "return   true ;", "}", "return   complete ;", "}    finally    {", "setPool ( pool )  ;", "}", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ParallelAction"}, {"methodBody": ["METHOD_START", "{", "actions . add ( action )  ;", "if    (  ( actor )     !  =    null )", "action . setActor ( actor )  ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ParallelAction"}, {"methodBody": ["METHOD_START", "{", "return   actions ;", "}", "METHOD_END"], "methodName": ["getActions"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ParallelAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "clear (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ParallelAction"}, {"methodBody": ["METHOD_START", "{", "complete    =    false ;", "Array < Action >     =    this ;", "for    ( int   i    =     0  ,    n    =  . size ;    i    <    n ;    i +  +  )", ". get ( i )  . restart (  )  ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ParallelAction"}, {"methodBody": ["METHOD_START", "{", "Array < Action >    actions    =    this . actions ;", "for    ( int   i    =     0  ,    n    =    actions . size ;    i    <    n ;    i +  +  )", "actions . get ( i )  . setActor ( actor )  ;", "super . setActor ( actor )  ;", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ParallelAction"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buffer    =    new   StringBuilder (  6  4  )  ;", "buffer . append ( super . toString (  )  )  ;", "buffer . append (  '  (  '  )  ;", "Array < Action >     =    this ;", "for    ( int   i    =     0  ,    n    =  . size ;    i    <    n ;    i +  +  )     {", "if    ( i    >     0  )", "buffer . append (  \"  ,     \"  )  ;", "buffer . append . get ( i )  )  ;", "}", "buffer . append (  '  )  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ParallelAction"}, {"methodBody": ["METHOD_START", "{", "lastPercent    =     0  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RelativeTemporalAction"}, {"methodBody": ["METHOD_START", "{", "updateRelative (  ( percent    -     ( lastPercent )  )  )  ;", "lastPercent    =    percent ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RelativeTemporalAction"}, {"methodBody": ["METHOD_START", "{", "target . removeAction ( action )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveAction"}, {"methodBody": ["METHOD_START", "{", "return   action ;", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "=    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveAction"}, {"methodBody": ["METHOD_START", "{", "this . action    =    action ;", "}", "METHOD_END"], "methodName": ["setAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveAction"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( removed )  )     {", "removed    =    true ;", "target . remove (  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction"}, {"methodBody": ["METHOD_START", "{", "removed    =    false ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveActorAction"}, {"methodBody": ["METHOD_START", "{", "if    ( capture )", "target . removeCaptureListener ( listener )  ;", "else", "target . r ( listener )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction"}, {"methodBody": ["METHOD_START", "{", "return   capture ;", "}", "METHOD_END"], "methodName": ["getCapture"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction"}, {"methodBody": ["METHOD_START", "{", "return   listener ;", "}", "METHOD_END"], "methodName": ["getListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "l    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction"}, {"methodBody": ["METHOD_START", "{", "this . capture    =    capture ;", "}", "METHOD_END"], "methodName": ["setCapture"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    listener ;", "}", "METHOD_END"], "methodName": ["setListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RemoveListenerAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executedCount )     =  =     ( repeatCount )  )", "return   true ;", "if    (  . act ( delta )  )     {", "if    ( finished )", "return   true ;", "if    (  ( repeatCount )     >     0  )", "( executedCount )  +  +  ;", "if    (  ( executedCount )     =  =     ( repeatCount )  )", "return   true ;", "if    (  (  )     !  =    null )", ". restart (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["delegate"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RepeatAction"}, {"methodBody": ["METHOD_START", "{", "finished    =    true ;", "}", "METHOD_END"], "methodName": ["finish"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RepeatAction"}, {"methodBody": ["METHOD_START", "{", "return   repeatCount ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RepeatAction"}, {"methodBody": ["METHOD_START", "{", "super . restart (  )  ;", "executedCount    =     0  ;", "finished    =    false ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RepeatAction"}, {"methodBody": ["METHOD_START", "{", "this . repeatCount    =    count ;", "}", "METHOD_END"], "methodName": ["setCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RepeatAction"}, {"methodBody": ["METHOD_START", "{", "return   amount ;", "}", "METHOD_END"], "methodName": ["getAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RotateByAction"}, {"methodBody": ["METHOD_START", "{", "amount    =    rotationAmount ;", "}", "METHOD_END"], "methodName": ["setAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RotateByAction"}, {"methodBody": ["METHOD_START", "{", "target . rotateBy (  (  ( amount )     *    percentDelta )  )  ;", "}", "METHOD_END"], "methodName": ["updateRelative"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RotateByAction"}, {"methodBody": ["METHOD_START", "{", "return   end ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RotateToAction"}, {"methodBody": ["METHOD_START", "{", "return   useShortestDirection ;", "}", "METHOD_END"], "methodName": ["isUseShortestDirection"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RotateToAction"}, {"methodBody": ["METHOD_START", "{", "this . end    =    rotation ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RotateToAction"}, {"methodBody": ["METHOD_START", "{", "this . useShortestDirection    =    useShortestDirection ;", "}", "METHOD_END"], "methodName": ["setUseShortestDirection"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RotateToAction"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ran )  )     {", "ran    =    true ;", "r (  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RunnableAction"}, {"methodBody": ["METHOD_START", "{", "return   runnable ;", "}", "METHOD_END"], "methodName": ["getRunnable"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RunnableAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "r    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RunnableAction"}, {"methodBody": ["METHOD_START", "{", "ran    =    false ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RunnableAction"}, {"methodBody": ["METHOD_START", "{", "Pool   pool    =    getPool (  )  ;", "setPool ( null )  ;", "try    {", "r . run (  )  ;", "}    finally    {", "setPool ( pool )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RunnableAction"}, {"methodBody": ["METHOD_START", "{", "this . runnable    =    runnable ;", "}", "METHOD_END"], "methodName": ["setRunnable"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.RunnableAction"}, {"methodBody": ["METHOD_START", "{", "return   amountX ;", "}", "METHOD_END"], "methodName": ["getAmountX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction"}, {"methodBody": ["METHOD_START", "{", "return   amountY ;", "}", "METHOD_END"], "methodName": ["getAmountY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction"}, {"methodBody": ["METHOD_START", "{", "amountX    =    scale ;", "amountY    =    scale ;", "}", "METHOD_END"], "methodName": ["setAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction"}, {"methodBody": ["METHOD_START", "{", "amountX    =    x ;", "amountY    =    y ;", "}", "METHOD_END"], "methodName": ["setAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction"}, {"methodBody": ["METHOD_START", "{", "this . amountX    =    x ;", "}", "METHOD_END"], "methodName": ["setAmountX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction"}, {"methodBody": ["METHOD_START", "{", "this . amountY    =    y ;", "}", "METHOD_END"], "methodName": ["setAmountY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction"}, {"methodBody": ["METHOD_START", "{", "target . scaleBy (  (  ( amountX )     *    percentDelta )  ,     (  ( amountY )     *    percentDelta )  )  ;", "}", "METHOD_END"], "methodName": ["updateRelative"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleByAction"}, {"methodBody": ["METHOD_START", "{", "startX    =    target . getScaleX (  )  ;", "startY    =    target . getScaleY (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "return   endX ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "return   endY ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "endX    =    scale ;", "endY    =    scale ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "endX    =    x ;", "endY    =    y ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "this . endX    =    x ;", "}", "METHOD_END"], "methodName": ["setX"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "this . endY    =    y ;", "}", "METHOD_END"], "methodName": ["setY"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "target . setScale (  (  ( startX )     +     (  (  ( endX )     -     ( startX )  )     *    percent )  )  ,     (  ( startY )     +     (  (  ( endY )     -     ( startY )  )     *    percent )  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.ScaleToAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index )     >  =     ( actions . size )  )", "return   true ;", "Pool   pool    =    getPool (  )  ;", "setPool ( null )  ;", "try    {", "if    ( actions . get ( index )  . act ( delta )  )     {", "if    (  ( actor )     =  =    null )", "return   true ;", "( index )  +  +  ;", "if    (  ( index )     >  =     ( actions . size )  )", "return   true ;", "}", "return   false ;", "}    finally    {", "setPool ( pool )  ;", "}", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SequenceAction"}, {"methodBody": ["METHOD_START", "{", "super . restart (  )  ;", "index    =     0  ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SequenceAction"}, {"methodBody": ["METHOD_START", "{", "return   amountHeight ;", "}", "METHOD_END"], "methodName": ["getAmountHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeByAction"}, {"methodBody": ["METHOD_START", "{", "return   amountWidth ;", "}", "METHOD_END"], "methodName": ["getAmountWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeByAction"}, {"methodBody": ["METHOD_START", "{", "amountWidth    =    width ;", "amountHeight    =    height ;", "}", "METHOD_END"], "methodName": ["setAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeByAction"}, {"methodBody": ["METHOD_START", "{", "amountHeight    =    height ;", "}", "METHOD_END"], "methodName": ["setAmountHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeByAction"}, {"methodBody": ["METHOD_START", "{", "amountWidth    =    width ;", "}", "METHOD_END"], "methodName": ["setAmountWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeByAction"}, {"methodBody": ["METHOD_START", "{", "target . sizeBy (  (  ( amountWidth )     *    percentDelta )  ,     (  ( amountHeight )     *    percentDelta )  )  ;", "}", "METHOD_END"], "methodName": ["updateRelative"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeByAction"}, {"methodBody": ["METHOD_START", "{", "startWidth    =    target . getWidth (  )  ;", "startHeight    =    target . getHeight (  )  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeToAction"}, {"methodBody": ["METHOD_START", "{", "return   endHeight ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeToAction"}, {"methodBody": ["METHOD_START", "{", "return   endWidth ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeToAction"}, {"methodBody": ["METHOD_START", "{", "endHeight    =    height ;", "}", "METHOD_END"], "methodName": ["setHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeToAction"}, {"methodBody": ["METHOD_START", "{", "endWidth    =    width ;", "endHeight    =    height ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeToAction"}, {"methodBody": ["METHOD_START", "{", "endWidth    =    width ;", "}", "METHOD_END"], "methodName": ["setWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeToAction"}, {"methodBody": ["METHOD_START", "{", "target . setSize (  (  ( startWidth )     +     (  (  ( endWidth )     -     ( startWidth )  )     *    percent )  )  ,     (  ( startHeight )     +     (  (  ( endHeight )     -     ( startHeight )  )     *    percent )  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.SizeToAction"}, {"methodBody": ["METHOD_START", "{", "if    ( complete )", "return   true ;", "Pool   pool    =    getPool (  )  ;", "setPool ( null )  ;", "try    {", "if    (  !  ( began )  )     {", "begin (  )  ;", "began    =    true ;", "}", "time    +  =    delta ;", "complete    =     ( time )     >  =     ( dura )  ;", "float   percent ;", "if    ( complete )", "percent    =     1  ;", "else    {", "percent    =     ( time )     /     ( dura )  ;", "if    (  ( interpola )     !  =    null )", "percent    =    interpola . apply ( percent )  ;", "}", "update (  ( reverse    ?     1     -    percent    :    percent )  )  ;", "if    ( complete )", "end (  )  ;", "return   complete ;", "}    finally    {", "setPool ( pool )  ;", "}", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "time    =    duration ;", "}", "METHOD_END"], "methodName": ["finish"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "return   duration ;", "}", "METHOD_END"], "methodName": ["getDuration"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "return   interpolation ;", "}", "METHOD_END"], "methodName": ["getInterpolation"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "return   time ;", "}", "METHOD_END"], "methodName": ["getTime"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "return   reverse ;", "}", "METHOD_END"], "methodName": ["isReverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "super . reset (  )  ;", "reverse    =    false ;", "interpola    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "time    =     0  ;", "began    =    false ;", "plete    =    false ;", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "this . duration    =    duration ;", "}", "METHOD_END"], "methodName": ["setDuration"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "this . interpolation    =    interpolation ;", "}", "METHOD_END"], "methodName": ["setInterpolation"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "this . reverse    =    reverse ;", "}", "METHOD_END"], "methodName": ["setReverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "this . time    =    time ;", "}", "METHOD_END"], "methodName": ["setTime"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TemporalAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( action )     =  =    null )", "return   true ;", "return   action . act (  ( delta    *     ( scale )  )  )  ;", "}", "METHOD_END"], "methodName": ["delegate"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TimeScaleAction"}, {"methodBody": ["METHOD_START", "{", "return   scale ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TimeScaleAction"}, {"methodBody": ["METHOD_START", "{", "this . scale    =    scale ;", "}", "METHOD_END"], "methodName": ["setScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TimeScaleAction"}, {"methodBody": ["METHOD_START", "{", "target . setTouchable ( touchable )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TouchableAction"}, {"methodBody": ["METHOD_START", "{", "return   touchable ;", "}", "METHOD_END"], "methodName": ["getTouchable"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TouchableAction"}, {"methodBody": ["METHOD_START", "{", "this . touchable    =    touchable ;", "}", "METHOD_END"], "methodName": ["setTouchable"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.TouchableAction"}, {"methodBody": ["METHOD_START", "{", "target . setVisible ( visible )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.VisibleAction"}, {"methodBody": ["METHOD_START", "{", "return   visible ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.VisibleAction"}, {"methodBody": ["METHOD_START", "{", "this . visible    =    visible ;", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "com.badlogic.gdx.scenes.scene2d.actions.VisibleAction"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "boolean   isDisabled    =    isDisabled (  )  ;", "boolean   isPressed    =    isPressed (  )  ;", "boolean   isChecked    =    isChecked (  )  ;", "boolean   isOver    =    isOver (  )  ;", "Drawable   background    =    null ;", "if    ( isDisabled    &  &     (  ( style . disabled )     !  =    null )  )", "background    =    style . disabled ;", "else", "if    ( isPressed    &  &     (  ( style . down )     !  =    null )  )", "background    =    style . down ;", "else", "if    ( isChecked    &  &     (  ( style . checked )     !  =    null )  )", "background    =     (  (  ( style . checkedOver )     !  =    null )     &  &    isOver )     ?    style . checkedOver    :    style . checked ;", "else", "if    ( isOver    &  &     (  ( style . over )     !  =    null )  )", "background    =    style . over ;", "else", "if    (  ( style . up )     !  =    null )", "background    =    style . up ;", "setBackground ( background )  ;", "float   offsetX    =     0  ;", "float   offsetY    =     0  ;", "if    ( isPressed    &  &     (  ! isDisabled )  )     {", "offsetX    =    style . pressedOffsetX ;", "offsetY    =    style . pressedOffsetY ;", "} else", "if    ( isChecked    &  &     (  ! isDisabled )  )     {", "offsetX    =    style . checkedOffsetX ;", "offsetY    =    style . checkedOffsetY ;", "} else    {", "offsetX    =    style . unpressedOffsetX ;", "offsetY    =    style . unpressedOffsetY ;", "}", "Array < Actor >    children    =    getChildren (  )  ;", "for    ( int   i    =     0  ;    i    <     ( children . size )  ;    i +  +  )", "children . get ( i )  . moveBy ( offsetX ,    offsetY )  ;", "super . draw ( batch ,    a )  ;", "for    ( int   i    =     0  ;    i    <     ( children . size )  ;    i +  +  )", "children . get ( i )  . moveBy (  (  - offsetX )  ,     (  - offsetY )  )  ;", "Stage   stage    =    getStage (  )  ;", "if    (  (  ( stage    !  =    null )     &  &     ( stage . getActionsRequestRendering (  )  )  )     &  &     ( isPressed    !  =     ( clickListener . isPressed (  )  )  )  )", "Gdx . graphics . requestRendering (  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   buttonGroup ;", "}", "METHOD_END"], "methodName": ["getButtonGroup"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   clickListener ;", "}", "METHOD_END"], "methodName": ["getClickListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   getPrefHeight (  )  ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   getPrefWidth (  )  ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "float   height    =    super . getPrefHeight (  )  ;", "if    (  ( style . up )     !  =    null )", "height    =    Math . max ( height ,    style . up . getMinHeight (  )  )  ;", "if    (  ( style . down )     !  =    null )", "height    =    Math . max ( height ,    style . down . getMinHeight (  )  )  ;", "if    (  ( style . checked )     !  =    null )", "height    =    Math . max ( height ,    style . checked . getMinHeight (  )  )  ;", "return   height ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "float   width    =    super . getPrefWidth (  )  ;", "if    (  ( style . up )     !  =    null )", "width    =    Math . max ( width ,    style . up . getMinWidth (  )  )  ;", "if    (  ( style . down )     !  =    null )", "width    =    Math . max ( width ,    style . down . getMinWidth (  )  )  ;", "if    (  ( style . checked )     !  =    null )", "width    =    Math . max ( width ,    style . checked . getMinWidth (  )  )  ;", "return   width ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "setTouchable ( Touchable . enabled )  ;", "addListr (  ( clickListr    =    new   ClickListr (  )     {", "public   void   clicked ( InputEvent   event ,    float   x ,    float   y )     {", "if    ( isDisabled (  )  )", "return ;", "setChecked (  (  !  ( isChecked )  )  ,    true )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   isChecked ;", "}", "METHOD_END"], "methodName": ["isChecked"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   isDisabled ;", "}", "METHOD_END"], "methodName": ["isDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   clickListener . isOver (  )  ;", "}", "METHOD_END"], "methodName": ["isOver"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "return   clickListener . isVisualPressed (  )  ;", "}", "METHOD_END"], "methodName": ["isPressed"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "setChecked ( isChecked ,    programmaticChangeEvents )  ;", "}", "METHOD_END"], "methodName": ["setChecked"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . isChecked )     =  =    isChecked )", "return ;", "if    (  (  ( bGroup )     !  =    null )     &  &     (  !  ( bGroup . canCheck ( this ,    isChecked )  )  )  )", "return ;", "this . isChecked    =    isChecked ;", "if    ( fireEvent )     {", "ChangeListener . ChangeEvent   changeEvent    =    Pools . obtain ( ChangeListener . ChangeEvent . class )  ;", "if    ( fire ( changeEvent )  )", "this . isChecked    =     ! isChecked ;", "Pools . free ( changeEvent )  ;", "}", "}", "METHOD_END"], "methodName": ["setChecked"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "this . isDisabled    =    isDisabled ;", "}", "METHOD_END"], "methodName": ["setDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "this . programmaticChangeEvents    =    programmaticChangeEvents ;", "}", "METHOD_END"], "methodName": ["setProgrammaticChangeEvents"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "thityle    =    style ;", "Drawable   background    =    null ;", "if    (  ( isPressed (  )  )     &  &     (  !  ( isDisabled (  )  )  )  )     {", "background    =     (  ( style . down )     =  =    null )     ?    style . up    :    style . down ;", "} else    {", "if    (  ( isDisabled (  )  )     &  &     (  ( style . disabled )     !  =    null )  )", "background    =    style . disabled ;", "else", "if    (  ( isChecked )     &  &     (  ( style . checked )     !  =    null )  )", "background    =     (  ( isOver (  )  )     &  &     (  ( style . checkedOver )     !  =    null )  )     ?    style . checkedOver    :    style . checked ;", "else", "if    (  ( isOver (  )  )     &  &     (  ( style . over )     !  =    null )  )", "background    =    style . over ;", "else", "background    =    style . up ;", "}", "setBackground ( background )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "setChecked (  (  !  ( isChecked )  )  )  ;", "}", "METHOD_END"], "methodName": ["toggle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Button"}, {"methodBody": ["METHOD_START", "{", "if    ( button    =  =    null )", "throw   new   IllegalArgumentException (  \" button   cannot   be   null .  \"  )  ;", "button . b    =    null ;", "boolean   shouldCheck    =     ( button . isChecked (  )  )     |  |     (  ( buttons . size )     <     ( minCheckCount )  )  ;", "button . setChecked ( false )  ;", "button . b    =    this ;", "buttons . add ( button )  ;", "button . setChecked ( shouldCheck )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( buttons    =  =    null )", "throw   new   IllegalArgumentException (  \" buttons   cannot   be   null .  \"  )  ;", "for    ( int   i    =     0  ,    n    =    buttons . length ;    i    <    n ;    i +  +  )", "add ( buttons [ i ]  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( button . isChecked )     =  =    newState )", "return   false ;", "if    (  ! newState )     {", "if    (  ( checkeds . size )     <  =     ( minCheckCount )  )", "return   false ;", "checkeds . removeValue ( button ,    true )  ;", "} else    {", "if    (  (  ( maxCheckCount )     !  =     (  -  1  )  )     &  &     (  ( checkeds . size )     >  =     ( maxCheckCount )  )  )     {", "if    ( uncheckLast )     {", "int   old    =    minCheckCount ;", "minCheckCount    =     0  ;", "lastChecked . setChecked ( false )  ;", "minCheckCount    =    old ;", "} else", "return   false ;", "}", "checkeds . add ( button )  ;", "lastChecked    =    button ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["canCheck"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "buttons . clear (  )  ;", "checkeds . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "return   checkedButtons ;", "}", "METHOD_END"], "methodName": ["getAllChecked"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "return   buttons ;", "}", "METHOD_END"], "methodName": ["getButtons"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( checkedButtons . size )     >     0  )", "return   checkedButtons . get (  0  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getChecked"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( checkedButtons . size )     >     0  )", "return   buttons . indexOf ( checkedButtons . get (  0  )  ,    true )  ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getCheckedIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( button    =  =    null )", "throw   new   IllegalArgumentException (  \" button   cannot   be   null .  \"  )  ;", "button . b    =    null ;", "buttons . removeValue ( button ,    true )  ;", "checkedButtons . removeValue ( button ,    true )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( buttons    =  =    null )", "throw   new   IllegalArgumentException (  \" buttons   cannot   be   null .  \"  )  ;", "for    ( int   i    =     0  ,    n    =    buttons . length ;    i    <    n ;    i +  +  )", "remove ( buttons [ i ]  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( text    =  =    null )", "throw   new   IllegalArgumentException (  \" text   cannot   be   null .  \"  )  ;", "for    ( int   i    =     0  ,    n    =    buttons . size ;    i    <    n ;    i +  +  )     {", "T   button    =    buttons . get ( i )  ;", "if    (  ( button   instanceof   Text )     &  &     ( text . contentEquals (  (  ( Text )     ( button )  )  . getText (  )  )  )  )     {", "button . setChecked ( true )  ;", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["setChecked"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( maxCheckCount    =  =     0  )", "maxCheckCount    =     -  1  ;", "this . maxCheckCount    =    maxCheckCount ;", "}", "METHOD_END"], "methodName": ["setMaxCheckCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "this . minCheckCount    =    minCheckCount ;", "}", "METHOD_END"], "methodName": ["setMinCheckCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "this . uncheckLast    =    uncheckLast ;", "}", "METHOD_END"], "methodName": ["setUncheckLast"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "int   old    =    minCheckCount ;", "minCheckCount    =     0  ;", "for    ( int   i    =     0  ,    n    =    bs . size ;    i    <    n ;    i +  +  )     {", "T   b    =    bs . get ( i )  ;", "b . setChecked ( false )  ;", "}", "minCheckCount    =    old ;", "}", "METHOD_END"], "methodName": ["uncheckAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup"}, {"methodBody": ["METHOD_START", "{", "this . align    =    align ;", "return   this ;", "}", "METHOD_END"], "methodName": ["align"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    (  ( align )     =  =    null )", "align    =    Cell . bottomi ;", "else", "align    =     (  ( align )     |     ( utils . Align . bottom )  )     &     (  ~  ( utils . Align . top )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "align    =    Cell . centeri ;", "return   this ;", "}", "METHOD_END"], "methodName": ["center"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "minWidth    =    null ;", "minHeight    =    null ;", "prefWidth    =    null ;", "prefHeight    =    null ;", "maxWidth    =    null ;", "maxHeight    =    null ;", "spaceTop    =    null ;", "spaceLeft    =    null ;", "spaceBottom    =    null ;", "spaceRight    =    null ;", "padTop    =    null ;", "padLeft    =    null ;", "padBottom    =    null ;", "padRight    =    null ;", "fillX    =    null ;", "fillY    =    null ;", "align    =    null ;", "expandX    =    null ;", "expandY    =    null ;", "colspan    =    null ;", "uniformX    =    null ;", "uniformY    =    null ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "setActor ( null )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["clearActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . colspan    =    colspan ;", "return   this ;", "}", "METHOD_END"], "methodName": ["colspan"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( Cell . files )     =  =    null )     |  |     (  ( Cell . files )     !  =     ( Gdx . files )  )  )     {", "Cell . files    =    Gdx . files ;", "Cell . defaults    =    new   Cell (  )  ;", "Cell . defaults . minWidth    =    Value . minWidth ;", "Cell . defaults . minHeight    =    Value . minHeight ;", "Cell . defaults . prefWidth    =    Value . prefWidth ;", "Cell . defaults . prefHeight    =    Value . prefHeight ;", "Cell . defaults . maxWidth    =    Value . maxWidth ;", "Cell . defaults . maxHeight    =    Value . maxHeight ;", "Cell . defaults . spaceTop    =    Value . zero ;", "Cell . defaults . spaceLeft    =    Value . zero ;", "Cell . defaults . spaceBottom    =    Value . zero ;", "Cell . defaults . spaceRight    =    Value . zero ;", "Cell . defaults . padTop    =    Value . zero ;", "Cell . defaults . padLeft    =    Value . zero ;", "Cell . defaults . padBottom    =    Value . zero ;", "Cell . defaults . padRight    =    Value . zero ;", "Cell . defaults . fillX    =    Cell . zerof ;", "Cell . defaults . fillY    =    Cell . zerof ;", "Cell . defaults . align    =    Cell . centeri ;", "Cell . defaults . expandX    =    Cell . zeroi ;", "Cell . defaults . expandY    =    Cell . zeroi ;", "Cell . defaults . colspan    =    Cell . onei ;", "Cell . defaults . uniformX    =    null ;", "Cell . defaults . uniformY    =    null ;", "}", "return   Cell . defaults ;", "}", "METHOD_END"], "methodName": ["defaults"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandX    =    Cell . onei ;", "expandY    =    Cell . onei ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandX    =     ( x )     ?    Cell . onei    :    Cell . zeroi ;", "expandY    =     ( y )     ?    Cell . onei    :    Cell . zeroi ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandX    =    x ;", "expandY    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandX    =    Cell . onei ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expandX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandY    =    Cell . onei ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expandY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "fillX    =    Cell . onef ;", "fillY    =    Cell . onef ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "fillX    =     ( fill )     ?    Cell . onef    :    Cell . zerof ;", "fillY    =     ( fill )     ?    Cell . onef    :    Cell . zerof ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "fillX    =     ( x )     ?    Cell . onef    :    Cell . zerof ;", "fillY    =     ( y )     ?    Cell . onef    :    Cell . zerof ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "fillX    =    x ;", "fillY    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "fillX    =    Cell . onef ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fillX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "fillY    =    Cell . onef ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fillY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( actor )  )  ;", "}", "METHOD_END"], "methodName": ["getActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   actorHeight ;", "}", "METHOD_END"], "methodName": ["getActorHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   actorWidth ;", "}", "METHOD_END"], "methodName": ["getActorWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   actorX ;", "}", "METHOD_END"], "methodName": ["getActorX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   actorY ;", "}", "METHOD_END"], "methodName": ["getActorY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   align ;", "}", "METHOD_END"], "methodName": ["getAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   colspan ;", "}", "METHOD_END"], "methodName": ["getColspan"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   column ;", "}", "METHOD_END"], "methodName": ["getColumn"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   computedPadBottom ;", "}", "METHOD_END"], "methodName": ["getComputedPadBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   computedPadLeft ;", "}", "METHOD_END"], "methodName": ["getComputedPadLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   computedPadRight ;", "}", "METHOD_END"], "methodName": ["getComputedPadRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   computedPadTop ;", "}", "METHOD_END"], "methodName": ["getComputedPadTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   expandX ;", "}", "METHOD_END"], "methodName": ["getExpandX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   expandY ;", "}", "METHOD_END"], "methodName": ["getExpandY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   fillX ;", "}", "METHOD_END"], "methodName": ["getFillX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   fillY ;", "}", "METHOD_END"], "methodName": ["getFillY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   maxHeight . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getMaxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   maxHeight ;", "}", "METHOD_END"], "methodName": ["getMaxHeightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   maxWidth . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getMaxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   maxWidth ;", "}", "METHOD_END"], "methodName": ["getMaxWidthValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   minHeight . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   minHeight ;", "}", "METHOD_END"], "methodName": ["getMinHeightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   minWidth . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   minWidth ;", "}", "METHOD_END"], "methodName": ["getMinWidthValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padBottom . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getPadBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padBottom ;", "}", "METHOD_END"], "methodName": ["getPadBottomValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padLeft . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getPadLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padLeft ;", "}", "METHOD_END"], "methodName": ["getPadLeftValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padRight . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getPadRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padRight ;", "}", "METHOD_END"], "methodName": ["getPadRightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padTop . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getPadTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   padTop ;", "}", "METHOD_END"], "methodName": ["getPadTopValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return    ( padLeft . get ( actor )  )     +     ( padRight . get ( actor )  )  ;", "}", "METHOD_END"], "methodName": ["getPadX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return    ( padTop . get ( actor )  )     +     ( padBottom . get ( actor )  )  ;", "}", "METHOD_END"], "methodName": ["getPadY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   prefHeight . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   prefWidth . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidthValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   row ;", "}", "METHOD_END"], "methodName": ["getRow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceBottom . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getSpaceBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceBottom ;", "}", "METHOD_END"], "methodName": ["getSpaceBottomValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceLeft . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getSpaceLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceLeft ;", "}", "METHOD_END"], "methodName": ["getSpaceLeftValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceRight . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getSpaceRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceRight ;", "}", "METHOD_END"], "methodName": ["getSpaceRightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceTop . get ( actor )  ;", "}", "METHOD_END"], "methodName": ["getSpaceTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   spaceTop ;", "}", "METHOD_END"], "methodName": ["getSpaceTopValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   table ;", "}", "METHOD_END"], "methodName": ["getTable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   uniformX ;", "}", "METHOD_END"], "methodName": ["getUniformX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   uniformY ;", "}", "METHOD_END"], "methodName": ["getUniformY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandX    =    Cell . onei ;", "expandY    =    Cell . onei ;", "fillX    =    Cell . onef ;", "fillY    =    Cell . onef ;", "return   this ;", "}", "METHOD_END"], "methodName": ["grow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandX    =    Cell . onei ;", "fillX    =    Cell . onef ;", "return   this ;", "}", "METHOD_END"], "methodName": ["growX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "expandY    =    Cell . onei ;", "fillY    =    Cell . onef ;", "return   this ;", "}", "METHOD_END"], "methodName": ["growY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return    ( actor )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( height    =  =    null )", "throw   new   IllegalArgumentException (  \" height   cannot   be   null .  \"  )  ;", "minHeight    =    height ;", "prefHeight    =    height ;", "maxHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["height"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "height ( new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["height"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return   endRow ;", "}", "METHOD_END"], "methodName": ["isEndRow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    (  ( align )     =  =    null )", "align    =    Cell . lefti ;", "else", "align    =     (  ( align )     |     ( utils . Align . left )  )     &     (  ~  ( utils . Align . right )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( maxHeight    =  =    null )", "throw   new   IllegalArgumentException (  \" maxHeight   cannot   be   null .  \"  )  ;", "this . maxHeight    =    maxHeight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . maxHeight    =    new   Value . Fixed ( maxHeight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentException (  \" size   cannot   be   null .  \"  )  ;", "maxWidth    =    size ;", "maxHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentException (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentException (  \" height   cannot   be   null .  \"  )  ;", "maxWidth    =    width ;", "maxHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "maxSize ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "maxSize ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( maxWidth    =  =    null )", "throw   new   IllegalArgumentException (  \" maxWidth   cannot   be   null .  \"  )  ;", "this . maxWidth    =    maxWidth ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . maxWidth    =    new   Value . Fixed ( maxWidth )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( cell    =  =    null )", "return ;", "if    (  ( cell . minWidth )     !  =    null )", "minWidth    =    cell . minWidth ;", "if    (  ( cell . minHeight )     !  =    null )", "minHeight    =    cell . minHeight ;", "if    (  ( cell . prefWidth )     !  =    null )", "prefWidth    =    cell . prefWidth ;", "if    (  ( cell . prefHeight )     !  =    null )", "prefHeight    =    cell . prefHeight ;", "if    (  ( cell . maxWidth )     !  =    null )", "maxWidth    =    cell . maxWidth ;", "if    (  ( cell . maxHeight )     !  =    null )", "maxHeight    =    cell . maxHeight ;", "if    (  ( cell . spaceTop )     !  =    null )", "spaceTop    =    cell . spaceTop ;", "if    (  ( cell . spaceLeft )     !  =    null )", "spaceLeft    =    cell . spaceLeft ;", "if    (  ( cell . spaceBottom )     !  =    null )", "spaceBottom    =    cell . spaceBottom ;", "if    (  ( cell . spaceRight )     !  =    null )", "spaceRight    =    cell . spaceRight ;", "if    (  ( cell . padTop )     !  =    null )", "padTop    =    cell . padTop ;", "if    (  ( cell . padLeft )     !  =    null )", "padLeft    =    cell . padLeft ;", "if    (  ( cell . padBottom )     !  =    null )", "padBottom    =    cell . padBottom ;", "if    (  ( cell . padRight )     !  =    null )", "padRight    =    cell . padRight ;", "if    (  ( cell . fillX )     !  =    null )", "fillX    =    cell . fillX ;", "if    (  ( cell . fillY )     !  =    null )", "fillY    =    cell . fillY ;", "if    (  ( cell . align )     !  =    null )", "align    =    cell . align ;", "if    (  ( cell . expandX )     !  =    null )", "expandX    =    cell . expandX ;", "if    (  ( cell . expandY )     !  =    null )", "expandY    =    cell . expandY ;", "if    (  ( cell . colspan )     !  =    null )", "colspan    =    cell . colspan ;", "if    (  ( cell . uniformX )     !  =    null )", "uniformX    =    cell . uniformX ;", "if    (  ( cell . uniformY )     !  =    null )", "uniformY    =    cell . uniformY ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( minHeight    =  =    null )", "throw   new   IllegalArgumentException (  \" minHeight   cannot   be   null .  \"  )  ;", "this . minHeight    =    minHeight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . minHeight    =    new   Value . Fixed ( minHeight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentException (  \" size   cannot   be   null .  \"  )  ;", "minWidth    =    size ;", "minHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentException (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentException (  \" height   cannot   be   null .  \"  )  ;", "minWidth    =    width ;", "minHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "minSize ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "minSize ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( minWidth    =  =    null )", "throw   new   IllegalArgumentException (  \" minWidth   cannot   be   null .  \"  )  ;", "this . minWidth    =    minWidth ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . minWidth    =    new   Value . Fixed ( minWidth )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( pad    =  =    null )", "throw   new   IllegalArgumentException (  \" pad   cannot   be   null .  \"  )  ;", "padTop    =    pad ;", "padLeft    =    pad ;", "padBottom    =    pad ;", "padRight    =    pad ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( top    =  =    null )", "throw   new   IllegalArgumentException (  \" top   cannot   be   null .  \"  )  ;", "if    ( left    =  =    null )", "throw   new   IllegalArgumentException (  \" left   cannot   be   null .  \"  )  ;", "if    ( bottom    =  =    null )", "throw   new   IllegalArgumentException (  \" bottom   cannot   be   null .  \"  )  ;", "if    ( right    =  =    null )", "throw   new   IllegalArgumentException (  \" right   cannot   be   null .  \"  )  ;", "padTop    =    top ;", "padLeft    =    left ;", "padBottom    =    bottom ;", "padRight    =    right ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "pad ( new   Value . Fixed ( pad )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "pad ( new   Value . Fixed ( top )  ,    new   Value . Fixed ( left )  ,    new   Value . Fixed ( bottom )  ,    new   Value . Fixed ( right )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( padBottom    =  =    null )", "throw   new   IllegalArgumentException (  \" padBottom   cannot   be   null .  \"  )  ;", "this . padBottom    =    padBottom ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . padBottom    =    new   Value . Fixed ( padBottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( padLeft    =  =    null )", "throw   new   IllegalArgumentException (  \" padLeft   cannot   be   null .  \"  )  ;", "this . padLeft    =    padLeft ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . padLeft    =    new   Value . Fixed ( padLeft )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( padRight    =  =    null )", "throw   new   IllegalArgumentException (  \" padRight   cannot   be   null .  \"  )  ;", "this . padRight    =    padRight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . padRight    =    new   Value . Fixed ( padRight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( padTop    =  =    null )", "throw   new   IllegalArgumentException (  \" padTop   cannot   be   null .  \"  )  ;", "this . padTop    =    padTop ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . padTop    =    new   Value . Fixed ( padTop )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( prefHeight    =  =    null )", "throw   new   IllegalArgumentException (  \" prefHeight   cannot   be   null .  \"  )  ;", "this . prefHeight    =    prefHeight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . prefHeight    =    new   Value . Fixed ( prefHeight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentException (  \" size   cannot   be   null .  \"  )  ;", "prefWidth    =    size ;", "prefHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentException (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentException (  \" height   cannot   be   null .  \"  )  ;", "prefWidth    =    width ;", "prefHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "prefSize ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "prefSize ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( prefWidth    =  =    null )", "throw   new   IllegalArgumentException (  \" prefWidth   cannot   be   null .  \"  )  ;", "this . prefWidth    =    prefWidth ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . prefWidth    =    new   Value . Fixed ( prefWidth )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "actor    =    null ;", "table    =    null ;", "endRow    =    false ;", "cellAboveIndex    =     -  1  ;", "defaults    =     . defaults (  )  ;", "if    ( defaults    !  =    null )", "set ( defaults )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    (  ( align )     =  =    null )", "align    =    Cell . righti ;", "else", "align    =     (  ( align )     |     ( utils . Align . right )  )     &     (  ~  ( utils . Align . left )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "table . row (  )  ;", "}", "METHOD_END"], "methodName": ["row"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "minWidth    =    cell . minWidth ;", "minHeight    =    cell . minHeight ;", "prefWidth    =    cell . prefWidth ;", "prefHeight    =    cell . prefHeight ;", "maxWidth    =    cell . maxWidth ;", "maxHeight    =    cell . maxHeight ;", "spaceTop    =    cell . spaceTop ;", "spaceLeft    =    cell . spaceLeft ;", "spaceBottom    =    cell . spaceBottom ;", "spaceRight    =    cell . spaceRight ;", "padTop    =    cell . padTop ;", "padLeft    =    cell . padLeft ;", "padBottom    =    cell . padBottom ;", "padRight    =    cell . padRight ;", "fillX    =    cell . fillX ;", "fillY    =    cell . fillY ;", "align    =    cell . align ;", "expandX    =    cell . expandX ;", "expandY    =    cell . expandY ;", "colspan    =    cell . colspan ;", "uniformX    =    cell . uniformX ;", "uniformY    =    cell . uniformY ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor )     !  =    newActor )     {", "if    (  ( actor )     !  =    null )", "actor . remove (  )  ;", "actor    =    newActor ;", "if    ( newActor    !  =    null )", "table . addActor ( newActor )  ;", "}", "return    (  (  < A >  )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "actorX    =    x ;", "actorY    =    y ;", "actorWidth    =    width ;", "actorHeight    =    height ;", "}", "METHOD_END"], "methodName": ["setActorBounds"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . actorHeight    =    actorHeight ;", "}", "METHOD_END"], "methodName": ["setActorHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . actorWidth    =    actorWidth ;", "}", "METHOD_END"], "methodName": ["setActorWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . actorX    =    actorX ;", "}", "METHOD_END"], "methodName": ["setActorX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . actorY    =    actorY ;", "}", "METHOD_END"], "methodName": ["setActorY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "this . table    =    table ;", "}", "METHOD_END"], "methodName": ["setLayout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentException (  \" size   cannot   be   null .  \"  )  ;", "minWidth    =    size ;", "minHeight    =    size ;", "prefWidth    =    size ;", "prefHeight    =    size ;", "maxWidth    =    size ;", "maxHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentException (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentException (  \" height   cannot   be   null .  \"  )  ;", "minWidth    =    width ;", "minHeight    =    height ;", "prefWidth    =    width ;", "prefHeight    =    height ;", "maxWidth    =    width ;", "maxHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "size ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "size ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( space    =  =    null )", "throw   new   IllegalArgumentException (  \" space   cannot   be   null .  \"  )  ;", "spaceTop    =    space ;", "spaceLeft    =    space ;", "spaceBottom    =    space ;", "spaceRight    =    space ;", "return   this ;", "}", "METHOD_END"], "methodName": ["space"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( top    =  =    null )", "throw   new   IllegalArgumentException (  \" top   cannot   be   null .  \"  )  ;", "if    ( left    =  =    null )", "throw   new   IllegalArgumentException (  \" left   cannot   be   null .  \"  )  ;", "if    ( bottom    =  =    null )", "throw   new   IllegalArgumentException (  \" bottom   cannot   be   null .  \"  )  ;", "if    ( right    =  =    null )", "throw   new   IllegalArgumentException (  \" right   cannot   be   null .  \"  )  ;", "spaceTop    =    top ;", "spaceLeft    =    left ;", "spaceBottom    =    bottom ;", "spaceRight    =    right ;", "return   this ;", "}", "METHOD_END"], "methodName": ["space"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( space    <     0  )", "throw   new   IllegalArgumentException (  \" space   cannot   be    <     0  .  \"  )  ;", "space ( new   Value . Fixed ( space )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["space"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( top    <     0  )", "throw   new   IllegalArgumentExption (  \" top   cannot   be    <     0  .  \"  )  ;", "if    ( left    <     0  )", "throw   new   IllegalArgumentExption (  \" left   cannot   be    <     0  .  \"  )  ;", "if    ( bottom    <     0  )", "throw   new   IllegalArgumentExption (  \" bottom   cannot   be    <     0  .  \"  )  ;", "if    ( right    <     0  )", "throw   new   IllegalArgumentExption (  \" right   cannot   be    <     0  .  \"  )  ;", "spa ( new   Value . Fixed ( top )  ,    new   Value . Fixed ( left )  ,    new   Value . Fixed ( bottom )  ,    new   Value . Fixed ( right )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["space"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceBottom    =  =    null )", "throw   new   IllegalArgumentException (  \" spaceBottom   cannot   be   null .  \"  )  ;", "thipaceBottom    =    spaceBottom ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceBottom    <     0  )", "throw   new   IllegalArgumentException (  \" spaceBottom   cannot   be    <     0  .  \"  )  ;", "thipaceBottom    =    new   Value . Fixed ( spaceBottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceLeft    =  =    null )", "throw   new   IllegalArgumentException (  \" spaceLeft   cannot   be   null .  \"  )  ;", "thipaceLeft    =    spaceLeft ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceLeft    <     0  )", "throw   new   IllegalArgumentException (  \" spaceLeft   cannot   be    <     0  .  \"  )  ;", "thipaceLeft    =    new   Value . Fixed ( spaceLeft )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceRight    =  =    null )", "throw   new   IllegalArgumentException (  \" spaceRight   cannot   be   null .  \"  )  ;", "thipaceRight    =    spaceRight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceRight    <     0  )", "throw   new   IllegalArgumentException (  \" spaceRight   cannot   be    <     0  .  \"  )  ;", "thipaceRight    =    new   Value . Fixed ( spaceRight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceTop    =  =    null )", "throw   new   IllegalArgumentException (  \" spaceTop   cannot   be   null .  \"  )  ;", "thipaceTop    =    spaceTop ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( spaceTop    <     0  )", "throw   new   IllegalArgumentException (  \" spaceTop   cannot   be    <     0  .  \"  )  ;", "thipaceTop    =    new   Value . Fixed ( spaceTop )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["spaceTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "return    ( actor )     !  =    null    ?    actor . toString (  )     :    super . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    (  ( align )     =  =    null )", "align    =    Cell . topi ;", "else", "align    =     (  ( align )     |     ( utils . Align . top )  )     &     (  ~  ( utils . Align . bottom )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["top"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "uniformX    =    Boolean . TRUE ;", "uniformY    =    Boolean . TRUE ;", "return   this ;", "}", "METHOD_END"], "methodName": ["uniform"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "uniformX    =    x ;", "uniformY    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["uniform"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "uniformX    =    Boolean . TRUE ;", "return   this ;", "}", "METHOD_END"], "methodName": ["uniformX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "uniformY    =    Boolean . TRUE ;", "return   this ;", "}", "METHOD_END"], "methodName": ["uniformY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentException (  \" width   cannot   be   null .  \"  )  ;", "minWidth    =    width ;", "prefWidth    =    width ;", "maxWidth    =    width ;", "return   this ;", "}", "METHOD_END"], "methodName": ["width"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "width ( new   Value . Fixed ( width )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["width"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Cell"}, {"methodBody": ["METHOD_START", "{", "Drawable   checkbox    =    null ;", "if    ( isDisabled (  )  )     {", "if    (  ( ised )     &  &     (  ( style . checkboxOnDisabled )     !  =    null )  )", "checkbox    =    style . checkboxOnDisabled ;", "else", "checkbox    =    style . checkboxOffDisabled ;", "}", "if    ( checkbox    =  =    null )     {", "boolean   over    =     ( isOver (  )  )     &  &     (  !  ( isDisabled (  )  )  )  ;", "if    (  ( ised )     &  &     (  ( style . checkboxOn )     !  =    null )  )", "checkbox    =     ( over    &  &     (  ( style . checkboxOnOver )     !  =    null )  )     ?    style . checkboxOnOver    :    style . checkboxOn ;", "else", "if    ( over    &  &     (  ( style . checkboxOver )     !  =    null )  )", "checkbox    =    style . checkboxOver ;", "else", "checkbox    =    style . checkboxOff ;", "}", "image . setDrawable ( checkbox )  ;", "super . draw ( batch ,    a )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.CheckBox"}, {"methodBody": ["METHOD_START", "{", "return   image ;", "}", "METHOD_END"], "methodName": ["getImage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.CheckBox"}, {"methodBody": ["METHOD_START", "{", "return   imageCell ;", "}", "METHOD_END"], "methodName": ["getImageCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.CheckBox"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.CheckBox"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( style   instanceof   CheckBox . CheckBoxStyle )  )", "throw   new   IllegalArgumentException (  \" style   must   be   a   CheckBoxStyle .  \"  )  ;", "super . setStyle ( style )  ;", "this . style    =     (  ( CheckBox . CheckBoxStyle )     ( style )  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.CheckBox"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   Container # setActor .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   Container # setActor .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorAfter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   Container # setActor .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorAt"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   Container # setActor .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorBefore"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . align    =    align ;", "return   this ;", "}", "METHOD_END"], "methodName": ["align"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "setBackground ( background )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["background"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . bottom ;", "align    &  =     ~  ( Align . top )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "align    =    Align . center ;", "return   this ;", "}", "METHOD_END"], "methodName": ["center"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "if    ( isTransform (  )  )     {", "applyTransform ( batch ,    puteTransform (  )  )  ;", "drawBackground ( batch ,    a ,     0  ,     0  )  ;", "if    ( clip )     {", "batch . flush (  )  ;", "float   padLeft    =    this . padLeft . get ( this )  ;", "float   padBottom    =    this . padBottom . get ( this )  ;", "if    ( clipBegin ( padLeft ,    padBottom ,     (  (  ( getWidth (  )  )     -    padLeft )     -     ( padRight . get ( this )  )  )  ,     (  (  ( getHeight (  )  )     -    padBottom )     -     ( padTop . get ( this )  )  )  )  )     {", "drawChildren ( batch ,    a )  ;", "batch . flush (  )  ;", "clipEnd (  )  ;", "}", "} else", "drawChildren ( batch ,    a )  ;", "resetTransform ( batch )  ;", "} else    {", "drawBackground ( batch ,    a ,    getX (  )  ,    getY (  )  )  ;", "super . draw ( batch ,    a )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    (  ( background )     =  =    null )", "return ;", "Color   color    =    getColor (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,     (  ( color . a )     *    a )  )  ;", "background . draw ( batch ,    x ,    y ,    getWidth (  )  ,    getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "if    ( isTransform (  )  )     {", "applyTransform ( shapes ,    puteTransform (  )  )  ;", "if    ( clip )     {", "shapes . flush (  )  ;", "float   padLeft    =    this . padLeft . get ( this )  ;", "float   padBottom    =    this . padBottom . get ( this )  ;", "boolean   draw    =     (  ( background )     =  =    null )     ?    clipBegin (  0  ,     0  ,    getWidth (  )  ,    getHeight (  )  )     :    clipBegin ( padLeft ,    padBottom ,     (  (  ( getWidth (  )  )     -    padLeft )     -     ( padRight . get ( this )  )  )  ,     (  (  ( getHeight (  )  )     -    padBottom )     -     ( padTop . get ( this )  )  )  )  ;", "if    ( draw )     {", "drawDebugChildren ( shapes )  ;", "clipEnd (  )  ;", "}", "} else", "drawDebugChildren ( shapes )  ;", "resetTransform ( shapes )  ;", "} else", "super . drawDebug ( shapes )  ;", "}", "METHOD_END"], "methodName": ["drawDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "fillX    =     1  .  0 F ;", "fillY    =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "fillX    =     ( fill )     ?     1  .  0 F    :     0  ;", "fillY    =     ( fill )     ?     1  .  0 F    :     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "fillX    =     ( x )     ?     1  .  0 F    :     0  ;", "fillY    =     ( y )     ?     1  .  0 F    :     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "fillX    =    x ;", "fillY    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "fillX    =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fillX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "fillY    =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fillY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   actor ;", "}", "METHOD_END"], "methodName": ["getActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   align ;", "}", "METHOD_END"], "methodName": ["getAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   background ;", "}", "METHOD_END"], "methodName": ["getBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   clip ;", "}", "METHOD_END"], "methodName": ["getClip"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   fillX ;", "}", "METHOD_END"], "methodName": ["getFillX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   fillY ;", "}", "METHOD_END"], "methodName": ["getFillY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "float   v    =    maxHeight . get ( actor )  ;", "if    ( v    >     0  )", "v    +  =     ( padTop . get ( this )  )     +     ( padBottget ( this )  )  ;", "return   v ;", "}", "METHOD_END"], "methodName": ["getMaxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   maxHeight ;", "}", "METHOD_END"], "methodName": ["getMaxHeightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "float   v    =    maxWidth . get ( actor )  ;", "if    ( v    >     0  )", "v    +  =     ( padLeft . get ( this )  )     +     ( padRight . get ( this )  )  ;", "return   v ;", "}", "METHOD_END"], "methodName": ["getMaxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   maxWidth ;", "}", "METHOD_END"], "methodName": ["getMaxWidthValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return    (  ( minHeight . get ( actor )  )     +     ( padTop . get ( this )  )  )     +     ( padBottom . get ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   minHeight ;", "}", "METHOD_END"], "methodName": ["getMinHeightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return    (  ( minWidth . get ( actor )  )     +     ( padLeft . get ( this )  )  )     +     ( padRight . get ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padBottom . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padBottom ;", "}", "METHOD_END"], "methodName": ["getPadBottomValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padLeft . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padLeft ;", "}", "METHOD_END"], "methodName": ["getPadLeftValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padRight . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padRight ;", "}", "METHOD_END"], "methodName": ["getPadRightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padTop . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   padTop ;", "}", "METHOD_END"], "methodName": ["getPadTopValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return    ( padLeft . get ( this )  )     +     ( padRight . get ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getPadX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return    ( padTop . get ( this )  )     +     ( padBottom . get ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getPadY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "float   v    =    prefHeight . get ( actor )  ;", "if    (  ( background )     !  =    null )", "v    =    Math . max ( v ,    background . getMinHeight (  )  )  ;", "return   Math . max ( getMinHeight (  )  ,     (  ( v    +     ( padTop . get ( this )  )  )     +     ( padBottget ( this )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "float   v    =    prefWidth . get ( actor )  ;", "if    (  ( background )     !  =    null )", "v    =    Math . max ( v ,    background . getMinWidth (  )  )  ;", "return   Math . max ( getMinWidth (  )  ,     (  ( v    +     ( padLeft . get ( this )  )  )     +     ( padRight . get ( this )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidthValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( height    =  =    null )", "throw   new   IllegalArgumentExption (  \" height   cannot   be   null .  \"  )  ;", "minHeight    =    height ;", "prefHeight    =    height ;", "maxHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["height"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "height ( new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["height"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( clip )     {", "if    ( touchable    &  &     (  ( getTouchable (  )  )     =  =     ( Touchable . disabled )  )  )", "return   null ;", "if    (  (  (  ( x    <     0  )     |  |     ( x    >  =     ( getWidth (  )  )  )  )     |  |     ( y    <     0  )  )     |  |     ( y    >  =     ( getHeight (  )  )  )  )", "return   null ;", "}", "return   sup . hit ( x ,    y ,    touchable )  ;", "}", "METHOD_END"], "methodName": ["hit"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor )     =  =    null )", "return ;", "float   padLeft    =    this . padLeft . get ( this )  ;", "float   padBottom    =    this . padBottom . get ( this )  ;", "float   cWidth    =     (  ( getWidth (  )  )     -    padLeft )     -     ( padRight . get ( this )  )  ;", "float   cHeight    =     (  ( getHeight (  )  )     -    padBottom )     -     ( padTop . get ( this )  )  ;", "float   minWidth    =    this . minWidth . get ( actor )  ;", "float   minHeight    =    this . minHeight . get ( actor )  ;", "float   prefWidth    =    this . prefWidth . get ( actor )  ;", "float   prefHeight    =    this . prefHeight . get ( actor )  ;", "float   maxWidth    =    this . maxWidth . get ( actor )  ;", "float   maxHeight    =    this . maxHeight . get ( actor )  ;", "float   width ;", "if    (  ( fillX )     >     0  )", "width    =    cWidth    *     ( fillX )  ;", "else", "width    =    Math . min ( prefWidth ,    cWidth )  ;", "if    ( width    <    minWidth )", "width    =    minWidth ;", "if    (  ( maxWidth    >     0  )     &  &     ( width    >    maxWidth )  )", "width    =    maxWidth ;", "float   height ;", "if    (  ( fillY )     >     0  )", "height    =    cHeight    *     ( fillY )  ;", "else", "height    =    Math . min ( prefHeight ,    cHeight )  ;", "if    ( height    <    minHeight )", "height    =    minHeight ;", "if    (  ( maxHeight    >     0  )     &  &     ( height    >    maxHeight )  )", "height    =    maxHeight ;", "float   x    =    padLeft ;", "if    (  (  ( align )     &     ( Align . right )  )     !  =     0  )", "x    +  =    cWidth    -    width ;", "else", "if    (  (  ( align )     &     ( Align . left )  )     =  =     0  )", "x    +  =     ( cWidth    -    width )     /     2  ;", "float   y    =    padBottom ;", "if    (  (  ( align )     &     ( Align . top )  )     !  =     0  )", "y    +  =    cHeight    -    height ;", "else", "if    (  (  ( align )     &     ( Align . bottom )  )     =  =     0  )", "y    +  =     ( cHeight    -    height )     /     2  ;", "if    ( round )     {", "x    =    Math . round ( x )  ;", "y    =    Math . round ( y )  ;", "width    =    Math . round ( width )  ;", "height    =    Math . round ( height )  ;", "}", "actor . setBounds ( x ,    y ,    width ,    height )  ;", "if    (  ( actor )    instanceof   Layout )", "(  ( Layout )     ( actor )  )  . validate (  )  ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . left ;", "align    &  =     ~  ( Align . right )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( maxHeight    =  =    null )", "throw   new   IllegalArgumentExption (  \" maxHeight   cannot   be   null .  \"  )  ;", "this . maxHeight    =    maxHeight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . maxHeight    =    new   Value . Fixed ( maxHeight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentExption (  \" size   cannot   be   null .  \"  )  ;", "maxWidth    =    size ;", "maxHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentExption (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentExption (  \" height   cannot   be   null .  \"  )  ;", "maxWidth    =    width ;", "maxHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "maxSize ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "maxSize ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( maxWidth    =  =    null )", "throw   new   IllegalArgumentExption (  \" maxWidth   cannot   be   null .  \"  )  ;", "this . maxWidth    =    maxWidth ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . maxWidth    =    new   Value . Fixed ( maxWidth )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( minHeight    =  =    null )", "throw   new   IllegalArgumentException (  \" minHeight   cannot   be   null .  \"  )  ;", "this . minHeight    =    minHeight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . minHeight    =    new   Value . Fixed ( minHeight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentExption (  \" size   cannot   be   null .  \"  )  ;", "minWidth    =    size ;", "minHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentExption (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentExption (  \" height   cannot   be   null .  \"  )  ;", "minWidth    =    width ;", "minHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "minSize ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "minSize ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( minWidth    =  =    null )", "throw   new   IllegalArgumentException (  \" minWidth   cannot   be   null .  \"  )  ;", "this . minWidth    =    minWidth ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . minWidth    =    new   Value . Fixed ( minWidth )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["minWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( pad    =  =    null )", "throw   new   IllegalArgumentException (  \" pad   cannot   be   null .  \"  )  ;", "padTop    =    pad ;", "padLeft    =    pad ;", "padBottom    =    pad ;", "padRight    =    pad ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( top    =  =    null )", "throw   new   IllegalArgumentExption (  \" top   cannot   be   null .  \"  )  ;", "if    ( left    =  =    null )", "throw   new   IllegalArgumentExption (  \" left   cannot   be   null .  \"  )  ;", "if    ( bottom    =  =    null )", "throw   new   IllegalArgumentExption (  \" bottom   cannot   be   null .  \"  )  ;", "if    ( right    =  =    null )", "throw   new   IllegalArgumentExption (  \" right   cannot   be   null .  \"  )  ;", "padTop    =    top ;", "padLeft    =    left ;", "padBottom    =    bottom ;", "padRight    =    right ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "Value   value    =    new   Value . Fixed ( pad )  ;", "padTop    =    value ;", "padLeft    =    value ;", "padBottom    =    value ;", "padRight    =    value ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "padTop    =    new   Value . Fixed ( top )  ;", "padLeft    =    new   Value . Fixed ( left )  ;", "padBottom    =    new   Value . Fixed ( bottom )  ;", "padRight    =    new   Value . Fixed ( right )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( padBottom    =  =    null )", "throw   new   IllegalArgumentException (  \" padBottom   cannot   be   null .  \"  )  ;", "this . padBottom    =    padBottom ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . padBottom    =    new   Value . Fixed ( padBottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( padLeft    =  =    null )", "throw   new   IllegalArgumentException (  \" padLeft   cannot   be   null .  \"  )  ;", "this . padLeft    =    padLeft ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . padLeft    =    new   Value . Fixed ( padLeft )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( padRight    =  =    null )", "throw   new   IllegalArgumentException (  \" padRight   cannot   be   null .  \"  )  ;", "this . padRight    =    padRight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . padRight    =    new   Value . Fixed ( padRight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( padTop    =  =    null )", "throw   new   IllegalArgumentException (  \" padTop   cannot   be   null .  \"  )  ;", "this . padTop    =    padTop ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . padTop    =    new   Value . Fixed ( padTop )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( prefHeight    =  =    null )", "throw   new   IllegalArgumentExption (  \" prefHeight   cannot   be   null .  \"  )  ;", "this . prefHeight    =    prefHeight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . prefHeight    =    new   Value . Fixed ( prefHeight )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentExption (  \" size   cannot   be   null .  \"  )  ;", "prefWidth    =    size ;", "prefHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentExption (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentExption (  \" height   cannot   be   null .  \"  )  ;", "prefWidth    =    width ;", "prefHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "prefSize ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "prefSize ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( prefWidth    =  =    null )", "throw   new   IllegalArgumentExption (  \" prefWidth   cannot   be   null .  \"  )  ;", "this . prefWidth    =    prefWidth ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . prefWidth    =    new   Value . Fixed ( prefWidth )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentExption (  \" actor   cannot   be   null .  \"  )  ;", "if    ( actor    !  =     ( this . actor )  )", "return   false ;", "setActor ( null )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentExption (  \" actor   cannot   be   null .  \"  )  ;", "if    ( actor    !  =     ( this . actor )  )", "return   false ;", "this . actor    =    null ;", "return   super . removeActor ( actor ,    unfocus )  ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . right ;", "align    &  =     ~  ( Align . left )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =     ( this )  )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   the    .  \"  )  ;", "if    ( actor    =  =     ( this . actor )  )", "return ;", "if    (  ( this . actor )     !  =    null )", "super . removeActor ( this . actor )  ;", "this . actor    =    actor ;", "if    ( actor    !  =    null )", "super . addActor ( actor )  ;", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "setBackground ( background ,    true )  ;", "}", "METHOD_END"], "methodName": ["setBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . background )     =  =    background )", "return ;", "this . background    =    background ;", "if    ( adjustPadding )     {", "if    ( background    =  =    null )", "pad ( Value . zero )  ;", "else", "pad ( background . getTopHeight (  )  ,    background . getLeftWidth (  )  ,    background . getBottomHeight (  )  ,    background . getRightWidth (  )  )  ;", "invalidate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "clip    =    enabled ;", "setTransform ( enabled )  ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setClip"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "this . round    =    round ;", "}", "METHOD_END"], "methodName": ["setRound"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( size    =  =    null )", "throw   new   IllegalArgumentExption (  \" size   cannot   be   null .  \"  )  ;", "minWidth    =    size ;", "minHeight    =    size ;", "prefWidth    =    size ;", "prefHeight    =    size ;", "maxWidth    =    size ;", "maxHeight    =    size ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentExption (  \" width   cannot   be   null .  \"  )  ;", "if    ( height    =  =    null )", "throw   new   IllegalArgumentExption (  \" height   cannot   be   null .  \"  )  ;", "minWidth    =    width ;", "minHeight    =    height ;", "prefWidth    =    width ;", "prefHeight    =    height ;", "maxWidth    =    width ;", "maxHeight    =    height ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "size ( new   Value . Fixed ( size )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "size ( new   Value . Fixed ( width )  ,    new   Value . Fixed ( height )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . top ;", "align    &  =     ~  ( Alignottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["top"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =    null )", "throw   new   IllegalArgumentExption (  \" width   cannot   be   null .  \"  )  ;", "minWidth    =    width ;", "prefWidth    =    width ;", "maxWidth    =    width ;", "return   this ;", "}", "METHOD_END"], "methodName": ["width"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "width ( new   Value . Fixed ( width )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["width"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Container"}, {"methodBody": ["METHOD_START", "{", "return   button ( button ,    null )  ;", "}", "METHOD_END"], "methodName": ["button"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "buttonTable . add ( button )  ;", "setObject ( button ,    object )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["button"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "return   button ( text ,    null )  ;", "}", "METHOD_END"], "methodName": ["button"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "if    (  ( skin )     =  =    null )", "throw   new   IllegalStateException (  \" This   method   may   only   be   used   if   the   d   was   constructed   with   a   Skin .  \"  )  ;", "return   button ( text ,    object ,    skin . get ( TextButton . TextButtonStyle . class )  )  ;", "}", "METHOD_END"], "methodName": ["button"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "return   button ( new   TextButton ( text ,    buttonStyle )  ,    object )  ;", "}", "METHOD_END"], "methodName": ["button"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "cancelHide    =    true ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "return   buttonTable ;", "}", "METHOD_END"], "methodName": ["getButtonTable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "return   contentTable ;", "}", "METHOD_END"], "methodName": ["getContentTable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "hide ( Actions . fadeOut (  0  .  4 F ,    Interpolation . fade )  )  ;", "}", "METHOD_END"], "methodName": ["hide"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "Stage   stage    =    getStage (  )  ;", "if    ( stage    !  =    null )     {", "removeListener ( focusListener )  ;", "if    (  (  ( previousKeyboardFocus )     !  =    null )     &  &     (  ( previousKeyboardFocus . getStage (  )  )     =  =    null )  )", "previousKeyboardFocus    =    null ;", "Actor   actor    =    stage . getKeyboardFocus (  )  ;", "if    (  ( actor    =  =    null )     |  |     ( actor . isDedantOf ( this )  )  )", "stage . setKeyboardFocus ( previousKeyboardFocus )  ;", "if    (  (  ( previousScrollFocus )     !  =    null )     &  &     (  ( previousScrollFocus . getStage (  )  )     =  =    null )  )", "previousScrollFocus    =    null ;", "actor    =    stage . getScrollFocus (  )  ;", "if    (  ( actor    =  =    null )     |  |     ( actor . isDedantOf ( this )  )  )", "stage . setScrollFocus ( previousScrollFocus )  ;", "}", "if    ( action    !  =    null )     {", "addCaptureListener ( ignoreTouchDown )  ;", "addAction ( Actions . sequence ( action ,    Actions . removeListener ( ignoreTouchDown ,    true )  ,    Actions . removeActor (  )  )  )  ;", "} else", "remove (  )  ;", "}", "METHOD_END"], "methodName": ["hide"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "setModal ( true )  ;", "defaults (  )  . space (  6  )  ;", "add (  ( contentTable    =    new   Table ( skin )  )  )  . expand (  )  . fill (  )  ;", "row (  )  ;", "add (  ( buttonTable    =    new   Table ( skin )  )  )  . fillX (  )  ;", "contentTable . defaults (  )  . space (  6  )  ;", "buttonTable . defaults (  )  . space (  6  )  ;", "buttonTable . addListener ( new   ChangeListener (  )     {", "public   void   changed ( ChangeListener . ChangeEvent   event ,    Actor   actor )     {", "if    (  !  ( values . containsKey ( actor )  )  )", "return ;", "while    (  ( actor . getParent (  )  )     !  =     ( buttonTable )  )", "actor    =    actor . getParent (  )  ;", "result ( values . get ( actor )  )  ;", "if    (  !  ( cancelHide )  )", "hide (  )  ;", "cancelHide    =    false ;", "}", "}  )  ;", "focusListener    =    new   FocusListener (  )     {", "public   void   keyboardFocusChanged ( FocusListener . FocusEvent   event ,    Actor   actor ,    boolean   focused )     {", "if    (  ! focused )", "focusChanged ( event )  ;", "}", "public   void   scrollFocusChanged ( FocusListener . FocusEvent   event ,    Actor   actor ,    boolean   focused )     {", "if    (  ! focused )", "focusChanged ( event )  ;", "}", "private   void   focusChanged ( FocusListener . FocusEvent   event )     {", "Stage   stage    =    getStage (  )  ;", "if    (  (  (  ( isModal )     &  &     ( stage    !  =    null )  )     &  &     (  ( stage . getRoot (  )  . getChildren (  )  . size )     >     0  )  )     &  &     (  ( stage . getRoot (  )  . getChildren (  )  . peek (  )  )     =  =     (  . this )  )  )     {", "Actor   newFocusedActor    =    event . getRelatedActor (  )  ;", "if    (  (  ( newFocusedActor    !  =    null )     &  &     (  !  ( newFocusedActor . isDescendantOf (  . this )  )  )  )     &  &     (  !  (  ( newFocusedActor . equals ( previousKeyboardFocus )  )     |  |     ( newFocusedActor . equals ( previousScrollFocus )  )  )  )  )", "event . cancel (  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "addListener ( new   InputListener (  )     {", "public   boolean   keyDown ( InputEvent   event ,    int   keycode 2  )     {", "if    ( keycode    =  =    keycode 2  )     {", "Gdx . app . postRunnable ( new   Runnable (  )     {", "public   void   run (  )     {", "result ( object )  ;", "if    (  !  ( cancelHide )  )", "hide (  )  ;", "cancelHide    =    false ;", "}", "}  )  ;", "}", "return   false ;", "}", "}  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["key"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "values . put ( actor ,    object )  ;", "}", "METHOD_END"], "methodName": ["setObject"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "if    ( stage    =  =    null )", "addListr ( focusListr )  ;", "else", "removeListr ( focusListr )  ;", "super . setStage ( stage )  ;", "}", "METHOD_END"], "methodName": ["setStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "show ( stage ,    Actions . sequence ( Actions . alpha (  0  )  ,    Actions . fadeIn (  0  .  4 F ,    Interpolation . fade )  )  )  ;", "setPosition ( Math . round (  (  (  ( stage . getWidth (  )  )     -     ( getWidth (  )  )  )     /     2  )  )  ,    Math . round (  (  (  ( stage . getHeight (  )  )     -     ( getHeight (  )  )  )     /     2  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["show"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "clearActions (  )  ;", "removeCaptureListener ( ignoreTouchDown )  ;", "previousKeyboardFocus    =    null ;", "Actor   actor    =    stage . getKeyboardFocus (  )  ;", "if    (  ( actor    !  =    null )     &  &     (  !  ( actor . isDedantOf ( this )  )  )  )", "previousKeyboardFocus    =    actor ;", "previousScrollFocus    =    null ;", "actor    =    stage . getScrollFocus (  )  ;", "if    (  ( actor    !  =    null )     &  &     (  !  ( actor . isDedantOf ( this )  )  )  )", "previousScrollFocus    =    actor ;", "pack (  )  ;", "stage . addActor ( this )  ;", "stage . cancelTouchFocus (  )  ;", "stage . setKeyboardFocus ( this )  ;", "stage . setScrollFocus ( this )  ;", "if    ( action    !  =    null )", "addAction ( action )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["show"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "contentTable . add ( label )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["text"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "if    (  ( skin )     =  =    null )", "throw   new   IllegalStateException (  \" This   method   may   only   be   used   if   the   d   was   constructed   with   a   Skin .  \"  )  ;", "return   text ( text ,    skin . get ( Label . LabelStyle . class )  )  ;", "}", "METHOD_END"], "methodName": ["text"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "return   text ( new   Label ( text ,    labelStyle )  )  ;", "}", "METHOD_END"], "methodName": ["text"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Dialog"}, {"methodBody": ["METHOD_START", "{", "this . align    =    align ;", "return   this ;", "}", "METHOD_END"], "methodName": ["align"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . bottom ;", "align    &  =     ~  ( Align . top )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "align    =    Align . center ;", "return   this ;", "}", "METHOD_END"], "methodName": ["center"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "sizeInvalid    =    false ;", "SnapshotArray < Actor >    children    =    getChildren (  )  ;", "int   n    =    children . size ;", "prefHeight    =     0  ;", "if    ( wrap )     {", "prefWidth    =     0  ;", "if    (  ( rowSizes )     =  =    null )", "rowSizes    =    new   FloatArray (  )  ;", "else", "rowSizes . clear (  )  ;", "FloatArray   rowSizes    =    this . rowSizes ;", "float   space    =    this . space ;", "float   wrapSpace    =    this . wrapSpace ;", "float   pad    =     ( padLeft )     +     ( padRight )  ;", "float   gWidth    =     ( getWidth (  )  )     -    pad ;", "float   x    =     0  ;", "float   y    =     0  ;", "float   rowHeight    =     0  ;", "int   i    =     0  ;", "int   incr    =     1  ;", "if    ( reverse )     {", "i    =    n    -     1  ;", "n    =     -  1  ;", "incr    =     -  1  ;", "}", "for    (  ;    i    !  =    n ;    i    +  =    incr )     {", "Actor   child    =    children . get ( i )  ;", "float   width ;", "float   height ;", "if    ( child   instanceof   Layout )     {", "Layout   layout    =     (  ( Layout )     ( child )  )  ;", "width    =    layout . getPrefWidth (  )  ;", "height    =    layout . getPrefHeight (  )  ;", "} else    {", "width    =    child . getWidth (  )  ;", "height    =    child . getHeight (  )  ;", "}", "float   incrX    =    width    +     ( x    >     0     ?    space    :     0  )  ;", "if    (  (  ( x    +    incrX )     >    gWidth )     &  &     ( x    >     0  )  )     {", "rowSizes . add ( x )  ;", "rowSizes . add ( rowHeight )  ;", "prefWidth    =    Math . max ( prefWidth ,     ( x    +    pad )  )  ;", "if    ( y    >     0  )", "y    +  =    wrapSpace ;", "y    +  =    rowHeight ;", "rowHeight    =     0  ;", "x    =     0  ;", "incrX    =    width ;", "}", "x    +  =    incrX ;", "rowHeight    =    Math . max ( rowHeight ,    height )  ;", "}", "rowSizes . add ( x )  ;", "rowSizes . add ( rowHeight )  ;", "prefWidth    =    Math . max ( prefWidth ,     ( x    +    pad )  )  ;", "if    ( y    >     0  )", "y    +  =    wrapSpace ;", "prefHeight    =    Math . max ( prefHeight ,     ( y    +    rowHeight )  )  ;", "} else    {", "prefWidth    =     (  ( padLeft )     +     ( padRight )  )     +     (  ( space )     *     ( n    -     1  )  )  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "Actor   child    =    children . get ( i )  ;", "if    ( child   instanceof   Layout )     {", "Layout   layout    =     (  ( Layout )     ( child )  )  ;", "prefWidth    +  =    layout . getPrefWidth (  )  ;", "prefHeight    =    Math . max ( prefHeight ,    layout . getPrefHeight (  )  )  ;", "} else    {", "prefWidth    +  =    child . getWidth (  )  ;", "prefHeight    =    Math . max ( prefHeight ,    child . getHeight (  )  )  ;", "}", "}", "}", "prefHeight    +  =     ( padTop )     +     ( padBottom )  ;", "if    ( round )     {", "prefWidth    =    Math . round ( prefWidth )  ;", "prefHeight    =    Math . round ( prefHeight )  ;", "}", "}", "METHOD_END"], "methodName": ["computeSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "super . drawDebugBounds ( shapes )  ;", "if    (  !  ( getDebug (  )  )  )", "return ;", "shapet ( ShapeRenderer . ShapeType . Line )  ;", "shapetColor ( getStage (  )  . getDebugColor (  )  )  ;", "shapes . rect (  (  ( getX (  )  )     +     ( padLeft )  )  ,     (  ( getY (  )  )     +     ( padBottom )  )  ,    getOriginX (  )  ,    getOriginY (  )  ,     (  (  ( getWidth (  )  )     -     ( padLeft )  )     -     ( padRight )  )  ,     (  (  ( getHeight (  )  )     -     ( padBottom )  )     -     ( padTop )  )  ,    getScaleX (  )  ,    getScaleY (  )  ,    getRotation (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawDebugBounds"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "expand    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . expand    =    expand ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "fill    =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . fill    =    fill ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   align ;", "}", "METHOD_END"], "methodName": ["getAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   expand ;", "}", "METHOD_END"], "methodName": ["getExpand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   fill ;", "}", "METHOD_END"], "methodName": ["getFill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padBottom ;", "}", "METHOD_END"], "methodName": ["getPadBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padLeft ;", "}", "METHOD_END"], "methodName": ["getPadLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padRight ;", "}", "METHOD_END"], "methodName": ["getPadRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padTop ;", "}", "METHOD_END"], "methodName": ["getPadTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( wrap )", "return    0  ;", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   reverse ;", "}", "METHOD_END"], "methodName": ["getReverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   space ;", "}", "METHOD_END"], "methodName": ["getSpace"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   wrap ;", "}", "METHOD_END"], "methodName": ["getWrap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "return   wrapSpace ;", "}", "METHOD_END"], "methodName": ["getWrapSpace"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "expand    =    true ;", "fill    =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["grow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "super . invalidate (  )  ;", "sizeInvalid    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "if    ( wrap )     {", "layoutWrapped (  )  ;", "return ;", "}", "boolean   round    =    this . round ;", "int   align    =    this . align ;", "float   space    =    this . space ;", "float   padBottom    =    this . padBottom ;", "float   fill    =    this . fill ;", "float   rowHeight    =     (  ( expand    ?    getHeight (  )     :    prefHeight )     -     ( padTop )  )     -    padBottom ;", "float   x    =    padLeft ;", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "x    +  =     ( getWidth (  )  )     -     ( prefWidth )  ;", "else", "if    (  ( align    &     ( Align . left )  )     =  =     0  )", "x    +  =     (  ( getWidth (  )  )     -     ( prefWidth )  )     /     2  ;", "float   startY ;", "if    (  ( align    &     ( Align . bottom )  )     !  =     0  )", "startY    =    padBottom ;", "else", "if    (  ( align    &     ( Align . top )  )     !  =     0  )", "startY    =     (  ( getHeight (  )  )     -     ( padTop )  )     -    rowHeight ;", "else", "startY    =    padBottom    +     (  (  (  (  ( getHeight (  )  )     -    padBottom )     -     ( padTop )  )     -    rowHeight )     /     2  )  ;", "align    =    rowAlign ;", "SnapshotArray < Actor >    children    =    getChildren (  )  ;", "int   i    =     0  ;", "int   n    =    children . size ;", "int   incr    =     1  ;", "if    ( reverse )     {", "i    =    n    -     1  ;", "n    =     -  1  ;", "incr    =     -  1  ;", "}", "for    ( int   r    =     0  ;    i    !  =    n ;    i    +  =    incr )     {", "Actor   child    =    children . get ( i )  ;", "float   width ;", "float   height ;", "Layout   layout    =    null ;", "if    ( child   instanceof   Layout )     {", "layout    =     (  ( Layout )     ( child )  )  ;", "width    =    layout . getPrefWidth (  )  ;", "height    =    layout . getPrefHeight (  )  ;", "} else    {", "width    =    child . getWidth (  )  ;", "height    =    child . getHeight (  )  ;", "}", "if    ( fill    >     0  )", "height    =    rowHeight    *    fill ;", "if    ( layout    !  =    null )     {", "height    =    Math . max ( height ,    layout . getMinHeight (  )  )  ;", "float   maxHeight    =    layout . getMaxHeight (  )  ;", "if    (  ( maxHeight    >     0  )     &  &     ( height    >    maxHeight )  )", "height    =    maxHeight ;", "}", "float   y    =    startY ;", "if    (  ( align    &     ( Align . top )  )     !  =     0  )", "y    +  =    rowHeight    -    height ;", "else", "if    (  ( align    &     ( Align . bottom )  )     =  =     0  )", "y    +  =     ( rowHeight    -    height )     /     2  ;", "if    ( round )", "child . setBounds ( Math . round ( x )  ,    Math . round ( y )  ,    Math . round ( width )  ,    Math . round ( height )  )  ;", "else", "child . setBounds ( x ,    y ,    width ,    height )  ;", "x    +  =    width    +    space ;", "if    ( layout    !  =    null )", "layout . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "float   prefHeight    =    getPrefHeight (  )  ;", "if    ( prefHeight    !  =     ( lastPrefHeight )  )     {", "lastPrefHeight    =    prefHeight ;", "invalidateHierarchy (  )  ;", "}", "int   align    =    this . align ;", "boolean   round    =    this . round ;", "float   space    =    this . space ;", "float   padBottom    =    this . padBottom ;", "float   fill    =    this . fill ;", "float   wrapSpace    =    this . wrapSpace ;", "float   maxWidth    =     (  ( prefWidth )     -     ( padLeft )  )     -     ( padRight )  ;", "float   rowY    =    prefHeight    -     ( padTop )  ;", "float   gWidth    =    getWidth (  )  ;", "float   xStart    =    padLeft ;", "float   x    =     0  ;", "float   rowHeight    =     0  ;", "if    (  ( align    &     ( Align . top )  )     !  =     0  )", "rowY    +  =     ( getHeight (  )  )     -    prefHeight ;", "else", "if    (  ( align    &     ( Align . bottom )  )     =  =     0  )", "rowY    +  =     (  ( getHeight (  )  )     -    prefHeight )     /     2  ;", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "xStart    +  =    gWidth    -     ( prefWidth )  ;", "else", "if    (  ( align    &     ( Align . left )  )     =  =     0  )", "xStart    +  =     ( gWidth    -     ( prefWidth )  )     /     2  ;", "gWidth    -  =    padRight ;", "align    =    this . rowAlign ;", "FloatArray   rowSizes    =    this . rowSizes ;", "SnapshotArray < Actor >    children    =    getChildren (  )  ;", "int   i    =     0  ;", "int   n    =    children . size ;", "int   incr    =     1  ;", "if    ( reverse )     {", "i    =    n    -     1  ;", "n    =     -  1  ;", "incr    =     -  1  ;", "}", "for    ( int   r    =     0  ;    i    !  =    n ;    i    +  =    incr )     {", "Actor   child    =    children . get ( i )  ;", "float   width ;", "float   height ;", "Layout   layout    =    null ;", "if    ( child   instanceof   Layout )     {", "layout    =     (  ( Layout )     ( child )  )  ;", "width    =    layout . getPrefWidth (  )  ;", "height    =    layout . getPrefHeight (  )  ;", "} else    {", "width    =    child . getWidth (  )  ;", "height    =    child . getHeight (  )  ;", "}", "if    (  (  ( x    +    width )     >    gWidth )     |  |     ( r    =  =     0  )  )     {", "x    =    xStart ;", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "x    +  =    maxWidth    -     ( rowSizes . get ( r )  )  ;", "else", "if    (  ( align    &     ( Align . left )  )     =  =     0  )", "x    +  =     ( maxWidth    -     ( rowSizes . get ( r )  )  )     /     2  ;", "rowHeight    =    rowSizes . get (  ( r    +     1  )  )  ;", "if    ( r    >     0  )", "rowY    -  =    wrapSpace ;", "rowY    -  =    rowHeight ;", "r    +  =     2  ;", "}", "if    ( fill    >     0  )", "height    =    rowHeight    *    fill ;", "if    ( layout    !  =    null )     {", "height    =    Math . max ( height ,    layout . getMinHeight (  )  )  ;", "float   maxHeight    =    layout . getMaxHeight (  )  ;", "if    (  ( maxHeight    >     0  )     &  &     ( height    >    maxHeight )  )", "height    =    maxHeight ;", "}", "float   y    =    rowY ;", "if    (  ( align    &     ( Align . top )  )     !  =     0  )", "y    +  =    rowHeight    -    height ;", "else", "if    (  ( align    &     ( Align . bottom )  )     =  =     0  )", "y    +  =     ( rowHeight    -    height )     /     2  ;", "if    ( round )", "child . setBounds ( Math . round ( x )  ,    Math . round ( y )  ,    Math . round ( width )  ,    Math . round ( height )  )  ;", "else", "child . setBounds ( x ,    y ,    width ,    height )  ;", "x    +  =    width    +    space ;", "if    ( layout    !  =    null )", "layout . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["layoutWrapped"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . left ;", "align    &  =     ~  ( Align . right )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "padTop    =    pad ;", "padLeft    =    pad ;", "padBottom    =    pad ;", "padRight    =    pad ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "padTop    =    top ;", "padLeft    =    left ;", "padBottom    =    bottom ;", "padRight    =    right ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padBottom    =    padBottom ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padLeft    =    padLeft ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padRight    =    padRight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padTop    =    padTop ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . reverse    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . reverse    =    reverse ;", "return   this ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . right ;", "align    &  =     ~  ( Align . left )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . rowAlign    =    row ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rowAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "rowAlign    |  =    Align . bottom ;", "rowAlign    &  =     ~  ( Align . top )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rowBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "rowAlign    =    Align . center ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rowCenter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "rowAlign    |  =    Align . top ;", "rowAlign    &  =     ~  ( Align . bottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rowTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . round    =    round ;", "}", "METHOD_END"], "methodName": ["setRound"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . space    =    space ;", "return   this ;", "}", "METHOD_END"], "methodName": ["space"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . top ;", "align    &  =     ~  ( Align . bottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["top"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "wrap    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . wrap    =    wrap ;", "return   this ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "this . wrapSpace    =    wrapSpace ;", "return   this ;", "}", "METHOD_END"], "methodName": ["wrapSpace"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.HorizontalGroup"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "Color   color    =    getColor (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,     (  ( color . a )     *    a )  )  ;", "float   x    =    getX (  )  ;", "float   y    =    getY (  )  ;", "float   scaleX    =    getScaleX (  )  ;", "float   scaleY    =    getScaleY (  )  ;", "if    (  ( drawable )    instanceof   TransformDrawable )     {", "float   rotation    =    getRotation (  )  ;", "if    (  (  ( scaleX    !  =     1  )     |  |     ( scaleY    !  =     1  )  )     |  |     ( rotation    !  =     0  )  )     {", "(  ( TransformDrawable )     ( drawable )  )  . draw ( batch ,     ( x    +     ( iX )  )  ,     ( y    +     ( iY )  )  ,     (  ( getOriginX (  )  )     -     ( iX )  )  ,     (  ( getOriginY (  )  )     -     ( iY )  )  ,    iWidth ,    iHeight ,    scaleX ,    scaleY ,    rotation )  ;", "return ;", "}", "}", "if    (  ( drawable )     !  =    null )", "drawable . draw ( batch ,     ( x    +     ( iX )  )  ,     ( y    +     ( iY )  )  ,     (  ( iWidth )     *    scaleX )  ,     (  ( iHeight )     *    scaleY )  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "return   drawable ;", "}", "METHOD_END"], "methodName": ["getDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "return   imageHeight ;", "}", "METHOD_END"], "methodName": ["getImageHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "return   imageWidth ;", "}", "METHOD_END"], "methodName": ["getImageWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "return   imageX ;", "}", "METHOD_END"], "methodName": ["getImageX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "return   imageY ;", "}", "METHOD_END"], "methodName": ["getImageY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "if    (  ( drawable )     !  =    null )", "return   drawableetMinHeht (  )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "if    (  ( drawable )     !  =    null )", "return   drawableetMinWidth (  )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "if    (  ( drawable )     =  =    null )", "return ;", "float   regionWidth    =    drawable . getMinWidth (  )  ;", "float   regionHeight    =    drawable . getMinHeight (  )  ;", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "Vector 2    size    =    scaling . apply ( regionWidth ,    regionHeight ,    width ,    height )  ;", "iWidth    =    size . x ;", "iHeight    =    size . y ;", "if    (  (  ( align )     &     ( Align . left )  )     !  =     0  )", "iX    =     0  ;", "else", "if    (  (  ( align )     &     ( Align . right )  )     !  =     0  )", "iX    =     (  ( int )     ( width    -     ( iWidth )  )  )  ;", "else", "iX    =     (  ( int )     (  ( width    /     2  )     -     (  ( iWidth )     /     2  )  )  )  ;", "if    (  (  ( align )     &     ( Align . top )  )     !  =     0  )", "iY    =     (  ( int )     ( height    -     ( iHeight )  )  )  ;", "else", "if    (  (  ( align )     &     ( Align . bottom )  )     !  =     0  )", "iY    =     0  ;", "else", "iY    =     (  ( int )     (  ( height    /     2  )     -     (  ( iHeight )     /     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "this . align    =    align ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "setDrawable ( skin . getDrawable ( drawableName )  )  ;", "}", "METHOD_END"], "methodName": ["setDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . drawable )     =  =    drawable )", "return ;", "if    ( drawable    !  =    null )     {", "if    (  (  ( getPrefWidth (  )  )     !  =     ( drawable . getMinWidth (  )  )  )     |  |     (  ( getPrefHeight (  )  )     !  =     ( drawable . getMinHeight (  )  )  )  )", "invalidateHierarchy (  )  ;", "} else", "invalidateHierarchy (  )  ;", "this . drawable    =    drawable ;", "}", "METHOD_END"], "methodName": ["setDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "if    ( scaling    =  =    null )", "throw   new   IllegalArgumentException (  \" scaling   cannot   be   null .  \"  )  ;", "thialing    =    scaling ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setScaling"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Image"}, {"methodBody": ["METHOD_START", "{", "updateImage (  )  ;", "super . draw ( batch ,    a )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageButton"}, {"methodBody": ["METHOD_START", "{", "return   image ;", "}", "METHOD_END"], "methodName": ["getImage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageButton"}, {"methodBody": ["METHOD_START", "{", "return   getCell ( image )  ;", "}", "METHOD_END"], "methodName": ["getImageCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageButton"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageButton"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( style   instanceof   ImageButton . ImageButtonStyle )  )", "throw   new   IllegalArgumentException (  \" style   must   be   an   ImageButtonStyle .  \"  )  ;", "super . setStyle ( style )  ;", "this . style    =     (  ( ImageButton . ImageButtonStyle )     ( style )  )  ;", "if    (  ( image )     !  =    null )", "updateImage (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageButton"}, {"methodBody": ["METHOD_START", "{", "Drawable   drawable    =    null ;", "if    (  ( isDisabled (  )  )     &  &     (  ( style . iDisabled )     !  =    null )  )", "drawable    =    style . iDisabled ;", "else", "if    (  ( isPressed (  )  )     &  &     (  ( style . iDown )     !  =    null )  )", "drawable    =    style . iDown ;", "else", "if    (  ( isChecked )     &  &     (  ( style . iChecked )     !  =    null )  )", "drawable    =     (  (  ( style . iCheckedOver )     !  =    null )     &  &     ( isOver (  )  )  )     ?    style . iCheckedOver    :    style . iChecked ;", "else", "if    (  ( isOver (  )  )     &  &     (  ( style . iOver )     !  =    null )  )", "drawable    =    style . iOver ;", "else", "if    (  ( style . iUp )     !  =    null )", "drawable    =    style . iUp ;", "i . setDrawable ( drawable )  ;", "}", "METHOD_END"], "methodName": ["updateImage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageButton"}, {"methodBody": ["METHOD_START", "{", "updateImage (  )  ;", "Color   fontColor ;", "if    (  ( isDisabled (  )  )     &  &     (  ( style . disabledFontColor )     !  =    null )  )", "fontColor    =    style . disabledFontColor ;", "else", "if    (  ( isPressed (  )  )     &  &     (  ( style . downFontColor )     !  =    null )  )", "fontColor    =    style . downFontColor ;", "else", "if    (  ( isChecked )     &  &     (  ( style . checkedFontColor )     !  =    null )  )", "fontColor    =     (  ( isOver (  )  )     &  &     (  ( style . checkedOverFontColor )     !  =    null )  )     ?    style . checkedOverFontColor    :    style . checkedFontColor ;", "else", "if    (  ( isOver (  )  )     &  &     (  ( style . overFontColor )     !  =    null )  )", "fontColor    =    style . overFontColor ;", "else", "fontColor    =    style . fontColor ;", "if    ( fontColor    !  =    null )", "label . getStyle (  )  . fontColor    =    fontColor ;", "super . draw ( batch ,    a )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "return   image ;", "}", "METHOD_END"], "methodName": ["getImage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "return   getCell ( image )  ;", "}", "METHOD_END"], "methodName": ["getImageCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "return   label ;", "}", "METHOD_END"], "methodName": ["getLabel"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "return   getCell ( label )  ;", "}", "METHOD_END"], "methodName": ["getLabelCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "return   label . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( style   instanceof   ImageTextButton . ImageTextButtonStyle )  )", "throw   new   IllegalArgumentException (  \" style   must   be   a   ImageTextButtonStyle .  \"  )  ;", "super . setStyle ( style )  ;", "this . style    =     (  ( ImageTextButton . ImageTextButtonStyle )     ( style )  )  ;", "if    (  ( image )     !  =    null )", "updateImage (  )  ;", "if    (  ( label )     !  =    null )     {", "ImageTextButton . ImageTextButtonStyle   textButtonStyle    =     (  ( ImageTextButton . ImageTextButtonStyle )     ( style )  )  ;", "Label . LabelStyle   labelStyle    =    label . getStyle (  )  ;", "labelStyle . font    =    textButtonStyle . font ;", "labelStyle . fontColor    =    textButtonStyle . fontColor ;", "label . setStyle ( labelStyle )  ;", "}", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "label . setText ( text )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "Drawable   drawable    =    null ;", "if    (  ( isDisabled (  )  )     &  &     (  ( style . iDisabled )     !  =    null )  )", "drawable    =    style . iDisabled ;", "else", "if    (  ( isPressed (  )  )     &  &     (  ( style . iDown )     !  =    null )  )", "drawable    =    style . iDown ;", "else", "if    (  ( isChecked )     &  &     (  ( style . iChecked )     !  =    null )  )", "drawable    =     (  (  ( style . iCheckedOver )     !  =    null )     &  &     ( isOver (  )  )  )     ?    style . iCheckedOver    :    style . iChecked ;", "else", "if    (  ( isOver (  )  )     &  &     (  ( style . iOver )     !  =    null )  )", "drawable    =    style . iOver ;", "else", "if    (  ( style . iUp )     !  =    null )", "drawable    =    style . iUp ;", "i . setDrawable ( drawable )  ;", "}", "METHOD_END"], "methodName": ["updateImage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton"}, {"methodBody": ["METHOD_START", "{", "prefSizeInvalid    =    false ;", "GlyphLayout   prefSizeLayout    =     . prefSizeLayout ;", "if    (  ( wrap )     &  &     (  ( ellipsis )     =  =    null )  )     {", "float   width    =    getWidth (  )  ;", "if    (  ( style . background )     !  =    null )", "width    -  =     ( style . background . getLeftWidth (  )  )     +     ( style . background . getRightWidth (  )  )  ;", "prefSizeLayout . setText ( cache . getFont (  )  ,    text ,    Color . WHITE ,    width ,    Align . left ,    true )  ;", "} else", "prefSizeLayout . setText ( cache . getFont (  )  ,    text )  ;", "prefSize . set ( prefSizeLayout . width ,    prefSizeLayout . height )  ;", "}", "METHOD_END"], "methodName": ["computePrefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "Color   color    =     . tempColor . set ( getColor (  )  )  ;", "color . a    *  =    a ;", "if    (  ( style . background )     !  =    null )     {", "batch . setColor ( color . r ,    color . g ,    color . b ,    color . a )  ;", "style . background . draw ( batch ,    getX (  )  ,    getY (  )  ,    getWidth (  )  ,    getHeight (  )  )  ;", "}", "if    (  ( style . fontColor )     !  =    null )", "color . mul ( style . fontColor )  ;", "cache . tint ( color )  ;", "cache . setPosition ( getX (  )  ,    getY (  )  )  ;", "cache . draw ( batch )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   cache ;", "}", "METHOD_END"], "methodName": ["getBitmapFontCache"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   fontScaleX ;", "}", "METHOD_END"], "methodName": ["getFontScaleX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   fontScaleY ;", "}", "METHOD_END"], "methodName": ["getFontScaleY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   layout ;", "}", "METHOD_END"], "methodName": ["getGlyphLayout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   labelAlign ;", "}", "METHOD_END"], "methodName": ["getLabelAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   lineAlign ;", "}", "METHOD_END"], "methodName": ["getLineAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "if    ( prefSizeInvalid )", "scaleAndComputePrefSize (  )  ;", "float   detScaleCorrection    =     1  ;", "if    ( fontScaleChanged )", "detScaleCorrection    =     ( fontScaleY )     /     ( style . font . getScaleY (  )  )  ;", "float   height    =     ( prefSize . y )     -     (  (  ( style . font . getDet (  )  )     *    detScaleCorrection )     *     2  )  ;", "Drawable   background    =    style . background ;", "if    ( background    !  =    null )", "height    +  =     ( background . getTopHeight (  )  )     +     ( background . getBottomHeight (  )  )  ;", "return   height ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "if    ( wrap )", "return    0  ;", "if    ( prefSizeInvalid )", "scaleAndComputePrefSize (  )  ;", "float   width    =    prefSize . x ;", "Drawableckground    =    styleckground ;", "if   ckground    !  =    null )", "width    +  =    ckground . getLeftWidth (  )  )     +    ckground . getRightWidth (  )  )  ;", "return   width ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return   text ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "super . invalidate (  )  ;", "prefSizeInvalid    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "BitmapFont   font    =    cache . getFont (  )  ;", "float   oldScaleX    =    font . getScaleX (  )  ;", "float   oldScaleY    =    font . getScaleY (  )  ;", "if    ( fontScaleChanged )", "font . getData (  )  . setScale ( fontScaleX ,    fontScaleY )  ;", "boolean   wrap    =     ( this . wrap )     &  &     (  ( ellipsis )     =  =    null )  ;", "if    ( wrap )     {", "float   prefHeight    =    getPrefHeight (  )  ;", "if    ( prefHeight    !  =     ( lastPrefHeight )  )     {", "lastPrefHeight    =    prefHeight ;", "invalidateHierarchy (  )  ;", "}", "}", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "Drawable   background    =    style . background ;", "float   x    =     0  ;", "float   y    =     0  ;", "if    ( background    !  =    null )     {", "x    =    background . getLeftWidth (  )  ;", "y    =    background . getBottomHeight (  )  ;", "width    -  =     ( background . getLeftWidth (  )  )     +     ( background . getRightWidth (  )  )  ;", "height    -  =     ( background . getBottomHeight (  )  )     +     ( background . getTopHeight (  )  )  ;", "}", "GlyphLayout   layout    =    this . layout ;", "float   textWidth ;", "float   textHeight ;", "if    ( wrap    |  |     (  ( text . indexOf (  \"  \\ n \"  )  )     !  =     (  -  1  )  )  )     {", "layout . setText ( font ,    text ,     0  ,    text . length ,    Color . WHITE ,    width ,    lineAlign ,    wrap ,    ellipsis )  ;", "textWidth    =    layout . width ;", "textHeight    =    layout . height ;", "if    (  (  ( lAlign )     &     ( Align . left )  )     =  =     0  )     {", "if    (  (  ( lAlign )     &     ( Align . right )  )     !  =     0  )", "x    +  =    width    -    textWidth ;", "else", "x    +  =     ( width    -    textWidth )     /     2  ;", "}", "} else    {", "textWidth    =    width ;", "textHeight    =    font . getData (  )  . capHeight ;", "}", "if    (  (  ( lAlign )     &     ( Align . top )  )     !  =     0  )     {", "y    +  =     ( cache . getFont (  )  . isFlipped (  )  )     ?     0     :    height    -    textHeight ;", "y    +  =    style . font . getDescent (  )  ;", "} else", "if    (  (  ( lAlign )     &     ( Align . bottom )  )     !  =     0  )     {", "y    +  =     ( cache . getFont (  )  . isFlipped (  )  )     ?    height    -    textHeight    :     0  ;", "y    -  =    style . font . getDescent (  )  ;", "} else    {", "y    +  =     ( height    -    textHeight )     /     2  ;", "}", "if    (  !  ( cache . getFont (  )  . isFlipped (  )  )  )", "y    +  =    textHeight ;", "layout . setText ( font ,    text ,     0  ,    text . length ,    Color . WHITE ,    textWidth ,    lineAlign ,    wrap ,    ellipsis )  ;", "cache . setText ( layout ,    x ,    y )  ;", "if    ( fontScaleChanged )", "font . getData (  )  . setScale ( oldScaleX ,    oldScaleY )  ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "BitmapFont   font    =    cache . getFont (  )  ;", "float   oldScaleX    =    font . getScaleX (  )  ;", "float   oldScaleY    =    font . getScaleY (  )  ;", "if    ( fontScaleChanged )", "font . getData (  )  . setScale ( fontScaleX ,    fontScaleY )  ;", "putePrefSize (  )  ;", "if    ( fontScaleChanged )", "font . getData (  )  . setScale ( oldScaleX ,    oldScaleY )  ;", "}", "METHOD_END"], "methodName": ["scaleAndComputePrefSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "setAlignment ( alignment ,    alignment )  ;", "}", "METHOD_END"], "methodName": ["setAlignment"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "this . labelAlign    =    labelAlign ;", "if    (  ( lineAlign    &     ( Align . left )  )     !  =     0  )", "this . lineAlign    =    Align . left ;", "else", "if    (  ( lineAlign    &     ( Align . right )  )     !  =     0  )", "this . lineAlign    =    Align . right ;", "else", "this . lineAlign    =    Align . center ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setAlignment"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "if    ( ellipsis )", "this . ellipsis    =     \"  .  .  .  \"  ;", "else", "this . ellipsis    =    null ;", "}", "METHOD_END"], "methodName": ["setEllipsis"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "this . ellipsis    =    ellipsis ;", "}", "METHOD_END"], "methodName": ["setEllipsis"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "setFontScale ( fontScale ,    fontScale )  ;", "}", "METHOD_END"], "methodName": ["setFontScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "fontScaleChanged    =    true ;", "thifontScaleX    =    fontScaleX ;", "thifontScaleY    =    fontScaleY ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setFontScale"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "setFontScale ( fontScaleX ,    fontScaleY )  ;", "}", "METHOD_END"], "methodName": ["setFontScaleX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "setFontScale ( fontScaleX ,    fontScaleY )  ;", "}", "METHOD_END"], "methodName": ["setFontScaleY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "if    (  ( style . font )     =  =    null )", "throw   new   IllegalArgumentException (  \" Missing   Style   font .  \"  )  ;", "this . style    =    style ;", "cache    =    style . font . newFontCache (  )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . intValue )     =  =    value )", "return   false ;", "setText ( Integer . toString ( value )  )  ;", "intValue    =    value ;", "return   true ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "if    ( newText    =  =    null )", "newText    =     \"  \"  ;", "if    ( newText   instanceof   StringBuilder )     {", "if    ( text . equals ( newText )  )", "return ;", "text . setLength (  0  )  ;", "text . append (  (  ( StringBuilder )     ( newText )  )  )  ;", "} else    {", "if    ( textEquals ( newText )  )", "return ;", "text . setLength (  0  )  ;", "text . append ( newText )  ;", "}", "intValue    =    Integer . MIN _ VALUE ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "this . wrap    =    wrap ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setWrap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "int   length    =    text . length ;", "char [  ]    chars    =    text . chars ;", "if    ( length    !  =     ( other . length (  )  )  )", "return   false ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )", "if    (  ( chars [ i ]  )     !  =     ( other . charAt ( i )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["textEquals"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "return    (  ( super . toString (  )  )     +     \"  :     \"  )     +     ( text )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . size )     =  =     0  )", "return ;", "items . clear (  )  ;", "selection . clear (  )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["clearItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "String   string    =    toString ( item )  ;", "return   font . draw ( batch ,    string ,    x ,    y ,     0  ,    string . length (  )  ,    width ,    alignment ,    false ,     \"  .  .  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["drawItem"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "return   itemHeight ;", "}", "METHOD_END"], "methodName": ["getItemHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "return   items ;", "}", "METHOD_END"], "methodName": ["getItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "return   selection . first (  )  ;", "}", "METHOD_END"], "methodName": ["getSelected"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "ObjectSet < T > elected    = election . ite (  )  ;", "return   electedize )     =  =     0     ?     -  1     :    ite . indexOfelected . fit (  )  ,    fae )  ;", "}", "METHOD_END"], "methodName": ["getSelectedIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "return   selection ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "BitmapFont   font    =    style . font ;", "Drawable   selectedDrawable    =    style . selection ;", "itemHeight    =     ( font . getCapHeight (  )  )     -     (  ( font . getDet (  )  )     *     2  )  ;", "itemHeight    +  =     ( selectedDrawable . getTopHeight (  )  )     +     ( selectedDrawable . getBottomHeight (  )  )  ;", "prefWidth    =     0  ;", "Pool < GlyphLayout >    layoutPool    =    Pools . get ( GlyphLayout . class )  ;", "GlyphLayout   layout    =    layoutPool . obtain (  )  ;", "for    ( int   i    =     0  ;    i    <     ( items . size )  ;    i +  +  )     {", "layout . setText ( font ,    toString ( items . get ( i )  )  )  ;", "prefWidth    =    Math . max ( layout . width ,    prefWidth )  ;", "}", "layoutPool . free ( layout )  ;", "prefWidth    +  =     ( selectedDrawable . getLeftWidth (  )  )     +     ( selectedDrawable . getRightWidth (  )  )  ;", "prefHeight    =     ( items . size )     *     ( itemHeight )  ;", "Drawable   background    =    style . background ;", "if    ( background    !  =    null )     {", "prefWidth    +  =     ( background . getLeftWidth (  )  )     +     ( background . getRightWidth (  )  )  ;", "prefHeight    +  =     ( background . getTopHeight (  )  )     +     ( background . getBottomHeight (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "this . alignment    =    alignment ;", "}", "METHOD_END"], "methodName": ["setAlignment"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "this . cullingArea    =    cullingArea ;", "}", "METHOD_END"], "methodName": ["setCullingArea"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "if    ( newItems    =  =    null )", "throw   new   IllegalArgumentException (  \" newItems   cannot   be   null .  \"  )  ;", "float   oldPrefWidth    =    getPrefWidth (  )  ;", "float   oldPrefHeight    =    getPrefHeight (  )  ;", "items . clear (  )  ;", "items . addAll ( newItems )  ;", "selection . validate (  )  ;", "invalidate (  )  ;", "if    (  ( oldPrefWidth    !  =     ( getPrefWidth (  )  )  )     |  |     ( oldPrefHeight    !  =     ( getPrefHeight (  )  )  )  )", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "if    ( newItems    =  =    null )", "throw   new   IllegalArgumentException (  \" newItems   cannot   be   null .  \"  )  ;", "float   oldPrefWidth    =    getPrefWidth (  )  ;", "float   oldPrefHeight    =    getPrefHeight (  )  ;", "if    ( newItems    !  =     ( items )  )     {", "items . clear (  )  ;", "items . addAll ( newItems )  ;", "}", "selection . validate (  )  ;", "invalidate (  )  ;", "if    (  ( oldPrefWidth    !  =     ( getPrefWidth (  )  )  )     |  |     ( oldPrefHeight    !  =     ( getPrefHeight (  )  )  )  )", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "if    ( items . contains ( item ,    false )  )", "selection . set ( item )  ;", "else", "if    (  ( selection . getRequired (  )  )     &  &     (  ( itemize )     >     0  )  )", "selection . set ( items . first (  )  )  ;", "else", "selection . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     (  -  1  )  )     |  |     ( index    >  =     ( items . size )  )  )", "throw   new   IllegalArgumentException (  (  (  (  \" index   must   be    >  =     -  1    and    <     \"     +     ( items . size )  )     +     \"  :     \"  )     +    index )  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "selection . clear (  )  ;", "} else    {", "selection . set ( items . get ( index )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelectedIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "thityle    =    style ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "return   object . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.List"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . clamp ( value ,    min ,    max )  ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return    ( disabled )     &  &     (  ( style . disabledKnob )     !  =    null )     ?    style . disabledKnob    :    style . knob ;", "}", "METHOD_END"], "methodName": ["getKnobDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   this . position ;", "}", "METHOD_END"], "methodName": ["getKnobPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   this . max ;", "}", "METHOD_END"], "methodName": ["getMaxValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   this . min ;", "}", "METHOD_END"], "methodName": ["getMinValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return    (  ( value )     -     ( min )  )     /     (  ( max )     -     ( min )  )  ;", "}", "METHOD_END"], "methodName": ["getPercent"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( vertical )", "return    1  4  0  ;", "else    {", "final   Drawable   knob    =    getKnobDrawable (  )  ;", "final   Drawable   bg    =     (  ( disabled )     &  &     (  ( style . disabledBackground )     !  =    null )  )     ?    style . disabledBackground    :    styleckground ;", "return   Math . max (  ( knob    =  =    null    ?     0     :    knob . getMinHeight (  )  )  ,     ( bg    =  =    null    ?     0     :    bg . getMinHeight (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( vertical )     {", "final   Drawable   knob    =    getKnobDrawable (  )  ;", "final   Drawable   bg    =     (  ( disabled )     &  &     (  ( style . disabledBackground )     !  =    null )  )     ?    style . disabledBackground    :    styleckground ;", "return   Math . max (  ( knob    =  =    null    ?     0     :    knob . getMinWidth (  )  )  ,    bg . getMinWidth (  )  )  ;", "} else", "return    1  4  0  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   this . stepSize ;", "}", "METHOD_END"], "methodName": ["getStepSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   visualInterpolation . apply (  (  (  ( getVisualValue (  )  )     -     ( min )  )     /     (  ( max )     -     ( min )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getVisualPercent"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( animateTime )     >     0  )", "return   animateInterpolation . apply ( animateFrValue ,    value ,     (  1     -     (  ( animateTime )     /     ( animateDuration )  )  )  )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["getVisualValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   disabled ;", "}", "METHOD_END"], "methodName": ["isDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   vertical ;", "}", "METHOD_END"], "methodName": ["isVertical"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . animateDuration    =    duration ;", "}", "METHOD_END"], "methodName": ["setAnimateDuration"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( animateInterpolation    =  =    null )", "throw   new   IllegalArgumentExption (  \" animateInterpolation   cannot   be   null .  \"  )  ;", "this . animateInterpolation    =    animateInterpolation ;", "}", "METHOD_END"], "methodName": ["setAnimateInterpolation"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . disabled    =    disabled ;", "}", "METHOD_END"], "methodName": ["setDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( min    >    max )", "throw   new   IllegalArgumentExption (  \" min   must   be    <  =    max \"  )  ;", "this . min    =    min ;", "this . max    =    max ;", "if    (  ( value )     <    min )", "setValue ( min )  ;", "else", "if    (  ( value )     >    max )", "setValue ( max )  ;", "}", "METHOD_END"], "methodName": ["setRange"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . round    =    round ;", "}", "METHOD_END"], "methodName": ["setRound"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( stepSize    <  =     0  )", "throw   new   IllegalArgumentException (  (  \" steps   must   be    >     0  :     \"     +    stepSize )  )  ;", "thitepSize    =    stepSize ;", "}", "METHOD_END"], "methodName": ["setStepSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "thityle    =    style ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "value    =    clamp (  (  ( Math . round (  ( value    /     ( stepSize )  )  )  )     *     ( stepSize )  )  )  ;", "float   oldValue    =    this . value ;", "if    ( value    =  =    oldValue )", "return   false ;", "float   oldVisualValue    =    getVisualValue (  )  ;", "this . value    =    value ;", "ChangeListr . ChangeEvent   changeEvent    =    Pools . obtain ( ChangeListr . ChangeEvent . class )  ;", "boolean   cancelled    =    fire ( changeEvent )  ;", "if    ( cancelled )", "this . value    =    oldValue ;", "else", "if    (  ( animateDuration )     >     0  )     {", "animateFromValue    =    oldVisualValue ;", "animateTime    =    animateDuration ;", "}", "Pools . free ( changeEvent )  ;", "return    ! cancelled ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . visualInterpolation    =    interpolation ;", "}", "METHOD_END"], "methodName": ["setVisualInterpolation"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "super . act ( delta )  ;", "boolean   panning    =    flickScrollListener . getGestureDetector (  )  . isPanning (  )  ;", "boolean   animating    =    false ;", "if    (  (  (  (  (  ( fadeAlpha )     >     0  )     &  &     ( fadeScrollBars )  )     &  &     (  ! panning )  )     &  &     (  !  ( touchScrollH )  )  )     &  &     (  !  ( touchScrollV )  )  )     {", "fadeDelay    -  =    delta ;", "if    (  ( fadeDelay )     <  =     0  )", "fadeAlpha    =    Math . max (  0  ,     (  ( fadeAlpha )     -    delta )  )  ;", "animating    =    true ;", "}", "if    (  ( flingTimer )     >     0  )     {", "resetFade (  )  ;", "float   alpha    =     ( flingTimer )     /     ( flingTime )  ;", "amountX    -  =     (  ( velocityX )     *    alpha )     *    delta ;", "amountY    -  =     (  ( velocityY )     *    alpha )     *    delta ;", "clamp (  )  ;", "if    (  ( amountX )     =  =     (  -  ( overscrollDistance )  )  )", "velocityX    =     0  ;", "if    (  ( amountX )     >  =     (  ( maxX )     +     ( overscrollDistance )  )  )", "velocityX    =     0  ;", "if    (  ( amountY )     =  =     (  -  ( overscrollDistance )  )  )", "velocityY    =     0  ;", "if    (  ( amountY )     >  =     (  ( maxY )     +     ( overscrollDistance )  )  )", "velocityY    =     0  ;", "flingTimer    -  =    delta ;", "if    (  ( flingTimer )     <  =     0  )     {", "velocityX    =     0  ;", "velocityY    =     0  ;", "}", "animating    =    true ;", "}", "if    (  (  (  ( smoothScrolling )     &  &     (  ( flingTimer )     <  =     0  )  )     &  &     (  ! panning )  )     &  &     (  (  (  !  ( touchScrollH )  )     |  |     (  ( scrollX )     &  &     (  (  ( maxX )     /     (  ( hScrollBounds . width )     -     ( hKnobBounds . width )  )  )     >     (  ( areaWidth )     *     0  .  1 F )  )  )  )     &  &     (  (  !  ( touchScrollV )  )     |  |     (  ( scrollY )     &  &     (  (  ( maxY )     /     (  ( vScrollBounds . height )     -     ( vKnobBounds . height )  )  )     >     (  ( areaHeight )     *     0  .  1 F )  )  )  )  )  )     {", "if    (  ( visualAmountX )     !  =     ( amountX )  )     {", "if    (  ( visualAmountX )     <     ( amountX )  )", "visualScrollX ( Math . min ( amountX ,     (  ( visualAmountX )     +     ( Math . max (  (  2  0  0     *    delta )  ,     (  (  (  ( amountX )     -     ( visualAmountX )  )     *     7  )     *    delta )  )  )  )  )  )  ;", "else", "visualScrollX ( Math . max ( amountX ,     (  ( visualAmountX )     -     ( Math . max (  (  2  0  0     *    delta )  ,     (  (  (  ( visualAmountX )     -     ( amountX )  )     *     7  )     *    delta )  )  )  )  )  )  ;", "animating    =    true ;", "}", "if    (  ( visualAmountY )     !  =     ( amountY )  )     {", "if    (  ( visualAmountY )     <     ( amountY )  )", "visualScrollY ( Math . min ( amountY ,     (  ( visualAmountY )     +     ( Math . max (  (  2  0  0     *    delta )  ,     (  (  (  ( amountY )     -     ( visualAmountY )  )     *     7  )     *    delta )  )  )  )  )  )  ;", "else", "visualScrollY ( Math . max ( amountY ,     (  ( visualAmountY )     -     ( Math . max (  (  2  0  0     *    delta )  ,     (  (  (  ( visualAmountY )     -     ( amountY )  )     *     7  )     *    delta )  )  )  )  )  )  ;", "animating    =    true ;", "}", "} else    {", "if    (  ( visualAmountX )     !  =     ( amountX )  )", "visualScrollX ( amountX )  ;", "if    (  ( visualAmountY )     !  =     ( amountY )  )", "visualScrollY ( amountY )  ;", "}", "if    (  ! panning )     {", "if    (  ( overscrollX )     &  &     ( scrollX )  )     {", "if    (  ( amountX )     <     0  )     {", "resetFade (  )  ;", "amountX    +  =     (  ( overscrollSpeedMin )     +     (  (  (  ( overscrollSpeedMax )     -     ( overscrollSpeedMin )  )     *     (  -  ( amountX )  )  )     /     ( overscrollDistance )  )  )     *    delta ;", "if    (  ( amountX )     >     0  )", "scrollX (  0  )  ;", "animating    =    true ;", "} else", "if    (  ( amountX )     >     ( maxX )  )     {", "resetFade (  )  ;", "amountX    -  =     (  ( overscrollSpeedMin )     +     (  (  (  ( overscrollSpeedMax )     -     ( overscrollSpeedMin )  )     *     (  -  (  ( maxX )     -     ( amountX )  )  )  )     /     ( overscrollDistance )  )  )     *    delta ;", "if    (  ( amountX )     <     ( maxX )  )", "scrollX ( maxX )  ;", "animating    =    true ;", "}", "}", "if    (  ( overscrollY )     &  &     ( scrollY )  )     {", "if    (  ( amountY )     <     0  )     {", "resetFade (  )  ;", "amountY    +  =     (  ( overscrollSpeedMin )     +     (  (  (  ( overscrollSpeedMax )     -     ( overscrollSpeedMin )  )     *     (  -  ( amountY )  )  )     /     ( overscrollDistance )  )  )     *    delta ;", "if    (  ( amountY )     >     0  )", "scrollY (  0  )  ;", "animating    =    true ;", "} else", "if    (  ( amountY )     >     ( maxY )  )     {", "resetFade (  )  ;", "amountY    -  =     (  ( overscrollSpeedMin )     +     (  (  (  ( overscrollSpeedMax )     -     ( overscrollSpeedMin )  )     *     (  -  (  ( maxY )     -     ( amountY )  )  )  )     /     ( overscrollDistance )  )  )     *    delta ;", "if    (  ( amountY )     <     ( maxY )  )", "scrollY ( maxY )  ;", "animating    =    true ;", "}", "}", "}", "if    ( animating )     {", "Stage   stage    =    getStage (  )  ;", "if    (  ( stage    !  =    null )     &  &     ( stage . getActionsRequestRendering (  )  )  )", "Gdx . graphics . requestRendering (  )  ;", "}", "}", "METHOD_END"], "methodName": ["act"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   ScrollPane # setWidget .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   ScrollPane # setWidget .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorAfter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   ScrollPane # setWidget .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorAt"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   ScrollPane # setWidget .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorBefore"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "draggingPointer    =     -  1  ;", "touchH    =    false ;", "touchV    =    false ;", "flickListener . getGestureDetector (  )  . cancel (  )  ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "Stage   stage    =    getStage (  )  ;", "if    ( stage    !  =    null )", "stage . cancelTouchFocusExcept ( flickListener ,    this )  ;", "}", "METHOD_END"], "methodName": ["cancelTouchFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( clamp )  )", "return ;", "sX (  ( oversX    ?    MathUtils . clamp ( amountX ,     (  -  ( oversDistance )  )  ,     (  ( maxX )     +     ( oversDistance )  )  )     :    MathUtils . clamp ( amountX ,     0  ,    maxX )  )  )  ;", "sY (  ( oversY    ?    MathUtils . clamp ( amountY ,     (  -  ( oversDistance )  )  ,     (  ( maxY )     +     ( oversDistance )  )  )     :    MathUtils . clamp ( amountY ,     0  ,    maxY )  )  )  ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "shapes . flush (  )  ;", "applyTransform ( shapes ,    computeTransform (  )  )  ;", "if    ( ScissorStack . pushScissors ( scissorBounds )  )     {", "drawDebugChildren ( shapes )  ;", "ScissorStack . popScissors (  )  ;", "}", "resetTransform ( shapes )  ;", "}", "METHOD_END"], "methodName": ["drawDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . flingTimer    =    flingTime ;", "this . velocityX    =    velocityX ;", "this . velocityY    =    velocityY ;", "}", "METHOD_END"], "methodName": ["fling"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   widget ;", "}", "METHOD_END"], "methodName": ["getActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   maxX ;", "}", "METHOD_END"], "methodName": ["getMaxX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   maxY ;", "}", "METHOD_END"], "methodName": ["getMaxY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   Math . min ( areaWidth ,     (  ( Math . max (  (  ( areaWidth )     *     0  .  9 F )  ,     (  ( maxX )     *     0  .  1 F )  )  )     /     4  )  )  ;", "}", "METHOD_END"], "methodName": ["getMouseWheelX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   Math . min ( areaHeight ,     (  ( Math . max (  (  ( areaHeight )     *     0  .  9 F )  ,     (  ( maxY )     *     0  .  1 F )  )  )     /     4  )  )  ;", "}", "METHOD_END"], "methodName": ["getMouseWheelY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   overscrollDistance ;", "}", "METHOD_END"], "methodName": ["getOverscrollDistance"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( widget )    instanceof   Layout )     {", "float   height    =     (  ( Layout )     ( widget )  )  . getPrefHeight (  )  ;", "if    (  ( style . background )     !  =    null )", "height    +  =     ( style . background . getTopHeight (  )  )     +     ( style . background . getBottomHeight (  )  )  ;", "if    ( forceX )     {", "float   scrollbarHeight    =     0  ;", "if    (  ( style . hKnob )     !  =    null )", "scrollbarHeight    =    style . hKnob . getMinHeight (  )  ;", "if    (  ( style . h )     !  =    null )", "scrollbarHeight    =    Math . max ( scrollbarHeight ,    style . h . getMinHeight (  )  )  ;", "height    +  =    scrollbarHeight ;", "}", "return   height ;", "}", "return    1  5  0  ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( widget )    instanceof   Layout )     {", "float   width    =     (  ( Layout )     ( widget )  )  . getPrefWidth (  )  ;", "if    (  ( style . background )     !  =    null )", "width    +  =     ( style . background . getLeftWidth (  )  )     +     ( style . background . getRightWidth (  )  )  ;", "if    ( forceY )     {", "float   scrollbarWidth    =     0  ;", "if    (  ( style . vKnob )     !  =    null )", "scrollbarWidth    =    style . vKnob . getMinWidth (  )  ;", "if    (  ( style . v )     !  =    null )", "scrollbarWidth    =    Math . max ( scrollbarWidth ,    style . v . getMinWidth (  )  )  ;", "width    +  =    scrollbarWidth ;", "}", "return   width ;", "}", "return    1  5  0  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( scrollX )  )", "return    0  ;", "float   height    =     0  ;", "if    (  ( style . hKnob )     !  =    null )", "height    =    style . hKnob . getMinHeight (  )  ;", "if    (  ( style . h )     !  =    null )", "height    =    Math . max ( height ,    style . h . getMinHeight (  )  )  ;", "return   height ;", "}", "METHOD_END"], "methodName": ["getScrollBarHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( scrollY )  )", "return    0  ;", "float   width    =     0  ;", "if    (  ( style . vKnob )     !  =    null )", "width    =    style . vKnob . getMinWidth (  )  ;", "if    (  ( style . v )     !  =    null )", "width    =    Math . max ( width ,    style . v . getMinWidth (  )  )  ;", "return   width ;", "}", "METHOD_END"], "methodName": ["getScrollBarWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   areaHeight ;", "}", "METHOD_END"], "methodName": ["getScrollHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . clamp (  (  ( amountX )     /     ( maxX )  )  ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["getScrollPercentX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . clamp (  (  ( amountY )     /     ( maxY )  )  ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["getScrollPercentY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   areaWidth ;", "}", "METHOD_END"], "methodName": ["getScrollWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   amountX ;", "}", "METHOD_END"], "methodName": ["getScrollX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   amountY ;", "}", "METHOD_END"], "methodName": ["getScrollY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   variableSizeKnobs ;", "}", "METHOD_END"], "methodName": ["getVariableSizeKnobs"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   velocityX ;", "}", "METHOD_END"], "methodName": ["getVelocityX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   velocityY ;", "}", "METHOD_END"], "methodName": ["getVelocityY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . clamp (  (  ( visualAmountX )     /     ( maxX )  )  ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["getVisualScrollPercentX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . clamp (  (  ( visualAmountY )     /     ( maxY )  )  ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["getVisualScrollPercentY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    !  ( scrollX )     ?     0     :    visualAmountX ;", "}", "METHOD_END"], "methodName": ["getVisualScrollX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    !  ( scrollY )     ?     0     :    visualAmountY ;", "}", "METHOD_END"], "methodName": ["getVisualScrollY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   widget ;", "}", "METHOD_END"], "methodName": ["getWidget"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( x    <     0  )     |  |     ( x    >  =     ( getWidth (  )  )  )  )     |  |     ( y    <     0  )  )     |  |     ( y    >  =     ( getHeight (  )  )  )  )", "return   null ;", "if    (  (  ( scrollX )     &  &     ( touchH )  )     &  &     ( hBounds . contains ( x ,    y )  )  )", "return   this ;", "if    (  (  ( scrollY )     &  &     ( touchV )  )     &  &     ( vBounds . contains ( x ,    y )  )  )", "return   this ;", "return   super . hit ( x ,    y ,    touchable )  ;", "}", "METHOD_END"], "methodName": ["hit"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( scrollY )  )     |  |     (  ( amountY )     >  =     ( maxY )  )  ;", "}", "METHOD_END"], "methodName": ["isBottomEdge"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    ( draggingPointer )     !  =     (  -  1  )  ;", "}", "METHOD_END"], "methodName": ["isDragging"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    ( flingTimer )     >     0  ;", "}", "METHOD_END"], "methodName": ["isFlinging"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   forceScrollX ;", "}", "METHOD_END"], "methodName": ["isForceScrollX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   forceScrollY ;", "}", "METHOD_END"], "methodName": ["isForceScrollY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( scrollX )  )     |  |     (  ( amountX )     <  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isLeftEdge"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   flickScrollListener . getGestureDetector (  )  . isPanning (  )  ;", "}", "METHOD_END"], "methodName": ["isPanning"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( scrollX )  )     |  |     (  ( amountX )     >  =     ( maxX )  )  ;", "}", "METHOD_END"], "methodName": ["isRightEdge"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   scrollX ;", "}", "METHOD_END"], "methodName": ["isScrollX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   scrollY ;", "}", "METHOD_END"], "methodName": ["isScrollY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   disableX ;", "}", "METHOD_END"], "methodName": ["isScrollingDisabledX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return   disableY ;", "}", "METHOD_END"], "methodName": ["isScrollingDisabledY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( scrollY )  )     |  |     (  ( amountY )     <  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isTopEdge"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "final   Drawable   bg    =    style . background ;", "final   Drawable   hScrollKnob    =    style . hScrollKnob ;", "final   Drawable   vScrollKnob    =    style . vScrollKnob ;", "float   bgLeftWidth    =     0  ;", "float   bgRightWidth    =     0  ;", "float   bgTopHeight    =     0  ;", "float   bgBottomHeight    =     0  ;", "if    ( bg    !  =    null )     {", "bgLeftWidth    =    bg . getLeftWidth (  )  ;", "bgRightWidth    =    bg . getRightWidth (  )  ;", "bgTopHeight    =    bg . getTopHeight (  )  ;", "bgBottomHeight    =    bg . getBottomHeight (  )  ;", "}", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "float   scrollbarHeight    =     0  ;", "if    ( hScrollKnob    !  =    null )", "scrollbarHeight    =    hScrollKnob . getMinHeight (  )  ;", "if    (  ( style . hScroll )     !  =    null )", "scrollbarHeight    =    Math . max ( scrollbarHeight ,    style . hScroll . getMinHeight (  )  )  ;", "float   scrollbarWidth    =     0  ;", "if    ( vScrollKnob    !  =    null )", "scrollbarWidth    =    vScrollKnob . getMinWidth (  )  ;", "if    (  ( style . vScroll )     !  =    null )", "scrollbarWidth    =    Math . max ( scrollbarWidth ,    style . vScroll . getMinWidth (  )  )  ;", "areaWidth    =     ( width    -    bgLeftWidth )     -    bgRightWidth ;", "areaHeight    =     ( height    -    bgTopHeight )     -    bgBottomHeight ;", "if    (  ( widget )     =  =    null )", "return ;", "float   widgetWidth ;", "float   widgetHeight ;", "if    (  ( widget )    instanceof   Layout )     {", "Layout   layout    =     (  ( Layout )     ( widget )  )  ;", "widgetWidth    =    layout . getPrefWidth (  )  ;", "widgetHeight    =    layout . getPrefHeight (  )  ;", "} else    {", "widgetWidth    =    widget . getWidth (  )  ;", "widgetHeight    =    widget . getHeight (  )  ;", "}", "scrollX    =     ( forceScrollX )     |  |     (  ( widgetWidth    >     ( areaWidth )  )     &  &     (  !  ( disableX )  )  )  ;", "scrollY    =     ( forceScrollY )     |  |     (  ( widgetHeight    >     ( areaHeight )  )     &  &     (  !  ( disableY )  )  )  ;", "boolean   fade    =    fadeScrollBars ;", "if    (  ! fade )     {", "if    ( scrollY )     {", "areaWidth    -  =    scrollbarWidth ;", "if    (  (  (  !  ( scrollX )  )     &  &     ( widgetWidth    >     ( areaWidth )  )  )     &  &     (  !  ( disableX )  )  )", "scrollX    =    true ;", "}", "if    ( scrollX )     {", "areaHeight    -  =    scrollbarHeight ;", "if    (  (  (  !  ( scrollY )  )     &  &     ( widgetHeight    >     ( areaHeight )  )  )     &  &     (  !  ( disableY )  )  )     {", "scrollY    =    true ;", "areaWidth    -  =    scrollbarWidth ;", "}", "}", "}", "widgetAreaBounds . set ( bgLeftWidth ,    bgBottomHeight ,    areaWidth ,    areaHeight )  ;", "if    ( fade )     {", "if    (  ( scrollX )     &  &     ( scrollY )  )     {", "areaHeight    -  =    scrollbarHeight ;", "areaWidth    -  =    scrollbarWidth ;", "}", "} else    {", "if    ( scrollbarsOnTop )     {", "if    ( scrollX )", "widgetAreaBounds . height    +  =    scrollbarHeight ;", "if    ( scrollY )", "widgetAreaBounds . width    +  =    scrollbarWidth ;", "} else    {", "if    (  ( scrollX )     &  &     ( hScrollOnBottom )  )", "widgetAreaBounds . y    +  =    scrollbarHeight ;", "if    (  ( scrollY )     &  &     (  !  ( vScrollOnRight )  )  )", "widgetAreaBounds . x    +  =    scrollbarWidth ;", "}", "}", "widgetWidth    =     ( disableX )     ?    areaWidth    :    Math . max ( areaWidth ,    widgetWidth )  ;", "widgetHeight    =     ( disableY )     ?    areaHeight    :    Math . max ( areaHeight ,    widgetHeight )  ;", "maxX    =    widgetWidth    -     ( areaWidth )  ;", "maxY    =    widgetHeight    -     ( areaHeight )  ;", "if    ( fade )     {", "if    (  ( scrollX )     &  &     ( scrollY )  )     {", "maxY    -  =    scrollbarHeight ;", "maxX    -  =    scrollbarWidth ;", "}", "}", "scrollX ( MathUtils . clamp ( amountX ,     0  ,    maxX )  )  ;", "scrollY ( MathUtils . clamp ( amountY ,     0  ,    maxY )  )  ;", "if    ( scrollX )     {", "if    ( hScrollKnob    !  =    null )     {", "float   hScrollHeight    =     (  ( style . hScroll )     !  =    null )     ?    style . hScroll . getMinHeight (  )     :    hScrollKnob . getMinHeight (  )  ;", "float   boundsX    =     ( vScrollOnRight )     ?    bgLeftWidth    :    bgLeftWidth    +    scrollbarWidth ;", "float   boundsY    =     ( hScrollOnBottom )     ?    bgBottomHeight    :     ( height    -    bgTopHeight )     -    hScrollHeight ;", "hScrollBounds . set ( boundsX ,    boundsY ,    areaWidth ,    hScrollHeight )  ;", "if    ( variableSizeKnobs )", "hKnobBounds . width    =    Math . max ( hScrollKnob . getMinWidth (  )  ,     (  ( int )     (  (  ( hScrollBounds . width )     *     ( areaWidth )  )     /    widgetWidth )  )  )  ;", "else", "hKnobBounds . width    =    hScrollKnob . getMinWidth (  )  ;", "hKnobBounds . height    =    hScrollKnob . getMinHeight (  )  ;", "hKnobBounds . x    =     ( hScrollBounds . x )     +     (  ( int )     (  (  ( hScrollBounds . width )     -     ( hKnobBounds . width )  )     *     ( getercentX (  )  )  )  )  ;", "hKnobBounds . y    =    hScrollBounds . y ;", "} else    {", "hScrollBounds . set (  0  ,     0  ,     0  ,     0  )  ;", "hKnobBounds . set (  0  ,     0  ,     0  ,     0  )  ;", "}", "}", "if    ( scrollY )     {", "if    ( vScrollKnob    !  =    null )     {", "float   vScrollWidth    =     (  ( style . vScroll )     !  =    null )     ?    style . vScroll . getMinWidth (  )     :    vScrollKnob . getMinWidth (  )  ;", "float   boundsX ;", "float   boundsY ;", "if    ( hScrollOnBottom )     {", "boundsY    =     ( height    -    bgTopHeight )     -     ( areaHeight )  ;", "} else    {", "boundsY    =    bgBottomHeight ;", "}", "if    ( vScrollOnRight )     {", "boundsX    =     ( width    -    bgRightWidth )     -    vScrollWidth ;", "} else    {", "boundsX    =    bgLeftWidth ;", "}", "vScrollBounds . set ( boundsX ,    boundsY ,    vScrollWidth ,    areaHeight )  ;", "vKnobBounds . width    =    vScrollKnob . getMinWidth (  )  ;", "if    ( variableSizeKnobs )", "vKnobBounds . height    =    Math . max ( vScrollKnob . getMinHeight (  )  ,     (  ( int )     (  (  ( vScrollBounds . height )     *     ( areaHeight )  )     /    widgetHeight )  )  )  ;", "else", "vKnobBounds . height    =    vScrollKnob . getMinHeight (  )  ;", "if    ( vScrollOnRight )     {", "vKnobBounds . x    =     ( width    -    bgRightWidth )     -     ( vScrollKnob . getMinWidth (  )  )  ;", "} else    {", "vKnobBounds . x    =    bgLeftWidth ;", "}", "vKnobBounds . y    =     ( vScrollBounds . y )     +     (  ( int )     (  (  ( vScrollBounds . height )     -     ( vKnobBounds . height )  )     *     (  1     -     ( getercentY (  )  )  )  )  )  ;", "} else    {", "vScrollBounds . set (  0  ,     0  ,     0  ,     0  )  ;", "vKnobBounds . set (  0  ,     0  ,     0  ,     0  )  ;", "}", "}", "updateWidgetPosition (  )  ;", "widget . setSize ( widgetWidth ,    widgetHeight )  ;", "if    (  ( widget )    instanceof   Layout )", "(  ( Layout )     ( widget )  )  . validate (  )  ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   null .  \"  )  ;", "if    ( actor    !  =     ( widget )  )", "return   false ;", "setActor ( null )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   null .  \"  )  ;", "if    ( actor    !  =     ( widget )  )", "return   false ;", "this . widget    =    null ;", "return   super . removeActor ( actor ,    unfocus )  ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "fadeAlpha    =    fadeAlphaSeconds ;", "fadeDelay    =    fadeDelaySeconds ;", "}", "METHOD_END"], "methodName": ["resetFade"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "scrollTo ( x ,    y ,    width ,    height ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["scrollTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "float   amountX    =    this . amountX ;", "if    ( centerHorizontal )     {", "amountX    =     ( x    -     (  ( areaWidth )     /     2  )  )     +     ( width    /     2  )  ;", "} else    {", "if    (  ( x    +    width )     >     ( amountX    +     ( areaWidth )  )  )", "amountX    =     ( x    +    width )     -     ( areaWidth )  ;", "if    ( x    <    amountX )", "amountX    =    x ;", "}", "sX ( MathUtils . clamp ( amountX ,     0  ,    maxX )  )  ;", "float   amountY    =    this . amountY ;", "if    ( centerVertical )     {", "amountY    =     (  (  ( maxY )     -    y )     +     (  ( areaHeight )     /     2  )  )     -     ( height    /     2  )  ;", "} else    {", "if    ( amountY    >     (  (  (  ( maxY )     -    y )     -    height )     +     ( areaHeight )  )  )", "amountY    =     (  (  ( maxY )     -    y )     -    height )     +     ( areaHeight )  ;", "if    ( amountY    <     (  ( maxY )     -    y )  )", "amountY    =     ( maxY )     -    y ;", "}", "sY ( MathUtils . clamp ( amountY ,     0  ,    maxY )  )  ;", "}", "METHOD_END"], "methodName": ["scrollTo"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . amountX    =    pixelsX ;", "}", "METHOD_END"], "methodName": ["scrollX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . amountY    =    pixelsY ;", "}", "METHOD_END"], "methodName": ["scrollY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( widget )     =  =     ( this )  )", "throw   new   IllegalArgumentException (  \" widget   cannot   be   the    .  \"  )  ;", "if    (  ( this . widget )     !  =    null )", "super . removeActor ( this . widget )  ;", "this . widget    =    actor ;", "if    (  ( widget )     !  =    null )", "super . addActor ( widget )  ;", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . cancelTouchFocus    =    cancelTouchFocus ;", "}", "METHOD_END"], "methodName": ["setCancelTouchFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . clamp    =    clamp ;", "}", "METHOD_END"], "methodName": ["setClamp"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . fadeScrollBars )     =  =    fadeScrollBars )", "return ;", "this . fadeScrollBars    =    fadeScrollBars ;", "if    (  ! fadeScrollBars )", "fadeAlpha    =    fadeAlphaSeconds ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setFadeScrollBars"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . flickScroll )     =  =    flickScroll )", "return ;", "this . flickScroll    =    flickScroll ;", "if    ( flickScroll )", "addListener ( flickScrollListener )  ;", "else", "removeListener ( flickScrollListener )  ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setFlickScroll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "flickScrollListener . getGestureDetector (  )  . setTapSquareSize ( halfTapSquareSize )  ;", "}", "METHOD_END"], "methodName": ["setFlickScrollTapSquareSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . flingTime    =    flingTime ;", "}", "METHOD_END"], "methodName": ["setFlingTime"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "forceScrollX    =    x ;", "forceScrollY    =    y ;", "}", "METHOD_END"], "methodName": ["setForceScroll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . overscrollX    =    overscrollX ;", "this . overscrollY    =    overscrollY ;", "}", "METHOD_END"], "methodName": ["setOverscroll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "hScrollOnBottom    =    bottom ;", "vScrollOnRight    =    right ;", "}", "METHOD_END"], "methodName": ["setScrollBarPositions"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . scrollBarTouch    =    scrollBarTouch ;", "}", "METHOD_END"], "methodName": ["setScrollBarTouch"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "scrollX (  (  ( maxX )     *     ( MathUtils . clamp ( percentX ,     0  ,     1  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setScrollPercentX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "scrollY (  (  ( maxY )     *     ( MathUtils . clamp ( percentY ,     0  ,     1  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setScrollPercentY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "scrollX ( MathUtils . clamp ( pixels ,     0  ,    maxX )  )  ;", "}", "METHOD_END"], "methodName": ["setScrollX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "scrollY ( MathUtils . clamp ( pixels ,     0  ,    maxY )  )  ;", "}", "METHOD_END"], "methodName": ["setScrollY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . scrollbarsOnTop    =    scrollbarsOnTop ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setScrollbarsOnTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "disableX    =    x ;", "disableY    =    y ;", "}", "METHOD_END"], "methodName": ["setScrollingDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . smoothScrolling    =    smoothScrolling ;", "}", "METHOD_END"], "methodName": ["setSmoothScrolling"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "thityle    =    style ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . variableSizeKnobs    =    variableSizeKnobs ;", "}", "METHOD_END"], "methodName": ["setVariableSizeKnobs"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . velocityX    =    velocityX ;", "}", "METHOD_END"], "methodName": ["setVelocityX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . velocityY    =    velocityY ;", "}", "METHOD_END"], "methodName": ["setVelocityY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "setActor ( actor )  ;", "}", "METHOD_END"], "methodName": ["setWidget"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . fadeAlphaSeconds    =    fadeAlphaSeconds ;", "this . fadeDelaySeconds    =    fadeDelaySeconds ;", "}", "METHOD_END"], "methodName": ["setupFadeScrollBars"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "overscrollDistance    =    distance ;", "overscrollSpeedMin    =    speedMin ;", "overscrollSpeedMax    =    speedMax ;", "}", "METHOD_END"], "methodName": ["setupOverscroll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "visualAmountX    =    amountX ;", "visualAmountY    =    amountY ;", "}", "METHOD_END"], "methodName": ["updateVisualScroll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "float   y    =    widgetAreaBounds . y ;", "if    (  !  ( scrollY )  )", "y    -  =     (  ( int )     ( maxY )  )  ;", "else", "y    -  =     (  ( int )     (  ( maxY )     -     ( visualAmountY )  )  )  ;", "float   x    =    widgetAreaBounds . x ;", "if    ( scrollX )", "x    -  =     (  ( int )     ( visualAmountX )  )  ;", "if    (  (  !  ( fadeBars )  )     &  &     ( scrollbarsOnTop )  )     {", "if    (  ( scrollX )     &  &     ( hOnBottom )  )     {", "float   scrollbarHeight    =     0  ;", "if    (  ( style . hKnob )     !  =    null )", "scrollbarHeight    =    style . hKnob . getMinHeight (  )  ;", "if    (  ( style . h )     !  =    null )", "scrollbarHeight    =    Math . max ( scrollbarHeight ,    style . h . getMinHeight (  )  )  ;", "y    +  =    scrollbarHeight ;", "}", "if    (  ( scrollY )     &  &     (  !  ( vOnRight )  )  )     {", "float   scrollbarWidth    =     0  ;", "if    (  ( style . hKnob )     !  =    null )", "scrollbarWidth    =    style . hKnob . getMinWidth (  )  ;", "if    (  ( style . h )     !  =    null )", "scrollbarWidth    =    Math . max ( scrollbarWidth ,    style . h . getMinWidth (  )  )  ;", "x    +  =    scrollbarWidth ;", "}", "}", "widget . setPosition ( x ,    y )  ;", "if    (  ( widget )    instanceof   Cullable )     {", "widgetCullingArea . x    =     ( widgetAreaBounds . x )     -    x ;", "widgetCullingArea . y    =     ( widgetAreaBounds . y )     -    y ;", "widgetCullingArea . width    =    widgetAreaBounds . width ;", "widgetCullingArea . height    =    widgetAreaBounds . height ;", "(  ( Cullable )     ( widget )  )  . setCullingArea ( widgetCullingArea )  ;", "}", "}", "METHOD_END"], "methodName": ["updateWidgetPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . visualAmountX    =    pixelsX ;", "}", "METHOD_END"], "methodName": ["visualScrollX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "this . visualAmountY    =    pixelsY ;", "}", "METHOD_END"], "methodName": ["visualScrollY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.ScrollPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . size )     =  =     0  )", "return ;", "items . clear (  )  ;", "sion . clear (  )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["clearItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "String   string    =    toString ( item )  ;", "return   font . draw ( tch ,    string ,    x ,    y ,     0  ,    string . length (  )  ,    width ,    alignment ,    false ,     \"  .  .  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["drawItem"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   items ;", "}", "METHOD_END"], "methodName": ["getItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   selectBoxList . list ;", "}", "METHOD_END"], "methodName": ["getList"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   selectBoxList . maxListCount ;", "}", "METHOD_END"], "methodName": ["getMaxListCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   selectBoxList ;", "}", "METHOD_END"], "methodName": ["getScrollPane"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   selection . first (  )  ;", "}", "METHOD_END"], "methodName": ["getSelected"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "ObjectSet < T >    selected    =    selection . items (  )  ;", "return    ( selected . size )     =  =     0     ?     -  1     :    items . indexOf ( selected . first (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["getSelectedIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   selection ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "selectBoxList . hide (  )  ;", "}", "METHOD_END"], "methodName": ["hideList"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   disabled ;", "}", "METHOD_END"], "methodName": ["isDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "selectBoxList . getColor (  )  . a    =     1  ;", "selectBoxList . addAction ( Actions . sequence ( Actions . fadeOut (  0  .  1  5 F ,    Interpolation . fade )  ,    Actions . removeActor (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["onHide"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "selectBoxList . getColor (  )  . a    =     0  ;", "selectBoxList . addAction ( Actions . fadeIn (  0  .  3 F ,    Interpolation . fade )  )  ;", "}", "METHOD_END"], "methodName": ["onShow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "this . alignment    =    alignment ;", "}", "METHOD_END"], "methodName": ["setAlignment"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "if    ( disabled    &  &     (  !  ( this . disabled )  )  )", "hideList (  )  ;", "this . disabled    =    disabled ;", "}", "METHOD_END"], "methodName": ["setDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "if    ( newItems    =  =    null )", "throw   new   IllegalArgumentException (  \" newItems   cannot   be   null .  \"  )  ;", "float   oldPrefWidth    =    getPrefWidth (  )  ;", "items . clear (  )  ;", "items . addAll ( newItems )  ;", "selection . validate (  )  ;", "sList . list . setItems ( items )  ;", "invalidate (  )  ;", "if    ( oldPrefWidth    !  =     ( getPrefWidth (  )  )  )", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "if    ( newItems    =  =    null )", "throw   new   IllegalArgumentException (  \" newItems   cannot   be   null .  \"  )  ;", "float   oldPrefWidth    =    getPrefWidth (  )  ;", "items . clear (  )  ;", "items . addAll ( newItems )  ;", "selection . validate (  )  ;", "sList . list . setItems ( items )  ;", "invalidate (  )  ;", "if    ( oldPrefWidth    !  =     ( getPrefWidth (  )  )  )", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "selectBoxList . maxListCount    =    maxListCount ;", "}", "METHOD_END"], "methodName": ["setMaxListCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "selectBoxList . setScrollingDisabled ( true ,    y )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setScrollingDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "if    ( items . contains ( item ,    false )  )", "sion . set ( item )  ;", "else", "if    (  ( items . size )     >     0  )", "sion . set ( items . first (  )  )  ;", "else", "sion . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "selection . set ( items . get ( index )  )  ;", "}", "METHOD_END"], "methodName": ["setSelectedIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "if    ( stage    =  =    null )", "sList . hide (  )  ;", "super . setStage ( stage )  ;", "}", "METHOD_END"], "methodName": ["setStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "this . style    =    style ;", "if    (  ( sList )     !  =    null )     {", "sList . setStyle ( style . scrollStyle )  ;", "sList . list . setStyle ( style . listStyle )  ;", "}", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . size )     =  =     0  )", "return ;", "sList . show ( getStage (  )  )  ;", "}", "METHOD_END"], "methodName": ["showList"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "return   item . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SelectBox"}, {"methodBody": ["METHOD_START", "{", "add ( name ,    resource ,    resource . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )", "throw   new   IllegalArgumentException (  \" name   cannot   be   null .  \"  )  ;", "if    ( rurce    =  =    null )", "throw   new   IllegalArgumentException (  \" rurce   cannot   be   null .  \"  )  ;", "ObjectMap < String ,    Object >    typeRurc =    rurcget ( type )  ;", "if    ( typeRurc =  =    null )     {", "typeRurc =    new   ObjectMap (  (  (  ( type    =  =     ( TextureRegion . class )  )     |  |     ( type    =  =     ( Drawable . class )  )  )     |  |     ( type    =  =     ( Sprite . class )  )     ?     2  5  6     :     6  4  )  )  ;", "rurcput ( type ,    typeRurc ;", "}", "typeRurcput ( name ,    rurce )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "Array < TextureAtlas . AtlasRegion >    regions    =    atlas . getRegions (  )  ;", "for    ( int   i    =     0  ,    n    =    regionize ;    i    <    n ;    i +  +  )     {", "TextureAtlas . AtlasRegion   region    =    regions . get ( i )  ;", "String   name    =    region . name ;", "if    (  ( region . index )     !  =     (  -  1  )  )     {", "name    +  =     \"  _  \"     +     ( region . index )  ;", "}", "add ( name ,    region ,    TextureRegion . class )  ;", "}", "}", "METHOD_END"], "methodName": ["addRegions"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "if    (  ( atlas )     !  =    null )", "atlas . dispose (  )  ;", "for    ( ObjectMap < String ,    Object >    entry    :    resources . values (  )  )     {", "for    ( Object   resource    :    entry . values (  )  )", "if    ( resource   instanceof   utils . Disposable )", "(  ( utils . Disposable )     ( resource )  )  . dispose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "if    ( rurce    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "ObjectMap < String ,    Object >    typeRurc =    rurcget ( rurce . getClass (  )  )  ;", "if    ( typeRurc =  =    null )", "return   null ;", "return   typeRurcfindKey ( rurce ,    true )  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    ClassReflection . getMethods ( type )  ;", "for    ( int   i    =     0  ,    n    =    methods . length ;    i    <    n ;    i +  +  )     {", "Method   method    =    methods [ i ]  ;", "if    ( method . getName (  )  . equals ( name )  )", "return   method ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   get (  \" default \"  ,    type )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )", "throw   new   IllegalArgumentException (  \" name   cannot   be   null .  \"  )  ;", "if    ( type    =  =    null )", "throw   new   IllegalArgumentException (  \" type   cannot   be   null .  \"  )  ;", "if    ( type    =  =     ( Drawable . class )  )", "return    (  ( T )     ( getDrawable ( name )  )  )  ;", "if    ( type    =  =     ( TextureRegion . class )  )", "return    (  ( T )     ( getRegion ( name )  )  )  ;", "if    ( type    =  =     ( NinePatch . class )  )", "return    (  ( T )     ( getPatch ( name )  )  )  ;", "if    ( type    =  =     ( Sprite . class )  )", "return    (  ( T )     ( getSprite ( name )  )  )  ;", "ObjectMap < String ,    Object >    typeResources    =    resources . get ( type )  ;", "if    ( typeResources    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" No    \"     +     ( type . getName (  )  )  )     +     \"    registered   with   name :     \"  )     +    name )  )  ;", "Object   resource    =    typeResources . get ( name )  ;", "if    ( resource    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" No    \"     +     ( type . getName (  )  )  )     +     \"    registered   with   name :     \"  )     +    name )  )  ;", "return    (  ( T )     ( resource )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ObjectMap < String ,    T >  )     ( resources . get ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   atlas ;", "}", "METHOD_END"], "methodName": ["getAtlas"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   get ( name ,    Color . class )  ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "Drawable   drawable    =    optional ( name ,    Drawable . class )  ;", "if    ( drawable    !  =    null )", "return   drawable ;", "try    {", "TextureRegion   textureRegion    =    getRegion ( name )  ;", "if    ( textureRegion   instanceof   TextureAtlas . AtlasRegion )     {", "TextureAtlas . AtlasRegion   region    =     (  ( TextureAtlas . AtlasRegion )     ( textureRegion )  )  ;", "if    (  ( region . splits )     !  =    null )", "drawable    =    new   tils . NinePatchDrawable ( getPatch ( name )  )  ;", "else", "if    (  (  ( region . rotate )     |  |     (  ( region . packedWidth )     !  =     ( region . originalWidth )  )  )     |  |     (  ( region . packedHeight )     !  =     ( region . originalHeight )  )  )", "drawable    =    new   tils . SpriteDrawable ( getSprite ( name )  )  ;", "}", "if    ( drawable    =  =    null )", "drawable    =    new   tils . TextureRegionDrawable ( textureRegion )  ;", "}    catch    ( GdxRuntimeException   ignored )     {", "}", "if    ( drawable    =  =    null )     {", "NinePatch   patch    =    optional ( name ,    NinePatch . class )  ;", "if    ( patch    !  =    null )", "drawable    =    new   tils . NinePatchDrawable ( patch )  ;", "else    {", "Sprite   sprite    =    optional ( name ,    Sprite . class )  ;", "if    ( sprite    !  =    null )", "drawable    =    new   tils . SpriteDrawable ( sprite )  ;", "else", "throw   new   GdxRuntimeException (  (  \" No   Drawable ,    NinePatch ,    TextureRegion ,    Texture ,    or   Sprite   registered   with   name :     \"     +    name )  )  ;", "}", "}", "if    ( drawable   instanceof   BaseDrawable )", "(  ( BaseDrawable )     ( drawable )  )  . setName ( name )  ;", "add ( name ,    drawable ,    Drawable . class )  ;", "return   drawable ;", "}", "METHOD_END"], "methodName": ["getDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   get ( name ,    BitmapFont . class )  ;", "}", "METHOD_END"], "methodName": ["getFont"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   jsonClassTags ;", "}", "METHOD_END"], "methodName": ["getJsonClassTags"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "final   Skin   skin    =    this ;", "final   Json   json    =    new   Json (  )     {", "private   static   final   String   parentFieldName    =     \" parent \"  ;", "public    < T >    T   readValue ( Class < T >    type ,    Class   elementType ,    JsonValue   jsonData )     {", "if    (  ( jsonData . isString (  )  )     &  &     (  !  ( ClassReflection . isAssignableFrom ( CharSequence . class ,    type )  )  )  )", "return   get ( jsonData . asString (  )  ,    type )  ;", "return   super . readValue ( type ,    elementType ,    jsonData )  ;", "}", "protected   boolean   ignoreUnknownField ( Class   type ,    String   fieldName )     {", "return   fieldName . equals ( parentFieldName )  ;", "}", "public   void   readFields ( Object   object ,    JsonValue   jsonMap )     {", "if    ( jsonMap . has ( parentFieldName )  )     {", "String   parentName    =    readValue ( parentFieldName ,    String . class ,    jsonMap )  ;", "Class   parentType    =    object . getClass (  )  ;", "while    ( true )     {", "try    {", "copyFields ( get ( parentName ,    parentType )  ,    object )  ;", "break ;", "}    catch    ( GdxRuntimeException   ex )     {", "parentType    =    parentType . getSuperclass (  )  ;", "if    ( parentType    =  =     ( Object . class )  )     {", "SerializationException   se    =    new   SerializationException (  (  \" Unable   to   find   parent   resource   with   name :     \"     +    parentName )  )  ;", "se . addTrace ( jsonMap . child . trace (  )  )  ;", "throw   se ;", "}", "}", "}", "}", "super . readFields ( object ,    jsonMap )  ;", "}", "}  ;", "json . setTypeName ( null )  ;", "json . setUsePrototypes ( false )  ;", "json . setSerializer ( Skin . class ,    new   Json . ReadOnlySerializer < Skin >  (  )     {", "public   Skin   read ( Json   json ,    JsonValue   typeToValueMap ,    Class   ignored )     {", "for    ( JsonValue   valueMap    =    typeToValueMap . child ;    valueMap    !  =    null ;    valueMap    =    valueMap . next )     {", "try    {", "Class   type    =    json . getClass ( valueMap . name (  )  )  ;", "if    ( type    =  =    null )", "type    =    ClassReflection . forName ( valueMap . name (  )  )  ;", "readNamedObjects ( json ,    type ,    valueMap )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}", "}", "return   skin ;", "}", "private   void   readNamedObjects ( Json   json ,    Class   type ,    JsonValue   valueMap )     {", "Class   addType    =     ( type    =  =     ( Skin . TintedDrawable . class )  )     ?    Drawable . class    :    type ;", "for    ( JsonValue   valueEntry    =    valueMap . child ;    valueEntry    !  =    null ;    valueEntry    =    valueEntry . next )     {", "Object   object    =    json . readValue ( type ,    valueEntry )  ;", "if    ( object    =  =    null )", "continue ;", "try    {", "add ( valueEntry . name ,    object ,    addType )  ;", "if    (  ( addType    !  =     ( Drawable . class )  )     &  &     ( ClassReflection . isAssignableFrom ( Drawable . class ,    addType )  )  )", "add ( valueEntry . name ,    object ,    Drawable . class )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SerializationException (  (  (  (  \" Error   reading    \"     +     ( ClassReflection . getSimpleName ( type )  )  )     +     \"  :     \"  )     +     ( valueEntry . name )  )  ,    ex )  ;", "}", "}", "}", "}  )  ;", "json . setSerializer ( BitmapFont . class ,    new   Json . ReadOnlySerializer < BitmapFont >  (  )     {", "public   BitmapFont   read ( Json   json ,    JsonValue   jsonData ,    Class   type )     {", "String   path    =    json . readValue (  \" file \"  ,    String . class ,    jsonData )  ;", "int   scaledSize    =    json . readValue (  \" scaledSize \"  ,    int . class ,     (  -  1  )  ,    jsonData )  ;", "Boolean   flip    =    json . readValue (  \" flip \"  ,    Boolean . class ,    false ,    jsonData )  ;", "Boolean   markupEnabled    =    json . readValue (  \" markupEnabled \"  ,    Boolean . class ,    false ,    jsonData )  ;", "FileHandle   fontFile    =    skinFile . parent (  )  . child ( path )  ;", "if    (  !  ( fontFile . exists (  )  )  )", "fontFile    =    Gdx . files . internal ( path )  ;", "if    (  !  ( fontFile . exists (  )  )  )", "throw   new   SerializationException (  (  \" Font   file   not   found :     \"     +    fontFile )  )  ;", "String   regionName    =    fontFile . nameWithoutExtension (  )  ;", "try    {", "BitmapFont   font ;", "Array < TextureRegion >    regions    =    skin . getRegions ( regionName )  ;", "if    ( regions    !  =    null )", "font    =    new   BitmapFont ( new   BitmapFont . BitmapFontData ( fontFile ,    flip )  ,    regions ,    true )  ;", "else    {", "TextureRegion   region    =    skin . optional ( regionName ,    TextureRegion . class )  ;", "if    ( region    !  =    null )", "font    =    new   BitmapFont ( fontFile ,    region ,    flip )  ;", "else    {", "FileHandle   imageFile    =    fontFile . parent (  )  . child (  ( regionName    +     \"  . png \"  )  )  ;", "if    ( imageFile . exists (  )  )", "font    =    new   BitmapFont ( fontFile ,    imageFile ,    flip )  ;", "else", "font    =    new   BitmapFont ( fontFile ,    flip )  ;", "}", "}", "font . getData (  )  . markupEnabled    =    markupEnabled ;", "if    ( scaledSize    !  =     (  -  1  )  )", "font . getData (  )  . setScale (  ( scaledSize    /     ( font . getCapHeight (  )  )  )  )  ;", "return   font ;", "}    catch    ( RuntimeException   ex )     {", "throw   new   SerializationException (  (  \" Error   loading   bitmap   font :     \"     +    fontFile )  ,    ex )  ;", "}", "}", "}  )  ;", "json . setSerializer ( Color . class ,    new   Json . ReadOnlySerializer < Color >  (  )     {", "public   Color   read ( Json   json ,    JsonValue   jsonData ,    Class   type )     {", "if    ( jsonData . isString (  )  )", "return   get ( jsonData . asString (  )  ,    Color . class )  ;", "String   hex    =    json . readValue (  \" hex \"  ,    String . class ,     (  ( String )     ( null )  )  ,    jsonData )  ;", "if    ( hex    !  =    null )", "return   Color . valueOf ( hex )  ;", "float   r    =    json . readValue (  \" r \"  ,    float . class ,     0  .  0 F ,    jsonData )  ;", "float   g    =    json . readValue (  \" g \"  ,    float . class ,     0  .  0 F ,    jsonData )  ;", "float   b    =    json . readValue (  \" b \"  ,    float . class ,     0  .  0 F ,    jsonData )  ;", "float   a    =    json . readValue (  \" a \"  ,    float . class ,     1  .  0 F ,    jsonData )  ;", "return   new   Color ( r ,    g ,    b ,    a )  ;", "}", "}  )  ;", "json . setSerializer ( Skin . TintedDrawable . class ,    new   Json . ReadOnlySerializer (  )     {", "public   Object   read ( Json   json ,    JsonValue   jsonData ,    Class   type )     {", "String   name    =    json . readValue (  \" name \"  ,    String . class ,    jsonData )  ;", "Color   color    =    json . readValue (  \" color \"  ,    Color . class ,    jsonData )  ;", "Drawable   drawable    =    newDrawable ( name ,    color )  ;", "if    ( drawable   instanceof   BaseDrawable )     {", "BaseDrawable   named    =     (  ( BaseDrawable )     ( drawable )  )  ;", "named . setName (  (  (  (  (  (  ( jsonData . name )     +     \"     (  \"  )     +    name )     +     \"  ,     \"  )     +    color )     +     \"  )  \"  )  )  ;", "}", "return   drawable ;", "}", "}  )  ;", "for    ( ObjectMap . Entry < String ,    Class >    entry    :    jsonClassTags )", "json . addClassTag ( entry . key ,    entry . value )  ;", "return   json ;", "}", "METHOD_END"], "methodName": ["getJsonLoader"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "NinePatch   patch    =    optional ( name ,    NinePatch . class )  ;", "if    ( patch    !  =    null )", "return   patch ;", "try    {", "TextureRegion   region    =    getRegion ( name )  ;", "if    ( region   instanceof   TextureAtlas . AtlasRegion )     {", "int [  ]    splits    =     (  ( TextureAtlas . AtlasRegion )     ( region )  )  . splits ;", "if    ( splits    !  =    null )     {", "patch    =    new   NinePatch ( region ,    splits [  0  ]  ,    splits [  1  ]  ,    splits [  2  ]  ,    splits [  3  ]  )  ;", "int [  ]    pads    =     (  ( TextureAtlas . AtlasRegion )     ( region )  )  . pads ;", "if    ( pads    !  =    null )", "patch . setPadding ( pads [  0  ]  ,    pads [  1  ]  ,    pads [  2  ]  ,    pads [  3  ]  )  ;", "}", "}", "if    ( patch    =  =    null )", "patch    =    new   NinePatch ( region )  ;", "add ( name ,    patch ,    NinePatch . class )  ;", "return   patch ;", "}    catch    ( GdxRuntimeException   ex )     {", "throw   new   GdxRuntimeException (  (  \" No   NinePatch ,    TextureRegion ,    or   Texture   registered   with   name :     \"     +    name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPatch"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "TextureRegion   region    =    optional ( name ,    TextureRegion . class )  ;", "if    ( region    !  =    null )", "return   region ;", "Texture   texture    =    optional ( name ,    Texture . class )  ;", "if    ( texture    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" No   TextureRegion   or   Texture   registered   with   name :     \"     +    name )  )  ;", "region    =    new   TextureRegion ( texture )  ;", "add ( name ,    region ,    TextureRegion . class )  ;", "return   region ;", "}", "METHOD_END"], "methodName": ["getRegion"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "Array < TextureRegion >    regions    =    null ;", "int   i    =     0  ;", "TextureRegion   region    =    optional (  (  ( regionName    +     \"  _  \"  )     +     ( i +  +  )  )  ,    TextureRegion . class )  ;", "if    ( region    !  =    null )     {", "regions    =    new   Array < TextureRegion >  (  )  ;", "while    ( region    !  =    null )     {", "regions . add ( region )  ;", "region    =    optional (  (  ( regionName    +     \"  _  \"  )     +     ( i +  +  )  )  ,    TextureRegion . class )  ;", "}", "}", "return   regions ;", "}", "METHOD_END"], "methodName": ["getRegions"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "Sprite   sprite    =    optional ( name ,    Sprite . class )  ;", "if    ( sprite    !  =    null )", "return   sprite ;", "try    {", "TextureReon   textureReon    =    getReon ( name )  ;", "if    ( textureReon   instanceof   TextureAtlas . AtlasReon )     {", "TextureAtlas . AtlasReon   reon    =     (  ( TextureAtlas . AtlasReon )     ( textureReon )  )  ;", "if    (  (  ( reon . rotate )     |  |     (  ( reon . packedWidth )     !  =     ( reon . orinalWidth )  )  )     |  |     (  ( reon . packedHeight )     !  =     ( reon . orinalHeight )  )  )", "sprite    =    new   TextureAtlas . AtlasSprite ( reon )  ;", "}", "if    ( sprite    =  =    null )", "sprite    =    new   Sprite ( textureReon )  ;", "add ( name ,    sprite ,    Sprite . class )  ;", "return   sprite ;", "}    catch    ( GdxRuntimeException   ex )     {", "throw   new   GdxRuntimeException (  (  \" No   NinePatch ,    TextureReon ,    or   Texture   restered   with   name :     \"     +    name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSprite"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "TiledDrawable   tiled    =    optional ( name ,    TiledDrawable . class )  ;", "if    ( tiled    !  =    null )", "return   tiled ;", "tiled    =    new   TiledDrawable ( getReon ( name )  )  ;", "tiled . setName ( name )  ;", "add ( name ,    tiled ,    TiledDrawable . class )  ;", "return   tiled ;", "}", "METHOD_END"], "methodName": ["getTiledDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    Object >    typeResources    =    resources . get ( type )  ;", "if    ( typeResources    =  =    null )", "return   false ;", "return   typeResources . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["has"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "try    {", "getJsonLoader ( skinFile )  . fromJson ( Skin . class ,    skinFile )  ;", "}    catch    ( SerializationException   ex )     {", "throw   new   SerializationException (  (  \" Error   reading   file :     \"     +    skinFile )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "if    ( drawable   instanceof   TiledDrawable )", "return   new   TiledDrawable (  (  ( TiledDrawable )     ( drawable )  )  )  ;", "if    ( drawable   instanceof   TextureRegionDrawable )", "return   new   TextureRegionDrawable (  (  ( TextureRegionDrawable )     ( drawable )  )  )  ;", "if    ( drawable   instanceof   NinePatchDrawable )", "return   new   NinePatchDrawable (  (  ( NinePatchDrawable )     ( drawable )  )  )  ;", "if    ( drawable   instanceof   SpriteDrawable )", "return   new   SpriteDrawable (  (  ( SpriteDrawable )     ( drawable )  )  )  ;", "throw   new   GdxRuntimeException (  (  \" Unable   to   copy ,    unknown   drawable   type :     \"     +     ( drawable . getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "Drawable   newDrawable ;", "if    ( drawable   instanceof   TextureRegionDrawable )", "newDrawable    =     (  ( TextureRegionDrawable )     ( drawable )  )  . tint ( tint )  ;", "else", "if    ( drawable   instanceof   tils . NinePatchDrawable )", "newDrawable    =     (  ( tils . NinePatchDrawable )     ( drawable )  )  . tint ( tint )  ;", "else", "if    ( drawable   instanceof   tils . SpriteDrawable )", "newDrawable    =     (  ( tils . SpriteDrawable )     ( drawable )  )  . tint ( tint )  ;", "else", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  \" Unable   to   copy ,    unknown   drawable   type :     \"     +     ( drawable . getClass (  )  )  )  )  ;", "if    ( newDrawable   instanceof   BaseDrawable )     {", "BaseDrawable   named    =     (  ( BaseDrawable )     ( newDrawable )  )  ;", "if    ( drawable   instanceof   BaseDrawable )", "named . setName (  (  (  (  (  (  ( BaseDrawable )     ( drawable )  )  . getName (  )  )     +     \"     (  \"  )     +    tint )     +     \"  )  \"  )  )  ;", "else", "named . setName (  (  (  \"     (  \"     +    tint )     +     \"  )  \"  )  )  ;", "}", "return   newDrawable ;", "}", "METHOD_END"], "methodName": ["newDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   newDrawable ( drawable ,    new   Color ( r ,    g ,    b ,    a )  )  ;", "}", "METHOD_END"], "methodName": ["newDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   newDrawable ( getDrawable ( name )  )  ;", "}", "METHOD_END"], "methodName": ["newDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   newDrawable ( getDrawable ( name )  ,    tint )  ;", "}", "METHOD_END"], "methodName": ["newDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "return   newDrawable ( getDrawable ( name )  ,    new   Color ( r ,    g ,    b ,    a )  )  ;", "}", "METHOD_END"], "methodName": ["newDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )", "throw   new   IllegalArgumentException (  \" name   cannot   be   null .  \"  )  ;", "if    ( type    =  =    null )", "throw   new   IllegalArgumentException (  \" type   cannot   be   null .  \"  )  ;", "ObjectMap < String ,    Object >    typeRurc =    rurcget ( type )  ;", "if    ( typeRurc =  =    null )", "return   null ;", "return    (  ( T )     ( typeRurcget ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["optional"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )", "throw   new   IllegalArgumentException (  \" name   cannot   be   null .  \"  )  ;", "ObjectMap < String ,    Object >    typeRurc =    rurcget ( type )  ;", "typeRurcremove ( name )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    Skin . findMethod ( actor . getClass (  )  ,     \" getStyle \"  )  ;", "if    ( method    =  =    null )", "return ;", "Object   style ;", "try    {", "style    =    method . invoke ( actor )  ;", "}    catch    ( Exception   ignored )     {", "return ;", "}", "String   name    =    find ( style )  ;", "if    ( name    =  =    null )", "return ;", "name    =     ( name . replace (  \"  - disabled \"  ,     \"  \"  )  )     +     ( enabled    ?     \"  \"     :     \"  - disabled \"  )  ;", "style    =    get ( name ,    style . getClass (  )  )  ;", "method    =    Skin . findMethod ( actor . getClass (  )  ,     \" setStyle \"  )  ;", "if    ( method    =  =    null )", "return ;", "try    {", "method . invoke ( actor ,    style )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Skin"}, {"methodBody": ["METHOD_START", "{", "final   Slider . SliderStyle   style    =    getStyle (  )  ;", "final   Drawable   knob    =    getKnobDrawable (  )  ;", "final   Drawable   bg    =     (  ( disabled )     &  &     (  ( style . disabledBackground )     !  =    null )  )     ?    style . disabledBackground    :    style . background ;", "float   value ;", "float   oldPosition    =    position ;", "final   float   min    =    getMinValue (  )  ;", "final   float   max    =    getMaxValue (  )  ;", "if    ( vertical )     {", "float   height    =     (  ( getHeight (  )  )     -     ( bg . getTopHeight (  )  )  )     -     ( bg . getBottomHeight (  )  )  ;", "float   knobHeight    =     ( knob    =  =    null )     ?     0     :    knob . getMinHeight (  )  ;", "position    =     ( y    -     ( bg . getBottomHeight (  )  )  )     -     ( knobHeight    *     0  .  5 F )  ;", "value    =    min    +     (  ( max    -    min )     *     ( visualInterpolationInverse . apply (  (  ( position )     /     ( height    -    knobHeight )  )  )  )  )  ;", "position    =    Math . max (  0  ,    position )  ;", "position    =    Math . min (  ( height    -    knobHeight )  ,    position )  ;", "} else    {", "float   width    =     (  ( getWidth (  )  )     -     ( bg . getLeftWidth (  )  )  )     -     ( bg . getRightWidth (  )  )  ;", "float   knobWidth    =     ( knob    =  =    null )     ?     0     :    knob . getMinWidth (  )  ;", "position    =     ( x    -     ( bg . getLeftWidth (  )  )  )     -     ( knobWidth    *     0  .  5 F )  ;", "value    =    min    +     (  ( max    -    min )     *     ( visualInterpolationInverse . apply (  (  ( position )     /     ( width    -    knobWidth )  )  )  )  )  ;", "position    =    Math . max (  0  ,    position )  ;", "position    =    Math . min (  ( width    -    knobWidth )  ,    position )  ;", "}", "float   oldValue    =    value ;", "if    (  (  !  ( Gdx . input . isKeyPressed ( Input . Keys . SHIFT _ LEFT )  )  )     &  &     (  !  ( Gdx . input . isKeyPressed ( Input . Keys . SHIFT _ RIGHT )  )  )  )", "value    =    snap ( value )  ;", "boolean   valueSet    =    setValue ( value )  ;", "if    ( value    =  =    oldValue )", "position    =    oldPosition ;", "return   valueSet ;", "}", "METHOD_END"], "methodName": ["calculatePositionAndValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "Slider . SliderStyle   style    =    getStyle (  )  ;", "return    ( disabled )     &  &     (  ( style . disabledKnob )     !  =    null )     ?    style . disabledKnob    :     ( isDragging (  )  )     &  &     (  ( style . knobDown )     !  =    null )     ?    style . knobDown    :     ( mouseOver )     &  &     (  ( style . knobOver )     !  =    null )     ?    style . knobOver    :    style . knob ;", "}", "METHOD_END"], "methodName": ["getKnobDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Slider . SliderStyle )     ( super . getStyle (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "return    ( draggingPointer )     !  =     (  -  1  )  ;", "}", "METHOD_END"], "methodName": ["isDragging"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "this . snapValues    =    values ;", "this . threshold    =    threshold ;", "}", "METHOD_END"], "methodName": ["setSnapToValues"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   NullPointerException (  \" style   cannot   be   null \"  )  ;", "if    (  !  ( style   instanceofStyle )  )", "throw   new   IllegalArgumentException (  \" style   must   be   aStyle .  \"  )  ;", "super . setStyle ( style )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "this . visualInterpolationInverse    =    interpolation ;", "}", "METHOD_END"], "methodName": ["setVisualInterpolationInverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( snapValu    =  =    null )", "return   value ;", "for    ( int   i    =     0  ;    i    <     ( snapValulength )  ;    i +  +  )     {", "if    (  ( Math . abs (  ( value    -     ( snapValui ]  )  )  )  )     <  =     ( throld )  )", "return   snapValui ]  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["snap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Slider"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   SplitPane # setWidget .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   SplitPane # setWidget .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorAt"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Use   SplitPane # setWidget .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addActorBefore"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "Drawable   handle    =    style . handle ;", "float   height    =    getHeight (  )  ;", "float   availWidth    =     ( getWidth (  )  )     -     ( handle . getMinWidth (  )  )  ;", "float   leftAreaWidth    =     (  ( int )     ( availWidth    *     ( sAmount )  )  )  ;", "float   rightAreaWidth    =    availWidth    -    leftAreaWidth ;", "float   handleWidth    =    handle . getMinWidth (  )  ;", "firstWidgetBounds . set (  0  ,     0  ,    leftAreaWidth ,    height )  ;", "secondWidgetBounds . set (  ( leftAreaWidth    +    handleWidth )  ,     0  ,    rightAreaWidth ,    height )  ;", "handleBounds . set ( leftAreaWidth ,     0  ,    handleWidth ,    height )  ;", "}", "METHOD_END"], "methodName": ["calculateHorizBoundsAndPositions"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "Drawable   handle    =    style . handle ;", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "float   availHeight    =    height    -     ( handle . getMinHeight (  )  )  ;", "float   topAreaHeight    =     (  ( int )     ( availHeight    *     ( sAmount )  )  )  ;", "float   bottomAreaHeight    =    availHeight    -    topAreaHeight ;", "float   handleHeight    =    handle . getMinHeight (  )  ;", "firstWidgetBounds . set (  0  ,     ( height    -    topAreaHeight )  ,    width ,    topAreaHeight )  ;", "secondWidgetBounds . set (  0  ,     0  ,    width ,    bottomAreaHeight )  ;", "handleBounds . set (  0  ,    bottomAreaHeight ,    width ,    handleHeight )  ;", "}", "METHOD_END"], "methodName": ["calculateVertBoundsAndPositions"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "float   effectiveMinAmount    =    minAmount ;", "float   effectiveMaxAmount    =    maxAmount ;", "if    ( vertical )     {", "float   availableHeight    =     ( getHeight (  )  )     -     ( style . handle . getMinHeight (  )  )  ;", "if    (  ( firstWidget )    instanceof   Layout )", "effectiveMinAmount    =    Math . max ( effectiveMinAmount ,    Math . min (  (  (  (  ( Layout )     ( firstWidget )  )  . getMinHeight (  )  )     /    availableHeight )  ,     1  )  )  ;", "if    (  ( secondWidget )    instanceof   Layout )", "effectiveMaxAmount    =    Math . min ( effectiveMaxAmount ,     (  1     -     ( Math . min (  (  (  (  ( Layout )     ( secondWidget )  )  . getMinHeight (  )  )     /    availableHeight )  ,     1  )  )  )  )  ;", "} else    {", "float   availableWidth    =     ( getWidth (  )  )     -     ( style . handle . getMinWidth (  )  )  ;", "if    (  ( firstWidget )    instanceof   Layout )", "effectiveMinAmount    =    Math . max ( effectiveMinAmount ,    Math . min (  (  (  (  ( Layout )     ( firstWidget )  )  . getMinWidth (  )  )     /    availableWidth )  ,     1  )  )  ;", "if    (  ( secondWidget )    instanceof   Layout )", "effectiveMaxAmount    =    Math . min ( effectiveMaxAmount ,     (  1     -     ( Math . min (  (  (  (  ( Layout )     ( secondWidget )  )  . getMinWidth (  )  )     /    availableWidth )  ,     1  )  )  )  )  ;", "}", "if    ( effectiveMinAmount    >    effectiveMaxAmount )", "sAmount    =     0  .  5 F    *     ( effectiveMinAmount    +    effectiveMaxAmount )  ;", "else", "sAmount    =    Math . max ( Math . min ( sAmount ,    effectiveMaxAmount )  ,    effectiveMinAmount )  ;", "}", "METHOD_END"], "methodName": ["clampSplitAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "return   maxAmount ;", "}", "METHOD_END"], "methodName": ["getMaxSplitAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "float   first    =     (  ( firstWidget )    instanceof   Layout )     ?     (  ( Layout )     ( firstWidget )  )  . getMinHeight (  )     :     0  ;", "float   second    =     (  ( secondWidget )    instanceof   Layout )     ?     (  ( Layout )     ( secondWidget )  )  . getMinHeight (  )     :     0  ;", "if    (  !  ( vertical )  )", "return   Math . max ( first ,    second )  ;", "return    ( first    +     ( style . handle . getMinHeight (  )  )  )     +    second ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "return   minAmount ;", "}", "METHOD_END"], "methodName": ["getMinSplitAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "float   first    =     (  ( firstWidget )    instanceof   Layout )     ?     (  ( Layout )     ( firstWidget )  )  . getMinWidth (  )     :     0  ;", "float   second    =     (  ( secondWidget )    instanceof   Layout )     ?     (  ( Layout )     ( secondWidget )  )  . getMinWidth (  )     :     0  ;", "if    ( vertical )", "return   Math . max ( first ,    second )  ;", "return    ( first    +     ( style . handle . getMinWidth (  )  )  )     +    second ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "return   splitAmount ;", "}", "METHOD_END"], "methodName": ["getSplitAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "addListener ( new   InputListener (  )     {", "int   draggingPointer    =     -  1  ;", "public   boolean   touchDown ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "if    (  ( draggingPointer )     !  =     (  -  1  )  )", "return   false ;", "if    (  ( pointer    =  =     0  )     &  &     ( button    !  =     0  )  )", "return   false ;", "if    ( handleBounds . contains ( x ,    y )  )     {", "draggingPointer    =    pointer ;", "lastPoint . set ( x ,    y )  ;", "handlePosition . set ( handleBounds . x ,    handleBounds . y )  ;", "return   true ;", "}", "return   false ;", "}", "public   void   touchUp ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    int   button )     {", "if    ( pointer    =  =     ( draggingPointer )  )", "draggingPointer    =     -  1  ;", "}", "public   void   touchDragged ( InputEvent   event ,    float   x ,    float   y ,    int   pointer )     {", "if    ( pointer    !  =     ( draggingPointer )  )", "return ;", "Drawable   handle    =    style . handle ;", "if    (  !  ( vertical )  )     {", "float   delta    =    x    -     ( lastPoint . x )  ;", "float   availWidth    =     ( getWidth (  )  )     -     ( handle . getMinWidth (  )  )  ;", "float   dragX    =     ( handlePosition . x )     +    delta ;", "handlePosition . x    =    dragX ;", "dragX    =    Math . max (  0  ,    dragX )  ;", "dragX    =    Math . min ( availWidth ,    dragX )  ;", "sAmount    =    dragX    /    availWidth ;", "lastPoint . set ( x ,    y )  ;", "} else    {", "float   delta    =    y    -     ( lastPoint . y )  ;", "float   availHeight    =     ( getHeight (  )  )     -     ( handle . getMinHeight (  )  )  ;", "float   dragY    =     ( handlePosition . y )     +    delta ;", "handlePosition . y    =    dragY ;", "dragY    =    Math . max (  0  ,    dragY )  ;", "dragY    =    Math . min ( availHeight ,    dragY )  ;", "sAmount    =     1     -     ( dragY    /    availHeight )  ;", "lastPoint . set ( x ,    y )  ;", "}", "invalidate (  )  ;", "}", "public   boolean   mouseMoved ( InputEvent   event ,    float   x ,    float   y )     {", "cursorOverHandle    =    handleBounds . contains ( x ,    y )  ;", "return   false ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "return   cursorOverHandle ;", "}", "METHOD_END"], "methodName": ["isCursorOverHandle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "return   vertical ;", "}", "METHOD_END"], "methodName": ["isVertical"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentExption (  \" actor   cannot   be   null .  \"  )  ;", "if    ( actor    =  =     ( firstWidget )  )     {", "setFirstWidget ( null )  ;", "return   true ;", "}", "if    ( actor    =  =     ( secondWidget )  )     {", "setSecondWidget ( null )  ;", "return   true ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentExption (  \" actor   cannot   be   null .  \"  )  ;", "if    ( actor    =  =     ( firstWidget )  )     {", "super . removeActor ( actor ,    unfocus )  ;", "firstWidget    =    null ;", "invalidate (  )  ;", "return   true ;", "}", "if    ( actor    =  =     ( secondWidget )  )     {", "super . removeActor ( actor ,    unfocus )  ;", "secondWidget    =    null ;", "invalidate (  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( firstWidget )     !  =    null )", "super . removeActor ( firstWidget )  ;", "firstWidget    =    widget ;", "if    ( widget    !  =    null )", "super . dActor ( widget )  ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setFirstWidget"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( maxAmount    <     0  )     |  |     ( maxAmount    >     1  )  )", "throw   new   utils . GdxRuntimeException (  \" maxAmount   has   to   be    >  =     0    and    <  =     1  \"  )  ;", "this . maxAmount    =    maxAmount ;", "}", "METHOD_END"], "methodName": ["setMaxSplitAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( minAmount    <     0  )     |  |     ( minAmount    >     1  )  )", "throw   new   utils . GdxRuntimeException (  \" minAmount   has   to   be    >  =     0    and    <  =     1  \"  )  ;", "this . minAmount    =    minAmount ;", "}", "METHOD_END"], "methodName": ["setMinSplitAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( secondWidget )     !  =    null )", "super . removeActor ( secondWidget )  ;", "secondWidget    =    widget ;", "if    ( widget    !  =    null )", "super . addActor ( widget )  ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setSecondWidget"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "this . splitAmount    =    splitAmount ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setSplitAmount"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "this . style    =    style ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . vertical )     =  =    vertical )", "return ;", "this . vertical    =    vertical ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setVertical"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.SplitPane"}, {"methodBody": ["METHOD_START", "{", "addActor ( actor )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "sizeInvalid    =    false ;", "prefWidth    =     0  ;", "prefHeight    =     0  ;", "minWidth    =     0  ;", "minHeight    =     0  ;", "maxWidth    =     0  ;", "maxHeight    =     0  ;", "SnapshotArray < Actor >    childr    =    getChildr (  )  ;", "for    ( int   i    =     0  ,    n    =    childr . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    childr . get ( i )  ;", "float   childMaxWidth ;", "float   childMaxHeight ;", "if    ( child   instanceof   Layout )     {", "Layout   layout    =     (  ( Layout )     ( child )  )  ;", "prefWidth    =    Math . max ( prefWidth ,    layout . getPrefWidth (  )  )  ;", "prefHeight    =    Math . max ( prefHeight ,    layout . getPrefHeight (  )  )  ;", "minWidth    =    Math . max ( minWidth ,    layout . getMinWidth (  )  )  ;", "minHeight    =    Math . max ( minHeight ,    layout . getMinHeight (  )  )  ;", "childMaxWidth    =    layout . getMaxWidth (  )  ;", "childMaxHeight    =    layout . getMaxHeight (  )  ;", "} else    {", "prefWidth    =    Math . max ( prefWidth ,    child . getWidth (  )  )  ;", "prefHeight    =    Math . max ( prefHeight ,    child . getHeight (  )  )  ;", "minWidth    =    Math . max ( minWidth ,    child . getWidth (  )  )  ;", "minHeight    =    Math . max ( minHeight ,    child . getHeight (  )  )  ;", "childMaxWidth    =     0  ;", "childMaxHeight    =     0  ;", "}", "if    ( childMaxWidth    >     0  )", "maxWidth    =     (  ( maxWidth )     =  =     0  )     ?    childMaxWidth    :    Math . min ( maxWidth ,    childMaxWidth )  ;", "if    ( childMaxHeight    >     0  )", "maxHeight    =     (  ( maxHeight )     =  =     0  )     ?    childMaxHeight    :    Math . min ( maxHeight ,    childMaxHeight )  ;", "}", "}", "METHOD_END"], "methodName": ["computeSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   maxHeight ;", "}", "METHOD_END"], "methodName": ["getMaxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   maxWidth ;", "}", "METHOD_END"], "methodName": ["getMaxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   minHeight ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   minWidth ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "super . invalidate (  )  ;", "sizeInvalid    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "Array < Actor >    children    =    getChildren (  )  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    children . get ( i )  ;", "child . setBounds (  0  ,     0  ,    width ,    height )  ;", "if    ( child   instanceof   Layout )", "(  ( Layout )     ( child )  )  . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Stack"}, {"methodBody": ["METHOD_START", "{", "return   add (  (  ( Actor )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Cell < T >    cell    =    obtainCell (  )  ;", "cell . actor    =    actor ;", "if    ( implicitEndRow )     {", "implicitEndRow    =    false ;", "( rows )  -  -  ;", "cells . peek (  )  . endRow    =    false ;", "}", "Array < Cell >    cells    =    this . cells ;", "int   cellCount    =    cellize ;", "if    ( cellCount    >     0  )     {", "Cell   lastCell    =    cells . peek (  )  ;", "if    (  !  ( lastCell . endRow )  )     {", "cell . column    =     ( lastCell . column )     +     ( lastCell . colspan )  ;", "cell . row    =    lastCell . row ;", "} else    {", "cell . column    =     0  ;", "cell . row    =     ( lastCell . row )     +     1  ;", "}", "if    (  ( cell . row )     >     0  )     {", "outer    :    for    ( int   i    =    cellCount    -     1  ;    i    >  =     0  ;    i -  -  )     {", "Cell   other    =    cells . get ( i )  ;", "for    ( int   column    =    other . column ,    nn    =    column    +     ( other . colspan )  ;    column    <    nn ;    column +  +  )     {", "if    ( column    =  =     ( cell . column )  )     {", "cell . cellAboveIndex    =    i ;", "break   outer ;", "}", "}", "}", "}", "} else    {", "cell . column    =     0  ;", "cell . row    =     0  ;", "}", "cells . add ( cell )  ;", "cell . set ( cellDefaults )  ;", "if    (  ( cell . column )     <     ( columnDefaultize )  )     {", "Cell   columnCell    =    columnDefaults . get ( cell . column )  ;", "if    ( columnCell    !  =    null )", "cell . merge ( columnCell )  ;", "}", "cell . merge ( rowDefaults )  ;", "if    ( actor    !  =    null )", "addActor ( actor )  ;", "return   cell ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    actors . length ;    i    <    n ;    i +  +  )", "add ( actors [ i ]  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( skin )     =  =    null )", "throw   new   IllegalStateException (  \"    must   have   a   skin   set   to   use   this   method .  \"  )  ;", "return   add ( new   Label ( text ,    skin )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( skin )     =  =    null )", "throw   new   IllegalStateException (  \"    must   have   a   skin   set   to   use   this   method .  \"  )  ;", "return   add ( new   Label ( text ,    skin . get ( labelStyleName ,    Label . LabelStyle . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( skin )     =  =    null )", "throw   new   IllegalStateException (  \"    must   have   a   skin   set   to   use   this   method .  \"  )  ;", "return   add ( new   Label ( text ,    new   Label . LabelStyle ( skin . getFont ( fontName )  ,    color )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( skin )     =  =    null )", "throw   new   IllegalStateException (  \"    must   have   a   skin   set   to   use   this   method .  \"  )  ;", "return   add ( new   Label ( text ,    new   Label . LabelStyle ( skin . getFont ( fontName )  ,    skin . getColor ( colorName )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( debugRects )     =  =    null )", "debugRects    =    new   utils . Array (  )  ;", "Table . DebugRect   rect    =    Table . DebugRect . pool . obtain (  )  ;", "rect . color    =    color ;", "rect . set ( x ,     (  (  ( getHeight (  )  )     -    y )     -    h )  ,    w ,    h )  ;", "debugRects . add ( rect )  ;", "}", "METHOD_END"], "methodName": ["addDebugRect"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "this . align    =    align ;", "return   this ;", "}", "METHOD_END"], "methodName": ["align"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "setBackground ( background )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["background"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "setBackground ( drawableName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["background"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . bottom ;", "align    &  =     ~  ( Align . top )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "align    =    Align . center ;", "return   this ;", "}", "METHOD_END"], "methodName": ["center"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Array < Cell >    cells    =    this . cells ;", "for    ( int   i    =     ( cells . size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "Cell   cell    =    cells . get ( i )  ;", "Actor   actor    =    cell . actor ;", "if    ( actor    !  =    null )", "actor . remove (  )  ;", "}", ". cellPool . freeAll ( cells )  ;", "cells . clear (  )  ;", "rows    =     0  ;", "columns    =     0  ;", "if    (  ( rowDefaults )     !  =    null )", ". cellPool . free ( rowDefaults )  ;", "rowDefaults    =    null ;", "implicitEndRow    =    false ;", "super . clearChildren (  )  ;", "}", "METHOD_END"], "methodName": ["clearChildren"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( debugRects )     =  =    null )", "return ;", ". DebugRect . pool . freeAll ( debugRects )  ;", "debugRects . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearDebugRects"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Cell   cell    =     (  ( columnDefaults . size )     >    column )     ?    columnDefaults . get ( column )     :    null ;", "if    ( cell    =  =    null )     {", "cell    =    obtainCell (  )  ;", "cell . clear (  )  ;", "if    ( column    >  =     ( columnDefaults . size )  )     {", "for    ( int   i    =    columnDefaults . size ;    i    <    column ;    i +  +  )", "columnDefaults . add ( null )  ;", "columnDefaults . add ( cell )  ;", "} else", "columnDefaults . set ( column ,    cell )  ;", "}", "return   cell ;", "}", "METHOD_END"], "methodName": ["columnDefaults"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "sizeInvalid    =    false ;", "Array < Cell >    cells    =    this . cells ;", "int   cellCount    =    cells . size ;", "if    (  ( cellCount    >     0  )     &  &     (  !  ( cells . peek (  )  . endRow )  )  )     {", "endRow (  )  ;", "implicitEndRow    =    true ;", "}", "int   columns    =    this . columns ;", "int   rows    =    this . rows ;", "float [  ]    columnMinWidth    =    this . columnMinWidth    =    ensureSize ( this . columnMinWidth ,    columns )  ;", "float [  ]    rowMinHeight    =    this . rowMinHeight    =    ensureSize ( this . rowMinHeight ,    rows )  ;", "float [  ]    columnPrefWidth    =    this . columnPrefWidth    =    ensureSize ( this . columnPrefWidth ,    columns )  ;", "float [  ]    rowPrefHeight    =    this . rowPrefHeight    =    ensureSize ( this . rowPrefHeight ,    rows )  ;", "float [  ]    columnWidth    =    this . columnWidth    =    ensureSize ( this . columnWidth ,    columns )  ;", "float [  ]    rowHeight    =    this . rowHeight    =    ensureSize ( this . rowHeight ,    rows )  ;", "float [  ]    expandWidth    =    this . expandWidth    =    ensureSize ( this . expandWidth ,    columns )  ;", "float [  ]    expandHeight    =    this . expandHeight    =    ensureSize ( this . expandHeight ,    rows )  ;", "float   spaceRightLast    =     0  ;", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "int   column    =    c . column ;", "int   row    =    c . row ;", "int   colspan    =    c . colspan ;", "Actor   a    =    c . actor ;", "if    (  (  ( c . expandY )     !  =     0  )     &  &     (  ( expandHeight [ row ]  )     =  =     0  )  )", "expandHeight [ row ]     =    c . expandY ;", "if    (  (  ( colspan    =  =     1  )     &  &     (  ( c . expandX )     !  =     0  )  )     &  &     (  ( expandWidth [ column ]  )     =  =     0  )  )", "expandWidth [ column ]     =    c . expandX ;", "c . computedPadLeft    =     ( c . padLeft . get ( a )  )     +     ( column    =  =     0     ?     0     :    Math . max (  0  ,     (  ( c . spaceLeft . get ( a )  )     -    spaceRightLast )  )  )  ;", "c . computedPadTop    =    c . padTop . get ( a )  ;", "if    (  ( c . cellAboveIndex )     !  =     (  -  1  )  )     {", "Cell   above    =    cells . get ( c . cellAboveIndex )  ;", "c . computedPadTop    +  =    Math . max (  0  ,     (  ( c . spaceTop . get ( a )  )     -     ( above . spaceBottom . get ( a )  )  )  )  ;", "}", "float   spaceRight    =    c . spaceRight . get ( a )  ;", "c . computedPadRight    =     ( c . padRight . get ( a )  )     +     (  ( column    +    colspan )     =  =    columns    ?     0     :    spaceRight )  ;", "c . computedPadBottom    =     ( c . padBottom . get ( a )  )     +     ( row    =  =     ( rows    -     1  )     ?     0     :    c . spaceBottom . get ( a )  )  ;", "spaceRightLast    =    spaceRight ;", "float   prefWidth    =    c . prefWidth . get ( a )  ;", "float   prefHeight    =    c . prefHeight . get ( a )  ;", "float   minWidth    =    c . minWidth . get ( a )  ;", "float   minHeight    =    c . minHeight . get ( a )  ;", "float   maxWidth    =    c . maxWidth . get ( a )  ;", "float   maxHeight    =    c . maxHeight . get ( a )  ;", "if    ( prefWidth    <    minWidth )", "prefWidth    =    minWidth ;", "if    ( prefHeight    <    minHeight )", "prefHeight    =    minHeight ;", "if    (  ( maxWidth    >     0  )     &  &     ( prefWidth    >    maxWidth )  )", "prefWidth    =    maxWidth ;", "if    (  ( maxHeight    >     0  )     &  &     ( prefHeight    >    maxHeight )  )", "prefHeight    =    maxHeight ;", "if    ( colspan    =  =     1  )     {", "float   hpadding    =     ( c . computedPadLeft )     +     ( c . computedPadRight )  ;", "columnPrefWidth [ column ]     =    Math . max ( columnPrefWidth [ column ]  ,     ( prefWidth    +    hpadding )  )  ;", "columnMinWidth [ column ]     =    Math . max ( columnMinWidth [ column ]  ,     ( minWidth    +    hpadding )  )  ;", "}", "float   vpadding    =     ( c . computedPadTop )     +     ( c . computedPadBottom )  ;", "rowPrefHeight [ row ]     =    Math . max ( rowPrefHeight [ row ]  ,     ( prefHeight    +    vpadding )  )  ;", "rowMinHeight [ row ]     =    Math . max ( rowMinHeight [ row ]  ,     ( minHeight    +    vpadding )  )  ;", "}", "float   uniformMinWidth    =     0  ;", "float   uniformMinHeight    =     0  ;", "float   uniformPrefWidth    =     0  ;", "float   uniformPrefHeight    =     0  ;", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "int   column    =    c . column ;", "int   expandX    =    c . expandX ;", "outer    :    if    ( expandX    !  =     0  )     {", "int   nn    =    column    +     ( c . colspan )  ;", "for    ( int   ii    =    column ;    ii    <    nn ;    ii +  +  )", "if    (  ( expandWidth [ ii ]  )     !  =     0  )", "break   outer ;", "for    ( int   ii    =    column ;    ii    <    nn ;    ii +  +  )", "expandWidth [ ii ]     =    expandX ;", "}", "if    (  (  ( c . uniformX )     =  =     ( Boolean . TRUE )  )     &  &     (  ( c . colspan )     =  =     1  )  )     {", "float   hpadding    =     ( c . computedPadLeft )     +     ( c . computedPadRight )  ;", "uniformMinWidth    =    Math . max ( uniformMinWidth ,     (  ( columnMinWidth [ column ]  )     -    hpadding )  )  ;", "uniformPrefWidth    =    Math . max ( uniformPrefWidth ,     (  ( columnPrefWidth [ column ]  )     -    hpadding )  )  ;", "}", "if    (  ( c . uniformY )     =  =     ( Boolean . TRUE )  )     {", "float   vpadding    =     ( c . computedPadTop )     +     ( c . computedPadBottom )  ;", "uniformMinHeight    =    Math . max ( uniformMinHeight ,     (  ( rowMinHeight [ c . row ]  )     -    vpadding )  )  ;", "uniformPrefHeight    =    Math . max ( uniformPrefHeight ,     (  ( rowPrefHeight [ c . row ]  )     -    vpadding )  )  ;", "}", "}", "if    (  ( uniformPrefWidth    >     0  )     |  |     ( uniformPrefHeight    >     0  )  )     {", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "if    (  (  ( uniformPrefWidth    >     0  )     &  &     (  ( c . uniformX )     =  =     ( Boolean . TRUE )  )  )     &  &     (  ( c . colspan )     =  =     1  )  )     {", "float   hpadding    =     ( c . computedPadLeft )     +     ( c . computedPadRight )  ;", "columnMinWidth [ c . column ]     =    uniformMinWidth    +    hpadding ;", "columnPrefWidth [ c . column ]     =    uniformPrefWidth    +    hpadding ;", "}", "if    (  ( uniformPrefHeight    >     0  )     &  &     (  ( c . uniformY )     =  =     ( Boolean . TRUE )  )  )     {", "float   vpadding    =     ( c . computedPadTop )     +     ( c . computedPadBottom )  ;", "rowMinHeight [ c . row ]     =    uniformMinHeight    +    vpadding ;", "rowPrefHeight [ c . row ]     =    uniformPrefHeight    +    vpadding ;", "}", "}", "}", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "int   colspan    =    c . colspan ;", "if    ( colspan    =  =     1  )", "continue ;", "int   column    =    c . column ;", "Actor   a    =    c . actor ;", "float   minWidth    =    c . minWidth . get ( a )  ;", "float   prefWidth    =    c . prefWidth . get ( a )  ;", "float   maxWidth    =    c . maxWidth . get ( a )  ;", "if    ( prefWidth    <    minWidth )", "prefWidth    =    minWidth ;", "if    (  ( maxWidth    >     0  )     &  &     ( prefWidth    >    maxWidth )  )", "prefWidth    =    maxWidth ;", "float   spannedMinWidth    =     -  (  ( c . computedPadLeft )     +     ( c . computedPadRight )  )  ;", "float   spannedPrefWidth    =    spannedMinWidth ;", "float   totalExpandWidth    =     0  ;", "for    ( int   ii    =    column ,    nn    =    ii    +    colspan ;    ii    <    nn ;    ii +  +  )     {", "spannedMinWidth    +  =    columnMinWidth [ ii ]  ;", "spannedPrefWidth    +  =    columnPrefWidth [ ii ]  ;", "totalExpandWidth    +  =    expandWidth [ ii ]  ;", "}", "float   extraMinWidth    =    Math . max (  0  ,     ( minWidth    -    spannedMinWidth )  )  ;", "float   extraPrefWidth    =    Math . max (  0  ,     ( prefWidth    -    spannedPrefWidth )  )  ;", "for    ( int   ii    =    column ,    nn    =    ii    +    colspan ;    ii    <    nn ;    ii +  +  )     {", "float   ratio    =     ( totalExpandWidth    =  =     0  )     ?     1  .  0 F    /    colspan    :     ( expandWidth [ ii ]  )     /    totalExpandWidth ;", "columnMinWidth [ ii ]     +  =    extraMinWidth    *    ratio ;", "columnPrefWidth [ ii ]     +  =    extraPrefWidth    *    ratio ;", "}", "}", "tMinWidth    =     0  ;", "tMinHeight    =     0  ;", "tPrefWidth    =     0  ;", "tPrefHeight    =     0  ;", "for    ( int   i    =     0  ;    i    <    columns ;    i +  +  )     {", "tMinWidth    +  =    columnMinWidth [ i ]  ;", "tPrefWidth    +  =    columnPrefWidth [ i ]  ;", "}", "for    ( int   i    =     0  ;    i    <    rows ;    i +  +  )     {", "tMinHeight    +  =    rowMinHeight [ i ]  ;", "tPrefHeight    +  =    Math . max ( rowMinHeight [ i ]  ,    rowPrefHeight [ i ]  )  ;", "}", "float   hpadding    =     ( padLeft . get ( this )  )     +     ( padRight . get ( this )  )  ;", "float   vpadding    =     ( padTop . get ( this )  )     +     ( padBottom . get ( this )  )  ;", "tMinWidth    =     ( tMinWidth )     +    hpadding ;", "tMinHeight    =     ( tMinHeight )     +    vpadding ;", "tPrefWidth    =    Math . max (  (  ( tPrefWidth )     +    hpadding )  ,    tMinWidth )  ;", "tPrefHeight    =    Math . max (  (  ( tPrefHeight )     +    vpadding )  ,    tMinHeight )  ;", "}", "METHOD_END"], "methodName": ["computeSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "super . debug (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["debug"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "super . setDebug (  ( debug    !  =     ( Table . Debug . none )  )  )  ;", "if    (  ( this . debug )     !  =    debug )     {", "this . debug    =    debug ;", "if    ( debug    =  =     ( Table . Debug . none )  )", "clearDebugRects (  )  ;", "else", "invalidate (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["debug"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "super . setDebug ( true )  ;", "if    (  ( debug )     !  =     (  . Debug . actor )  )     {", "this . debug    =     . Debug . actor ;", "invalidate (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["debugActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "super . debugAll (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["debugAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "super . setDebug ( true )  ;", "if    (  ( debug )     !  =     (  . Debug . cell )  )     {", "this . debug    =     . Debug . cell ;", "invalidate (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["debugCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "super . setDebug ( true )  ;", "if    (  ( debug )     !  =     (  . Debug . table )  )     {", "this . debug    =     . Debug . table ;", "invalidate (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["debugTable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   cellDefaults ;", "}", "METHOD_END"], "methodName": ["defaults"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "if    ( isTransform (  )  )     {", "applyTransform ( batch ,    puteTransform (  )  )  ;", "drawBackground ( batch ,    a ,     0  ,     0  )  ;", "if    ( clip )     {", "batch . flush (  )  ;", "float   padLeft    =    this . padLeft . get ( this )  ;", "float   padBottom    =    this . padBottom . get ( this )  ;", "if    ( clipBegin ( padLeft ,    padBottom ,     (  (  ( getWidth (  )  )     -    padLeft )     -     ( padRight . get ( this )  )  )  ,     (  (  ( getHeight (  )  )     -    padBottom )     -     ( padTop . get ( this )  )  )  )  )     {", "drawChildren ( batch ,    a )  ;", "batch . flush (  )  ;", "clipEnd (  )  ;", "}", "} else", "drawChildren ( batch ,    a )  ;", "resetTransform ( batch )  ;", "} else    {", "drawBackground ( batch ,    a ,    getX (  )  ,    getY (  )  )  ;", "super . draw ( batch ,    a )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( background )     =  =    null )", "return ;", "Color   color    =    getColor (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,     (  ( color . a )     *    a )  )  ;", "background . draw ( batch ,    x ,    y ,    getWidth (  )  ,    getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( isTransform (  )  )     {", "applyTransform ( shapes ,    puteTransform (  )  )  ;", "drawDebugRects ( shapes )  ;", "if    ( clip )     {", "shapes . flush (  )  ;", "float   x    =     0  ;", "float   y    =     0  ;", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "if    (  ( background )     !  =    null )     {", "x    =    padLeft . get ( this )  ;", "y    =    padBottom . get ( this )  ;", "width    -  =    x    +     ( padRight . get ( this )  )  ;", "height    -  =    y    +     ( padTop . get ( this )  )  ;", "}", "if    ( clipBegin ( x ,    y ,    width ,    height )  )     {", "drawDebugChildren ( shapes )  ;", "clipEnd (  )  ;", "}", "} else", "drawDebugChildren ( shapes )  ;", "resetTransform ( shapes )  ;", "} else    {", "drawDebugRects ( shapes )  ;", "super . drawDebug ( shapes )  ;", "}", "}", "METHOD_END"], "methodName": ["drawDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( debugRects )     =  =    null )     |  |     (  !  ( getDebug (  )  )  )  )", "return ;", "shapes . set ( ShapeRenderer . ShapeType . Line )  ;", "shapes . setColor ( getStage (  )  . getDebugColor (  )  )  ;", "float   x    =     0  ;", "float   y    =     0  ;", "if    (  !  ( isTransform (  )  )  )     {", "x    =    getX (  )  ;", "y    =    getY (  )  ;", "}", "for    ( int   i    =     0  ,    n    =    debugRects . size ;    i    <    n ;    i +  +  )     {", ". DebugRect   debugRect    =    debugRects . get ( i )  ;", "shapes . setColor ( debugRect . color )  ;", "shapes . rect (  ( x    +     ( debugRect . x )  )  ,     ( y    +     ( debugRect . y )  )  ,    debugRect . width ,    debugRect . height )  ;", "}", "}", "METHOD_END"], "methodName": ["drawDebugRects"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Array < Cell >    cells    =    this . cells ;", "int   rowColumns    =     0  ;", "for    ( int   i    =     ( cellize )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "Cell   cell    =    cells . get ( i )  ;", "if    ( cell . endRow )", "break ;", "rowColumns    +  =    cell . colspan ;", "}", "columns    =    Math . max ( columns ,    rowColumns )  ;", "( rows )  +  +  ;", "cells . peek (  )  . endRow    =    true ;", "}", "METHOD_END"], "methodName": ["endRow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( array    =  =    null )     |  |     (  ( array . length )     <    size )  )", "return   new   float [ size ]  ;", "for    ( int   i    =     0  ,    n    =    array . length ;    i    <    n ;    i +  +  )", "array [ i ]     =     0  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["ensureSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   align ;", "}", "METHOD_END"], "methodName": ["getAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   background ;", "}", "METHOD_END"], "methodName": ["getBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Array < Cell >    cells    =    this . cells ;", "for    ( int   i    =     0  ,    n    =    cellize ;    i    <    n ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "if    (  ( c . actor )     =  =    actor )", "return   c ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   cells ;", "}", "METHOD_END"], "methodName": ["getCells"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   clip ;", "}", "METHOD_END"], "methodName": ["getClip"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   columnMinWidth [ columnIndex ]  ;", "}", "METHOD_END"], "methodName": ["getColumnMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   columnPrefWidth [ columnIndex ]  ;", "}", "METHOD_END"], "methodName": ["getColumnPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( columnWidth )     =  =    null )", "return    0  ;", "return   columnWidth [ columnIndex ]  ;", "}", "METHOD_END"], "methodName": ["getColumnWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   columns ;", "}", "METHOD_END"], "methodName": ["getColumns"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "computeSize (  )  ;", "return   tMinHeight ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "computeSize (  )  ;", "return   tMinWidth ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padBottom . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padBottom ;", "}", "METHOD_END"], "methodName": ["getPadBottomValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padLeft . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padLeft ;", "}", "METHOD_END"], "methodName": ["getPadLeftValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padRight . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padRight ;", "}", "METHOD_END"], "methodName": ["getPadRightValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padTop . get ( this )  ;", "}", "METHOD_END"], "methodName": ["getPadTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   padTop ;", "}", "METHOD_END"], "methodName": ["getPadTopValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return    ( padLeft . get ( this )  )     +     ( padRight . get ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getPadX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return    ( padTop . get ( this )  )     +     ( padBottom . get ( this )  )  ;", "}", "METHOD_END"], "methodName": ["getPadY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "computeSize (  )  ;", "float   height    =    tPrefHeight ;", "if    (  ( background )     !  =    null )", "return   Math . max ( height ,    background . getMinHeight (  )  )  ;", "return   height ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "computeSize (  )  ;", "float   width    =    tPrefWidth ;", "if    (  ( background )     !  =    null )", "return   Math . max ( width ,    background . getMinWidth (  )  )  ;", "return   width ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Array < Cell >    cells    =    this . cells ;", "int   row    =     0  ;", "y    +  =    getPadTop (  )  ;", "int   i    =     0  ;", "int   n    =    cellize ;", "if    ( n    =  =     0  )", "return    -  1  ;", "if    ( n    =  =     1  )", "return    0  ;", "while    ( i    <    n )     {", "Cell   c    =    cells . get (  ( i +  +  )  )  ;", "if    (  (  ( c . actorY )     +     ( c . computedPadTop )  )     <    y )", "break ;", "if    ( c . endRow )", "row +  +  ;", "}", "return   row ;", "}", "METHOD_END"], "methodName": ["getRow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( rowHeight )     =  =    null )", "return    0  ;", "return   rowHeight [ rowIndex ]  ;", "}", "METHOD_END"], "methodName": ["getRowHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   rowMinHeight [ rowIndex ]  ;", "}", "METHOD_END"], "methodName": ["getRowMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   rowPrefHeight [ rowIndex ]  ;", "}", "METHOD_END"], "methodName": ["getRowPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   rows ;", "}", "METHOD_END"], "methodName": ["getRows"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   skin ;", "}", "METHOD_END"], "methodName": ["getSkin"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   debug ;", "}", "METHOD_END"], "methodName": ["getTableDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( clip )     {", "if    ( touch    &  &     (  ( getTouch (  )  )     =  =     ( Touch . disd )  )  )", "return   null ;", "if    (  (  (  ( x    <     0  )     |  |     ( x    >  =     ( getWidth (  )  )  )  )     |  |     ( y    <     0  )  )     |  |     ( y    >  =     ( getHeight (  )  )  )  )", "return   null ;", "}", "return   super . hit ( x ,    y ,    touch )  ;", "}", "METHOD_END"], "methodName": ["hit"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "sizeInvalid    =    true ;", "super . invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "layout (  0  ,     0  ,    width ,    height )  ;", "Array < Cell >    cells    =    this . cells ;", "if    ( round )     {", "for    ( int   i    =     0  ,    n    =    cellize ;    i    <    n ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "float   actorWidth    =    Math . round ( c . actorWidth )  ;", "float   actorHeight    =    Math . round ( c . actorHeight )  ;", "float   actorX    =    Math . round ( c . actorX )  ;", "float   actorY    =     ( height    -     ( Math . round ( c . actorY )  )  )     -    actorHeight ;", "c . setActorBounds ( actorX ,    actorY ,    actorWidth ,    actorHeight )  ;", "Actor   actor    =    c . actor ;", "if    ( actor    !  =    null )", "actor . setBounds ( actorX ,    actorY ,    actorWidth ,    actorHeight )  ;", "}", "} else    {", "for    ( int   i    =     0  ,    n    =    cellize ;    i    <    n ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "float   actorHeight    =    c . actorHeight ;", "float   actorY    =     ( height    -     ( c . actorY )  )     -    actorHeight ;", "c . setActorY ( actorY )  ;", "Actor   actor    =    c . actor ;", "if    ( actor    !  =    null )", "actor . setBounds ( c . actorX ,    actorY ,    c . actorWidth ,    actorHeight )  ;", "}", "}", "Array < Actor >    children    =    getChildren (  )  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   child    =    children . get ( i )  ;", "if    ( child   instanceof   Layout )", "(  ( Layout )     ( child )  )  . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Array < Cell >    cells    =    this . cells ;", "int   cellCount    =    cells . size ;", "if    ( sizeInvalid )", "computeSize (  )  ;", "float   padLeft    =    this . padLeft . get ( this )  ;", "float   hpadding    =    padLeft    +     ( padRight . get ( this )  )  ;", "float   padTop    =    this . padTop . get ( this )  ;", "float   vpadding    =    padTop    +     ( padBottom . get ( this )  )  ;", "int   columns    =    this . columns ;", "int   rows    =    this . rows ;", "float [  ]    expandWidth    =    this . expandWidth ;", "float [  ]    expandHeight    =    this . expandHeight ;", "float [  ]    columnWidth    =    this . columnWidth ;", "float [  ]    rowHeight    =    this . rowHeight ;", "float   totalExpandWidth    =     0  ;", "float   totalExpandHeight    =     0  ;", "for    ( int   i    =     0  ;    i    <    columns ;    i +  +  )", "totalExpandWidth    +  =    expandWidth [ i ]  ;", "for    ( int   i    =     0  ;    i    <    rows ;    i +  +  )", "totalExpandHeight    +  =    expandHeight [ i ]  ;", "float [  ]    columnWeightedWidth ;", "float   totalGrowWidth    =     ( tablePrefWidth )     -     ( tableMinWidth )  ;", "if    ( totalGrowWidth    =  =     0  )", "columnWeightedWidth    =    columnMinWidth ;", "else    {", "float   extraWidth    =    Math . min ( totalGrowWidth ,    Math . max (  0  ,     ( layoutWidth    -     ( tableMinWidth )  )  )  )  ;", "columnWeightedWidth    =     . columnWeightedWidth    =    ensureSize (  . columnWeightedWidth ,    columns )  ;", "float [  ]    columnMinWidth    =    this . columnMinWidth ;", "float [  ]    columnPrefWidth    =    this . columnPrefWidth ;", "for    ( int   i    =     0  ;    i    <    columns ;    i +  +  )     {", "float   growWidth    =     ( columnPrefWidth [ i ]  )     -     ( columnMinWidth [ i ]  )  ;", "float   growRatio    =    growWidth    /    totalGrowWidth ;", "columnWeightedWidth [ i ]     =     ( columnMinWidth [ i ]  )     +     ( extraWidth    *    growRatio )  ;", "}", "}", "float [  ]    rowWeightedHeight ;", "float   totalGrowHeight    =     ( tablePrefHeight )     -     ( tableMinHeight )  ;", "if    ( totalGrowHeight    =  =     0  )", "rowWeightedHeight    =    rowMinHeight ;", "else    {", "rowWeightedHeight    =     . rowWeightedHeight    =    ensureSize (  . rowWeightedHeight ,    rows )  ;", "float   extraHeight    =    Math . min ( totalGrowHeight ,    Math . max (  0  ,     ( layoutHeight    -     ( tableMinHeight )  )  )  )  ;", "float [  ]    rowMinHeight    =    this . rowMinHeight ;", "float [  ]    rowPrefHeight    =    this . rowPrefHeight ;", "for    ( int   i    =     0  ;    i    <    rows ;    i +  +  )     {", "float   growHeight    =     ( rowPrefHeight [ i ]  )     -     ( rowMinHeight [ i ]  )  ;", "float   growRatio    =    growHeight    /    totalGrowHeight ;", "rowWeightedHeight [ i ]     =     ( rowMinHeight [ i ]  )     +     ( extraHeight    *    growRatio )  ;", "}", "}", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "int   column    =    c . column ;", "int   row    =    c . row ;", "Actor   a    =    c . actor ;", "float   spannedWeightedWidth    =     0  ;", "int   colspan    =    c . colspan ;", "for    ( int   ii    =    column ,    nn    =    ii    +    colspan ;    ii    <    nn ;    ii +  +  )", "spannedWeightedWidth    +  =    columnWeightedWidth [ ii ]  ;", "float   weightedHeight    =    rowWeightedHeight [ row ]  ;", "float   prefWidth    =    c . prefWidth . get ( a )  ;", "float   prefHeight    =    c . prefHeight . get ( a )  ;", "float   minWidth    =    c . minWidth . get ( a )  ;", "float   minHeight    =    c . minHeight . get ( a )  ;", "float   maxWidth    =    c . maxWidth . get ( a )  ;", "float   maxHeight    =    c . maxHeight . get ( a )  ;", "if    ( prefWidth    <    minWidth )", "prefWidth    =    minWidth ;", "if    ( prefHeight    <    minHeight )", "prefHeight    =    minHeight ;", "if    (  ( maxWidth    >     0  )     &  &     ( prefWidth    >    maxWidth )  )", "prefWidth    =    maxWidth ;", "if    (  ( maxHeight    >     0  )     &  &     ( prefHeight    >    maxHeight )  )", "prefHeight    =    maxHeight ;", "c . actorWidth    =    Math . min (  (  ( spannedWeightedWidth    -     ( c . computedPadLeft )  )     -     ( c . computedPadRight )  )  ,    prefWidth )  ;", "c . actorHeight    =    Math . min (  (  ( weightedHeight    -     ( c . computedPadTop )  )     -     ( c . computedPadBottom )  )  ,    prefHeight )  ;", "if    ( colspan    =  =     1  )", "columnWidth [ column ]     =    Math . max ( columnWidth [ column ]  ,    spannedWeightedWidth )  ;", "rowHeight [ row ]     =    Math . max ( rowHeight [ row ]  ,    weightedHeight )  ;", "}", "if    ( totalExpandWidth    >     0  )     {", "float   extra    =    layoutWidth    -    hpadding ;", "for    ( int   i    =     0  ;    i    <    columns ;    i +  +  )", "extra    -  =    columnWidth [ i ]  ;", "float   used    =     0  ;", "int   lastIndex    =     0  ;", "for    ( int   i    =     0  ;    i    <    columns ;    i +  +  )     {", "if    (  ( expandWidth [ i ]  )     =  =     0  )", "continue ;", "float   amount    =     ( extra    *     ( expandWidth [ i ]  )  )     /    totalExpandWidth ;", "columnWidth [ i ]     +  =    amount ;", "used    +  =    amount ;", "lastIndex    =    i ;", "}", "columnWidth [ lastIndex ]     +  =    extra    -    used ;", "}", "if    ( totalExpandHeight    >     0  )     {", "float   extra    =    layoutHeight    -    vpadding ;", "for    ( int   i    =     0  ;    i    <    rows ;    i +  +  )", "extra    -  =    rowHeight [ i ]  ;", "float   used    =     0  ;", "int   lastIndex    =     0  ;", "for    ( int   i    =     0  ;    i    <    rows ;    i +  +  )     {", "if    (  ( expandHeight [ i ]  )     =  =     0  )", "continue ;", "float   amount    =     ( extra    *     ( expandHeight [ i ]  )  )     /    totalExpandHeight ;", "rowHeight [ i ]     +  =    amount ;", "used    +  =    amount ;", "lastIndex    =    i ;", "}", "rowHeight [ lastIndex ]     +  =    extra    -    used ;", "}", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "int   colspan    =    c . colspan ;", "if    ( colspan    =  =     1  )", "continue ;", "float   extraWidth    =     0  ;", "for    ( int   column    =    c . column ,    nn    =    column    +    colspan ;    column    <    nn ;    column +  +  )", "extraWidth    +  =     ( columnWeightedWidth [ column ]  )     -     ( columnWidth [ column ]  )  ;", "extraWidth    -  =    Math . max (  0  ,     (  ( c . computedPadLeft )     +     ( c . computedPadRight )  )  )  ;", "extraWidth    /  =    colspan ;", "if    ( extraWidth    >     0  )     {", "for    ( int   column    =    c . column ,    nn    =    column    +    colspan ;    column    <    nn ;    column +  +  )", "columnWidth [ column ]     +  =    extraWidth ;", "}", "}", "float   tableWidth    =    hpadding ;", "float   tableHeight    =    vpadding ;", "for    ( int   i    =     0  ;    i    <    columns ;    i +  +  )", "tableWidth    +  =    columnWidth [ i ]  ;", "for    ( int   i    =     0  ;    i    <    rows ;    i +  +  )", "tableHeight    +  =    rowHeight [ i ]  ;", "int   align    =    this . align ;", "float   x    =    layoutX    +    padLeft ;", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "x    +  =    layoutWidth    -    tableWidth ;", "else", "if    (  ( align    &     ( Align . left )  )     =  =     0  )", "x    +  =     ( layoutWidth    -    tableWidth )     /     2  ;", "float   y    =    layoutY    +    padTop ;", "if    (  ( align    &     ( Align . bottom )  )     !  =     0  )", "y    +  =    layoutHeight    -    tableHeight ;", "else", "if    (  ( align    &     ( Align . top )  )     =  =     0  )", "y    +  =     ( layoutHeight    -    tableHeight )     /     2  ;", "float   currentX    =    x ;", "float   currentY    =    y ;", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "float   spannedCellWidth    =     0  ;", "for    ( int   column    =    c . column ,    nn    =    column    +     ( c . colspan )  ;    column    <    nn ;    column +  +  )", "spannedCellWidth    +  =    columnWidth [ column ]  ;", "spannedCellWidth    -  =     ( c . computedPadLeft )     +     ( c . computedPadRight )  ;", "currentX    +  =    c . computedPadLeft ;", "float   fillX    =    c . fillX ;", "float   fillY    =    c . fillY ;", "if    ( fillX    >     0  )     {", "c . actorWidth    =    Math . max (  ( spannedCellWidth    *    fillX )  ,    c . minWidth . get ( c . actor )  )  ;", "float   maxWidth    =    c . maxWidth . get ( c . actor )  ;", "if    ( maxWidth    >     0  )", "c . actorWidth    =    Math . min ( c . actorWidth ,    maxWidth )  ;", "}", "if    ( fillY    >     0  )     {", "c . actorHeight    =    Math . max (  (  (  (  ( rowHeight [ c . row ]  )     *    fillY )     -     ( c . computedPadTop )  )     -     ( c . computedPadBottom )  )  ,    c . minHeight . get ( c . actor )  )  ;", "float   maxHeight    =    c . maxHeight . get ( c . actor )  ;", "if    ( maxHeight    >     0  )", "c . actorHeight    =    Math . min ( c . actorHeight ,    maxHeight )  ;", "}", "align    =    c . align ;", "if    (  ( align    &     ( Align . left )  )     !  =     0  )", "c . actorX    =    currentX ;", "else", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "c . actorX    =     ( currentX    +    spannedCellWidth )     -     ( c . actorWidth )  ;", "else", "c . actorX    =    currentX    +     (  ( spannedCellWidth    -     ( c . actorWidth )  )     /     2  )  ;", "if    (  ( align    &     ( Align . top )  )     !  =     0  )", "c . actorY    =    currentY    +     ( c . computedPadTop )  ;", "else", "if    (  ( align    &     ( Align . bottom )  )     !  =     0  )", "c . actorY    =     (  ( currentY    +     ( rowHeight [ c . row ]  )  )     -     ( c . actorHeight )  )     -     ( c . computedPadBottom )  ;", "else", "c . actorY    =    currentY    +     (  (  (  (  ( rowHeight [ c . row ]  )     -     ( c . actorHeight )  )     +     ( c . computedPadTop )  )     -     ( c . computedPadBottom )  )     /     2  )  ;", "if    ( c . endRow )     {", "currentX    =    x ;", "currentY    +  =    rowHeight [ c . row ]  ;", "} else", "currentX    +  =    spannedCellWidth    +     ( c . computedPadRight )  ;", "}", "if    (  ( debug )     =  =     (  . Debug . none )  )", "return ;", "clearDebugRects (  )  ;", "currentX    =    x ;", "currentY    =    y ;", "if    (  (  ( debug )     =  =     (  . Debug . table )  )     |  |     (  ( debug )     =  =     (  . Debug . all )  )  )     {", "addDebugRect ( layoutX ,    layoutY ,    layoutWidth ,    layoutHeight ,     . debugColor )  ;", "addDebugRect ( x ,    y ,     ( tableWidth    -    hpadding )  ,     ( tableHeight    -    vpadding )  ,     . debugColor )  ;", "}", "for    ( int   i    =     0  ;    i    <    cellCount ;    i +  +  )     {", "Cell   c    =    cells . get ( i )  ;", "if    (  (  ( debug )     =  =     (  . Debug . actor )  )     |  |     (  ( debug )     =  =     (  . Debug . all )  )  )", "addDebugRect ( c . actorX ,    c . actorY ,    c . actorWidth ,    c . actorHeight ,     . debugActorColor )  ;", "float   spannedCellWidth    =     0  ;", "for    ( int   column    =    c . column ,    nn    =    column    +     ( c . colspan )  ;    column    <    nn ;    column +  +  )", "spannedCellWidth    +  =    columnWidth [ column ]  ;", "spannedCellWidth    -  =     ( c . computedPadLeft )     +     ( c . computedPadRight )  ;", "currentX    +  =    c . computedPadLeft ;", "if    (  (  ( debug )     =  =     (  . Debug . cell )  )     |  |     (  ( debug )     =  =     (  . Debug . all )  )  )     {", "addDebugRect ( currentX ,     ( currentY    +     ( c . computedPadTop )  )  ,    spannedCellWidth ,     (  (  ( rowHeight [ c . row ]  )     -     ( c . computedPadTop )  )     -     ( c . computedPadBottom )  )  ,     . debugCellColor )  ;", "}", "if    ( c . endRow )     {", "currentX    =    x ;", "currentY    +  =    rowHeight [ c . row ]  ;", "} else", "currentX    +  =    spannedCellWidth    +     ( c . computedPadRight )  ;", "}", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . left ;", "align    &  =     ~  ( Align . right )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Cell   cell    =    Table . cellPool . obtain (  )  ;", "cell . setLayout ( this )  ;", "return   cell ;", "}", "METHOD_END"], "methodName": ["obtainCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( pad    =  =    null )", "throw   new   IllegalArgumentException (  \" pad   cannot   be   null .  \"  )  ;", "padTop    =    pad ;", "padLeft    =    pad ;", "padBottom    =    pad ;", "padRight    =    pad ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( top    =  =    null )", "throw   new   IllegalArgumentExption (  \" top   cannot   be   null .  \"  )  ;", "if    ( left    =  =    null )", "throw   new   IllegalArgumentExption (  \" left   cannot   be   null .  \"  )  ;", "if    ( bottom    =  =    null )", "throw   new   IllegalArgumentExption (  \" bottom   cannot   be   null .  \"  )  ;", "if    ( right    =  =    null )", "throw   new   IllegalArgumentExption (  \" right   cannot   be   null .  \"  )  ;", "padTop    =    top ;", "padLeft    =    left ;", "padBottom    =    bottom ;", "padRight    =    right ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "pad ( new   Value . Fixed ( pad )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "padTop    =    new   Value . Fixed ( top )  ;", "padLeft    =    new   Value . Fixed ( left )  ;", "padBottom    =    new   Value . Fixed ( bottom )  ;", "padRight    =    new   Value . Fixed ( right )  ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( padBottom    =  =    null )", "throw   new   IllegalArgumentException (  \" padBottom   cannot   be   null .  \"  )  ;", "this . padBottom    =    padBottom ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "this . padBottom    =    new   Value . Fixed ( padBottom )  ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( padLeft    =  =    null )", "throw   new   IllegalArgumentException (  \" padLeft   cannot   be   null .  \"  )  ;", "this . padLeft    =    padLeft ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "this . padLeft    =    new   Value . Fixed ( padLeft )  ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( padRight    =  =    null )", "throw   new   IllegalArgumentException (  \" padRight   cannot   be   null .  \"  )  ;", "this . padRight    =    padRight ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "this . padRight    =    new   Value . Fixed ( padRight )  ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    ( padTop    =  =    null )", "throw   new   IllegalArgumentException (  \" padTop   cannot   be   null .  \"  )  ;", "this . padTop    =    padTop ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "this . padTop    =    new   Value . Fixed ( padTop )  ;", "sizeInvalid    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "return   removeActor ( actor ,    true )  ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( super . removeActor ( actor ,    unfocus )  )  )", "return   false ;", "Cell   ll    =    getCell ( actor )  ;", "if    ( ll    !  =    null )", "ll . actor    =    null ;", "return   true ;", "}", "METHOD_END"], "methodName": ["removeActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "clearChildren (  )  ;", "padTop    =     . backgroundTop ;", "padLeft    =     . backgroundLeft ;", "padBottom    =     . backgroundBottom ;", "padRight    =     . backgroundRight ;", "align    =    Align . center ;", "debug (  . Debug . none )  ;", "cellDefaults . reset (  )  ;", "for    ( int   i    =     0  ,    n    =    columnDefaults . size ;    i    <    n ;    i +  +  )     {", "Cell   columnCell    =    columnDefaults . get ( i )  ;", "if    ( columnCell    !  =    null )", ". cellPool . free ( columnCell )  ;", "}", "columnDefaults . clear (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . right ;", "align    &  =     ~  ( Align . ft )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cells . size )     >     0  )     {", "if    (  !  ( implicitEndRow )  )", "endRow (  )  ;", "invalidate (  )  ;", "}", "implicitEndRow    =    false ;", "if    (  ( rowDefaults )     !  =    null )", ". cellPool . free ( rowDefaults )  ;", "rowDefaults    =    obtainCell (  )  ;", "rowDefaults . clear (  )  ;", "return   rowDefaults ;", "}", "METHOD_END"], "methodName": ["row"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . background )     =  =    background )", "return ;", "float   padTopOld    =    getPadTop (  )  ;", "float   padLeftOld    =    getPadLeft (  )  ;", "float   padBottomOld    =    getPadBottom (  )  ;", "float   padRightOld    =    getPadRight (  )  ;", "this . background    =    background ;", "float   padTopNew    =    getPadTop (  )  ;", "float   padLeftNew    =    getPadLeft (  )  ;", "float   padBottomNew    =    getPadBottom (  )  ;", "float   padRightNew    =    getPadRight (  )  ;", "if    (  (  ( padTopOld    +    padBottomOld )     !  =     ( padTopNew    +    padBottomNew )  )     |  |     (  ( padLeftOld    +    padRightOld )     !  =     ( padLeftNew    +    padRightNew )  )  )", "invalidateHierarchy (  )  ;", "else", "if    (  (  (  ( padTopOld    !  =    padTopNew )     |  |     ( padLeftOld    !  =    padLeftNew )  )     |  |     ( padBottomOld    !  =    padBottomNew )  )     |  |     ( padRightOld    !  =    padRightNew )  )", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "if    (  ( skin )     =  =    null )", "throw   new   IllegalStateException (  \"    must   have   a   skin   set   to   use   this   method .  \"  )  ;", "setBackground ( skin . getDrawable ( drawableName )  )  ;", "}", "METHOD_END"], "methodName": ["setBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "clip    =    enabled ;", "setTransform ( enabled )  ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setClip"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "debug (  ( enabled    ?    Table . Debug . all    :    Table . Debug . none )  )  ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "this . round    =    round ;", "}", "METHOD_END"], "methodName": ["setRound"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "this . skin    =    skin ;", "}", "METHOD_END"], "methodName": ["setSkin"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "Stack   stack    =    new   Stack (  )  ;", "if    ( actors    !  =    null )     {", "for    ( int   i    =     0  ,    n    =    actors . length ;    i    <    n ;    i +  +  )", "stack . addActor ( actors [ i ]  )  ;", "}", "return   add ( stack )  ;", "}", "METHOD_END"], "methodName": ["stack"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . top ;", "align    &  =     ~  ( Alignottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["top"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Table"}, {"methodBody": ["METHOD_START", "{", "int   index    =     0  ;", "while    (  ( index    <     ( liBreak . size )  )     &  &     ( cursor    >     ( liBreak . items [ index ]  )  )  )     {", "index +  +  ;", "}", "return   index ;", "}", "METHOD_END"], "methodName": ["calculateCurrentLineIndex"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "return   cursorLine ;", "}", "METHOD_END"], "methodName": ["getCursorLine"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "return    (  ( textOffset )     +     ( fontOffset )  )     +     ( style . font . getData (  )  . cursorX )  ;", "}", "METHOD_END"], "methodName": ["getCursorX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "BitmapFont   font    =    style . font ;", "return    -  (  (  (  -  ( font . getDet (  )  )  )     /     2  )     -     (  (  (  ( cursorLine )     -     ( firstLineShowing )  )     +     1  )     *     ( font . getLineHeight (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCursorY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "return   firstLineShowing ;", "}", "METHOD_END"], "methodName": ["getFirstLineShowing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "return    (  ( linesBreak . size )     /     2  )     +     ( newLineAtEnd (  )     ?     1     :     0  )  ;", "}", "METHOD_END"], "methodName": ["getLines"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "return   linesShowing ;", "}", "METHOD_END"], "methodName": ["getLinesShowing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "if    (  ( linesBreak . size )     >     0  )     {", "if    (  (  ( cursorLine )     *     2  )     >  =     ( linesBreak . size )  )     {", "return   text . length (  )  ;", "} else    {", "float [  ]    glyphPositions    =    this . glyphPositions . items ;", "int   start    =    linesBreak . items [  (  ( cursorLine )     *     2  )  ]  ;", "x    +  =    glyphPositions [ start ]  ;", "int   end    =    linesBreak . items [  (  (  ( cursorLine )     *     2  )     +     1  )  ]  ;", "int   i    =    start ;", "for    (  ;    i    <    end ;    i +  +  )", "if    (  ( glyphPositions [ i ]  )     >    x )", "break ;", "if    (  (  ( glyphPositions [ i ]  )     -    x )     <  =     ( x    -     ( glyphPositions [  ( i    -     1  )  ]  )  )  )", "return   i ;", "return   Math . max (  0  ,     ( i    -     1  )  )  ;", "}", "} else    {", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["letterUnderCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "if    ( line    <     0  )     {", "cursorLine    =     0  ;", "cursor    =     0  ;", "moveOffset    =     -  1  ;", "} else", "if    ( line    >  =     ( getLi (  )  )  )     {", "int   newLine    =     ( getLi (  )  )     -     1  ;", "cursor    =    text . length (  )  ;", "if    (  ( line    >     ( getLi (  )  )  )     |  |     ( newLine    =  =     ( cursorLine )  )  )     {", "moveOffset    =     -  1  ;", "}", "cursorLine    =    newLine ;", "} else", "if    ( line    !  =     ( cursorLine )  )     {", "if    (  ( moveOffset )     <     0  )     {", "moveOffset    =     (  ( liBreak . size )     <  =     (  ( cursorLine )     *     2  )  )     ?     0     :     ( glyphPositions . get ( cursor )  )     -     ( glyphPositions . get ( liBreak . get (  (  ( cursorLine )     *     2  )  )  )  )  ;", "}", "cursorLine    =    line ;", "cursor    =     (  (  ( cursorLine )     *     2  )     >  =     ( liBreak . size )  )     ?    text . length (  )     :    liBreak . get (  (  ( cursorLine )     *     2  )  )  ;", "while    (  (  (  ( cursor )     <     ( text . length (  )  )  )     &  &     (  ( cursor )     <  =     (  ( liBreak . get (  (  (  ( cursorLine )     *     2  )     +     1  )  )  )     -     1  )  )  )     &  &     (  (  ( glyphPositions . get ( cursor )  )     -     ( glyphPositions . get ( liBreak . get (  (  ( cursorLine )     *     2  )  )  )  )  )     <     ( moveOffset )  )  )     {", "( cursor )  +  +  ;", "}", "showCursor (  )  ;", "}", "}", "METHOD_END"], "methodName": ["moveCursorLine"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "return    (  ( text . length (  )  )     !  =     0  )     &  &     (  (  ( text . charAt (  (  ( text . length (  )  )     -     1  )  )  )     =  =     ( TextField . ENTER _ ANDROID )  )     |  |     (  ( text . charAt (  (  ( text . length (  )  )     -     1  )  )  )     =  =     ( TextField . ENTER _ DESKTOP )  )  )  ;", "}", "METHOD_END"], "methodName": ["newLineAtEnd"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "this . prefRows    =    prefRows ;", "}", "METHOD_END"], "methodName": ["setPrefRows"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "updateCurrentLine (  )  ;", "updateFirstLineShowing (  )  ;", "}", "METHOD_END"], "methodName": ["showCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "int   index    =    calculateCurrentLineIndex ( cursor )  ;", "int   line    =    index    /     2  ;", "if    (  (  (  (  ( index    %     2  )     =  =     0  )     |  |     (  ( index    +     1  )     >  =     ( linesBreak . size )  )  )     |  |     (  ( cursor )     !  =     ( linesBreak . items [ index ]  )  )  )     |  |     (  ( linesBreak . items [  ( index    +     1  )  ]  )     !  =     ( linesBreak . items [ index ]  )  )  )     {", "if    (  (  (  ( line    <     (  ( linesBreak . size )     /     2  )  )     |  |     (  ( text . length (  )  )     =  =     0  )  )     |  |     (  ( text . charAt (  (  ( text . length (  )  )     -     1  )  )  )     =  =     ( Field . ENTER _ ANDROID )  )  )     |  |     (  ( text . charAt (  (  ( text . length (  )  )     -     1  )  )  )     =  =     ( Field . ENTER _ DESKTOP )  )  )     {", "cursorLine    =    line ;", "}", "}", "updateFirstLineShowing (  )  ;", "}", "METHOD_END"], "methodName": ["updateCurrentLine"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cursorLine )     !  =     ( firstLineShowing )  )     {", "int   step    =     (  ( cursorLine )     >  =     ( firstLineShowing )  )     ?     1     :     -  1  ;", "while    (  (  ( firstLineShowing )     >     ( cursorLine )  )     |  |     (  (  (  ( firstLineShowing )     +     ( liShowing )  )     -     1  )     <     ( cursorLine )  )  )     {", "firstLineShowing    +  =    step ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateFirstLineShowing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextArea"}, {"methodBody": ["METHOD_START", "{", "Color   fontColor ;", "if    (  ( isDisabled (  )  )     &  &     (  ( style . disabledFontColor )     !  =    null )  )", "fontColor    =    style . disabledFontColor ;", "else", "if    (  ( isPressed (  )  )     &  &     (  ( style . downFontColor )     !  =    null )  )", "fontColor    =    style . downFontColor ;", "else", "if    (  ( isChecked )     &  &     (  ( style . checkedFontColor )     !  =    null )  )", "fontColor    =     (  ( isOver (  )  )     &  &     (  ( style . checkedOverFontColor )     !  =    null )  )     ?    style . checkedOverFontColor    :    style . checkedFontColor ;", "else", "if    (  ( isOver (  )  )     &  &     (  ( style . overFontColor )     !  =    null )  )", "fontColor    =    style . overFontColor ;", "else", "fontColor    =    style . fontColor ;", "if    ( fontColor    !  =    null )", "label . getStyle (  )  . fontColor    =    fontColor ;", "super . draw ( batch ,    a )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextButton"}, {"methodBody": ["METHOD_START", "{", "return   label ;", "}", "METHOD_END"], "methodName": ["getLabel"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextButton"}, {"methodBody": ["METHOD_START", "{", "return   getCell ( label )  ;", "}", "METHOD_END"], "methodName": ["getLabelCell"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextButton"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextButton"}, {"methodBody": ["METHOD_START", "{", "return   label . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextButton"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   NullPointerException (  \" style   cannot   be   null \"  )  ;", "if    (  !  ( style   instanceofStyle )  )", "throw   new   IllegalArgumentException (  \" style   must   be   aStyle .  \"  )  ;", "super . setStyle ( style )  ;", "this . style    =     ( Style )     ( style )  )  ;", "if    (  ( label )     !  =    null )     {", "Style   textButtonStyle    =     ( Style )     ( style )  )  ;", "Label . LabelStyle   labelStyle    =    label . getStyle (  )  ;", "labelStyle . font    =    textButtonStyle . font ;", "labelStyle . fontColor    =    textButtonStyle . fontColor ;", "label . setStyle ( labelStyle )  ;", "}", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextButton"}, {"methodBody": ["METHOD_START", "{", "label . setText ( text )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextButton"}, {"methodBody": ["METHOD_START", "{", "if    ( str    =  =    null )", "str    =     \"  \"  ;", "clearSelection (  )  ;", "cursor    =    t . length (  )  ;", "paste ( str ,    programmaticChangeEvents )  ;", "}", "METHOD_END"], "methodName": ["appendText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "float   visibleWidth    =    getWidth (  )  ;", "Drawable   background    =    getBackgroundDrawable (  )  ;", "if    ( background    !  =    null )", "visibleWidth    -  =     ( background . getLeftWidth (  )  )     +     ( background . getRightWidth (  )  )  ;", "int   glyphCount    =    glyphPositions . size ;", "float [  ]    glyphPositions    =    this . glyphPositions . items ;", "float   distance    =     ( glyphPositions [ Math . max (  0  ,     (  ( cursor )     -     1  )  )  ]  )     +     ( renderOffset )  ;", "if    ( distance    <  =     0  )", "renderOffset    -  =    distance ;", "else    {", "int   index    =    Math . min (  ( glyphCount    -     1  )  ,     (  ( cursor )     +     1  )  )  ;", "float   minX    =     ( glyphPositions [ index ]  )     -    visibleWidth ;", "if    (  (  -  ( renderOffset )  )     <    minX )", "renderOffset    =     - minX ;", "}", "float   maxOffset    =     0  ;", "float   width    =    glyphPositions [  ( glyphCount    -     1  )  ]  ;", "for    ( int   i    =    glyphCount    -     2  ;    i    >  =     0  ;    i -  -  )     {", "float   x    =    glyphPositions [ i ]  ;", "if    (  ( width    -    x )     >    visibleWidth )", "break ;", "maxOffset    =    x ;", "}", "if    (  (  -  ( renderOffset )  )     >    maxOffset )", "renderOffset    =     - maxOffset ;", "visibleStart    =     0  ;", "float   startX    =     0  ;", "for    ( int   i    =     0  ;    i    <    glyphCount ;    i +  +  )     {", "if    (  ( glyphPositions [ i ]  )     >  =     (  -  ( renderOffset )  )  )     {", "visibleStart    =    Math . max (  0  ,    i )  ;", "startX    =    glyphPositions [ i ]  ;", "break ;", "}", "}", "int   length    =    Math . min ( display . length (  )  ,     (  ( glyphPositions . length )     -     1  )  )  ;", "visibleEnd    =    Math . min ( length ,     (  ( cursor )     +     1  )  )  ;", "for    (  ;     ( visibleEnd )     <  =    length ;     ( visibleEnd )  +  +  )", "if    (  ( glyphPositions [ visibleEnd ]  )     >     ( startX    +    visibleWidth )  )", "break ;", "visibleEnd    =    Math . max (  0  ,     (  ( visibleEnd )     -     1  )  )  ;", "if    (  (  ( textHAlign )     &     ( Align . left )  )     =  =     0  )     {", "textOffset    =    visibleWidth    -     (  ( glyphPositions [ visibleEnd ]  )     -    startX )  ;", "if    (  (  ( textHAlign )     &     ( Align . center )  )     !  =     0  )", "textOffset    =    Math . round (  (  ( textOffset )     *     0  .  5 F )  )  ;", "} else", "textOffset    =    startX    +     ( renderOffset )  ;", "if    ( hasSelection )     {", "int   minIndex    =    Math . min ( cursor ,    selectionStart )  ;", "int   maxIndex    =    Math . max ( cursor ,    selectionStart )  ;", "float   minX    =    Math . max (  (  ( glyphPositions [ minIndex ]  )     -     ( glyphPositions [ visibleStart ]  )  )  ,     (  -  ( textOffset )  )  )  ;", "float   maxX    =    Math . min (  (  ( glyphPositions [ maxIndex ]  )     -     ( glyphPositions [ visibleStart ]  )  )  ,     ( visibleWidth    -     ( textOffset )  )  )  ;", "selectionX    =    minX ;", "selectionWidth    =     ( maxX    -    minX )     -     ( style . font . getData (  )  . cursorX )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateOffsets"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    ( newText . equals ( oldText )  )", "return   false ;", "text    =    newText ;", "ChangeListener . ChangeEvent   changeEvent    =    Pools . obtain ( ChangeListener . ChangeEvent . class )  ;", "boolean   cancelled    =    fire ( changeEvent )  ;", "text    =     ( cancelled )     ?    oldText    :    newText ;", "Pools . free ( changeEvent )  ;", "return    ! cancelled ;", "}", "METHOD_END"], "methodName": ["changeText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "hasSelection    =    false ;", "}", "METHOD_END"], "methodName": ["clearSelection"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "char   c    =    text . charAt (  ( index    +    offset )  )  ;", "return   isWordCharacter ( c )  ;", "}", "METHOD_END"], "methodName": ["continueCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hasSelection )     &  &     (  !  ( passwordMode )  )  )     {", "clipboard . setContents ( t . substring ( Math . min ( cursor ,    selectionStart )  ,    Math . max ( cursor ,    selectionStart )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   new   TextField . TextFieldClickListener (  )  ;", "}", "METHOD_END"], "methodName": ["createInputListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "cut ( programmaticChangeEvents )  ;", "}", "METHOD_END"], "methodName": ["cut"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hasSelection )     &  &     (  !  ( passwordMode )  )  )     {", "copy (  )  ;", "cursor    =    delete ( fireChangeEvent )  ;", "updateDisplay (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cut"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "int   from    =    selectionStart ;", "int   to    =    cursor ;", "int   minIndex    =    Math . min ( from ,    to )  ;", "int   maxIndex    =    Math . max ( from ,    to )  ;", "String   new    =     ( minIndex    >     0     ?    text . substring (  0  ,    minIndex )     :     \"  \"  )     +     ( maxIndex    <     ( text . length (  )  )     ?    text . substring ( maxIndex ,    text . length (  )  )     :     \"  \"  )  ;", "if    ( fireChangeEvent )", "change ( text ,    new )  ;", "else", "text    =    new ;", "clearSelection (  )  ;", "return   minIndex ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "final   BitmapFont   font    =    style . font ;", "final   Color   fontColor    =     (  ( disabled )     &  &     (  ( style . disabledFontColor )     !  =    null )  )     ?    style . disabledFontColor    :     ( focused )     &  &     (  ( style . focusedFontColor )     !  =    null )     ?    style . focusedFontColor    :    style . fontColor ;", "final   Drawable   selection    =    style . selection ;", "final   Drawable   cursorPatch    =    style . cursor ;", "final   Drawable   background    =    getBackgroundDrawable (  )  ;", "Color   color    =    getColor (  )  ;", "float   x    =    getX (  )  ;", "float   y    =    getY (  )  ;", "float   width    =    getWidth (  )  ;", "float   height    =    getHeight (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,     (  ( color . a )     *    a )  )  ;", "float   bgLeftWidth    =     0  ;", "float   bgRightWidth    =     0  ;", "if    ( background    !  =    null )     {", "background . draw ( batch ,    x ,    y ,    width ,    height )  ;", "bgLeftWidth    =    background . getLeftWidth (  )  ;", "bgRightWidth    =    background . getRightWidth (  )  ;", "}", "float   textY    =    getY ( font ,    background )  ;", "calculateOffsets (  )  ;", "if    (  (  ( focused )     &  &     ( hasSelection )  )     &  &     ( selection    !  =    null )  )     {", "drawSelection ( selection ,    batch ,    font ,     ( x    +    bgLeftWidth )  ,     ( y    +    textY )  )  ;", "}", "float   yOffset    =     ( font . isFlipped (  )  )     ?     -  ( textHeight )     :     0  ;", "if    (  ( display . length (  )  )     =  =     0  )     {", "if    (  (  !  ( focused )  )     &  &     (  ( message )     !  =    null )  )     {", "if    (  ( style . messageFontColor )     !  =    null )     {", "font . setColor ( style . messageFontColor . r ,    style . messageFontColor . g ,    style . messageFontColor . b ,     (  (  ( style . messageFontColor . a )     *     ( color . a )  )     *    a )  )  ;", "} else", "font . setColor (  0  .  7 F ,     0  .  7 F ,     0  .  7 F ,     (  ( color . a )     *    a )  )  ;", "BitmapFont   messageFont    =     (  ( style . messageFont )     !  =    null )     ?    style . messageFont    :    font ;", "messageFont . draw ( batch ,    message ,     ( x    +    bgLeftWidth )  ,     (  ( y    +    textY )     +    yOffset )  ,     0  ,    message . length (  )  ,     (  ( width    -    bgLeftWidth )     -    bgRightWidth )  ,    textHAlign ,    false ,     \"  .  .  .  \"  )  ;", "}", "} else    {", "font . setColor ( fontColor . r ,    fontColor . g ,    fontColor . b ,     (  (  ( fontColor . a )     *     ( color . a )  )     *    a )  )  ;", "draw ( batch ,    font ,     ( x    +    bgLeftWidth )  ,     (  ( y    +    textY )     +    yOffset )  )  ;", "}", "if    (  (  (  !  ( disabled )  )     &  &     ( cursorOn )  )     &  &     ( cursorPatch    !  =    null )  )     {", "drawCursor ( cursorPatch ,    batch ,    font ,     ( x    +    bgLeftWidth )  ,     ( y    +    textY )  )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "cursorPatch . draw ( batch ,     (  (  (  (  ( x    +     ( textOffset )  )     +     ( glyphPositions . get ( cursor )  )  )     -     ( glyphPositions . get ( visibleTextStart )  )  )     +     ( fontOffset )  )     +     ( font . getData (  )  . cursorX )  )  ,     (  ( y    -     ( textHeight )  )     -     ( font . getDescent (  )  )  )  ,    cursorPatch . getMinWidth (  )  ,    textHeight )  ;", "}", "METHOD_END"], "methodName": ["drawCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "selection . draw ( batch ,     (  (  ( x    +     ( textOffset )  )     +     ( selectionX )  )     +     ( fontOffset )  )  ,     (  ( y    -     ( textHeight )  )     -     ( font . getDescent (  )  )  )  ,    selectionWidth ,    textHeight )  ;", "}", "METHOD_END"], "methodName": ["drawSelection"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "font . draw ( batch ,    displayText ,     ( x    +     ( textOffset )  )  ,    y ,    visibleTextStart ,    visibleTextEnd ,     0  ,    Align . left ,    false )  ;", "}", "METHOD_END"], "methodName": ["drawText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    actors . size ;    i    <    n ;    i +  +  )     {", "Actor   actor    =    actors . get ( i )  ;", "if    ( actor   instanceof   TextField )     {", "if    ( actor    =  =     ( this )  )", "continue ;", "TextField   textField    =     (  ( TextField )     ( actor )  )  ;", "if    (  ( textField . isDisabled (  )  )     |  |     (  !  ( textField . focusTraversal )  )  )", "continue ;", "Vector 2    actorCoords    =    actor . getParent (  )  . localToStageCoordinates ( TextField . tmp 3  . set ( actor . getX (  )  ,    actor . getY (  )  )  )  ;", "boolean   below    =     (  ( actorCoords . y )     !  =     ( currentCoords . y )  )     &  &     (  (  ( actorCoords . y )     <     ( currentCoords . y )  )     ^    up )  ;", "boolean   right    =     (  ( actorCoords . y )     =  =     ( currentCoords . y )  )     &  &     (  (  ( actorCoords . x )     >     ( currentCoords . x )  )     ^    up )  ;", "if    (  (  ! below )     &  &     (  ! right )  )", "continue ;", "boolean   better    =     ( best    =  =    null )     |  |     (  (  ( actorCoords . y )     !  =     ( bestCoords . y )  )     &  &     (  (  ( actorCoords . y )     >     ( bestCoords . y )  )     ^    up )  )  ;", "if    (  ! better )", "better    =     (  ( actorCoords . y )     =  =     ( bestCoords . y )  )     &  &     (  (  ( actorCoords . x )     <     ( bestCoords . x )  )     ^    up )  ;", "if    ( better )     {", "best    =     (  ( TextField )     ( actor )  )  ;", "bestCoords . set ( actorCoords )  ;", "}", "} else", "if    ( actor   instanceof   Group )", "best    =    findNextTextField (  (  ( Group )     ( actor )  )  . getChildren (  )  ,    best ,    bestCoords ,    currentCoords ,    up )  ;", "}", "return   best ;", "}", "METHOD_END"], "methodName": ["findNextTextField"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "Stage   stage    =    getStage (  )  ;", "boolean   focused    =     ( stage    !  =    null )     &  &     (  ( stage . getKeyboardFocus (  )  )     =  =     ( this )  )  ;", "return    ( disabled )     &  &     (  ( style . disabledBackground )     !  =    null )     ?    style . disabledBackground    :    focused    &  &     (  ( style . focusedBackground )     !  =    null )     ?    style . focusedBackground    :    styleckground ;", "}", "METHOD_END"], "methodName": ["getBackgroundDrawable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   cursor ;", "}", "METHOD_END"], "methodName": ["getCursorPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   inputListener ;", "}", "METHOD_END"], "methodName": ["getDefaultInputListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   this . maxLength ;", "}", "METHOD_END"], "methodName": ["getMaxLength"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   messageText ;", "}", "METHOD_END"], "methodName": ["getMessageText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   keyboard ;", "}", "METHOD_END"], "methodName": ["getOnscreenKeyboard"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "float   topAndBottom    =     0  ;", "float   minHeight    =     0  ;", "if    (  ( styleckground )     !  =    null )     {", "topAndBottom    =    Math . max ( topAndBottom ,     (  ( styleckground . getBottomHeight (  )  )     +     ( styleckground . getTopHeight (  )  )  )  )  ;", "minHeight    =    Math . max ( minHeight ,    styleckground . getMinHeight (  )  )  ;", "}", "if    (  ( style . focusedBackground )     !  =    null )     {", "topAndBottom    =    Math . max ( topAndBottom ,     (  ( style . focusedBackground . getBottomHeight (  )  )     +     ( style . focusedBackground . getTopHeight (  )  )  )  )  ;", "minHeight    =    Math . max ( minHeight ,    style . focusedBackground . getMinHeight (  )  )  ;", "}", "if    (  ( style . disabledBackground )     !  =    null )     {", "topAndBottom    =    Math . max ( topAndBottom ,     (  ( style . disabledBackground . getBottomHeight (  )  )     +     ( style . disabledBackground . getTopHeight (  )  )  )  )  ;", "minHeight    =    Math . max ( minHeight ,    style . disabledBackground . getMinHeight (  )  )  ;", "}", "return   Math . max (  ( topAndBottom    +     ( textHeight )  )  ,    minHeight )  ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return    1  5  0  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   programmaticChangeEvents ;", "}", "METHOD_END"], "methodName": ["getProgrammaticChangeEvents"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   hasSelection    ?    text . substring ( Math . min ( selectionStart ,    cursor )  ,    Math . max ( selectionStart ,    cursor )  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   selectionStart ;", "}", "METHOD_END"], "methodName": ["getSelectionStart"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   text ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   filter ;", "}", "METHOD_END"], "methodName": ["getTextFieldFilter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "float   height    =    getHeight (  )  ;", "float   textY    =     (  ( textHeight )     /     2  )     +     ( font . getDet (  )  )  ;", "if    ( background    !  =    null )     {", "float   bottom    =    background . getBottomHeight (  )  ;", "textY    =     ( textY    +     (  (  ( height    -     ( background . getTopHeight (  )  )  )     -    bottom )     /     2  )  )     +    bottom ;", "} else    {", "textY    =    textY    +     ( height    /     2  )  ;", "}", "if    ( font . usesIntegerPositions (  )  )", "textY    =     (  ( int )     ( textY )  )  ;", "return   textY ;", "}", "METHOD_END"], "methodName": ["getTextY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "addListener (  ( inputListener    =    createInputListener (  )  )  )  ;", "addListener ( new   FocusListener (  )     {", "public   void   keyboardFocusChanged ( FocusListener . FocusEvent   event ,    Actor   actor ,    boolean   focused )     {", "blinkTask . cancel (  )  ;", "cursorOn    =    focused ;", "if    ( focused )", "utils . Timer . schedule ( blinkTask ,    blinkTime ,    blinkTime )  ;", "else", "keyRepeatTask . cancel (  )  ;", "TextField . this . focused    =    focused ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    (  ( to . length (  )  )     =  =     0  )", "return   t . toString (  )  ;", "return    (  ( to . substring (  0  ,    position )  )     +    t )     +     ( to . substring ( position ,    to . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   disabled ;", "}", "METHOD_END"], "methodName": ["isDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   passwordMode ;", "}", "METHOD_END"], "methodName": ["isPasswordMode"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   Character . isLetterOrDigit ( c )  ;", "}", "METHOD_END"], "methodName": ["isWordCharacter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "x    -  =     (  (  ( textOffset )     +     ( fontOffset )  )     -     ( style . font . getData (  )  . cursorX )  )     -     ( glyphPositions . get ( visibleTextStart )  )  ;", "Drawable   background    =    getBackgroundDrawable (  )  ;", "if    ( background    !  =    null )", "x    -  =    style . background . getLeftWidth (  )  ;", "int   n    =    this . glyphPositions . size ;", "float [  ]    glyphPositions    =    this . glyphPositions . items ;", "for    ( int   i    =     1  ;    i    <    n ;    i +  +  )     {", "if    (  ( glyphPositions [ i ]  )     >    x )     {", "if    (  (  ( glyphPositions [ i ]  )     -    x )     <  =     ( x    -     ( glyphPositions [  ( i    -     1  )  ]  )  )  )", "return   i ;", "return   i    -     1  ;", "}", "}", "return   n    -     1  ;", "}", "METHOD_END"], "methodName": ["letterUnderCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "int   limit    =     ( forward )     ?    text . length (  )     :     0  ;", "int   charOffset    =     ( forward )     ?     0     :     -  1  ;", "while    (  ( forward    ?     (  +  +  ( cursor )  )     <    limit    :     (  -  -  ( cursor )  )     >    limit )     &  &    jump )     {", "if    (  !  ( continueCursor ( cursor ,    charOffset )  )  )", "break ;", "}", "}", "METHOD_END"], "methodName": ["moveCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "Stage   stage    =    getStage (  )  ;", "if    ( stage    =  =    null )", "return ;", "current    =    this ;", "Vector 2    currentCoords    =    current . getParent (  )  . localToStageCoordinates (  . tmp 2  . set ( current . getX (  )  ,    current . getY (  )  )  )  ;", "Vector 2    bestCoords    =     . tmp 1  ;", "while    ( true )     {", "textField    =    current . findNext ( stage . getActors (  )  ,    null ,    bestCoords ,    currentCoords ,    up )  ;", "if    ( textField    =  =    null )     {", "if    ( up )", "currentCoords . set ( Float . MIN _ VALUE ,    Float . MIN _ VALUE )  ;", "else", "currentCoords . set ( Float . MAX _ VALUE ,    Float . MAX _ VALUE )  ;", "textField    =    current . findNext ( stage . getActors (  )  ,    null ,    bestCoords ,    currentCoords ,    up )  ;", "}", "if    ( textField    =  =    null )     {", "Gdx . input . setOnscreenKeyboardVisible ( false )  ;", "break ;", "}", "if    ( stage . setKeyboardFocus ( textField )  )", "break ;", "current    =    textField ;", "currentCoords . set ( bestCoords )  ;", "}", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    ( content    =  =    null )", "return ;", "StringBuilder   buffer    =    new   StringBuilder (  )  ;", "int   textLength    =    text . length (  )  ;", "if    ( hasSelection )", "textLength    -  =    Math . abs (  (  ( cursor )     -     ( selectionStart )  )  )  ;", "BitmapFont . BitmapFontData   data    =    style . font . getData (  )  ;", "for    ( int   i    =     0  ,    n    =    content . length (  )  ;    i    <    n ;    i +  +  )     {", "if    (  !  ( withinMaxLength (  ( textLength    +     ( buffer . length (  )  )  )  )  )  )", "break ;", "char   c    =    content . charAt ( i )  ;", "if    (  !  (  ( writeEnters )     &  &     (  ( c    =  =     (  . ENTER _ ANDROID )  )     |  |     ( c    =  =     (  . ENTER _ DESKTOP )  )  )  )  )     {", "if    (  ( c    =  =     '  \\ r '  )     |  |     ( c    =  =     '  \\ n '  )  )", "continue ;", "if    (  ( onlyFontChars )     &  &     (  !  ( data . hasGlyph ( c )  )  )  )", "continue ;", "if    (  (  ( filter )     !  =    null )     &  &     (  !  ( filter . acceptChar ( this ,    c )  )  )  )", "continue ;", "}", "buffer . append ( c )  ;", "}", "content    =    buffer . toString (  )  ;", "if    ( hasSelection )", "cursor    =    delete ( fireChangeEvent )  ;", "if    ( fireChangeEvent )", "changeText ( text ,    insert ( cursor ,    content ,    text )  )  ;", "else", "text    =    insert ( cursor ,    content ,    text )  ;", "updateDisplayText (  )  ;", "cursor    +  =    content . length (  )  ;", "}", "METHOD_END"], "methodName": ["paste"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "setSelection (  0  ,    text . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["selectAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . textHAlign    =    alignment ;", "}", "METHOD_END"], "methodName": ["setAlignment"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . blinkTime    =    blinkTime ;", "}", "METHOD_END"], "methodName": ["setBlinkTime"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . clipboard    =    clipboard ;", "}", "METHOD_END"], "methodName": ["setClipboard"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    ( cursorPosition    <     0  )", "throw   new   IllegalArgumentException (  \" cursorPosition   must   be    >  =     0  \"  )  ;", "clearSelection (  )  ;", "cursor    =    Math . min ( cursorPosition ,    t . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCursorPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . disabled    =    disabled ;", "}", "METHOD_END"], "methodName": ["setDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . focusTraversal    =    focusTraversal ;", "}", "METHOD_END"], "methodName": ["setFocusTraversal"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . maxLength    =    maxLength ;", "}", "METHOD_END"], "methodName": ["setMaxLength"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . messageText    =    messageText ;", "}", "METHOD_END"], "methodName": ["setMessageText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . onlyFontChars    =    onlyFontChars ;", "}", "METHOD_END"], "methodName": ["setOnlyFontChars"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . keyboard    =    keyboard ;", "}", "METHOD_END"], "methodName": ["setOnscreenKeyboard"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . passwordCharacter    =    passwordCharacter ;", "if    ( passwordMode )", "updateDisplay (  )  ;", "}", "METHOD_END"], "methodName": ["setPasswordCharacter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . passwordMode    =    passwordMode ;", "updateDisplay (  )  ;", "}", "METHOD_END"], "methodName": ["setPasswordMode"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . programmaticChangeEvents    =    programmaticChangeEvents ;", "}", "METHOD_END"], "methodName": ["setProgrammaticChangeEvents"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    ( selectionStart    <     0  )", "throw   new   IllegalArgumentException (  \" selectionStart   must   be    >  =     0  \"  )  ;", "if    ( selectionEnd    <     0  )", "throw   new   IllegalArgumentException (  \" selectionEnd   must   be    >  =     0  \"  )  ;", "selectionStart    =    Math . min ( t . length (  )  ,    selectionStart )  ;", "selectionEnd    =    Math . min ( t . length (  )  ,    selectionEnd )  ;", "if    ( selectionEnd    =  =    selectionStart )     {", "clearSelection (  )  ;", "return ;", "}", "if    ( selectionEnd    <    selectionStart )     {", "int   temp    =    selectionEnd ;", "selectionEnd    =    selectionStart ;", "selectionStart    =    temp ;", "}", "hasSelection    =    true ;", "this . selectionStart    =    selectionStart ;", "cursor    =    selectionEnd ;", "}", "METHOD_END"], "methodName": ["setSelection"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "this . style    =    style ;", "textHeight    =     ( style . font . getCapHeight (  )  )     -     (  ( style . font . getDet (  )  )     *     2  )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    ( str    =  =    null )", "str    =     \"  \"  ;", "if    ( str . equals ( text )  )", "return ;", "clearSelection (  )  ;", "String   old    =    text ;", "text    =     \"  \"  ;", "paste ( str ,    false )  ;", "if    ( programmaticChangeEvents )", "change ( old ,    text )  ;", "cursor    =     0  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . filter    =    filter ;", "}", "METHOD_END"], "methodName": ["setTextFieldFilter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    listener ;", "}", "METHOD_END"], "methodName": ["setTextFieldListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "BitmapFont   font    =    style . font ;", "BitmapFont . BitmapFontData   data    =    font . getData (  )  ;", "String   text    =    this . text ;", "int   textLength    =    text . length (  )  ;", "StringBuilder   buffer    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    textLength ;    i +  +  )     {", "char   c    =    text . charAt ( i )  ;", "buffer . append (  ( data . hasGlyph ( c )     ?    c    :     '     '  )  )  ;", "}", "String   newDisplay    =    buffer . toString (  )  ;", "if    (  ( passwordMode )     &  &     ( data . hasGlyph ( passwordCharacter )  )  )     {", "if    (  ( passwordBuffer )     =  =    null )", "passwordBuffer    =    new   StringBuilder ( newDisplay . length (  )  )  ;", "if    (  ( passwordBuffer . length (  )  )     >    textLength )", "passwordBuffer . setLength ( textLength )  ;", "else    {", "for    ( int   i    =    passwordBuffer . length (  )  ;    i    <    textLength ;    i +  +  )", "passwordBuffer . append ( passwordCharacter )  ;", "}", "display    =    passwordBuffer ;", "} else", "display    =    newDisplay ;", "layout . set ( font ,    display )  ;", "glyphPositions . clear (  )  ;", "float   x    =     0  ;", "if    (  ( layout . runs . size )     >     0  )     {", "GlyphLayout . GlyphRun   run    =    layout . runs . first (  )  ;", "FloatArray   xAdvances    =    run . xAdvances ;", "fontOffset    =    xAdvances . first (  )  ;", "for    ( int   i    =     1  ,    n    =    xAdvances . size ;    i    <    n ;    i +  +  )     {", "glyphPositions . add ( x )  ;", "x    +  =    xAdvances . get ( i )  ;", "}", "} else", "fontOffset    =     0  ;", "glyphPositions . add ( x )  ;", "if    (  ( selectionStart )     >     ( newDisplay . length (  )  )  )", "selectionStart    =    textLength ;", "}", "METHOD_END"], "methodName": ["updateDisplayText"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return    (  ( maxLength )     <  =     0  )     |  |     ( size    <     ( maxLength )  )  ;", "}", "METHOD_END"], "methodName": ["withinMaxLength"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "return   wordUnderCursor ( letterUnderCursor ( x )  )  ;", "}", "METHOD_END"], "methodName": ["wordUnderCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "String   text    =    this . text ;", "int   start    =    at ;", "int   right    =    text . length (  )  ;", "int   left    =     0  ;", "int   index    =    start ;", "if    ( at    >  =     ( text . length (  )  )  )     {", "left    =    text . length (  )  ;", "right    =     0  ;", "} else    {", "for    (  ;    index    <    right ;    index +  +  )     {", "if    (  !  ( isWordCharacter ( text . charAt ( index )  )  )  )     {", "right    =    index ;", "break ;", "}", "}", "for    ( index    =    start    -     1  ;    index    >     (  -  1  )  ;    index -  -  )     {", "if    (  !  ( isWordCharacter ( text . charAt ( index )  )  )  )     {", "left    =    index    +     1  ;", "break ;", "}", "}", "}", "return   new   int [  ]  {    left ,    right    }  ;", "}", "METHOD_END"], "methodName": ["wordUnderCursor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextField"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   NullPointerException (  \" style   cannot   be   null \"  )  ;", "if    (  !  ( style   instanceofStyle )  )", "throw   new   IllegalArgumentException (  \" style   must   be   aStyle .  \"  )  ;", "container . getActor (  )  . setStyle ( style . label )  ;", "container . setBackground ( style . background )  ;", "container . maxWidth ( style . wrapWidth )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TextTooltip"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    !  =     (  -  1  )  )", "return ;", "if    ( Gdx . input . isTouched (  )  )", "return ;", "Actor   actor    =    event . getListenerActor (  )  ;", "if    (  ( fromActor    !  =    null )     &  &     ( fromActor . isDedantOf ( actor )  )  )", "return ;", "setContainerPosition ( actor ,    x ,    y )  ;", "manager . enter ( this )  ;", "}", "METHOD_END"], "methodName": ["enter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "if    (  ( toActor    !  =    null )     &  &     ( toActor . isDescendantOf ( event . getListenerActor (  )  )  )  )", "return ;", "hide (  )  ;", "}", "METHOD_END"], "methodName": ["exit"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "return   container . getActor (  )  ;", "}", "METHOD_END"], "methodName": ["getActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "return   container ;", "}", "METHOD_END"], "methodName": ["getContainer"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "return   manager ;", "}", "METHOD_END"], "methodName": ["getManager"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "manager . hide ( this )  ;", "}", "METHOD_END"], "methodName": ["hide"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "if    ( container . hasParent (  )  )", "return   false ;", "setContainerPosition ( event . getListrActor (  )  ,    x ,    y )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["mouseMoved"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "container . setActor ( contents )  ;", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "this . always    =    always ;", "}", "METHOD_END"], "methodName": ["setAlways"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "this . targetActor    =    actor ;", "Stage   stage    =    actor . getStage (  )  ;", "if    ( stage    =  =    null )", "return ;", "container . pack (  )  ;", "float   offsetX    =    manager . offsetX ;", "float   offsetY    =    manager . offsetY ;", "float   dist    =    manager . edgeDistance ;", "Vector 2    point    =    actor . localToStageCoordinates (  . tmp . set (  ( x    +    offsetX )  ,     (  ( y    -    offsetY )     -     ( container . getHeight (  )  )  )  )  )  ;", "if    (  ( point . y )     <    dist )", "point    =    actor . localToStageCoordinates (  . tmp . set (  ( x    +    offsetX )  ,     ( y    +    offsetY )  )  )  ;", "if    (  ( point . x )     <    dist )", "point . x    =    dist ;", "if    (  (  ( point . x )     +     ( container . getWidth (  )  )  )     >     (  ( stage . getWidth (  )  )     -    dist )  )", "point . x    =     (  ( stage . getWidth (  )  )     -    dist )     -     ( container . getWidth (  )  )  ;", "if    (  (  ( point . y )     +     ( container . getHeight (  )  )  )     >     (  ( stage . getHeight (  )  )     -    dist )  )", "point . y    =     (  ( stage . getHeight (  )  )     -    dist )     -     ( container . getHeight (  )  )  ;", "container . setPosition ( point . x ,    point . y )  ;", "point    =    actor . localToStageCoordinates (  . tmp . set (  (  ( actor . getWidth (  )  )     /     2  )  ,     (  ( actor . getHeight (  )  )     /     2  )  )  )  ;", "point . sub ( container . getX (  )  ,    container . getY (  )  )  ;", "container . setOrigin ( point . x ,    point . y )  ;", "}", "METHOD_END"], "methodName": ["setContainerPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "this . instant    =    instant ;", "}", "METHOD_END"], "methodName": ["setInstant"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "if    ( instant )     {", "ntainer . toFront (  )  ;", "return   false ;", "}", "manager . touchDown ( this )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tooltip"}, {"methodBody": ["METHOD_START", "{", "showTooltip    =    tooltip ;", "showTask . cancel (  )  ;", "if    (  ( enabled )     |  |     ( tooltip . always )  )     {", "if    (  (  ( time )     =  =     0  )     |  |     ( tooltip . instant )  )", "showTask . run (  )  ;", "else", "utils . Timer . schedule ( showTask ,    time )  ;", "}", "}", "METHOD_END"], "methodName": ["enter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( TooltipManager . files )     =  =    null )     |  |     (  ( TooltipManager . files )     !  =     ( Gdx . files )  )  )     {", "TooltipManager . files    =    Gdx . files ;", "TooltipManager . instance    =    new   TooltipManager (  )  ;", "}", "return   TooltipManager . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "showTooltip    =    null ;", "showTask . cancel (  )  ;", "if    ( tooltip . container . hasParent (  )  )     {", "shown . removeValue ( tooltip ,    true )  ;", "hideAction ( tooltip )  ;", "resetTask . cancel (  )  ;", "Timer . schedule ( resetTask ,    resetTime )  ;", "}", "}", "METHOD_END"], "methodName": ["hide"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "tooltip . container . addAction ( Actions . sequence ( Actions . parallel ( Actions . alpha (  0  .  2 F ,     0  .  2 F ,    Interpolation . fade )  ,    Actions . scaleTo (  0  .  0  5 F ,     0  .  0  5 F ,     0  .  2 F ,    Interpolation . fade )  )  ,    Actions . removeActor (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hideAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "resetTask . cancel (  )  ;", "showTask . cancel (  )  ;", "time    =    initialTime ;", "show    =    null ;", "for    (    tooltip    :    shown )", "tooltip . hide (  )  ;", "shown . clear (  )  ;", "}", "METHOD_END"], "methodName": ["hideAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "time    =     0  ;", "showTask . run (  )  ;", "showTask . cancel (  )  ;", "}", "METHOD_END"], "methodName": ["instant"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "float   actionTime    =     ( animations )     ?     ( time )     >     0     ?     0  .  5 F    :     0  .  1  5 F    :     0  .  1 F ;", "t . container . setTransform ( true )  ;", "t . container . getColor (  )  . a    =     0  .  2 F ;", "t . container . setScale (  0  .  0  5 F )  ;", "t . container . addAction ( Actions . parallel ( Actions . fadeIn ( actionTime ,    Interpolation . fade )  ,    Actions . scaleTo (  1  ,     1  ,    actionTime ,    Interpolation . fade )  )  )  ;", "}", "METHOD_END"], "methodName": ["showAction"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "showTask . cancel (  )  ;", "if    ( tooltip . container . remove (  )  )", "resetTask . cancel (  )  ;", "resetTask . run (  )  ;", "if    (  ( enabled )     |  |     ( tooltip . always )  )     {", "show    =    tooltip ;", "Timer . schedule ( showTask ,    time )  ;", "}", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.TooltipManager"}, {"methodBody": ["METHOD_START", "{", "float   oldPositionX    =    knobPosition . x ;", "float   oldPositionY    =    knobPosition . y ;", "float   oldPercentX    =    knobPercent . x ;", "float   oldPercentY    =    knobPercent . y ;", "float   centerX    =    knobBounds . x ;", "float   centerY    =    knobBounds . y ;", "knobPosition . set ( centerX ,    centerY )  ;", "knobPercent . set (  0  .  0 F ,     0  .  0 F )  ;", "if    (  ! isUp )     {", "if    (  !  ( deadzoneBounds . contains ( x ,    y )  )  )     {", "knobPercent . set (  (  ( x    -    centerX )     /     ( knobBounds . radius )  )  ,     (  ( y    -    centerY )     /     ( knobBounds . radius )  )  )  ;", "float   length    =    knobPercent . len (  )  ;", "if    ( length    >     1  )", "knobPercent . scl (  (  1     /    length )  )  ;", "if    ( knobBounds . contains ( x ,    y )  )     {", "knobPosition . set ( x ,    y )  ;", "} else    {", "knobPosition . set ( knobPercent )  . nor (  )  . scl ( knobBounds . radius )  . add ( knobBounds . x ,    knobBounds . y )  ;", "}", "}", "}", "if    (  ( oldPercentX    !  =     ( knobPercent . x )  )     |  |     ( oldPercentY    !  =     ( knobPercent . y )  )  )     {", "ChangeListener . ChangeEvent   changeEvent    =    Pools . obtain ( ChangeListener . ChangeEvent . class )  ;", "if    ( fire ( changeEvent )  )     {", "knobPercent . set ( oldPercentX ,    oldPercentY )  ;", "knobPosition . set ( oldPositionX ,    oldPositionY )  ;", "}", "Pools . free ( changeEvent )  ;", "}", "}", "METHOD_END"], "methodName": ["calculatePositionAndValue"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "return   knobPercent . x ;", "}", "METHOD_END"], "methodName": ["getKnobPercentX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "return   knobPercent . y ;", "}", "METHOD_END"], "methodName": ["getKnobPercentY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "return   knobPosition . x ;", "}", "METHOD_END"], "methodName": ["getKnobX"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "return   knobPosition . y ;", "}", "METHOD_END"], "methodName": ["getKnobY"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "return   resetOnTouchUp ;", "}", "METHOD_END"], "methodName": ["getResetOnTouchUp"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "return   touched ;", "}", "METHOD_END"], "methodName": ["isTouched"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "if    ( deadzoneRadius    <     0  )", "throw   new   IllegalArgumentException (  \" deadzoneRadius   must   be    >     0  \"  )  ;", "this . deadzoneRadius    =    deadzoneRadius ;", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setDeadzone"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "this . resetOnTouchUp    =    reset ;", "}", "METHOD_END"], "methodName": ["setResetOnTouchUp"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null \"  )  ;", "thityle    =    style ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Touchpad"}, {"methodBody": ["METHOD_START", "{", "insert ( rootNodes . size ,    node )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "super . clearChildren (  )  ;", "setOverNode ( null )  ;", "rootNodclear (  )  ;", "selection . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearChildren"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "Tree . collapseAll ( rootNodes )  ;", "}", "METHOD_END"], "methodName": ["collapseAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "node . setExpanded ( false )  ;", "Tree . collapseAll ( node . children )  ;", "}", "}", "METHOD_END"], "methodName": ["collapseAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "sizeInvalid    =    false ;", "prefWidth    =    style . plus . getMinWidth (  )  ;", "prefWidth    =    Math . max ( prefWidth ,    style . minus . getMinWidth (  )  )  ;", "prefHeight    =    getHeight (  )  ;", "float   plusMinusWidth    =    Math . max ( style . plus . getMinWidth (  )  ,    style . minus . getMinWidth (  )  )  ;", "puteSize ( rootNodes ,    indentSpacing ,    plusMinusWidth )  ;", "prefWidth    +  =     ( padding )     *     2  ;", "prefHeight    =     ( getHeight (  )  )     -     ( prefHeight )  ;", "}", "METHOD_END"], "methodName": ["computeSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "float   ySpacing    =    this . ySpacing ;", "float   spacing    =     ( iconSpacingLeft )     +     ( iconSpacingRight )  ;", "for    ( int   i    =     0  ,    n    =    nodize ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "float   rowWidth    =    indent    +    plusMinusWidth ;", "Actor   actor    =    node . actor ;", "if    ( actor   instanceof   Layout )     {", "Layout   layout    =     (  ( Layout )     ( actor )  )  ;", "rowWidth    +  =    layout . getPrefWidth (  )  ;", "node . height    =    layout . getPrefHeight (  )  ;", "layout . pack (  )  ;", "} else    {", "rowWidth    +  =    actor . getWidth (  )  ;", "node . height    =    actor . getHeight (  )  ;", "}", "if    (  ( node . icon )     !  =    null )     {", "rowWidth    +  =    spacing    +     ( node . icon . getMinWidth (  )  )  ;", "node . height    =    Math . max ( node . height ,    node . icon . getMinHeight (  )  )  ;", "}", "prefWidth    =    Math . max ( prefWidth ,    rowWidth )  ;", "prefHeight    -  =     ( node . height )     +    ySpacing ;", "if    ( node . expanded )", "computeSize ( node . children ,     ( indent    +     ( indentSpacing )  )  ,    plusMinusWidth )  ;", "}", "}", "METHOD_END"], "methodName": ["computeSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "Drawable   plus    =    style . plus ;", "Drawable   minus    =    style . minus ;", "float   x    =    getX (  )  ;", "float   y    =    getY (  )  ;", "float   expandX    =    x    +    indent ;", "float   iconX    =     ( expandX    +    plusMinusWidth )     +     ( iconSpacingLeft )  ;", "for    ( int   i    =     0  ,    n    =    nodize ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "float   height    =    node . height ;", "Actor   actor    =    node . actor ;", "if    (  ( selection . contains ( node )  )     &  &     (  ( style . selection )     !  =    null )  )     {", "style . selection . draw ( batch ,    x ,     (  ( y    +     ( actor . getY (  )  )  )     -     (  ( ySpacing )     /     2  )  )  ,    getWidth (  )  ,     ( height    +     ( ySpacing )  )  )  ;", "} else", "if    (  ( node    =  =     ( overNode )  )     &  &     (  ( style . over )     !  =    null )  )     {", "style . over . draw ( batch ,    x ,     (  ( y    +     ( actor . getY (  )  )  )     -     (  ( ySpacing )     /     2  )  )  ,    getWidth (  )  ,     ( height    +     ( ySpacing )  )  )  ;", "}", "if    (  ( node . icon )     !  =    null )     {", "float   iconY    =     ( y    +     ( actor . getY (  )  )  )     +     ( Math . round (  (  ( height    -     ( node . icon . getMinHeight (  )  )  )     /     2  )  )  )  ;", "batch . setColor ( actor . getColor (  )  )  ;", "node . icon . draw ( batch ,    iconX ,    iconY ,    node . icon . getMinWidth (  )  ,    node . icon . getMinHeight (  )  )  ;", "batch . setColor ( Color . WHITE )  ;", "}", "if    (  ( node . children . size )     =  =     0  )", "continue ;", "Drawable   expandIcon    =     ( node . expanded )     ?    minus    :    plus ;", "float   iconY    =     ( y    +     ( actor . getY (  )  )  )     +     ( Math . round (  (  ( height    -     ( expandIcon . getMinHeight (  )  )  )     /     2  )  )  )  ;", "expandIcon . draw ( batch ,    expandX ,    iconY ,    expandIcon . getMinWidth (  )  ,    expandIcon . getMinHeight (  )  )  ;", "if    ( node . expanded )", "draw ( batch ,    node . children ,     ( indent    +     ( indentSpacing )  )  ,    plusMinusWidth )  ;", "}", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "drawBackground ( batch ,    a )  ;", "Color   color    =    getColor (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,     (  ( color . a )     *    a )  )  ;", "float   plusMinusWidth    =    Math . max ( style . plus . getMinWidth (  )  ,    style . minus . getMinWidth (  )  )  ;", "draw ( batch ,    rootNodes ,    padding ,    plusMinusWidth )  ;", "super . draw ( batch ,    a )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "if    (  ( style . background )     !  =    null )     {", "Color   color    =    getColor (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,     (  ( color . a )     *    a )  )  ;", "style . background . draw ( batch ,    getX (  )  ,    getY (  )  ,    getWidth (  )  ,    getHeight (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["drawBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "Tree . expandAll ( rootNodes )  ;", "}", "METHOD_END"], "methodName": ["expandAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;    i +  +  )", "nodes . get ( i )  . expandAll (  )  ;", "}", "METHOD_END"], "methodName": ["expandAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "Tree . findExpandedObjects ( rootNodes ,    objects )  ;", "}", "METHOD_END"], "methodName": ["findExpandedObjects"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "boolean   expanded    =    false ;", "for    ( int   i    =     0  ,    n    =    nodize ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "if    (  ( node . expanded )     &  &     (  !  ( Tree . findExpandedObjects ( node . children ,    objects )  )  )  )", "objects . add ( node . object )  ;", "}", "return   expanded ;", "}", "METHOD_END"], "methodName": ["findExpandedObjects"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "if    ( object . equals ( node . object )  )", "return   node ;", "}", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "Tree . Node   found    =    Tree . findNode ( node . children ,    object )  ;", "if    ( found    !  =    null )", "return   found ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findNode"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )", "throw   new   IllegalArgumentException (  \" object   cannot   be   null .  \"  )  ;", "return    . findNode ( rootNodes ,    object )  ;", "}", "METHOD_END"], "methodName": ["findNode"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   clickListener ;", "}", "METHOD_END"], "methodName": ["getClickListener"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   indentSpacing ;", "}", "METHOD_END"], "methodName": ["getIndentSpacing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "float   height    =    node . height ;", "rowY    -  =     ( node . getHeight (  )  )     -    height ;", "if    (  ( y    >  =     (  ( rowY    -    height )     -     ( ySpacing )  )  )     &  &     ( y    <    rowY )  )     {", "foundNode    =    node ;", "return    -  1  ;", "}", "rowY    -  =    height    +     ( ySpacing )  ;", "if    ( node . expanded )     {", "rowY    =    getNodeAt ( node . children ,    y ,    rowY )  ;", "if    ( rowY    =  =     (  -  1  )  )", "return    -  1  ;", "}", "}", "return   rowY ;", "}", "METHOD_END"], "methodName": ["getNodeAt"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "foundNode    =    null ;", "getNodeAt ( rootNod ,    y ,    getHeight (  )  )  ;", "return   foundNode ;", "}", "METHOD_END"], "methodName": ["getNodeAt"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   rootNodes ;", "}", "METHOD_END"], "methodName": ["getNodes"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   overNode ;", "}", "METHOD_END"], "methodName": ["getOverNode"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "if    (  ( overNode )     =  =    null )", "turn   null ;", "turn   overNode . getObject (  )  ;", "}", "METHOD_END"], "methodName": ["getOverObject"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   rootNodes ;", "}", "METHOD_END"], "methodName": ["getRootNodes"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   selection ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   ySpacing ;", "}", "METHOD_END"], "methodName": ["getYSpacing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "addListener (  ( clickListener    =    new   ClickListener (  )     {", "public   void   clicked ( InputEvent   event ,    float   x ,    float   y )     {", ". Node   node    =    getNodeAt ( y )  ;", "if    ( node    =  =    null )", "return ;", "if    ( node    !  =     ( getNodeAt ( getTouchDownY (  )  )  )  )", "return ;", "if    (  (  ( selection . getMultiple (  )  )     &  &     ( selection . hasItems (  )  )  )     &  &     ( UIUtils . shift (  )  )  )     {", "if    (  ( rangeStart )     =  =    null )", "rangeStart    =    node ;", ". Node   rangeStart    =     . this . rangeStart ;", "if    (  !  ( UIUtils . ctrl (  )  )  )", "selection . clear (  )  ;", "float   start    =    rangeStart . actor . getY (  )  ;", "float   end    =    node . actor . getY (  )  ;", "if    ( start    >    end )", "selectNodes ( rootNodes ,    end ,    start )  ;", "else    {", "selectNodes ( rootNodes ,    start ,    end )  ;", "selection . items (  )  . orderedItems (  )  . reverse (  )  ;", "}", "selection . fireChangeEvent (  )  ;", ". this . rangeStart    =    rangeStart ;", "return ;", "}", "if    (  (  ( node . children . size )     >     0  )     &  &     (  (  !  ( selection . getMultiple (  )  )  )     |  |     (  !  ( UIUtils . ctrl (  )  )  )  )  )     {", "float   rowX    =    node . actor . getX (  )  ;", "if    (  ( node . icon )     !  =    null )", "rowX    -  =     ( iconSpacingRight )     +     ( node . icon . getMinWidth (  )  )  ;", "if    ( x    <    rowX )     {", "node . setExpanded (  (  !  ( node . expanded )  )  )  ;", "return ;", "}", "}", "if    (  !  ( node . isSelectable (  )  )  )", "return ;", "selection . choose ( node )  ;", "if    (  !  ( selection . isEmpty (  )  )  )", "rangeStart    =    node ;", "}", "public   boolean   mouseMoved ( InputEvent   event ,    float   x ,    float   y )     {", "setOverNode ( getNodeAt ( y )  )  ;", "return   false ;", "}", "public   void   exit ( InputEvent   event ,    float   x ,    float   y ,    int   pointer ,    Actor   toActor )     {", "super . exit ( event ,    x ,    y ,    pointer ,    toActor )  ;", "if    (  ( toActor    =  =    null )     |  |     (  !  ( toActor . isDescendantOf (  . this )  )  )  )", "setOverNode ( null )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "remove ( node )  ;", "node . parent    =    null ;", "rootNodes . insert ( index ,    node )  ;", "node . addTo ( this )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "super . invalidate (  )  ;", "sizeInvalid    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "float   plusMinusWidth    =    Math . max ( style . plus . getMinWidth (  )  ,    style . minus . getMinWidth (  )  )  ;", "layout ( rootNodes ,    padding ,     (  ( getHeight (  )  )     -     (  ( ySpacing )     /     2  )  )  ,    plusMinusWidth )  ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "float   ySpacing    =    this . ySpacing ;", "float   spacing    =     ( iconSpacingLeft )     +     ( iconSpacingRight )  ;", "for    ( int   i    =     0  ,    n    =    nodize ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "float   x    =    indent    +    plusMinusWidth ;", "if    (  ( node . icon )     !  =    null )", "x    +  =    spacing    +     ( node . icon . getMinWidth (  )  )  ;", "y    -  =    node . getHeight (  )  ;", "node . actor . setPosition ( x ,    y )  ;", "y    -  =    ySpacing ;", "if    ( node . expanded )", "y    =    layout ( node . children ,     ( indent    +     ( indentSpacing )  )  ,    y ,    plusMinusWidth )  ;", "}", "return   y ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node . parent )     !  =    null )     {", "node . parent . remove ( node )  ;", "return ;", "}", "rootNodes . removeValue ( node ,    true )  ;", "node . removeFrom ( this )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    objects . size ;    i    <    n ;    i +  +  )     {", ". Node   node    =    findNode ( objects . get ( i )  )  ;", "if    ( node    !  =    null )     {", "node . setExpanded ( true )  ;", "node . expandTo (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["restoreExpandedObjects"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    nodes . size ;    i    <    n ;    i +  +  )     {", "Tree . Node   node    =    nodes . get ( i )  ;", "if    (  ( node . actor . getY (  )  )     <    low )", "break ;", "if    (  !  ( node . isSelectable (  )  )  )", "continue ;", "if    (  ( node . actor . getY (  )  )     <  =    high )", "selection . add ( node )  ;", "if    ( node . expanded )", "selectNodes ( node . children ,    low ,    high )  ;", "}", "}", "METHOD_END"], "methodName": ["selectNodes"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "this . iconSpacingLeft    =    left ;", "this . iconSpacingRight    =    right ;", "}", "METHOD_END"], "methodName": ["setIconSpacing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "this . indentSpacing    =    indentSpacing ;", "}", "METHOD_END"], "methodName": ["setIndentSpacing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "this . overNode    =    overNode ;", "}", "METHOD_END"], "methodName": ["setOverNode"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "this . padding    =    padding ;", "}", "METHOD_END"], "methodName": ["setPadding"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "this . style    =    style ;", "if    (  ( indentSpacing )     =  =     0  )", "indentSpacing    =    Math . max ( style . plus . getMinWidth (  )  ,    style . minus . getMinWidth (  )  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "this . ySpacing    =    ySpacing ;", "}", "METHOD_END"], "methodName": ["setYSpacing"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Tree"}, {"methodBody": ["METHOD_START", "{", "return   new   Value (  )     {", "public   float   get ( Actor   actor )     {", "return    ( actor . getHeight (  )  )     *    percent ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["percentHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Value"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   null .  \"  )  ;", "return   new    (  )     {", "public   float   get ( Actor   context )     {", "return    ( actor . getHeight (  )  )     *    percent ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["percentHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Value"}, {"methodBody": ["METHOD_START", "{", "return   new   Value (  )     {", "public   float   get ( Actor   actor )     {", "return    ( actor . getWidth (  )  )     *    percent ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["percentWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Value"}, {"methodBody": ["METHOD_START", "{", "if    ( actor    =  =    null )", "throw   new   IllegalArgumentException (  \" actor   cannot   be   null .  \"  )  ;", "return   new    (  )     {", "public   float   get ( Actor   context )     {", "return    ( actor . getWidth (  )  )     *    percent ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["percentWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Value"}, {"methodBody": ["METHOD_START", "{", "this . align    =    align ;", "return   this ;", "}", "METHOD_END"], "methodName": ["align"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . bottom ;", "align    &  =     ~  ( Align . top )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "align    =    Align . center ;", "return   this ;", "}", "METHOD_END"], "methodName": ["center"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . columnAlign    =    columnAlign ;", "return   this ;", "}", "METHOD_END"], "methodName": ["columnAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "columnAlign    =    Align . center ;", "return   this ;", "}", "METHOD_END"], "methodName": ["columnCenter"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "columnAlign    |  =    Align . left ;", "columnAlign    &  =     ~  ( Align . right )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["columnLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "columnAlign    |  =    Align . right ;", "columnAlign    &  =     ~  ( Align . left )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["columnRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "sizeInvalid    =    false ;", "SnapshotArray < Actor >    children    =    getChildren (  )  ;", "int   n    =    children . size ;", "prefWidth    =     0  ;", "if    ( wrap )     {", "prefHeight    =     0  ;", "if    (  ( columnSizes )     =  =    null )", "columnSizes    =    new   FloatArray (  )  ;", "else", "columnSizes . clear (  )  ;", "FloatArray   columnSizes    =    this . columnSizes ;", "float   space    =    this . space ;", "float   wrapSpace    =    this . wrapSpace ;", "float   pad    =     ( padTop )     +     ( padBottom )  ;", "float   gHeight    =     ( getHeight (  )  )     -    pad ;", "float   x    =     0  ;", "float   y    =     0  ;", "float   columnWidth    =     0  ;", "int   i    =     0  ;", "int   incr    =     1  ;", "if    ( reverse )     {", "i    =    n    -     1  ;", "n    =     -  1  ;", "incr    =     -  1  ;", "}", "for    (  ;    i    !  =    n ;    i    +  =    incr )     {", "Actor   child    =    children . get ( i )  ;", "float   width ;", "float   height ;", "if    ( child   instanceof   Layout )     {", "Layout   layout    =     (  ( Layout )     ( child )  )  ;", "width    =    layout . getPrefWidth (  )  ;", "height    =    layout . getPrefHeight (  )  ;", "} else    {", "width    =    child . getWidth (  )  ;", "height    =    child . getHeight (  )  ;", "}", "float   incrY    =    height    +     ( y    >     0     ?    space    :     0  )  ;", "if    (  (  ( y    +    incrY )     >    gHeight )     &  &     ( y    >     0  )  )     {", "columnSizes . add ( y )  ;", "columnSizes . add ( columnWidth )  ;", "prefHeight    =    Math . max ( prefHeight ,     ( y    +    pad )  )  ;", "if    ( x    >     0  )", "x    +  =    wrapSpace ;", "x    +  =    columnWidth ;", "columnWidth    =     0  ;", "y    =     0  ;", "incrY    =    height ;", "}", "y    +  =    incrY ;", "columnWidth    =    Math . max ( columnWidth ,    width )  ;", "}", "columnSizes . add ( y )  ;", "columnSizes . add ( columnWidth )  ;", "prefHeight    =    Math . max ( prefHeight ,     ( y    +    pad )  )  ;", "if    ( x    >     0  )", "x    +  =    wrapSpace ;", "prefWidth    =    Math . max ( prefWidth ,     ( x    +    columnWidth )  )  ;", "} else    {", "prefHeight    =     (  ( padTop )     +     ( padBottom )  )     +     (  ( space )     *     ( n    -     1  )  )  ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "Actor   child    =    children . get ( i )  ;", "if    ( child   instanceof   Layout )     {", "Layout   layout    =     (  ( Layout )     ( child )  )  ;", "prefWidth    =    Math . max ( prefWidth ,    layout . getPrefWidth (  )  )  ;", "prefHeight    +  =    layout . getPrefHeight (  )  ;", "} else    {", "prefWidth    =    Math . max ( prefWidth ,    child . getWidth (  )  )  ;", "prefHeight    +  =    child . getHeight (  )  ;", "}", "}", "}", "prefWidth    +  =     ( padLeft )     +     ( padRight )  ;", "if    ( round )     {", "prefWidth    =    Math . round ( prefWidth )  ;", "prefHeight    =    Math . round ( prefHeight )  ;", "}", "}", "METHOD_END"], "methodName": ["computeSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "super . drawDebugBounds ( shapes )  ;", "if    (  !  ( getDebug (  )  )  )", "return ;", "shapet ( ShapeRenderer . ShapeType . Line )  ;", "shapetColor ( getStage (  )  . getDebugColor (  )  )  ;", "shapes . rect (  (  ( getX (  )  )     +     ( padLeft )  )  ,     (  ( getY (  )  )     +     ( padBottom )  )  ,    getOriginX (  )  ,    getOriginY (  )  ,     (  (  ( getWidth (  )  )     -     ( padLeft )  )     -     ( padRight )  )  ,     (  (  ( getHeight (  )  )     -     ( padBottom )  )     -     ( padTop )  )  ,    getScaleX (  )  ,    getScaleY (  )  ,    getRotation (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawDebugBounds"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "expand    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . expand    =    expand ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "fill    =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . fill    =    fill ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   align ;", "}", "METHOD_END"], "methodName": ["getAlign"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   expand ;", "}", "METHOD_END"], "methodName": ["getExpand"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   fill ;", "}", "METHOD_END"], "methodName": ["getFill"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padBottom ;", "}", "METHOD_END"], "methodName": ["getPadBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padLeft ;", "}", "METHOD_END"], "methodName": ["getPadLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padRight ;", "}", "METHOD_END"], "methodName": ["getPadRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   padTop ;", "}", "METHOD_END"], "methodName": ["getPadTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( wrap )", "return    0  ;", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefHeight ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "return   prefWidth ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   reverse ;", "}", "METHOD_END"], "methodName": ["getReverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   space ;", "}", "METHOD_END"], "methodName": ["getSpace"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   wrap ;", "}", "METHOD_END"], "methodName": ["getWrap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "return   wrapSpace ;", "}", "METHOD_END"], "methodName": ["getWrapSpace"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "expand    =    true ;", "fill    =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["grow"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "super . invalidate (  )  ;", "sizeInvalid    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "if    ( sizeInvalid )", "puteSize (  )  ;", "if    ( wrap )     {", "layoutWrapped (  )  ;", "return ;", "}", "boolean   round    =    this . round ;", "int   align    =    this . align ;", "float   space    =    this . space ;", "float   padLeft    =    this . padLeft ;", "float   fill    =    this . fill ;", "float   columnWidth    =     (  ( expand    ?    getWidth (  )     :    prefWidth )     -    padLeft )     -     ( padRight )  ;", "float   y    =     (  ( prefHeight )     -     ( padTop )  )     +    space ;", "if    (  ( align    &     ( Align . top )  )     !  =     0  )", "y    +  =     ( getHeight (  )  )     -     ( prefHeight )  ;", "else", "if    (  ( align    &     ( Align . bottom )  )     =  =     0  )", "y    +  =     (  ( getHeight (  )  )     -     ( prefHeight )  )     /     2  ;", "float   startX ;", "if    (  ( align    &     ( Align . left )  )     !  =     0  )", "startX    =    padLeft ;", "else", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "startX    =     (  ( getWidth (  )  )     -     ( padRight )  )     -    columnWidth ;", "else", "startX    =    padLeft    +     (  (  (  (  ( getWidth (  )  )     -    padLeft )     -     ( padRight )  )     -    columnWidth )     /     2  )  ;", "align    =    columnAlign ;", "SnapshotArray < Actor >    children    =    getChildren (  )  ;", "int   i    =     0  ;", "int   n    =    children . size ;", "int   incr    =     1  ;", "if    ( reverse )     {", "i    =    n    -     1  ;", "n    =     -  1  ;", "incr    =     -  1  ;", "}", "for    ( int   r    =     0  ;    i    !  =    n ;    i    +  =    incr )     {", "Actor   child    =    children . get ( i )  ;", "float   width ;", "float   height ;", "Layout   layout    =    null ;", "if    ( child   instanceof   Layout )     {", "layout    =     (  ( Layout )     ( child )  )  ;", "width    =    layout . getPrefWidth (  )  ;", "height    =    layout . getPrefHeight (  )  ;", "} else    {", "width    =    child . getWidth (  )  ;", "height    =    child . getHeight (  )  ;", "}", "if    ( fill    >     0  )", "width    =    columnWidth    *    fill ;", "if    ( layout    !  =    null )     {", "width    =    Math . max ( width ,    layout . getMinWidth (  )  )  ;", "float   maxWidth    =    layout . getMaxWidth (  )  ;", "if    (  ( maxWidth    >     0  )     &  &     ( width    >    maxWidth )  )", "width    =    maxWidth ;", "}", "float   x    =    startX ;", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "x    +  =    columnWidth    -    width ;", "else", "if    (  ( align    &     ( Align . left )  )     =  =     0  )", "x    +  =     ( columnWidth    -    width )     /     2  ;", "y    -  =    height    +    space ;", "if    ( round )", "child . setBounds ( Math . round ( x )  ,    Math . round ( y )  ,    Math . round ( width )  ,    Math . round ( height )  )  ;", "else", "child . setBounds ( x ,    y ,    width ,    height )  ;", "if    ( layout    !  =    null )", "layout . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "float   prefWidth    =    getPrefWidth (  )  ;", "if    ( prefWidth    !  =     ( lastPrefWidth )  )     {", "lastPrefWidth    =    prefWidth ;", "invalidateHierarchy (  )  ;", "}", "int   align    =    this . align ;", "boolean   round    =    this . round ;", "float   space    =    this . space ;", "float   padLeft    =    this . padLeft ;", "float   fill    =    this . fill ;", "float   wrapSpace    =    this . wrapSpace ;", "float   maxHeight    =     (  ( prefHeight )     -     ( padTop )  )     -     ( padBottom )  ;", "float   columnX    =    padLeft ;", "float   gHeight    =    getHeight (  )  ;", "float   yStart    =     (  ( prefHeight )     -     ( padTop )  )     +    space ;", "float   y    =     0  ;", "float   columnWidth    =     0  ;", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "columnX    +  =     ( getWidth (  )  )     -    prefWidth ;", "else", "if    (  ( align    &     ( Align . left )  )     =  =     0  )", "columnX    +  =     (  ( getWidth (  )  )     -    prefWidth )     /     2  ;", "if    (  ( align    &     ( Align . top )  )     !  =     0  )", "yStart    +  =    gHeight    -     ( prefHeight )  ;", "else", "if    (  ( align    &     ( Align . bottom )  )     =  =     0  )", "yStart    +  =     ( gHeight    -     ( prefHeight )  )     /     2  ;", "gHeight    -  =    padTop ;", "align    =    columnAlign ;", "FloatArray   columnSizes    =    this . columnSizes ;", "SnapshotArray < Actor >    children    =    getChildren (  )  ;", "int   i    =     0  ;", "int   n    =    children . size ;", "int   incr    =     1  ;", "if    ( reverse )     {", "i    =    n    -     1  ;", "n    =     -  1  ;", "incr    =     -  1  ;", "}", "for    ( int   r    =     0  ;    i    !  =    n ;    i    +  =    incr )     {", "Actor   child    =    children . get ( i )  ;", "float   width ;", "float   height ;", "Layout   layout    =    null ;", "if    ( child   instanceof   Layout )     {", "layout    =     (  ( Layout )     ( child )  )  ;", "width    =    layout . getPrefWidth (  )  ;", "height    =    layout . getPrefHeight (  )  ;", "} else    {", "width    =    child . getWidth (  )  ;", "height    =    child . getHeight (  )  ;", "}", "if    (  (  (  ( y    -    height )     -    space )     <     ( padBottom )  )     |  |     ( r    =  =     0  )  )     {", "y    =    yStart ;", "if    (  ( align    &     ( Align . bottom )  )     !  =     0  )", "y    -  =    maxHeight    -     ( columnSizes . get ( r )  )  ;", "else", "if    (  ( align    &     ( Align . top )  )     =  =     0  )", "y    -  =     ( maxHeight    -     ( columnSizes . get ( r )  )  )     /     2  ;", "if    ( r    >     0  )     {", "columnX    +  =    wrapSpace ;", "columnX    +  =    columnWidth ;", "}", "columnWidth    =    columnSizes . get (  ( r    +     1  )  )  ;", "r    +  =     2  ;", "}", "if    ( fill    >     0  )", "width    =    columnWidth    *    fill ;", "if    ( layout    !  =    null )     {", "width    =    Math . max ( width ,    layout . getMinWidth (  )  )  ;", "float   maxWidth    =    layout . getMaxWidth (  )  ;", "if    (  ( maxWidth    >     0  )     &  &     ( width    >    maxWidth )  )", "width    =    maxWidth ;", "}", "float   x    =    columnX ;", "if    (  ( align    &     ( Align . right )  )     !  =     0  )", "x    +  =    columnWidth    -    width ;", "else", "if    (  ( align    &     ( Align . left )  )     =  =     0  )", "x    +  =     ( columnWidth    -    width )     /     2  ;", "y    -  =    height    +    space ;", "if    ( round )", "child . setBounds ( Math . round ( x )  ,    Math . round ( y )  ,    Math . round ( width )  ,    Math . round ( height )  )  ;", "else", "child . setBounds ( x ,    y ,    width ,    height )  ;", "if    ( layout    !  =    null )", "layout . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["layoutWrapped"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . left ;", "align    &  =     ~  ( Align . right )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "padTop    =    pad ;", "padLeft    =    pad ;", "padBottom    =    pad ;", "padRight    =    pad ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "padTop    =    top ;", "padLeft    =    left ;", "padBottom    =    bottom ;", "padRight    =    right ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padBottom    =    padBottom ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padBottom"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padLeft    =    padLeft ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padLeft"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padRight    =    padRight ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padRight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . padTop    =    padTop ;", "return   this ;", "}", "METHOD_END"], "methodName": ["padTop"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . reverse    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . reverse    =    reverse ;", "return   this ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . right ;", "align    &  =     ~  ( Align . left )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . round    =    round ;", "}", "METHOD_END"], "methodName": ["setRound"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . space    =    space ;", "return   this ;", "}", "METHOD_END"], "methodName": ["space"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "align    |  =    Align . top ;", "align    &  =     ~  ( Align . bottom )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["top"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "wrap    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . wrap    =    wrap ;", "return   this ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "this . wrapSpace    =    wrapSpace ;", "return   this ;", "}", "METHOD_END"], "methodName": ["wrapSpace"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMaxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMaxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "return   getPrefHeight (  )  ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "return   getPrefWidth (  )  ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "needsLayout    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( layoutEnabled )  )", "return ;", "invalidate (  )  ;", "Group   parent    =    Parent (  )  ;", "if    ( parent   instanceof   Layout )", "(  ( Layout )     ( parent )  )  . invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["invalidateHierarchy"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "return   needsLayout ;", "}", "METHOD_END"], "methodName": ["needsLayout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "setSize ( getPrefWidth (  )  ,    getPrefHeight (  )  )  ;", "validate (  )  ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "this . fillParent    =    fillParent ;", "}", "METHOD_END"], "methodName": ["setFillParent"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "layoutEnabled    =    enabled ;", "if    ( enabled )", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setLayoutEnabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["sizeChanged"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( layoutEnabled )  )", "return ;", "Group   parent    =    Parent (  )  ;", "if    (  ( fillParent )     &  &     ( parent    !  =    null )  )     {", "float   parentWidth ;", "float   parentHeight ;", "Stage   stage    =    Stage (  )  ;", "if    (  ( stage    !  =    null )     &  &     ( parent    =  =     ( stage . Root (  )  )  )  )     {", "parentWidth    =    stage . Width (  )  ;", "parentHeight    =    stage . Height (  )  ;", "} else    {", "parentWidth    =    parent . Width (  )  ;", "parentHeight    =    parent . Height (  )  ;", "}", "setSize ( parentWidth ,    parentHeight )  ;", "}", "if    (  !  ( needsLayout )  )", "return ;", "needsLayout    =    false ;", "layout (  )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Widget"}, {"methodBody": ["METHOD_START", "{", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["childrenChanged"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "validate (  )  ;", "super . draw ( batch ,    a )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMaxHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getMaxWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "return   getPrefHeight (  )  ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "return   getPrefWidth (  )  ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getPrefHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "needsLayout    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "invalidate (  )  ;", "parent    =    getParent (  )  ;", "if    ( parent   instanceof   Layout )", "(  ( Layout )     ( parent )  )  . invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["invalidateHierarchy"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "return   needsLayout ;", "}", "METHOD_END"], "methodName": ["needsLayout"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "setSize ( getPrefWidth (  )  ,    getPrefHeight (  )  )  ;", "validate (  )  ;", "if    ( needsLayout )     {", "setSize ( getPrefWidth (  )  ,    getPrefHeight (  )  )  ;", "validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "this . fillParent    =    fillParent ;", "}", "METHOD_END"], "methodName": ["setFillParent"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( layoutEnabled )     =  =    enabled )", "return ;", "layoutEnabled    =    enabled ;", "setLayoutEnabled ( this ,    enabled )  ;", "}", "METHOD_END"], "methodName": ["setLayoutEnabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "SnapshotArray < Actor >    children    =    parent . getChildren (  )  ;", "for    ( int   i    =     0  ,    n    =    children . size ;    i    <    n ;    i +  +  )     {", "Actor   actor    =    children . get ( i )  ;", "if    ( actor   instanceof   Layout )", "(  ( Layout )     ( actor )  )  . setLayoutEnabled ( enabled )  ;", "else", "if    ( actor   instanceof    )", "setLayoutEnabled (  (  (  )     ( actor )  )  ,    enabled )  ;", "}", "}", "METHOD_END"], "methodName": ["setLayoutEnabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["sizeChanged"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( layoutEnabled )  )", "return ;", "Group   parent    =    getParent (  )  ;", "if    (  ( fillParent )     &  &     ( parent    !  =    null )  )     {", "float   parentWidth ;", "float   parentHeight ;", "Stage   stage    =    getStage (  )  ;", "if    (  ( stage    !  =    null )     &  &     ( parent    =  =     ( stage . getRoot (  )  )  )  )     {", "parentWidth    =    stage . getWidth (  )  ;", "parentHeight    =    stage . getHeight (  )  ;", "} else    {", "parentWidth    =    parent . getWidth (  )  ;", "parentHeight    =    parent . getHeight (  )  ;", "}", "if    (  (  ( getWidth (  )  )     !  =    parentWidth )     |  |     (  ( getHeight (  )  )     !  =    parentHeight )  )     {", "setWidth ( parentWidth )  ;", "setHeight ( parentHeight )  ;", "invalidate (  )  ;", "}", "}", "if    (  !  ( needsLayout )  )", "return ;", "needsLayout    =    false ;", "layout (  )  ;", "if    ( needsLayout )     {", "while    ( parent    !  =    null )     {", "if    ( parent   instanceof    )", "return ;", "parent    =    parent . getParent (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )     {", "needsLayout    =    false ;", "layout (  )  ;", "if    (  !  ( needsLayout )  )", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup"}, {"methodBody": ["METHOD_START", "{", "Stage   stage    =    getStage (  )  ;", "if    (  ( stage . getKeyboardFocus (  )  )     =  =    null )", "stage . setKeyboardFocus ( this )  ;", "keepWithinStage (  )  ;", "if    (  ( style . stageBackground )     !  =    null )     {", "stageToLocalCoordinates (  . tmpPosition . set (  0  ,     0  )  )  ;", "stageToLocalCoordinates (  . tmpSize . set ( stage . getWidth (  )  ,    stage . getHeight (  )  )  )  ;", "drawStageBackground ( batch ,    a ,     (  ( getX (  )  )     +     (  . tmpPosition . x )  )  ,     (  ( getY (  )  )     +     (  . tmpPosition . y )  )  ,     (  ( getX (  )  )     +     (  . tmpSize . x )  )  ,     (  ( getY (  )  )     +     (  . tmpSize . y )  )  )  ;", "}", "super . draw ( batch ,    a )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "super . drawBackground ( batch ,    a ,    x ,    y )  ;", "titleTable . getColor (  )  . a    =    getColor (  )  . a ;", "float   padTop    =    getPadTop (  )  ;", "float   padLeft    =    getPadLeft (  )  ;", "titleTable . setSize (  (  (  ( getWidth (  )  )     -    padLeft )     -     ( getPadRight (  )  )  )  ,    padTop )  ;", "titleTable . setPosition ( padLeft ,     (  ( getHeight (  )  )     -    padTop )  )  ;", "drawTitleTable    =    true ;", "titleTable . draw ( batch ,    a )  ;", "drawTitleTable    =    false ;", "}", "METHOD_END"], "methodName": ["drawBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "Color   color    =    getColor (  )  ;", "batch . setColor ( color . r ,    color . g ,    color . b ,     (  ( color . a )     *    a )  )  ;", "style . stageBackground . draw ( batch ,    x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["drawStageBackground"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   Math . max ( super . getPrefWidth (  )  ,     (  (  ( titleTable . getPrefWidth (  )  )     +     ( getPadLeft (  )  )  )     +     ( getPadRight (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrefWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   style ;", "}", "METHOD_END"], "methodName": ["getStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   titleLabel ;", "}", "METHOD_END"], "methodName": ["getTitleLabel"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   titleTable ;", "}", "METHOD_END"], "methodName": ["getTitleTable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "Actor   hit    =    super . hit ( x ,    y ,    touchable )  ;", "if    (  (  ( hit    =  =    null )     &  &     ( isModal )  )     &  &     (  (  ! touchable )     |  |     (  ( getTouchable (  )  )     =  =     ( Touchable . abled )  )  )  )", "return   this ;", "float   height    =    getHeight (  )  ;", "if    (  ( hit    =  =    null )     |  |     ( hit    =  =     ( this )  )  )", "return   hit ;", "if    (  (  (  ( y    <  =    height )     &  &     ( y    >  =     ( height    -     ( getPadTop (  )  )  )  )  )     &  &     ( x    >  =     0  )  )     &  &     ( x    <  =     ( getWidth (  )  )  )  )     {", "Actor   currt    =    hit ;", "while    (  ( currt . getPart (  )  )     !  =     ( this )  )", "currt    =    currt . getPart (  )  ;", "if    (  ( getCell ( currt )  )     !  =    null )", "return   this ;", "}", "return   hit ;", "}", "METHOD_END"], "methodName": ["hit"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   dragging ;", "}", "METHOD_END"], "methodName": ["isDragging"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   isModal ;", "}", "METHOD_END"], "methodName": ["isModal"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   isMovable ;", "}", "METHOD_END"], "methodName": ["isMovable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   isResizable ;", "}", "METHOD_END"], "methodName": ["isResizable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( keepWithinStage )  )", "return ;", "Stage   stage    =    getStage (  )  ;", "Camera   camera    =    stage . getCamera (  )  ;", "if    ( camera   instanceof   OrthographicCamera )     {", "OrthographicCamera   orthographicCamera    =     (  ( OrthographicCamera )     ( camera )  )  ;", "float   parentWidth    =    stage . getWidth (  )  ;", "float   parentHeight    =    stage . getHeight (  )  ;", "if    (  (  ( getX ( Align . right )  )     -     ( camera . position . x )  )     >     (  ( parentWidth    /     2  )     /     ( orthographicCamera . zoom )  )  )", "setPosition (  (  ( camera . position . x )     +     (  ( parentWidth    /     2  )     /     ( orthographicCamera . zoom )  )  )  ,    getY ( Align . right )  ,    Align . right )  ;", "if    (  (  ( getX ( Align . left )  )     -     ( camera . position . x )  )     <     (  (  (  - parentWidth )     /     2  )     /     ( orthographicCamera . zoom )  )  )", "setPosition (  (  ( camera . position . x )     -     (  ( parentWidth    /     2  )     /     ( orthographicCamera . zoom )  )  )  ,    getY ( Align . left )  ,    Align . left )  ;", "if    (  (  ( getY ( Align . top )  )     -     ( camera . position . y )  )     >     (  ( parentHeight    /     2  )     /     ( orthographicCamera . zoom )  )  )", "setPosition ( getX ( Align . top )  ,     (  ( camera . position . y )     +     (  ( parentHeight    /     2  )     /     ( orthographicCamera . zoom )  )  )  ,    Align . top )  ;", "if    (  (  ( getY ( Align . bottom )  )     -     ( camera . position . y )  )     <     (  (  (  - parentHeight )     /     2  )     /     ( orthographicCamera . zoom )  )  )", "setPosition ( getX ( Align . bottom )  ,     (  ( camera . position . y )     -     (  ( parentHeight    /     2  )     /     ( orthographicCamera . zoom )  )  )  ,    Align . bottom )  ;", "} else", "if    (  ( getParent (  )  )     =  =     ( stage . getRoot (  )  )  )     {", "float   parentWidth    =    stage . getWidth (  )  ;", "float   parentHeight    =    stage . getHeight (  )  ;", "if    (  ( getX (  )  )     <     0  )", "setX (  0  )  ;", "if    (  ( getRight (  )  )     >    parentWidth )", "setX (  ( parentWidth    -     ( getWidth (  )  )  )  )  ;", "if    (  ( getY (  )  )     <     0  )", "setY (  0  )  ;", "if    (  ( getTop (  )  )     >    parentHeight )", "setY (  ( parentHeight    -     ( getHeight (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["keepWithinStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "this . keepWithinStage    =    keepWithinStage ;", "}", "METHOD_END"], "methodName": ["setKeepWithinStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "this . isModal    =    isModal ;", "}", "METHOD_END"], "methodName": ["setModal"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "this . isMovable    =    isMovable ;", "}", "METHOD_END"], "methodName": ["setMovable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "this . isResizable    =    isResizable ;", "}", "METHOD_END"], "methodName": ["setResizable"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "this . resizeBorder    =    resizeBorder ;", "}", "METHOD_END"], "methodName": ["setResizeBorder"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "if    ( style    =  =    null )", "throw   new   IllegalArgumentException (  \" style   cannot   be   null .  \"  )  ;", "thityle    =    style ;", "setBackground ( style . background )  ;", "titleLabel . setStyle ( new   Label . LabelStyle ( style . titleFont ,    style . titleFontColor )  )  ;", "invalidateHierarchy (  )  ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "com.badlogic.gdx.scenes.scene2d.ui.Window"}, {"methodBody": ["METHOD_START", "{", "return   detector ;", "}", "METHOD_END"], "methodName": ["getGestureDetector"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener"}, {"methodBody": ["METHOD_START", "{", "return   touchDownTarget ;", "}", "METHOD_END"], "methodName": ["getTouchDownTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( e   instanceof   InputEvent )  )", "return   false ;", "InputEvent   event    =     (  ( InputEvent )     ( e )  )  ;", "switch    ( event . getType (  )  )     {", "case   touchDown    :", "actor    =    event . getListenerActor (  )  ;", "touchDownTarget    =    event . getTarget (  )  ;", "detector . touchDown ( event . getStageX (  )  ,    event . getStageY (  )  ,    event . getPointer (  )  ,    event . getButton (  )  )  ;", "actor . stageToLocalCoordinates (  . tmpCoords . set ( event . getStageX (  )  ,    event . getStageY (  )  )  )  ;", "touchDown ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getPointer (  )  ,    event . getButton (  )  )  ;", "return   true ;", "case   touchUp    :", "if    ( event . isTouchFocusCancel (  )  )     {", "detector . reset (  )  ;", "return   false ;", "}", "this . event    =    event ;", "actor    =    event . getListenerActor (  )  ;", "detector . touchUp ( event . getStageX (  )  ,    event . getStageY (  )  ,    event . getPointer (  )  ,    event . getButton (  )  )  ;", "actor . stageToLocalCoordinates (  . tmpCoords . set ( event . getStageX (  )  ,    event . getStageY (  )  )  )  ;", "touchUp ( event ,     . tmpCoords . x ,     . tmpCoords . y ,    event . getPointer (  )  ,    event . getButton (  )  )  ;", "return   true ;", "case   touchDragged    :", "this . event    =    event ;", "actor    =    event . getListenerActor (  )  ;", "detector . touchDragged ( event . getStageX (  )  ,    event . getStageY (  )  ,    event . getPointer (  )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["longPress"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener"}, {"methodBody": ["METHOD_START", "{", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    ( isDisabled )", "return ;", "int   index    =    array . indexOf ( item ,    false )  ;", "if    (  (  (  (  ( selected . size )     >     0  )     &  &     ( range )  )     &  &     ( multiple )  )     &  &     ( UIUtils . shift (  )  )  )     {", "int   oldRangeState    =    rangeStart ;", "snapshot (  )  ;", "int   start    =    rangeStart ;", "int   end    =    index ;", "if    ( start    >    end )     {", "int   temp    =    end ;", "end    =    start ;", "start    =    temp ;", "}", "if    (  !  ( UIUtils . ctrl (  )  )  )", "selected . clear (  )  ;", "for    ( int   i    =    start ;    i    <  =    end ;    i +  +  )", "selected . add ( array . get ( i )  )  ;", "if    ( fireChangeEvent (  )  )     {", "rangeStart    =    oldRangeState ;", "revert (  )  ;", "}", "cleanup (  )  ;", "return ;", "} else", "rangeStart    =    index ;", "super . choose ( item )  ;", "}", "METHOD_END"], "methodName": ["choose"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ArraySelection"}, {"methodBody": ["METHOD_START", "{", "return   rangeSelect ;", "}", "METHOD_END"], "methodName": ["getRangeSelect"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ArraySelection"}, {"methodBody": ["METHOD_START", "{", "this . rangeSelect    =    rangeSelect ;", "}", "METHOD_END"], "methodName": ["setRangeSelect"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ArraySelection"}, {"methodBody": ["METHOD_START", "{", "Array < T >    array    =    this . array ;", "if    (  ( array . size )     =  =     0  )     {", "clear (  )  ;", "return ;", "}", "for    ( Iterator < T >    iter    =    items (  )  . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "T   selected    =    iter . next (  )  ;", "if    (  !  ( array . contains ( selected ,    false )  )  )", "iter . remove (  )  ;", "}", "if    (  ( required )     &  &     (  ( selected . size )     =  =     0  )  )", "set ( array . first (  )  )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ArraySelection"}, {"methodBody": ["METHOD_START", "{", "return   bottomHeight ;", "}", "METHOD_END"], "methodName": ["getBottomHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "return   leftWidth ;", "}", "METHOD_END"], "methodName": ["getLeftWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "return   minHeight ;", "}", "METHOD_END"], "methodName": ["getMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "return   minWidth ;", "}", "METHOD_END"], "methodName": ["getMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "return   rightWidth ;", "}", "METHOD_END"], "methodName": ["getRightWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "return   topHeight ;", "}", "METHOD_END"], "methodName": ["getTopHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "this . bottomHeight    =    bottomHeight ;", "}", "METHOD_END"], "methodName": ["setBottomHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "this . leftWidth    =    leftWidth ;", "}", "METHOD_END"], "methodName": ["setLeftWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "this . minHeight    =    minHeight ;", "}", "METHOD_END"], "methodName": ["setMinHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "this . minWidth    =    minWidth ;", "}", "METHOD_END"], "methodName": ["setMinWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "this . rightWidth    =    rightWidth ;", "}", "METHOD_END"], "methodName": ["setRightWidth"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "this . topHeight    =    topHeight ;", "}", "METHOD_END"], "methodName": ["setTopHeight"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name )     =  =    null )", "return   utils . reflect . ClassReflection . getSimpleName ( getClass (  )  )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( event   instanceof   ChangeListener . ChangeEvent )  )", "return   false ;", "changed (  (  ( ChangeListener . ChangeEvent )     ( event )  )  ,    event . getTarget (  )  )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ChangeListener"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pressedPointer )     =  =     (  -  1  )  )", "return ;", "cancelled    =    true ;", "pressed    =    false ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pointer    =  =     (  -  1  )  )     &  &     (  !  ( cancelled )  )  )", "over    =    true ;", "}", "METHOD_END"], "methodName": ["enter"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pointer    =  =     (  -  1  )  )     &  &     (  !  ( cancelled )  )  )", "over    =    false ;", "}", "METHOD_END"], "methodName": ["exit"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   button ;", "}", "METHOD_END"], "methodName": ["getButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   pressedButton ;", "}", "METHOD_END"], "methodName": ["getPressedButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   pressedPointer ;", "}", "METHOD_END"], "methodName": ["getPressedPointer"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   tapCount ;", "}", "METHOD_END"], "methodName": ["getTapCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   tapSquareSize ;", "}", "METHOD_END"], "methodName": ["getTapSquareSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   touchDownX ;", "}", "METHOD_END"], "methodName": ["getTouchDownX"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   touchDownY ;", "}", "METHOD_END"], "methodName": ["getTouchDownY"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return    ( touchDownX )     !  =     (  -  1  )  ;", "}", "METHOD_END"], "methodName": ["inTapSquare"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( touchDownX )     =  =     (  -  1  )  )     &  &     (  ( touchDownY )     =  =     (  -  1  )  )  )", "return   fae ;", "return    (  ( Math . abs (  ( x    -     ( touchDownX )  )  )  )     <     ( tapSquareSize )  )     &  &     (  ( Math . abs (  ( y    -     ( touchDownY )  )  )  )     <     ( tapSquareSize )  )  ;", "}", "METHOD_END"], "methodName": ["inTapSquare"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "touchDownX    =     -  1  ;", "touchDownY    =     -  1  ;", "}", "METHOD_END"], "methodName": ["invalidateTapSquare"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return    ( over )     |  |     ( pressed )  ;", "}", "METHOD_END"], "methodName": ["isOver"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "Actor   hit    =    actor . hit ( x ,    y ,    true )  ;", "if    (  ( hit    =  =    null )     |  |     (  !  ( hit . isDedantOf ( actor )  )  )  )", "return   inTapSquare ( x ,    y )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isOver"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "return   pressed ;", "}", "METHOD_END"], "methodName": ["isPressed"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "if    ( pressed )", "return   true ;", "if    (  ( visualPressedTime )     <  =     0  )", "return   false ;", "if    (  ( visualPressedTime )     >     ( TimeUmillis (  )  )  )", "return   true ;", "visualPressedTime    =     0  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["isVisualPressed"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "this . button    =    button ;", "}", "METHOD_END"], "methodName": ["setButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "this . tapCount    =    tapCount ;", "}", "METHOD_END"], "methodName": ["setTapCount"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "this . tapCountInterval    =     (  ( long )     ( tapCountInterval    *     1  0  0  0  0  0  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["setTapCountInterval"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "tapSquareSize    =    halfTapSquareSize ;", "}", "METHOD_END"], "methodName": ["setTapSquareSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "if    ( pressed )", "return   false ;", "if    (  (  ( pointer    =  =     0  )     &  &     (  ( this . button )     !  =     (  -  1  )  )  )     &  &     ( button    !  =     ( this . button )  )  )", "return   false ;", "pressed    =    true ;", "pressedPointer    =    pointer ;", "pressedButton    =    button ;", "touchDownX    =    x ;", "touchDownY    =    y ;", "visualPressedTime    =     ( TimeUtils . millis (  )  )     +     (  ( long )     (  (  . visualPressedDuration )     *     1  0  0  0  )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pointer    !  =     ( pressedPointer )  )     |  |     ( cancelled )  )", "return ;", "pressed    =    isOver ( event . getActor (  )  ,    x ,    y )  ;", "if    (  !  ( pressed )  )     {", "invalidateTapSquare (  )  ;", "}", "}", "METHOD_END"], "methodName": ["touchDragged"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    =  =     ( pressedPointer )  )     {", "if    (  !  ( cancelled )  )     {", "boolean   touchUpOver    =    isOver ( event . getActor (  )  ,    x ,    y )  ;", "if    (  (  ( touchUpOver    &  &     ( pointer    =  =     0  )  )     &  &     (  ( this . button )     !  =     (  -  1  )  )  )     &  &     ( button    !  =     ( this . button )  )  )", "touchUpOver    =    false ;", "if    ( touchUpOver )     {", "long   time    =    TimeUtils . nanoTime (  )  ;", "if    (  ( time    -     ( lastTapTime )  )     >     ( tapCountInterval )  )", "tapCount    =     0  ;", "( tapCount )  +  +  ;", "lastTapTime    =    time ;", "clicked ( event ,    x ,    y )  ;", "}", "}", "pressed    =    false ;", "pressedPointer    =     -  1  ;", "pressedButton    =     -  1  ;", "cancelled    =    false ;", "}", "}", "METHOD_END"], "methodName": ["touchUp"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ClickListener"}, {"methodBody": ["METHOD_START", "{", "DragListener   listener    =    new   DragListener (  )     {", "public   void   dragStart ( InputEvent   event ,    float   x ,    float   y ,    int   pointer )     {", "if    (  ( activePointer )     !  =     (  -  1  )  )     {", "event . stop (  )  ;", "return ;", "}", "activePointer    =    pointer ;", "dragStartTime    =    System . currentTimeMillis (  )  ;", "payload    =    source . dragStart ( event ,    getTouchDownX (  )  ,    getTouchDownY (  )  ,    pointer )  ;", "event . stop (  )  ;", "if    (  ( cancelTouchFocus )     &  &     (  ( payload )     !  =    null )  )", "source . getActor (  )  . getStage (  )  . cancelTouchFocusExcept ( this ,    source . getActor (  )  )  ;", "}", "public   void   drag ( InputEvent   event ,    float   x ,    float   y ,    int   pointer )     {", "if    (  ( payload )     =  =    null )", "return ;", "if    ( pointer    !  =     ( activePointer )  )", "return ;", "Stage   stage    =    event . getStage (  )  ;", "Touchable   dragActorTouchable    =    null ;", "if    (  ( dragActor )     !  =    null )     {", "dragActorTouchable    =    dragActor . getTouchable (  )  ;", "dragActor . setTouchable ( Touchable . disabled )  ;", "}", ". Target   newTarget    =    null ;", "isValidTarget    =    false ;", "float   stageX    =     ( event . getStageX (  )  )     +     ( touchOffsetX )  ;", "float   stageY    =     ( event . getStageY (  )  )     +     ( touchOffsetY )  ;", "Actor   hit    =    event . getStage (  )  . hit ( stageX ,    stageY ,    true )  ;", "if    ( hit    =  =    null )", "hit    =    event . getStage (  )  . hit ( stageX ,    stageY ,    false )  ;", "if    ( hit    !  =    null )     {", "for    ( int   i    =     0  ,    n    =    targets . size ;    i    <    n ;    i +  +  )     {", ". Target   target    =    targets . get ( i )  ;", "if    (  !  ( target . actor . isAscendantOf ( hit )  )  )", "continue ;", "newTarget    =    target ;", "target . actor . stageToLocalCoordinates (  . tmpVector . set ( stageX ,    stageY )  )  ;", "break ;", "}", "}", "if    ( newTarget    !  =     ( target )  )     {", "if    (  ( target )     !  =    null )", "target . reset ( source ,    payload )  ;", "target    =    newTarget ;", "}", "if    ( newTarget    !  =    null )", "isValidTarget    =    newTarget . drag ( source ,    payload ,     . tmpVector . x ,     . tmpVector . y ,    pointer )  ;", "if    (  ( dragActor )     !  =    null )", "dragActor . setTouchable ( dragActorTouchable )  ;", "Actor   actor    =    null ;", "if    (  ( target )     !  =    null )", "actor    =     ( isValidTarget )     ?    payload . validDragActor    :    payload . invalidDragActor ;", "if    ( actor    =  =    null )", "actor    =    payload . dragActor ;", "if    ( actor    =  =    null )", "return ;", "if    (  ( dragActor )     !  =    actor )     {", "if    (  ( dragActor )     !  =    null )", "dragActor . remove (  )  ;", "dragActor    =    actor ;", "stage . addActor ( actor )  ;", "}", "float   actorX    =     (  ( event . getStageX (  )  )     -     ( actor . getWidth (  )  )  )     +     ( dragActorX )  ;", "float   actorY    =     ( event . getStageY (  )  )     +     ( dragActorY )  ;", "if    ( keepWithinStage )     {", "if    ( actorX    <     0  )", "actorX    =     0  ;", "if    ( actorY    <     0  )", "actorY    =     0  ;", "if    (  ( actorX    +     ( actor . getWidth (  )  )  )     >     ( stage . getWidth (  )  )  )", "actorX    =     ( stage . getWidth (  )  )     -     ( actor . getWidth (  )  )  ;", "if    (  ( actorY    +     ( actor . getHeight (  )  )  )     >     ( stage . getHeight (  )  )  )", "actorY    =     ( stage . getHeight (  )  )     -     ( actor . getHeight (  )  )  ;", "}", "actor . setPosition ( actorX ,    actorY )  ;", "}", "public   void   dragStop ( InputEvent   event ,    float   x ,    float   y ,    int   pointer )     {", "if    ( pointer    !  =     ( activePointer )  )", "return ;", "activePointer    =     -  1  ;", "if    (  ( payload )     =  =    null )", "return ;", "if    (  (  ( System . currentTimeMillis (  )  )     -     ( dragStartTime )  )     <     ( dragTime )  )", "isValidTarget    =    false ;", "if    (  ( dragActor )     !  =    null )", "dragActor . remove (  )  ;", "if    ( isValidTarget )     {", "float   stageX    =     ( event . getStageX (  )  )     +     ( touchOffsetX )  ;", "float   stageY    =     ( event . getStageY (  )  )     +     ( touchOffsetY )  ;", "target . actor . stageToLocalCoordinates (  . tmpVector . set ( stageX ,    stageY )  )  ;", "target . drop ( source ,    payload ,     . tmpVector . x ,     . tmpVector . y ,    pointer )  ;", "}", "source . dragStop ( event ,    x ,    y ,    pointer ,    payload ,     ( isValidTarget    ?    target    :    null )  )  ;", "if    (  ( target )     !  =    null )", "target . reset ( source ,    payload )  ;", "payload    =    null ;", "target    =    null ;", "isValidTarget    =    false ;", "dragActor    =    null ;", "}", "}  ;", "listener . setTapSquareSize ( tapSquareSize )  ;", "listener . setButton ( button )  ;", "source . actor . addCaptureListener ( listener )  ;", "sourceListeners . put ( source ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addSource"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "targets . add ( target )  ;", "}", "METHOD_END"], "methodName": ["addTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "targets . clear (  )  ;", "for    ( ObjectMap . Entry <  . Source ,    DragListener >    entry    :    sourceListeners . entries (  )  )", "entry . key . actor . removeCaptureListener ( entry . value )  ;", "sourceListeners . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "return   dragActor ;", "}", "METHOD_END"], "methodName": ["getDragActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "return   payload ;", "}", "METHOD_END"], "methodName": ["getDragPayload"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "return    ( payload )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isDragging"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "DragListener   dragListener    =    sourceListeners . remove ( source )  ;", "source . actor . removeCaptureListener ( dragListener )  ;", "}", "METHOD_END"], "methodName": ["removeSource"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "targets . removeValue ( target ,    true )  ;", "}", "METHOD_END"], "methodName": ["removeTarget"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "this . button    =    button ;", "}", "METHOD_END"], "methodName": ["setButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "this . cancelTouchFocus    =    cancelTouchFocus ;", "}", "METHOD_END"], "methodName": ["setCancelTouchFocus"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "this . dragActorX    =    dragActorX ;", "this . dragActorY    =    dragActorY ;", "}", "METHOD_END"], "methodName": ["setDragActorPosition"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "this . dragTime    =    dragMillis ;", "}", "METHOD_END"], "methodName": ["setDragTime"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "this . keepWithinStage    =    keepWithinStage ;", "}", "METHOD_END"], "methodName": ["setKeepWithinStage"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "tapSquareSize    =    halfTapSquareSize ;", "}", "METHOD_END"], "methodName": ["setTapSquareSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "this . touchOffsetX    =    touchOffsetX ;", "this . touchOffsetY    =    touchOffsetY ;", "}", "METHOD_END"], "methodName": ["setTouchOffset"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragAndDrop"}, {"methodBody": ["METHOD_START", "{", "dragging    =    false ;", "pressedPointer    =     -  1  ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   button ;", "}", "METHOD_END"], "methodName": ["getButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return    ( dragX )     -     ( dragLastX )  ;", "}", "METHOD_END"], "methodName": ["getDeltaX"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return    ( dragY )     -     ( dragLastY )  ;", "}", "METHOD_END"], "methodName": ["getDeltaY"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   Vector 2  . len (  (  ( dragX )     -     ( dragStartX )  )  ,     (  ( dragY )     -     ( dragStartY )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDragDistance"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   dragStartX ;", "}", "METHOD_END"], "methodName": ["getDragStartX"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   dragStartY ;", "}", "METHOD_END"], "methodName": ["getDragStartY"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   dragX ;", "}", "METHOD_END"], "methodName": ["getDragX"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   dragY ;", "}", "METHOD_END"], "methodName": ["getDragY"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   stageTouchDownX ;", "}", "METHOD_END"], "methodName": ["getStageTouchDownX"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   stageTouchDownY ;", "}", "METHOD_END"], "methodName": ["getStageTouchDownY"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   tapSquareSize ;", "}", "METHOD_END"], "methodName": ["getTapSquareSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   touchDownX ;", "}", "METHOD_END"], "methodName": ["getTouchDownX"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   touchDownY ;", "}", "METHOD_END"], "methodName": ["getTouchDownY"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "return   dragging ;", "}", "METHOD_END"], "methodName": ["isDragging"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "this . button    =    button ;", "}", "METHOD_END"], "methodName": ["setButton"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "this . dragStartX    =    dragStartX ;", "}", "METHOD_END"], "methodName": ["setDragStartX"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "this . dragStartY    =    dragStartY ;", "}", "METHOD_END"], "methodName": ["setDragStartY"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "tapSquareSize    =    halfTapSquareSize ;", "}", "METHOD_END"], "methodName": ["setTapSquareSize"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pressedPointer )     !  =     (  -  1  )  )", "return   false ;", "if    (  (  ( pointer    =  =     0  )     &  &     (  ( this . button )     !  =     (  -  1  )  )  )     &  &     ( button    !  =     ( this . button )  )  )", "return   false ;", "pressedPointer    =    pointer ;", "touchDownX    =    x ;", "touchDownY    =    y ;", "stageTouchDownX    =    event . getStageX (  )  ;", "stageTouchDownY    =    event . getStageY (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["touchDown"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    !  =     ( pressedPointer )  )", "return ;", "if    (  (  !  ( dragging )  )     &  &     (  (  ( Math . abs (  (  ( touchDownX )     -    x )  )  )     >     ( tapSquareSize )  )     |  |     (  ( Math . abs (  (  ( touchDownY )     -    y )  )  )     >     ( tapSquareSize )  )  )  )     {", "dragging    =    true ;", "dragStartX    =    x ;", "dragStartY    =    y ;", "dragStart ( event ,    x ,    y ,    pointer )  ;", "dragX    =    x ;", "dragY    =    y ;", "}", "if    ( dragging )     {", "dastX    =    dragX ;", "dastY    =    dragY ;", "dragX    =    x ;", "dragY    =    y ;", "drag ( event ,    x ,    y ,    pointer )  ;", "}", "}", "METHOD_END"], "methodName": ["touchDragged"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    =  =     ( pressedPointer )  )     {", "if    ( dging )", "dStop ( event ,    x ,    y ,    pointer )  ;", "cancel (  )  ;", "}", "}", "METHOD_END"], "methodName": ["touchUp"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragListener"}, {"methodBody": ["METHOD_START", "{", "event . getListenerActor (  )  . localToActorCoordinates ( scroll ,    DragScrollListener . tmpCoords . set ( x ,    y )  )  ;", "if    (  (  ( DragScrollListener . tmpCoords . x )     >  =     0  )     &  &     (  ( DragScrollListener . tmpCoords . x )     <     ( scroll . getWidth (  )  )  )  )     {", "if    (  ( DragScrollListener . tmpCoords . y )     >  =     ( scroll . getHeight (  )  )  )     {", "scrollDown . cancel (  )  ;", "if    (  !  ( scrollUp . isScheduled (  )  )  )     {", "startTime    =    System . currentTimeMillis (  )  ;", "Timer . schedule ( scrollUp ,    tickSecs ,    tickSecs )  ;", "}", "return ;", "} else", "if    (  ( DragScrollListener . tmpCoords . y )     <     0  )     {", "scrollUp . cancel (  )  ;", "if    (  !  ( scrollDown . isScheduled (  )  )  )     {", "startTime    =    System . currentTimeMillis (  )  ;", "Timer . schedule ( scrollDown ,    tickSecs ,    tickSecs )  ;", "}", "return ;", "}", "}", "scrollUp . cancel (  )  ;", "scrollDown . cancel (  )  ;", "}", "METHOD_END"], "methodName": ["drag"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener"}, {"methodBody": ["METHOD_START", "{", "scrollUp . cancel (  )  ;", "scrollDown . cancel (  )  ;", "}", "METHOD_END"], "methodName": ["dragStop"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener"}, {"methodBody": ["METHOD_START", "{", "return   interpolation . apply ( minSpeed ,    maxSpeed ,    Math . min (  1  ,     (  (  ( System . currentTimeMillis (  )  )     -     ( startTime )  )     /     (  ( float )     ( rampTime )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScrollPixels"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener"}, {"methodBody": ["METHOD_START", "{", "scroll . setScrollY ( y )  ;", "}", "METHOD_END"], "methodName": ["scroll"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener"}, {"methodBody": ["METHOD_START", "{", "this . minSpeed    =    minSpeedPixels ;", "this . maxSpeed    =    maxSpeedPixels ;", "this . tickSecs    =    tickSecs ;", "rampTime    =     (  ( long )     ( rampSecs    *     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.DragScrollListener"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( event   instanceof   FocusListener . FocusEvent )  )", "return   false ;", "FocusListener . FocusEvent   focusEvent    =     (  ( FocusListener . FocusEvent )     ( event )  )  ;", "switch    ( focusEvent . getType (  )  )     {", "case   keyboard    :", "keyboardFocusChanged ( focusEvent ,    event . getTarget (  )  ,    focusEvent . isFocused (  )  )  ;", "break ;", "case   scroll    :", "scrollFocusChanged ( focusEvent ,    event . getTarget (  )  ,    focusEvent . isFocused (  )  )  ;", "break ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.FocusListener"}, {"methodBody": ["METHOD_START", "{", "patch . draw ( batch ,    x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable"}, {"methodBody": ["METHOD_START", "{", "patch . draw ( batch ,    x ,    y ,    originX ,    originY ,    width ,    height ,    scaleX ,    scaleY ,    rotation )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable"}, {"methodBody": ["METHOD_START", "{", "return   patch ;", "}", "METHOD_END"], "methodName": ["getPatch"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable"}, {"methodBody": ["METHOD_START", "{", "this . patch    =    patch ;", "setMinWidth ( patch . getTotalWidth (  )  )  ;", "setMinHeight ( patch . getTotalHeight (  )  )  ;", "setTopHeight ( patch . getPadTop (  )  )  ;", "setRightWidth ( patch . getPadRight (  )  )  ;", "setBottomHeight ( patch . getPadBottom (  )  )  ;", "setLeftWidth ( patch . getPadLeft (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPatch"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable"}, {"methodBody": ["METHOD_START", "{", "NinePatchDrawable   drawable    =    new   NinePatchDrawable ( this )  ;", "drawable . setPatch ( new   NinePatch ( drawable . getPatch (  )  ,    tint )  )  ;", "return   drawable ;", "}", "METHOD_END"], "methodName": ["tint"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable"}, {"methodBody": ["METHOD_START", "{", "ScissorStack . calculateScissors ( camera ,     0  ,     0  ,    Gdx . graphics . getWidth (  )  ,    Gdx . graphics . getHeight (  )  ,    batchTransform ,    area ,    scissor )  ;", "}", "METHOD_END"], "methodName": ["calculateScissors"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ScissorStack"}, {"methodBody": ["METHOD_START", "{", "ScissorStack . tmp . set ( area . x ,    area . y ,     0  )  ;", "ScissorStack . tmp . mul ( batchTransform )  ;", "camera . project ( ScissorStack . tmp ,    viewportX ,    viewportY ,    viewportWidth ,    viewportHeight )  ;", "scissor . x    =    ScissorStack . tmp . x ;", "scissor . y    =    ScissorStack . tmp . y ;", "ScissorStack . tmp . set (  (  ( area . x )     +     ( area . width )  )  ,     (  ( area . y )     +     ( area . height )  )  ,     0  )  ;", "ScissorStack . tmp . mul ( batchTransform )  ;", "camera . project ( ScissorStack . tmp ,    viewportX ,    viewportY ,    viewportWidth ,    viewportHeight )  ;", "scissor . width    =     ( ScissorStack . tmp . x )     -     ( scissor . x )  ;", "scissor . height    =     ( ScissorStack . tmp . y )     -     ( scissor . y )  ;", "}", "METHOD_END"], "methodName": ["calculateScissors"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ScissorStack"}, {"methodBody": ["METHOD_START", "{", "rect . x    =    Math . round ( rect . x )  ;", "rect . y    =    Math . round ( rect . y )  ;", "rect . width    =    Math . round ( rect . width )  ;", "rect . height    =    Math . round ( rect . height )  ;", "if    (  ( rect . width )     <     0  )     {", "rect . width    =     -  ( rect . width )  ;", "rect . x    -  =    rect . width ;", "}", "if    (  ( rect . height )     <     0  )     {", "rect . height    =     -  ( rect . height )  ;", "rect . y    -  =    rect . height ;", "}", "}", "METHOD_END"], "methodName": ["fix"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ScissorStack"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ScissorStack . scissors . size )     =  =     0  )     {", "ScissorStack . viewport . set (  0  ,     0  ,    Gdx . graphics . getWidth (  )  ,    Gdx . graphics . getHeight (  )  )  ;", "return   ScissorStack . viewport ;", "} else    {", "Rectangle   scissor    =    ScissorStack . scissors . peek (  )  ;", "ScissorStack . viewport . set ( scissor )  ;", "return   ScissorStack . viewport ;", "}", "}", "METHOD_END"], "methodName": ["getViewport"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ScissorStack"}, {"methodBody": ["METHOD_START", "{", "return   ScissorStack . scissors . peek (  )  ;", "}", "METHOD_END"], "methodName": ["peekScissors"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ScissorStack"}, {"methodBody": ["METHOD_START", "{", "Rectangle   old    =    ScissorStack . scissors . pop (  )  ;", "if    (  ( ScissorStack . scissors . size )     =  =     0  )", "Gdx . gl . glDisable ( graphics . GL 2  0  . GL _ SCISSOR _ TEST )  ;", "else    {", "Rectangle   scissor    =    ScissorStack . scissors . peek (  )  ;", "HdpiUtils . glScissor (  (  ( int )     ( scissor . x )  )  ,     (  ( int )     ( scissor . y )  )  ,     (  ( int )     ( scissor . width )  )  ,     (  ( int )     ( scissor . height )  )  )  ;", "}", "return   old ;", "}", "METHOD_END"], "methodName": ["popScissors"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ScissorStack"}, {"methodBody": ["METHOD_START", "{", "ScissorStack . fix ( scissor )  ;", "if    (  ( ScissorStack . scissors . size )     =  =     0  )     {", "if    (  (  ( scissor . width )     <     1  )     |  |     (  ( scissor . height )     <     1  )  )", "return   false ;", "Gdx . gl . glEnable ( GL 2  0  . GL _ SCISSOR _ TEST )  ;", "} else    {", "Rectangle   parent    =    ScissorStack . scissors . get (  (  ( ScissorStack . scissors . size )     -     1  )  )  ;", "float   minX    =    Math . max ( parent . x ,    scissor . x )  ;", "float   maxX    =    Math . min (  (  ( parent . x )     +     ( parent . width )  )  ,     (  ( scissor . x )     +     ( scissor . width )  )  )  ;", "if    (  ( maxX    -    minX )     <     1  )", "return   false ;", "float   minY    =    Math . max ( parent . y ,    scissor . y )  ;", "float   maxY    =    Math . min (  (  ( parent . y )     +     ( parent . height )  )  ,     (  ( scissor . y )     +     ( scissor . height )  )  )  ;", "if    (  ( maxY    -    minY )     <     1  )", "return   false ;", "scissor . x    =    minX ;", "scissor . y    =    minY ;", "scissor . width    =    maxX    -    minX ;", "scissor . height    =    Math . max (  1  ,     ( maxY    -    minY )  )  ;", "}", "ScissorStack . scissors . add ( scissor )  ;", "HdpiUtils . glScissor (  (  ( int )     ( scissor . x )  )  ,     (  ( int )     ( scissor . y )  )  ,     (  ( int )     ( scissor . width )  )  ,     (  ( int )     ( scissor . height )  )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["pushScissors"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.ScissorStack"}, {"methodBody": ["METHOD_START", "{", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    (  !  ( selected . add ( item )  )  )", "return ;", "if    (  ( programmaticChangeEvents )     &  &     ( fireChangeEvent (  )  )  )", "selected . remove ( item )  ;", "else    {", "lasted    =    item ;", "changed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "boolean   added    =    false ;", "snapshot (  )  ;", "for    ( int   i    =     0  ,    n    =    items . size ;    i    <    n ;    i +  +  )     {", "T   item    =    items . get ( i )  ;", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    ( selected . add ( item )  )", "added    =    true ;", "}", "if    ( added )     {", "if    (  ( programmaticChangeEvents )     &  &     ( fireChangeEvent (  )  )  )", "revert (  )  ;", "else    {", "lasted    =    items . peek (  )  ;", "changed (  )  ;", "}", "}", "cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    ( isDisabled )", "return ;", "snapshot (  )  ;", "try    {", "if    (  (  (  ( toggle )     |  |     (  (  !  ( required )  )     &  &     (  ( selected . size )     =  =     1  )  )  )     |  |     ( UIUtils . ctrl (  )  )  )     &  &     ( selected . contains ( item )  )  )     {", "if    (  ( required )     &  &     (  ( selected . size )     =  =     1  )  )", "return ;", "selected . remove ( item )  ;", "lasted    =    null ;", "} else    {", "boolean   modified    =    false ;", "if    (  (  !  ( multiple )  )     |  |     (  (  !  ( toggle )  )     &  &     (  !  ( UIUtils . ctrl (  )  )  )  )  )     {", "if    (  (  ( selected . size )     =  =     1  )     &  &     ( selected . contains ( item )  )  )", "return ;", "modified    =     ( selected . size )     >     0  ;", "selected . clear (  )  ;", "}", "if    (  (  !  ( selected . add ( item )  )  )     &  &     (  ! modified )  )", "return ;", "lasted    =    item ;", "}", "if    ( fireChangeEvent (  )  )", "revert (  )  ;", "else", "changed (  )  ;", "}    finally    {", "cleanup (  )  ;", "}", "}", "METHOD_END"], "methodName": ["choose"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "old . clear (  3  2  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( selected . size )     =  =     0  )", "return ;", "snapshot (  )  ;", "selected . clear (  )  ;", "if    (  ( programmaticChangeEvents )     &  &     ( fireChangeEvent (  )  )  )", "revert (  )  ;", "else    {", "lasted    =    null ;", "changed (  )  ;", "}", "cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "if    ( item    =  =    null )", "return   false ;", "return   sed . contains ( item )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actor )     =  =    null )", "return   false ;", "ChangeListr . ChangeEvent   changeEvent    =    Pools . obtain ( ChangeListr . ChangeEvent . class )  ;", "try    {", "return   actor . fire ( changeEvent )  ;", "}    finally    {", "Pools . free ( changeEvent )  ;", "}", "}", "METHOD_END"], "methodName": ["fireChangeEvent"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return    ( selected . size )     =  =     0     ?    null    :    selected . first (  )  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( lastSelected )     !  =    null )     {", "return   lastSelected ;", "} else", "if    (  ( selected . size )     >     0  )     {", "return   selected . first (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getLastSelected"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   multiple ;", "}", "METHOD_END"], "methodName": ["getMultiple"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   required ;", "}", "METHOD_END"], "methodName": ["getRequired"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   toggle ;", "}", "METHOD_END"], "methodName": ["getToggle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return    ( selected . size )     >     0  ;", "}", "METHOD_END"], "methodName": ["hasItems"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   isDisabled ;", "}", "METHOD_END"], "methodName": ["isDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return    ( selected . size )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   selected ;", "}", "METHOD_END"], "methodName": ["items"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   selected . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    (  !  ( selected . remove ( item )  )  )", "return ;", "if    (  ( programmaticChangeEvents )     &  &     ( fireChangeEvent (  )  )  )", "selected . add ( item )  ;", "else    {", "lasted    =    null ;", "changed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "boolean   removed    =    false ;", "snapshot (  )  ;", "for    ( int   i    =     0  ,    n    =    items . size ;    i    <    n ;    i +  +  )     {", "T   item    =    items . get ( i )  ;", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    ( selected . remove ( item )  )", "removed    =    true ;", "}", "if    ( removed )     {", "if    (  ( programmaticChangeEvents )     &  &     ( fireChangeEvent (  )  )  )", "revert (  )  ;", "else    {", "lasted    =    null ;", "changed (  )  ;", "}", "}", "cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "selected . clear (  )  ;", "selected . addAll ( old )  ;", "}", "METHOD_END"], "methodName": ["revert"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    (  (  ( selected . size )     =  =     1  )     &  &     (  ( selected . first (  )  )     =  =    item )  )", "return ;", "snapshot (  )  ;", "selected . clear (  )  ;", "selected . add ( item )  ;", "if    (  ( programmaticChangeEvents )     &  &     ( fireChangeEvent (  )  )  )", "revert (  )  ;", "else    {", "lasted    =    item ;", "changed (  )  ;", "}", "cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "this . actor    =    actor ;", "}", "METHOD_END"], "methodName": ["setActor"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "boolean   added    =    false ;", "snapshot (  )  ;", "lasted    =    null ;", "selected . clear (  )  ;", "for    ( int   i    =     0  ,    n    =    items . size ;    i    <    n ;    i +  +  )     {", "T   item    =    items . get ( i )  ;", "if    ( item    =  =    null )", "throw   new   IllegalArgumentException (  \" item   cannot   be   null .  \"  )  ;", "if    ( selected . add ( item )  )", "added    =    true ;", "}", "if    ( added )     {", "if    (  ( programmaticChangeEvents )     &  &     ( fireChangeEvent (  )  )  )", "revert (  )  ;", "else", "if    (  ( items . size )     >     0  )     {", "lasted    =    items . peek (  )  ;", "changed (  )  ;", "}", "}", "cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["setAll"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "this . isDisabled    =    isDisabled ;", "}", "METHOD_END"], "methodName": ["setDisabled"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "this . multiple    =    multiple ;", "}", "METHOD_END"], "methodName": ["setMultiple"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "this . programmaticChangeEvents    =    programmaticChangeEvents ;", "}", "METHOD_END"], "methodName": ["setProgrammaticChangeEvents"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "this . required    =    required ;", "}", "METHOD_END"], "methodName": ["setRequired"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "this . toggle    =    toggle ;", "}", "METHOD_END"], "methodName": ["setToggle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   selected . size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "old . clear (  )  ;", "old . addAll ( sed )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   selected . iterator (  )  . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   selected . iterator (  )  . toArray ( array )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "return   selected . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.Selection"}, {"methodBody": ["METHOD_START", "{", "Color   spriteColor    =    sprite . getColor (  )  ;", "float   batchColor    =    batch . getPackedColor (  )  ;", "sprite . setColor ( batch . getColor (  )  . mul ( spriteColor )  )  ;", "sprite . setRotation (  0  )  ;", "sprite . setScale (  1  ,     1  )  ;", "sprite . setBounds ( x ,    y ,    width ,    height )  ;", "sprite . draw ( batch )  ;", "sprite . setColor ( spriteColor )  ;", "batch . setColor ( batchColor )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable"}, {"methodBody": ["METHOD_START", "{", "Color   spriteColor    =    sprite . getColor (  )  ;", "float   batchColor    =    batch . getPackedColor (  )  ;", "sprite . setColor ( batch . getColor (  )  . mul ( spriteColor )  )  ;", "sprite . setOrigin ( originX ,    originY )  ;", "sprite . setRotation ( rotation )  ;", "sprite . setScale ( scaleX ,    scaleY )  ;", "sprite . setBounds ( x ,    y ,    width ,    height )  ;", "sprite . draw ( batch )  ;", "sprite . setColor ( spriteColor )  ;", "batch . setColor ( batchColor )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable"}, {"methodBody": ["METHOD_START", "{", "return   sprite ;", "}", "METHOD_END"], "methodName": ["getSprite"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable"}, {"methodBody": ["METHOD_START", "{", "this . sprite    =    sprite ;", "setMinWidth ( sprite . getWidth (  )  )  ;", "setMinHeight ( sprite . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["setSprite"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable"}, {"methodBody": ["METHOD_START", "{", "Sprite   newSprite ;", "if    (  ( sprite )    instanceof   TextureAtlas . AtlasSprite )", "newSprite    =    new   TextureAtlas . AtlasSprite (  (  ( TextureAtlas . AtlasSprite )     ( sprite )  )  )  ;", "else", "newSprite    =    new   Sprite ( sprite )  ;", "newSprite . setColor ( tint )  ;", "newSprite . setSize ( getMinWidth (  )  ,    getMinHeight (  )  )  ;", "drawable    =    new    ( newSprite )  ;", "drawable . setLeftWidth ( getLeftWidth (  )  )  ;", "drawable . setRightWidth ( getRightWidth (  )  )  ;", "drawable . setTopHeight ( getTopHeight (  )  )  ;", "drawable . setBottomHeight ( getBottomHeight (  )  )  ;", "return   drawable ;", "}", "METHOD_END"], "methodName": ["tint"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable"}, {"methodBody": ["METHOD_START", "{", "batch . draw ( region ,    x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable"}, {"methodBody": ["METHOD_START", "{", "batch . draw ( region ,    x ,    y ,    originX ,    originY ,    width ,    height ,    scaleX ,    scaleY ,    rotation )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable"}, {"methodBody": ["METHOD_START", "{", "return   region ;", "}", "METHOD_END"], "methodName": ["getRegion"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable"}, {"methodBody": ["METHOD_START", "{", "this . region    =    region ;", "if    ( region    !  =    null )     {", "setMinWidth ( region . getWidth (  )  )  ;", "setMinHeight ( region . getHeight (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRegion"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable"}, {"methodBody": ["METHOD_START", "{", "Sprite   sprite ;", "if    (  ( region )    instanceof   TextureAtlas . AtlasRegion )", "sprite    =    new   TextureAtlas . AtlasSprite (  (  ( TextureAtlas . AtlasRegion )     ( region )  )  )  ;", "else", "sprite    =    new   Sprite ( region )  ;", "sprite . setColor ( tint )  ;", "sprite . setSize ( getMinWidth (  )  ,    getMinHeight (  )  )  ;", "Sprite   drawable    =    new   Sprite ( sprite )  ;", "drawable . setLeftWidth ( getLeftWidth (  )  )  ;", "drawable . setRightWidth ( getRightWidth (  )  )  ;", "drawable . setTopHeight ( getTopHeight (  )  )  ;", "drawable . setBottomHeight ( getBottomHeight (  )  )  ;", "return   drawable ;", "}", "METHOD_END"], "methodName": ["tint"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable"}, {"methodBody": ["METHOD_START", "{", "float   batchColor    =    batch . getPackedColor (  )  ;", "batch . setColor ( batch . getColor (  )  . mul ( color )  )  ;", "TextureRegion   region    =    getRegion (  )  ;", "float   regionWidth    =    region . getRegionWidth (  )  ;", "float   regionHeight    =    region . getRegionHeight (  )  ;", "int   fullX    =     (  ( int )     ( width    /    regionWidth )  )  ;", "int   fullY    =     (  ( int )     ( height    /    regionHeight )  )  ;", "float   remainingX    =    width    -     ( regionWidth    *    fullX )  ;", "float   remainingY    =    height    -     ( regionHeight    *    fullY )  ;", "float   startX    =    x ;", "float   startY    =    y ;", "float   endX    =     ( x    +    width )     -    remainingX ;", "float   endY    =     ( y    +    height )     -    remainingY ;", "for    ( int   i    =     0  ;    i    <    fullX ;    i +  +  )     {", "y    =    startY ;", "for    ( int   ii    =     0  ;    ii    <    fullY ;    ii +  +  )     {", "batch . d ( region ,    x ,    y ,    regionWidth ,    regionHeight )  ;", "y    +  =    regionHeight ;", "}", "x    +  =    regionWidth ;", "}", "Texture   texture    =    region . getTexture (  )  ;", "float   u    =    region . getU (  )  ;", "float   v 2     =    region . getV 2  (  )  ;", "if    ( remainingX    >     0  )     {", "float   u 2     =    u    +     ( remainingX    /     ( texture . getWidth (  )  )  )  ;", "float   v    =    region . getV (  )  ;", "y    =    startY ;", "for    ( int   ii    =     0  ;    ii    <    fullY ;    ii +  +  )     {", "batch . d ( texture ,    x ,    y ,    remainingX ,    regionHeight ,    u ,    v 2  ,    u 2  ,    v )  ;", "y    +  =    regionHeight ;", "}", "if    ( remainingY    >     0  )     {", "v    =    v 2     -     ( remainingY    /     ( texture . getHeight (  )  )  )  ;", "batch . d ( texture ,    x ,    y ,    remainingX ,    remainingY ,    u ,    v 2  ,    u 2  ,    v )  ;", "}", "}", "if    ( remainingY    >     0  )     {", "float   u 2     =    region . getU 2  (  )  ;", "float   v    =    v 2     -     ( remainingY    /     ( texture . getHeight (  )  )  )  ;", "x    =    startX ;", "for    ( int   i    =     0  ;    i    <    fullX ;    i +  +  )     {", "batch . d ( texture ,    x ,    y ,    regionWidth ,    remainingY ,    u ,    v 2  ,    u 2  ,    v )  ;", "x    +  =    regionWidth ;", "}", "}", "batch . setColor ( batchColor )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["draw"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable"}, {"methodBody": ["METHOD_START", "{", "TiledDrawable   drawable    =    new   TiledDrawable ( this )  ;", "drawable . color . set ( tint )  ;", "drawable . setLeftWidth ( getLeftWidth (  )  )  ;", "drawable . setRightWidth ( getRightWidth (  )  )  ;", "drawable . setTopHeight ( getTopHeight (  )  )  ;", "drawable . setBottomHeight ( getBottomHeight (  )  )  ;", "return   drawable ;", "}", "METHOD_END"], "methodName": ["tint"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable"}, {"methodBody": ["METHOD_START", "{", "return    ( Gdx . input . isKeyPressed ( Input . Keys . ALT _ LEFT )  )     |  |     ( Gdx . input . isKeyPressed ( Input . Keys . ALT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["alt"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( keycode    =  =     ( Input . Keys . ALT _ LEFT )  )     |  |     ( keycode    =  =     ( Input . Keys . ALT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["alt"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( UIUtils . isMac )", "return   Gdx . input . isKeyPressed ( Input . Keys . SYM )  ;", "else", "return    ( Gdx . input . isKeyPressed ( Input . Keys . CONTROL _ LEFT )  )     |  |     ( Gdx . input . isKeyPressed ( Input . Keys . CONTROL _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["ctrl"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( UIUtils . isMac )", "return   keycode    =  =     ( Input . Keys . SYM )  ;", "else", "return    ( keycode    =  =     ( Input . Keys . CONTROL _ LEFT )  )     |  |     ( keycode    =  =     ( Input . Keys . CONTROL _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["ctrl"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   Gdx . input . isButtonPressed ( Input . Buttons . LEFT )  ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   button    =  =     ( Input . Buttons . LEFT )  ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   Gdx . input . isButtonPressed ( Input . Buttons . MIDDLE )  ;", "}", "METHOD_END"], "methodName": ["middle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   button    =  =     ( Input . Buttons . MIDDLE )  ;", "}", "METHOD_END"], "methodName": ["middle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   Gdx . input . isButtonPressed ( Input . Buttons . RIGHT )  ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   button    =  =     ( Input . Buttons . RIGHT )  ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( Gdx . input . isKeyPressed ( Input . Keys . SHIFT _ LEFT )  )     |  |     ( Gdx . input . isKeyPressed ( Input . Keys . SHIFT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["shift"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( keycode    =  =     ( Input . Keys . SHIFT _ LEFT )  )     |  |     ( keycode    =  =     ( Input . Keys . SHIFT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["shift"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    count ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . acopy ( a ,    start ,    items ,    size ,    count )  ;", "size    +  =    count ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( start    +    count )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" start    +    count   must   be    <  =    size :     \"     +    start )     +     \"     +     \"  )     +    count )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll (  (  ( T [  ]  )     ( array . items )  )  ,    start ,    count )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "items [ i ]     =    null ;", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "int   i    =     ( size )     -     1  ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "while    ( i    >  =     0  )", "if    (  ( items [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "} else    {", "while    ( i    >  =     0  )", "if    ( value . equals ( items [  ( i -  -  )  ]  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "Object [  ]    items 1     =    this . items ;", "Object [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "Object   o 1     =    items 1  [ i ]  ;", "Object   o 2     =    items 2  [ i ]  ;", "if    (  !  ( o 1     =  =    null    ?    o 2     =  =    null    :    o 1  . equals ( o 2  )  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   per . haCode (  )  ;", "Object [  ]    item =    thiitem", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    ze ;    i    <    n ;    i +  +  )     {", "h    *  =     3  1  ;", "Object   item    =    itemi ]  ;", "if    ( item    !  =    null )", "h    +  =    item . haCode (  )  ;", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "} else    {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    ( value . equals ( items [ i ]  )  )", "return   i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "T [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . acopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterable )     =  =    null )", "iterable    =    newIterable ( this )  ;", "return   iterable . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "} else    {", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    ( value . equals ( items [ i ]  )  )", "return   i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "return   new   Array < T >  ( ordered ,    capacity ,    arrayType )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "return   new   Array < T >  ( arrayType )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "-  -  ( size )  ;", "T   item    =    items [ size ]  ;", "items [ size ]     =    null ;", "return   item ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return   null ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "T [  ]    items    =    this . items ;", "if    ( identity )     {", "for    ( int   i    =     0  ,    n    =    a . size ;    i    <    n ;    i +  +  )     {", "T   item    =    a . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "} else    {", "for    ( int   i    =     0  ,    n    =    a . size ;    i    <    n ;    i +  +  )     {", "T   item    =    a . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item . equals ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "T [  ]    items    =    this . items ;", "T   value    =     (  ( T )     ( items [ index ]  )  )  ;", "( size )  -  -  ;", "if    ( ordered )", "System . acopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "items [ size ]     =    null ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "T [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . acopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( items [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "} else    {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    ( value . equals ( items [ i ]  )  )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "T [  ]    newItems    =     (  ( T [  ]  )     ( Reflection . newInstance ( items . getClass (  )  . getComponentType (  )  ,    newSize )  )  )  ;", "System . arraycopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "T   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( predicateIterable )     =  =    null )", "predicateIterable    =    new   Predicate . PredicateIterable < T >  ( this ,    predicate )  ;", "else", "predicateIterable . set ( this ,    predicate )  ;", "return   predicateIterable ;", "}", "METHOD_END"], "methodName": ["select"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( kthLowest    <     1  )     {", "throw   new   GdxRuntimeException (  \" nth _ lowest   must   be   greater   than    0  ,     1     =    first ,     2     =    second .  .  .  \"  )  ;", "}", "return   Select . instance (  )  . select ( items ,    parator ,    kthLowest ,    size )  ;", "}", "METHOD_END"], "methodName": ["selectRanked"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( kthLowest    <     1  )     {", "throw   new   GdxRuntimeException (  \" nth _ lowest   must   be   greater   than    0  ,     1     =    first ,     2     =    second .  .  .  \"  )  ;", "}", "return   Select . instance (  )  . selectIndex ( items ,    parator ,    kthLowest ,    size )  ;", "}", "METHOD_END"], "methodName": ["selectRankedIndex"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "truncate ( newSize )  ;", "if    ( newSize    >     ( itemlength )  )", "reze ( Math . max (  8  ,    newSize )  )  ;", "ze    =    newSize ;", "return   item", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "T [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "T   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "Sort . instance (  )  . sort ( items ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "Sort . instance (  )  . sort ( items ,    comparator ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "T [  ]    items    =    this . items ;", "T   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T [  ]  )     ( toArray ( items . getClass (  )  . getComponentType (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "V [  ]    result    =     (  ( V [  ]  )     ( ArrayReflection . newInstance ( type ,    size )  )  )  ;", "System . arraycopy ( items ,     0  ,    result ,     0  ,    size )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return    \"  [  ]  \"  ;", "T [  ]    item =    thiitem", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( item 0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( ze )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( itemi ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return    \"  \"  ;", "T [  ]    item =    thiitem", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( item 0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( ze )  ;    i +  +  )     {", "buffer . append ( parator )  ;", "buffer . append ( itemi ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     <  =    newSize )", "return ;", "for    ( int   i    =    newSize ;    i    <     ( size )  ;    i +  +  )", "items [ i ]     =    null ;", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "return   new   Array ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.Array"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keys    =    this . keys ;", "V [  ]    values    =    this . values ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "keys [ i ]     =    null ;", "values [ i ]     =    null ;", "}", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys . length )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keys    =    this . keys ;", "int   i    =     ( size )     -     1  ;", "if    ( key    =  =    null )     {", "while    ( i    >  =     0  )", "if    (  ( keys [  ( i -  -  )  ]  )     =  =    key )", "return   true ;", "} else    {", "while    ( i    >  =     0  )", "if    ( key . equals ( keys [  ( i -  -  )  ]  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    values    =    this . values ;", "int   i    =     ( size )     -     1  ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "while    ( i    >  =     0  )", "if    (  ( values [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "} else    {", "while    ( i    >  =     0  )", "if    ( value . equals ( values [  ( i -  -  )  ]  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( keys . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . index    =     0  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . index    =     0  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "< K ,    V >    other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "K [  ]    keys    =    this . keys ;", "V [  ]    values    =    this . values ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "K   key    =    keys [ i ]  ;", "V   value    =    values [ i ]  ;", "if    ( value    =  =    null )     {", "if    (  (  !  ( other . containsKey ( key )  )  )     |  |     (  ( other . get ( key )  )     !  =    null )  )     {", "return   false ;", "}", "} else    {", "if    (  !  ( value . equals ( other . get ( key )  )  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   keys [  0  ]  ;", "}", "METHOD_END"], "methodName": ["firstKey"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   values [  0  ]  ;", "}", "METHOD_END"], "methodName": ["firstValue"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    keys    =    this . keys ;", "int   i    =     ( size )     -     1  ;", "if    ( key    =  =    null )     {", "for    (  ;    i    >  =     0  ;    i -  -  )", "if    (  ( keys [ i ]  )     =  =    key )", "return   values [ i ]  ;", "} else    {", "for    (  ;    i    >  =     0  ;    i -  -  )", "if    ( key . equals ( keys [ i ]  )  )", "return   values [ i ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    values    =    this . values ;", "int   i    =     ( size )     -     1  ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "for    (  ;    i    >  =     0  ;    i -  -  )", "if    (  ( values [ i ]  )     =  =    value )", "return   keys [ i ]  ;", "} else    {", "for    (  ;    i    >  =     0  ;    i -  -  )", "if    ( value . equals ( values [ i ]  )  )", "return   keys [ i ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException ( String . valueOf ( index )  )  ;", "return   keys [ index ]  ;", "}", "METHOD_END"], "methodName": ["getKeyAt"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException ( String . valueOf ( index )  )  ;", "return   values [ index ]  ;", "}", "METHOD_END"], "methodName": ["getValueAt"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keys    =    this . keys ;", "V [  ]    values    =    this . values ;", "int   h    =     0  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "K   key    =    keys [ i ]  ;", "V   value    =    values [ i ]  ;", "if    ( key    !  =    null )", "h    +  =     ( key . hashCode (  )  )     *     3  1  ;", "if    ( value    !  =    null )", "h    +  =    value . hashCode (  )  ;", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    keys    =    this . keys ;", "if    ( key    =  =    null )     {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( keys [ i ]  )     =  =    key )", "return   i ;", "} else    {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keys [ i ]  )  )", "return   i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOfKey"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    values    =    this . values ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( values [ i ]  )     =  =    value )", "return   i ;", "} else    {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    ( value . equals ( values [ i ]  )  )", "return   i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOfValue"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException ( String . valueOf ( index )  )  ;", "if    (  ( size )     =  =     ( keys . length )  )", "resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )     {", "System . acopy ( keys ,    index ,    keys ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "System . acopy ( values ,    index ,    values ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "} else    {", "keys [ size ]     =    keys [ index ]  ;", "values [ size ]     =    values [ index ]  ;", "}", "( size )  +  +  ;", "keys [ index ]     =    key ;", "values [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keysIter 1  )     =  =    null )     {", "keysIter 1     =    new    . Keys ( this )  ;", "keysIter 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keysIter 1  . valid )  )     {", "keysIter 1  . index    =     0  ;", "keysIter 1  . valid    =    true ;", "keysIter 2  . valid    =    false ;", "return   keysIter 1  ;", "}", "keysIter 2  . index    =     0  ;", "keysIter 2  . valid    =    true ;", "keysIter 1  . valid    =    false ;", "return   keysIter 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "return   keys [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peekKey"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "return   values [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peekValue"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "int   index    =    indexOfKey ( key )  ;", "if    ( index    =  =     (  -  1  )  )     {", "if    (  ( ze )     =  =     ( keylength )  )", "reze ( Math . max (  8  ,     (  ( int )     (  ( ze )     *     1  .  7  5 F )  )  )  )  ;", "index    =     ( ze )  +  +  ;", "}", "keyindex ]     =    key ;", "valueindex ]     =    value ;", "return   index ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "int   existingIndex    =    indexOfKey ( key )  ;", "if    ( existingIndex    !  =     (  -  1  )  )", "removeIndex ( existingIndex )  ;", "else", "if    (  ( size )     =  =     ( keys . length )  )", "resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "System . acopy ( keys ,    index ,    keys ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "System . acopy ( values ,    index ,    values ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "keys [ index ]     =    key ;", "values [ index ]     =    value ;", "( size )  +  +  ;", "return   index ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "putAll ( map ,     0  ,    map . size )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( map . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( map . size )  )  )  ;", "int   sizeNeeded    =     (  ( size )     +    length )     -    offset ;", "if    ( sizeNeeded    >  =     ( keys . length )  )", "resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . acopy ( map . keys ,    offset ,    keys ,    size ,    length )  ;", "System . acopy ( map . values ,    offset ,    values ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException ( String . valueOf ( index )  )  ;", "Object [  ]    keys    =    this . keys ;", "( size )  -  -  ;", "if    ( ordered )     {", "System . acopy ( keys ,     ( index    +     1  )  ,    keys ,    index ,     (  ( size )     -    index )  )  ;", "System . acopy ( values ,     ( index    +     1  )  ,    values ,    index ,     (  ( size )     -    index )  )  ;", "} else    {", "keys [ index ]     =    keys [ size ]  ;", "values [ index ]     =    values [ size ]  ;", "}", "keys [ size ]     =    null ;", "values [ size ]     =    null ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    keys    =    this . keys ;", "if    ( key    =  =    null )     {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( keys [ i ]  )     =  =    key )     {", "V   value    =    values [ i ]  ;", "removeIndex ( i )  ;", "return   value ;", "}", "}", "} else    {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keys [ i ]  )  )     {", "V   value    =    values [ i ]  ;", "removeIndex ( i )  ;", "return   value ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["removeKey"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    values    =    this . values ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( values [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "} else    {", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    ( value . equals ( values [ i ]  )  )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    newKeys    =     (  ( K [  ]  )     ( ArrayReflection . newInstance ( keys . getClass (  )  . getComponentType (  )  ,    newSize )  )  )  ;", "System . arraycopy ( keys ,     0  ,    newKeys ,     0  ,    Math . min ( size ,    newKeys . length )  )  ;", "this . keys    =    newKeys ;", "V [  ]    newValues    =     (  ( V [  ]  )     ( ArrayReflection . newInstance ( values . getClass (  )  . getComponentType (  )  ,    newSize )  )  )  ;", "System . arraycopy ( values ,     0  ,    newValues ,     0  ,    Math . min ( size ,    newValues . length )  )  ;", "this . values    =    newValues ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "K   tempKey    =    keys [ i ]  ;", "keys [ i ]     =    keys [ ii ]  ;", "keys [ ii ]     =    tempKey ;", "V   tempValue    =    values [ i ]  ;", "values [ i ]     =    values [ ii ]  ;", "values [ ii ]     =    tempValue ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException ( String . valueOf ( index )  )  ;", "keys [ index ]     =    key ;", "}", "METHOD_END"], "methodName": ["setKey"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException ( String . valueOf ( index )  )  ;", "values [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys . length )     =  =     ( size )  )", "return ;", "resize ( size )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "K   tempKey    =    keys [ i ]  ;", "keys [ i ]     =    keys [ ii ]  ;", "keys [ ii ]     =    tempKey ;", "V   tempValue    =    values [ i ]  ;", "values [ i ]     =    values [ ii ]  ;", "values [ ii ]     =    tempValue ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return    \"  {  }  \"  ;", "K [  ]    key =    thikey", "V [  ]    value =    thivalue", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  {  '  )  ;", "buffer . append ( key 0  ]  )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( value 0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( ze )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( keyi ]  )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valuei ]  )  ;", "}", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     <  =    newSize )", "return ;", "for    ( int   i    =    newSize ;    i    <     ( size )  ;    i +  +  )     {", "keys [ i ]     =    null ;", "values [ i ]     =    null ;", "}", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( valuesIter 1  )     =  =    null )     {", "valuesIter 1     =    new    . Values ( this )  ;", "valuesIter 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( valuesIter 1  . valid )  )     {", "valuesIter 1  . index    =     0  ;", "valuesIter 1  . valid    =    true ;", "valuesIter 2  . valid    =    false ;", "return   valuesIter 1  ;", "}", "valuesIter 2  . index    =     0  ;", "valuesIter 2  . valid    =    true ;", "valuesIter 1  . valid    =    false ;", "return   valuesIter 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.ArrayMap"}, {"methodBody": ["METHOD_START", "{", "return    ( idx    +     1  )     %     ( queue . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.badlogic.gdx.utils.AtomicQueue"}, {"methodBody": ["METHOD_START", "{", "int   read    =    readIndex . get (  )  ;", "int   write    =    writeIndex . get (  )  ;", "if    ( read    =  =    write )", "return   null ;", "T   value    =    q . get ( read )  ;", "readIndex . set ( next ( read )  )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["poll"], "fileName": "com.badlogic.gdx.utils.AtomicQueue"}, {"methodBody": ["METHOD_START", "{", "int   write    =    writeIndex . get (  )  ;", "int   read    =    readIndex . get (  )  ;", "int   next    =    next ( write )  ;", "if    ( next    =  =    read )", "return   false ;", "q . set ( write ,    value )  ;", "writeIndex . set ( next )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.AtomicQueue"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decode ( in ,     0  ,    in . length ,    Base 6  4 Coder . regularMap . decodingMap )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decode ( in ,     0  ,    in . length ,    inverseCharMap )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decode ( in ,     0  ,    in . length ,    inverseCharMap )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iLen    %     4  )     !  =     0  )     {", "throw   new   IllegalArgumentException (  \" Length   of      encoded   input   string   is   not   a   multiple   of    4  .  \"  )  ;", "}", "while    (  ( iLen    >     0  )     &  &     (  ( in [  (  ( iOff    +    iLen )     -     1  )  ]  )     =  =     '  =  '  )  )     {", "iLen -  -  ;", "}", "int   oLen    =     ( iLen    *     3  )     /     4  ;", "byte [  ]    out    =    new   byte [ oLen ]  ;", "int   ip    =    iOff ;", "int   iEnd    =    iOff    +    iLen ;", "int   op    =     0  ;", "while    ( ip    <    iEnd )     {", "int   i 0     =    in [  ( ip +  +  )  ]  ;", "int   i 1     =    in [  ( ip +  +  )  ]  ;", "int   i 2     =     ( ip    <    iEnd )     ?    in [  ( ip +  +  )  ]     :     ' A '  ;", "int   i 3     =     ( ip    <    iEnd )     ?    in [  ( ip +  +  )  ]     :     ' A '  ;", "if    (  (  (  ( i 0     >     1  2  7  )     |  |     ( i 1     >     1  2  7  )  )     |  |     ( i 2     >     1  2  7  )  )     |  |     ( i 3     >     1  2  7  )  )     {", "throw   new   IllegalArgumentException (  \" Illegal   character   in      encoded   data .  \"  )  ;", "}", "int   b 0     =    inverseCharMap [ i 0  ]  ;", "int   b 1     =    inverseCharMap [ i 1  ]  ;", "int   b 2     =    inverseCharMap [ i 2  ]  ;", "int   b 3     =    inverseCharMap [ i 3  ]  ;", "if    (  (  (  ( b 0     <     0  )     |  |     ( b 1     <     0  )  )     |  |     ( b 2     <     0  )  )     |  |     ( b 3     <     0  )  )     {", "throw   new   IllegalArgumentException (  \" Illegal   character   in      encoded   data .  \"  )  ;", "}", "int   o 0     =     ( b 0     <  <     2  )     |     ( b 1     >  >  >     4  )  ;", "int   o 1     =     (  ( b 1     &     1  5  )     <  <     4  )     |     ( b 2     >  >  >     2  )  ;", "int   o 2     =     (  ( b 2     &     3  )     <  <     6  )     |    b 3  ;", "out [  ( op +  +  )  ]     =     (  ( byte )     ( o 0  )  )  ;", "if    ( op    <    oLen )     {", "out [  ( op +  +  )  ]     =     (  ( byte )     ( o 1  )  )  ;", "}", "if    ( op    <    oLen )     {", "out [  ( op +  +  )  ]     =     (  ( byte )     ( o 2  )  )  ;", "}", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decode ( in ,    iOff ,    iLen ,    inverseCharMap . decodingMap )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decode ( s . toCharArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decode ( s . toCharArray (  )  ,    inverseCharMap )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decodeLines ( s ,    Base 6  4 Coder . regularMap . decodingMap )  ;", "}", "METHOD_END"], "methodName": ["decodeLines"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "char [  ]    buf    =    new   char [ s . length (  )  ]  ;", "int   p    =     0  ;", "for    ( int   ip    =     0  ;    ip    <     ( s . length (  )  )  ;    ip +  +  )     {", "char   c    =    s . charAt ( ip )  ;", "if    (  (  (  ( c    !  =     '     '  )     &  &     ( c    !  =     '  \\ r '  )  )     &  &     ( c    !  =     '  \\ n '  )  )     &  &     ( c    !  =     '  \\ t '  )  )     {", "buf [  ( p +  +  )  ]     =    c ;", "}", "}", "return    . decode ( buf ,     0  ,    p ,    inverseCharMap )  ;", "}", "METHOD_END"], "methodName": ["decodeLines"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decodeLines ( s ,    inverseCharMap . decodingMap )  ;", "}", "METHOD_END"], "methodName": ["decodeLines"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . decodeString ( s ,    false )  ;", "}", "METHOD_END"], "methodName": ["decodeString"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   new   String ( Base 6  4 Coder . decode ( s . toCharArray (  )  ,     ( useUrlSafeEncoding    ?    Base 6  4 Coder . urlsafeMap . decodingMap    :    Base 6  4 Coder . regularMap . decodingMap )  )  )  ;", "}", "METHOD_END"], "methodName": ["decodeString"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encode ( in ,    Base 6  4 Coder . regularMap . encodingMap )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encode ( in ,     0  ,    in . length ,    charMap )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encode ( in ,     0  ,    in . length ,    charMap )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encode ( in ,     0  ,    iLen ,    Base 6  4 Coder . regularMap . encodingMap )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "int   oDataLen    =     (  ( iLen    *     4  )     +     2  )     /     3  ;", "int   oLen    =     (  ( iLen    +     2  )     /     3  )     *     4  ;", "char [  ]    o    =    new   char [ oLen ]  ;", "int   ip    =    iOff ;", "int   iEnd    =    iOff    +    iLen ;", "int   op    =     0  ;", "while    ( ip    <    iEnd )     {", "int   i 0     =     ( in [  ( ip +  +  )  ]  )     &     2  5  5  ;", "int   i 1     =     ( ip    <    iEnd )     ?     ( in [  ( ip +  +  )  ]  )     &     2  5  5     :     0  ;", "int   i 2     =     ( ip    <    iEnd )     ?     ( in [  ( ip +  +  )  ]  )     &     2  5  5     :     0  ;", "int   o 0     =    i 0     >  >  >     2  ;", "int   o 1     =     (  ( i 0     &     3  )     <  <     4  )     |     ( i 1     >  >  >     4  )  ;", "int   o 2     =     (  ( i 1     &     1  5  )     <  <     2  )     |     ( i 2     >  >  >     6  )  ;", "int   o 3     =    i 2     &     6  3  ;", "o [  ( op +  +  )  ]     =    charMap [ o 0  ]  ;", "o [  ( op +  +  )  ]     =    charMap [ o 1  ]  ;", "o [ op ]     =     ( op    <    oDataLen )     ?    charMap [ o 2  ]     :     '  =  '  ;", "op +  +  ;", "o [ op ]     =     ( op    <    oDataLen )     ?    charMap [ o 3  ]     :     '  =  '  ;", "op +  +  ;", "}", "return   o ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encode ( in ,    iOff ,    iLen ,    charMap . encodingMap )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encodeLines ( in ,     0  ,    in . length ,     7  6  ,    Base 6  4 Coder . systemLineSeparator ,    Base 6  4 Coder . regularMap . encodingMap )  ;", "}", "METHOD_END"], "methodName": ["encodeLines"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "int   blockLen    =     ( lineLen    *     3  )     /     4  ;", "if    ( blockLen    <  =     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "int   lines    =     (  ( iLen    +    blockLen )     -     1  )     /    blockLen ;", "int   bufLen    =     (  (  ( iLen    +     2  )     /     3  )     *     4  )     +     ( lines    *     ( lineSeparator . length (  )  )  )  ;", "StringBuilder   buf    =    new   StringBuilder ( bufLen )  ;", "int   ip    =     0  ;", "while    ( ip    <    iLen )     {", "int   l    =    Math . min (  ( iLen    -    ip )  ,    blockLen )  ;", "buf . append (  . encode ( in ,     ( iOff    +    ip )  ,    l ,    charMap )  )  ;", "buf . append ( lineSeparator )  ;", "ip    +  =    l ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["encodeLines"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encodeLines ( in ,    iOff ,    iLen ,    lineLen ,    lineSeparator ,    charMap . encodingMap )  ;", "}", "METHOD_END"], "methodName": ["encodeLines"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Coder . encodeString ( s ,    false )  ;", "}", "METHOD_END"], "methodName": ["encodeString"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "return   new   String ( Base 6  4 Coder . encode ( s . getBytes (  )  ,     ( useUrlsafeEncoding    ?    Base 6  4 Coder . urlsafeMap . encodingMap    :    Base 6  4 Coder . regularMap . encodingMap )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeString"], "fileName": "com.badlogic.gdx.utils.Base64Coder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     ( nodes . length )  )     {", ". Node [  ]    newNodes    =    new    . Node [  ( size )     <  <     1  ]  ;", "System . arraycopy ( nodes ,     0  ,    newNodes ,     0  ,    size )  ;", "nodes    =    newNodes ;", "}", "node . index    =    size ;", "nodes [ size ]     =    node ;", "up (  (  ( size )  +  +  )  )  ;", "return   node ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "node . value    =    value ;", "return   d ( node )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "BinaryHeap . Node [  ]    nodes    =    this . nodes ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "nodes [ i ]     =    null ;", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "BinaryHeap . Node [  ]    nodes    =    this . nodes ;", "int   size    =    this . size ;", "BinaryHeap . Node   node    =    nodes [ index ]  ;", "float   value    =    node . value ;", "while    ( true )     {", "int   leftIndex    =     1     +     ( index    <  <     1  )  ;", "if    ( leftIndex    >  =    size )", "break ;", "int   rightIndex    =    leftIndex    +     1  ;", "BinaryHeap . Node   leftNode    =    nodes [ leftIndex ]  ;", "float   leftValue    =    leftNode . value ;", "BinaryHeap . Node   rightNode ;", "float   rightValue ;", "if    ( rightIndex    >  =    size )     {", "rightNode    =    null ;", "rightValue    =     ( isMaxHeap )     ?    Float . MIN _ VALUE    :    Float . MAX _ VALUE ;", "} else    {", "rightNode    =    nodes [ rightIndex ]  ;", "rightValue    =    rightNode . value ;", "}", "if    (  ( leftValue    <    rightValue )     ^     ( isMaxHeap )  )     {", "if    (  ( leftValue    =  =    value )     |  |     (  ( leftValue    >    value )     ^     ( isMaxHeap )  )  )", "break ;", "nodes [ index ]     =    leftNode ;", "leftNode . index    =    index ;", "index    =    leftIndex ;", "} else    {", "if    (  ( rightValue    =  =    value )     |  |     (  ( rightValue    >    value )     ^     ( isMaxHeap )  )  )", "break ;", "nodes [ index ]     =    rightNode ;", "rightNode . index    =    index ;", "index    =    rightIndex ;", "}", "}", "nodes [ index ]     =    node ;", "node . index    =    index ;", "}", "METHOD_END"], "methodName": ["down"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     ( Float . floatToIntBits ( nodes [ i ]  . value )  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \" The   h   is   empty .  \"  )  ;", "return    (  ( T )     ( nodes [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "return   remove (  0  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "return   remove ( node . index )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "BinaryHeap . Node [  ]    nodes    =    this . nodes ;", "BinaryHeap . Node   removed    =    nodes [ index ]  ;", "nodes [ index ]     =    nodes [  (  -  -  ( size )  )  ]  ;", "nodes [ size ]     =    null ;", "if    (  (  ( size )     >     0  )     &  &     ( index    <     ( size )  )  )", "down ( index )  ;", "return    (  ( T )     ( removed )  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "float   oldValue    =    node . value ;", "node . value    =    value ;", "if    (  ( value    <    oldValue )     ^     ( isMax )  )", "up ( node . index )  ;", "else", "down ( node . index )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", ". Node [  ]    nodes    =    this . nodes ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( nodes [  0  ]  . value )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( nodes [ i ]  . value )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "BinaryHeap . Node [  ]    nodes    =    this . nodes ;", "BinaryHeap . Node   node    =    nodes [ index ]  ;", "float   value    =    node . value ;", "while    ( index    >     0  )     {", "int   parentIndex    =     ( index    -     1  )     >  >     1  ;", "BinaryHeap . Node   parent    =    nodes [ parentIndex ]  ;", "if    (  ( value    <     ( parent . value )  )     ^     ( isMaxHeap )  )     {", "nodes [ index ]     =    parent ;", "parent . index    =    index ;", "index    =    parentIndex ;", "} else", "break ;", "}", "nodes [ index ]     =    node ;", "node . index    =    index ;", "}", "METHOD_END"], "methodName": ["up"], "fileName": "com.badlogic.gdx.utils.BinaryHeap"}, {"methodBody": ["METHOD_START", "{", "int   commonWords    =    Math . min ( bits . length ,    other . bits . length )  ;", "for    ( int   i    =     0  ;    commonWords    >    i ;    i +  +  )     {", "bits [ i ]     &  =    other . bits [ i ]  ;", "}", "if    (  ( bits . length )     >    commonWords )     {", "for    ( int   i    =    commonWords ,    s    =    bits . length ;    s    >    i ;    i +  +  )     {", "bits [ i ]     =     0 L ;", "}", "}", "}", "METHOD_END"], "methodName": ["and"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    j    =    bits . length ,    k    =    other . bits . length ;     ( i    <    j )     &  &     ( i    <    k )  ;    i +  +  )     {", "bits [ i ]     &  =     ~  ( other . bits [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["andNot"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "if    ( len    >  =     ( bits . length )  )     {", "long [  ]    new    =    new   long [ len    +     1  ]  ;", "System . arraycopy ( bits ,     0  ,    new ,     0  ,    bits . length )  ;", "bits    =    new ;", "}", "}", "METHOD_END"], "methodName": ["checkCapacity"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "long [  ]    bits    =    this . bits ;", "int   length    =    bits . length ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "bits [ i ]     =     0 L ;", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "final   int   word    =    index    >  >  >     6  ;", "if    ( word    >  =     ( b . length )  )", "return ;", "b [ word ]     &  =     ~  (  1 L    <  <     ( index    &     6  3  )  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "long [  ]    bits    =    this . bits ;", "long [  ]    other    =    other . bits ;", "int   otherLength    =    other . length ;", "int   bitsLength    =    bits . length ;", "for    ( int   i    =    bitsLength ;    i    <    otherLength ;    i +  +  )     {", "if    (  ( other [ i ]  )     !  =     0  )     {", "return   false ;", "}", "}", "for    ( int   i    =     ( Math . min ( bitsLength ,    otherLength )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    (  (  ( bits [ i ]  )     &     ( other [ i ]  )  )     !  =     ( other [ i ]  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsAll"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "final   int   word    =    index    >  >  >     6  ;", "checkCapacity ( word )  ;", "b [ word ]     ^  =     1 L    <  <     ( index    &     6  3  )  ;", "}", "METHOD_END"], "methodName": ["flip"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "final   int   word    =    index    >  >  >     6  ;", "if    ( word    >  =     ( b . length )  )", "return   false ;", "return    (  ( b [ word ]  )     &     (  1 L    <  <     ( index    &     6  3  )  )  )     !  =     0 L ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "final   int   word    =    index    >  >  >     6  ;", "if    ( word    >  =     ( bits . length )  )", "return   false ;", "long   old    =    bits [ word ]  ;", "bits [ word ]     &  =     ~  (  1 L    <  <     ( index    &     6  3  )  )  ;", "return    ( bits [ word ]  )     !  =    old ;", "}", "METHOD_END"], "methodName": ["getAndClear"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "final   int   word    =    index    >  >  >     6  ;", "checkCapacity ( word )  ;", "long   old    =    bits [ word ]  ;", "bits [ word ]     |  =     1 L    <  <     ( index    &     6  3  )  ;", "return    ( bits [ word ]  )     =  =    old ;", "}", "METHOD_END"], "methodName": ["getAndSet"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "long [  ]    bits    =    this . bits ;", "long [  ]    other    =    other . bits ;", "for    ( int   i    =     ( Math . min ( bits . length ,    other . length )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    (  (  ( bits [ i ]  )     &     ( other [ i ]  )  )     !  =     0  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["intersects"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "long [  ]    bits    =    this . bits ;", "int   length    =    bits . length ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    (  ( bits [ i ]  )     !  =     0 L )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "long [  ]    bits    =    this . bits ;", "for    ( int   word    =     ( bits . length )     -     1  ;    word    >  =     0  ;     -  - word )     {", "long   bitsAtWord    =    bits [ word ]  ;", "if    ( bitsAtWord    !  =     0  )     {", "for    ( int   bit    =     6  3  ;    bit    >  =     0  ;     -  - bit )     {", "if    (  ( bitsAtWord    &     (  1 L    <  <     ( bit    &     6  3  )  )  )     !  =     0 L )     {", "return    (  ( word    <  <     6  )     +    bit )     +     1  ;", "}", "}", "}", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "long [  ]    bits    =    this . bits ;", "int   word    =    fromIndex    >  >  >     6  ;", "int   bitsLength    =    bits . length ;", "if    ( word    >  =    bitsLength )", "return    ( bits . length )     <  <     6  ;", "long   bitsAtWord    =    bits [ word ]  ;", "for    ( int   i    =    fromIndex    &     6  3  ;    i    <     6  4  ;    i +  +  )     {", "if    (  ( bitsAtWord    &     (  1 L    <  <     ( i    &     6  3  )  )  )     =  =     0 L )     {", "return    ( word    <  <     6  )     +    i ;", "}", "}", "for    ( word +  +  ;    word    <    bitsLength ;    word +  +  )     {", "if    ( word    =  =     0  )     {", "return   word    <  <     6  ;", "}", "bitsAtWord    =    bits [ word ]  ;", "for    ( int   i    =     0  ;    i    <     6  4  ;    i +  +  )     {", "if    (  ( bitsAtWord    &     (  1 L    <  <     ( i    &     6  3  )  )  )     =  =     0 L )     {", "return    ( word    <  <     6  )     +    i ;", "}", "}", "}", "return    ( bits . length )     <  <     6  ;", "}", "METHOD_END"], "methodName": ["nextClearBit"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "long [  ]    bits    =    this . bits ;", "int   word    =    fromIndex    >  >  >     6  ;", "int   bitsLength    =    bits . length ;", "if    ( word    >  =    bitsLength )", "return    -  1  ;", "long   bitsAtWord    =    bits [ word ]  ;", "if    ( bitsAtWord    !  =     0  )     {", "for    ( int   i    =    fromIndex    &     6  3  ;    i    <     6  4  ;    i +  +  )     {", "if    (  ( bitsAtWord    &     (  1 L    <  <     ( i    &     6  3  )  )  )     !  =     0 L )     {", "return    ( word    <  <     6  )     +    i ;", "}", "}", "}", "for    ( word +  +  ;    word    <    bitsLength ;    word +  +  )     {", "if    ( word    !  =     0  )     {", "bitsAtWord    =    bits [ word ]  ;", "if    ( bitsAtWord    !  =     0  )     {", "for    ( int   i    =     0  ;    i    <     6  4  ;    i +  +  )     {", "if    (  ( bitsAtWord    &     (  1 L    <  <     ( i    &     6  3  )  )  )     !  =     0 L )     {", "return    ( word    <  <     6  )     +    i ;", "}", "}", "}", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["nextSetBit"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "return    ( bits . length )     <  <     6  ;", "}", "METHOD_END"], "methodName": ["numBits"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "int   commonWords    =    Math . min ( bits . length ,    other . bits . length )  ;", "for    ( int   i    =     0  ;    commonWords    >    i ;    i +  +  )     {", "bits [ i ]     |  =    other . bits [ i ]  ;", "}", "if    ( commonWords    <     ( other . bits . length )  )     {", "checkCapacity ( other . bits . length )  ;", "for    ( int   i    =    commonWords ,    s    =    other . bits . length ;    s    >    i ;    i +  +  )     {", "bits [ i ]     =    other . bits [ i ]  ;", "}", "}", "}", "METHOD_END"], "methodName": ["or"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "final   int   word    =    index    >  >  >     6  ;", "checkCapacity ( word )  ;", "b [ word ]     |  =     1 L    <  <     ( index    &     6  3  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "int   commonWords    =    Math . min ( bits . length ,    other . bits . length )  ;", "for    ( int   i    =     0  ;    commonWords    >    i ;    i +  +  )     {", "bits [ i ]     ^  =    other . bits [ i ]  ;", "}", "if    ( commonWords    <     ( other . bits . length )  )     {", "checkCapacity ( other . bits . length )  ;", "for    ( int   i    =    commonWords ,    s    =    other . bits . length ;    s    >    i ;    i +  +  )     {", "bits [ i ]     =    other . bits [ i ]  ;", "}", "}", "}", "METHOD_END"], "methodName": ["xor"], "fileName": "com.badlogic.gdx.utils.Bits"}, {"methodBody": ["METHOD_START", "{", "Bits   b 1     =    new   Bits (  )  ;", "Bits   b 2     =    new   Bits (  )  ;", "b 2  . set (  2  0  0  )  ;", "b 2  . and ( b 1  )  ;", "assertFalse ( b 2  . get (  2  0  0  )  )  ;", "b 1  . set (  4  0  0  )  ;", "b 1  . and ( b 2  )  ;", "assertFalse ( b 1  . get (  4  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnd"], "fileName": "com.badlogic.gdx.utils.BitsTest"}, {"methodBody": ["METHOD_START", "{", "Bits   b 1     =    new   Bits (  )  ;", "Bits   b 2     =    new   Bits (  )  ;", "b 1  . set (  1  )  ;", "b 2  . set (  1  )  ;", "assertEquals ( b 1  . hashCode (  )  ,    b 2  . hashCode (  )  )  ;", "assertTrue ( b 1  . equals ( b 2  )  )  ;", "b 2  . set (  4  2  0  )  ;", "b 2  . clear (  4  2  0  )  ;", "assertEquals ( b 1  . hashCode (  )  ,    b 2  . hashCode (  )  )  ;", "assertTrue ( b 1  . equals ( b 2  )  )  ;", "b 1  . set (  8  1  0  )  ;", "b 1  . clear (  8  1  0  )  ;", "assertEquals ( b 1  . hashCode (  )  ,    b 2  . hashCode (  )  )  ;", "assertTrue ( b 1  . equals ( b 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testHashcodeAndEquals"], "fileName": "com.badlogic.gdx.utils.BitsTest"}, {"methodBody": ["METHOD_START", "{", "Bits   b 1     =    new   Bits (  )  ;", "Bits   b 2     =    new   Bits (  )  ;", "b 2  . set (  2  0  0  )  ;", "b 1  . or ( b 2  )  ;", "assertTrue ( b 1  . get (  2  0  0  )  )  ;", "b 1  . set (  1  0  2  4  )  ;", "b 2  . or ( b 1  )  ;", "assertTrue ( b 2  . get (  1  0  2  4  )  )  ;", "}", "METHOD_END"], "methodName": ["testOr"], "fileName": "com.badlogic.gdx.utils.BitsTest"}, {"methodBody": ["METHOD_START", "{", "Bits   b 1     =    new   Bits (  )  ;", "Bits   b 2     =    new   Bits (  )  ;", "b 2  . set (  2  0  0  )  ;", "b 1  . xor ( b 2  )  ;", "assertTrue ( b 1  . get (  2  0  0  )  )  ;", "b 1  . set (  1  0  2  4  )  ;", "b 2  . xor ( b 1  )  ;", "assertTrue ( b 2  . get (  1  0  2  4  )  )  ;", "}", "METHOD_END"], "methodName": ["testXor"], "fileName": "com.badlogic.gdx.utils.BitsTest"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    length ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . arraycopy ( array ,    offset ,    items ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "boolean [  ]    items 1     =    this . items ;", "boolean [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( items 1  [ i ]  )     !  =     ( items 2  [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   super . hashCode (  )  ;", "b [  ]    items    =    this . items ;", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     ( items [ i ]     ?     1  2  3  1     :     1  2  3  7  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "b [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . arraycopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  -  -  ( size )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return   false ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "b [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    array . size ;    i    <    n ;    i +  +  )     {", "b   item    =    array . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "b [  ]    items    =    this . items ;", "b   value    =    items [ index ]  ;", "( size )  -  -  ;", "if    ( ordered )", "System . arraycopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "b [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . arraycopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    newItems    =    new   boolean [ newSize ]  ;", "boolean [  ]    items    =    this . items ;", "System . arraycopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "boolean   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( newSize    >     ( items . length )  )", "resize ( Math . max (  8  ,    newSize )  )  ;", "size    =    newSize ;", "return   items ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUtils . random ( i )  ;", "boolean   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "b [  ]    items    =    this . items ;", "b   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    array    =    new   boolean [ size ]  ;", "System . arraycopy ( items ,     0  ,    array ,     0  ,    size )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "b [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  \"  ;", "b [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append ( separator )  ;", "buffer . append ( items [ i ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     >    newSize )", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "return   new   BooleanArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.BooleanArray"}, {"methodBody": ["METHOD_START", "{", "if    ( dst   instanceof   ByteBuffer )", "return   bytes ;", "else", "if    ( dst   instanceof   ShortBuffer )", "return   bytes    >  >  >     1  ;", "else", "if    ( dst   instanceof   CharBuffer )", "return   bytes    >  >  >     1  ;", "else", "if    ( dst   instanceof   IntBuffer )", "return   bytes    >  >  >     2  ;", "else", "if    ( dst   instanceof   LongBuffer )", "return   bytes    >  >  >     3  ;", "else", "if    ( dst   instanceof   FloatBuffer )", "return   bytes    >  >  >     2  ;", "else", "if    ( dst   instanceof   DoubleBuffer )", "return   bytes    >  >  >     3  ;", "else", "throw   new   GdxRuntimeException (  (  (  \" Can ' t   copy   to   a    \"     +     ( dst . getClass (  )  . getName (  )  )  )     +     \"    instance \"  )  )  ;", "}", "METHOD_END"], "methodName": ["bytesToElements"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,    numElements )  )  )  )  ;", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,    numElements )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     1  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,     ( numElements    <  <     1  )  )  )  )  )  ;", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     1  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     3  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,     ( numElements    <  <     3  )  )  )  )  )  ;", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     3  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     2  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,     ( numElements    <  <     2  )  )  )  )  )  ;", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     2  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( dst   instanceof   ByteBuffer )", "dst . limit (  ( numFloats    <  <     2  )  )  ;", "else", "if    ( dst   instanceof   FloatBuffer )", "dst . limit ( numFloats )  ;", ". copyJni ( src ,    dst ,    numFloats ,    offset )  ;", "dst . position (  0  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     2  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,     ( numElements    <  <     2  )  )  )  )  )  ;", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     2  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "int   numBytes    =    BufferUtils . elementsToBytes ( src ,    numElements )  ;", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,    numBytes )  )  )  )  ;", "BufferUtils . copyJni ( src ,    BufferUtils . positionInBytes ( src )  ,    dst ,    BufferUtils . positionInBytes ( dst )  ,    numBytes )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     3  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,     ( numElements    <  <     3  )  )  )  )  )  ;", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     3  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "dst . limit (  (  ( dst . position (  )  )     +     ( BufferUtils . bytesToElements ( dst ,     ( numElements    <  <     1  )  )  )  )  )  ;", "BufferUtils . copyJni ( src ,    srcOffset ,    dst ,    BufferUtils . positionInBytes ( dst )  ,     ( numElements    <  <     1  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "int   size    =    buffer . capacity (  )  ;", "synchronized (  . unsafeBuffers )     {", "if    (  !  (  . unsafeBuffers . removeValue ( buffer ,    true )  )  )", "throw   new   IllegalArgumentException (  \" buffer   not   allocated   with   newUnsafeByteBuffer   or   already   disposed \"  )  ;", "}", ". allocatedUnsafe    -  =    size ;", ". freeMemory ( buffer )  ;", "}", "METHOD_END"], "methodName": ["disposeUnsafeByteBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( dst   instanceof   ByteBuffer )", "return   elements ;", "else", "if    ( dst   instanceof   ShortBuffer )", "return   elements    <  <     1  ;", "else", "if    ( dst   instanceof   CharBuffer )", "return   elements    <  <     1  ;", "else", "if    ( dst   instanceof   IntBuffer )", "return   elements    <  <     2  ;", "else", "if    ( dst   instanceof   LongBuffer )", "return   elements    <  <     3  ;", "else", "if    ( dst   instanceof   FloatBuffer )", "return   elements    <  <     2  ;", "else", "if    ( dst   instanceof   DoubleBuffer )", "return   elements    <  <     3  ;", "else", "throw   new   GdxRuntimeException (  (  (  \" Can ' t   copy   to   a    \"     +     ( dst . getClass (  )  . getName (  )  )  )     +     \"    instance \"  )  )  ;", "}", "METHOD_END"], "methodName": ["elementsToBytes"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,     0  ,    strideInBytes ,    vertices ,     0  ,    numVertices )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,     0  ,    strideInBytes ,    vertices ,     0  ,    numVertices ,    epsilon )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,     0  ,    strideInBytes ,    vertices ,    BufferUtils . positionInBytes ( vertices )  ,    numVertices )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,     0  ,    strideInBytes ,    vertices ,    BufferUtils . positionInBytes ( vertices )  ,    numVertices ,    epsilon )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,    BufferUtils . positionInBytes ( vertex )  ,    strideInBytes ,    vertices ,     0  ,    numVertices )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,    BufferUtils . positionInBytes ( vertex )  ,    strideInBytes ,    vertices ,     0  ,    numVertices ,    epsilon )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,    BufferUtils . positionInBytes ( vertex )  ,    strideInBytes ,    vertices ,    BufferUtils . positionInBytes ( vertices )  ,    numVertices )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . find ( vertex ,    BufferUtils . positionInBytes ( vertex )  ,    strideInBytes ,    vertices ,    BufferUtils . positionInBytes ( vertices )  ,    numVertices ,    epsilon )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . allocatedUnsafe ;", "}", "METHOD_END"], "methodName": ["getAllocatedBytesUnsafe"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( BufferUtils . getBufferAddress ( buffer )  )     +     ( buffer . position (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUnsafeBufferAddress"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect ( numBytes )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["newByteBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  ( numChars    *     2  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asCharBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["newCharBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  ( numDoubles    *     8  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asDoubleBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["newDoubleBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  ( numFloats    *     4  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asFloatBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["newFloatBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  ( numInts    *     4  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asIntBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["newIntBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  ( numLongs    *     8  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asLongBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["newLongBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  ( numShorts    *     2  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asShortBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["newShortBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    BufferUtils . newDisposableByteBuffer ( numBytes )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "BufferUtils . allocatedUnsafe    +  =    numBytes ;", "synchronized ( BufferUtils . unsafeBuffers )     {", "BufferUtils . unsafeBuffers . add ( buffer )  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["newUnsafeByteBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . allocatedUnsafe    +  =    buffer . capacity (  )  ;", "synchronized ( BufferUtils . unsafeBuffers )     {", "BufferUtils . unsafeBuffers . add ( buffer )  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["newUnsafeByteBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( dst   instanceof   ByteBuffer )", "return   dst . position (  )  ;", "else", "if    ( dst   instanceof   ShortBuffer )", "return    ( dst . position (  )  )     <  <     1  ;", "else", "if    ( dst   instanceof   CharBuffer )", "return    ( dst . position (  )  )     <  <     1  ;", "else", "if    ( dst   instanceof   IntBuffer )", "return    ( dst . position (  )  )     <  <     2  ;", "else", "if    ( dst   instanceof   LongBuffer )", "return    ( dst . position (  )  )     <  <     3  ;", "else", "if    ( dst   instanceof   FloatBuffer )", "return    ( dst . position (  )  )     <  <     2  ;", "else", "if    ( dst   instanceof   DoubleBuffer )", "return    ( dst . position (  )  )     <  <     3  ;", "else", "throw   new   GdxRuntimeException (  (  (  \" Can ' t   copy   to   a    \"     +     ( dst . getClass (  )  . getName (  )  )  )     +     \"    instance \"  )  )  ;", "}", "METHOD_END"], "methodName": ["positionInBytes"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . transform ( data ,    dimensions ,    strideInBytes ,    count ,    matrix ,     0  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "switch    ( dimensions )     {", "case    3     :", ". transformV 3 M 3 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,    offset )  ;", "break ;", "case    2     :", ". transformV 2 M 3 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,    offset )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . transform ( data ,    dimensions ,    strideInBytes ,    count ,    matrix ,     0  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "switch    ( dimensions )     {", "case    4     :", ". transformV 4 M 4 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,    offset )  ;", "break ;", "case    3     :", ". transformV 3 M 4 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,    offset )  ;", "break ;", "case    2     :", ". transformV 2 M 4 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,    offset )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . transform ( data ,    dimensions ,    strideInBytes ,    count ,    matrix ,     0  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "switch    ( dimensions )     {", "case    3     :", ". transformV 3 M 3 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,     (  (  . positionInBytes ( data )  )     +    offset )  )  ;", "break ;", "case    2     :", ". transformV 2 M 3 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,     (  (  . positionInBytes ( data )  )     +    offset )  )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "BufferUtils . transform ( data ,    dimensions ,    strideInBytes ,    count ,    matrix ,     0  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "switch    ( dimensions )     {", "case    4     :", ". transformV 4 M 4 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,     (  (  . positionInBytes ( data )  )     +    offset )  )  ;", "break ;", "case    3     :", ". transformV 3 M 4 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,     (  (  . positionInBytes ( data )  )     +    offset )  )  ;", "break ;", "case    2     :", ". transformV 2 M 4 Jni ( data ,    strideInBytes ,    count ,    matrix . val ,     (  (  . positionInBytes ( data )  )     +    offset )  )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    length ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . acopy ( a ,    offset ,    items ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "int   i    =     ( size )     -     1  ;", "b [  ]    items    =    this . items ;", "while    ( i    >  =     0  )", "if    (  ( items [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "byte [  ]    items 1     =    this . items ;", "byte [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( items 1  [ i ]  )     !  =     ( items 2  [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   super . hashCode (  )  ;", "b [  ]    items    =    this . items ;", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     ( items [ i ]  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     +  =    value ;", "}", "METHOD_END"], "methodName": ["incr"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "byte [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . acopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     *  =    value ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  -  -  ( size )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    0  ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "byte [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    a . size ;    i    <    n ;    i +  +  )     {", "int   item    =    a . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "byte [  ]    items    =    this . items ;", "int   value    =    items [ index ]  ;", "( size )  -  -  ;", "if    ( ordered )", "System . acopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "byte [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . acopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( items [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    newItems    =    new   byte [ newSize ]  ;", "byte [  ]    items    =    this . items ;", "System . acopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "byte   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( newSize    >     ( items . length )  )", "resize ( Math . max (  8  ,    newSize )  )  ;", "size    =    newSize ;", "return   items ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "byte   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( items ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "b [  ]    items    =    this . items ;", "b   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    array    =    new   byte [ size ]  ;", "System . arraycopy ( items ,     0  ,    array ,     0  ,    size )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "b [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  \"  ;", "b [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append ( separator )  ;", "buffer . append ( items [ i ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     >    newSize )", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "return   new   ByteArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.ByteArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    length ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . acopy ( a ,    offset ,    items ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "int   i    =     ( size )     -     1  ;", "c [  ]    items    =    this . items ;", "while    ( i    >  =     0  )", "if    (  ( items [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "char [  ]    items 1     =    this . items ;", "char [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( items 1  [ i ]  )     !  =     ( items 2  [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   super . hashCode (  )  ;", "c [  ]    items    =    this . items ;", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     ( items [ i ]  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     +  =    value ;", "}", "METHOD_END"], "methodName": ["incr"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "char [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . acopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     *  =    value ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  -  -  ( size )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    0  ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "char [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    a . size ;    i    <    n ;    i +  +  )     {", "char   item    =    a . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "char [  ]    items    =    this . items ;", "char   value    =    items [ index ]  ;", "( size )  -  -  ;", "if    ( ordered )", "System . acopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "char [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . acopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( items [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    newItems    =    new   char [ newSize ]  ;", "char [  ]    items    =    this . items ;", "System . acopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "char   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( newSize    >     ( items . length )  )", "resize ( Math . max (  8  ,    newSize )  )  ;", "size    =    newSize ;", "return   items ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "char   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( items ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "c [  ]    items    =    this . items ;", "c   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "char [  ]    array    =    new   char [ size ]  ;", "System . arraycopy ( items ,     0  ,    array ,     0  ,    size )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "c [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  \"  ;", "c [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append ( separator )  ;", "buffer . append ( items [ i ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     >    newSize )", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "return   new   CharArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.CharArray"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert    ( lo    <  =    start )     &  &     ( start    <  =    hi )  ;", "if    ( start    =  =    lo )", "start +  +  ;", "for    (  ;    start    <    hi ;    start +  +  )     {", "@ SuppressWarnings (  \" unchecked \"  )", "Comparable < Object >    pivot    =     (  ( Comparable )     ( a [ start ]  )  )  ;", "int   left    =    lo ;", "int   right    =    start ;", "if    ( ComparableTimSort . DEBUG )", "assert   left    <  =    right ;", "while    ( left    <    right )     {", "int   mid    =     ( left    +    right )     >  >  >     1  ;", "if    (  ( pivot . compareTo ( a [ mid ]  )  )     <     0  )", "right    =    mid ;", "else", "left    =    mid    +     1  ;", "}", "if    ( ComparableTimSort . DEBUG )", "assert   left    =  =    right ;", "int   n    =    start    -    left ;", "switch    ( n )     {", "case    2     :", "a [  ( left    +     2  )  ]     =    a [  ( left    +     1  )  ]  ;", "case    1     :", "a [  ( left    +     1  )  ]     =    a [ left ]  ;", "break ;", "default    :", "System . arraycopy ( a ,    left ,    a ,     ( left    +     1  )  ,    n )  ;", "}", "a [ left ]     =    pivot ;", "}", "}", "METHOD_END"], "methodName": ["binarySort"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert   lo    <    hi ;", "int   runHi    =    lo    +     1  ;", "if    ( runHi    =  =    hi )", "return    1  ;", "if    (  (  (  ( Comparable )     ( a [  ( runHi +  +  )  ]  )  )  . compareTo ( a [ lo ]  )  )     <     0  )     {", "while    (  ( runHi    <    hi )     &  &     (  (  (  ( Comparable )     ( a [ runHi ]  )  )  . compareTo ( a [  ( runHi    -     1  )  ]  )  )     <     0  )  )", "runHi +  +  ;", "ComparableTimSort . reverseRange ( a ,    lo ,    runHi )  ;", "} else    {", "while    (  ( runHi    <    hi )     &  &     (  (  (  ( Comparable )     ( a [ runHi ]  )  )  . compareTo ( a [  ( runHi    -     1  )  ]  )  )     >  =     0  )  )", "runHi +  +  ;", "}", "return   runHi    -    lo ;", "}", "METHOD_END"], "methodName": ["countRunAndMakeAscending"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "stackSize    =     0  ;", ". rangeCheck ( a . length ,    lo ,    hi )  ;", "int   nRemaining    =    hi    -    lo ;", "if    ( nRemaining    <     2  )", "return ;", "if    ( nRemaining    <     (  . MIN _ MERGE )  )     {", "int   initRunLen    =     . countRunAndMakeAscending ( a ,    lo ,    hi )  ;", ". binarySort ( a ,    lo ,    hi ,     ( lo    +    initRunLen )  )  ;", "return ;", "}", "this . a    =    a ;", "tmpCount    =     0  ;", "int   minRun    =     . minRunLength ( nRemaining )  ;", "do    {", "int   runLen    =     . countRunAndMakeAscending ( a ,    lo ,    hi )  ;", "if    ( runLen    <    minRun )     {", "int   force    =     ( nRemaining    <  =    minRun )     ?    nRemaining    :    minRun ;", ". binarySort ( a ,    lo ,     ( lo    +    force )  ,     ( lo    +    runLen )  )  ;", "runLen    =    force ;", "}", "pushRun ( lo ,    runLen )  ;", "mergeCollapse (  )  ;", "lo    +  =    runLen ;", "nRemaining    -  =    runLen ;", "}    while    ( nRemaining    !  =     0     )  ;", "if    (  . DEBUG )", "assert   lo    =  =    hi ;", "mergeForceCollapse (  )  ;", "if    (  . DEBUG )", "assert    ( stackSize )     =  =     1  ;", "this . a    =    null ;", "Object [  ]    tmp    =    this . tmp ;", "for    ( int   i    =     0  ,    n    =    tmpCount ;    i    <    n ;    i +  +  )", "tmp [ i ]     =    null ;", "}", "METHOD_END"], "methodName": ["doSort"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "tmpCount    =    Math . max ( tmpCount ,    minCapacity )  ;", "if    (  ( tmp . length )     <    minCapacity )     {", "int   newSize    =    minCapacity ;", "newSize    |  =    newSize    >  >     1  ;", "newSize    |  =    newSize    >  >     2  ;", "newSize    |  =    newSize    >  >     4  ;", "newSize    |  =    newSize    >  >     8  ;", "newSize    |  =    newSize    >  >     1  6  ;", "newSize +  +  ;", "if    ( newSize    <     0  )", "newSize    =    minCapacity ;", "else", "newSize    =    Math . min ( newSize ,     (  ( a . length )     >  >  >     1  )  )  ;", "Object [  ]    newArray    =    new   Object [ newSize ]  ;", "tmp    =    newArray ;", "}", "return   tmp ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert    (  ( len    >     0  )     &  &     ( hint    >  =     0  )  )     &  &     ( hint    <    len )  ;", "int   lastOfs    =     0  ;", "int   ofs    =     1  ;", "if    (  ( key . compareTo ( a [  ( base    +    hint )  ]  )  )     >     0  )     {", "int   maxOfs    =    len    -    hint ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( key . compareTo ( a [  (  ( base    +    hint )     +    ofs )  ]  )  )     >     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "lastOfs    +  =    hint ;", "ofs    +  =    hint ;", "} else    {", "final   int   maxOfs    =    hint    +     1  ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( key . compareTo ( a [  (  ( base    +    hint )     -    ofs )  ]  )  )     <  =     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "int   tmp    =    lastOfs ;", "lastOfs    =    hint    -    ofs ;", "ofs    =    hint    -    tmp ;", "}", "if    ( ComparableTimSort . DEBUG )", "assert    (  (  (  -  1  )     <  =    lastOfs )     &  &     ( lastOfs    <    ofs )  )     &  &     ( ofs    <  =    len )  ;", "lastOfs +  +  ;", "while    ( lastOfs    <    ofs )     {", "int   m    =    lastOfs    +     (  ( ofs    -    lastOfs )     >  >  >     1  )  ;", "if    (  ( key . compareTo ( a [  ( base    +    m )  ]  )  )     >     0  )", "lastOfs    =    m    +     1  ;", "else", "ofs    =    m ;", "}", "if    ( ComparableTimSort . DEBUG )", "assert   lastOfs    =  =    ofs ;", "return   ofs ;", "}", "METHOD_END"], "methodName": ["gallopLeft"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert    (  ( len    >     0  )     &  &     ( hint    >  =     0  )  )     &  &     ( hint    <    len )  ;", "int   ofs    =     1  ;", "int   lastOfs    =     0  ;", "if    (  ( key . compareTo ( a [  ( base    +    hint )  ]  )  )     <     0  )     {", "int   maxOfs    =    hint    +     1  ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( key . compareTo ( a [  (  ( base    +    hint )     -    ofs )  ]  )  )     <     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "int   tmp    =    lastOfs ;", "lastOfs    =    hint    -    ofs ;", "ofs    =    hint    -    tmp ;", "} else    {", "int   maxOfs    =    len    -    hint ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( key . compareTo ( a [  (  ( base    +    hint )     +    ofs )  ]  )  )     >  =     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "lastOfs    +  =    hint ;", "ofs    +  =    hint ;", "}", "if    ( ComparableTimSort . DEBUG )", "assert    (  (  (  -  1  )     <  =    lastOfs )     &  &     ( lastOfs    <    ofs )  )     &  &     ( ofs    <  =    len )  ;", "lastOfs +  +  ;", "while    ( lastOfs    <    ofs )     {", "int   m    =    lastOfs    +     (  ( ofs    -    lastOfs )     >  >  >     1  )  ;", "if    (  ( key . compareTo ( a [  ( base    +    m )  ]  )  )     <     0  )", "ofs    =    m ;", "else", "lastOfs    =    m    +     1  ;", "}", "if    ( ComparableTimSort . DEBUG )", "assert   lastOfs    =  =    ofs ;", "return   ofs ;", "}", "METHOD_END"], "methodName": ["gallopRight"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert    ( stackSize )     >  =     2  ;", "if    ( ComparableTimSort . DEBUG )", "assert   i    >  =     0  ;", "if    ( ComparableTimSort . DEBUG )", "assert    ( i    =  =     (  ( stackSize )     -     2  )  )     |  |     ( i    =  =     (  ( stackSize )     -     3  )  )  ;", "int   base 1     =    runBase [ i ]  ;", "int   len 1     =    runLen [ i ]  ;", "int   base 2     =    runBase [  ( i    +     1  )  ]  ;", "int   len 2     =    runLen [  ( i    +     1  )  ]  ;", "if    ( ComparableTimSort . DEBUG )", "assert    ( len 1     >     0  )     &  &     ( len 2     >     0  )  ;", "if    ( ComparableTimSort . DEBUG )", "assert    ( base 1     +    len 1  )     =  =    base 2  ;", "runLen [ i ]     =    len 1     +    len 2  ;", "if    ( i    =  =     (  ( stackSize )     -     3  )  )     {", "runBase [  ( i    +     1  )  ]     =    runBase [  ( i    +     2  )  ]  ;", "runLen [  ( i    +     1  )  ]     =    runLen [  ( i    +     2  )  ]  ;", "}", "( stackSize )  -  -  ;", "int   k    =    ComparableTimSort . gallopRight (  (  ( Comparable < Object >  )     ( a [ base 2  ]  )  )  ,    a ,    base 1  ,    len 1  ,     0  )  ;", "if    ( ComparableTimSort . DEBUG )", "assert   k    >  =     0  ;", "base 1     +  =    k ;", "len 1     -  =    k ;", "if    ( len 1     =  =     0  )", "return ;", "len 2     =    ComparableTimSort . gallopLeft (  (  ( Comparable < Object >  )     ( a [  (  ( base 1     +    len 1  )     -     1  )  ]  )  )  ,    a ,    base 2  ,    len 2  ,     ( len 2     -     1  )  )  ;", "if    ( ComparableTimSort . DEBUG )", "assert   len 2     >  =     0  ;", "if    ( len 2     =  =     0  )", "return ;", "if    ( len 1     <  =    len 2  )", "mergeLo ( base 1  ,    len 1  ,    base 2  ,    len 2  )  ;", "else", "mergeHi ( base 1  ,    len 1  ,    base 2  ,    len 2  )  ;", "}", "METHOD_END"], "methodName": ["mergeAt"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "while    (  ( stackSize )     >     1  )     {", "int   n    =     ( stackSize )     -     2  ;", "if    (  ( n    >     0  )     &  &     (  ( runLen [  ( n    -     1  )  ]  )     <  =     (  ( runLen [ n ]  )     +     ( runLen [  ( n    +     1  )  ]  )  )  )  )     {", "if    (  ( runLen [  ( n    -     1  )  ]  )     <     ( runLen [  ( n    +     1  )  ]  )  )", "n -  -  ;", "mergeAt ( n )  ;", "} else", "if    (  ( runLen [ n ]  )     <  =     ( runLen [  ( n    +     1  )  ]  )  )     {", "mergeAt ( n )  ;", "} else    {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["mergeCollapse"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "while    (  ( stackSize )     >     1  )     {", "int   n    =     ( stackSize )     -     2  ;", "if    (  ( n    >     0  )     &  &     (  ( runLen [  ( n    -     1  )  ]  )     <     ( runLen [  ( n    +     1  )  ]  )  )  )", "n -  -  ;", "mergeAt ( n )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeForceCollapse"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert    (  ( len 1     >     0  )     &  &     ( len 2     >     0  )  )     &  &     (  ( base 1     +    len 1  )     =  =    base 2  )  ;", "Object [  ]    a    =    this . a ;", "Object [  ]    tmp    =    ensureCapacity ( len 2  )  ;", "System . arraycopy ( a ,    base 2  ,    tmp ,     0  ,    len 2  )  ;", "int   cursor 1     =     ( base 1     +    len 1  )     -     1  ;", "int   cursor 2     =    len 2     -     1  ;", "int   dest    =     ( base 2     +    len 2  )     -     1  ;", "a [  ( dest -  -  )  ]     =    a [  ( cursor 1  -  -  )  ]  ;", "if    (  (  -  - len 1  )     =  =     0  )     {", "System . arraycopy ( tmp ,     0  ,    a ,     ( dest    -     ( len 2     -     1  )  )  ,    len 2  )  ;", "return ;", "}", "if    ( len 2     =  =     1  )     {", "dest    -  =    len 1  ;", "cursor 1     -  =    len 1  ;", "System . arraycopy ( a ,     ( cursor 1     +     1  )  ,    a ,     ( dest    +     1  )  ,    len 1  )  ;", "a [ dest ]     =    tmp [ cursor 2  ]  ;", "return ;", "}", "int   minGallop    =    this . minGallop ;", "outer    :    while    ( true )     {", "int   count 1     =     0  ;", "int   count 2     =     0  ;", "do    {", "if    ( ComparableTimSort . DEBUG )", "assert    ( len 1     >     0  )     &  &     ( len 2     >     1  )  ;", "if    (  (  (  ( Comparable )     ( tmp [ cursor 2  ]  )  )  . compareTo ( a [ cursor 1  ]  )  )     <     0  )     {", "a [  ( dest -  -  )  ]     =    a [  ( cursor 1  -  -  )  ]  ;", "count 1  +  +  ;", "count 2     =     0  ;", "if    (  (  -  - len 1  )     =  =     0  )", "break   outer ;", "} else    {", "a [  ( dest -  -  )  ]     =    tmp [  ( cursor 2  -  -  )  ]  ;", "count 2  +  +  ;", "count 1     =     0  ;", "if    (  (  -  - len 2  )     =  =     1  )", "break   outer ;", "}", "}    while    (  ( count 1     |    count 2  )     <    minGallop    )  ;", "do    {", "if    ( ComparableTimSort . DEBUG )", "assert    ( len 1     >     0  )     &  &     ( len 2     >     1  )  ;", "count 1     =    len 1     -     ( ComparableTimSort . gallopRight (  (  ( Comparable )     ( tmp [ cursor 2  ]  )  )  ,    a ,    base 1  ,    len 1  ,     ( len 1     -     1  )  )  )  ;", "if    ( count 1     !  =     0  )     {", "dest    -  =    count 1  ;", "cursor 1     -  =    count 1  ;", "len 1     -  =    count 1  ;", "System . arraycopy ( a ,     ( cursor 1     +     1  )  ,    a ,     ( dest    +     1  )  ,    count 1  )  ;", "if    ( len 1     =  =     0  )", "break   outer ;", "}", "a [  ( dest -  -  )  ]     =    tmp [  ( cursor 2  -  -  )  ]  ;", "if    (  (  -  - len 2  )     =  =     1  )", "break   outer ;", "count 2     =    len 2     -     ( ComparableTimSort . gallopLeft (  (  ( Comparable )     ( a [ cursor 1  ]  )  )  ,    tmp ,     0  ,    len 2  ,     ( len 2     -     1  )  )  )  ;", "if    ( count 2     !  =     0  )     {", "dest    -  =    count 2  ;", "cursor 2     -  =    count 2  ;", "len 2     -  =    count 2  ;", "System . arraycopy ( tmp ,     ( cursor 2     +     1  )  ,    a ,     ( dest    +     1  )  ,    count 2  )  ;", "if    ( len 2     <  =     1  )", "break   outer ;", "}", "a [  ( dest -  -  )  ]     =    a [  ( cursor 1  -  -  )  ]  ;", "if    (  (  -  - len 1  )     =  =     0  )", "break   outer ;", "minGallop -  -  ;", "}    while    (  ( count 1     >  =     ( ComparableTimSort . MIN _ GALLOP )  )     |     ( count 2     >  =     ( ComparableTimSort . MIN _ GALLOP )  )     )  ;", "if    ( minGallop    <     0  )", "minGallop    =     0  ;", "minGallop    +  =     2  ;", "}", "this . minGallop    =     ( minGallop    <     1  )     ?     1     :    minGallop ;", "if    ( len 2     =  =     1  )     {", "if    ( ComparableTimSort . DEBUG )", "assert   len 1     >     0  ;", "dest    -  =    len 1  ;", "cursor 1     -  =    len 1  ;", "System . arraycopy ( a ,     ( cursor 1     +     1  )  ,    a ,     ( dest    +     1  )  ,    len 1  )  ;", "a [ dest ]     =    tmp [ cursor 2  ]  ;", "} else", "if    ( len 2     =  =     0  )     {", "throw   new   IllegalArgumentException (  \" Comparison   method   violates   its   general   contract !  \"  )  ;", "} else    {", "if    ( ComparableTimSort . DEBUG )", "assert   len 1     =  =     0  ;", "if    ( ComparableTimSort . DEBUG )", "assert   len 2     >     0  ;", "System . arraycopy ( tmp ,     0  ,    a ,     ( dest    -     ( len 2     -     1  )  )  ,    len 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeHi"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert    (  ( len 1     >     0  )     &  &     ( len 2     >     0  )  )     &  &     (  ( base 1     +    len 1  )     =  =    base 2  )  ;", "Object [  ]    a    =    this . a ;", "Object [  ]    tmp    =    ensureCapacity ( len 1  )  ;", "System . arraycopy ( a ,    base 1  ,    tmp ,     0  ,    len 1  )  ;", "int   cursor 1     =     0  ;", "int   cursor 2     =    base 2  ;", "int   dest    =    base 1  ;", "a [  ( dest +  +  )  ]     =    a [  ( cursor 2  +  +  )  ]  ;", "if    (  (  -  - len 2  )     =  =     0  )     {", "System . arraycopy ( tmp ,    cursor 1  ,    a ,    dest ,    len 1  )  ;", "return ;", "}", "if    ( len 1     =  =     1  )     {", "System . arraycopy ( a ,    cursor 2  ,    a ,    dest ,    len 2  )  ;", "a [  ( dest    +    len 2  )  ]     =    tmp [ cursor 1  ]  ;", "return ;", "}", "int   minGallop    =    this . minGallop ;", "outer    :    while    ( true )     {", "int   count 1     =     0  ;", "int   count 2     =     0  ;", "do    {", "if    ( ComparableTimSort . DEBUG )", "assert    ( len 1     >     1  )     &  &     ( len 2     >     0  )  ;", "if    (  (  (  ( Comparable )     ( a [ cursor 2  ]  )  )  . compareTo ( tmp [ cursor 1  ]  )  )     <     0  )     {", "a [  ( dest +  +  )  ]     =    a [  ( cursor 2  +  +  )  ]  ;", "count 2  +  +  ;", "count 1     =     0  ;", "if    (  (  -  - len 2  )     =  =     0  )", "break   outer ;", "} else    {", "a [  ( dest +  +  )  ]     =    tmp [  ( cursor 1  +  +  )  ]  ;", "count 1  +  +  ;", "count 2     =     0  ;", "if    (  (  -  - len 1  )     =  =     1  )", "break   outer ;", "}", "}    while    (  ( count 1     |    count 2  )     <    minGallop    )  ;", "do    {", "if    ( ComparableTimSort . DEBUG )", "assert    ( len 1     >     1  )     &  &     ( len 2     >     0  )  ;", "count 1     =    ComparableTimSort . gallopRight (  (  ( Comparable )     ( a [ cursor 2  ]  )  )  ,    tmp ,    cursor 1  ,    len 1  ,     0  )  ;", "if    ( count 1     !  =     0  )     {", "System . arraycopy ( tmp ,    cursor 1  ,    a ,    dest ,    count 1  )  ;", "dest    +  =    count 1  ;", "cursor 1     +  =    count 1  ;", "len 1     -  =    count 1  ;", "if    ( len 1     <  =     1  )", "break   outer ;", "}", "a [  ( dest +  +  )  ]     =    a [  ( cursor 2  +  +  )  ]  ;", "if    (  (  -  - len 2  )     =  =     0  )", "break   outer ;", "count 2     =    ComparableTimSort . gallopLeft (  (  ( Comparable )     ( tmp [ cursor 1  ]  )  )  ,    a ,    cursor 2  ,    len 2  ,     0  )  ;", "if    ( count 2     !  =     0  )     {", "System . arraycopy ( a ,    cursor 2  ,    a ,    dest ,    count 2  )  ;", "dest    +  =    count 2  ;", "cursor 2     +  =    count 2  ;", "len 2     -  =    count 2  ;", "if    ( len 2     =  =     0  )", "break   outer ;", "}", "a [  ( dest +  +  )  ]     =    tmp [  ( cursor 1  +  +  )  ]  ;", "if    (  (  -  - len 1  )     =  =     1  )", "break   outer ;", "minGallop -  -  ;", "}    while    (  ( count 1     >  =     ( ComparableTimSort . MIN _ GALLOP )  )     |     ( count 2     >  =     ( ComparableTimSort . MIN _ GALLOP )  )     )  ;", "if    ( minGallop    <     0  )", "minGallop    =     0  ;", "minGallop    +  =     2  ;", "}", "this . minGallop    =     ( minGallop    <     1  )     ?     1     :    minGallop ;", "if    ( len 1     =  =     1  )     {", "if    ( ComparableTimSort . DEBUG )", "assert   len 2     >     0  ;", "System . arraycopy ( a ,    cursor 2  ,    a ,    dest ,    len 2  )  ;", "a [  ( dest    +    len 2  )  ]     =    tmp [ cursor 1  ]  ;", "} else", "if    ( len 1     =  =     0  )     {", "throw   new   IllegalArgumentException (  \" Comparison   method   violates   its   general   contract !  \"  )  ;", "} else    {", "if    ( ComparableTimSort . DEBUG )", "assert   len 2     =  =     0  ;", "if    ( ComparableTimSort . DEBUG )", "assert   len 1     >     1  ;", "System . arraycopy ( tmp ,    cursor 1  ,    a ,    dest ,    len 1  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeLo"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( ComparableTimSort . DEBUG )", "assert   n    >  =     0  ;", "int   r    =     0  ;", "while    ( n    >  =     ( ComparableTimSort . MIN _ MERGE )  )     {", "r    |  =    n    &     1  ;", "n    >  >  =     1  ;", "}", "return   n    +    r ;", "}", "METHOD_END"], "methodName": ["minRunLength"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "this . runBase [ stackSize ]     =    runBase ;", "this . runLen [ stackSize ]     =    runLen ;", "( stackSize )  +  +  ;", "}", "METHOD_END"], "methodName": ["pushRun"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( fromIndex    >    toIndex )", "throw   new   IllegalArgumentException (  (  (  (  (  \" fromIndex (  \"     +    fromIndex )     +     \"  )     >    toIndex (  \"  )     +    toIndex )     +     \"  )  \"  )  )  ;", "if    ( fromIndex    <     0  )", "throw   new   ArrayIndexOutOfBoundsException ( fromIndex )  ;", "if    ( toIndex    >    arrayLen )", "throw   new   ArrayIndexOutOfBoundsException ( toIndex )  ;", "}", "METHOD_END"], "methodName": ["rangeCheck"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "hi -  -  ;", "whe    ( lo    <    hi )     {", "Object   t    =    a [ lo ]  ;", "a [  ( lo +  +  )  ]     =    a [ hi ]  ;", "a [  ( hi -  -  )  ]     =    t ;", "}", "}", "METHOD_END"], "methodName": ["reverseRange"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "ComparableTimSort . sort ( a ,     0  ,    a . length )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "ComparableTimSort . rangeCheck ( a . length ,    lo ,    hi )  ;", "int   nRemaining    =    hi    -    lo ;", "if    ( nRemaining    <     2  )", "return ;", "if    ( nRemaining    <     ( ComparableTimSort . MIN _ MERGE )  )     {", "int   initRunLen    =    ComparableTimSort . countRunAndMakeAscending ( a ,    lo ,    hi )  ;", "ComparableTimSort . binarySort ( a ,    lo ,    hi ,     ( lo    +    initRunLen )  )  ;", "return ;", "}", "ComparableTimSort   ts    =    new   ComparableTimSort ( a )  ;", "int   minRun    =    ComparableTimSort . minRunLength ( nRemaining )  ;", "do    {", "int   runLen    =    ComparableTimSort . countRunAndMakeAscending ( a ,    lo ,    hi )  ;", "if    ( runLen    <    minRun )     {", "int   force    =     ( nRemaining    <  =    minRun )     ?    nRemaining    :    minRun ;", "ComparableTimSort . binarySort ( a ,    lo ,     ( lo    +    force )  ,     ( lo    +    runLen )  )  ;", "runLen    =    force ;", "}", "ts . pushRun ( lo ,    runLen )  ;", "ts . mergeCollapse (  )  ;", "lo    +  =    runLen ;", "nRemaining    -  =    runLen ;", "}    while    ( nRemaining    !  =     0     )  ;", "if    ( ComparableTimSort . DEBUG )", "assert   lo    =  =    hi ;", "ts . mergeForceCollapse (  )  ;", "if    ( ComparableTimSort . DEBUG )", "assert    ( ts . stackSize )     =  =     1  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.ComparableTimSort"}, {"methodBody": ["METHOD_START", "{", "return   outStream . getBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getBuffer"], "fileName": "com.badlogic.gdx.utils.DataBuffer"}, {"methodBody": ["METHOD_START", "{", "return   outStream . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.DataBuffer"}, {"methodBody": ["METHOD_START", "{", "int   b    =    read (  )  ;", "int   result    =    b    &     1  2  7  ;", "if    (  ( b    &     1  2  8  )     !  =     0  )     {", "b    =    read (  )  ;", "result    |  =     ( b    &     1  2  7  )     <  <     7  ;", "if    (  ( b    &     1  2  8  )     !  =     0  )     {", "b    =    read (  )  ;", "result    |  =     ( b    &     1  2  7  )     <  <     1  4  ;", "if    (  ( b    &     1  2  8  )     !  =     0  )     {", "b    =    read (  )  ;", "result    |  =     ( b    &     1  2  7  )     <  <     2  1  ;", "if    (  ( b    &     1  2  8  )     !  =     0  )     {", "b    =    read (  )  ;", "result    |  =     ( b    &     1  2  7  )     <  <     2  8  ;", "}", "}", "}", "}", "return   optimizePositive    ?    result    :     ( result    >  >  >     1  )     ^     (  -  ( result    &     1  )  )  ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "com.badlogic.gdx.utils.DataInput"}, {"methodBody": ["METHOD_START", "{", "int   charCount    =    readInt ( true )  ;", "switch    ( charCount )     {", "case    0     :", "return   null ;", "case    1     :", "return    \"  \"  ;", "}", "charCount -  -  ;", "if    (  ( chars . length )     <    charCount )", "chars    =    new   char [ charCount ]  ;", "char [  ]    chars    =    this . chars ;", "int   charIndex    =     0  ;", "int   b    =     0  ;", "while    ( charIndex    <    charCount )     {", "b    =    read (  )  ;", "if    ( b    >     1  2  7  )", "break ;", "chars [  ( charIndex +  +  )  ]     =     (  ( char )     ( b )  )  ;", "}", "if    ( charIndex    <    charCount )", "readUtf 8  _ slow ( charCount ,    charIndex ,    b )  ;", "return   new   String ( chars ,     0  ,    charCount )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.utils.DataInput"}, {"methodBody": ["METHOD_START", "{", "char [  ]    chars    =    this . chars ;", "while    ( true )     {", "switch    ( b    >  >     4  )     {", "case    0     :", "case    1     :", "case    2     :", "case    3     :", "case    4     :", "case    5     :", "case    6     :", "case    7     :", "chars [ charIndex ]     =     (  ( char )     ( b )  )  ;", "break ;", "case    1  2     :", "case    1  3     :", "chars [ charIndex ]     =     (  ( char )     (  (  ( b    &     3  1  )     <  <     6  )     |     (  ( read (  )  )     &     6  3  )  )  )  ;", "break ;", "case    1  4     :", "chars [ charIndex ]     =     (  ( char )     (  (  (  ( b    &     1  5  )     <  <     1  2  )     |     (  (  ( read (  )  )     &     6  3  )     <  <     6  )  )     |     (  ( read (  )  )     &     6  3  )  )  )  ;", "break ;", "}", "if    (  (  +  + charIndex )     >  =    charCount )", "break ;", "b    =     ( read (  )  )     &     2  5  5  ;", "}", "}", "METHOD_END"], "methodName": ["readUtf8_slow"], "fileName": "com.badlogic.gdx.utils.DataInput"}, {"methodBody": ["METHOD_START", "{", "if    (  ! optimizePositive )", "value    =     ( value    <  <     1  )     ^     ( value    >  >     3  1  )  ;", "if    (  ( value    >  >  >     7  )     =  =     0  )     {", "write (  (  ( byte )     ( value )  )  )  ;", "return    1  ;", "}", "write (  (  ( byte )     (  ( value    &     1  2  7  )     |     1  2  8  )  )  )  ;", "if    (  ( value    >  >  >     1  4  )     =  =     0  )     {", "write (  (  ( byte )     ( value    >  >  >     7  )  )  )  ;", "return    2  ;", "}", "write (  (  ( byte )     (  ( value    >  >  >     7  )     |     1  2  8  )  )  )  ;", "if    (  ( value    >  >  >     2  1  )     =  =     0  )     {", "write (  (  ( byte )     ( value    >  >  >     1  4  )  )  )  ;", "return    3  ;", "}", "write (  (  ( byte )     (  ( value    >  >  >     1  4  )     |     1  2  8  )  )  )  ;", "if    (  ( value    >  >  >     2  8  )     =  =     0  )     {", "write (  (  ( byte )     ( value    >  >  >     2  1  )  )  )  ;", "return    4  ;", "}", "write (  (  ( byte )     (  ( value    >  >  >     2  1  )     |     1  2  8  )  )  )  ;", "write (  (  ( byte )     ( value    >  >  >     2  8  )  )  )  ;", "return    5  ;", "}", "METHOD_END"], "methodName": ["writeInt"], "fileName": "com.badlogic.gdx.utils.DataOutput"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "write (  0  )  ;", "return ;", "}", "int   charCount    =    value . length (  )  ;", "if    ( charCount    =  =     0  )     {", "writeByte (  1  )  ;", "return ;", "}", "writeInt (  ( charCount    +     1  )  ,    true )  ;", "int   charIndex    =     0  ;", "for    (  ;    charIndex    <    charCount ;    charIndex +  +  )     {", "int   c    =    value . charAt ( charIndex )  ;", "if    ( c    >     1  2  7  )", "break ;", "write (  (  ( byte )     ( c )  )  )  ;", "}", "if    ( charIndex    <    charCount )", "writeString _ sw ( value ,    charCount ,    charIndex )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.utils.DataOutput"}, {"methodBody": ["METHOD_START", "{", "for    (  ;    charIndex    <    charCount ;    charIndex +  +  )     {", "int   c    =    value . charAt ( charIndex )  ;", "if    ( c    <  =     1  2  7  )     {", "write (  (  ( byte )     ( c )  )  )  ;", "} ee", "if    ( c    >     2  0  4  7  )     {", "write (  (  ( byte )     (  2  2  4     |     (  ( c    >  >     1  2  )     &     1  5  )  )  )  )  ;", "write (  (  ( byte )     (  1  2  8     |     (  ( c    >  >     6  )     &     6  3  )  )  )  )  ;", "write (  (  ( byte )     (  1  2  8     |     ( c    &     6  3  )  )  )  )  ;", "} ee    {", "write (  (  ( byte )     (  1  9  2     |     (  ( c    >  >     6  )     &     3  1  )  )  )  )  ;", "write (  (  ( byte )     (  1  2  8     |     ( c    &     6  3  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeString_slow"], "fileName": "com.badlogic.gdx.utils.DataOutput"}, {"methodBody": ["METHOD_START", "{", "( iterating )  +  +  ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )     {", "clear    =    size ;", "return ;", "}", "super . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     =  =     0  )", "throw   new   IllegalStateException (  \" begin   must   be   called   before   end .  \"  )  ;", "( iterating )  -  -  ;", "if    (  ( iterating )     =  =     0  )     {", "if    (  (  ( clear )     >     0  )     &  &     (  ( clear )     =  =     ( size )  )  )     {", "re . clear (  )  ;", "clear (  )  ;", "} else    {", "for    ( int   i    =     0  ,    n    =    re . size ;    i    <    n ;    i +  +  )     {", "int   index    =    re . pop (  )  ;", "if    ( index    >  =     ( clear )  )", "reIndex ( index )  ;", "}", "for    ( int   i    =     ( clear )     -     1  ;    i    >  =     0  ;    i -  -  )", "reIndex ( i )  ;", "}", "clear    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . insert ( index ,    ue )  ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "return   super . pop (  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    <     ( clear )  )", "return ;", "for    ( int   i    =     0  ,    n    =    re . size ;    i    <    n ;    i +  +  )     {", "int   reIndex    =    re . get ( i )  ;", "if    ( index    =  =    reIndex )", "return ;", "if    ( index    <    reIndex )     {", "re . insert ( i ,    index )  ;", "return ;", "}", "}", "re . add ( index )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )     {", "re ( index )  ;", "return   get ( index )  ;", "}", "return   super . reIndex ( index )  ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )     {", "for    ( int   i    =    end ;    i    >  =    start ;    i -  -  )", "re ( i )  ;", "} else", "super . reRange ( start ,    end )  ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )     {", "int   index    =    indexOf ( value ,    identity )  ;", "if    ( index    =  =     (  -  1  )  )", "return   false ;", "re ( index )  ;", "return   true ;", "}", "return   super . reValue ( value ,    identity )  ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . reverse (  )  ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . set ( index ,    ue )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "return   super . setSize ( newSize )  ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . shuffle (  )  ;", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . sort (  )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . sort ( comparator )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . swap ( first ,    second )  ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterating )     >     0  )", "throw   new   IllegalStateException (  \" Inid   between   begin / end .  \"  )  ;", "super . truncate ( newSize )  ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "return   new   DelayedRemovalArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.DelayedRemovalArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    length ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . arraycopy ( array ,    offset ,    items ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "int   i    =     ( size )     -     1  ;", "f [  ]    items    =    this . items ;", "while    ( i    >  =     0  )", "if    (  ( items [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "float [  ]    items 1     =    this . items ;", "float [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( items 1  [ i ]  )     !  =     ( items 2  [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( array . ordered )  )", "return   false ;", "float [  ]    items 1     =    this . items ;", "float [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( Math . abs (  (  ( items 1  [ i ]  )     -     ( items 2  [ i ]  )  )  )  )     >    epsilon )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   super . hashCode (  )  ;", "float [  ]    items    =    this . items ;", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     (  . floatToIntBits ( items [ i ]  )  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     +  =    value ;", "}", "METHOD_END"], "methodName": ["incr"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "f [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . arraycopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     *  =    value ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  -  -  ( size )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    0  ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "f [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    array . size ;    i    <    n ;    i +  +  )     {", "f   item    =    array . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "f [  ]    items    =    this . items ;", "f   value    =    items [ index ]  ;", "( size )  -  -  ;", "if    ( ordered )", "System . arraycopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "f [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . arraycopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( items [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    newItems    =    new   float [ newSize ]  ;", "float [  ]    items    =    this . items ;", "System . arraycopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "float   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( newSize    >     ( items . length )  )", "resize ( Math . max (  8  ,    newSize )  )  ;", "size    =    newSize ;", "return   items ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "float   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( items ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "f [  ]    items    =    this . items ;", "f   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "float [  ]    array    =    new   float [ size ]  ;", "System . arraycopy ( items ,     0  ,    array ,     0  ,    size )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "f [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  \"  ;", "f [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append ( separator )  ;", "buffer . append ( items [ i ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     >    newSize )", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "return   new   FloatArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.FloatArray"}, {"methodBody": ["METHOD_START", "{", "super . freeAll ( obtained )  ;", "obtained . car (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.utils.FlushablePool"}, {"methodBody": ["METHOD_START", "{", "String   JNI _ DIR    =     \" jni \"  ;", "String   LIBS _ DIR    =     \" libs \"  ;", "new   NativeCodeGenerator (  )  . generate (  \" src \"  ,     \" bin \"  ,    JNI _ DIR ,    new   String [  ]  {     \"  *  *  /  *  \"     }  ,    null )  ;", "String [  ]    excludeCpp    =    new   String [  ]  {     \" android /  *  *  \"  ,     \" iosgl /  *  *  \"     }  ;", "Target   win 3  2 home    =    Target . newDefaultTarget ( Windows ,    false )  ;", "win 3  2 home . compilerPrefix    =     \"  \"  ;", "win 3  2 home . buildFileName    =     \" build - windows 3  2 home . xml \"  ;", "win 3  2 home . excludeFromMasterFile    =    true ;", "win 3  2 home . cppExcludes    =    excludeCpp ;", "Target   win 3  2     =    Target . newDefaultTarget ( Windows ,    false )  ;", "win 3  2  . cppExcludes    =    excludeCpp ;", "Target   win 6  4     =    Target . newDefaultTarget ( Windows ,    true )  ;", "win 6  4  . cppExcludes    =    excludeCpp ;", "Target   lin 3  2     =    Target . newDefaultTarget ( Linux ,    false )  ;", "lin 3  2  . cppExcludes    =    excludeCpp ;", "Target   lin 6  4     =    Target . newDefaultTarget ( Linux ,    true )  ;", "lin 6  4  . cppExcludes    =    excludeCpp ;", "Target   android    =    Target . newDefaultTarget ( Android ,    false )  ;", "android . linkerFlags    +  =     \"     - lGLESv 2     - llog \"  ;", "android . cppExcludes    =    new   String [  ]  {     \" iosgl /  *  *  \"     }  ;", "Target   mac    =    Target . newDefaultTarget ( MacOsX ,    false )  ;", "mac . cppExcludes    =    excludeCpp ;", "Target   mac 6  4     =    Target . newDefaultTarget ( MacOsX ,    true )  ;", "mac 6  4  . cppExcludes    =    excludeCpp ;", "Target   ios    =    Target . newDefaultTarget ( IOS ,    false )  ;", "ios . cppExcludes    =    new   String [  ]  {     \" android /  *  *  \"     }  ;", "ios . headerDirs    =    new   String [  ]  {     \" iosgl \"     }  ;", "new   AntScriptGenerator (  )  . generate ( new   Config (  \" gdx \"  ,     \"  .  .  / target / native \"  ,    LIBS _ DIR ,    JNI _ DIR )  ,    mac ,    mac 6  4  ,    win 3  2 home ,    win 3  2  ,    win 6  4  ,    lin 3  2  ,    lin 6  4  ,    android ,    ios )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.badlogic.gdx.utils.GdxBuild"}, {"methodBody": ["METHOD_START", "{", "if    ( GdxNativesLoader . nativesLoaded )", "return ;", "GdxNativesLoader . nativesLoaded    =    true ;", "if    ( GdxNativesLoader . disableNativesLoading )", "return ;", "new   SharedLibraryLoader (  )  . load (  \" gdx \"  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.utils.GdxNativesLoader"}, {"methodBody": ["METHOD_START", "{", "try    {", "fh . re (  )  . close (  )  ;", "return   true ;", "}    catch    ( Exception   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["checkFileExistence"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   I 1  8 NBundle . createBundleImpl ( baseFileHandle ,    Locale . getDefault (  )  ,    I 1  8 NBundle . DEFAULT _ ENCODING )  ;", "}", "METHOD_END"], "methodName": ["createBundle"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   I 1  8 NBundle . createBundleImpl ( baseFileHandle ,    Locale . getDefault (  )  ,    encoding )  ;", "}", "METHOD_END"], "methodName": ["createBundle"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   I 1  8 NBundle . createBundleImpl ( baseFileHandle ,    locale ,    I 1  8 NBundle . DEFAULT _ ENCODING )  ;", "}", "METHOD_END"], "methodName": ["createBundle"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   I 1  8 NBundle . createBundleImpl ( baseFileHandle ,    locale ,    encoding )  ;", "}", "METHOD_END"], "methodName": ["createBundle"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( baseFileHandle    =  =    null )     |  |     ( locale    =  =    null )  )     |  |     ( encoding    =  =    null )  )", "throw   new   NullPointerException (  )  ;", "bundle    =    null ;", "baseBundle    =    null ;", "Locale   targetLocale    =    locale ;", "do    {", "List < Locale >    candidateLocales    =     . getCandidateLocales ( targetLocale )  ;", "bundle    =     . loadBundleChain ( baseFileHandle ,    encoding ,    candidateLocales ,     0  ,    baseBundle )  ;", "if    ( bundle    !  =    null )     {", "Locale   bundleLocale    =    bundle . getLocale (  )  ;", "boolean   isBaseBundle    =    bundleLocale . equals (  . ROOT _ LOCALE )  ;", "if    (  (  ! isBaseBundle )     |  |     ( bundleLocale . equals ( locale )  )  )     {", "break ;", "}", "if    (  (  ( candidateLocales . size (  )  )     =  =     1  )     &  &     ( bundleLocale . equals ( candidateLocales . get (  0  )  )  )  )     {", "break ;", "}", "if    ( isBaseBundle    &  &     ( baseBundle    =  =    null )  )     {", "baseBundle    =    bundle ;", "}", "}", "targetLocale    =     . getFallbackLocale ( targetLocale )  ;", "}    while    ( targetLocale    !  =    null    )  ;", "if    ( bundle    =  =    null )     {", "if    ( baseBundle    =  =    null )     {", "throw   new   MissingResourceException (  (  (  (  \" Can ' t   find   bundle   for   base   file   handle    \"     +     ( baseFileHandle . path (  )  )  )     +     \"  ,    locale    \"  )     +    locale )  ,     (  ( baseFileHandle    +     \"  _  \"  )     +    locale )  ,     \"  \"  )  ;", "}", "bundle    =    baseBundle ;", "}", "return   bundle ;", "}", "METHOD_END"], "methodName": ["createBundleImpl"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   formatter . format ( get ( key )  ,    args )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "String   result    =    properties . get ( key )  ;", "if    ( result    =  =    null )     {", "if    (  ( parent )     !  =    null )", "result    =    parent . get ( key )  ;", "if    ( result    =  =    null )     {", "if    (  . exceptionOnMissingKey )", "throw   new   MissingResourceException (  (  \" Can ' t   find   bundle   key    \"     +    key )  ,    this . getClass (  )  . getName (  )  ,    key )  ;", "else", "return    (  \"  ?  ?  ?  \"     +    key )     +     \"  ?  ?  ?  \"  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "String   language    =    locale . getLanguage (  )  ;", "String   country    =    locale . getCountry (  )  ;", "String   variant    =    locale . getVariant (  )  ;", "List < Locale >    locales    =    new   ArrayList < Locale >  (  4  )  ;", "if    (  ( variant . length (  )  )     >     0  )     {", "locales . add ( locale )  ;", "}", "if    (  ( country . length (  )  )     >     0  )     {", "locales . add (  (  ( locales . size (  )  )     =  =     0     ?    locale    :    new   Locale ( language ,    country )  )  )  ;", "}", "if    (  ( language . length (  )  )     >     0  )     {", "locales . add (  (  ( locales . size (  )  )     =  =     0     ?    locale    :    new   Locale ( language )  )  )  ;", "}", "locales . add (  . ROOT _ LOCALE )  ;", "return   locales ;", "}", "METHOD_END"], "methodName": ["getCandidateLocales"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   I 1  8 NBundle . exceptionOnMissingKey ;", "}", "METHOD_END"], "methodName": ["getExceptionOnMissingKey"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "Locale   defaultLocale    =    Locale . getDefault (  )  ;", "return   locale . equals ( defaultLocale )     ?    null    :    defaultLocale ;", "}", "METHOD_END"], "methodName": ["getFallbackLocale"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   locale ;", "}", "METHOD_END"], "methodName": ["getLocale"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "return   I 1  8 NBundle . simpleFormatter ;", "}", "METHOD_END"], "methodName": ["getSimpleFormatter"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "properties    =    new   ObjectMap < String ,    String >  (  )  ;", "PropertiesUload ( properties ,    reader )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "I 1  8 NBundle   bundle    =    null ;", "Reader   reader    =    null ;", "try    {", "FileHandle   fileHandle    =    I 1  8 NBundle . toFileHandle ( baseFileHandle ,    targetLocale )  ;", "if    ( I 1  8 NBundle . checkFileExistence ( fileHandle )  )     {", "bundle    =    new   I 1  8 NBundle (  )  ;", "reader    =    fileHandle . reader ( encoding )  ;", "bundle . load ( reader )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   GdxRuntimeException ( e )  ;", "}    finally    {", "StreamUtils . closeQuietly ( reader )  ;", "}", "if    ( bundle    !  =    null )     {", "bundle . setLocale ( targetLocale )  ;", "}", "return   bundle ;", "}", "METHOD_END"], "methodName": ["loadBundle"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "Locale   targetLocale    =    candidateLocales . get ( candidateIndex )  ;", "parent    =    null ;", "if    ( candidateIndex    !  =     (  ( candidateLocales . size (  )  )     -     1  )  )     {", "parent    =     . loadBundleChain ( baseFileHandle ,    encoding ,    candidateLocales ,     ( candidateIndex    +     1  )  ,    baseBundle )  ;", "} else", "if    (  ( baseBundle    !  =    null )     &  &     ( targetLocale . equals (  . ROOT _ LOCALE )  )  )     {", "return   baseBundle ;", "}", "bundle    =     . loadBundle ( baseFileHandle ,    encoding ,    targetLocale )  ;", "if    ( bundle    !  =    null )     {", "bundle . parent    =    parent ;", "return   bundle ;", "}", "return   parent ;", "}", "METHOD_END"], "methodName": ["loadBundleChain"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "I 1  8 NBundle . exceptionOnMissingKey    =    enabled ;", "}", "METHOD_END"], "methodName": ["setExceptionOnMissingKey"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "this . locale    =    locale ;", "this . formatter    =    new   TextFormatter ( locale ,     (  !  (  . simpleFormatter )  )  )  ;", "}", "METHOD_END"], "methodName": ["setLocale"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "I 1  8 NBundle . simpleFormatter    =    enabled ;", "}", "METHOD_END"], "methodName": ["setSimpleFormatter"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( baseFileHandle . name (  )  )  ;", "if    (  !  ( locale . equals (  . ROOT _ LOCALE )  )  )     {", "String   language    =    locale . getLanguage (  )  ;", "String   country    =    locale . getCountry (  )  ;", "String   variant    =    locale . getVariant (  )  ;", "boolean   emptyLanguage    =     \"  \"  . equals ( language )  ;", "boolean   emptyCountry    =     \"  \"  . equals ( country )  ;", "boolean   emptyVariant    =     \"  \"  . equals ( variant )  ;", "if    (  !  (  ( emptyLanguage    &  &    emptyCountry )     &  &    emptyVariant )  )     {", "sb . append (  '  _  '  )  ;", "if    (  ! emptyVariant )     {", "sb . append ( language )  . append (  '  _  '  )  . append ( country )  . append (  '  _  '  )  . append ( variant )  ;", "} else", "if    (  ! emptyCountry )     {", "sb . append ( language )  . append (  '  _  '  )  . append ( country )  ;", "} else    {", "sb . append ( language )  ;", "}", "}", "}", "return   baseFileHandle . sibling ( sb . append (  \"  . properties \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toFileHandle"], "fileName": "com.badlogic.gdx.utils.I18NBundle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return ;", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capac )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )     {", "keyTable [ i ]     =    null ;", "valueTable [ i ]     =    null ;", "}", "size    =     0  ;", "stashSize    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    System . identityHashCode ( key )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )", "return   containsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capac ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   true ;", "} else", "if    ( i )     {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   true ;", "} else    {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "< K ,    V >    other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "V   value    =    valueTable [ i ]  ;", "if    ( value    =  =    null )     {", "if    (  (  !  ( other . containsKey ( key )  )  )     |  |     (  ( other . get ( key )  )     !  =    null )  )     {", "return   false ;", "}", "} else    {", "if    (  !  ( value . equals ( other . get ( key )  )  )  )     {", "return   false ;", "}", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   keyTable [ i ]  ;", "} else", "if    ( i )     {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   keyTable [ i ]  ;", "} else    {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   keyTable [ i ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    System . identityHashCode ( key )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )", "return   getStash ( key ,    null )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    System . identityHashCode ( key )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capac ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IdentityMap . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IdentityMap . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capac )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "h    +  =     ( key . hashCode (  )  )     *     3  1  ;", "V   value    =    valueTable [ i ]  ;", "if    ( value    !  =    null )     {", "h    +  =    value . hashCode (  )  ;", "}", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "K   evictedKey ;", "V   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUtils . random (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "int   hashCode    =    System . iHashCode ( evictedKey )  ;", "index 1     =    hashCode    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( hashCode )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( hashCode )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )", "throw   new   IllegalArgumentException (  \" key   cannot   be   null .  \"  )  ;", "K [  ]    keyTable    =    this . keyTable ;", "int   hashCode    =    System . iHashCode ( key )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    key )     {", "V   oldValue    =    valueTable [ index 1  ]  ;", "valueTable [ index 1  ]     =    value ;", "return   oldValue ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    key )     {", "V   oldValue    =    valueTable [ index 2  ]  ;", "valueTable [ index 2  ]     =    value ;", "return   oldValue ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    key )     {", "V   oldValue    =    valueTable [ index 3  ]  ;", "valueTable [ index 3  ]     =    value ;", "return   oldValue ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    (  ( keyTable [ i ]  )     =  =    key )     {", "V   oldValue    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value ;", "return   oldValue ;", "}", "}", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    System . identityHashCode ( key )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    System . identityHashCode ( key )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =    null ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( hashCode )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =    null ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( hashCode )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =    null ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capac ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    (  ( keyTable [ i ]  )     =  =    key )     {", "V   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastIndex    =     ( capac )     +     ( stashSize )  ;", "if    ( index    <    lastIndex )     {", "keyTable [ index ]     =    keyTable [ lastIndex ]  ;", "valueTable [ index ]     =    valueTable [ lastIndex ]  ;", "valueTable [ lastIndex ]     =    null ;", "} else", "valueTable [ index ]     =    null ;", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "K [  ]    oldKeyTable    =    keyTable ;", "V [  ]    oldValueTable    =    valueTable ;", "keyTable    =     (  ( K [  ]  )     ( new   Object [ newSize    +     ( stashCapacity )  ]  )  )  ;", "valueTable    =     (  ( V [  ]  )     ( new   Object [ newSize    +     ( stashCapacity )  ]  )  )  ;", "int   oldSize    =    size ;", "size    =     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "K   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =    null )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "while    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "conue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "while    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "conue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.IdentityMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    length ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . acopy ( a ,    offset ,    items ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int   i    =     ( size )     -     1  ;", "int [  ]    items    =    this . items ;", "while    ( i    >  =     0  )", "if    (  ( items [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "int [  ]    items 1     =    this . items ;", "int [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     !  =     ( array . items [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   super . hashCode (  )  ;", "i [  ]    items    =    this . items ;", "i   h    =     1  ;", "for    ( i   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     ( items [ i ]  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     +  =    value ;", "}", "METHOD_END"], "methodName": ["incr"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "int [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . acopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     *  =    value ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  -  -  ( size )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    0  ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "int [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    a . size ;    i    <    n ;    i +  +  )     {", "int   item    =    a . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "int [  ]    items    =    this . items ;", "int   value    =    items [ index ]  ;", "( size )  -  -  ;", "if    ( ordered )", "System . acopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "int [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . acopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( items [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    newItems    =    new   int [ newSize ]  ;", "int [  ]    items    =    this . items ;", "System . acopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "int   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( newSize    >     ( items . length )  )", "resize ( Math . max (  8  ,    newSize )  )  ;", "size    =    newSize ;", "return   items ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "int   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( items ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "int [  ]    items    =    this . items ;", "int   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "int [  ]    array    =    new   int [ size ]  ;", "System . arraycopy ( items ,     0  ,    array ,     0  ,    size )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "i [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( i   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  \"  ;", "i [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( i   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append ( separator )  ;", "buffer . append ( items [ i ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     >    newSize )", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "return   new   IntArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.IntArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return ;", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "keyTable [ i ]     =     . EMPTY ;", "hasZeroValue    =    false ;", "size    =     0  ;", "stashSize    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "hasZeroValue    =    false ;", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )", "return   hasZeroValue ;", "i   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   coainsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key    =  =     ( keyTable [ i ]  )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     =  =    value )  )", "return   true ;", "int [  ]    keyTable    =    this . keyTable ;", "f [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     0  )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hasZeroValue )     &  &     (  ( Math . abs (  (  ( zeroValue )     -    value )  )  )     <  =    epsilon )  )", "return   true ;", "f [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( Math . abs (  (  ( valueTable [ i ]  )     -    value )  )  )     <  =    epsilon )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "if    (  ( other . hasZeroValue )     !  =     ( hasZeroValue )  )", "return   false ;", "if    (  ( hasZeroValue )     &  &     (  ( other . zeroValue )     !  =     ( zeroValue )  )  )     {", "return   false ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "float [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "float   otherValue    =    other . get ( key ,     0  .  0 F )  ;", "if    (  ( otherValue    =  =     0  .  0 F )     &  &     (  !  ( other . containsKey ( key )  )  )  )", "return   false ;", "float   value    =    valueTable [ i ]  ;", "if    ( otherValue    !  =    value )", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     =  =    value )  )", "return    0  ;", "int [  ]    keyTable    =    this . keyTable ;", "f [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     0  )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   keyTable [ i ]  ;", "return   notFound ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   defaultValue ;", "return   zeroValue ;", "}", "i   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    ( hasZeroValue )     {", "f   value    =    zeroValue ;", "zeroValue    +  =    increment ;", "return   value ;", "} else    {", "hasZeroValue    =    true ;", "zeroValue    =    defaultValue    +    increment ;", "+  +  ( size )  ;", "return   defaultValue ;", "}", "}", "int   index    =    key    &     ( mask )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 2  ( key )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 3  ( key )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )", "return   getAndIncrementStash ( key ,    defaultValue ,    increment )  ;", "}", "}", "f   value    =    valueTable [ index ]  ;", "valueTable [ index ]     =    value    +    increment ;", "return   value ;", "}", "METHOD_END"], "methodName": ["getAndIncrement"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key    =  =     ( keyTable [ i ]  )  )     {", "f   value    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value    +    increment ;", "return   value ;", "}", "put ( key ,     ( defaultValue    +    increment )  )  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getAndIncrementStash"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key    =  =     ( keyTable [ i ]  )  )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntFloatMap . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntFloatMap . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "if    ( hasZeroValue )     {", "h    +  =    Float . floatToIntBits ( zeroValue )  ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "float [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "h    +  =    key    *     3  1  ;", "float   value    =    valueTable [ i ]  ;", "h    +  =    Float . floatToIntBits ( value )  ;", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "float [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "int   evictedKey ;", "float   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUtils . random (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "index 1     =    evictedKey    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( evictedKey )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( evictedKey )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "zeroValue    =    value ;", "if    (  !  ( hasZeroValue )  )     {", "hasZeroValue    =    true ;", "( size )  +  +  ;", "}", "return ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key    =  =    key 1  )     {", "valueTable [ index 1  ]     =    value ;", "return ;", "}", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key    =  =    key 2  )     {", "valueTable [ index 2  ]     =    value ;", "return ;", "}", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key    =  =    key 3  )     {", "valueTable [ index 3  ]     =    value ;", "return ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key    =  =     ( keyTable [ i ]  )  )     {", "valueTable [ i ]     =    value ;", "return ;", "}", "}", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "for    ( IntFloatMap . Entry   entry    :    map . entries (  )  )", "put ( entry . key ,    entry . value )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "zeroValue    =    value ;", "hasZeroValue    =    true ;", "return ;", "}", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   defaultValue ;", "hasZeroValue    =    false ;", "( size )  -  -  ;", "return   zeroValue ;", "}", "int   index    =    key    &     ( mask )  ;", "if    ( key    =  =     ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =     . EMPTY ;", "float   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( key )  ;", "if    ( key    =  =     ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =     . EMPTY ;", "float   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( key )  ;", "if    ( key    =  =     ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =     . EMPTY ;", "float   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key    =  =     ( keyTable [ i ]  )  )     {", "f   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastdex    =     ( capacity )     +     ( stashSize )  ;", "if    ( index    <    lastdex )     {", "keyTable [ index ]     =    keyTable [ lastdex ]  ;", "valueTable [ index ]     =    valueTable [ lastdex ]  ;", "}", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "int [  ]    oldKeyTable    =    keyTable ;", "float [  ]    oldValueTable    =    valueTable ;", "keyTable    =    new   int [ newSize    +     ( stashCapacity )  ]  ;", "valueTable    =    new   float [ newSize    +     ( stashCapacity )  ]  ;", "int   oldSize    =    size ;", "size    =     ( hasZeroValue )     ?     1     :     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "int   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  {  }  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  {  '  )  ;", "int [  ]    keyTable    =    this . keyTable ;", "float [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "if    ( hasZeroValue )     {", "buffer . append (  \"  0  =  \"  )  ;", "buffer . append ( zeroValue )  ;", "} else    {", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "}", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.IntFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return ;", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "keyTable [ i ]     =     . EMPTY ;", "size    =     0  ;", "stashSize    =     0  ;", "hasZeroValue    =    false ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "hasZeroValue    =    false ;", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )", "return   hasZeroValue ;", "i   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   coainsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key    =  =     ( keyTable [ i ]  )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( haeroValue )     &  &     (  ( zeroValue )     =  =    value )  )", "return   true ;", "int [  ]    keyTable    =    thikeyTable ;", "int [  ]    valueTable    =    thivalueTable ;", "for    ( int   i    =     ( capacity )     +     ( aSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     0  )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   true ;", "return   fal ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "if    (  ( other . hasZeroValue )     !  =     ( hasZeroValue )  )", "return   false ;", "if    (  ( hasZeroValue )     &  &     (  ( other . zeroValue )     !  =     ( zeroValue )  )  )     {", "return   false ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "int   otherValue    =    other . get ( key ,     0  )  ;", "if    (  ( otherValue    =  =     0  )     &  &     (  !  ( other . containsKey ( key )  )  )  )", "return   false ;", "int   value    =    valueTable [ i ]  ;", "if    ( otherValue    !  =    value )", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( haeroValue )     &  &     (  ( zeroValue )     =  =    value )  )", "return    0  ;", "int [  ]    keyTable    =    thikeyTable ;", "int [  ]    valueTable    =    thivalueTable ;", "for    ( int   i    =     ( capacity )     +     ( aSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     0  )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   keyTable [ i ]  ;", "return   notFound ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   defaultValue ;", "return   zeroValue ;", "}", "i   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    ( hasZeroValue )     {", "i   value    =    zeroValue ;", "zeroValue    +  =    increme ;", "return   value ;", "} else    {", "hasZeroValue    =    true ;", "zeroValue    =    defaultValue    +    increme ;", "+  +  ( size )  ;", "return   defaultValue ;", "}", "}", "i   index    =    key    &     ( mask )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 2  ( key )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )     {", "index    =    hash 3  ( key )  ;", "if    ( key    !  =     ( keyTable [ index ]  )  )", "return   getAndIncremeStash ( key ,    defaultValue ,    increme )  ;", "}", "}", "i   value    =    valueTable [ index ]  ;", "valueTable [ index ]     =    value    +    increme ;", "return   value ;", "}", "METHOD_END"], "methodName": ["getAndIncrement"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key    =  =     ( keyTable [ i ]  )  )     {", "int   value    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value    +    increment ;", "return   value ;", "}", "put ( key ,     ( defaultValue    +    increment )  )  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getAndIncrementStash"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key    =  =     ( keyTable [ i ]  )  )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntIntMap . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntIntMap . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "if    ( hasZeroValue )     {", "h    +  =    Float . floatToIntBits ( zeroValue )  ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "h    +  =    key    *     3  1  ;", "int   value    =    valueTable [ i ]  ;", "h    +  =    value ;", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "int   evictedKey ;", "int   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUtils . random (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "index 1     =    evictedKey    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( evictedKey )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( evictedKey )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "zeroValue    =    value ;", "if    (  !  ( hasZeroValue )  )     {", "hasZeroValue    =    true ;", "( size )  +  +  ;", "}", "return ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key    =  =    key 1  )     {", "valueTable [ index 1  ]     =    value ;", "return ;", "}", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key    =  =    key 2  )     {", "valueTable [ index 2  ]     =    value ;", "return ;", "}", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key    =  =    key 3  )     {", "valueTable [ index 3  ]     =    value ;", "return ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key    =  =     ( keyTable [ i ]  )  )     {", "valueTable [ i ]     =    value ;", "return ;", "}", "}", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "for    ( IntIntMap . Entry   entry    :    map . entries (  )  )", "put ( entry . key ,    entry . value )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "zeroValue    =    value ;", "hasZeroValue    =    true ;", "return ;", "}", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   defaultValue ;", "hasZeroValue    =    false ;", "( size )  -  -  ;", "return   zeroValue ;", "}", "int   index    =    key    &     ( mask )  ;", "if    ( key    =  =     ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =     . EMPTY ;", "int   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( key )  ;", "if    ( key    =  =     ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =     . EMPTY ;", "int   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( key )  ;", "if    ( key    =  =     ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =     . EMPTY ;", "int   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key    =  =     ( keyTable [ i ]  )  )     {", "int   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lasdex    =     ( capacity )     +     ( stashSize )  ;", "if    ( index    <    lasdex )     {", "keyTable [ index ]     =    keyTable [ lasdex ]  ;", "valueTable [ index ]     =    valueTable [ lasdex ]  ;", "}", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "int [  ]    oldKeyTable    =    keyTable ;", "int [  ]    oldValueTable    =    valueTable ;", "keyTable    =    new   int [ newSize    +     ( stashCapacity )  ]  ;", "valueTable    =    new   int [ newSize    +     ( stashCapacity )  ]  ;", "int   oldSize    =    size ;", "size    =     ( hasZeroValue )     ?     1     :     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "int   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  {  }  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  {  '  )  ;", "int [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "if    ( hasZeroValue )     {", "buffer . append (  \"  0  =  \"  )  ;", "buffer . append ( zeroValue )  ;", "} else    {", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "}", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.IntIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return ;", "int [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )     {", "keyTable [ i ]     =     . EMPTY ;", "valueTable [ i ]     =    null ;", "}", "size    =     0  ;", "stashSize    =     0  ;", "zeroValue    =    null ;", "hasZeroValue    =    false ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "zeroValue    =    null ;", "hasZeroValue    =    false ;", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )", "return   hasZeroValue ;", "i   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   coainsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     =  =    null )  )", "return   true ;", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     (  . EMPTY )  )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   true ;", "} else", "if    ( identity )     {", "if    ( value    =  =     ( zeroValue )  )", "return   true ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   true ;", "} else    {", "if    (  ( hasZeroValue )     &  &     ( value . equals ( zeroValue )  )  )", "return   true ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "< V >    other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "if    (  ( other . hasZeroValue )     !  =     ( hasZeroValue )  )", "return   false ;", "if    ( hasZeroValue )     {", "if    (  ( other . zeroValue )     =  =    null )     {", "if    (  ( zeroValue )     !  =    null )", "return   false ;", "} else    {", "if    (  !  ( other . zeroValue . equals ( zeroValue )  )  )", "return   false ;", "}", "}", "int [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "V   value    =    valueTable [ i ]  ;", "if    ( value    =  =    null )     {", "if    (  (  !  ( other . containsKey ( key )  )  )     |  |     (  ( other . get ( key )  )     !  =    null )  )     {", "return   false ;", "}", "} else    {", "if    (  !  ( value . equals ( other . get ( key )  )  )  )     {", "return   false ;", "}", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     =  =    null )  )", "return    0  ;", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     (  . EMPTY )  )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   keyTable [ i ]  ;", "} else", "if    ( identity )     {", "if    ( value    =  =     ( zeroValue )  )", "return    0  ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   keyTable [ i ]  ;", "} else    {", "if    (  ( hasZeroValue )     &  &     ( value . equals ( zeroValue )  )  )", "return    0  ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   keyTable [ i ]  ;", "}", "return   notFound ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   null ;", "return   zeroValue ;", "}", "i   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   getStash ( key ,    null )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   defaultValue ;", "return   zeroValue ;", "}", "i   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntMap . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntMap . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     !  =    null )  )     {", "h    +  =    zeroValue . hashCode (  )  ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "h    +  =    key    *     3  1  ;", "V   value    =    valueTable [ i ]  ;", "if    ( value    !  =    null )     {", "h    +  =    value . hashCode (  )  ;", "}", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "int   evictedKey ;", "V   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUtils . random (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "index 1     =    evictedKey    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( evictedKey )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( evictedKey )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "V   oldValue    =    zeroValue ;", "zeroValue    =    value ;", "if    (  !  ( hasZeroValue )  )     {", "hasZeroValue    =    true ;", "( size )  +  +  ;", "}", "return   oldValue ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    key )     {", "V   oldValue    =    valueTable [ index 1  ]  ;", "valueTable [ index 1  ]     =    value ;", "return   oldValue ;", "}", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    key )     {", "V   oldValue    =    valueTable [ index 2  ]  ;", "valueTable [ index 2  ]     =    value ;", "return   oldValue ;", "}", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    key )     {", "V   oldValue    =    valueTable [ index 3  ]  ;", "valueTable [ index 3  ]     =    value ;", "return   oldValue ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    (  ( keyTable [ i ]  )     =  =    key )     {", "V   oldValue    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value ;", "return   oldValue ;", "}", "}", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "for    ( IntMap . Entry < V >    entry    :    map . entries (  )  )", "put ( entry . key ,    entry . value )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "zeroValue    =    value ;", "hasZeroValue    =    true ;", "return ;", "}", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   null ;", "V   oldValue    =    zeroValue ;", "zeroValue    =    null ;", "hasZeroValue    =    false ;", "( size )  -  -  ;", "return   oldValue ;", "}", "int   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    (  ( keyTable [ i ]  )     =  =    key )     {", "V   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastdex    =     ( capacity )     +     ( stashSize )  ;", "if    ( index    <    lastdex )     {", "keyTable [ index ]     =    keyTable [ lastdex ]  ;", "valueTable [ index ]     =    valueTable [ lastdex ]  ;", "valueTable [ lastdex ]     =    null ;", "} else", "valueTable [ index ]     =    null ;", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "int [  ]    oldKeyTable    =    keyTable ;", "V [  ]    oldValueTable    =    valueTable ;", "keyTable    =    new   int [ newSize    +     ( stashCapacity )  ]  ;", "valueTable    =     (  ( V [  ]  )     ( new   Object [ newSize    +     ( stashCapacity )  ]  )  )  ;", "int   oldSize    =    size ;", "size    =     ( hasZeroValue )     ?     1     :     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "int   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "int [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "if    ( hasZeroValue )     {", "buffer . append (  \"  0  =  \"  )  ;", "buffer . append ( zeroValue )  ;", "} else    {", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "}", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.IntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    ( hasZeroValue )", "return   false ;", "hasZeroValue    =    true ;", "( size )  +  +  ;", "return   true ;", "}", "int [  ]    keyTable    =    this . keyTable ;", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    key )", "return   false ;", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    key )", "return   false ;", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    key )", "return   false ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   false ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   true ;", "}", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   true ;", "}", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   true ;", "}", "push ( key ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "ensureCapacity ( set . size )  ;", "Iterator   iterator    =    set . iterator (  )  ;", "while    ( iterator . hasNext )", "add ( iterator . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "ensureCapacity ( length )  ;", "for    ( i   i    =    offset ,    n    =    i    +    length ;    i    <    n ;    i +  +  )", "add ( array [ i ]  )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "hasZeroValue    =    true ;", "return ;", "}", "int   index 1     =    key    &     ( mask )  ;", "int   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( key )  ;", "int   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( key )  ;", "int   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["addResize"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "d ( key )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["addStash"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return ;", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "keyTable [ i ]     =     . EMPTY ;", "size    =     0  ;", "stashSize    =     0  ;", "hasZeroValue    =    false ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "rurn ;", "}", "hasZeroValue    =    false ;", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )", "rurn   hasZeroValue ;", "int   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "rurn   containsKeyStash ( key )  ;", "}", "}", "rurn   true ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( obj   instanceof   IntSet )  )", "return   false ;", "IntSet   other    =     (  ( IntSet )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "if    (  ( other . hasZeroValue )     !  =     ( hasZeroValue )  )", "return   false ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  (  ( keyTable [ i ]  )     !  =     ( IntSet . EMPTY )  )     &  &     (  !  ( other . contains ( keyTable [ i ]  )  )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    ( hasZeroValue )", "return    0  ;", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     !  =     (  . EMPTY )  )", "return   keyTable [ i ]  ;", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntSet . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "h    *  =    IntSet . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     !  =     (  . EMPTY )  )", "h    +  =    keyTable [ i ]  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterator 1  )     =  =    null )     {", "iterator 1     =    newIterator ( this )  ;", "iterator 2     =    newIterator ( this )  ;", "}", "if    (  !  ( iterator 1  . valid )  )     {", "iterator 1  . reset (  )  ;", "iterator 1  . valid    =    true ;", "iterator 2  . valid    =    false ;", "return   iterator 1  ;", "}", "iterator 2  . reset (  )  ;", "iterator 2  . valid    =    true ;", "iterator 1  . valid    =    false ;", "return   iterator 2  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "int   mask    =    this . mask ;", "int   evictedKey ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUtils . random (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "keyTable [ index 1  ]     =    insertKey ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "keyTable [ index 2  ]     =    insertKey ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "keyTable [ index 3  ]     =    insertKey ;", "break ;", "}", "index 1     =    evictedKey    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    evictedKey ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( evictedKey )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    evictedKey ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( evictedKey )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    evictedKey ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "}    while    ( true    )  ;", "addStash ( evictedKey )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   false ;", "hasZeroValue    =    false ;", "( size )  -  -  ;", "return   true ;", "}", "int   index    =    key    &     ( mask )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "( size )  -  -  ;", "return   true ;", "}", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "( size )  -  -  ;", "return   true ;", "}", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "( size )  -  -  ;", "return   true ;", "}", "return   removeStash ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    (  ( keyTable [ i ]  )     =  =    key )     {", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastdex    =     ( capacity )     +     ( stashSize )  ;", "if    ( index    <    lastdex )", "keyTable [ index ]     =    keyTable [ lastdex ]  ;", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "int [  ]    oldKeyTable    =    keyTable ;", "keyTable    =    new   int [ newSize    +     ( stashCapacity )  ]  ;", "int   oldSize    =    size ;", "size    =     ( hasZeroValue )     ?     1     :     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "int   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )", "addResize ( key )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "int [  ]    keyTable    =    this . keyTable ;", "int   i    =    keyTable . length ;", "if    ( hasZeroValue )", "buffer . append (  \"  0  \"  )  ;", "else    {", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append ( key )  ;", "break ;", "}", "}", "while    (  ( i -  -  )     >     0  )     {", "int   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "IntSet   set    =    new   IntSet (  )  ;", "set . addAll ( array )  ;", "return   set ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.IntSet"}, {"methodBody": ["METHOD_START", "{", "tagToClass . put ( tag ,    type )  ;", "classToTag . put ( type ,    tag )  ;", "}", "METHOD_END"], "methodName": ["addClassTag"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   enumNames    ?    e . name (  )     :    e . toString (  )  ;", "}", "METHOD_END"], "methodName": ["convertToString"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "if    ( object   instanceof   Enum )", "return   nvertToString (  (  ( Enum )     ( object )  )  )  ;", "if    ( object   instanceof   Class )", "return    (  ( Class )     ( object )  )  . getName (  )  ;", "return   String . valueOf ( object )  ;", "}", "METHOD_END"], "methodName": ["convertToString"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    Json . FieldMetadata >    fromFields    =    getFields ( from . getClass (  )  )  ;", "for    ( ObjectMap . Entry < String ,    Json . FieldMetadata >    entry    :    getFields ( to . getClass (  )  )  )     {", "Field   toField    =    entry . value . field ;", "Json . FieldMetadata   fromField    =    fromFields . get ( entry . key )  ;", "if    ( fromField    =  =    null )", "throw   new   SerializationException (  (  \" From   object   is   missing   field :     \"     +     ( toField . getName (  )  )  )  )  ;", "try    {", "toField . set ( to ,    fromField . field . get ( from )  )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException (  (  \" Error   copying   field :     \"     +     ( toField . getName (  )  )  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["copyFields"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    null ,    new   JsonReader (  )  . parse ( data ,    offset ,    length )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( T )     ( readValue ( type ,    null ,    new   Reader (  )  . parse ( file )  )  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SerializationException (  (  \" Error   reading   file :     \"     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    null ,    new   JsonReader (  )  . parse ( input )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    null ,    new   JsonReader (  )  . parse ( reader )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    elementType ,    new   JsonReader (  )  . parse ( data ,    offset ,    length )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( T )     ( readValue ( type ,    elementType ,    new   Reader (  )  . parse ( file )  )  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SerializationException (  (  \" Error   reading   file :     \"     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    elementType ,    new   JsonReader (  )  . parse ( input )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    elementType ,    new   JsonReader (  )  . parse ( reader )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    elementType ,    new   JsonReader (  )  . parse ( json )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    null ,    new   JsonReader (  )  . parse ( json )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   tagToClass . get ( tag )  ;", "}", "METHOD_END"], "methodName": ["getClass"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( usePrototypes )  )", "return   null ;", "if    ( classToDefaultValues . containsKey ( type )  )", "return   classToDefaultValues . get ( type )  ;", "Object   object ;", "try    {", "object    =    newInstance ( type )  ;", "}    catch    ( Exception   ex )     {", "classToDefaultValues . put ( type ,    null )  ;", "return   null ;", "}", "ObjectMap < String ,     . FieldMetadata >    fields    =    getFields ( type )  ;", "Object [  ]    values    =    new   Object [ fields . size ]  ;", "classToDefaultValues . put ( type ,    values )  ;", "int   i    =     0  ;", "for    (  . FieldMetadata   metadata    :    fields . values (  )  )     {", "Field   field    =    metadata . field ;", "if    (  (  ( readDeprecated )     &  &     ( ignoreDeprecated )  )     &  &     ( field . isAnnotationPresent ( Deprecated . class )  )  )", "continue ;", "try    {", "values [  ( i +  +  )  ]     =    field . get ( object )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException (  (  (  (  (  \" Error   accessing   field :     \"     +     ( field . getName (  )  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  ,    ex )  ;", "}    catch    ( SerializationException   ex )     {", "ex . addTrace (  (  (  ( field    +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}    catch    ( RuntimeException   runtimeEx )     {", "SerializationException   ex    =    new   SerializationException ( runtimeEx )  ;", "ex . addTrace (  (  (  ( field    +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}", "}", "return   values ;", "}", "METHOD_END"], "methodName": ["getDefaultValues"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "OrderedMap < String ,    Json . FieldMetadata >    fields    =    typeToFields . get ( type )  ;", "if    ( fields    !  =    null )", "return   fields ;", "Array < Class >    classHierarchy    =    new   Array (  )  ;", "Class   nextClass    =    type ;", "while    ( nextClass    !  =     ( Object . class )  )     {", "classHierarchy . add ( nextClass )  ;", "nextClass    =    nextClass . getSuperclass (  )  ;", "}", "ArrayList < Field >    allFields    =    new   ArrayList (  )  ;", "for    ( int   i    =     ( classHierarchy . size )     -     1  ;    i    >  =     0  ;    i -  -  )", "addAll ( allFields ,    reflect . ClassReflection . getDeclaredFields ( classHierarchy . get ( i )  )  )  ;", "OrderedMap < String ,    Json . FieldMetadata >    nameToField    =    new   OrderedMap ( allFields . size (  )  )  ;", "for    ( int   i    =     0  ,    n    =    allFields . size (  )  ;    i    <    n ;    i +  +  )     {", "Field   field    =    allFields . get ( i )  ;", "if    ( field . isTransient (  )  )", "continue ;", "if    ( field . isStatic (  )  )", "continue ;", "if    ( field . isSynthetic (  )  )", "continue ;", "if    (  !  ( field . isAccessible (  )  )  )     {", "try    {", "field . setAccessible ( true )  ;", "}    catch    ( AccessControlException   ex )     {", "continue ;", "}", "}", "if    (  (  ( ignoreDeprecated )     &  &     (  !  ( readDeprecated )  )  )     &  &     ( field . isAnnotationPresent ( Deprecated . class )  )  )", "continue ;", "nameToField . put ( field . getName (  )  ,    new   Json . FieldMetadata ( field )  )  ;", "}", "typeToFields . put ( type ,    nameToField )  ;", "return   nameToField ;", "}", "METHOD_END"], "methodName": ["getFields"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   ignoreUnknownFields ;", "}", "METHOD_END"], "methodName": ["getIgnoreUnknownFields"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   classToSerializer . get ( type )  ;", "}", "METHOD_END"], "methodName": ["getSerializer"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   classToTag . get ( type )  ;", "}", "METHOD_END"], "methodName": ["getTag"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   writer ;", "}", "METHOD_END"], "methodName": ["getWriter"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["ignoreUnknownField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   ClassReflecon . newInstance ( type )  ;", "}    catch    ( Excepon   ex )     {", "try    {", "Constructor   constructor    =    ClassReflecon . getDeclaredConstructor ( type )  ;", "constructor . setAccessible ( true )  ;", "return   constructor . newInstance (  )  ;", "}    catch    ( SecurityExcepon   ignored )     {", "}    catch    ( RefleconExcepon   ignored )     {", "if    ( ClassReflecon . isAssignableFrom ( Enum . class ,    type )  )     {", "if    (  ( type . getEnumConstants (  )  )     =  =    null )", "type    =    type . getSuperclass (  )  ;", "return   type . getEnumConstants (  )  [  0  ]  ;", "}", "if    ( type . isArray (  )  )", "throw   new   SerializaonExcepon (  (  \" Encountered   JSON   object   when   expected   array   of   type :     \"     +     ( type . getName (  )  )  )  ,    ex )  ;", "else", "if    (  ( ClassReflecon . isMemberClass ( type )  )     &  &     (  !  ( ClassReflecon . isStacClass ( type )  )  )  )", "throw   new   SerializaonExcepon (  (  \" Class   cannot   be   created    ( non - stac   member   class )  :     \"     +     ( type . getName (  )  )  )  ,    ex )  ;", "else", "throw   new   SerializaonExcepon (  (  \" Class   cannot   be   created    ( missing   no - arg   constructor )  :     \"     +     ( type . getName (  )  )  )  ,    ex )  ;", "}    catch    ( Excepon   privateConstructorExcepon )     {", "ex    =    privateConstructorExcepon ;", "}", "throw   new   SerializaonExcepon (  (  \" Error   construcng   instance   of   class :     \"     +     ( type . getName (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   prettyPrint ( object ,     0  )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   prettyPrint ( toJson ( object )  ,    settings )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   prettyPrint ( toJson ( object )  ,    singleLineColumns )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   prettyPrint ( json ,     0  )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonReader (  )  . parse ( json )  . prettyPrint ( settings )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonReader (  )  . parse ( json )  . prettyPrint ( outputType ,    singleLineColumns )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "JsonValue   jsonValue    =    jsonMap . get ( jsonName )  ;", "if    ( jsonValue    =  =    null )", "return ;", "try    {", "field . set ( object ,    readValue ( field . getType (  )  ,    elementType ,    jsonValue )  )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException (  (  (  (  (  \" Error   accessing   field :     \"     +     ( field . getName (  )  )  )     +     \"     (  \"  )     +     ( field . getDeclaringClass (  )  . getName (  )  )  )     +     \"  )  \"  )  ,    ex )  ;", "}    catch    ( SerializationException   ex )     {", "ex . addTrace (  (  (  (  ( field . getName (  )  )     +     \"     (  \"  )     +     ( field . getDeclaringClass (  )  . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}    catch    ( RuntimeException   runtimeEx )     {", "SerializationException   ex    =    new   SerializationException ( runtimeEx )  ;", "ex . addTrace ( jsonValue . trace (  )  )  ;", "ex . addTrace (  (  (  (  ( field . getName (  )  )     +     \"     (  \"  )     +     ( field . getDeclaringClass (  )  . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["readField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "readField ( object ,    name ,    name ,    null ,    jsonData )  ;", "}", "METHOD_END"], "methodName": ["readField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "readField ( object ,    name ,    name ,    elementType ,    jsonData )  ;", "}", "METHOD_END"], "methodName": ["readField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "readField ( object ,    fieldName ,    jsonName ,    null ,    jsonData )  ;", "}", "METHOD_END"], "methodName": ["readField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "Class   type    =    object . getClass (  )  ;", "ObjectMap < String ,     . FieldMetadata >    fields    =    getFields ( type )  ;", ". FieldMetadata   metadata    =    fields . get ( fieldName )  ;", "if    ( metadata    =  =    null )", "throw   new   SerializationException (  (  (  (  (  \" Field   not   found :     \"     +    fieldName )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "Field   field    =    metadata . field ;", "if    ( elementType    =  =    null )", "elementType    =    metadata . elementType ;", "readField ( object ,    field ,    jsonName ,    elementType ,    jsonMap )  ;", "}", "METHOD_END"], "methodName": ["readField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "Class   type    =    object . getClass (  )  ;", "ObjectMap < String ,     . FieldMetadata >    fields    =    getFields ( type )  ;", "for    ( Value   child    =    jsonMap . child ;    child    !  =    null ;    child    =    child . next )     {", ". FieldMetadata   metadata    =    fields . get ( child . name (  )  . replace (  \"     \"  ,     \"  _  \"  )  )  ;", "if    ( metadata    =  =    null )     {", "if    ( child . name . equals ( typeName )  )", "continue ;", "if    (  ( ignoreUnknownFields )     |  |     ( ignoreUnknownField ( type ,    child . name )  )  )     {", "if    (  . debug )", "System . out . println (  (  (  (  (  \" Ignoring   unknown   field :     \"     +     ( child . name )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "continue ;", "} else    {", "SerializationException   ex    =    new   SerializationException (  (  (  (  (  \" Field   not   found :     \"     +     ( child . name )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "ex . addTrace ( child . trace (  )  )  ;", "throw   ex ;", "}", "}", "Field   field    =    metadata . field ;", "try    {", "field . set ( object ,    readValue ( field . getType (  )  ,    metadata . elementType ,    child )  )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException (  (  (  (  (  \" Error   accessing   field :     \"     +     ( field . getName (  )  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  ,    ex )  ;", "}    catch    ( SerializationException   ex )     {", "ex . addTrace (  (  (  (  ( field . getName (  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}    catch    ( RuntimeException   runtimeEx )     {", "SerializationException   ex    =    new   SerializationException ( runtimeEx )  ;", "ex . addTrace ( child . trace (  )  )  ;", "ex . addTrace (  (  (  (  ( field . getName (  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}", "}", "}", "METHOD_END"], "methodName": ["readFields"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    null ,    jsonData )  )  )  ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "if    ( jsonData    =  =    null )", "return   defaultValue ;", "return    (  ( T )     ( readValue ( type ,    elementType ,    jsonData )  )  )  ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "if    ( jsonData    =  =    null )", "return   null ;", "if    ( jsonData . isObject (  )  )     {", "String   className    =     (  ( typeName )     =  =    null )     ?    null    :    jsonData . getString ( typeName ,    null )  ;", "if    ( className    !  =    null )     {", "type    =    getClass ( className )  ;", "if    ( type    =  =    null )     {", "try    {", "type    =     (  ( Class < T >  )     ( ClassReflection . forName ( className )  )  )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}", "}", "}", "if    ( type    =  =    null )     {", "if    (  ( defaultSerializer )     !  =    null )", "return    (  ( T )     ( defaultSerializer . read ( this ,    jsonData ,    type )  )  )  ;", "return    (  ( T )     ( jsonData )  )  ;", "}", "if    (  (  ( typeName )     !  =    null )     &  &     ( ClassReflection . isAssignableFrom ( Collection . class ,    type )  )  )     {", "jsonData    =    jsonData . get (  \" items \"  )  ;", "if    ( jsonData    =  =    null )", "throw   new   SerializationException (  (  (  (  (  \" Unable   to   convert   object   to   collection :     \"     +    jsonData )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "} else    {", ". Serializer   serializer    =    classToSerializer . get ( type )  ;", "if    ( serializer    !  =    null )", "return    (  ( T )     ( serializer . read ( this ,    jsonData ,    type )  )  )  ;", "if    (  (  (  (  (  (  (  (  (  ( type    =  =     ( String . class )  )     |  |     ( type    =  =     ( Integer . class )  )  )     |  |     ( type    =  =     ( Boolean . class )  )  )     |  |     ( type    =  =     ( Float . class )  )  )     |  |     ( type    =  =     ( Long . class )  )  )     |  |     ( type    =  =     ( Double . class )  )  )     |  |     ( type    =  =     ( Short . class )  )  )     |  |     ( type    =  =     ( Byte . class )  )  )     |  |     ( type    =  =     ( Character . class )  )  )     |  |     ( ClassReflection . isAssignableFrom ( Enum . class ,    type )  )  )     {", "return   readValue (  \" value \"  ,    type ,    jsonData )  ;", "}", "Object   object    =    newInstance ( type )  ;", "if    ( object   instanceof    . Serializable )     {", "(  (  . Serializable )     ( object )  )  . read ( this ,    jsonData )  ;", "return    (  ( T )     ( object )  )  ;", "}", "if    ( object   instanceof   ObjectMap )     {", "ObjectMap   result    =     (  ( ObjectMap )     ( object )  )  ;", "for    ( Value   child    =    jsonData . child ;    child    !  =    null ;    child    =    child . next )", "result . put ( child . name ,    readValue ( elementType ,    null ,    child )  )  ;", "return    (  ( T )     ( result )  )  ;", "}", "if    ( object   instanceof   ArrayMap )     {", "ArrayMap   result    =     (  ( ArrayMap )     ( object )  )  ;", "for    ( Value   child    =    jsonData . child ;    child    !  =    null ;    child    =    child . next )", "result . put ( child . name ,    readValue ( elementType ,    null ,    child )  )  ;", "return    (  ( T )     ( result )  )  ;", "}", "if    ( object   instanceof   Map )     {", "Map   result    =     (  ( Map )     ( object )  )  ;", "for    ( Value   child    =    jsonData . child ;    child    !  =    null ;    child    =    child . next )     {", "if    ( child . name . equals ( typeName )  )     {", "continue ;", "}", "result . put ( child . name ,    readValue ( elementType ,    null ,    child )  )  ;", "}", "return    (  ( T )     ( result )  )  ;", "}", "readFields ( object ,    jsonData )  ;", "return    (  ( T )     ( object )  )  ;", "}", "}", "if    ( type    !  =    null )     {", ". Serializer   serializer    =    classToSerializer . get ( type )  ;", "if    ( serializer    !  =    null )", "return    (  ( T )     ( serializer . read ( this ,    jsonData ,    type )  )  )  ;", "if    ( ClassReflection . isAssignableFrom (  . Serializable . class ,    type )  )     {", "Object   object    =    newInstance ( type )  ;", "(  (  . Serializable )     ( object )  )  . read ( this ,    jsonData )  ;", "return    (  ( T )     ( object )  )  ;", "}", "}", "if    ( jsonData . isArray (  )  )     {", "if    (  ( type    =  =    null )     |  |     ( type    =  =     ( Object . class )  )  )", "type    =     (  ( Class < T >  )     ( Array . class )  )  ;", "if    ( ClassReflection . isAssignableFrom ( Array . class ,    type )  )     {", "Array   result    =     ( type    =  =     ( Array . class )  )     ?    new   Array (  )     :     (  ( Array )     ( newInstance ( type )  )  )  ;", "for    ( Value   child    =    jsonData . child ;    child    !  =    null ;    child    =    child . next )", "result . add ( readValue ( elementType ,    null ,    child )  )  ;", "return    (  ( T )     ( result )  )  ;", "}", "if    ( ClassReflection . isAssignableFrom ( Queue . class ,    type )  )     {", "Queue   result    =     ( type    =  =     ( Queue . class )  )     ?    new   Queue (  )     :     (  ( Queue )     ( newInstance ( type )  )  )  ;", "for    ( Value   child    =    jsonData . child ;    child    !  =    null ;    child    =    child . next )", "result . addLast ( readValue ( elementType ,    null ,    child )  )  ;", "return    (  ( T )     ( result )  )  ;", "}", "if    ( ClassReflection . isAssignableFrom ( Collection . class ,    type )  )     {", "Collection   result    =     ( type . isInterface (  )  )     ?    new   ArrayList (  )     :     (  ( Collection )     ( newInstance ( type )  )  )  ;", "for    ( Value   child    =    jsonData . child ;    child    !  =    null ;    child    =    child . next )", "result . add ( readValue ( elementType ,    null ,    child )  )  ;", "return    (  ( T )     ( result )  )  ;", "}", "if    ( type . isArray (  )  )     {", "Class   componentType    =    type . getComponentType (  )  ;", "if    ( elementType    =  =    null )", "elementType    =    componentType ;", "Object   result    =    ArrayReflection . newInstance ( componentType ,    jsonData . size )  ;", "int   i    =     0  ;", "for    ( Value   child    =    jsonData . child ;    child    !  =    null ;    child    =    child . next )", "ArrayReflection . set ( result ,     ( i +  +  )  ,    readValue ( elementType ,    null ,    child )  )  ;", "return    (  ( T )     ( result )  )  ;", "}", "throw   new   SerializationException (  (  (  (  (  \" Unable   to   convert   value   to   required   type :     \"     +    jsonData )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "}", "if    ( jsonData . isNumber (  )  )     {", "try    {", "if    (  (  ( type    =  =    null )     |  |     ( type    =  =     ( float . class )  )  )     |  |     ( type    =  =     ( Float . class )  )  )", "return    (  ( T )     (  ( Float )     ( jsonData . asFloat (  )  )  )  )  ;", "if    (  ( type    =  =     ( int . class )  )     |  |     ( type    =  =     ( Integer . class )  )  )", "return    (  ( T )     (  ( Integer )     ( jsonData . asInt (  )  )  )  )  ;", "if    (  ( type    =  =     ( long . class )  )     |  |     ( type    =  =     ( Long . class )  )  )", "return    (  ( T )     (  ( Long )     ( jsonData . asLong (  )  )  )  )  ;", "if    (  ( type    =  =     ( double . class )  )     |  |     ( type    =  =     ( Double . class )  )  )", "return    (  ( T )     (  ( Double )     ( jsonData . asDouble (  )  )  )  )  ;", "if    ( type    =  =     ( String . class )  )", "return    (  ( T )     ( jsonData . asString (  )  )  )  ;", "if    (  ( type    =  =     ( short . class )  )     |  |     ( type    =  =     ( Short . class )  )  )", "return    (  ( T )     (  ( Short )     ( jsonData . asShort (  )  )  )  )  ;", "if    (  ( type    =  =     ( byte . class )  )     |  |     ( type    =  =     ( Byte . class )  )  )", "return    (  ( T )     (  ( Byte )     ( jsonData . asByte (  )  )  )  )  ;", "}    catch    ( NumberFormatException   ignored )     {", "}", "jsonData    =    new   Value ( jsonData . asString (  )  )  ;", "}", "if    ( jsonData . isBoolean (  )  )     {", "try    {", "if    (  (  ( type    =  =    null )     |  |     ( type    =  =     ( boolean . class )  )  )     |  |     ( type    =  =     ( Boolean . class )  )  )", "return    (  ( T )     (  ( Boolean )     ( jsonData . asBoolean (  )  )  )  )  ;", "}    catch    ( NumberFormatException   ignored )     {", "}", "jsonData    =    new   Value ( jsonData . asString (  )  )  ;", "}", "if    ( jsonData . isString (  )  )     {", "String   string    =    jsonData . asString (  )  ;", "if    (  ( type    =  =    null )     |  |     ( type    =  =     ( String . class )  )  )", "return    (  ( T )     ( string )  )  ;", "try    {", "if    (  ( type    =  =     ( int . class )  )     |  |     ( type    =  =     ( Integer . class )  )  )", "return    (  ( T )     ( Integer . valueOf ( string )  )  )  ;", "if    (  ( type    =  =     ( float . class )  )     |  |     ( type    =  =     ( Float . class )  )  )", "return    (  ( T )     ( Float . valueOf ( string )  )  )  ;", "if    (  ( type    =  =     ( long . class )  )     |  |     ( type    =  =     ( Long . class )  )  )", "return    (  ( T )     ( Long . valueOf ( string )  )  )  ;", "if    (  ( type    =  =     ( double . class )  )     |  |     ( type    =  =     ( Double . class )  )  )", "return    (  ( T )     ( Double . valueOf ( string )  )  )  ;", "if    (  ( type    =  =     ( short . class )  )     |  |     ( type    =  =     ( Short . class )  )  )", "return    (  ( T )     ( Short . valueOf ( string )  )  )  ;", "if    (  ( type    =  =     ( byte . class )  )     |  |     ( type    =  =     ( Byte . class )  )  )", "return    (  ( T )     ( Byte . valueOf ( string )  )  )  ;", "}    catch    ( NumberFormatException   ignored )     {", "}", "if    (  ( type    =  =     ( boolean . class )  )     |  |     ( type    =  =     ( Boolean . class )  )  )", "return    (  ( T )     ( Boolean . valueOf ( string )  )  )  ;", "if    (  ( type    =  =     ( char . class )  )     |  |     ( type    =  =     ( Character . class )  )  )", "return    (  ( T )     (  ( Character )     ( string . charAt (  0  )  )  )  )  ;", "if    ( ClassReflection . isAssignableFrom ( Enum . class ,    type )  )     {", "Enum [  ]    constants    =     (  ( Enum [  ]  )     ( type . getEnumConstants (  )  )  )  ;", "for    ( int   i    =     0  ,    n    =    constants . length ;    i    <    n ;    i +  +  )     {", "Enum   e    =    constants [ i ]  ;", "if    ( string . equals ( convertToString ( e )  )  )", "return    (  ( T )     ( e )  )  ;", "}", "}", "if    ( type    =  =     ( CharSequence . class )  )", "return    (  ( T )     ( string )  )  ;", "throw   new   SerializationException (  (  (  (  (  \" Unable   to   convert   value   to   required   type :     \"     +    jsonData )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "JsonValue   jsonValue    =    jsonMap . get ( name )  ;", "if    ( jsonValue    =  =    null )", "return   defaultValue ;", "return    (  ( T )     ( readValue ( type ,    null ,    jsonValue )  )  )  ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    null ,    jsonMap . get ( name )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "JsonValue   jsonValue    =    jsonMap . get ( name )  ;", "return    (  ( T )     ( readValue ( type ,    elementType ,    defaultValue ,    jsonValue )  )  )  ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( readValue ( type ,    elementType ,    jsonMap . get ( name )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . defaultSerializer    =    defaultSerializer ;", "}", "METHOD_END"], "methodName": ["setDefaultSerializer"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "ObjectMap < String ,    Json . FieldMetadata >    fields    =    getFields ( type )  ;", "Json . FieldMetadata   metadata    =    fields . get ( fieldName )  ;", "if    ( metadata    =  =    null )", "throw   new   SerializationException (  (  (  (  (  \" Field   not   found :     \"     +    fieldName )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "metadata . elementType    =    elementType ;", "}", "METHOD_END"], "methodName": ["setElementType"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . enumNames    =    enumNames ;", "}", "METHOD_END"], "methodName": ["setEnumNames"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . ignoreDeprecated    =    ignoreDeprecated ;", "}", "METHOD_END"], "methodName": ["setIgnoreDeprecated"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . ignoreUnknownFields    =    ignoreUnknownFields ;", "}", "METHOD_END"], "methodName": ["setIgnoreUnknownFields"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . outputType    =    outputType ;", "}", "METHOD_END"], "methodName": ["setOutputType"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . quoteLongValues    =    quoteLongValues ;", "}", "METHOD_END"], "methodName": ["setQuoteLongValues"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . readDeprecated    =    readDeprecated ;", "}", "METHOD_END"], "methodName": ["setReadDeprecated"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "classToSerializer . put ( type ,    serializer )  ;", "}", "METHOD_END"], "methodName": ["setSerializer"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . typeName    =    typeName ;", "}", "METHOD_END"], "methodName": ["setTypeName"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "this . usePrototypes    =    usePrototypes ;", "}", "METHOD_END"], "methodName": ["setUsePrototypes"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( writer   instanceof   JsonWriter )  )", "writer    =    new   JsonWriter ( writer )  ;", "this . writer    =     (  ( JsonWriter )     ( writer )  )  ;", "this . writer . setOutputType ( outputType )  ;", "this . writer . setQuoteLongValues ( quoteLongValues )  ;", "}", "METHOD_END"], "methodName": ["setWriter"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   toJson ( object ,     ( object    =  =    null    ?    null    :    object . getClass (  )  )  ,     (  ( Class )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "toJson ( object ,     ( object    =  =    null    ?    null    :    object . getClass (  )  )  ,    null ,    file )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "toJson ( object ,     ( object    =  =    null    ?    null    :    object . getClass (  )  )  ,    null ,    writer )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "return   toJson ( object ,    knownType ,     (  ( Class )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "toJson ( object ,    knownType ,    null ,    file )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "toJson ( object ,    knownType ,    null ,    writer )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "StringWriter   buffer    =    new   StringWriter (  )  ;", "to ( object ,    knownType ,    elementType ,    buffer )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "Writer   writer    =    null ;", "try    {", "writer    =    file . writer ( false ,     \" UTF -  8  \"  )  ;", "toJson ( object ,    knownType ,    elementType ,    writer )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SerializationException (  (  \" Error   writing   file :     \"     +    file )  ,    ex )  ;", "}    finally    {", "StreamUcloseQuietly ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "setWriter ( writer )  ;", "try    {", "writeValue ( object ,    knownType ,    elementType )  ;", "}    finally    {", "StreamUcloseQuietly ( this . writer )  ;", "this . writer    =    null ;", "}", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . pop (  )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeArrayEnd"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . array (  )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeArrayStart"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . name ( name )  ;", "writer . array (  )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeArrayStart"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "writeField ( object ,    name ,    name ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "writeField ( object ,    name ,    name ,    elementType )  ;", "}", "METHOD_END"], "methodName": ["writeField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "writeField ( object ,    fieldName ,    jsonName ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "Class   type    =    object . getClass (  )  ;", "ObjectMap < String ,     . FieldMetadata >    fields    =    getFields ( type )  ;", ". FieldMetadata   metadata    =    fields . get ( fieldName )  ;", "if    ( metadata    =  =    null )", "throw   new   SerializationException (  (  (  (  (  \" Field   not   found :     \"     +    fieldName )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "Field   field    =    metadata . field ;", "if    ( elementType    =  =    null )", "elementType    =    metadata . elementType ;", "try    {", "if    (  . debug )", "System . out . println (  (  (  (  (  \" Writing   field :     \"     +     ( field . getName (  )  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "writer . name ( jsonName )  ;", "writeValue ( field . get ( object )  ,    field . getType (  )  ,    elementType )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException (  (  (  (  (  \" Error   accessing   field :     \"     +     ( field . getName (  )  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  ,    ex )  ;", "}    catch    ( SerializationException   ex )     {", "ex . addTrace (  (  (  ( field    +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}    catch    ( Exception   runtimeEx )     {", "SerializationException   ex    =    new   SerializationException ( runtimeEx )  ;", "ex . addTrace (  (  (  ( field    +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["writeField"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "Class   type    =    object . getClass (  )  ;", "Object [  ]    defaultValues    =    getDefaultValues ( type )  ;", "OrderedMap < String ,     . FieldMetadata >    fields    =    getFields ( type )  ;", "int   i    =     0  ;", "for    (  . FieldMetadata   metadata    :    new   OrderedMap . OrderedMapValues <  . FieldMetadata >  ( fields )  )     {", "Field   field    =    metadata . field ;", "if    (  (  ( readDeprecated )     &  &     ( ignoreDeprecated )  )     &  &     ( field . isAnnotationPresent ( Deprecated . class )  )  )", "continue ;", "try    {", "Object   value    =    field . get ( object )  ;", "if    ( defaultValues    !  =    null )     {", "Object   defaultValue    =    defaultValues [  ( i +  +  )  ]  ;", "if    (  ( value    =  =    null )     &  &     ( defaultValue    =  =    null )  )", "continue ;", "if    (  ( value    !  =    null )     &  &     ( defaultValue    !  =    null )  )     {", "if    ( value . equals ( defaultValue )  )", "continue ;", "if    (  ( value . getClass (  )  . isArray (  )  )     &  &     ( defaultValue . getClass (  )  . isArray (  )  )  )     {", "equals 1  [  0  ]     =    value ;", "equals 2  [  0  ]     =    defaultValue ;", "if    ( Arrays . deepEquals ( equals 1  ,    equals 2  )  )", "continue ;", "}", "}", "}", "if    (  . debug )", "System . out . println (  (  (  (  (  \" Writing   field :     \"     +     ( field . getName (  )  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "writer . name ( field . getName (  )  )  ;", "writeValue ( value ,    field . getType (  )  ,    metadata . elementType )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   SerializationException (  (  (  (  (  \" Error   accessing   field :     \"     +     ( field . getName (  )  )  )     +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  ,    ex )  ;", "}    catch    ( SerializationException   ex )     {", "ex . addTrace (  (  (  ( field    +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}    catch    ( Exception   runtimeEx )     {", "SerializationException   ex    =    new   SerializationException ( runtimeEx )  ;", "ex . addTrace (  (  (  ( field    +     \"     (  \"  )     +     ( type . getName (  )  )  )     +     \"  )  \"  )  )  ;", "throw   ex ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeFields"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . pop (  )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeObjectEnd"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . object (  )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeObjectStart"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . object (  )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "if    (  ( knownType    =  =    null )     |  |     ( knownType    !  =    actualType )  )", "writeType ( actualType )  ;", "}", "METHOD_END"], "methodName": ["writeObjectStart"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . name ( name )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "writeObjectStart (  )  ;", "}", "METHOD_END"], "methodName": ["writeObjectStart"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . name ( name )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "writeObjectStart ( actualType ,    knownType )  ;", "}", "METHOD_END"], "methodName": ["writeObjectStart"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "if    (  ( typeName )     =  =    null )", "return ;", "String   className    =    getTag ( type )  ;", "if    ( className    =  =    null )", "className    =    type . getName (  )  ;", "try    {", "writer . set ( typeName ,    className )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}", "if    (  . debug )", "System . out . println (  (  \" Writing   type :     \"     +     ( type . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeType"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )", "writeValue ( value ,    null ,    null )  ;", "ee", "writeValue ( value ,    value . getClass (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "writeValue ( value ,    knownType ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( value    =  =    null )     {", "writer . value ( null )  ;", "return ;", "}", "if    (  (  (  (  (  (  (  (  (  (  ( knownType    !  =    null )     &  &     ( knownType . isPrimitive (  )  )  )     |  |     ( knownType    =  =     ( String . class )  )  )     |  |     ( knownType    =  =     ( Integer . class )  )  )     |  |     ( knownType    =  =     ( Boolean . class )  )  )     |  |     ( knownType    =  =     ( Float . class )  )  )     |  |     ( knownType    =  =     ( Long . class )  )  )     |  |     ( knownType    =  =     ( Double . class )  )  )     |  |     ( knownType    =  =     ( Short . class )  )  )     |  |     ( knownType    =  =     ( Byte . class )  )  )     |  |     ( knownType    =  =     ( Character . class )  )  )     {", "writer . value ( value )  ;", "return ;", "}", "Class   actualType    =    value . getClass (  )  ;", "if    (  (  (  (  (  (  (  (  (  ( actualType . isPrimitive (  )  )     |  |     ( actualType    =  =     ( String . class )  )  )     |  |     ( actualType    =  =     ( Integer . class )  )  )     |  |     ( actualType    =  =     ( Boolean . class )  )  )     |  |     ( actualType    =  =     ( Float . class )  )  )     |  |     ( actualType    =  =     ( Long . class )  )  )     |  |     ( actualType    =  =     ( Double . class )  )  )     |  |     ( actualType    =  =     ( Short . class )  )  )     |  |     ( actualType    =  =     ( Byte . class )  )  )     |  |     ( actualType    =  =     ( Character . class )  )  )     {", "writeObjectStart ( actualType ,    null )  ;", "writeValue (  \" value \"  ,    value )  ;", "writeObjectEnd (  )  ;", "return ;", "}", "if    ( value   instanceof   Json . Serializable )     {", "writeObjectStart ( actualType ,    knownType )  ;", "(  ( Json . Serializable )     ( value )  )  . write ( this )  ;", "writeObjectEnd (  )  ;", "return ;", "}", "Json . Serializer   serializer    =    classToSerializer . get ( actualType )  ;", "if    ( serializer    !  =    null )     {", "serializer . write ( this ,    value ,    knownType )  ;", "return ;", "}", "if    ( value   instanceof   Array )     {", "if    (  (  ( knownType    !  =    null )     &  &     ( actualType    !  =    knownType )  )     &  &     ( actualType    !  =     ( Array . class )  )  )", "throw   new   SerializationException (  (  (  (  (  \" Serialization   of   an   Array   other   than   the   known   type   is   not   supported .  \\ n \"     +     \" Known   type :     \"  )     +    knownType )     +     \"  \\ nActual   type :     \"  )     +    actualType )  )  ;", "writeArrayStart (  )  ;", "Array   array    =     (  ( Array )     ( value )  )  ;", "for    ( int   i    =     0  ,    n    =    array . size ;    i    <    n ;    i +  +  )", "writeValue ( array . get ( i )  ,    elementType ,    null )  ;", "writeArrayEnd (  )  ;", "return ;", "}", "if    ( value   instanceof   Queue )     {", "if    (  (  ( knownType    !  =    null )     &  &     ( actualType    !  =    knownType )  )     &  &     ( actualType    !  =     ( Queue . class )  )  )", "throw   new   SerializationException (  (  (  (  (  \" Serialization   of   a   Queue   other   than   the   known   type   is   not   supported .  \\ n \"     +     \" Known   type :     \"  )     +    knownType )     +     \"  \\ nActual   type :     \"  )     +    actualType )  )  ;", "writeArrayStart (  )  ;", "Queue   queue    =     (  ( Queue )     ( value )  )  ;", "for    ( int   i    =     0  ,    n    =    queue . size ;    i    <    n ;    i +  +  )", "writeValue ( queue . get ( i )  ,    elementType ,    null )  ;", "writeArrayEnd (  )  ;", "return ;", "}", "if    ( value   instanceof   Collection )     {", "if    (  (  (  ( typeName )     !  =    null )     &  &     ( actualType    !  =     ( ArrayList . class )  )  )     &  &     (  ( knownType    =  =    null )     |  |     ( knownType    !  =    actualType )  )  )     {", "writeObjectStart ( actualType ,    knownType )  ;", "writeArrayStart (  \" items \"  )  ;", "for    ( Object   item    :     (  ( Collection )     ( value )  )  )", "writeValue ( item ,    elementType ,    null )  ;", "writeArrayEnd (  )  ;", "writeObjectEnd (  )  ;", "} else    {", "writeArrayStart (  )  ;", "for    ( Object   item    :     (  ( Collection )     ( value )  )  )", "writeValue ( item ,    elementType ,    null )  ;", "writeArrayEnd (  )  ;", "}", "return ;", "}", "if    ( actualType . isArray (  )  )     {", "if    ( elementType    =  =    null )", "elementType    =    actualType . getComponentType (  )  ;", "int   length    =    ArrayReflection . getLength ( value )  ;", "writeArrayStart (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )", "writeValue ( ArrayReflection . get ( value ,    i )  ,    elementType ,    null )  ;", "writeArrayEnd (  )  ;", "return ;", "}", "if    ( value   instanceof   ObjectMap )     {", "if    ( knownType    =  =    null )", "knownType    =    ObjectMap . class ;", "writeObjectStart ( actualType ,    knownType )  ;", "for    ( ObjectMap . Entry   entry    :     (  ( ObjectMap <  ?  ,     ?  >  )     ( value )  )  . entries (  )  )     {", "writer . name ( convertToString ( entry . key )  )  ;", "writeValue ( entry . value ,    elementType ,    null )  ;", "}", "writeObjectEnd (  )  ;", "return ;", "}", "if    ( value   instanceof   ArrayMap )     {", "if    ( knownType    =  =    null )", "knownType    =    ArrayMap . class ;", "writeObjectStart ( actualType ,    knownType )  ;", "ArrayMap   map    =     (  ( ArrayMap )     ( value )  )  ;", "for    ( int   i    =     0  ,    n    =    map . size ;    i    <    n ;    i +  +  )     {", "writer . name ( convertToString ( map . keys [ i ]  )  )  ;", "writeValue ( map . values [ i ]  ,    elementType ,    null )  ;", "}", "writeObjectEnd (  )  ;", "return ;", "}", "if    ( value   instanceof   Map )     {", "if    ( knownType    =  =    null )", "knownType    =    class ;", "writeObjectStart ( actualType ,    knownType )  ;", "for    ( Map . Entry   entry    :     (  ( Map <  ?  ,     ?  >  )     ( value )  )  . entrySet (  )  )     {", "writer . name ( convertToString ( entry . getKey (  )  )  )  ;", "writeValue ( entry . getValue (  )  ,    elementType ,    null )  ;", "}", "writeObjectEnd (  )  ;", "return ;", "}", "if    ( ClassReflection . isAssignableFrom ( Enum . class ,    actualType )  )     {", "if    (  (  ( typeName )     !  =    null )     &  &     (  ( knownType    =  =    null )     |  |     ( knownType    !  =    actualType )  )  )     {", "if    (  ( actualType . getEnumConstants (  )  )     =  =    null )", "actualType    =    actualType . getSuperclass (  )  ;", "writeObjectStart ( actualType ,    null )  ;", "writer . name (  \" value \"  )  ;", "writer . value ( convertToString (  (  ( Enum )     ( value )  )  )  )  ;", "writeObjectEnd (  )  ;", "} else    {", "writer . value ( convertToString (  (  ( Enum )     ( value )  )  )  )  ;", "}", "return ;", "}", "writeObjectStart ( actualType ,    knownType )  ;", "writeFields ( value )  ;", "writeObjectEnd (  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . name ( name )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "if    ( value    =  =    null )", "writeValue ( value ,    null ,    null )  ;", "else", "writeValue ( value ,    value . getClass (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . name ( name )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "writeValue ( value ,    knownType ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "try    {", "writer . name ( name )  ;", "}    catch    ( IOExcepon   ex )     {", "throw   new   SerializaonExcepon ( ex )  ;", "}", "writeValue ( value ,    knownType ,    elementType )  ;", "}", "METHOD_END"], "methodName": ["writeValue"], "fileName": "com.badlogic.gdx.utils.Json"}, {"methodBody": ["METHOD_START", "{", "child . setName ( name )  ;", "if    (  ( current )     =  =    null )     {", "current    =    child ;", "root    =    child ;", "} else", "if    (  ( current . isArray (  )  )     |  |     ( current . isObject (  )  )  )     {", "child . parent    =    current ;", "if    (  ( current . size )     =  =     0  )", "current . child    =    child ;", "else    {", "Value   last    =    lastChild . pop (  )  ;", "last . next    =    child ;", "child . prev    =    last ;", "}", "lastChild . add ( child )  ;", "( current . size )  +  +  ;", "} else", "root    =    current ;", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "addChild ( name ,    new   JsonValue ( value )  )  ;", "}", "METHOD_END"], "methodName": ["bool"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     1  ,     1  ,     1  ,     2  ,     1  ,     3  ,     1  ,     4  ,     1  ,     5  ,     1  ,     6  ,     1  ,     7  ,     1  ,     8  ,     2  ,     0  ,     7  ,     2  ,     0  ,     8  ,     2  ,     1  ,     3  ,     2  ,     1  ,     5     }  ;", "}", "METHOD_END"], "methodName": ["init__json_actions_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     1  ,     0  ,     0  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__json_eof_actions_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   short [  ]  {     0  ,     0  ,     1  1  ,     1  4  ,     1  6  ,     1  9  ,     2  8  ,     3  4  ,     4  0  ,     4  3  ,     5  4  ,     6  2  ,     7  0  ,     7  9  ,     8  1  ,     9  0  ,     9  3  ,     9  6  ,     1  0  5  ,     1  0  8  ,     1  1  1  ,     1  1  3  ,     1  1  6  ,     1  1  9  ,     1  3  0  ,     1  3  8  ,     1  4  6  ,     1  5  7  ,     1  5  9  ,     1  7  0  ,     1  7  3  ,     1  7  6  ,     1  8  7  ,     1  9  0  ,     1  9  3  ,     1  9  6  ,     2  0  1  ,     2  0  6  ,     2  0  7     }  ;", "}", "METHOD_END"], "methodName": ["init__json_index_offsets_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     1  ,     1  ,     2  ,     3  ,     4  ,     3  ,     5  ,     3  ,     6  ,     1  ,     0  ,     7  ,     7  ,     3  ,     8  ,     3  ,     9  ,     9  ,     3  ,     1  1  ,     1  1  ,     1  2  ,     1  3  ,     1  4  ,     3  ,     1  5  ,     1  1  ,     1  0  ,     1  6  ,     1  6  ,     1  7  ,     1  8  ,     1  6  ,     3  ,     1  9  ,     1  9  ,     2  0  ,     2  1  ,     1  9  ,     3  ,     2  2  ,     2  2  ,     3  ,     2  1  ,     2  1  ,     2  4  ,     3  ,     2  5  ,     3  ,     2  6  ,     3  ,     2  7  ,     2  1  ,     2  3  ,     2  8  ,     2  9  ,     2  9  ,     2  8  ,     3  0  ,     3  1  ,     3  2  ,     3  ,     3  3  ,     3  4  ,     3  4  ,     3  3  ,     1  3  ,     3  5  ,     1  5  ,     3  ,     3  4  ,     3  4  ,     1  2  ,     3  6  ,     3  7  ,     3  ,     1  5  ,     3  4  ,     1  0  ,     1  6  ,     3  ,     3  6  ,     3  6  ,     1  2  ,     3  ,     3  8  ,     3  ,     3  ,     3  6  ,     1  0  ,     3  9  ,     3  9  ,     3  ,     4  0  ,     4  0  ,     3  ,     1  3  ,     1  3  ,     1  2  ,     3  ,     4  1  ,     3  ,     1  5  ,     1  3  ,     1  0  ,     4  2  ,     4  2  ,     3  ,     4  3  ,     4  3  ,     3  ,     2  8  ,     3  ,     4  4  ,     4  4  ,     3  ,     4  5  ,     4  5  ,     3  ,     4  7  ,     4  7  ,     4  8  ,     4  9  ,     5  0  ,     3  ,     5  1  ,     5  2  ,     5  3  ,     4  7  ,     4  6  ,     5  4  ,     5  5  ,     5  5  ,     5  4  ,     5  6  ,     5  7  ,     5  8  ,     3  ,     5  9  ,     6  0  ,     6  0  ,     5  9  ,     4  9  ,     6  1  ,     5  2  ,     3  ,     6  0  ,     6  0  ,     4  8  ,     6  2  ,     6  3  ,     3  ,     5  1  ,     5  2  ,     5  3  ,     6  0  ,     4  6  ,     5  4  ,     3  ,     6  2  ,     6  2  ,     4  8  ,     3  ,     6  4  ,     3  ,     5  1  ,     3  ,     5  3  ,     6  2  ,     4  6  ,     6  5  ,     6  5  ,     3  ,     6  6  ,     6  6  ,     3  ,     4  9  ,     4  9  ,     4  8  ,     3  ,     6  7  ,     3  ,     5  1  ,     5  2  ,     5  3  ,     4  9  ,     4  6  ,     6  8  ,     6  8  ,     3  ,     6  9  ,     6  9  ,     3  ,     7  0  ,     7  0  ,     3  ,     8  ,     8  ,     7  1  ,     8  ,     3  ,     7  2  ,     7  2  ,     7  3  ,     7  2  ,     3  ,     3  ,     3  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__json_indicies_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   short [  ]  {     0  ,     0  ,     1  1  ,     1  3  ,     1  4  ,     1  6  ,     2  5  ,     3  1  ,     3  7  ,     3  9  ,     5  0  ,     5  7  ,     6  4  ,     7  3  ,     7  4  ,     8  3  ,     8  5  ,     8  7  ,     9  6  ,     9  8  ,     1  0  0  ,     1  0  1  ,     1  0  3  ,     1  0  5  ,     1  1  6  ,     1  2  3  ,     1  3  0  ,     1  4  1  ,     1  4  2  ,     1  5  3  ,     1  5  5  ,     1  5  7  ,     1  6  8  ,     1  7  0  ,     1  7  2  ,     1  7  4  ,     1  7  9  ,     1  8  4  ,     1  8  4     }  ;", "}", "METHOD_END"], "methodName": ["init__json_key_offsets_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     1  ,     0  ,     0  ,     0  ,     1  ,     1  ,     1  ,     0  ,     1  ,     0  ,     0  ,     1  ,     0  ,     1  ,     0  ,     0  ,     1  ,     0  ,     0  ,     0  ,     0  ,     0  ,     1  ,     0  ,     0  ,     1  ,     0  ,     1  ,     0  ,     0  ,     1  ,     0  ,     0  ,     0  ,     1  ,     1  ,     0  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__json_range_lengths_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     9  ,     2  ,     1  ,     2  ,     7  ,     4  ,     4  ,     2  ,     9  ,     7  ,     7  ,     7  ,     1  ,     7  ,     2  ,     2  ,     7  ,     2  ,     2  ,     1  ,     2  ,     2  ,     9  ,     7  ,     7  ,     9  ,     1  ,     9  ,     2  ,     2  ,     9  ,     2  ,     2  ,     2  ,     3  ,     3  ,     0  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__json_single_lengths_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     1  3  ,     0  ,     1  5  ,     0  ,     0  ,     7  ,     3  ,     1  1  ,     1  ,     1  1  ,     1  7  ,     0  ,     2  0  ,     0  ,     0  ,     5  ,     1  ,     1  ,     1  ,     0  ,     0  ,     0  ,     1  1  ,     1  3  ,     1  5  ,     0  ,     7  ,     3  ,     1  ,     1  ,     1  ,     1  ,     2  3  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     1  1  ,     1  1  ,     0  ,     1  1  ,     1  1  ,     1  1  ,     1  1  ,     1  3  ,     0  ,     1  5  ,     0  ,     0  ,     7  ,     9  ,     3  ,     1  ,     1  ,     1  ,     1  ,     2  6  ,     0  ,     0  ,     0  ,     0  ,     0  ,     0  ,     1  1  ,     1  1  ,     0  ,     1  1  ,     1  1  ,     1  1  ,     1  ,     0  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__json_trans_actions_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   char [  ]  {     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     9  1  ,     9  3  ,     1  2  3  ,     9  ,     1  0  ,     4  2  ,     4  7  ,     3  4  ,     4  2  ,     4  7  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     1  2  5  ,     9  ,     1  0  ,     1  3  ,     3  2  ,     4  7  ,     5  8  ,     9  ,     1  0  ,     1  3  ,     3  2  ,     4  7  ,     5  8  ,     9  ,     1  0  ,     4  2  ,     4  7  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     9  1  ,     9  3  ,     1  2  3  ,     9  ,     1  0  ,     9  ,     1  0  ,     1  3  ,     3  2  ,     4  4  ,     4  7  ,     1  2  5  ,     9  ,     1  0  ,     1  3  ,     3  2  ,     4  4  ,     4  7  ,     1  2  5  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     1  2  5  ,     9  ,     1  0  ,     3  4  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     1  2  5  ,     9  ,     1  0  ,     4  2  ,     4  7  ,     4  2  ,     4  7  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     1  2  5  ,     9  ,     1  0  ,     4  2  ,     4  7  ,     4  2  ,     4  7  ,     3  4  ,     4  2  ,     4  7  ,     4  2  ,     4  7  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     9  1  ,     9  3  ,     1  2  3  ,     9  ,     1  0  ,     9  ,     1  0  ,     1  3  ,     3  2  ,     4  4  ,     4  7  ,     9  3  ,     9  ,     1  0  ,     1  3  ,     3  2  ,     4  4  ,     4  7  ,     9  3  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     9  1  ,     9  3  ,     1  2  3  ,     9  ,     1  0  ,     3  4  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     9  1  ,     9  3  ,     1  2  3  ,     9  ,     1  0  ,     4  2  ,     4  7  ,     4  2  ,     4  7  ,     1  3  ,     3  2  ,     3  4  ,     4  4  ,     4  7  ,     5  8  ,     9  1  ,     9  3  ,     1  2  3  ,     9  ,     1  0  ,     4  2  ,     4  7  ,     4  2  ,     4  7  ,     4  2  ,     4  7  ,     1  3  ,     3  2  ,     4  7  ,     9  ,     1  0  ,     1  3  ,     3  2  ,     4  7  ,     9  ,     1  0  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__json_trans_keys_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     3  5  ,     1  ,     3  ,     0  ,     4  ,     3  6  ,     3  6  ,     3  6  ,     3  6  ,     1  ,     6  ,     5  ,     1  3  ,     1  7  ,     2  2  ,     3  7  ,     7  ,     8  ,     9  ,     7  ,     8  ,     9  ,     7  ,     1  0  ,     2  0  ,     2  1  ,     1  1  ,     1  1  ,     1  1  ,     1  2  ,     1  7  ,     1  9  ,     3  7  ,     1  1  ,     1  2  ,     1  9  ,     1  4  ,     1  6  ,     1  5  ,     1  4  ,     1  2  ,     1  8  ,     1  7  ,     1  1  ,     9  ,     5  ,     2  4  ,     2  3  ,     2  7  ,     3  1  ,     3  4  ,     2  5  ,     3  8  ,     2  5  ,     2  5  ,     2  6  ,     3  1  ,     3  3  ,     3  8  ,     2  5  ,     2  6  ,     3  3  ,     2  8  ,     3  0  ,     2  9  ,     2  8  ,     2  6  ,     3  2  ,     3  1  ,     2  5  ,     2  3  ,     2  ,     3  6  ,     2     }  ;", "}", "METHOD_END"], "methodName": ["init__json_trans_targs_0"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "addChild ( name ,    new   JsonValue ( value ,    stringValue )  )  ;", "}", "METHOD_END"], "methodName": ["number"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "addChild ( name ,    new   JsonValue ( value ,    stringValue )  )  ;", "}", "METHOD_END"], "methodName": ["number"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "int   cs ;", "int   p    =    offset ;", "int   pe    =    length ;", "int   eof    =    pe ;", "int   top    =     0  ;", "int [  ]    stack    =    new   int [  4  ]  ;", "int   s    =     0  ;", "Array < String >    names    =    new   Array (  8  )  ;", "boolean   needsUnescape    =    false ;", "boolean   stringIsName    =    false ;", "boolean   stringIsUnquoted    =    false ;", "RuntimeException   parseRuntimeEx    =    null ;", "boolean   debug    =    false ;", "if    ( debug )", "System . out . println (  )  ;", "try    {", "{", "cs    =     . json _ start ;", "top    =     0  ;", "}", "{", "int    _ klen ;", "int    _ trans    =     0  ;", "int    _ acts ;", "int    _ nacts ;", "int    _ keys ;", "int    _ goto _ targ    =     0  ;", "_ goto    :    while    ( true )     {", "switch    (  _ goto _ targ )     {", "case    0     :", "if    ( p    =  =    pe )     {", "_ goto _ targ    =     4  ;", "continue    _ goto ;", "}", "if    ( cs    =  =     0  )     {", "_ goto _ targ    =     5  ;", "continue    _ goto ;", "}", "case    1     :", "_ match    :    do    {", "_ keys    =     .  _ json _ key _ offsets [ cs ]  ;", "_ trans    =     .  _ json _ index _ offsets [ cs ]  ;", "_ klen    =     .  _ json _ single _ lengths [ cs ]  ;", "if    (  _ klen    >     0  )     {", "int    _ lower    =     _ keys ;", "int    _ mid ;", "int    _ upper    =     (  _ keys    +     _ klen )     -     1  ;", "while    ( true )     {", "if    (  _ upper    <     _ lower )", "break ;", "_ mid    =     _ lower    +     (  (  _ upper    -     _ lower )     >  >     1  )  ;", "if    (  ( data [ p ]  )     <     (  .  _ json _ trans _ keys [  _ mid ]  )  )", "_ upper    =     _ mid    -     1  ;", "else", "if    (  ( data [ p ]  )     >     (  .  _ json _ trans _ keys [  _ mid ]  )  )", "_ lower    =     _ mid    +     1  ;", "else    {", "_ trans    +  =     _ mid    -     _ keys ;", "break    _ match ;", "}", "}", "_ keys    +  =     _ klen ;", "_ trans    +  =     _ klen ;", "}", "_ klen    =     .  _ json _ range _ lengths [ cs ]  ;", "if    (  _ klen    >     0  )     {", "int    _ lower    =     _ keys ;", "int    _ mid ;", "int    _ upper    =     (  _ keys    +     (  _ klen    <  <     1  )  )     -     2  ;", "while    ( true )     {", "if    (  _ upper    <     _ lower )", "break ;", "_ mid    =     _ lower    +     (  (  (  _ upper    -     _ lower )     >  >     1  )     &     (  ~  1  )  )  ;", "if    (  ( data [ p ]  )     <     (  .  _ json _ trans _ keys [  _ mid ]  )  )", "_ upper    =     _ mid    -     2  ;", "else", "if    (  ( data [ p ]  )     >     (  .  _ json _ trans _ keys [  (  _ mid    +     1  )  ]  )  )", "_ lower    =     _ mid    +     2  ;", "else    {", "_ trans    +  =     (  _ mid    -     _ keys )     >  >     1  ;", "break    _ match ;", "}", "}", "_ trans    +  =     _ klen ;", "}", "}    while    ( false    )  ;", "_ trans    =     .  _ json _ indicies [  _ trans ]  ;", "cs    =     .  _ json _ trans _ targs [  _ trans ]  ;", "if    (  (  .  _ json _ trans _ actions [  _ trans ]  )     !  =     0  )     {", "_ acts    =     .  _ json _ trans _ actions [  _ trans ]  ;", "_ nacts    =     (  ( int )     (  .  _ json _ actions [  (  _ acts +  +  )  ]  )  )  ;", "while    (  (  _ nacts -  -  )     >     0  )     {", "switch    (  .  _ json _ actions [  (  _ acts +  +  )  ]  )     {", "case    0     :", "{", "stringIsName    =    true ;", "}", "break ;", "case    1     :", "{", "String   value    =    new   String ( data ,    s ,     ( p    -    s )  )  ;", "if    ( needsUnescape )", "value    =    unescape ( value )  ;", "outer    :    if    ( stringIsName )     {", "stringIsName    =    false ;", "if    ( debug )", "System . out . println (  (  \" name :     \"     +    value )  )  ;", "names . add ( value )  ;", "} else    {", "String   name    =     (  ( names . size )     >     0  )     ?    names . pop (  )     :    null ;", "if    ( stringIsUnquoted )     {", "if    ( value . equals (  \" true \"  )  )     {", "if    ( debug )", "System . out . println (  (  (  \" boolean :     \"     +    name )     +     \"  = true \"  )  )  ;", "bool ( name ,    true )  ;", "break   outer ;", "} else", "if    ( value . equals (  \" false \"  )  )     {", "if    ( debug )", "System . out . println (  (  (  \" boolean :     \"     +    name )     +     \"  = false \"  )  )  ;", "bool ( name ,    false )  ;", "break   outer ;", "} else", "if    ( value . equals (  \" null \"  )  )     {", "string ( name ,    null )  ;", "break   outer ;", "}", "boolean   couldBeDouble    =    false ;", "boolean   couldBeLong    =    true ;", "outer 2     :    for    ( int   i    =    s ;    i    <    p ;    i +  +  )     {", "switch    ( data [ i ]  )     {", "case    '  0  '     :", "case    '  1  '     :", "case    '  2  '     :", "case    '  3  '     :", "case    '  4  '     :", "case    '  5  '     :", "case    '  6  '     :", "case    '  7  '     :", "case    '  8  '     :", "case    '  9  '     :", "case    '  -  '     :", "case    '  +  '     :", "break ;", "case    '  .  '     :", "case    ' e '     :", "case    ' E '     :", "couldBeDouble    =    true ;", "couldBeLong    =    false ;", "break ;", "default    :", "couldBeDouble    =    false ;", "couldBeLong    =    false ;", "break   outer 2  ;", "}", "}", "if    ( couldBeDouble )     {", "try    {", "if    ( debug )", "System . out . println (  (  (  (  \" double :     \"     +    name )     +     \"  =  \"  )     +     ( Double . parseDouble ( value )  )  )  )  ;", "number ( name ,    Double . parseDouble ( value )  ,    value )  ;", "break   outer ;", "}    catch    ( NumberFormatException   ignored )     {", "}", "} else", "if    ( couldBeLong )     {", "if    ( debug )", "System . out . println (  (  (  (  \" double :     \"     +    name )     +     \"  =  \"  )     +     ( Double . parseDouble ( value )  )  )  )  ;", "try    {", "number ( name ,    Long . parseLong ( value )  ,    value )  ;", "break   outer ;", "}    catch    ( NumberFormatException   ignored )     {", "}", "}", "}", "if    ( debug )", "System . out . println (  (  (  (  \" string :     \"     +    name )     +     \"  =  \"  )     +    value )  )  ;", "string ( name ,    value )  ;", "}", "stringIsUnquoted    =    false ;", "s    =    p ;", "}", "break ;", "case    2     :", "{", "String   name    =     (  ( names . size )     >     0  )     ?    names . pop (  )     :    null ;", "if    ( debug )", "System . out . println (  (  \" startObject :     \"     +    name )  )  ;", "startObject ( name )  ;", "{", "if    ( top    =  =     ( stack . length )  )     {", "int [  ]    newStack    =    new   int [  ( stack . length )     *     2  ]  ;", "System . arraycopy ( stack ,     0  ,    newStack ,     0  ,    stack . length )  ;", "stack    =    newStack ;", "}", "{", "stack [  ( top +  +  )  ]     =    cs ;", "cs    =     5  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "}", "break ;", "case    3     :", "{", "if    ( debug )", "System . out . println (  \" endObject \"  )  ;", "pop (  )  ;", "{", "cs    =    stack [  (  -  - top )  ]  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "break ;", "case    4     :", "{", "String   name    =     (  ( names . size )     >     0  )     ?    names . pop (  )     :    null ;", "if    ( debug )", "System . out . println (  (  \" startArray :     \"     +    name )  )  ;", "startArray ( name )  ;", "{", "if    ( top    =  =     ( stack . length )  )     {", "int [  ]    newStack    =    new   int [  ( stack . length )     *     2  ]  ;", "System . arraycopy ( stack ,     0  ,    newStack ,     0  ,    stack . length )  ;", "stack    =    newStack ;", "}", "{", "stack [  ( top +  +  )  ]     =    cs ;", "cs    =     2  3  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "}", "break ;", "case    5     :", "{", "if    ( debug )", "System . out . println (  \" endArray \"  )  ;", "pop (  )  ;", "{", "cs    =    stack [  (  -  - top )  ]  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "break ;", "case    6     :", "{", "int   start    =    p    -     1  ;", "if    (  ( data [  ( p +  +  )  ]  )     =  =     '  /  '  )     {", "while    (  ( p    !  =    eof )     &  &     (  ( data [ p ]  )     !  =     '  \\ n '  )  )", "p +  +  ;", "p -  -  ;", "} else    {", "while    (  (  (  ( p    +     1  )     <    eof )     &  &     (  ( data [ p ]  )     !  =     '  *  '  )  )     |  |     (  ( data [  ( p    +     1  )  ]  )     !  =     '  /  '  )  )", "p +  +  ;", "p +  +  ;", "}", "if    ( debug )", "System . out . println (  (  \" comment    \"     +     ( new   String ( data ,    start ,     ( p    -    start )  )  )  )  )  ;", "}", "break ;", "case    7     :", "{", "if    ( debug )", "System . out . println (  \" unquotedChars \"  )  ;", "s    =    p ;", "needsUnescape    =    false ;", "stringIsUnquoted    =    true ;", "if    ( stringIsName )     {", "outer    :    while    ( true )     {", "switch    ( data [ p ]  )     {", "case    '  \\  \\  '     :", "needsUnescape    =    true ;", "break ;", "case    '  /  '     :", "if    (  ( p    +     1  )     =  =    eof )", "break ;", "char   c    =    data [  ( p    +     1  )  ]  ;", "if    (  ( c    =  =     '  /  '  )     |  |     ( c    =  =     '  *  '  )  )", "break   outer ;", "break ;", "case    '  :  '     :", "case    '  \\ r '     :", "case    '  \\ n '     :", "break   outer ;", "}", "if    ( debug )", "System . out . println (  (  (  \" unquotedChar    ( name )  :     '  \"     +     ( data [ p ]  )  )     +     \"  '  \"  )  )  ;", "p +  +  ;", "if    ( p    =  =    eof )", "break ;", "}", "} else    {", "outer    :    while    ( true )     {", "switch    ( data [ p ]  )     {", "case    '  \\  \\  '     :", "needsUnescape    =    true ;", "break ;", "case    '  /  '     :", "if    (  ( p    +     1  )     =  =    eof )", "break ;", "char   c    =    data [  ( p    +     1  )  ]  ;", "if    (  ( c    =  =     '  /  '  )     |  |     ( c    =  =     '  *  '  )  )", "break   outer ;", "break ;", "case    '  }  '     :", "case    '  ]  '     :", "case    '  ,  '     :", "case    '  \\ r '     :", "case    '  \\ n '     :", "break   outer ;", "}", "if    ( debug )", "System . out . println (  (  (  \" unquotedChar    ( value )  :     '  \"     +     ( data [ p ]  )  )     +     \"  '  \"  )  )  ;", "p +  +  ;", "if    ( p    =  =    eof )", "break ;", "}", "}", "p -  -  ;", "while    ( Character . isSpace ( data [ p ]  )  )", "p -  -  ;", "}", "break ;", "case    8     :", "{", "if    ( debug )", "System . out . println (  \" quotedChars \"  )  ;", "s    =     +  + p ;", "needsUnescape    =    false ;", "outer    :    while    ( true )     {", "switch    ( data [ p ]  )     {", "case    '  \\  \\  '     :", "needsUnescape    =    true ;", "p +  +  ;", "break ;", "case    '  \"  '     :", "break   outer ;", "}", "p +  +  ;", "if    ( p    =  =    eof )", "break ;", "}", "p -  -  ;", "}", "break ;", "}", "}", "}", "case    2     :", "if    ( cs    =  =     0  )     {", "_ goto _ targ    =     5  ;", "continue    _ goto ;", "}", "if    (  (  +  + p )     !  =    pe )     {", "_ goto _ targ    =     1  ;", "continue    _ goto ;", "}", "case    4     :", "if    ( p    =  =    eof )     {", "int    _  _ acts    =     .  _ json _ eof _ actions [ cs ]  ;", "int    _  _ nacts    =     (  ( int )     (  .  _ json _ actions [  (  _  _ acts +  +  )  ]  )  )  ;", "while    (  (  _  _ nacts -  -  )     >     0  )     {", "switch    (  .  _ json _ actions [  (  _  _ acts +  +  )  ]  )     {", "case    1     :", "{", "String   value    =    new   String ( data ,    s ,     ( p    -    s )  )  ;", "if    ( needsUnescape )", "value    =    unescape ( value )  ;", "outer    :    if    ( stringIsName )     {", "stringIsName    =    false ;", "if    ( debug )", "System . out . println (  (  \" name :     \"     +    value )  )  ;", "names . add ( value )  ;", "} else    {", "String   name    =     (  ( names . size )     >     0  )     ?    names . pop (  )     :    null ;", "if    ( stringIsUnquoted )     {", "if    ( value . equals (  \" true \"  )  )     {", "if    ( debug )", "System . out . println (  (  (  \" boolean :     \"     +    name )     +     \"  = true \"  )  )  ;", "bool ( name ,    true )  ;", "break   outer ;", "} else", "if    ( value . equals (  \" false \"  )  )     {", "if    ( debug )", "System . out . println (  (  (  \" boolean :     \"     +    name )     +     \"  = false \"  )  )  ;", "bool ( name ,    false )  ;", "break   outer ;", "} else", "if    ( value . equals (  \" null \"  )  )     {", "string ( name ,    null )  ;", "break   outer ;", "}", "boolean   couldBeDouble    =    false ;", "boolean   couldBeLong    =    true ;", "outer 2     :    for    ( int   i    =    s ;    i    <    p ;    i +  +  )     {", "switch    ( data [ i ]  )     {", "case    '  0  '     :", "case    '  1  '     :", "case    '  2  '     :", "case    '  3  '     :", "case    '  4  '     :", "case    '  5  '     :", "case    '  6  '     :", "case    '  7  '     :", "case    '  8  '     :", "case    '  9  '     :", "case    '  -  '     :", "case    '  +  '     :", "break ;", "case    '  .  '     :", "case    ' e '     :", "case    ' E '     :", "couldBeDouble    =    true ;", "couldBeLong    =    false ;", "break ;", "default    :", "couldBeDouble    =    false ;", "couldBeLong    =    false ;", "break   outer 2  ;", "}", "}", "if    ( couldBeDouble )     {", "try    {", "if    ( debug )", "System . out . println (  (  (  (  \" double :     \"     +    name )     +     \"  =  \"  )     +     ( Double . parseDouble ( value )  )  )  )  ;", "number ( name ,    Double . parseDouble ( value )  ,    value )  ;", "break   outer ;", "}    catch    ( NumberFormatException   ignored )     {", "}", "} else", "if    ( couldBeLong )     {", "if    ( debug )", "System . out . println (  (  (  (  \" double :     \"     +    name )     +     \"  =  \"  )     +     ( Double . parseDouble ( value )  )  )  )  ;", "try    {", "number ( name ,    Long . parseLong ( value )  ,    value )  ;", "break   outer ;", "}    catch    ( NumberFormatException   ignored )     {", "}", "}", "}", "if    ( debug )", "System . out . println (  (  (  (  \" string :     \"     +    name )     +     \"  =  \"  )     +    value )  )  ;", "string ( name ,    value )  ;", "}", "stringIsUnquoted    =    false ;", "s    =    p ;", "}", "break ;", "}", "}", "}", "case    5     :", "}", "break ;", "}", "}", "}    catch    ( RuntimeException   ex )     {", "parseRuntimeEx    =    ex ;", "}", "JsonValue   root    =    this . root ;", "this . root    =    null ;", "current    =    null ;", "lastChild . clear (  )  ;", "if    ( p    <    pe )     {", "int   lineNumber    =     1  ;", "for    ( int   i    =     0  ;    i    <    p ;    i +  +  )", "if    (  ( data [ i ]  )     =  =     '  \\ n '  )", "lineNumber +  +  ;", "int   start    =    Math . max (  0  ,     ( p    -     3  2  )  )  ;", "throw   new   SerializationException (  (  (  (  (  (  \" Error   parsing   JSON   on   line    \"     +    lineNumber )     +     \"    near :     \"  )     +     ( new   String ( data ,    start ,     ( p    -    start )  )  )  )     +     \"  * ERROR *  \"  )     +     ( new   String ( data ,    p ,    Math . min (  6  4  ,     ( pe    -    p )  )  )  )  )  ,    parseRuntimeEx )  ;", "} else", "if    (  ( elements . size )     !  =     0  )     {", "JsonValue   element    =    elements . peek (  )  ;", "elements . clear (  )  ;", "if    (  ( element    !  =    null )     &  &     ( element . isObject (  )  )  )", "throw   new   SerializationException (  \" Error   parsing   JSON ,    unmatched   brace .  \"  )  ;", "else", "throw   new   SerializationException (  \" Error   parsing   JSON ,    unmatched   bracket .  \"  )  ;", "} else", "if    ( parseRuntimeEx    !  =    null )     {", "throw   new   SerializationException (  (  \" Error   parsing   JSON :     \"     +     ( new   String ( data )  )  )  ,    parseRuntimeEx )  ;", "}", "return   root ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   parse ( file . r (  \" UTF -  8  \"  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SerializationException (  (  \" Error   parsing   file :     \"     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   parse ( new   InputStream ( input ,     \" UTF -  8  \"  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( input )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "char [  ]    data    =    new   char [  1  0  2  4  ]  ;", "int   offset    =     0  ;", "while    ( true )     {", "int   length    =    r . read ( data ,    offset ,     (  ( data . length )     -    offset )  )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "if    ( length    =  =     0  )     {", "char [  ]    newData    =    new   char [  ( data . length )     *     2  ]  ;", "System . arraycopy ( data ,     0  ,    newData ,     0  ,    data . length )  ;", "data    =    newData ;", "} else", "offset    +  =    length ;", "}", "return   parse ( data ,     0  ,    offset )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( r )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    data    =    json . toCharArray (  )  ;", "return   parse ( data ,     0  ,    data . length )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "root    =    elements . pop (  )  ;", "if    (  ( current . size )     >     0  )", "lastChild . pop (  )  ;", "current    =     (  ( elements . size )     >     0  )     ?    elements . peek (  )     :    null ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   value    =    new   JsonValue ( JsonValue . ValueType . array )  ;", "if    (  ( current )     !  =    null )", "addChild ( name ,    value )  ;", "elements . add ( value )  ;", "current    =    value ;", "}", "METHOD_END"], "methodName": ["startArray"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   value    =    new   JsonValue ( JsonValue . ValueType . object )  ;", "if    (  ( current )     !  =    null )", "addChild ( name ,    value )  ;", "elements . add ( value )  ;", "current    =    value ;", "}", "METHOD_END"], "methodName": ["startObject"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "addChild ( name ,    new   JsonValue ( value )  )  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "int   length    =    value . length (  )  ;", "StringBuil   buffer    =    new   StringBuil (  ( length    +     1  6  )  )  ;", "for    ( int   i    =     0  ;    i    <    length ;  )     {", "char   c    =    value . charAt (  ( i +  +  )  )  ;", "if    ( c    !  =     '  \\  \\  '  )     {", "buffer . append ( c )  ;", "continue ;", "}", "if    ( i    =  =    length )", "break ;", "c    =    value . charAt (  ( i +  +  )  )  ;", "if    ( c    =  =     ' u '  )     {", "buffer . append ( Character . toChars ( Integer . parseInt ( value . substring ( i ,     ( i    +     4  )  )  ,     1  6  )  )  )  ;", "i    +  =     4  ;", "continue ;", "}", "switch    ( c )     {", "case    '  \"  '     :", "case    '  \\  \\  '     :", "case    '  /  '     :", "break ;", "case    ' b '     :", "c    =     '  \\ b '  ;", "break ;", "case    ' f '     :", "c    =     '  \\ f '  ;", "break ;", "case    ' n '     :", "c    =     '  \\ n '  ;", "break ;", "case    ' r '     :", "c    =     '  \\ r '  ;", "break ;", "case    ' t '     :", "c    =     '  \\ t '  ;", "break ;", "default    :", "throw   new   SerializationException (  (  \" Illegal   escaped   character :     \\  \\  \"     +    c )  )  ;", "}", "buffer . append ( c )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["unescape"], "fileName": "com.badlogic.gdx.utils.JsonReader"}, {"methodBody": ["METHOD_START", "{", "value . parent    =    this ;", "current    =    child ;", "if    ( current    =  =    null )", "child    =    value ;", "else    {", "while    ( true )     {", "if    (  ( current . next )     =  =    null )     {", "current . next    =    value ;", "return ;", "}", "current    =    current . next ;", "}", "}", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "value . name    =    name ;", "addChild ( value )  ;", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   stringValue . equalsIgnoreCase (  \" true \"  )  ;", "case   doubleValue    :", "return    ( doubleValue )     !  =     0  ;", "case   longValue    :", "return    ( longValue )     !  =     0  ;", "case   boolea    :", "return    ( longValue )     !  =     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   boolean :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asBoolean"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "boolean [  ]    array    =    new   boolean [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "boolean   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    Boolean . parseBoolean ( value . stringValue )  ;", "break ;", "case   doubleValue    :", "v    =     ( value . doubleValue )     =  =     0  ;", "break ;", "case   longValue    :", "v    =     ( value . longValue )     =  =     0  ;", "break ;", "case   booleanValue    :", "v    =     ( value . longValue )     !  =     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   boolean :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asBooleanArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   Byte . parseByte ( stringValue )  ;", "case   doubleValue    :", "return    (  ( byte )     ( doubleValue )  )  ;", "case   longValue    :", "return    (  ( byte )     ( longValue )  )  ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     (  ( byte )     (  1  )  )     :     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   byte :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asByte"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "byte [  ]    array    =    new   byte [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "byte   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    Byte . parseByte ( value . stringValue )  ;", "break ;", "case   doubleValue    :", "v    =     (  ( byte )     ( value . doubleValue )  )  ;", "break ;", "case   longValue    :", "v    =     (  ( byte )     ( value . longValue )  )  ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     (  ( byte )     (  1  )  )     :     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   byte :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asByteArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return    ( stringValue . length (  )  )     =  =     0     ?     0     :    stringValue . charAt (  0  )  ;", "case   doubleValue    :", "return    (  ( char )     ( doubleValue )  )  ;", "case   longValue    :", "return    (  ( char )     ( longValue )  )  ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     (  ( char )     (  1  )  )     :     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   char :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asChar"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "char [  ]    array    =    new   char [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "char   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =     (  ( value . stringValue . length (  )  )     =  =     0  )     ?     0     :    value . stringValue . charAt (  0  )  ;", "break ;", "case   doubleValue    :", "v    =     (  ( char )     ( value . doubleValue )  )  ;", "break ;", "case   longValue    :", "v    =     (  ( char )     ( value . longValue )  )  ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     (  ( char )     (  1  )  )     :     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   char :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asCharArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   Double . parseDouble ( stringValue )  ;", "case   doubleValue    :", "return   doubleValue ;", "case   longValue    :", "return    (  ( double )     ( longValue )  )  ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     1     :     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   double :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asDouble"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "double [  ]    array    =    new   double [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "double   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    Double . parseDouble ( value . stringValue )  ;", "break ;", "case   doubleValue    :", "v    =    value . doubleValue ;", "break ;", "case   longValue    :", "v    =     (  ( double )     ( value . longValue )  )  ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     1     :     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   double :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asDoubleArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   Float . parseFloat ( stringValue )  ;", "case   doubleValue    :", "return    (  ( float )     ( doubleValue )  )  ;", "case   longValue    :", "return    (  ( float )     ( longValue )  )  ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     1     :     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   float :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asFloat"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "float [  ]    array    =    new   float [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "float   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    Float . parseFloat ( value . stringValue )  ;", "break ;", "case   doubleValue    :", "v    =     (  ( float )     ( value . doubleValue )  )  ;", "break ;", "case   longValue    :", "v    =     (  ( float )     ( value . longValue )  )  ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     1     :     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   float :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asFloatArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   Integer . parseInt ( stringValue )  ;", "case   doubleValue    :", "return    (  ( int )     ( doubleValue )  )  ;", "case   longValue    :", "return    (  ( int )     ( longValue )  )  ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     1     :     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   int :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asInt"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "int [  ]    array    =    new   int [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "int   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    Integer . parseInt ( value . stringValue )  ;", "break ;", "case   doubleValue    :", "v    =     (  ( int )     ( value . doubleValue )  )  ;", "break ;", "case   longValue    :", "v    =     (  ( int )     ( value . longValue )  )  ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     1     :     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   int :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asIntArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   Long . parseLong ( stringValue )  ;", "case   doubleValue    :", "return    (  ( long )     ( doubleValue )  )  ;", "case   longValue    :", "return   longValue ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     1     :     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   long :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asLong"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "long [  ]    array    =    new   long [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "long   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    Long . parseLong ( value . stringValue )  ;", "break ;", "case   doubleValue    :", "v    =     (  ( long )     ( value . doubleValue )  )  ;", "break ;", "case   longValue    :", "v    =    value . longValue ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     1     :     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   long :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asLongArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   Short . parseShort ( stringValue )  ;", "case   doubleValue    :", "return    (  ( short )     ( doubleValue )  )  ;", "case   longValue    :", "return    (  ( short )     ( longValue )  )  ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     (  ( short )     (  1  )  )     :     0  ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   short :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asShort"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "short [  ]    array    =    new   short [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "short   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    Short . parseShort ( value . stringValue )  ;", "break ;", "case   doubleValue    :", "v    =     (  ( short )     ( value . doubleValue )  )  ;", "break ;", "case   longValue    :", "v    =     (  ( short )     ( value . longValue )  )  ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     (  ( short )     (  1  )  )     :     0  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   short :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asShortArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "return   stringValue ;", "case   doubleValue    :", "return    ( stringValue )     !  =    null    ?    stringValue    :    Double . toString ( doubleValue )  ;", "case   longValue    :", "return    ( stringValue )     !  =    null    ?    stringValue    :    Long . toString ( longValue )  ;", "case   boolea    :", "return    ( longValue )     !  =     0     ?     \" true \"     :     \" false \"  ;", "case   nullValue    :", "return   null ;", "}", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   string :     \"     +     ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     !  =     ( JsonValue . ValueType . array )  )", "throw   new   IllegalStateException (  (  \" Value   is   not   an   array :     \"     +     ( type )  )  )  ;", "String [  ]    array    =    new   String [ size ]  ;", "int   i    =     0  ;", "for    ( JsonValue   value    =    child ;    value    !  =    null ;    value    =    value . next    ,    i +  +  )     {", "String   v ;", "switch    ( value . type )     {", "case   stringValue    :", "v    =    value . stringValue ;", "break ;", "case   doubleValue    :", "v    =     (  ( stringValue )     !  =    null )     ?    stringValue    :    Double . toString ( value . doubleValue )  ;", "break ;", "case   longValue    :", "v    =     (  ( stringValue )     !  =    null )     ?    stringValue    :    Long . toString ( value . longValue )  ;", "break ;", "case   booleanValue    :", "v    =     (  ( value . longValue )     !  =     0  )     ?     \" true \"     :     \" false \"  ;", "break ;", "case   nullValue    :", "v    =    null ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Value   cannot   be   converted   to   string :     \"     +     ( value . type )  )  )  ;", "}", "array [ i ]     =    v ;", "}", "return   array ;", "}", "METHOD_END"], "methodName": ["asStringArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   child ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   current    =    child ;", "while    (  ( current    !  =    null )     &  &     ( index    >     0  )  )     {", "index -  -  ;", "current    =    current . next ;", "}", "return   current ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   current    =    child ;", "while    (  ( current    !  =    null )     &  &     (  (  ( current . name )     =  =    null )     |  |     (  !  ( current . name . equalsIgnoreCase ( name )  )  )  )  )", "current    =    current . next ;", "return   current ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["getBoolean"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["getBoolean"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["getBoolean"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asByte (  )  ;", "}", "METHOD_END"], "methodName": ["getByte"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asByte (  )  ;", "}", "METHOD_END"], "methodName": ["getByte"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asByte (  )  ;", "}", "METHOD_END"], "methodName": ["getByte"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asChar (  )  ;", "}", "METHOD_END"], "methodName": ["getChar"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asChar (  )  ;", "}", "METHOD_END"], "methodName": ["getChar"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asChar (  )  ;", "}", "METHOD_END"], "methodName": ["getChar"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return   child    =  =    null    ?    null    :    child . child ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asDouble (  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asDouble (  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asDouble (  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asFloat (  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asFloat (  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asFloat (  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asInt (  )  ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asInt (  )  ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asInt (  )  ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asLong (  )  ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asLong (  )  ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asLong (  )  ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asShort (  )  ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asShort (  )  ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )     ?    defaultValue    :    child . asShort (  )  ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Indexed   value   not   found :     \"     +     ( name )  )  )  ;", "return   child . asString (  )  ;", "}", "METHOD_END"], "methodName": ["getString"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Named   value   not   found :     \"     +    name )  )  ;", "return   child . asString (  )  ;", "}", "METHOD_END"], "methodName": ["getString"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "return    (  ( child    =  =    null )     |  |     (  !  ( child . isValue (  )  )  )  )     |  |     ( child . isNull (  )  )     ?    defaultValue    :    child . asString (  )  ;", "}", "METHOD_END"], "methodName": ["getString"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( get ( name )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["has"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( getChild ( name )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasChild"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "buffer . append (  '  \\ t '  )  ;", "}", "METHOD_END"], "methodName": ["indent"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     =  =     ( JsonValue . ValueType . array )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     =  =     ( JsonValue . ValueType . booleanValue )  ;", "}", "METHOD_END"], "methodName": ["isBoolean"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     =  =     ( JsonValue . ValueType . doubleValue )  ;", "}", "METHOD_END"], "methodName": ["isDouble"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "for    ( JsonValue   child    =    object . child ;    child    !  =    null ;    child    =    child . next )", "if    (  ( child . isObject (  )  )     |  |     ( child . isArray (  )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isFlat"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     =  =     ( JsonValue . ValueType . longValue )  ;", "}", "METHOD_END"], "methodName": ["isLong"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     =  =     ( JsonValue . ValueType . nullValue )  ;", "}", "METHOD_END"], "methodName": ["isNull"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    (  ( type )     =  =     ( JsonValue . ValueType . doubleValue )  )     |  |     (  ( type )     =  =     ( JsonValue . ValueType . longValue )  )  ;", "}", "METHOD_END"], "methodName": ["isNumber"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "for    ( JsonValue   child    =    object . child ;    child    !  =    null ;    child    =    child . next )", "if    (  !  ( child . isNumber (  )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isNumeric"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     =  =     ( JsonValue . ValueType . object )  ;", "}", "METHOD_END"], "methodName": ["isObject"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     =  =     ( JsonValue . ValueType . stringValue )  ;", "}", "METHOD_END"], "methodName": ["isString"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   stringValue    :", "case   doubleValue    :", "case   longValue    :", "case   boolea    :", "case   nullValue    :", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isValue"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonValue . JsonIterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    ( object . isObject (  )  )     {", "if    (  ( object . child )     =  =    null )", "buffer . append (  \"  {  }  \"  )  ;", "else    {", "int   start    =    buffer . length (  )  ;", "while    ( true )     {", "buffer . append (  '  {  '  )  ;", "int   i    =     0  ;", "for    (    child    =    object . child ;    child    !  =    null ;    child    =    child . next )     {", "buffer . append ( outputType . quoteName ( child . name )  )  ;", "buffer . append (  '  :  '  )  ;", "json ( child ,    buffer ,    outputType )  ;", "if    (  ( child . next )     !  =    null )", "buffer . append (  '  ,  '  )  ;", "}", "break ;", "}", "buffer . append (  '  }  '  )  ;", "}", "} else", "if    ( object . isArray (  )  )     {", "if    (  ( object . child )     =  =    null )", "buffer . append (  \"  [  ]  \"  )  ;", "else    {", "int   start    =    buffer . length (  )  ;", "while    ( true )     {", "buffer . append (  '  [  '  )  ;", "for    (    child    =    object . child ;    child    !  =    null ;    child    =    child . next )     {", "json ( child ,    buffer ,    outputType )  ;", "if    (  ( child . next )     !  =    null )", "buffer . append (  '  ,  '  )  ;", "}", "break ;", "}", "buffer . append (  '  ]  '  )  ;", "}", "} else", "if    ( object . isString (  )  )     {", "buffer . append ( outputType . quoteValue ( object . asString (  )  )  )  ;", "} else", "if    ( object . isDouble (  )  )     {", "double   doubleValue    =    object . asDouble (  )  ;", "long   longValue    =    object . asLong (  )  ;", "buffer . append (  ( doubleValue    =  =    longValue    ?    longValue    :    doubleValue )  )  ;", "} else", "if    ( object . isLong (  )  )     {", "buffer . append ( object . asLong (  )  )  ;", "} else", "if    ( object . isBoolean (  )  )     {", "buffer . append ( object . asBoolean (  )  )  ;", "} else", "if    ( object . isNull (  )  )     {", "buffer . append (  \" null \"  )  ;", "} else", "throw   new   SerializationException (  (  \" Unknown   object   type :     \"     +    object )  )  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   next ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buffer    =    new   StringBuilder (  5  1  2  )  ;", "prettyPrint ( this ,    buffer ,     0  ,    settings )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonWriter . OutputType   outputType    =    settings . outputType ;", "if    ( object . isObject (  )  )     {", "if    (  ( object . child )     =  =    null )", "buffer . append (  \"  {  }  \"  )  ;", "else    {", "boolean   newLines    =     !  (  . isFlat ( object )  )  ;", "int   start    =    buffer . length (  )  ;", "outer    :    while    ( true )     {", "buffer . append (  ( newLines    ?     \"  {  \\ n \"     :     \"  {     \"  )  )  ;", "int   i    =     0  ;", "for    (    child    =    object . child ;    child    !  =    null ;    child    =    child . next )     {", "if    ( newLines )", ". indent ( indent ,    buffer )  ;", "buffer . append ( outputType . quoteName ( child . name )  )  ;", "buffer . append (  \"  :     \"  )  ;", "prettyPrint ( child ,    buffer ,     ( indent    +     1  )  ,    settings )  ;", "if    (  (  (  ! newLines )     |  |     ( outputType    !  =     ( JsonWriter . OutputType . minimal )  )  )     &  &     (  ( child . next )     !  =    null )  )", "buffer . append (  '  ,  '  )  ;", "buffer . append (  ( newLines    ?     '  \\ n '     :     '     '  )  )  ;", "if    (  (  ! newLines )     &  &     (  (  ( buffer . length (  )  )     -    start )     >     ( settings . singleLineColumns )  )  )     {", "buffer . setLength ( start )  ;", "newLines    =    true ;", "continue   outer ;", "}", "}", "break ;", "}", "if    ( newLines )", ". indent (  ( indent    -     1  )  ,    buffer )  ;", "buffer . append (  '  }  '  )  ;", "}", "} else", "if    ( object . isArray (  )  )     {", "if    (  ( object . child )     =  =    null )", "buffer . append (  \"  [  ]  \"  )  ;", "else    {", "boolean   newLines    =     !  (  . isFlat ( object )  )  ;", "boolean   wrap    =     ( settings . wrapNumericArrays )     |  |     (  !  (  . isNumeric ( object )  )  )  ;", "int   start    =    buffer . length (  )  ;", "outer    :    while    ( true )     {", "buffer . append (  ( newLines    ?     \"  [  \\ n \"     :     \"  [     \"  )  )  ;", "for    (    child    =    object . child ;    child    !  =    null ;    child    =    child . next )     {", "if    ( newLines )", ". indent ( indent ,    buffer )  ;", "prettyPrint ( child ,    buffer ,     ( indent    +     1  )  ,    settings )  ;", "if    (  (  (  ! newLines )     |  |     ( outputType    !  =     ( JsonWriter . OutputType . minimal )  )  )     &  &     (  ( child . next )     !  =    null )  )", "buffer . append (  '  ,  '  )  ;", "buffer . append (  ( newLines    ?     '  \\ n '     :     '     '  )  )  ;", "if    (  ( wrap    &  &     (  ! newLines )  )     &  &     (  (  ( buffer . length (  )  )     -    start )     >     ( settings . singleLineColumns )  )  )     {", "buffer . setLength ( start )  ;", "newLines    =    true ;", "continue   outer ;", "}", "}", "break ;", "}", "if    ( newLines )", ". indent (  ( indent    -     1  )  ,    buffer )  ;", "buffer . append (  '  ]  '  )  ;", "}", "} else", "if    ( object . isString (  )  )     {", "buffer . append ( outputType . quoteValue ( object . asString (  )  )  )  ;", "} else", "if    ( object . isDouble (  )  )     {", "double   doubleValue    =    object . asDouble (  )  ;", "long   longValue    =    object . asLong (  )  ;", "buffer . append (  ( doubleValue    =  =    longValue    ?    longValue    :    doubleValue )  )  ;", "} else", "if    ( object . isLong (  )  )     {", "buffer . append ( object . asLong (  )  )  ;", "} else", "if    ( object . isBoolean (  )  )     {", "buffer . append ( object . asBoolean (  )  )  ;", "} else", "if    ( object . isNull (  )  )     {", "buffer . append (  \" null \"  )  ;", "} else", "throw   new   SerializationException (  (  \" Unknown   object   type :     \"     +    object )  )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue . PrettyPrintSettings   settings    =    new   JsonValue . PrettyPrintSettings (  )  ;", "settings . outputType    =    outputType ;", "settings . singleLineColumns    =    singleLineColumns ;", "return   prettyPrint ( settings )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   prev ;", "}", "METHOD_END"], "methodName": ["prev"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( index )  ;", "if    ( child    =  =    null )", "return   null ;", "if    (  ( child . prev )     =  =    null )     {", "this . child    =    child . next ;", "if    (  ( this . child )     !  =    null )", "this . child . prev    =    null ;", "} else    {", "child . prev . next    =    child . next ;", "if    (  ( child . next )     !  =    null )", "child . next . prev    =    child . prev ;", "}", "( size )  -  -  ;", "return   child ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   child    =    get ( name )  ;", "if    ( child    =  =    null )", "return   null ;", "if    (  ( child . prev )     =  =    null )     {", "this . child    =    child . next ;", "if    (  ( this . child )     !  =    null )", "this . child . prev    =    null ;", "} else    {", "child . prev . next    =    child . next ;", "if    (  ( child . next )     !  =    null )", "child . next . prev    =    child . prev ;", "}", "( size )  -  -  ;", "return   child ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   current    =    child ;", "while    (  ( current    !  =    null )     &  &     ( index    >     0  )  )     {", "index -  -  ;", "current    =    current . next ;", "}", "if    ( current    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Child   not   found   with   index :     \"     +    index )  )  ;", "return   current ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "JsonValue   current    =    child ;", "while    (  ( current    !  =    null )     &  &     (  (  ( current . name )     =  =    null )     |  |     (  !  ( current . name . equalsIgnoreCase ( name )  )  )  )  )", "current    =    current . next ;", "if    ( current    =  =    null )", "throw   new   IllegalArgumentException (  (  \" Child   not   found   with   name :     \"     +    name )  )  ;", "return   current ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "longValue    =     ( value )     ?     1     :     0  ;", "type    =     . ValueType . booleanValue ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "doubleValue    =    value ;", "longValue    =     (  ( long )     ( value )  )  ;", "this . stringValue    =    stringValue ;", "type    =     . ValueType . doubleValue ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "stringValue    =    value ;", "type    =     ( value    =  =    null )     ?     . ValueType . nullValue    :     . ValueType . stringValue ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "longValue    =    value ;", "doubleValue    =     (  ( double )     ( value )  )  ;", "this . stringValue    =    stringValue ;", "type    =     . ValueType . longValue ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "this . next    =    next ;", "}", "METHOD_END"], "methodName": ["setNext"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "this . prev    =    prev ;", "}", "METHOD_END"], "methodName": ["setPrev"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )", "throw   new   IllegalArgumentExcepon (  \" type   cannot   be   null .  \"  )  ;", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    ( isValue (  )  )", "return   asString (  )  ;", "StringBuilder   buffer    =    new   StringBuilder (  5  1  2  )  ;", "json ( this ,    buffer ,    outputType )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toJson"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    ( isValue (  )  )", "return    ( name )     =  =    null    ?    asString (  )     :     (  ( name )     +     \"  :     \"  )     +     ( asString (  )  )  ;", "return    (  ( name )     =  =    null    ?     \"  \"     :     ( name )     +     \"  :     \"  )     +     ( prettyPrint ( JsonWriter . OutputType . minimal ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     =  =    null )     {", "if    (  ( type )     =  =     (  . ValueType . array )  )", "return    \"  [  ]  \"  ;", "if    (  ( type )     =  =     (  . ValueType . object )  )", "return    \"  {  }  \"  ;", "return    \"  \"  ;", "}", "String   trace ;", "if    (  ( parent . type )     =  =     (  . ValueType . array )  )     {", "trace    =     \"  [  ]  \"  ;", "int   i    =     0  ;", "for    (    child    =    parent . child ;    child    !  =    null ;    child    =    child . next    ,    i +  +  )     {", "if    ( child    =  =     ( this )  )     {", "trace    =     (  \"  [  \"     +    i )     +     \"  ]  \"  ;", "break ;", "}", "}", "} else", "if    (  ( name . indexOf (  '  .  '  )  )     !  =     (  -  1  )  )", "trace    =     (  \"  .  \\  \"  \"     +     ( name . replace (  \"  \\  \"  \"  ,     \"  \\  \\  \\  \"  \"  )  )  )     +     \"  \\  \"  \"  ;", "else", "trace    =     '  .  '     +     ( name )  ;", "return    ( parent . trace (  )  )     +    trace ;", "}", "METHOD_END"], "methodName": ["trace"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.badlogic.gdx.utils.JsonValue"}, {"methodBody": ["METHOD_START", "{", "requireCommaOrName (  )  ;", "stack . add (  ( current    =    new    . JsonObject ( true )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . array (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "while    (  ( stack . size )     >     0  )", "pop (  )  ;", "w . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   writer ;", "}", "METHOD_END"], "methodName": ["getWriter"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "requireCommaOrName (  )  ;", "w . write ( json )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . json ( json )  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( current )     =  =    null )     |  |     ( current . array )  )", "throw   new   IllegalStateException (  \" Current   item   must   be   an   object .  \"  )  ;", "if    (  !  ( current . needsComma )  )", "current . needsComma    =    true ;", "else", "w . write (  '  ,  '  )  ;", "w . write ( outputType . quoteName ( name )  )  ;", "w . write (  '  :  '  )  ;", "named    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "requireCommaOrName (  )  ;", "stack . add (  ( current    =    new    . JsonObject ( false )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["object"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . object (  )  ;", "}", "METHOD_END"], "methodName": ["object"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( named )", "throw   new   IllegalStateExcepon (  \" Expected   an   object ,    array ,    or   value   since   a   name   was   set .  \"  )  ;", "stack . pop (  )  . close (  )  ;", "current    =     (  ( stack . size )     =  =     0  )     ?    null    :    stack . peek (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     =  =    null )", "return ;", "if    ( current . array )     {", "if    (  !  ( current . needsComma )  )", "current . needsComma    =    true ;", "else", "w . write (  '  ,  '  )  ;", "} else    {", "if    (  !  ( named )  )", "throw   new   IllegalStateException (  \" Name   must   be   set .  \"  )  ;", "named    =    false ;", "}", "}", "METHOD_END"], "methodName": ["requireCommaOrName"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "this . outputType    =    outputType ;", "}", "METHOD_END"], "methodName": ["setOutputType"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "this . quoteLongValues    =    quoteLongValues ;", "}", "METHOD_END"], "methodName": ["setQuoteLongValues"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( quoteLongValues )     &  &     (  (  (  ( value   instanceof   Long )     |  |     ( value   instanceof   Double )  )     |  |     ( value   instanceof   BigDecimal )  )     |  |     ( value   instanceof   BigInteger )  )  )     {", "value    =    value . toString (  )  ;", "} else", "if    ( value   instanceof   Number )     {", "Number   number    =     (  ( Number )     ( value )  )  ;", "long   longValue    =    number . longValue (  )  ;", "if    (  ( number . doubleValue (  )  )     =  =    longValue )", "value    =    longValue ;", "}", "requireCommaOrName (  )  ;", "w . write ( outputType . quoteValue ( value )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "writer . write ( cbuf ,    off ,    len )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.utils.JsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   din . readBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["readBoolean"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   din . readByte (  )  ;", "}", "METHOD_END"], "methodName": ["readByte"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   din . readChar (  )  ;", "}", "METHOD_END"], "methodName": ["readChar"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   Double . longBitsToDouble ( readLong (  )  )  ;", "}", "METHOD_END"], "methodName": ["readDouble"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   Float . intBitsToFloat ( readInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["readFloat"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "din . readFully ( b )  ;", "}", "METHOD_END"], "methodName": ["readFully"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "din . readFully ( b ,    off ,    len )  ;", "}", "METHOD_END"], "methodName": ["readFully"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "int [  ]    res    =    new   int [  4  ]  ;", "for    ( int   i    =     3  ;    i    >  =     0  ;    i -  -  )", "res [ i ]     =    din . d (  )  ;", "return    (  (  (  (  ( res [  0  ]  )     &     2  5  5  )     <  <     2  4  )     |     (  (  ( res [  1  ]  )     &     2  5  5  )     <  <     1  6  )  )     |     (  (  ( res [  2  ]  )     &     2  5  5  )     <  <     8  )  )     |     (  ( res [  3  ]  )     &     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   din . readLine (  )  ;", "}", "METHOD_END"], "methodName": ["readLine"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "int [  ]    res    =    new   int [  8  ]  ;", "for    ( int   i    =     7  ;    i    >  =     0  ;    i -  -  )", "res [ i ]     =    din . d (  )  ;", "return    (  (  (  (  (  (  (  (  ( long )     (  ( res [  0  ]  )     &     2  5  5  )  )     <  <     5  6  )     |     (  (  ( long )     (  ( res [  1  ]  )     &     2  5  5  )  )     <  <     4  8  )  )     |     (  (  ( long )     (  ( res [  2  ]  )     &     2  5  5  )  )     <  <     4  0  )  )     |     (  (  ( long )     (  ( res [  3  ]  )     &     2  5  5  )  )     <  <     3  2  )  )     |     (  (  ( long )     (  ( res [  4  ]  )     &     2  5  5  )  )     <  <     2  4  )  )     |     (  (  ( long )     (  ( res [  5  ]  )     &     2  5  5  )  )     <  <     1  6  )  )     |     (  (  ( long )     (  ( res [  6  ]  )     &     2  5  5  )  )     <  <     8  )  )     |     (  ( long )     (  ( res [  7  ]  )     &     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readLong"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "int   low    =    din . read (  )  ;", "int   high    =    din . read (  )  ;", "return    (  ( short )     (  ( high    <  <     8  )     |     ( low    &     2  5  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readShort"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   din . readUTF (  )  ;", "}", "METHOD_END"], "methodName": ["readUTF"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   din . readUnsignedByte (  )  ;", "}", "METHOD_END"], "methodName": ["readUnsignedByte"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "int   low    =    din . read (  )  ;", "int   high    =    din . read (  )  ;", "return    (  ( high    &     2  5  5  )     <  <     8  )     |     ( low    &     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["readUnsignedShort"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "return   din . skipBytes ( n )  ;", "}", "METHOD_END"], "methodName": ["skipBytes"], "fileName": "com.badlogic.gdx.utils.LittleEndianInputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( level )     >  =     ( Logger . DEBUG )  )", "Gdx . app . debug ( tag ,    message )  ;", "}", "METHOD_END"], "methodName": ["debug"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( level )     >  =     ( Logger . DEBUG )  )", "Gdx . app . debug ( tag ,    message ,    exception )  ;", "}", "METHOD_END"], "methodName": ["debug"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( level )     >  =     ( Logger . ERROR )  )", "Gdx . app . error ( tag ,    message )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( level )     >  =     ( Logger . ERROR )  )", "Gdx . app . error ( tag ,    message ,    exception )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "return   level ;", "}", "METHOD_END"], "methodName": ["getLevel"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( level )     >  =     ( Logger . INFO )  )", "Gdx . app . log ( tag ,    message )  ;", "}", "METHOD_END"], "methodName": ["info"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( level )     >  =     ( Logger . INFO )  )", "Gdx . app . log ( tag ,    message ,    exception )  ;", "}", "METHOD_END"], "methodName": ["info"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "this . level    =    level ;", "}", "METHOD_END"], "methodName": ["setLevel"], "fileName": "com.badlogic.gdx.utils.Logger"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    length ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . acopy ( a ,    offset ,    items ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "int   i    =     ( size )     -     1  ;", "l [  ]    items    =    this . items ;", "while    ( i    >  =     0  )", "if    (  ( items [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "long [  ]    items 1     =    this . items ;", "long [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     !  =     ( array . items [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   super . hashCode (  )  ;", "l [  ]    items    =    this . items ;", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     (  ( int )     (  ( items [ i ]  )     ^     (  ( items [ i ]  )     >  >  >     3  2  )  )  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     +  =    value ;", "}", "METHOD_END"], "methodName": ["incr"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "long [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . acopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     *  =    value ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  -  -  ( size )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    0  ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "long [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    a . size ;    i    <    n ;    i +  +  )     {", "long   item    =    a . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "long [  ]    items    =    this . items ;", "long   value    =    items [ index ]  ;", "( size )  -  -  ;", "if    ( ordered )", "System . acopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "long [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . acopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( items [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    newItems    =    new   long [ newSize ]  ;", "long [  ]    items    =    this . items ;", "System . acopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "long   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( newSize    >     ( items . length )  )", "resize ( Math . max (  8  ,    newSize )  )  ;", "size    =    newSize ;", "return   items ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "long   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( items ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "l [  ]    items    =    this . items ;", "l   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "long [  ]    array    =    new   long [ size ]  ;", "System . arraycopy ( items ,     0  ,    array ,     0  ,    size )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "l [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  \"  ;", "l [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append ( separator )  ;", "buffer . append ( items [ i ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     >    newSize )", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "return   new   LongArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.LongArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return ;", "long [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )     {", "keyTable [ i ]     =     . EMPTY ;", "valueTable [ i ]     =    null ;", "}", "size    =     0  ;", "stashSize    =     0  ;", "zeroValue    =    null ;", "hasZeroValue    =    false ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "zeroValue    =    null ;", "hasZeroValue    =    false ;", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )", "return   hasZeroValue ;", "int   index    =     (  ( int )     ( key    &     ( mask )  )  )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   ntainsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "long [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     =  =    null )  )", "return   true ;", "long [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     (  . EMPTY )  )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   true ;", "} else", "if    ( identity )     {", "if    ( value    =  =     ( zeroValue )  )", "return   true ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   true ;", "} else    {", "if    (  ( hasZeroValue )     &  &     ( value . equals ( zeroValue )  )  )", "return   true ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "< V >    other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "if    (  ( other . hasZeroValue )     !  =     ( hasZeroValue )  )", "return   false ;", "if    ( hasZeroValue )     {", "if    (  ( other . zeroValue )     =  =    null )     {", "if    (  ( zeroValue )     !  =    null )", "return   false ;", "} else    {", "if    (  !  ( other . zeroValue . equals ( zeroValue )  )  )", "return   false ;", "}", "}", "long [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "long   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "V   value    =    valueTable [ i ]  ;", "if    ( value    =  =    null )     {", "if    (  (  !  ( other . containsKey ( key )  )  )     |  |     (  ( other . get ( key )  )     !  =    null )  )     {", "return   false ;", "}", "} else    {", "if    (  !  ( value . equals ( other . get ( key )  )  )  )     {", "return   false ;", "}", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     =  =    null )  )", "return    0  ;", "long [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =     (  . EMPTY )  )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   keyTable [ i ]  ;", "} else", "if    ( identity )     {", "if    ( value    =  =     ( zeroValue )  )", "return    0  ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   keyTable [ i ]  ;", "} else    {", "if    (  ( hasZeroValue )     &  &     ( value . equals ( zeroValue )  )  )", "return    0  ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   keyTable [ i ]  ;", "}", "return   notFound ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   null ;", "return   zeroValue ;", "}", "int   index    =     (  ( int )     ( key    &     ( mask )  )  )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   getStash ( key ,    null )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   defaultValue ;", "return   zeroValue ;", "}", "int   index    =     (  ( int )     ( key    &     ( mask )  )  )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )     {", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     !  =    key )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "long [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     =  =    key )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    LongMap . PRIME 2  ;", "return    (  ( int )     (  ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  )  )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    LongMap . PRIME 3  ;", "return    (  ( int )     (  ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  )  )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "if    (  ( hasZeroValue )     &  &     (  ( zeroValue )     !  =    null )  )     {", "h    +  =    zeroValue . hashCode (  )  ;", "}", "long [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "long   key    =    keyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )     {", "h    +  =     (  ( int )     ( key    ^     ( key    >  >  >     3  2  )  )  )     *     3  1  ;", "V   value    =    valueTable [ i ]  ;", "if    ( value    !  =    null )     {", "h    +  =    value . hashCode (  )  ;", "}", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "long [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "long   evictedKey ;", "V   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUtils . random (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "index 1     =     (  ( int )     ( evictedKey    &    mask )  )  ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( evictedKey )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( evictedKey )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "V   oldValue    =    zeroValue ;", "zeroValue    =    value ;", "if    (  !  ( hasZeroValue )  )     {", "hasZeroValue    =    true ;", "( size )  +  +  ;", "}", "return   oldValue ;", "}", "long [  ]    keyTable    =    this . keyTable ;", "int   index 1     =     (  ( int )     ( key    &     ( mask )  )  )  ;", "long   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    key )     {", "V   oldValue    =    valueTable [ index 1  ]  ;", "valueTable [ index 1  ]     =    value ;", "return   oldValue ;", "}", "int   index 2     =    hash 2  ( key )  ;", "long   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    key )     {", "V   oldValue    =    valueTable [ index 2  ]  ;", "valueTable [ index 2  ]     =    value ;", "return   oldValue ;", "}", "int   index 3     =    hash 3  ( key )  ;", "long   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    key )     {", "V   oldValue    =    valueTable [ index 3  ]  ;", "valueTable [ index 3  ]     =    value ;", "return   oldValue ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    (  ( keyTable [ i ]  )     =  =    key )     {", "V   oldValue    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value ;", "return   oldValue ;", "}", "}", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "for    ( LongMap . Entry < V >    entry    :    map . entries (  )  )", "put ( entry . key ,    entry . value )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "zeroValue    =    value ;", "hasZeroValue    =    true ;", "return ;", "}", "int   index 1     =     (  ( int )     ( key    &     ( mask )  )  )  ;", "long   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =     (  . EMPTY )  )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( key )  ;", "long   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =     (  . EMPTY )  )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( key )  ;", "long   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =     (  . EMPTY )  )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =     0  )     {", "if    (  !  ( hasZeroValue )  )", "return   null ;", "V   oldValue    =    zeroValue ;", "zeroValue    =    null ;", "hasZeroValue    =    false ;", "( size )  -  -  ;", "return   oldValue ;", "}", "int   index    =     (  ( int )     ( key    &     ( mask )  )  )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( key )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( key )  ;", "if    (  ( keyTable [ index ]  )     =  =    key )     {", "keyTable [ index ]     =     . EMPTY ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "long [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    (  ( keyTable [ i ]  )     =  =    key )     {", "V   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastIndex    =     ( cacity )     +     ( stashSize )  ;", "if    ( index    <    lastIndex )     {", "keyTable [ index ]     =    keyTable [ lastIndex ]  ;", "valueTable [ index ]     =    valueTable [ lastIndex ]  ;", "valueTable [ lastIndex ]     =    null ;", "} else", "valueTable [ index ]     =    null ;", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     6  3     -     ( Long . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "long [  ]    oldKeyTable    =    keyTable ;", "V [  ]    oldValueTable    =    valueTable ;", "keyTable    =    new   long [ newSize    +     ( stashCapacity )  ]  ;", "valueTable    =     (  ( V [  ]  )     ( new   Object [ newSize    +     ( stashCapacity )  ]  )  )  ;", "int   oldSize    =    size ;", "size    =     ( hasZeroValue )     ?     1     :     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "long   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =     (  . EMPTY )  )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "long [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "while    (  ( i -  -  )     >     0  )     {", "long   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "while    (  ( i -  -  )     >     0  )     {", "long   key    =    keyTable [ i ]  ;", "if    ( key    =  =     (  . EMPTY )  )", "continue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.LongMap"}, {"methodBody": ["METHOD_START", "{", "return   Double . doubleToLongBits ( value )  ;", "}", "METHOD_END"], "methodName": ["doubleToLongBits"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Float . floatToIntBits ( value )  ;", "}", "METHOD_END"], "methodName": ["floatToIntBits"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Float . floatToRawIntBits ( value )  ;", "}", "METHOD_END"], "methodName": ["floatToIntColor"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Float . floatToRawIntBits ( value )  ;", "}", "METHOD_END"], "methodName": ["floatToRawIntBits"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Float . intBitsToFloat ( value )  ;", "}", "METHOD_END"], "methodName": ["intBitsToFloat"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Float . intBitsToFloat (  ( value    &     -  1  6  7  7  7  2  1  7  )  )  ;", "}", "METHOD_END"], "methodName": ["intToFloatColor"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Double . longBitsToDouble ( value )  ;", "}", "METHOD_END"], "methodName": ["longBitsToDouble"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return ;", "K [  ]    keyTable    =    thikeyTable ;", "for    ( int   i    =     ( capacity )     +     ( aSize )  ;     ( i -  -  )     >     0  ;  )", "keyTable [ i ]     =    null ;", "ze    =     0  ;", "aSize    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )", "return   containsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "f [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "< K >    other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "K [  ]    keyTable    =    this . keyTable ;", "float [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "float   otherValue    =    other . get ( key ,     0  .  0 F )  ;", "if    (  ( otherValue    =  =     0  .  0 F )     &  &     (  !  ( other . containsKey ( key )  )  )  )", "return   false ;", "float   value    =    valueTable [ i ]  ;", "if    ( otherValue    !  =    value )", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "f [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   keyTable [ i ]  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )", "return   getAndIncrementStash ( key ,    defaultValue ,    increment )  ;", "}", "}", "f   value    =    valueTable [ index ]  ;", "valueTable [ index ]     =    value    +    increment ;", "return   value ;", "}", "METHOD_END"], "methodName": ["getAndIncrement"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )     {", "f   value    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value    +    increment ;", "return   value ;", "}", "put ( key ,     ( defaultValue    +    increment )  )  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getAndIncrementStash"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectFloatMap . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectFloatMap . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "K [  ]    keyTable    =    this . keyTable ;", "float [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "h    +  =     ( key . hashCode (  )  )     *     3  1  ;", "float   value    =    valueTable [ i ]  ;", "h    +  =     . floatToIntBits ( value )  ;", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "float [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "K   evictedKey ;", "float   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUrandom (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "int   hashCode    =    evictedKey . hashCode (  )  ;", "index 1     =    hashCode    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( hashCode )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( hashCode )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )", "throw   new   IllegalArgumentExcepon (  \" key   cannot   be   null .  \"  )  ;", "K [  ]    keyTable    =    this . keyTable ;", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key . equals ( key 1  )  )     {", "valueTable [ index 1  ]     =    value ;", "return ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key . equals ( key 2  )  )     {", "valueTable [ index 2  ]     =    value ;", "return ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key . equals ( key 3  )  )     {", "valueTable [ index 3  ]     =    value ;", "return ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keyTable [ i ]  )  )     {", "valueTable [ i ]     =    value ;", "return ;", "}", "}", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "for    ( ObjectFloatMap . Entry < K >    entry    :    map . entries (  )  )", "put ( entry . key ,    entry . value )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( cacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( cacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( cacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    ( key . equals ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "f   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( hashCode )  ;", "if    ( key . equals ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "f   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( hashCode )  ;", "if    ( key . equals ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "f   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keyTable [ i ]  )  )     {", "f   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastIndex    =     ( cacity )     +     ( stashSize )  ;", "if    ( index    <    lastIndex )     {", "keyTable [ index ]     =    keyTable [ lastIndex ]  ;", "valueTable [ index ]     =    valueTable [ lastIndex ]  ;", "}", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "K [  ]    oldKeyTable    =    keyTable ;", "float [  ]    oldValueTable    =    valueTable ;", "keyTable    =     (  ( K [  ]  )     ( new    [ newSize    +     ( stashCapacity )  ]  )  )  ;", "valueTable    =    new   float [ newSize    +     ( stashCapacity )  ]  ;", "int   oldSize    =    size ;", "size    =     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "K   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =    null )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  {  }  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  {  '  )  ;", "K [  ]    keyTable    =    this . keyTable ;", "f [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "while    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "while    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.ObjectFloatMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return ;", "K [  ]    keyTable    =    thikeyTable ;", "for    ( int   i    =     ( capacity )     +     ( aSize )  ;     ( i -  -  )     >     0  ;  )", "keyTable [ i ]     =    null ;", "ze    =     0  ;", "aSize    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )", "return   containsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "< K >    other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "K [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "int   otherValue    =    other . get ( key ,     0  )  ;", "if    (  ( otherValue    =  =     0  )     &  &     (  !  ( other . containsKey ( key )  )  )  )", "return   false ;", "int   value    =    valueTable [ i ]  ;", "if    ( otherValue    !  =    value )", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    value )  )", "return   keyTable [ i ]  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equals ( keyTable [ index ]  )  )  )", "return   getAndIncrementStash ( key ,    defaultValue ,    increment )  ;", "}", "}", "int   value    =    valueTable [ index ]  ;", "valueTable [ index ]     =    value    +    increment ;", "return   value ;", "}", "METHOD_END"], "methodName": ["getAndIncrement"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )     {", "int   value    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value    +    increment ;", "return   value ;", "}", "put ( key ,     ( defaultValue    +    increment )  )  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getAndIncrementStash"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectIntMap . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectIntMap . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "K [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "h    +  =     ( key . hashCode (  )  )     *     3  1  ;", "int   value    =    valueTable [ i ]  ;", "h    +  =    value ;", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "K   evictedKey ;", "int   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUrandom (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "int   hashCode    =    evictedKey . hashCode (  )  ;", "index 1     =    hashCode    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( hashCode )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( hashCode )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )", "throw   new   IllegalArgumentExcepon (  \" key   cannot   be   null .  \"  )  ;", "K [  ]    keyTable    =    this . keyTable ;", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key . equals ( key 1  )  )     {", "valueTable [ index 1  ]     =    value ;", "return ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key . equals ( key 2  )  )     {", "valueTable [ index 2  ]     =    value ;", "return ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key . equals ( key 3  )  )     {", "valueTable [ index 3  ]     =    value ;", "return ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keyTable [ i ]  )  )     {", "valueTable [ i ]     =    value ;", "return ;", "}", "}", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "for    ( ObjectIntMap . Entry < K >    entry    :    map . entries (  )  )", "put ( entry . key ,    entry . value )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    ( key . equals ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "int   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( hashCode )  ;", "if    ( key . equals ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "int   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( hashCode )  ;", "if    ( key . equals ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "int   oldValue    =    valueTable [ index ]  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keyTable [ i ]  )  )     {", "int   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lasdex    =     ( capacity )     +     ( stashSize )  ;", "if    ( index    <    lasdex )     {", "keyTable [ index ]     =    keyTable [ lasdex ]  ;", "valueTable [ index ]     =    valueTable [ lasdex ]  ;", "}", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "K [  ]    oldKeyTable    =    keyTable ;", "int [  ]    oldValueTable    =    valueTable ;", "keyTable    =     (  ( K [  ]  )     ( new    [ newSize    +     ( stashCapacity )  ]  )  )  ;", "valueTable    =    new   int [ newSize    +     ( stashCapacity )  ]  ;", "int   oldSize    =    size ;", "size    =     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "K   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =    null )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  {  }  \"  ;", "StringBuder   buffer    =    new   StringBuder (  3  2  )  ;", "buffer . append (  '  {  '  )  ;", "K [  ]    keyTable    =    this . keyTable ;", "int [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "whe    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "whe    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.ObjectIntMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return ;", "K [  ]    keyTable    =    thikeyTable ;", "V [  ]    valueTable    =    thivalueTable ;", "for    ( int   i    =     ( capacity )     +     ( aSize )  ;     ( i -  -  )     >     0  ;  )     {", "keyTable [ i ]     =    null ;", "valueTable [ i ]     =    null ;", "}", "ze    =     0  ;", "aSize    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "return ;", "}", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )", "return   containsKeyStash ( key )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["containsKeyStash"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   true ;", "} else", "if    ( identity )     {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   true ;", "} else    {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    new    . Entries ( this )  ;", "entries 2     =    new    . Entries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )", "return   true ;", "if    (  !  ( obj   instanceof    )  )", "return   false ;", "< K ,    V >    other    =     (  (  )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "V   value    =    valueTable [ i ]  ;", "if    ( value    =  =    null )     {", "if    (  (  !  ( other . containsKey ( key )  )  )     |  |     (  ( other . get ( key )  )     !  =    null )  )     {", "return   false ;", "}", "} else    {", "if    (  !  ( value . equals ( other . get ( key )  )  )  )     {", "return   false ;", "}", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "V [  ]    valueTable    =    this . valueTable ;", "if    ( value    =  =    null )     {", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  ( valueTable [ i ]  )     =  =    null )  )", "return   keyTable [ i ]  ;", "} else", "if    ( identity )     {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    (  ( valueTable [ i ]  )     =  =    value )", "return   keyTable [ i ]  ;", "} else    {", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "if    ( value . equals ( valueTable [ i ]  )  )", "return   keyTable [ i ]  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findKey"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )", "return   getStash ( key ,    null )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )", "return   getStash ( key ,    defaultValue )  ;", "}", "}", "return   valueTable [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   valueTable [ i ]  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getStash"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectMap . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectMap . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "K [  ]    keyTable    =    thikeyTable ;", "V [  ]    valueTable    =    thivalueTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( aSize )  ;    i    <    n ;    i +  +  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    !  =    null )     {", "h    +  =     ( key . haCode (  )  )     *     3  1  ;", "V   value    =    valueTable [ i ]  ;", "if    ( value    !  =    null )     {", "h    +  =    value . haCode (  )  ;", "}", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    new    . Keys ( this )  ;", "keys 2     =    new    . Keys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   mask    =    this . mask ;", "K   evictedKey ;", "V   evictedValue ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUrandom (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "evictedValue    =    valueTable [ index 1  ]  ;", "keyTable [ index 1  ]     =    insertKey ;", "valueTable [ index 1  ]     =    insertValue ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "evictedValue    =    valueTable [ index 2  ]  ;", "keyTable [ index 2  ]     =    insertKey ;", "valueTable [ index 2  ]     =    insertValue ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "evictedValue    =    valueTable [ index 3  ]  ;", "keyTable [ index 3  ]     =    insertKey ;", "valueTable [ index 3  ]     =    insertValue ;", "break ;", "}", "int   hashCode    =    evictedKey . hashCode (  )  ;", "index 1     =    hashCode    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    evictedKey ;", "valueTable [ index 1  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( hashCode )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    evictedKey ;", "valueTable [ index 2  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( hashCode )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    evictedKey ;", "valueTable [ index 3  ]     =    evictedValue ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "insertValue    =    evictedValue ;", "}    while    ( true    )  ;", "putStash ( evictedKey ,    evictedValue )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )", "throw   new   IllegalArgumentExcepon (  \" key   cannot   be   null .  \"  )  ;", "return   put _ internal ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "ensureCapacity ( map . size )  ;", "for    (  . Entry < K ,    V >    entry    :    map )", "put ( entry . key ,    entry . value )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( cacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( cacity )     <  <     1  )  )  ;", "return ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( cacity )     <  <     1  )  )  ;", "return ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["putResize"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "put _ internal ( key ,    value )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "valueTable [ index ]     =    value ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["putStash"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "K   key 1     =    keyTable [ index 1  ]  ;", "if    ( key . equals ( key 1  )  )     {", "V   oldValue    =    valueTable [ index 1  ]  ;", "valueTable [ index 1  ]     =    value ;", "return   oldValue ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "K   key 2     =    keyTable [ index 2  ]  ;", "if    ( key . equals ( key 2  )  )     {", "V   oldValue    =    valueTable [ index 2  ]  ;", "valueTable [ index 2  ]     =    value ;", "return   oldValue ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "K   key 3     =    keyTable [ index 3  ]  ;", "if    ( key . equals ( key 3  )  )     {", "V   oldValue    =    valueTable [ index 3  ]  ;", "valueTable [ index 3  ]     =    value ;", "return   oldValue ;", "}", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keyTable [ i ]  )  )     {", "V   oldValue    =    valueTable [ i ]  ;", "valueTable [ i ]     =    value ;", "return   oldValue ;", "}", "}", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "valueTable [ index 1  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "valueTable [ index 2  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "valueTable [ index 3  ]     =    value ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   null ;", "}", "push ( key ,    value ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["put_internal"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    ( key . equa ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 2  ( hashCode )  ;", "if    ( key . equa ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "index    =    hash 3  ( hashCode )  ;", "if    ( key . equa ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "V   oldValue    =    valueTable [ index ]  ;", "valueTable [ index ]     =    null ;", "( size )  -  -  ;", "return   oldValue ;", "}", "return   removeStash ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "K [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keyTable [ i ]  )  )     {", "V   oldValue    =    valueTable [ i ]  ;", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   oldValue ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastIndex    =     ( cacity )     +     ( stashSize )  ;", "if    ( index    <    lastIndex )     {", "keyTable [ index ]     =    keyTable [ lastIndex ]  ;", "valueTable [ index ]     =    valueTable [ lastIndex ]  ;", "valueTable [ lastIndex ]     =    null ;", "} else", "valueTable [ index ]     =    null ;", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "K [  ]    oldKeyTable    =    keyTable ;", "V [  ]    oldValueTable    =    valueTable ;", "keyTable    =     (  ( K [  ]  )     ( new    [ newSize    +     ( stashCapacity )  ]  )  )  ;", "valueTable    =     (  ( V [  ]  )     ( new    [ newSize    +     ( stashCapacity )  ]  )  )  ;", "int   oldSize    =    size ;", "size    =     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "K   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =    null )", "putResize ( key ,    oldValueTable [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "return   toString (  \"  ,     \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "return   toString ( separator ,    false )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return   braces    ?     \"  {  }  \"     :     \"  \"  ;", "StringBuder   buffer    =    new   StringBuder (  3  2  )  ;", "if    ( braces )", "buffer . append (  '  {  '  )  ;", "K [  ]    keyTable    =    this . keyTable ;", "V [  ]    valueTable    =    this . valueTable ;", "int   i    =    keyTable . length ;", "whe    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "break ;", "}", "whe    (  ( i -  -  )     >     0  )     {", "K   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append ( separator )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( valueTable [ i ]  )  ;", "}", "if    ( braces )", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    new    . Values ( this )  ;", "values 2     =    new    . Values ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.ObjectMap"}, {"methodBody": ["METHOD_START", "{", "if    ( key    =  =    null )", "throw   new   IllegalArgumentExcepon (  \" key   cannot   be   null .  \"  )  ;", "T [  ]    keyTable    =    this . keyTable ;", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "T   key 1     =    keyTable [ index 1  ]  ;", "if    ( key . equals ( key 1  )  )", "return   false ;", "int   index 2     =    hash 2  ( hashCode )  ;", "T   key 2     =    keyTable [ index 2  ]  ;", "if    ( key . equals ( key 2  )  )", "return   false ;", "int   index 3     =    hash 3  ( hashCode )  ;", "T   key 3     =    keyTable [ index 3  ]  ;", "if    ( key . equals ( key 3  )  )", "return   false ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   false ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   true ;", "}", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   true ;", "}", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return   true ;", "}", "push ( key ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "ensureCapacity ( length )  ;", "for    ( int   i    =    offs ,    n    =    i    +    length ;    i    <    n ;    i +  +  )", "add ( array [ i ]  )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll (  (  ( T [  ]  )     ( array . items )  )  ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "ensureCapacity ( set . size )  ;", "for    ( T   key    :    set )", "add ( key )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index 1     =    hashCode    &     ( mask )  ;", "T   key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "rurn ;", "}", "int   index 2     =    hash 2  ( hashCode )  ;", "T   key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "rurn ;", "}", "int   index 3     =    hash 3  ( hashCode )  ;", "T   key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    key ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "rurn ;", "}", "push ( key ,    index 1  ,    key 1  ,    index 2  ,    key 2  ,    index 3  ,    key 3  )  ;", "}", "METHOD_END"], "methodName": ["addResize"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stashSize )     =  =     ( stashCapacity )  )     {", "resize (  (  ( capacity )     <  <     1  )  )  ;", "d ( key )  ;", "return ;", "}", "int   index    =     ( capacity )     +     ( stashSize )  ;", "keyTable [ index ]     =    key ;", "( stashSize )  +  +  ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["addStash"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "rurn ;", "T [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     ( capacity )     +     ( stashSize )  ;     ( i -  -  )     >     0  ;  )", "keyTable [ i ]     =    null ;", "size    =     0  ;", "stashSize    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( capacity )     <  =    maximumCapacity )     {", "clear (  )  ;", "rurn ;", "}", "size    =     0  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "if    (  !  ( key . equa ( keyTable [ index ]  )  )  )", "return    ( getKeyStash ( key )  )     !  =    null ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >  =     ( threshold )  )", "resize ( math . MathUtils . nextPowerOfTwo (  (  ( int )     ( Math . ceil (  ( sizeNeeded    /     ( loadFactor )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( obj   instanceof   ObjectSet )  )", "return   false ;", "ObjectSet   other    =     (  ( ObjectSet )     ( obj )  )  ;", "if    (  ( other . size )     !  =     ( size )  )", "return   false ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  (  ( keyTable [ i ]  )     !  =    null )     &  &     (  !  ( other . contains ( keyTable [ i ]  )  )  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "T [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     !  =    null )", "return   keyTable [ i ]  ;", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "T   found    =    keyTable [ index ]  ;", "if    (  !  ( key . equa ( found )  )  )     {", "index    =    hash 2  ( hashCode )  ;", "found    =    keyTable [ index ]  ;", "if    (  !  ( key . equa ( found )  )  )     {", "index    =    hash 3  ( hashCode )  ;", "found    =    keyTable [ index ]  ;", "if    (  !  ( key . equa ( found )  )  )", "return   getKeyStash ( key )  ;", "}", "}", "return   found ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "T [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    ( key . equals ( keyTable [ i ]  )  )", "return   keyTable [ i ]  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getKeyStash"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectSet . PRIME 2  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash2"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "h    *  =    ObjectSet . PRIME 3  ;", "return    ( h    ^     ( h    >  >  >     ( hashShift )  )  )     &     ( mask )  ;", "}", "METHOD_END"], "methodName": ["hash3"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "int   h    =     0  ;", "for    ( int   i    =     0  ,    n    =     ( capacity )     +     ( stashSize )  ;    i    <    n ;    i +  +  )", "if    (  ( keyTable [ i ]  )     !  =    null )", "h    +  =    keyTable [ i ]  . hashCode (  )  ;", "rurn   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterator 1  )     =  =    null )     {", "iterator 1     =    newIterator ( this )  ;", "iterator 2     =    newIterator ( this )  ;", "}", "if    (  !  ( iterator 1  . valid )  )     {", "iterator 1  . reset (  )  ;", "iterator 1  . valid    =    true ;", "iterator 2  . valid    =    false ;", "return   iterator 1  ;", "}", "iterator 2  . reset (  )  ;", "iterator 2  . valid    =    true ;", "iterator 1  . valid    =    false ;", "return   iterator 2  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "T [  ]    keyTable    =    this . keyTable ;", "int   mask    =    this . mask ;", "T   evictedKey ;", "int   i    =     0  ;", "int   pushIterations    =    this . pushIterations ;", "do    {", "switch    ( MathUrandom (  2  )  )     {", "case    0     :", "evictedKey    =    key 1  ;", "keyTable [ index 1  ]     =    insertKey ;", "break ;", "case    1     :", "evictedKey    =    key 2  ;", "keyTable [ index 2  ]     =    insertKey ;", "break ;", "default    :", "evictedKey    =    key 3  ;", "keyTable [ index 3  ]     =    insertKey ;", "break ;", "}", "int   hashCode    =    evictedKey . hashCode (  )  ;", "index 1     =    hashCode    &    mask ;", "key 1     =    keyTable [ index 1  ]  ;", "if    ( key 1     =  =    null )     {", "keyTable [ index 1  ]     =    evictedKey ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 2     =    hash 2  ( hashCode )  ;", "key 2     =    keyTable [ index 2  ]  ;", "if    ( key 2     =  =    null )     {", "keyTable [ index 2  ]     =    evictedKey ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "index 3     =    hash 3  ( hashCode )  ;", "key 3     =    keyTable [ index 3  ]  ;", "if    ( key 3     =  =    null )     {", "keyTable [ index 3  ]     =    evictedKey ;", "if    (  (  ( size )  +  +  )     >  =     ( threshold )  )", "resize (  (  ( capacity )     <  <     1  )  )  ;", "return ;", "}", "if    (  (  +  + i )     =  =    pushIterations )", "break ;", "insertKey    =    evictedKey ;", "}    while    ( true    )  ;", "addStash ( evictedKey )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    key . hashCode (  )  ;", "int   index    =    hashCode    &     ( mask )  ;", "if    ( key . equa ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "( size )  -  -  ;", "return   true ;", "}", "index    =    hash 2  ( hashCode )  ;", "if    ( key . equa ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "( size )  -  -  ;", "return   true ;", "}", "index    =    hash 3  ( hashCode )  ;", "if    ( key . equa ( keyTable [ index ]  )  )     {", "keyTable [ index ]     =    null ;", "( size )  -  -  ;", "return   true ;", "}", "return   removeStash ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "T [  ]    keyTable    =    this . keyTable ;", "for    ( int   i    =    capacity ,    n    =    i    +     ( stashSize )  ;    i    <    n ;    i +  +  )     {", "if    ( key . equals ( keyTable [ i ]  )  )     {", "removeStashIndex ( i )  ;", "( size )  -  -  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeStash"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "( stashSize )  -  -  ;", "int   lastIndex    =     ( capacity )     +     ( stashSize )  ;", "if    ( index    <    lastIndex )", "keyTable [ index ]     =    keyTable [ lastIndex ]  ;", "}", "METHOD_END"], "methodName": ["removeStashIndex"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "int   oldEndIndex    =     ( capacity )     +     ( stashSize )  ;", "capacity    =    newSize ;", "threshold    =     (  ( int )     ( newSize    *     ( loadFactor )  )  )  ;", "mask    =    newSize    -     1  ;", "hashShift    =     3  1     -     ( Integer . numberOfTrailingZeros ( newSize )  )  ;", "stashCapacity    =    Math . max (  3  ,     (  (  ( int )     ( Math . ceil ( Math . log ( newSize )  )  )  )     *     2  )  )  ;", "pushIterations    =    Math . max ( Math . min ( newSize ,     8  )  ,     (  (  ( int )     ( Math . sqrt ( newSize )  )  )     /     8  )  )  ;", "T [  ]    oldKeyTable    =    keyTable ;", "keyTable    =     (  ( T [  ]  )     ( new    [ newSize    +     ( stashCapacity )  ]  )  )  ;", "int   oldSize    =    size ;", "size    =     0  ;", "stashSize    =     0  ;", "if    ( oldSize    >     0  )     {", "for    ( int   i    =     0  ;    i    <    oldEndIndex ;    i +  +  )     {", "T   key    =    oldKeyTable [ i ]  ;", "if    ( key    !  =    null )", "addResize ( key )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    ( maximumCapacity    <     0  )", "throw   new   IllegalArgumentException (  (  \" maximumCapacity   must   be    >  =     0  :     \"     +    maximumCapacity )  )  ;", "if    (  ( size )     >    maximumCapacity )", "maximumCapacity    =    size ;", "if    (  ( capacity )     <  =    maximumCapacity )", "return ;", "maximumCapacity    =    MathUnextPowerOfTwo ( maximumCapacity )  ;", "resize ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "return    (  '  {  '     +     ( toString (  \"  ,     \"  )  )  )     +     '  }  '  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "rurn    \"  \"  ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "T [  ]    keyTable    =    this . keyTable ;", "int   i    =    keyTable . length ;", "while    (  ( i -  -  )     >     0  )     {", "T   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append ( key )  ;", "break ;", "}", "while    (  ( i -  -  )     >     0  )     {", "T   key    =    keyTable [ i ]  ;", "if    ( key    =  =    null )", "continue ;", "buffer . append ( separator )  ;", "buffer . append ( key )  ;", "}", "rurn   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "ObjectSet   set    =    new   ObjectSet (  )  ;", "set . addAll ( array )  ;", "return   set ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.ObjectSet"}, {"methodBody": ["METHOD_START", "{", "keys . clear (  )  ;", "super . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "keys . clear (  )  ;", "super . clear ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entries 1  )     =  =    null )     {", "entries 1     =    newEntries ( this )  ;", "entries 2     =    newEntries ( this )  ;", "}", "if    (  !  ( entries 1  . valid )  )     {", "entries 1  . reset (  )  ;", "entries 1  . valid    =    true ;", "entries 2  . valid    =    false ;", "return   entries 1  ;", "}", "entries 2  . reset (  )  ;", "entries 2  . valid    =    true ;", "entries 1  . valid    =    false ;", "return   entries 2  ;", "}", "METHOD_END"], "methodName": ["entries"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "return   entries (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( keys 1  )     =  =    null )     {", "keys 1     =    newKeys ( this )  ;", "keys 2     =    newKeys ( this )  ;", "}", "if    (  !  ( keys 1  . valid )  )     {", "keys 1  . reset (  )  ;", "keys 1  . valid    =    true ;", "keys 2  . valid    =    false ;", "return   keys 1  ;", "}", "keys 2  . reset (  )  ;", "keys 2  . valid    =    true ;", "keys 1  . valid    =    false ;", "return   keys 2  ;", "}", "METHOD_END"], "methodName": ["keys"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "return   keys ;", "}", "METHOD_END"], "methodName": ["orderedKeys"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( containsKey ( key )  )  )", "keys . add ( key )  ;", "return   super . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "keys . removeValue ( key ,    false )  ;", "return   super . remove ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  {  }  \"  ;", "StringBuil   buffer    =    new   StringBuil (  3  2  )  ;", "buffer . append (  '  {  '  )  ;", "Array < K >    keys    =    this . keys ;", "for    ( int   i    =     0  ,    n    =    keys . size ;    i    <    n ;    i +  +  )     {", "K   key    =    keys . get ( i )  ;", "if    ( i    >     0  )", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( key )  ;", "buffer . append (  '  =  '  )  ;", "buffer . append ( get ( key )  )  ;", "}", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( values 1  )     =  =    null )     {", "values 1     =    newValues ( this )  ;", "values 2     =    newValues ( this )  ;", "}", "if    (  !  ( values 1  . valid )  )     {", "values 1  . reset (  )  ;", "values 1  . valid    =    true ;", "values 2  . valid    =    false ;", "return   values 1  ;", "}", "values 2  . reset (  )  ;", "values 2  . valid    =    true ;", "values 1  . valid    =    false ;", "return   values 2  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "com.badlogic.gdx.utils.OrderedMap"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( super . add ( key )  )  )", "return   false ;", "items . add ( key )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( super . add ( key )  )  )     {", "items . removeValue ( key ,    true )  ;", "items . insert ( index ,    key )  ;", "return   false ;", "}", "items . insert ( index ,    key )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "items . clear (  )  ;", "super . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "items . clear (  )  ;", "super . clear ( maximumCapacity )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterator 1  )     =  =    null )     {", "iterator 1     =    newIterator ( this )  ;", "iterator 2     =    newIterator ( this )  ;", "}", "if    (  !  ( iterator 1  . valid )  )     {", "iterator 1  . reset (  )  ;", "iterator 1  . valid    =    true ;", "iterator 2  . valid    =    false ;", "return   iterator 1  ;", "}", "iterator 2  . reset (  )  ;", "iterator 2  . valid    =    true ;", "iterator 1  . valid    =    false ;", "return   iterator 2  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "return   items ;", "}", "METHOD_END"], "methodName": ["orderedItems"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "items . removeValue ( key ,    false )  ;", "return   super . remove ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  {  }  \"  ;", "T [  ]    items    =    this . items . items ;", "StringBuil   buffer    =    new   StringBuil (  3  2  )  ;", "buffer . append (  '  {  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  }  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "return   items . toString ( separator )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.OrderedSet"}, {"methodBody": ["METHOD_START", "{", "return   paused ;", "}", "METHOD_END"], "methodName": ["isPaused"], "fileName": "com.badlogic.gdx.utils.PauseableThread"}, {"methodBody": ["METHOD_START", "{", "paused    =    true ;", "}", "METHOD_END"], "methodName": ["onPause"], "fileName": "com.badlogic.gdx.utils.PauseableThread"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "pd    =    false ;", "this . notifyAll (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onResume"], "fileName": "com.badlogic.gdx.utils.PauseableThread"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "synchronized ( this )     {", "try    {", "while    ( pd )", "wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "if    ( exit )", "return ;", "runnable . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "com.badlogic.gdx.utils.PauseableThread"}, {"methodBody": ["METHOD_START", "{", "exit    =    true ;", "if    ( pd )", "onResume (  )  ;", "}", "METHOD_END"], "methodName": ["stopThread"], "fileName": "com.badlogic.gdx.utils.PauseableThread"}, {"methodBody": ["METHOD_START", "{", "time . reset (  )  ;", "load . reset (  )  ;", "startTime    =     0 L ;", "lastTick    =     0 L ;", "current    =     0  .  0 F ;", "valid    =    false ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.utils.PerformanceCounter"}, {"methodBody": ["METHOD_START", "{", "startTime    =    TimeUtils . nanoTime (  )  ;", "valid    =    false ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.badlogic.gdx.utils.PerformanceCounter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( startTime )     >     0 L )     {", "current    +  =     (  ( TimeUtils . nanoTime (  )  )     -     ( startTime )  )     *     (  . nano 2 seconds )  ;", "startTime    =     0 L ;", "valid    =    true ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.utils.PerformanceCounter"}, {"methodBody": ["METHOD_START", "{", "final   long   t    =    TimeUtils . nanoTime (  )  ;", "if    (  ( lastTick )     >     0 L )", "tick (  (  ( t    -     ( lastTick )  )     *     (  . nano 2 seconds )  )  )  ;", "lastTick    =    t ;", "}", "METHOD_END"], "methodName": ["tick"], "fileName": "com.badlogic.gdx.utils.PerformanceCounter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( valid )  )     {", "Gdx . app . error (  \"  \"  ,     \" Invalid   data ,    check   if   you   called    # stop (  )  \"  )  ;", "return ;", "}", "time . put ( current )  ;", "final   float   currentLoad    =     ( delta    =  =     0  .  0 F )     ?     0  .  0 F    :     ( current )     /    delta ;", "load . put (  ( delta    >     1  .  0 F    ?    currentLoad    :     ( delta    *    currentLoad )     +     (  (  1  .  0 F    -    delta )     *     ( load . latest )  )  )  )  ;", "current    =     0  .  0 F ;", "valid    =    false ;", "}", "METHOD_END"], "methodName": ["tick"], "fileName": "com.badlogic.gdx.utils.PerformanceCounter"}, {"methodBody": ["METHOD_START", "{", "sb . append ( name )  . append (  \"  :     [ time :     \"  )  . append ( time . value )  . append (  \"  ,    load :     \"  )  . append ( load . value )  . append (  \"  ]  \"  )  ;", "return   sb ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.PerformanceCounter"}, {"methodBody": ["METHOD_START", "{", "PerformanceCounter   result    =    new   PerformanceCounter ( name )  ;", "counters . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.PerformanceCounters"}, {"methodBody": ["METHOD_START", "{", "PerformanceCounter   result    =    new   PerformanceCounter ( name ,    windowSize )  ;", "counters . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.PerformanceCounters"}, {"methodBody": ["METHOD_START", "{", "final   long   t    =    TimeUtils . nanoTime (  )  ;", "if    (  ( lastTick )     >     0 L )", "tick (  (  ( t    -     ( lastTick )  )     *     (  . nano 2 seconds )  )  )  ;", "lastTick    =    t ;", "}", "METHOD_END"], "methodName": ["tick"], "fileName": "com.badlogic.gdx.utils.PerformanceCounters"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( counters . size )  ;    i +  +  )", "counters . get ( i )  . tick ( deltaTime )  ;", "}", "METHOD_END"], "methodName": ["tick"], "fileName": "com.badlogic.gdx.utils.PerformanceCounters"}, {"methodBody": ["METHOD_START", "{", "sb . setLength (  0  )  ;", "for    ( int   i    =     0  ;    i    <     ( c . size )  ;    i +  +  )     {", "if    ( i    !  =     0  )", "sb . append (  \"  ;     \"  )  ;", "c . get ( i )  . toString ( sb )  ;", "}", "return   sb ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.PerformanceCounters"}, {"methodBody": ["METHOD_START", "{", "freeObjects . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.Pool"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )", "throw   new   IllegalArgumentExcepon (  \" object   cannot   be   null .  \"  )  ;", "if    (  ( freeObjects . size )     <     ( max )  )     {", "freeObjects . add ( object )  ;", "peak    =    Math . max ( peak ,    freeObjects . size )  ;", "}", "reset ( object )  ;", "}", "METHOD_END"], "methodName": ["free"], "fileName": "com.badlogic.gdx.utils.Pool"}, {"methodBody": ["METHOD_START", "{", "if    ( objects    =  =    null )", "throw   new   IllegalArgumentExcepon (  \" objects   cannot   be   null .  \"  )  ;", "Array < T >    freeObjects    =    this . freeObjects ;", "int   max    =    this . max ;", "for    ( int   i    =     0  ;    i    <     ( objects . size )  ;    i +  +  )     {", "T   object    =    objects . get ( i )  ;", "if    ( object    =  =    null )", "connue ;", "if    (  ( freeObjects . size )     <    max )", "freeObjects . add ( object )  ;", "reset ( object )  ;", "}", "peak    =    Math . max ( peak ,    freeObjects . size )  ;", "}", "METHOD_END"], "methodName": ["freeAll"], "fileName": "com.badlogic.gdx.utils.Pool"}, {"methodBody": ["METHOD_START", "{", "return   freeObjects . size ;", "}", "METHOD_END"], "methodName": ["getFree"], "fileName": "com.badlogic.gdx.utils.Pool"}, {"methodBody": ["METHOD_START", "{", "return    ( freeObjects . size )     =  =     0     ?    newObject (  )     :    freeObjects . pop (  )  ;", "}", "METHOD_END"], "methodName": ["obtain"], "fileName": "com.badlogic.gdx.utils.Pool"}, {"methodBody": ["METHOD_START", "{", "if    ( object   instanceof   Pool . Poolable )", "(  ( Pool . Poolable )     ( object )  )  . reset (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.utils.Pool"}, {"methodBody": ["METHOD_START", "{", "PooledLinkedList . Item < T >    item    =    pool . obtain (  )  ;", "item . payload    =    object ;", "item . next    =    null ;", "item . prev    =    null ;", "if    (  ( head )     =  =    null )     {", "head    =    item ;", "tail    =    item ;", "( size )  +  +  ;", "return ;", "}", "item . prev    =    tail ;", "tail . next    =    item ;", "tail    =    item ;", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "iter (  )  ;", "T   v    =    null ;", "whe    (  ( v    =    next (  )  )     !  =    null )", "remove (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "iter    =    head ;", "}", "METHOD_END"], "methodName": ["iter"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "iter    =    tail ;", "}", "METHOD_END"], "methodName": ["iterReverse"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iter )     =  =    null )", "return   null ;", "T   payad    =    iter . payad ;", "curr    =    iter ;", "iter    =    iter . next ;", "return   payad ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iter )     =  =    null )", "return   null ;", "T   payad    =    iter . payad ;", "curr    =    iter ;", "iter    =    iter . prev ;", "return   payad ;", "}", "METHOD_END"], "methodName": ["previous"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "if    (  ( curr )     =  =    null )", "return ;", "( size )  -  -  ;", "pool . free ( curr )  ;", ". Item < T >    c    =    curr ;", ". Item < T >    n    =    curr . next ;", ". Item < T >    p    =    curr . prev ;", "curr    =    null ;", "if    (  ( size )     =  =     0  )     {", "head    =    null ;", "tail    =    null ;", "return ;", "}", "if    ( c    =  =     ( head )  )     {", "n . prev    =    null ;", "head    =    n ;", "return ;", "}", "if    ( c    =  =     ( tail )  )     {", "p . next    =    null ;", "tail    =    p ;", "return ;", "}", "p . next    =    n ;", "n . prev    =    p ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "return   size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.utils.PooledLinkedList"}, {"methodBody": ["METHOD_START", "{", "list . clear (  )  ;", "assertEquals (  0  ,    list . size (  )  )  ;", "list . iter (  )  ;", "assertNull ( list . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.PooledLinkedListTest"}, {"methodBody": ["METHOD_START", "{", "list . iter (  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    list . next (  )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    list . next (  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    list . next (  )  )  ;", "assertNull ( list . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["iteration"], "fileName": "com.badlogic.gdx.utils.PooledLinkedListTest"}, {"methodBody": ["METHOD_START", "{", "list . iter (  )  ;", "list . next (  )  ;", "list . remove (  )  ;", "list . next (  )  ;", "list . next (  )  ;", "list . remove (  )  ;", "list . iter (  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    list . next (  )  )  ;", "assertNull ( list . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.utils.PooledLinkedListTest"}, {"methodBody": ["METHOD_START", "{", "list . iterReverse (  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    list . previous (  )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    list . previous (  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    list . previous (  )  )  ;", "assertNull ( list . previous (  )  )  ;", "}", "METHOD_END"], "methodName": ["reverseIteration"], "fileName": "com.badlogic.gdx.utils.PooledLinkedListTest"}, {"methodBody": ["METHOD_START", "{", "list    =    new   PooledLinkedList < Integer >  (  1  0  )  ;", "list . add (  1  )  ;", "list . add (  2  )  ;", "list . add (  3  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "com.badlogic.gdx.utils.PooledLinkedListTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  3  ,    list . size (  )  )  ;", "list . iter (  )  ;", "list . next (  )  ;", "list . remove (  )  ;", "assertEquals (  2  ,    list . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.utils.PooledLinkedListTest"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )", "throw   new   IllegalArgumentException (  \" Object   cannot   be   null .  \"  )  ;", "Pool   pool    =     . type . get ( object . getClass (  )  )  ;", "if    ( pool    =  =    null )", "return ;", "pool . free ( object )  ;", "}", "METHOD_END"], "methodName": ["free"], "fileName": "com.badlogic.gdx.utils.Pools"}, {"methodBody": ["METHOD_START", "{", "Pools . freeAll ( objects ,    false )  ;", "}", "METHOD_END"], "methodName": ["freeAll"], "fileName": "com.badlogic.gdx.utils.Pools"}, {"methodBody": ["METHOD_START", "{", "if    ( objects    =  =    null )", "throw   new   IllegalArgumentException (  \" Objects   cannot   be   null .  \"  )  ;", "Pool   pool    =    null ;", "for    ( int   i    =     0  ,    n    =    objects . size ;    i    <    n ;    i +  +  )     {", "Object   object    =    objects . get ( i )  ;", "if    ( object    =  =    null )", "continue ;", "if    ( pool    =  =    null )     {", "pool    =     . type . get ( object . getClass (  )  )  ;", "if    ( pool    =  =    null )", "continue ;", "}", "pool . free ( object )  ;", "if    (  ! samePool )", "pool    =    null ;", "}", "}", "METHOD_END"], "methodName": ["freeAll"], "fileName": "com.badlogic.gdx.utils.Pools"}, {"methodBody": ["METHOD_START", "{", "return   Pools . get ( type ,     1  0  0  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.Pools"}, {"methodBody": ["METHOD_START", "{", "Pool   pool    =    Pools . typePools . get ( type )  ;", "if    ( pool    =  =    null )     {", "pool    =    new   ReflectionPool ( type ,     4  ,    max )  ;", "Pools . typePools . put ( type ,    pool )  ;", "}", "return   pool ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.Pools"}, {"methodBody": ["METHOD_START", "{", "return   Pools . get ( type )  . obtain (  )  ;", "}", "METHOD_END"], "methodName": ["obtain"], "fileName": "com.badlogic.gdx.utils.Pools"}, {"methodBody": ["METHOD_START", "{", "Pools . typePools . put ( type ,    pool )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.Pools"}, {"methodBody": ["METHOD_START", "{", "int   len    =    string . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "char   ch    =    string . charAt ( i )  ;", "if    (  ( ch    >     6  1  )     &  &     ( ch    <     1  2  7  )  )     {", "oBuffer . append (  ( ch    =  =     '  \\  \\  '     ?     \"  \\  \\  \\  \\  \"     :    ch )  )  ;", "continue ;", "}", "switch    ( ch )     {", "case    '     '     :", "if    (  ( i    =  =     0  )     |  |    escapeSpace )     {", "oBuffer . append (  \"  \\  \\     \"  )  ;", "} else    {", "oBuffer . append ( ch )  ;", "}", "break ;", "case    '  \\ n '     :", "oBuffer . append (  \"  \\  \\ n \"  )  ;", "break ;", "case    '  \\ r '     :", "oBuffer . append (  \"  \\  \\ r \"  )  ;", "break ;", "case    '  \\ t '     :", "oBuffer . append (  \"  \\  \\ t \"  )  ;", "break ;", "case    '  \\ f '     :", "oBuffer . append (  \"  \\  \\ f \"  )  ;", "break ;", "case    '  =  '     :", "case    '  :  '     :", "case    '  #  '     :", "case    '  !  '     :", "oBuffer . append (  '  \\  \\  '  )  . append ( ch )  ;", "break ;", "default    :", "if    (  (  ( ch    <     3  2  )     |  |     ( ch    >     1  2  6  )  )     &    escapeUnicode )     {", "String   hex    =    Integer . toHexString ( ch )  ;", "oBuffer . append (  \"  \\  \\ u \"  )  ;", "for    ( int   j    =     0  ;    j    <     (  4     -     ( hex . length (  )  )  )  ;    j +  +  )     {", "oBuffer . append (  '  0  '  )  ;", "}", "oBuffer . append ( hex )  ;", "} else    {", "oBuffer . append ( ch )  ;", "}", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["dumpString"], "fileName": "com.badlogic.gdx.utils.PropertiesUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( properties    =  =    null )", "throw   new   NullPointerException (  \" ObjectMap   cannot   be   null \"  )  ;", "if    ( reader    =  =    null )", "throw   new   NullPointerException (  \" Reader   cannot   be   null \"  )  ;", "int   mode    =     . NONE ;", "int   unicode    =     0  ;", "int   count    =     0  ;", "char   nextChar ;", "char [  ]    buf    =    new   char [  4  0  ]  ;", "int   offset    =     0  ;", "int   keyLength    =     -  1  ;", "int   intVal ;", "boolean   firstChar    =    true ;", "BufferedReader   br    =    new   BufferedReader ( reader )  ;", "while    ( true )     {", "intVal    =    br . read (  )  ;", "if    ( intVal    =  =     (  -  1  )  )     {", "break ;", "}", "nextChar    =     (  ( char )     ( intVal )  )  ;", "if    ( offset    =  =     ( buf . length )  )     {", "char [  ]    newBuf    =    new   char [  ( buf . length )     *     2  ]  ;", "System . arraycopy ( buf ,     0  ,    newBuf ,     0  ,    offset )  ;", "buf    =    newBuf ;", "}", "if    ( mode    =  =     (  . UNICODE )  )     {", "int   digit    =    Character . digit ( nextChar ,     1  6  )  ;", "if    ( digit    >  =     0  )     {", "unicode    =     ( unicode    <  <     4  )     +    digit ;", "if    (  (  +  + count )     <     4  )     {", "continue ;", "}", "} else", "if    ( count    <  =     4  )     {", "throw   new   IllegalArgumentException (  \" Invalid   Unicode   sequence :    illegal   character \"  )  ;", "}", "mode    =     . NONE ;", "buf [  ( offset +  +  )  ]     =     (  ( char )     ( unicode )  )  ;", "if    ( nextChar    !  =     '  \\ n '  )     {", "continue ;", "}", "}", "if    ( mode    =  =     (  . SLASH )  )     {", "mode    =     . NONE ;", "switch    ( nextChar )     {", "case    '  \\ r '     :", "mode    =     . CONTINUE ;", "continue ;", "case    '  \\ n '     :", "mode    =     . IGNORE ;", "continue ;", "case    ' b '     :", "nextChar    =     '  \\ b '  ;", "break ;", "case    ' f '     :", "nextChar    =     '  \\ f '  ;", "break ;", "case    ' n '     :", "nextChar    =     '  \\ n '  ;", "break ;", "case    ' r '     :", "nextChar    =     '  \\ r '  ;", "break ;", "case    ' t '     :", "nextChar    =     '  \\ t '  ;", "break ;", "case    ' u '     :", "mode    =     . UNICODE ;", "unicode    =    count    =     0  ;", "continue ;", "}", "} else    {", "switch    ( nextChar )     {", "case    '  #  '     :", "case    '  !  '     :", "if    ( firstChar )     {", "while    ( true )     {", "intVal    =    br . read (  )  ;", "if    ( intVal    =  =     (  -  1  )  )     {", "break ;", "}", "nextChar    =     (  ( char )     ( intVal )  )  ;", "if    (  ( nextChar    =  =     '  \\ r '  )     |  |     ( nextChar    =  =     '  \\ n '  )  )     {", "break ;", "}", "}", "continue ;", "}", "break ;", "case    '  \\ n '     :", "if    ( mode    =  =     (  . CONTINUE )  )     {", "mode    =     . IGNORE ;", "continue ;", "}", "case    '  \\ r '     :", "mode    =     . NONE ;", "firstChar    =    true ;", "if    (  ( offset    >     0  )     |  |     (  ( offset    =  =     0  )     &  &     ( keyLength    =  =     0  )  )  )     {", "if    ( keyLength    =  =     (  -  1  )  )     {", "keyLength    =    offset ;", "}", "String   temp    =    new   String ( buf ,     0  ,    offset )  ;", "properties . put ( temp . substring (  0  ,    keyLength )  ,    temp . substring ( keyLength )  )  ;", "}", "keyLength    =     -  1  ;", "offset    =     0  ;", "continue ;", "case    '  \\  \\  '     :", "if    ( mode    =  =     (  . KEY _ DONE )  )     {", "keyLength    =    offset ;", "}", "mode    =     . SLASH ;", "continue ;", "case    '  :  '     :", "case    '  =  '     :", "if    ( keyLength    =  =     (  -  1  )  )     {", "mode    =     . NONE ;", "keyLength    =    offset ;", "continue ;", "}", "break ;", "}", "if    ( Character . isSpace ( nextChar )  )     {", "if    ( mode    =  =     (  . CONTINUE )  )     {", "mode    =     . IGNORE ;", "}", "if    (  (  ( offset    =  =     0  )     |  |     ( offset    =  =    keyLength )  )     |  |     ( mode    =  =     (  . IGNORE )  )  )     {", "continue ;", "}", "if    ( keyLength    =  =     (  -  1  )  )     {", "mode    =     . KEY _ DONE ;", "continue ;", "}", "}", "if    (  ( mode    =  =     (  . IGNORE )  )     |  |     ( mode    =  =     (  . CONTINUE )  )  )     {", "mode    =     . NONE ;", "}", "}", "firstChar    =    false ;", "if    ( mode    =  =     (  . KEY _ DONE )  )     {", "keyLength    =    offset ;", "mode    =     . NONE ;", "}", "buf [  ( offset +  +  )  ]     =    nextChar ;", "}", "if    (  ( mode    =  =     (  . UNICODE )  )     &  &     ( count    <  =     4  )  )     {", "throw   new   IllegalArgumentException (  \" Invalid   Unicode   sequence :    expected   format    \\  \\ uxxxx \"  )  ;", "}", "if    (  ( keyLength    =  =     (  -  1  )  )     &  &     ( offset    >     0  )  )     {", "keyLength    =    offset ;", "}", "if    ( keyLength    >  =     0  )     {", "String   temp    =    new   String ( buf ,     0  ,    offset )  ;", "String   key    =    temp . substring (  0  ,    keyLength )  ;", "String   value    =    temp . substring ( keyLength )  ;", "if    ( mode    =  =     (  . SLASH )  )     {", "value    +  =     \"  \\ u 0  0  0  0  \"  ;", "}", "properties . put ( key ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.utils.PropertiesUtils"}, {"methodBody": ["METHOD_START", "{", "PropertiesUtils . storeImpl ( properties ,    writer ,    comment ,    false )  ;", "}", "METHOD_END"], "methodName": ["store"], "fileName": "com.badlogic.gdx.utils.PropertiesUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( comment    !  =    null )     {", ". writeComment ( writer ,    comment )  ;", "}", "writer . write (  \"  #  \"  )  ;", "writer . write ( new   Date (  )  . toString (  )  )  ;", "writer . write (  . LINE _ SEPARATOR )  ;", "StringBuilder   sb    =    new   StringBuilder (  2  0  0  )  ;", "for    ( ObjectMap . Entry < String ,    String >    entry    :    properties . entries (  )  )     {", ". dumpString ( sb ,    entry . key ,    true ,    escapeUnicode )  ;", "sb . append (  '  =  '  )  ;", ". dumpString ( sb ,    entry . value ,    false ,    escapeUnicode )  ;", "writer . write (  . LINE _ SEPARATOR )  ;", "writer . write ( sb . toString (  )  )  ;", "sb . setLength (  0  )  ;", "}", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["storeImpl"], "fileName": "com.badlogic.gdx.utils.PropertiesUtils"}, {"methodBody": ["METHOD_START", "{", "writer . write (  \"  #  \"  )  ;", "int   len    =    comment . length (  )  ;", "int   curIndex    =     0  ;", "int   lastIndex    =     0  ;", "while    ( curIndex    <    len )     {", "char   c    =    comment . charAt ( curIndex )  ;", "if    (  (  ( c    >     '  \\ u 0  0 ff '  )     |  |     ( c    =  =     '  \\ n '  )  )     |  |     ( c    =  =     '  \\ r '  )  )     {", "if    ( lastIndex    !  =    curIndex )", "writer . write ( comment . substring ( lastIndex ,    curIndex )  )  ;", "if    ( c    >     '  \\ u 0  0 ff '  )     {", "String   hex    =    Integer . toHexString ( c )  ;", "writer . write (  \"  \\  \\ u \"  )  ;", "for    ( int   j    =     0  ;    j    <     (  4     -     ( hex . length (  )  )  )  ;    j +  +  )     {", "writer . write (  '  0  '  )  ;", "}", "writer . write ( hex )  ;", "} else    {", "writer . write (  . LINE _ SEPARATOR )  ;", "if    (  (  ( c    =  =     '  \\ r '  )     &  &     ( curIndex    !  =     ( len    -     1  )  )  )     &  &     (  ( comment . charAt (  ( curIndex    +     1  )  )  )     =  =     '  \\ n '  )  )     {", "curIndex +  +  ;", "}", "if    (  ( curIndex    =  =     ( len    -     1  )  )     |  |     (  (  ( comment . charAt (  ( curIndex    +     1  )  )  )     !  =     '  #  '  )     &  &     (  ( comment . charAt (  ( curIndex    +     1  )  )  )     !  =     '  !  '  )  )  )", "writer . write (  \"  #  \"  )  ;", "}", "lastIndex    =    curIndex    +     1  ;", "}", "curIndex +  +  ;", "}", "if    ( lastIndex    !  =    curIndex )", "writer . write ( comment . substring ( lastIndex ,    curIndex )  )  ;", "writer . write (  . LINE _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["writeComment"], "fileName": "com.badlogic.gdx.utils.PropertiesUtils"}, {"methodBody": ["METHOD_START", "{", "T [  ]    values    =    this . values ;", "if    (  ( size )     =  =     ( values . length )  )     {", "resize (  (  ( values . length )     <  <     1  )  )  ;", "values    =    this . values ;", "}", "int   head    =    this . head ;", "head -  -  ;", "if    ( head    =  =     (  -  1  )  )     {", "head    =     ( values . length )     -     1  ;", "}", "values [ head ]     =    object ;", "this . head    =    head ;", "( this . size )  +  +  ;", "}", "METHOD_END"], "methodName": ["addFirst"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "T [  ]    values    =    this . values ;", "if    (  ( size )     =  =     ( values . length )  )     {", "resize (  (  ( values . length )     <  <     1  )  )  ;", "values    =    this . values ;", "}", "values [  (  ( tail )  +  +  )  ]     =    object ;", "if    (  ( tail )     =  =     ( values . length )  )     {", "tail    =     0  ;", "}", "( size )  +  +  ;", "}", "METHOD_END"], "methodName": ["addLast"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return ;", "final   T [  ]    value =    thivalue", "final   int   head    =    thihead ;", "final   int   tail    =    thitail ;", "if    ( head    <    tail )     {", "for    ( int   i    =    head ;    i    <    tail ;    i +  +  )     {", "valuei ]     =    null ;", "}", "} el    {", "for    ( int   i    =    head ;    i    <     ( valuelength )  ;    i +  +  )     {", "valuei ]     =    null ;", "}", "for    ( int   i    =     0  ;    i    <    tail ;    i +  +  )     {", "valuei ]     =    null ;", "}", "}", "thihead    =     0  ;", "thitail    =     0  ;", "thize    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "final   int   needed    =     ( size )     +    additional ;", "if    (  ( values . length )     <    needed )     {", "resize ( needed )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )", "return   true ;", "if    (  ( o    =  =    null )     |  |     (  !  ( o   instanceof    )  )  )", "return   false ;", "<  ?  >    q    =     (  (  <  ?  >  )     ( o )  )  ;", "final   int   size    =    this . size ;", "if    (  ( q . size )     !  =    size )", "return   false ;", "final   T [  ]    myValues    =    this . values ;", "final   int   myBackingLength    =    myValues . length ;", "final   Object [  ]    itsValues    =    q . values ;", "final   int   itsBackingLength    =    itsValues . length ;", "int   myIndex    =    head ;", "int   itsIndex    =    q . head ;", "for    ( int   s    =     0  ;    s    <    size ;    s +  +  )     {", "T   myValue    =    myValues [ myIndex ]  ;", "Object   itsValue    =    itsValues [ itsIndex ]  ;", "if    (  !  ( myValue    =  =    null    ?    itsValue    =  =    null    :    myValue . equals ( itsValue )  )  )", "return   false ;", "myIndex +  +  ;", "itsIndex +  +  ;", "if    ( myIndex    =  =    myBackingLength )", "myIndex    =     0  ;", "if    ( itsIndex    =  =    itsBackingLength )", "itsIndex    =     0  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )     {", "throw   new   NoSuchElementException (  \"    is   empty .  \"  )  ;", "}", "return   values [ head ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    ( index    <     0  )", "throw   new   IndexOOfBoundsException (  (  \" index   can ' t   be    <     0  :     \"     +    index )  )  ;", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "final   T [  ]    values    =    this . values ;", "int   i    =     ( head )     +    index ;", "if    ( i    >  =     ( values . length )  )     {", "i    -  =    values . length ;", "}", "return   values [ i ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "final   int   size    =    this . size ;", "final   T [  ]    values    =    this . values ;", "final   int   backingLength    =    values . length ;", "int   index    =    this . head ;", "int   hash    =    size    +     1  ;", "for    ( int   s    =     0  ;    s    <    size ;    s +  +  )     {", "final   T   value    =    values [ index ]  ;", "hash    *  =     3  1  ;", "if    ( value    !  =    null )", "hash    +  =    value . hashCode (  )  ;", "index +  +  ;", "if    ( index    =  =    backingLength )", "index    =     0  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )", "return    -  1  ;", "T [  ]    value =    thivalue", "final   int   head    =    thihead ;", "final   int   tail    =    thitail ;", "if    ( identity    |  |     ( value    =  =    null )  )     {", "if    ( head    <    tail )     {", "for    ( int   i    =    head ;    i    <    tail ;    i +  +  )", "if    (  ( valuei ]  )     =  =    value )", "return   i ;", "} el    {", "for    ( int   i    =    head ,    n    =    valuelength ;    i    <    n ;    i +  +  )", "if    (  ( valuei ]  )     =  =    value )", "return   i    -    head ;", "for    ( int   i    =     0  ;    i    <    tail ;    i +  +  )", "if    (  ( valuei ]  )     =  =    value )", "return    ( i    +     ( valuelength )  )     -    head ;", "}", "} el    {", "if    ( head    <    tail )     {", "for    ( int   i    =    head ;    i    <    tail ;    i +  +  )", "if    ( value . equalvaluei ]  )  )", "return   i ;", "} el    {", "for    ( int   i    =    head ,    n    =    valuelength ;    i    <    n ;    i +  +  )", "if    ( value . equalvaluei ]  )  )", "return   i    -    head ;", "for    ( int   i    =     0  ;    i    <    tail ;    i +  +  )", "if    ( value . equalvaluei ]  )  )", "return    ( i    +     ( valuelength )  )     -    head ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterable )     =  =    null )", "iterable    =    newIterable ( this )  ;", "return   iterable . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )     {", "throw   new   NoSuchElementException (  \"    is   empty .  \"  )  ;", "}", "final   T [  ]    values    =    this . values ;", "int   tail    =    this . tail ;", "tail -  -  ;", "if    ( tail    =  =     (  -  1  )  )     {", "tail    =     ( values . length )     -     1  ;", "}", "return   values [ tail ]  ;", "}", "METHOD_END"], "methodName": ["last"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )     {", "throw   new   NoSuchElementException (  \"    is   empty .  \"  )  ;", "}", "final   T [  ]    values    =    this . values ;", "final   T   result    =    values [ head ]  ;", "values [ head ]     =    null ;", "( head )  +  +  ;", "if    (  ( head )     =  =     ( values . length )  )     {", "head    =     0  ;", "}", "( size )  -  -  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["removeFirst"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    ( index    <     0  )", "throw   new   IndexOOfBoundsException (  (  \" index   can ' t   be    <     0  :     \"     +    index )  )  ;", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "T [  ]    values    =    this . values ;", "int   head    =    this . head ;", "int   tail    =    this . tail ;", "index    +  =    head ;", "T   value ;", "if    ( head    <    tail )     {", "value    =    values [ index ]  ;", "System . arraycopy ( values ,     ( index    +     1  )  ,    values ,    index ,     ( tail    -    index )  )  ;", "values [ tail ]     =    null ;", "( this . tail )  -  -  ;", "} else", "if    ( index    >  =     ( values . length )  )     {", "index    -  =    values . length ;", "value    =    values [ index ]  ;", "System . arraycopy ( values ,     ( index    +     1  )  ,    values ,    index ,     ( tail    -    index )  )  ;", "( this . tail )  -  -  ;", "} else    {", "value    =    values [ index ]  ;", "System . arraycopy ( values ,    head ,    values ,     ( head    +     1  )  ,     ( index    -    head )  )  ;", "values [ head ]     =    null ;", "( this . head )  +  +  ;", "if    (  ( this . head )     =  =     ( values . length )  )     {", "this . head    =     0  ;", "}", "}", "( size )  -  -  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )     {", "throw   new   NoSuchElementException (  \"    is   empty .  \"  )  ;", "}", "final   T [  ]    values    =    this . values ;", "int   tail    =    this . tail ;", "tail -  -  ;", "if    ( tail    =  =     (  -  1  )  )     {", "tail    =     ( values . length )     -     1  ;", "}", "final   T   result    =    values [ tail ]  ;", "values [ tail ]     =    null ;", "this . tail    =    tail ;", "( size )  -  -  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["removeLast"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "int   index    =    indexOf ( value ,    identity )  ;", "if    ( index    =  =     (  -  1  )  )", "return   false ;", "removeIndex ( index )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "final   T [  ]    values    =    this . values ;", "final   int   head    =    this . head ;", "final   int   tail    =    this . tail ;", "@ SuppressWarnings (  \" unchecked \"  )", "final   T [  ]    newArray    =     (  ( T [  ]  )     ( ArrayReflection . newInstance ( values . getClass (  )  . getComponentType (  )  ,    newSize )  )  )  ;", "if    ( head    <    tail )     {", "System . arraycopy ( values ,    head ,    newArray ,     0  ,     ( tail    -    head )  )  ;", "} else", "if    (  ( size )     >     0  )     {", "final   int   rest    =     ( values . length )     -    head ;", "System . arraycopy ( values ,    head ,    newArray ,     0  ,    rest )  ;", "System . arraycopy ( values ,     0  ,    newArray ,    rest ,    tail )  ;", "}", "this . values    =    newArray ;", "this . head    =     0  ;", "this . tail    =    size ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ze )     =  =     0  )     {", "return    \"  [  ]  \"  ;", "}", "final   T [  ]    value =    thivalue", "final   int   head    =    thihead ;", "final   int   tail    =    thitail ;", "StringBuilder       =    new   StringBuilder (  6  4  )  ;", ". append (  '  [  '  )  ;", ". append ( valuehead ]  )  ;", "for    ( int   i    =     ( head    +     1  )     %     ( valuelength )  ;    i    !  =    tail ;    i    =     ( i    +     1  )     %     ( valuelength )  )     {", ". append (  \"  ,     \"  )  . append ( valuei ]  )  ;", "}", ". append (  '  ]  '  )  ;", "return    . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.Queue"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( q 1  ,    q 2  )  ;", "assertEquals (  \" Hash   codes   are   not   equal \"  ,    q 1  . hashCode (  )  ,    q 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEqualsAndHash"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "Assert . assertEquals ( values [ i ]  ,    q . get ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValues"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "final   Queue < Integer >    q    =    new   Queue < Integer >  (  7  )  ;", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <     4  ;    j +  +  )     {", "q . addLast ( j )  ;", "}", "assertEquals (  (  (  \" get (  0  )    is   not   equal   to   peek    (  \"     +    i )     +     \"  )  \"  )  ,    q . get (  0  )  ,    q . first (  )  )  ;", "assertEquals (  (  (  \" get ( size -  1  )    is   not   equal   to   peekLast    (  \"     +    i )     +     \"  )  \"  )  ,    q . get (  (  ( q . size )     -     1  )  )  ,    q . last (  )  )  ;", "for    ( int   j    =     0  ;    j    <     4  ;    j +  +  )     {", "assertTrue (  (  ( q . get ( j )  )     =  =    j )  )  ;", "}", "for    ( int   j    =     0  ;    j    <     (  4     -     1  )  ;    j +  +  )     {", "q . removeFirst (  )  ;", "assertEquals (  (  (  \" get (  0  )    is   not   equal   to   peek    (  \"     +    i )     +     \"  )  \"  )  ,    q . get (  0  )  ,    q . first (  )  )  ;", "}", "q . removeFirst (  )  ;", "assert    ( q . size )     =  =     0  ;", "try    {", "q . get (  0  )  ;", "fail (  \" get (  )    on   empty   queue   did   not   throw \"  )  ;", "}    catch    ( IndexOutOfBoundsException   ignore )     {", "}", "}", "}", "METHOD_END"], "methodName": ["getTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "Queue < Integer >    q 1     =    new   Queue < Integer >  (  )  ;", "Queue < Integer >    q 2     =    new   Queue < Integer >  (  )  ;", "assertEqualsAndHash ( q 1  ,    q 2  )  ;", "q 1  . addFirst (  1  )  ;", "assertNotEquals ( q 1  ,    q 2  )  ;", "q 2  . addFirst (  1  )  ;", "assertEqualsAndHash ( q 1  ,    q 2  )  ;", "q 1  . clear (  )  ;", "q 1  . addLast (  1  )  ;", "q 1  . addLast (  2  )  ;", "q 2  . addLast (  2  )  ;", "assertEqualsAndHash ( q 1  ,    q 2  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "q 1  . addLast ( i )  ;", "q 1  . addLast ( i )  ;", "q 1  . removeFirst (  )  ;", "assertNotEquals ( q 1  ,    q 2  )  ;", "q 2  . addLast ( i )  ;", "q 2  . addLast ( i )  ;", "q 2  . removeFirst (  )  ;", "assertEqualsAndHash ( q 1  ,    q 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["hashEqualsTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "final   Queue < Integer >    q    =    new   Queue < Integer >  (  )  ;", "for    ( int   j    =     0  ;    j    <  =     6  ;    j +  +  )", "q . addLast ( j )  ;", "for    ( int   j    =     0  ;    j    <  =     6  ;    j +  +  )", "assertEquals ( q . indexOf ( j ,    false )  ,    j )  ;", "q . clear (  )  ;", "for    ( int   j    =     2  ;    j    >  =     0  ;    j -  -  )", "q . addFirst ( j )  ;", "for    ( int   j    =     3  ;    j    <  =     6  ;    j +  +  )", "q . addLast ( j )  ;", "for    ( int   j    =     0  ;    j    <  =     6  ;    j +  +  )", "assertEquals ( q . indexOf ( j ,    false )  ,    j )  ;", "}", "METHOD_END"], "methodName": ["indexOfTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "Queue < Integer >    queue    =    new   Queue < Integer >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "queue . addLast ( i )  ;", "if    ( i    >     5  0  )", "queue . removeFirst (  )  ;", "}", "Iterator < Integer >    it    =    queue . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "it . next (  )  ;", "it . remove (  )  ;", "}", "queue . addLast (  1  3  3  7  )  ;", "Integer   i    =    queue . first (  )  ;", "assertEquals (  1  3  3  7  ,     (  ( int )     ( i )  )  )  ;", "}", "METHOD_END"], "methodName": ["iteratorRemoveEdgeCaseTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "final   Queue < Integer >    q    =    new   Queue < Integer >  (  )  ;", "for    ( int   j    =     0  ;    j    <  =     6  ;    j +  +  )", "q . addLast ( j )  ;", "Iterator < Integer >    iter    =    q . iterator (  )  ;", "for    ( int   j    =     0  ;    j    <  =     6  ;    j +  +  )", "assertEquals ( iter . next (  )  . intValue (  )  ,    j )  ;", "iter    =    q . iterator (  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     1  ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "iter . next (  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     2  ,     4  ,     5  ,     6  )  ;", "iter . next (  )  ;", "iter . next (  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     2  ,     4  ,     5  )  ;", "q . clear (  )  ;", "for    ( int   j    =     2  ;    j    >  =     0  ;    j -  -  )", "q . addFirst ( j )  ;", "for    ( int   j    =     3  ;    j    <  =     6  ;    j +  +  )", "q . addLast ( j )  ;", "iter    =    q . iterator (  )  ;", "for    ( int   j    =     0  ;    j    <  =     6  ;    j +  +  )", "assertEquals ( iter . next (  )  . intValue (  )  ,    j )  ;", "iter    =    q . iterator (  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     1  ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "iter . next (  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     2  ,     4  ,     5  ,     6  )  ;", "iter . next (  )  ;", "iter . next (  )  ;", "iter . next (  )  ;", "iter . remove (  )  ;", "assertValues ( q ,     2  ,     4  ,     5  )  ;", "}", "METHOD_END"], "methodName": ["iteratorTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "final   Queue < Integer >    q    =    new   Queue < Integer >  (  )  ;", "for    ( int   j    =     0  ;    j    <  =     6  ;    j +  +  )", "q . addLast ( j )  ;", "assertValues ( q ,     0  ,     1  ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "q . removeIndex (  0  )  ;", "assertValues ( q ,     1  ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "q . removeIndex (  1  )  ;", "assertValues ( q ,     1  ,     3  ,     4  ,     5  ,     6  )  ;", "q . removeIndex (  4  )  ;", "assertValues ( q ,     1  ,     3  ,     4  ,     5  )  ;", "q . removeIndex (  2  )  ;", "assertValues ( q ,     1  ,     3  ,     5  )  ;", "q . clear (  )  ;", "for    ( int   j    =     2  ;    j    >  =     0  ;    j -  -  )", "q . addFirst ( j )  ;", "for    ( int   j    =     3  ;    j    <  =     6  ;    j +  +  )", "q . addLast ( j )  ;", "assertValues ( q ,     0  ,     1  ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "q . removeIndex (  1  )  ;", "assertValues ( q ,     0  ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "q . removeIndex (  0  )  ;", "assertValues ( q ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "q . clear (  )  ;", "for    ( int   j    =     2  ;    j    >  =     0  ;    j -  -  )", "q . addFirst ( j )  ;", "for    ( int   j    =     3  ;    j    <  =     6  ;    j +  +  )", "q . addLast ( j )  ;", "assertValues ( q ,     0  ,     1  ,     2  ,     3  ,     4  ,     5  ,     6  )  ;", "q . removeIndex (  5  )  ;", "assertValues ( q ,     0  ,     1  ,     2  ,     3  ,     4  ,     6  )  ;", "q . removeIndex (  5  )  ;", "assertValues ( q ,     0  ,     1  ,     2  ,     3  ,     4  )  ;", "}", "METHOD_END"], "methodName": ["removeTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "final   Queue < Integer >    q    =    new   Queue < Integer >  (  8  )  ;", "assertTrue (  \" New   deque   is   not   empty !  \"  ,     (  ( q . size )     =  =     0  )  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    i ;    j +  +  )     {", "try    {", "q . addFirst ( j )  ;", "}    catch    ( IllegalStateException   e )     {", "fail (  (  (  (  (  \" Failed   to   add   element    \"     +    j )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  )  ;", "}", "final   Integer   peeked    =    q . first (  )  ;", "assertTrue (  (  (  (  (  (  (  \" peek   shows    \"     +    peeked )     +     \"  ,    should   be    \"  )     +    j )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,    peeked . equals ( j )  )  ;", "final   int   size    =    q . size ;", "assertTrue (  (  (  (  (  (  (  \" Size   should   be    \"     +     ( j    +     1  )  )     +     \"    but   is    \"  )     +    size )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( size    =  =     ( j    +     1  )  )  )  ;", "}", "if    ( i    !  =     0  )     {", "final   Integer   peek    =    q . last (  )  ;", "assertTrue (  (  (  (  (  \" Last   thing   is   not   zero   but    \"     +    peek )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( peek    =  =     0  )  )  ;", "}", "for    ( int   j    =     0  ;    j    <    i ;    j +  +  )     {", "final   Integer   pop    =    q . removeLast (  )  ;", "assertTrue (  (  (  (  (  (  (  \" Popped   should   be    \"     +    j )     +     \"    but   is    \"  )     +    pop )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( pop    =  =    j )  )  ;", "final   int   size    =    q . size ;", "assertTrue (  (  (  (  (  (  (  \" Size   should   be    \"     +     (  ( i    -     1  )     -    j )  )     +     \"    but   is    \"  )     +    size )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( size    =  =     (  ( i    -     1  )     -    j )  )  )  ;", "}", "assertTrue (  (  \" Not   empty   after   cycle    \"     +    i )  ,     (  ( q . size )     =  =     0  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     5  6  ;    i +  +  )     {", "q . addFirst (  4  2  )  ;", "}", "q . clear (  )  ;", "assertTrue (  \" Clear   did   not   clear   properly \"  ,     (  ( q . size )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["resizableDequeTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "final   Queue < Integer >    q    =    new   Queue < Integer >  (  8  )  ;", "assertTrue (  \" New   queue   is   not   empty !  \"  ,     (  ( q . size )     =  =     0  )  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    i ;    j +  +  )     {", "try    {", "q . addLast ( j )  ;", "}    catch    ( IllegalStateException   e )     {", "fail (  (  (  (  (  \" Failed   to   add   element    \"     +    j )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  )  ;", "}", "final   Integer   peeked    =    q . last (  )  ;", "assertTrue (  (  (  (  (  (  (  \" peekLast   shows    \"     +    peeked )     +     \"  ,    should   be    \"  )     +    j )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,    peeked . equals ( j )  )  ;", "final   int   size    =    q . size ;", "assertTrue (  (  (  (  (  (  (  \" Size   should   be    \"     +     ( j    +     1  )  )     +     \"    but   is    \"  )     +    size )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( size    =  =     ( j    +     1  )  )  )  ;", "}", "if    ( i    !  =     0  )     {", "final   Integer   peek    =    q . first (  )  ;", "assertTrue (  (  (  (  (  \" First   thing   is   not   zero   but    \"     +    peek )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( peek    =  =     0  )  )  ;", "}", "for    ( int   j    =     0  ;    j    <    i ;    j +  +  )     {", "final   Integer   pop    =    q . removeFirst (  )  ;", "assertTrue (  (  (  (  (  (  (  \" Popped   should   be    \"     +    j )     +     \"    but   is    \"  )     +    pop )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( pop    =  =    j )  )  ;", "final   int   size    =    q . size ;", "assertTrue (  (  (  (  (  (  (  \" Size   should   be    \"     +     (  ( i    -     1  )     -    j )  )     +     \"    but   is    \"  )     +    size )     +     \"     (  \"  )     +    i )     +     \"  )  \"  )  ,     ( size    =  =     (  ( i    -     1  )     -    j )  )  )  ;", "}", "assertTrue (  (  \" Not   empty   after   cycle    \"     +    i )  ,     (  ( q . size )     =  =     0  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     5  6  ;    i +  +  )     {", "q . addLast (  4  2  )  ;", "}", "q . clear (  )  ;", "assertTrue (  \" Clear   did   not   clear   properly \"  ,     (  ( q . size )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["resizableQueueTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "Queue < Integer >    q    =    new   Queue < Integer >  (  1  )  ;", "assertTrue ( q . toString (  )  . equals (  \"  [  ]  \"  )  )  ;", "q . addLast (  4  )  ;", "assertTrue ( q . toString (  )  . equals (  \"  [  4  ]  \"  )  )  ;", "q . addLast (  5  )  ;", "q . addLast (  6  )  ;", "q . addLast (  7  )  ;", "assertTrue ( q . toString (  )  . equals (  \"  [  4  ,     5  ,     6  ,     7  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["toStringTest"], "fileName": "com.badlogic.gdx.utils.QueueTest"}, {"methodBody": ["METHOD_START", "{", "T   left    =    array [ leftIdx ]  ;", "int   midIdx    =     ( leftIdx    +    rightIdx )     /     2  ;", "T   mid    =    array [ midIdx ]  ;", "T   right    =    array [ rightIdx ]  ;", "if    (  ( p . pare ( left ,    mid )  )     >     0  )     {", "if    (  ( p . pare ( mid ,    right )  )     >     0  )     {", "return   midIdx ;", "} else", "if    (  ( p . pare ( left ,    right )  )     >     0  )     {", "return   rightIdx ;", "} else    {", "return   leftIdx ;", "}", "} else    {", "if    (  ( p . pare ( left ,    right )  )     >     0  )     {", "return   leftIdx ;", "} else", "if    (  ( p . pare ( mid ,    right )  )     >     0  )     {", "return   rightIdx ;", "} else    {", "return   midIdx ;", "}", "}", "}", "METHOD_END"], "methodName": ["medianOfThreePivot"], "fileName": "com.badlogic.gdx.utils.QuickSelect"}, {"methodBody": ["METHOD_START", "{", "T   pivotValue    =    array [ pivot ]  ;", "swap ( right ,    pivot )  ;", "int   storage    =    left ;", "for    ( int   i    =    left ;    i    <    right ;    i +  +  )     {", "if    (  ( p . pare ( array [ i ]  ,    pivotValue )  )     <     0  )     {", "swap ( storage ,    i )  ;", "storage +  +  ;", "}", "}", "swap ( right ,    storage )  ;", "return   storage ;", "}", "METHOD_END"], "methodName": ["partition"], "fileName": "com.badlogic.gdx.utils.QuickSelect"}, {"methodBody": ["METHOD_START", "{", "if    ( left    =  =    right )", "return   left ;", "int   pivotIndex    =    medianOfThreePivot ( left ,    right )  ;", "int   pivotNewIndex    =    partition ( left ,    right ,    pivotIndex )  ;", "int   pivotDist    =     ( pivotNewIndex    -    left )     +     1  ;", "int   result ;", "if    ( pivotDist    =  =    k )     {", "result    =    pivotNewIndex ;", "} else", "if    ( k    <    pivotDist )     {", "result    =    recursive ( left ,     ( pivotNewIndex    -     1  )  ,    k )  ;", "} else    {", "result    =    recursive (  ( pivotNewIndex    +     1  )  ,    right ,     ( k    -    pivotDist )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["recursiveSelect"], "fileName": "com.badlogic.gdx.utils.QuickSelect"}, {"methodBody": ["METHOD_START", "{", "this . array    =    items ;", "this . comp    =    comp ;", "return   recursive (  0  ,     ( size    -     1  )  ,    n )  ;", "}", "METHOD_END"], "methodName": ["select"], "fileName": "com.badlogic.gdx.utils.QuickSelect"}, {"methodBody": ["METHOD_START", "{", "T   tmp    =    array [ left ]  ;", "array [ left ]     =    array [ right ]  ;", "array [ right ]     =    tmp ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.QuickSelect"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Class . getConstructor ( type ,     (  ( Class [  ]  )     ( null )  )  )  ;", "}    catch    ( Exception   ex 1  )     {", "try    {", "Constructor   constructor    =    Class . getDeclaredConstructor ( type ,     (  ( Class [  ]  )     ( null )  )  )  ;", "constructor . setAccessible ( true )  ;", "return   constructor ;", "}    catch    ( Exception   ex 2  )     {", "return   null ;", "}", "}", "}", "METHOD_END"], "methodName": ["findConstructor"], "fileName": "com.badlogic.gdx.utils.ReflectionPool"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( T )     ( constructor . newInstance (  (  ( Object [  ]  )     ( null )  )  )  )  )  ;", "}    catch    ( Excep   ex )     {", "throw   new   GdxRuntimeExcep (  (  \" Unable   to   create   new   instance :     \"     +     ( constructor . getDeclaringClass (  )  . getName (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newObject"], "fileName": "com.badlogic.gdx.utils.ReflectionPool"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "case   fit    :", "{", "float   targetRatio    =    targetHeight    /    targetWidth ;", "float   sourceRatio    =    sourceHeight    /    sourceWidth ;", "float   scale    =     ( targetRatio    >    sourceRatio )     ?    targetWidth    /    sourceWidth    :    targetHeight    /    sourceHeight ;", ". temp . x    =    sourceWidth    *    scale ;", ". temp . y    =    sourceHeight    *    scale ;", "break ;", "}", "case   fill    :", "{", "float   targetRatio    =    targetHeight    /    targetWidth ;", "float   sourceRatio    =    sourceHeight    /    sourceWidth ;", "float   scale    =     ( targetRatio    <    sourceRatio )     ?    targetWidth    /    sourceWidth    :    targetHeight    /    sourceHeight ;", ". temp . x    =    sourceWidth    *    scale ;", ". temp . y    =    sourceHeight    *    scale ;", "break ;", "}", "case   fillX    :", "{", "float   scale    =    targetWidth    /    sourceWidth ;", ". temp . x    =    sourceWidth    *    scale ;", ". temp . y    =    sourceHeight    *    scale ;", "break ;", "}", "case   fillY    :", "{", "float   scale    =    targetHeight    /    sourceHeight ;", ". temp . x    =    sourceWidth    *    scale ;", ". temp . y    =    sourceHeight    *    scale ;", "break ;", "}", "case   stretch    :", ". temp . x    =    targetWidth ;", ". temp . y    =    targetHeight ;", "break ;", "case   stretchX    :", ". temp . x    =    targetWidth ;", ". temp . y    =    sourceHeight ;", "break ;", "case   stretchY    :", ". temp . x    =    sourceWidth ;", ". temp . y    =    targetHeight ;", "break ;", "case   none    :", ". temp . x    =    sourceWidth ;", ". temp . y    =    sourceHeight ;", "break ;", "}", "return    . temp ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.badlogic.gdx.utils.Scaling"}, {"methodBody": ["METHOD_START", "{", "final   int   w    =    Gdx . graphics . getBackBufferWidth (  )  ;", "final   int   h    =    Gdx . graphics . getBackBufferHeight (  )  ;", "return    . getFrameBufferPixels (  0  ,     0  ,    w ,    h ,    flipY )  ;", "}", "METHOD_END"], "methodName": ["getFrameBufferPixels"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glPixelStorei ( GL 2  0  . GL _ PACK _ ALIGNMENT ,     1  )  ;", "final   ByteBuffer   pixels    =    BufferUnewByteBuffer (  (  ( w    *    h )     *     4  )  )  ;", "Gdx . gl . glReadPixels ( x ,    y ,    w ,    h ,    GL 2  0  . GL _ RGBA ,    GL 2  0  . GL _ UNSIGNED _ BYTE ,    pixels )  ;", "final   int   numBytes    =     ( w    *    h )     *     4  ;", "byte [  ]    lines    =    new   byte [ numBytes ]  ;", "if    ( flipY )     {", "final   int   numBytesPerLine    =    w    *     4  ;", "for    ( int   i    =     0  ;    i    <    h ;    i +  +  )     {", "pixels . position (  (  (  ( h    -    i )     -     1  )     *    numBytesPerLine )  )  ;", "pixels . get ( lines ,     ( i    *    numBytesPerLine )  ,    numBytesPerLine )  ;", "}", "} else    {", "pixels . clear (  )  ;", "pixels . get ( lines )  ;", "}", "return   lines ;", "}", "METHOD_END"], "methodName": ["getFrameBufferPixels"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "Gdx . gl . glPixelStorei ( GL 2  0  . GL _ PACK _ ALIGNMENT ,     1  )  ;", "final   Pixmap   pixmap    =    new   Pixmap ( w ,    h ,    Pixmap . Format . RGBA 8  8  8  8  )  ;", "ByteBuffer   pixels    =    pixmap . getPixels (  )  ;", "Gdx . gl . glReadPixels ( x ,    y ,    w ,    h ,    GL 2  0  . GL _ RGBA ,    GL 2  0  . GL _ UNSIGNED _ BYTE ,    pixels )  ;", "return   pixmap ;", "}", "METHOD_END"], "methodName": ["getFrameBufferPixmap"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   w    =    Gdx . graphics . getBackBufferWidth (  )  ;", "final   int   h    =    Gdx . graphics . getBackBufferHeight (  )  ;", "return    . getFrameBufferTexture (  0  ,     0  ,    w ,    h )  ;", "}", "METHOD_END"], "methodName": ["getFrameBufferTexture"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   potW    =    MathUtils . nextPowerOfTwo ( w )  ;", "final   int   potH    =    MathUtils . nextPowerOfTwo ( h )  ;", "final   Pixmap   pixmap    =     . getFrameBufferPixmap ( x ,    y ,    w ,    h )  ;", "final   Pixmap   potPixmap    =    new   Pixmap ( potW ,    potH ,    Pixmap . Format . RGBA 8  8  8  8  )  ;", "potPixmap . drawPixmap ( pixmap ,     0  ,     0  )  ;", "Texture   texture    =    new   Texture ( potPixmap )  ;", "TextureRegion   textureRegion    =    new   TextureRegion ( texture ,     0  ,    h ,    w ,     (  - h )  )  ;", "potPixmap . dispose (  )  ;", "pixmap . dispose (  )  ;", "return   textureRegion ;", "}", "METHOD_END"], "methodName": ["getFrameBufferTexture"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "int   highestIdx    =     0  ;", "for    ( int   i    =     1  ;    i    <    size ;    i +  +  )     {", "int   parison    =    p . pare ( items [ i ]  ,    items [ highestIdx ]  )  ;", "if    ( parison    >     0  )     {", "highestIdx    =    i ;", "}", "}", "return   highestIdx ;", "}", "METHOD_END"], "methodName": ["fastMax"], "fileName": "com.badlogic.gdx.utils.Select"}, {"methodBody": ["METHOD_START", "{", "int   lowestIdx    =     0  ;", "for    ( int   i    =     1  ;    i    <    size ;    i +  +  )     {", "int   parison    =    p . pare ( items [ i ]  ,    items [ lowestIdx ]  )  ;", "if    ( parison    <     0  )     {", "lowestIdx    =    i ;", "}", "}", "return   lowestIdx ;", "}", "METHOD_END"], "methodName": ["fastMin"], "fileName": "com.badlogic.gdx.utils.Select"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Select . instance )     =  =    null )", "Select . instance    =    new   Select (  )  ;", "return   Select . instance ;", "}", "METHOD_END"], "methodName": ["instance"], "fileName": "com.badlogic.gdx.utils.Select"}, {"methodBody": ["METHOD_START", "{", "int   idx    =    selectIndex ( items ,    comp ,    kthLowest ,    size )  ;", "return   items [ idx ]  ;", "}", "METHOD_END"], "methodName": ["select"], "fileName": "com.badlogic.gdx.utils.Select"}, {"methodBody": ["METHOD_START", "{", "if    ( size    <     1  )     {", "throw   new   GdxRuntimeException (  \" cannot   select   from   empty   array    ( size    <     1  )  \"  )  ;", "} else", "if    ( kthLowest    >    size )     {", "throw   new   GdxRuntimeException (  (  (  (  \" Kth   rank   is   larger   than   size .    k :     \"     +    kthLowest )     +     \"  ,    size :     \"  )     +    size )  )  ;", "}", "int   idx ;", "if    ( kthLowest    =  =     1  )     {", "idx    =    fastMin ( items ,    comp ,    size )  ;", "} else", "if    ( kthLowest    =  =    size )     {", "idx    =    fastMax ( items ,    comp ,    size )  ;", "} else    {", "if    (  ( quick )     =  =    null )", "quick    =    new   Quick (  )  ;", "idx    =    quick . select ( items ,    comp ,    kthLowest ,    size )  ;", "}", "return   idx ;", "}", "METHOD_END"], "methodName": ["selectIndex"], "fileName": "com.badlogic.gdx.utils.Select"}, {"methodBody": ["METHOD_START", "{", "if    ( info    =  =    null )", "throw   new   IllegalArgument (  \" info   cannot   be   null .  \"  )  ;", "if    (  ( trace )     =  =    null )", "trace    =    new   StringBuffer (  5  1  2  )  ;", "trace . append (  '  \\ n '  )  ;", "trace . append ( info )  ;", "}", "METHOD_END"], "methodName": ["addTrace"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "return   causedBy ( this ,    type )  ;", "}", "METHOD_END"], "methodName": ["causedBy"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "Throwable   cause    =    ex . getCause (  )  ;", "if    (  ( cause    =  =    null )     |  |     ( cause    =  =    ex )  )", "return   false ;", "if    ( type . isAssignableFrom ( cause . getClass (  )  )  )", "return   true ;", "return   causedBy ( cause ,    type )  ;", "}", "METHOD_END"], "methodName": ["causedBy"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( trace )     =  =    null )", "return   super . getMessage (  )  ;", "StringBuffer   buffer    =    new   StringBuffer (  5  1  2  )  ;", "buffer . append ( super . getMessage (  )  )  ;", "if    (  ( buffer . length (  )  )     >     0  )", "buffer . append (  '  \\ n '  )  ;", "buffer . append (  \"    trace :  \"  )  ;", "buffer . append ( trace )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   canExecute    =    File . class . getMethod (  \" canExecute \"  )  ;", "if    (  (  ( Boolean )     ( canExecute . invoke ( file )  )  )  )", "return   true ;", "Method   setExecutable    =    File . class . getMethod (  \" setExecutable \"  ,    boolean . class ,    boolean . class )  ;", "setExecutable . invoke ( file ,    true ,    false )  ;", "return    (  ( Boolean )     ( canExecute . invoke ( file )  )  )  ;", "}    catch    ( Exception   igno )     {", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["canExecute"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "File   parent    =    file . getParentFile (  )  ;", "File   testFile ;", "if    ( file . exists (  )  )     {", "if    (  (  !  ( file . canWrite (  )  )  )     |  |     (  !  ( canExecute ( file )  )  )  )", "return   false ;", "testFile    =    new   File ( parent ,    UUID . randomUUID (  )  . toString (  )  )  ;", "} else    {", "parent . mkdirs (  )  ;", "if    (  !  ( parent . isDirectory (  )  )  )", "return   false ;", "testFile    =    file ;", "}", "try    {", "new   FileOutputStream ( testFile )  . close (  )  ;", "if    (  !  ( canExecute ( testFile )  )  )", "return   false ;", "return   true ;", "}    catch    ( Throwable   ex )     {", "return   false ;", "}    finally    {", "testFile . delete (  )  ;", "}", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( input    =  =    null )", "throw   new   IllegalArgumentException (  \" input   cannot   be   null .  \"  )  ;", "CRC 3  2    crc    =    new   CRC 3  2  (  )  ;", "byte [  ]    buffer    =    new   byte [  4  0  9  6  ]  ;", "try    {", "while    ( true )     {", "int   length    =    input . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "crc . update ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( Exception   ex )     {", "}    finally    {", "StreamUcloseQuietly ( input )  ;", "}", "return   Long . toString ( crc . getValue (  )  ,     1  6  )  ;", "}", "METHOD_END"], "methodName": ["crc"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   sourceCrc    =    crc ( readFile ( sourcePath )  )  ;", "if    ( dirName    =  =    null )", "dirName    =    sourceCrc ;", "File   extractedFile    =    getExtractedFile ( dirName ,    new   File ( sourcePath )  . getName (  )  )  ;", "if    ( extractedFile    =  =    null )     {", "extractedFile    =    getExtractedFile ( UUID . randomUUID (  )  . toString (  )  ,    new   File ( sourcePath )  . getName (  )  )  ;", "if    ( extractedFile    =  =    null )", "throw   new   GdxRuntimeException (  \" Unable   to   find   writable   path   to   extract   file .    Is   the   user   home   directory   writable ?  \"  )  ;", "}", "return   extractFile ( sourcePath ,    sourceCrc ,    extractedFile )  ;", "}    catch    ( RuntimeException   ex )     {", "File   file    =    new   File ( System . getProperty (  \" path \"  )  ,    sourcePath )  ;", "if    ( file . exists (  )  )", "return   file ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["extractFile"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "String   extractedCrc    =    null ;", "if    ( extractedFile . exists (  )  )     {", "try    {", "extractedCrc    =    crc ( new   FileInputStream ( extractedFile )  )  ;", "}    catch    ( FileNotFoundException   ignored )     {", "}", "}", "if    (  ( extractedCrc    =  =    null )     |  |     (  !  ( extractedCrc . equals ( sourceCrc )  )  )  )     {", "InputStream   input    =    null ;", "FileOutputStream   output    =    null ;", "try    {", "input    =    readFile ( sourcePath )  ;", "extractedFile . getParentFile (  )  . mkdirs (  )  ;", "output    =    new   FileOutputStream ( extractedFile )  ;", "byte [  ]    buffer    =    new   byte [  4  0  9  6  ]  ;", "while    ( true )     {", "int   length    =    input . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "output . write ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  \" Error   extracting   file :     \"     +    sourcePath )     +     \"  \\ nTo :     \"  )     +     ( extractedFile . getAbsolutePath (  )  )  )  ,    ex )  ;", "}    finally    {", "StreamUcloseQuietly ( input )  ;", "StreamUcloseQuietly ( output )  ;", "}", "}", "return   extractedFile ;", "}", "METHOD_END"], "methodName": ["extractFile"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "extractFile ( sourcePath ,    crc ( readFile ( sourcePath )  )  ,    new   File ( dir ,    new   File ( sourcePath )  . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["extractFileTo"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "File   idealFile    =    new   File (  (  (  (  (  ( System . getProperty (  \" tmpdir \"  )  )     +     \"  / libgdx \"  )     +     ( System . getProperty (  \" user . name \"  )  )  )     +     \"  /  \"  )     +    dirName )  ,    fileName )  ;", "if    ( canWrite ( idealFile )  )", "return   idealFile ;", "try    {", "File   file    =    File . createTempFile ( dirName ,    null )  ;", "if    ( file . delete (  )  )     {", "file    =    new   File ( file ,    fileName )  ;", "if    ( canWrite ( file )  )", "return   file ;", "}", "}    catch    ( IOException   ignored )     {", "}", "File   file    =    new   File (  (  (  ( System . getProperty (  \" user . home \"  )  )     +     \"  /  . libgdx /  \"  )     +    dirName )  ,    fileName )  ;", "if    ( canWrite ( file )  )", "return   file ;", "file    =    new   File (  (  \"  . temp /  \"     +    dirName )  ,    fileName )  ;", "if    ( canWrite ( file )  )", "return   file ;", "if    (  ( System . getenv (  \" APP _ SANDBOX _ CONTAINER _ ID \"  )  )     !  =    null )", "return   idealFile ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getExtractedFile"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "return   SharedLibraryLoader . loadedLibraries . contains ( libraryName )  ;", "}", "METHOD_END"], "methodName": ["isLoaded"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( SharedLibraryLoader . isIos )", "return ;", "synchronized ( SharedLibraryLoader . class )     {", "if    ( SharedLibraryLoader . isLoaded ( libraryName )  )", "return ;", "String   platformName    =    mapLibraryName ( libraryName )  ;", "try    {", "if    ( SharedLibraryLoader . isAndroid )", "System . loadLibrary ( platformName )  ;", "else", "loadFile ( platformName )  ;", "SharedLibraryLoader . setLoaded ( libraryName )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" Couldn ' t   load   shared   library    '  \"     +    platformName )     +     \"  '    for   target :     \"  )     +     ( System . getProperty (  \" os . name \"  )  )  )     +     ( SharedLibraryLoader . is 6  4 Bit    ?     \"  ,     6  4  - bit \"     :     \"  ,     3  2  - bit \"  )  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "String   sourceCrc    =    crc ( readFile ( sourcePath )  )  ;", "String   fileName    =    new   File ( sourcePath )  . getName (  )  ;", "File   file    =    new   File (  (  (  (  (  ( System . getProperty (  \" tmpdir \"  )  )     +     \"  / libgdx \"  )     +     ( System . getProperty (  \" user . name \"  )  )  )     +     \"  /  \"  )     +    sourceCrc )  ,    fileName )  ;", "Throwable   ex    =    loadFile ( sourcePath ,    sourceCrc ,    file )  ;", "if    ( ex    =  =    null )", "return ;", "try    {", "file    =    File . createTempFile ( sourceCrc ,    null )  ;", "if    (  ( file . delete (  )  )     &  &     (  ( loadFile ( sourcePath ,    sourceCrc ,    file )  )     =  =    null )  )", "return ;", "}    catch    ( Throwable   ignored )     {", "}", "file    =    new   File (  (  (  ( System . getProperty (  \" user . home \"  )  )     +     \"  /  . libgdx /  \"  )     +    sourceCrc )  ,    fileName )  ;", "if    (  ( loadFile ( sourcePath ,    sourceCrc ,    file )  )     =  =    null )", "return ;", "file    =    new   File (  (  \"  . temp /  \"     +    sourceCrc )  ,    fileName )  ;", "if    (  ( loadFile ( sourcePath ,    sourceCrc ,    file )  )     =  =    null )", "return ;", "file    =    new   File ( System . getProperty (  \" path \"  )  ,    sourcePath )  ;", "if    ( file . exists (  )  )     {", "System . load ( file . getAbsolutePath (  )  )  ;", "return ;", "}", "throw   new   GdxRuntimeException ( ex )  ;", "}", "METHOD_END"], "methodName": ["loadFile"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "try    {", "System . l ( extractFile ( sourcePath ,    sourceCrc ,    extractedFile )  . getAbsolutePath (  )  )  ;", "return   null ;", "}    catch    ( Throwable   ex )     {", "return   ex ;", "}", "}", "METHOD_END"], "methodName": ["loadFile"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( SharedLibraryLoader . isWindows )", "return   libraryName    +     ( SharedLibraryLoader . is 6  4 Bit    ?     \"  6  4  . dll \"     :     \"  . dll \"  )  ;", "if    ( SharedLibraryLoader . isLinux )", "return    (  (  \" lib \"     +    libraryName )     +     ( SharedLibraryLoader . isARM    ?     \" arm \"     +     ( SharedLibraryLoader . abi )     :     \"  \"  )  )     +     ( SharedLibraryLoader . is 6  4 Bit    ?     \"  6  4  . so \"     :     \"  . so \"  )  ;", "if    ( SharedLibraryLoader . isMac )", "return    (  \" lib \"     +    libraryName )     +     ( SharedLibraryLoader . is 6  4 Bit    ?     \"  6  4  . dylib \"     :     \"  . dylib \"  )  ;", "return   libraryName ;", "}", "METHOD_END"], "methodName": ["mapLibraryName"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nativesJar )     =  =    null )     {", "InputStream   input    =     . class . getResourceAsStream (  (  \"  /  \"     +    path )  )  ;", "if    ( input    =  =    null )", "throw   new   GdxRuntimeException (  (  \" Unable   to   read   file   for   extraction :     \"     +    path )  )  ;", "return   input ;", "}", "try    {", "ZipFile   file    =    new   ZipFile ( nativesJar )  ;", "ZipEntry   entry    =    file . getEntry ( path )  ;", "if    ( entry    =  =    null )", "throw   new   GdxRuntimeException (  (  (  (  \" Couldn ' t   find    '  \"     +    path )     +     \"  '    in   JAR :     \"  )     +     ( nativesJar )  )  )  ;", "return   file . getInputStream ( entry )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  \" Error   reading    '  \"     +    path )     +     \"  '    in   JAR :     \"  )     +     ( nativesJar )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readFile"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "SharedLibraryLoader . loadedLibraries . add ( libraryName )  ;", "}", "METHOD_END"], "methodName": ["setLoaded"], "fileName": "com.badlogic.gdx.utils.SharedLibraryLoader"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =     (  ( short )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [  (  ( size )  +  +  )  ]     =    value ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "if    (  (  ( size )     +     1  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "size    +  =     2  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "if    (  (  ( size )     +     2  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "size    +  =     3  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "if    (  (  ( size )     +     3  )     >  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  8 F )  )  )  )  ;", "items [ size ]     =    value 1  ;", "items [  (  ( size )     +     1  )  ]     =    value 2  ;", "items [  (  ( size )     +     2  )  ]     =    value 3  ;", "items [  (  ( size )     +     3  )  ]     =    value 4  ;", "size    +  =     4  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . size )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    +    length )     >     ( array . size )  )", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" offset    +    length   must   be    <  =    size :     \"     +    offset )     +     \"     +     \"  )     +    length )     +     \"     <  =     \"  )     +     ( array . size )  )  )  ;", "addAll ( array . items ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "addAll ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "int   sizeNeeded    =     ( size )     +    length ;", "if    ( sizeNeeded    >     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     ( sizeNeeded    *     1  .  7  5 F )  )  )  )  ;", "System . arraycopy ( array ,    offset ,    items ,    size ,    length )  ;", "size    +  =    length ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "int   i    =     ( size )     -     1  ;", "s [  ]    items    =    this . items ;", "while    ( i    >  =     0  )", "if    (  ( items [  ( i -  -  )  ]  )     =  =    value )", "return   true ;", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "int   sizeNeeded    =     ( size )     +    additionalCapacity ;", "if    ( sizeNeeded    >     ( items . length )  )", "resize ( Math . max (  8  ,    sizeNeeded )  )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =     ( this )  )", "return   true ;", "if    (  !  ( ordered )  )", "return   false ;", "if    (  !  ( object   instanceof    )  )", "return   false ;", "array    =     (  (  )     ( object )  )  ;", "if    (  !  ( array . ordered )  )", "return   false ;", "int   n    =    size ;", "if    ( n    !  =     ( array . size )  )", "return   false ;", "short [  ]    items 1     =    this . items ;", "short [  ]    items 2     =    array . items ;", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     !  =     ( array . items [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "throw   new   IllegalStateException (  \"    is   empty .  \"  )  ;", "return   items [  0  ]  ;", "}", "METHOD_END"], "methodName": ["first"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "return   items [ index ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ordered )  )", "return   super . hashCode (  )  ;", "s [  ]    items    =    this . items ;", "int   h    =     1  ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "h    =     ( h    *     3  1  )     +     ( items [ i ]  )  ;", "return   h ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     +  =    value ;", "}", "METHOD_END"], "methodName": ["incr"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >    size :     \"     +    index )     +     \"     >     \"  )     +     ( size )  )  )  ;", "s [  ]    items    =    this . items ;", "if    (  ( size )     =  =     ( items . length )  )", "items    =    resize ( Math . max (  8  ,     (  ( int )     (  ( size )     *     1  .  7  5 F )  )  )  )  ;", "if    ( ordered )", "System . arraycopy ( items ,    index ,    items ,     ( index    +     1  )  ,     (  ( size )     -    index )  )  ;", "else", "items [ size ]     =    items [ index ]  ;", "( size )  +  +  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )", "if    (  ( items [ i ]  )     =  =    value )", "return   i ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     *  =    value ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  ( size )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "return   items [  (  -  -  ( size )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    0  ;", "return   items [ MathUrandom (  0  ,     (  ( size )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . size ;", "int   startSize    =    size ;", "s [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    array . size ;    i    <    n ;    i +  +  )     {", "s   item    =    array . get ( i )  ;", "for    ( int   ii    =     0  ;    ii    <    size ;    ii +  +  )     {", "if    ( item    =  =     ( items [ ii ]  )  )     {", "removeIndex ( ii )  ;", "size -  -  ;", "break ;", "}", "}", "}", "return   size    !  =    startSize ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "s [  ]    items    =    this . items ;", "s   value    =    items [ index ]  ;", "( size )  -  -  ;", "if    ( ordered )", "System . arraycopy ( items ,     ( index    +     1  )  ,    items ,    index ,     (  ( size )     -    index )  )  ;", "else", "items [ index ]     =    items [ size ]  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( end    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" end   can ' t   be    >  =    size :     \"     +    end )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( start    >    end )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" start   can ' t   be    >    end :     \"     +    start )     +     \"     >     \"  )     +    end )  )  ;", "s [  ]    items    =    this . items ;", "int   count    =     ( end    -    start )     +     1  ;", "if    ( ordered )", "System . arraycopy ( items ,     ( start    +    count )  ,    items ,    start ,     (  ( size )     -     ( start    +    count )  )  )  ;", "else    {", "int   lastIndex    =     ( this . size )     -     1  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "items [  ( start    +    i )  ]     =    items [  ( lastIndex    -    i )  ]  ;", "}", "size    -  =    count ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    n    =    size ;    i    <    n ;    i +  +  )     {", "if    (  ( items [ i ]  )     =  =    value )     {", "removeIndex ( i )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    newItems    =    new   short [ newSize ]  ;", "short [  ]    items    =    this . items ;", "System . arraycopy ( items ,     0  ,    newItems ,     0  ,    Math . min ( size ,    newItems . length )  )  ;", "this . items    =    newItems ;", "return   newItems ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "for    ( int   i    =     0  ,    lastIndex    =     ( size )     -     1  ,    n    =     ( size )     /     2  ;    i    <    n ;    i +  +  )     {", "int   ii    =    lastIndex    -    i ;", "short   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( size )  )", "throw   new   IndexOOfBoundsException (  (  (  (  \" index   can ' t   be    >  =    size :     \"     +    index )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "items [ index ]     =    value ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( newSize    >     ( items . length )  )", "resize ( Math . max (  8  ,    newSize )  )  ;", "size    =    newSize ;", "return   items ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( items . length )     !  =     ( size )  )", "resize ( size )  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    items    =    this . items ;", "for    ( int   i    =     ( size )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   ii    =    MathUrandom ( i )  ;", "short   temp    =    items [ i ]  ;", "items [ i ]     =    items [ ii ]  ;", "items [ ii ]     =    temp ;", "}", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( items ,     0  ,    size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    ( first    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" first   can ' t   be    >  =    size :     \"     +    first )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "if    ( second    >  =     ( size )  )", "throw   new   IndexOutOfBoundsException (  (  (  (  \" second   can ' t   be    >  =    size :     \"     +    second )     +     \"     >  =     \"  )     +     ( size )  )  )  ;", "s [  ]    items    =    this . items ;", "s   firstValue    =    items [ first ]  ;", "items [ first ]     =    items [ second ]  ;", "items [ second ]     =    firstValue ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "short [  ]    array    =    new   short [ size ]  ;", "System . arraycopy ( items ,     0  ,    array ,     0  ,    size )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  [  ]  \"  ;", "s [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append (  '  [  '  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append (  \"  ,     \"  )  ;", "buffer . append ( items [ i ]  )  ;", "}", "buffer . append (  '  ]  '  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )", "return    \"  \"  ;", "s [  ]    items    =    this . items ;", "StringBuilder   buffer    =    new   StringBuilder (  3  2  )  ;", "buffer . append ( items [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . append ( separator )  ;", "buffer . append ( items [ i ]  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     >    newSize )", "size    =    newSize ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "return   new   ShortArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.ShortArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "s    =    items ;", "( ss )  +  +  ;", "return   items ;", "}", "METHOD_END"], "methodName": ["begin"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "snapshots    =    Math . max (  0  ,     (  ( snapshots )     -     1  )  )  ;", "if    (  ( snapshot )     =  =    null )", "return ;", "if    (  (  ( snapshot )     !  =     ( items )  )     &  &     (  ( snapshots )     =  =     0  )  )     {", "recycled    =    snapshot ;", "for    ( int   i    =     0  ,    n    =    recycled . length ;    i    <    n ;    i +  +  )", "recycled [ i ]     =    null ;", "}", "snapshot    =    null ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . insert ( index ,    value )  ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( snapshot )     =  =    null )     |  |     (  ( snapshot )     !  =     ( items )  )  )", "return ;", "if    (  (  ( recycled )     !  =    null )     &  &     (  ( recycled . length )     >  =     ( size )  )  )     {", "System . arraycopy ( items ,     0  ,    recycled ,     0  ,    size )  ;", "items    =    recycled ;", "recycled    =    null ;", "} else", "resize ( items . length )  ;", "}", "METHOD_END"], "methodName": ["modified"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "return   super . pop (  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "return   super . removeAll ( a ,    identity )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "return   super . removeIndex ( index )  ;", "}", "METHOD_END"], "methodName": ["removeIndex"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . removeRange ( start ,    end )  ;", "}", "METHOD_END"], "methodName": ["removeRange"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "return   super . removeValue ( value ,    identy )  ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . reverse (  )  ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . set ( index ,    value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "return   super . setSize ( newSize )  ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . uffle (  )  ;", "}", "METHOD_END"], "methodName": ["shuffle"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . sort (  )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . sort ( parator )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . sw ( first ,    second )  ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "modified (  )  ;", "super . truncate ( newSize )  ;", "}", "METHOD_END"], "methodName": ["truncate"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "return   new   SnapshotArray ( array )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "com.badlogic.gdx.utils.SnapshotArray"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Sort . instance )     =  =    null )", "Sort . instance    =    new   Sort (  )  ;", "return   Sort . instance ;", "}", "METHOD_END"], "methodName": ["instance"], "fileName": "com.badlogic.gdx.utils.Sort"}, {"methodBody": ["METHOD_START", "{", "if    (  ( comparableTimSort )     =  =    null )", "comparableTimSort    =    new   ComparableTimSort (  )  ;", "comparableTimSort . doSort ( a ,     0  ,    a . length )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Sort"}, {"methodBody": ["METHOD_START", "{", "if    (  ( comparableTimSort )     =  =    null )", "comparableTimSort    =    new   ComparableTimSort (  )  ;", "comparableTimSort . doSort ( a ,    fromIndex ,    toIndex )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Sort"}, {"methodBody": ["METHOD_START", "{", "if    (  ( timSort )     =  =    null )", "timSort    =    new   TimSort (  )  ;", "timSort . doSort ( a ,    c ,     0  ,    a . length )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Sort"}, {"methodBody": ["METHOD_START", "{", "if    (  ( timSort )     =  =    null )", "timSort    =    new   TimSort (  )  ;", "timSort . doSort ( a ,    c ,    fromIndex ,    toIndex )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Sort"}, {"methodBody": ["METHOD_START", "{", "if    (  ( comparableTimSort )     =  =    null )", "comparableTimSort    =    new   ComparableTimSort (  )  ;", "comparableTimSort . doSort (  (  ( Object [  ]  )     ( a . items )  )  ,     0  ,    a . size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Sort"}, {"methodBody": ["METHOD_START", "{", "if    (  ( timSort )     =  =    null )", "timSort    =    new   TimSort (  )  ;", "timSort . doSort (  (  ( Object [  ]  )     ( a . items )  )  ,     (  ( Comparator )     ( c )  )  ,     0  ,    a . size )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.Sort"}, {"methodBody": ["METHOD_START", "{", "for    (  ;     ( first )     !  =    null ;    first    =    first . n )     {", "nodePool . free ( first )  ;", "}", "size    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.SortedIntList"}, {"methodBody": ["METHOD_START", "{", "E   match    =    null ;", "if    (  ( first )     !  =    null )     {", ". Node < E >    c    =    first ;", "while    (  (  ( c . n )     !  =    null )     &  &     (  ( c . index )     <    index )  )     {", "c    =    c . n ;", "}", "if    (  ( c . index )     =  =    index )     {", "match    =    c . value ;", "}", "}", "return   match ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.SortedIntList"}, {"methodBody": ["METHOD_START", "{", "if    (  ( first )     !  =    null )     {", ". Node < E >    c    =    first ;", "while    (  (  ( c . n )     !  =    null )     &  &     (  ( c . n . index )     <  =    index )  )     {", "c    =    c . n ;", "}", "if    ( index    >     ( c . index )  )     {", "c . n    =    nodePool . obtain ( c ,    c . n ,    value ,    index )  ;", "if    (  ( c . n . n )     !  =    null )     {", "c . n . n . p    =    c . n ;", "}", "( size )  +  +  ;", "} else", "if    ( index    <     ( c . index )  )     {", ". Node < E >    newFirst    =    nodePool . obtain ( null ,    first ,    value ,    index )  ;", "first . p    =    newFirst ;", "first    =    newFirst ;", "( size )  +  +  ;", "} else    {", "c . value    =    value ;", "}", "} else    {", "first    =    nodePool . obtain ( null ,    null ,    value ,    index )  ;", "( size )  +  +  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.SortedIntList"}, {"methodBody": ["METHOD_START", "{", "if    (  ( iterator )     =  =    null )     {", "iterator    =    new   Iterator (  )  ;", "}", "return   iterator . reset (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.utils.SortedIntList"}, {"methodBody": ["METHOD_START", "{", "return   size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "com.badlogic.gdx.utils.SortedIntList"}, {"methodBody": ["METHOD_START", "{", "if    ( c    !  =    null )     {", "y    {", "c . close (  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["closeQuietly"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "StreamUtils . copyStream ( input ,    output ,    new   byte [ StreamUtils . DEFAULT _ BUFFER _ SIZE ]  )  ;", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "int   bytesRead ;", "while    (  ( bytesRead    =    input . d ( buffer )  )     !  =     (  -  1  )  )     {", "output . write ( buffer ,     0  ,    bytesRead )  ;", "}", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "StreamUtils . copyStream ( input ,    output ,    new   byte [ bufferSize ]  )  ;", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "StreamUtils . copyStream ( input ,    output ,    new   byte [ StreamUtils . DEFAULT _ BUFFER _ SIZE ]  )  ;", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "int   startPosition    =    output . position (  )  ;", "int   total    =     0  ;", "int   bytesRead ;", "while    (  ( bytesRead    =    input . read ( buffer )  )     !  =     (  -  1  )  )     {", "BufferUcopy ( buffer ,     0  ,    output ,    bytesRead )  ;", "total    +  =    bytesRead ;", "output . position (  ( startPosition    +    total )  )  ;", "}", "output . position ( startPosition )  ;", "return   total ;", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "StreamUtils . copyStream ( input ,    output ,    new   byte [ bufferSize ]  )  ;", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "return   StreamUtils . copyStreamToByteArray ( input ,    input . available (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyStreamToByteArray"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   StreamUtils . OptimizedByteArrayOutputStream ( Math . max (  0  ,    estimatedSize )  )  ;", "StreamUtils . copyStream ( input ,    baos )  ;", "return   baos . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["copyStreamToByteArray"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "return   StreamUtils . copyStreamToString ( input ,    input . available (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["copyStreamToString"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "return   StreamUtils . copyStreamToString ( input ,    estimatedSize ,    null )  ;", "}", "METHOD_END"], "methodName": ["copyStreamToString"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "InputStreamReader   reader    =     ( charset    =  =    null )     ?    new   InputStreamReader ( input )     :    new   InputStreamReader ( input ,    charset )  ;", "StringWriter   writer    =    new   StringWriter ( Math . max (  0  ,    estimatedSize )  )  ;", "char [  ]    buffer    =    new   char [  . DEFAULT _ BUFFER _ SIZE ]  ;", "int   charsRead ;", "while    (  ( charsRead    =    reader . read ( buffer )  )     !  =     (  -  1  )  )     {", "writer . write ( buffer ,     0  ,    charsRead )  ;", "}", "return   writer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["copyStreamToString"], "fileName": "com.badlogic.gdx.utils.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "append 0  (  ( b    ?     \" true \"     :     \" false \"  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( c )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( ch )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( str ,    offset ,    len )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( builder    =  =    null )", "appendNull (  )  ;", "else", "append 0  ( builder . chars ,     0  ,    builder . length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( builder    =  =    null )", "appendNull (  )  ;", "else", "append 0  ( builder . chars ,    start ,    end )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( Double . toString ( d )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( Float . toString ( f )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   append ( value ,     0  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   append ( value ,    minLength ,     '  0  '  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =     ( Integer . MIN _ VALUE )  )     {", "append 0  (  \"  -  2  1  4  7  4  8  3  6  4  8  \"  )  ;", "return   this ;", "}", "if    ( value    <     0  )     {", "append 0  (  '  -  '  )  ;", "value    =     - value ;", "}", "if    ( minLength    >     1  )     {", "for    ( int   j    =    minLength    -     (  . numChars ( value ,     1  0  )  )  ;    j    >     0  ;     -  - j )", "append ( prefix )  ;", "}", "if    ( value    >  =     1  0  0  0  0  )     {", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  )", "append 0  (  . digits [  (  ( int )     (  (  (  ( long )     ( value )  )     %     1  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  )", "append 0  (  . digits [  (  ( value    %     1  0  0  0  0  0  0  0  0  0  )     /     1  0  0  0  0  0  0  0  0  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  )", "append 0  (  . digits [  (  ( value    %     1  0  0  0  0  0  0  0  0  )     /     1  0  0  0  0  0  0  0  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  )", "append 0  (  . digits [  (  ( value    %     1  0  0  0  0  0  0  0  )     /     1  0  0  0  0  0  0  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  )", "append 0  (  . digits [  (  ( value    %     1  0  0  0  0  0  0  )     /     1  0  0  0  0  0  )  ]  )  ;", "append 0  (  . digits [  (  ( value    %     1  0  0  0  0  0  )     /     1  0  0  0  0  )  ]  )  ;", "}", "if    ( value    >  =     1  0  0  0  )", "append 0  (  . digits [  (  ( value    %     1  0  0  0  0  )     /     1  0  0  0  )  ]  )  ;", "if    ( value    >  =     1  0  0  )", "append 0  (  . digits [  (  ( value    %     1  0  0  0  )     /     1  0  0  )  ]  )  ;", "if    ( value    >  =     1  0  )", "append 0  (  . digits [  (  ( value    %     1  0  0  )     /     1  0  )  ]  )  ;", "append 0  (  . digits [  ( value    %     1  0  )  ]  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( csq    =  =    null )     {", "appendNull (  )  ;", "} else", "if    ( csq   instanceof    )     {", "builder    =     (  (  )     ( csq )  )  ;", "append 0  ( builder . chars ,     0  ,    builder . length )  ;", "} else    {", "append 0  ( csq . toString (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( csq ,    start ,    end )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =    null )     {", "appendNull (  )  ;", "} else    {", "append 0  ( obj . to (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( str )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   append ( value ,     0  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   append ( value ,    minLength ,     '  0  '  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =     ( Long . MIN _ VALUE )  )     {", "append 0  (  \"  -  9  2  2  3  3  7  2  0  3  6  8  5  4  7  7  5  8  0  8  \"  )  ;", "return   this ;", "}", "if    ( value    <     0 L )     {", "append 0  (  '  -  '  )  ;", "value    =     - value ;", "}", "if    ( minLength    >     1  )     {", "for    ( int   j    =    minLength    -     (  . numChars ( value ,     1  0  )  )  ;    j    >     0  ;     -  - j )", "append ( prefix )  ;", "}", "if    ( value    >  =     1  0  0  0  0  )     {", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  .  0 E 1  9  )     /     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0  0 L )     /     1  0  0  0  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0  0 L )     /     1  0  0  0  0  0 L )  )  ]  )  ;", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0  0 L )     /     1  0  0  0  0 L )  )  ]  )  ;", "}", "if    ( value    >  =     1  0  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0  0 L )     /     1  0  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0  0 L )     /     1  0  0 L )  )  ]  )  ;", "if    ( value    >  =     1  0 L )", "append 0  (  . digits [  (  ( int )     (  ( value    %     1  0  0 L )     /     1  0 L )  )  ]  )  ;", "append 0  (  . digits [  (  ( int )     ( value    %     1  0 L )  )  ]  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( length )     =  =     ( chars . length )  )     {", "enlargeBuffer (  (  ( length )     +     1  )  )  ;", "}", "chars [  (  ( length )  +  +  )  ]     =    ch ;", "}", "METHOD_END"], "methodName": ["append0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   newSize    =     ( length )     +     ( value . length )  ;", "if    ( newSize    >     ( chars . length )  )     {", "enlargeBuffer ( newSize )  ;", "}", "System . arraycopy ( value ,     0  ,    chars ,    length ,    value . length )  ;", "length    =    newSize ;", "}", "METHOD_END"], "methodName": ["append0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    >     ( value . length )  )     |  |     ( offset    <     0  )  )     {", "throw   new   ArrayIndexOutOfBoundsException (  (  \" Offset   out   of   bounds :     \"     +    offset )  )  ;", "}", "if    (  ( length    <     0  )     |  |     (  (  ( value . length )     -    offset )     <    length )  )     {", "throw   new   ArrayIndexOutOfBoundsException (  (  \" Length   out   of   bounds :     \"     +    length )  )  ;", "}", "int   newSize    =     ( this . length )     +    length ;", "if    ( newSize    >     ( chars . length )  )     {", "enlargeBuffer ( newSize )  ;", "}", "System . arraycopy ( value ,    offset ,    chars ,    this . length ,    length )  ;", "this . length    =    newSize ;", "}", "METHOD_END"], "methodName": ["append0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( s    =  =    null )     {", "s    =     \" null \"  ;", "}", "if    (  (  (  ( start    <     0  )     |  |     ( end    <     0  )  )     |  |     ( start    >    end )  )     |  |     ( end    >     ( s . length (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "append 0  ( s . subSequence ( start ,    end )  . to (  )  )  ;", "}", "METHOD_END"], "methodName": ["append0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( string    =  =    null )     {", "appendNull (  )  ;", "return ;", "}", "int   adding    =    string . length (  )  ;", "int   newSize    =     ( length )     +    adding ;", "if    ( newSize    >     ( chars . length )  )     {", "enlargeBuffer ( newSize )  ;", "}", "string . getChars (  0  ,    adding ,    chars ,    length )  ;", "length    =    newSize ;", "}", "METHOD_END"], "methodName": ["append0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( Character . toChars ( codePoint )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["appendCodePoint"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "append 0  ( str )  ;", "append 0  (  '  \\ n '  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["appendLine"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   newSize    =     ( length )     +     4  ;", "if    ( newSize    >     ( chars . length )  )     {", "enlargeBuffer ( newSize )  ;", "}", "chars [  (  ( length )  +  +  )  ]     =     ' n '  ;", "chars [  (  ( length )  +  +  )  ]     =     ' u '  ;", "chars [  (  ( length )  +  +  )  ]     =     ' l '  ;", "chars [  (  ( length )  +  +  )  ]     =     ' l '  ;", "}", "METHOD_END"], "methodName": ["appendNull"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   chars . length ;", "}", "METHOD_END"], "methodName": ["capacity"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( length )  )  )     {", "throw   new   IndexOutOfBoundsException ( index )  ;", "}", "return   chars [ index ]  ;", "}", "METHOD_END"], "methodName": ["charAt"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( length )  )  )     {", "throw   new   IndexOutOfBoundsException ( index )  ;", "}", "return   Character . codePointAt ( chars ,    index ,    length )  ;", "}", "METHOD_END"], "methodName": ["codePointAt"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     1  )     |  |     ( index    >     ( length )  )  )     {", "throw   new   IndexOutOfBoundsException ( index )  ;", "}", "return   Character . codePointBefore ( chars ,    index )  ;", "}", "METHOD_END"], "methodName": ["codePointBefore"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( beginIndex    <     0  )     |  |     ( endIndex    >     ( length )  )  )     |  |     ( beginIndex    >    endIndex )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   Character . codePointCount ( chars ,    beginIndex ,     ( endIndex    -    beginIndex )  )  ;", "}", "METHOD_END"], "methodName": ["codePointCount"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "delete 0  ( start ,    end )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( start    >  =     0  )     {", "if    ( end    >     ( length )  )     {", "end    =    length ;", "}", "if    ( end    =  =    start )     {", "return ;", "}", "if    ( end    >    start )     {", "int   count    =     ( length )     -    end ;", "if    ( count    >  =     0  )", "System . arraycopy ( chars ,    end ,    chars ,    start ,    count )  ;", "length    -  =    end    -    start ;", "return ;", "}", "}", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "METHOD_END"], "methodName": ["delete0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "deleteCharAt 0  ( index )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["deleteCharAt"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     >    location )     |  |     ( location    >  =     ( length )  )  )     {", "throw   new   IndexOutOfBoundsException ( location )  ;", "}", "int   count    =     (  ( length )     -    location )     -     1  ;", "if    ( count    >     0  )     {", "System . arraycopy ( chars ,     ( location    +     1  )  ,    chars ,    location ,    count )  ;", "}", "( length )  -  -  ;", "}", "METHOD_END"], "methodName": ["deleteCharAt0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   newSize    =     (  (  ( chars . length )     >  >     1  )     +     ( chars . length )  )     +     2  ;", "char [  ]    newData    =    new   char [ min    >    newSize    ?    min    :    newSize ]  ;", "System . arraycopy ( chars ,     0  ,    newData ,     0  ,    length )  ;", "chars    =    newData ;", "}", "METHOD_END"], "methodName": ["enlargeBuffer"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( min    >     ( chars . length )  )     {", "int   twice    =     (  ( chars . length )     <  <     1  )     +     2  ;", "enlargeBuffer (  ( twice    >    min    ?    twice    :    min )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    obj )", "return   true ;", "if    ( obj    =  =    null )", "return   false ;", "if    (  ( getClass (  )  )     !  =     ( obj . getClass (  )  )  )", "return   false ;", "other    =     (  (  )     ( obj )  )  ;", "int   length    =    this . length ;", "if    ( length    !  =     ( other . length )  )", "return   false ;", "char [  ]    chars    =    this . chars ;", "char [  ]    chars 2     =    other . chars ;", "if    ( chars    =  =    chars 2  )", "return   true ;", "if    (  ( chars    =  =    null )     |  |     ( chars 2     =  =    null )  )", "return   false ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )", "if    (  ( chars [ i ]  )     !  =     ( chars 2  [ i ]  )  )", "return   false ;", "return   true ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( start    >     ( length )  )     |  |     ( end    >     ( length )  )  )     |  |     ( start    >    end )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "System . arraycopy ( chars ,    start ,    dest ,    destStart ,     ( end    -    start )  )  ;", "}", "METHOD_END"], "methodName": ["getChars"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   chars ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "final   int   prime    =     3  1  ;", "int   result    =     1  ;", "result    =    prime    +     ( length )  ;", "result    =     ( prime    *    result )     +     ( Arrays . hashCode ( chars )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   indexOf ( string ,     0  )  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( start    <     0  )     {", "start    =     0  ;", "}", "int   subCount    =    sub . length (  )  ;", "if    ( subCount    >     0  )     {", "if    (  ( subCount    +    start )     >     ( length )  )     {", "return    -  1  ;", "}", "char   firstChar    =    sub . charAt (  0  )  ;", "while    ( true )     {", "int   i    =    start ;", "boolean   found    =    false ;", "for    (  ;    i    <     ( length )  ;    i +  +  )     {", "if    (  ( chars [ i ]  )     =  =    firstChar )     {", "found    =    true ;", "break ;", "}", "}", "if    (  (  ! found )     |  |     (  ( subCount    +    i )     >     ( length )  )  )     {", "return    -  1  ;", "}", "int   o 1     =    i ;", "int   o 2     =     0  ;", "while    (  (  (  +  + o 2  )     <    subCount )     &  &     (  ( chars [  (  +  + o 1  )  ]  )     =  =     ( sub . charAt ( o 2  )  )  )  )     {", "}", "if    ( o 2     =  =    subCount )     {", "return   i ;", "}", "start    =    i    +     1  ;", "}", "}", "return    ( start    <     ( length )  )     |  |     ( start    =  =     0  )     ?    start    :    length ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,     ( b    ?     \" true \"     :     \" false \"  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    c )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    ch )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    str ,    strOffset ,    strLen )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    Double . toString ( d )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    Float . toString ( f )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    Integer . toString ( i )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,     ( s    =  =    null    ?     \" null \"     :    s . toString (  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    s ,    start ,    end )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,     ( obj    =  =    null    ?     \" null \"     :    obj . toString (  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    str )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "insert 0  ( offset ,    Long . toString ( l )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["insert"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     >    index )     |  |     ( index    >     ( length )  )  )     {", "throw   new   ArrayIndexOutOfBoundsException ( index )  ;", "}", "move (  1  ,    index )  ;", "chars [ index ]     =    ch ;", "( length )  +  +  ;", "}", "METHOD_END"], "methodName": ["insert0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     >    index )     |  |     ( index    >     ( length )  )  )     {", "throw   new   IndexOutOfBoundsException ( index )  ;", "}", "if    (  ( value . length )     !  =     0  )     {", "move ( value . length ,    index )  ;", "System . arraycopy ( value ,     0  ,    value ,    index ,    value . length )  ;", "length    +  =    value . length ;", "}", "}", "METHOD_END"], "methodName": ["insert0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     <  =    index )     &  &     ( index    <  =    length )  )     {", "if    (  (  ( start    >  =     0  )     &  &     (  0     <  =    length )  )     &  &     ( length    <  =     (  ( value . length )     -    start )  )  )     {", "if    ( length    !  =     0  )     {", "move ( length ,    index )  ;", "System . arraycopy ( value ,    start ,    chars ,    index ,    length )  ;", "this . length    +  =    length ;", "}", "return ;", "}", "throw   new   IndexOutOfBoundsException (  (  (  (  (  (  \" offset    \"     +    start )     +     \"  ,    length    \"  )     +    length )     +     \"  ,    char [  ]  . length    \"  )     +     ( value . length )  )  )  ;", "}", "throw   new   IndexOutOfBoundsException ( index )  ;", "}", "METHOD_END"], "methodName": ["insert0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( s    =  =    null )     {", "s    =     \" null \"  ;", "}", "if    (  (  (  (  (  ( index    <     0  )     |  |     ( index    >     ( length )  )  )     |  |     ( start    <     0  )  )     |  |     ( end    <     0  )  )     |  |     ( start    >    end )  )     |  |     ( end    >     ( s . length (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "insert 0  ( index ,    s . subSequence ( start ,    end )  . to (  )  )  ;", "}", "METHOD_END"], "methodName": ["insert0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     <  =    index )     &  &     ( index    <  =     ( length )  )  )     {", "if    ( string    =  =    null )     {", "string    =     \" null \"  ;", "}", "int   min    =    string . length (  )  ;", "if    ( min    !  =     0  )     {", "move ( min ,    index )  ;", "string . getChars (  0  ,    min ,    chars ,    index )  ;", "length    +  =    min ;", "}", "} else    {", "throw   new   IndexOutOfBoundsException ( index )  ;", "}", "}", "METHOD_END"], "methodName": ["insert0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   lastIndexOf ( string ,    length )  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   subCount    =    subString . length (  )  ;", "if    (  ( subCount    <  =     ( length )  )     &  &     ( start    >  =     0  )  )     {", "if    ( subCount    >     0  )     {", "if    ( start    >     (  ( length )     -    subCount )  )     {", "start    =     ( length )     -    subCount ;", "}", "char   firstChar    =    subString . charAt (  0  )  ;", "while    ( true )     {", "int   i    =    start ;", "boolean   found    =    false ;", "for    (  ;    i    >  =     0  ;     -  - i )     {", "if    (  ( chars [ i ]  )     =  =    firstChar )     {", "found    =    true ;", "break ;", "}", "}", "if    (  ! found )     {", "return    -  1  ;", "}", "int   o 1     =    i ;", "int   o 2     =     0  ;", "while    (  (  (  +  + o 2  )     <    subCount )     &  &     (  ( chars [  (  +  + o 1  )  ]  )     =  =     ( subString . charAt ( o 2  )  )  )  )     {", "}", "if    ( o 2     =  =    subCount )     {", "return   i ;", "}", "start    =    i    -     1  ;", "}", "}", "return   start    <     ( length )     ?    start    :    length ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( chars . length )     -     ( length )  )     >  =    size )     {", "System . arraycopy ( chars ,    index ,    chars ,     ( index    +    size )  ,     (  ( length )     -    index )  )  ;", "return ;", "}", "int   a    =     ( length )     +    size ;", "int   b    =     (  ( chars . length )     <  <     1  )     +     2  ;", "int   newSize    =     ( a    >    b )     ?    a    :    b ;", "char [  ]    newData    =    new   char [ newSize ]  ;", "System . arraycopy ( chars ,     0  ,    newData ,     0  ,    index )  ;", "System . arraycopy ( chars ,    index ,    newData ,     ( index    +    size )  ,     (  ( length )     -    index )  )  ;", "chars    =    newData ;", "}", "METHOD_END"], "methodName": ["move"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   result    =     ( value    <     0  )     ?     2     :     1  ;", "while    (  ( value    /  =    radix )     !  =     0  )", "+  + result ;", "return   result ;", "}", "METHOD_END"], "methodName": ["numChars"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   result    =     ( value    <     0  )     ?     2     :     1  ;", "while    (  ( value    /  =    radix )     !  =     0  )", "+  + result ;", "return   result ;", "}", "METHOD_END"], "methodName": ["numChars"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   Character . offsetByCodePoints ( chars ,     0  ,    length ,    index ,    codePointOffset )  ;", "}", "METHOD_END"], "methodName": ["offsetByCodePoints"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   replaceLength    =    replace . length (  )  ;", "int   index    =     0  ;", "while    ( true )     {", "while    ( true )     {", "if    ( index    =  =     ( length )  )", "return   this ;", "if    (  ( chars [ index ]  )     =  =    find )", "break ;", "index +  +  ;", "}", "replace 0  ( index ,     ( index    +     1  )  ,    replace )  ;", "index    +  =    replaceLength ;", "}", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "replace 0  ( start ,    end ,    str )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "int   findLength    =    find . length (  )  ;", "int   replaceLength    =    replace . length (  )  ;", "int   index    =     0  ;", "while    ( true )     {", "index    =    indexOf ( find ,    index )  ;", "if    ( index    =  =     (  -  1  )  )", "break ;", "replace 0  ( index ,     ( index    +    findLength )  ,    replace )  ;", "index    +  =    replaceLength ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( start    >  =     0  )     {", "if    ( end    >     ( length )  )     {", "end    =    length ;", "}", "if    ( end    >    start )     {", "int   stringLength    =    string . length (  )  ;", "int   diff    =     ( end    -    start )     -    stringLength ;", "if    ( diff    >     0  )     {", "System . arraycopy ( chars ,    end ,    chars ,     ( start    +    stringLength )  ,     (  ( length )     -    end )  )  ;", "} else", "if    ( diff    <     0  )     {", "move (  (  - diff )  ,    end )  ;", "}", "string . getChars (  0  ,    stringLength ,    chars ,    start )  ;", "length    -  =    diff ;", "return ;", "}", "if    ( start    =  =    end )     {", "if    ( string    =  =    null )     {", "throw   new   NullPointerException (  )  ;", "}", "insert 0  ( start ,    string )  ;", "return ;", "}", "}", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "METHOD_END"], "methodName": ["replace0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "reverse 0  (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( length )     <     2  )     {", "return ;", "}", "int   end    =     ( length )     -     1  ;", "char   frontHigh    =    chars [  0  ]  ;", "char   endLow    =    chars [ end ]  ;", "boolean   allowFrontSur    =    true ;", "boolean   allowEndSur    =    true ;", "for    ( int   i    =     0  ,    mid    =     ( length )     /     2  ;    i    <    mid ;    i +  +     ,     -  - end )     {", "char   frontLow    =    chars [  ( i    +     1  )  ]  ;", "char   endHigh    =    chars [  ( end    -     1  )  ]  ;", "boolean   surAtFront    =     (  (  ( allowFrontSur    &  &     ( frontLow    >  =     5  6  3  2  0  )  )     &  &     ( frontLow    <  =     5  7  3  4  3  )  )     &  &     ( frontHigh    >  =     5  5  2  9  6  )  )     &  &     ( frontHigh    <  =     5  6  3  1  9  )  ;", "if    ( surAtFront    &  &     (  ( length )     <     3  )  )     {", "return ;", "}", "boolean   surAtEnd    =     (  (  ( allowEndSur    &  &     ( endHigh    >  =     5  5  2  9  6  )  )     &  &     ( endHigh    <  =     5  6  3  1  9  )  )     &  &     ( endLow    >  =     5  6  3  2  0  )  )     &  &     ( endLow    <  =     5  7  3  4  3  )  ;", "allowFrontSur    =    allowEndSur    =    true ;", "if    ( surAtFront    =  =    surAtEnd )     {", "if    ( surAtFront )     {", "chars [ end ]     =    frontLow ;", "chars [  ( end    -     1  )  ]     =    frontHigh ;", "chars [ i ]     =    endHigh ;", "chars [  ( i    +     1  )  ]     =    endLow ;", "frontHigh    =    chars [  ( i    +     2  )  ]  ;", "endLow    =    chars [  ( end    -     2  )  ]  ;", "i +  +  ;", "end -  -  ;", "} else    {", "chars [ end ]     =    frontHigh ;", "chars [ i ]     =    endLow ;", "frontHigh    =    frontLow ;", "endLow    =    endHigh ;", "}", "} else    {", "if    ( surAtFront )     {", "chars [ end ]     =    frontLow ;", "chars [ i ]     =    endLow ;", "endLow    =    endHigh ;", "allowFrontSur    =    false ;", "} else    {", "chars [ end ]     =    frontHigh ;", "chars [ i ]     =    endHigh ;", "frontHigh    =    frontLow ;", "allowEndSur    =    false ;", "}", "}", "}", "if    (  (  (  ( length )     &     1  )     =  =     1  )     &  &     (  (  ! allowFrontSur )     |  |     (  ! allowEndSur )  )  )     {", "chars [ end ]     =     ( allowFrontSur )     ?    endLow    :    frontHigh ;", "}", "}", "METHOD_END"], "methodName": ["reverse0"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     >    index )     |  |     ( index    >  =     ( length )  )  )     {", "throw   new   IndexOutOfBoundsException ( index )  ;", "}", "chars [ index ]     =    ch ;", "}", "METHOD_END"], "methodName": ["setCharAt"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( newLength    <     0  )     {", "throw   new   IndexOutOfBoundsException ( newLength )  ;", "}", "if    ( newLength    >     ( chars . length )  )     {", "enlargeBuffer ( newLength )  ;", "} else    {", "if    (  ( length )     <    newLength )     {", "Arrays . fill ( chars ,    length ,    newLength ,     (  ( char )     (  0  )  )  )  ;", "}", "}", "length    =    newLength ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "return   substring ( start ,    end )  ;", "}", "METHOD_END"], "methodName": ["subSequence"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     <  =    start )     &  &     ( start    <  =     ( length )  )  )     {", "if    ( start    =  =     ( length )  )     {", "return    \"  \"  ;", "}", "return   new    ( chars ,    start ,     (  ( length )     -    start )  )  ;", "}", "throw   new   IndexOutOfBoundsException ( start )  ;", "}", "METHOD_END"], "methodName": ["substring"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  0     <  =    start )     &  &     ( start    <  =    end )  )     &  &     ( end    <  =     ( length )  )  )     {", "if    ( start    =  =    end )     {", "return    \"  \"  ;", "}", "return   new    ( chars ,    start ,     ( end    -    start )  )  ;", "}", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "METHOD_END"], "methodName": ["substring"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( length )     <     ( chars . length )  )     {", "char [  ]    newValue    =    new   char [ length ]  ;", "System . arraycopy ( chars ,     0  ,    newValue ,     0  ,    length )  ;", "chars    =    newValue ;", "}", "}", "METHOD_END"], "methodName": ["trimToSize"], "fileName": "com.badlogic.gdx.utils.StringBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( messageFormat )     !  =    null )     {", "messageFormat . applyPattern ( replaceEscapeChars ( pattern )  )  ;", "return   messageFormat . format ( args )  ;", "}", "return   simpleFormat ( pattern ,    args )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "com.badlogic.gdx.utils.TextFormatter"}, {"methodBody": ["METHOD_START", "{", "buffer . setLength (  0  )  ;", "boolean   changed    =    false ;", "int   len    =    pn . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "char   ch    =    pn . charAt ( i )  ;", "if    ( ch    =  =     '  \\  '  '  )     {", "changed    =    true ;", "buffer . append (  \"  '  '  \"  )  ;", "} else", "if    ( ch    =  =     '  {  '  )     {", "int   j    =    i    +     1  ;", "while    (  ( j    <    len )     &  &     (  ( pn . charAt ( j )  )     =  =     '  {  '  )  )", "j +  +  ;", "int   escaped    =     ( j    -    i )     /     2  ;", "if    ( escaped    >     0  )     {", "changed    =    true ;", "buffer . append (  '  \\  '  '  )  ;", "do    {", "buffer . append (  '  {  '  )  ;", "}    while    (  (  -  - escaped )     >     0     )  ;", "buffer . append (  '  \\  '  '  )  ;", "}", "if    (  (  ( j    -    i )     %     2  )     !  =     0  )", "buffer . append (  '  {  '  )  ;", "i    =    j    -     1  ;", "} else    {", "buffer . append ( ch )  ;", "}", "}", "return   changed    ?    buffer . toString (  )     :    pn ;", "}", "METHOD_END"], "methodName": ["replaceEscapeChars"], "fileName": "com.badlogic.gdx.utils.TextFormatter"}, {"methodBody": ["METHOD_START", "{", "buffer . setLength (  0  )  ;", "boolean   changed    =    false ;", "int   placeholder    =     -  1  ;", "int   pnLength    =    pn . length (  )  ;", "for    ( int   i    =     0  ;    i    <    pnLength ;     +  + i )     {", "char   ch    =    pn . charAt ( i )  ;", "if    ( placeholder    <     0  )     {", "if    ( ch    =  =     '  {  '  )     {", "changed    =    true ;", "if    (  (  ( i    +     1  )     <    pnLength )     &  &     (  ( pn . charAt (  ( i    +     1  )  )  )     =  =     '  {  '  )  )     {", "buffer . append ( ch )  ;", "+  + i ;", "} else    {", "placeholder    =     0  ;", "}", "} else    {", "buffer . append ( ch )  ;", "}", "} else    {", "if    ( ch    =  =     '  }  '  )     {", "if    ( placeholder    >  =     ( args . length )  )", "throw   new   IllegalArgumentException (  (  \" Argument   index   out   of   bounds :     \"     +    placeholder )  )  ;", "if    (  ( pn . charAt (  ( i    -     1  )  )  )     =  =     '  {  '  )", "throw   new   IllegalArgumentException (  \" Missing   argument   index   after   a   left   curly   brace \"  )  ;", "if    (  ( args [ placeholder ]  )     =  =    null )", "buffer . append (  \" null \"  )  ;", "else", "buffer . append ( args [ placeholder ]  . toString (  )  )  ;", "placeholder    =     -  1  ;", "} else    {", "if    (  ( ch    <     '  0  '  )     |  |     ( ch    >     '  9  '  )  )", "throw   new   IllegalArgumentException (  (  (  \" Unexpected    '  \"     +    ch )     +     \"  '    while   parsing   argument   index \"  )  )  ;", "placeholder    =     ( placeholder    *     1  0  )     +     ( ch    -     '  0  '  )  ;", "}", "}", "}", "if    ( placeholder    >  =     0  )", "throw   new   IllegalArgumentException (  \" Unmatched   braces   in   the   pn .  \"  )  ;", "return   changed    ?    buffer . toString (  )     :    pn ;", "}", "METHOD_END"], "methodName": ["simpleFormat"], "fileName": "com.badlogic.gdx.utils.TextFormatter"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert    ( lo    <  =    start )     &  &     ( start    <  =    hi )  ;", "if    ( start    =  =    lo )", "start +  +  ;", "for    (  ;    start    <    hi ;    start +  +  )     {", "T   pivot    =    a [ start ]  ;", "int   left    =    lo ;", "int   right    =    start ;", "if    ( TimSort . DEBUG )", "assert   left    <  =    right ;", "while    ( left    <    right )     {", "int   mid    =     ( left    +    right )     >  >  >     1  ;", "if    (  ( c . compare ( pivot ,    a [ mid ]  )  )     <     0  )", "right    =    mid ;", "else", "left    =    mid    +     1  ;", "}", "if    ( TimSort . DEBUG )", "assert   left    =  =    right ;", "int   n    =    start    -    left ;", "switch    ( n )     {", "case    2     :", "a [  ( left    +     2  )  ]     =    a [  ( left    +     1  )  ]  ;", "case    1     :", "a [  ( left    +     1  )  ]     =    a [ left ]  ;", "break ;", "default    :", "System . arraycopy ( a ,    left ,    a ,     ( left    +     1  )  ,    n )  ;", "}", "a [ left ]     =    pivot ;", "}", "}", "METHOD_END"], "methodName": ["binarySort"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert   lo    <    hi ;", "int   runHi    =    lo    +     1  ;", "if    ( runHi    =  =    hi )", "return    1  ;", "if    (  ( c . compare ( a [  ( runHi +  +  )  ]  ,    a [ lo ]  )  )     <     0  )     {", "while    (  ( runHi    <    hi )     &  &     (  ( c . compare ( a [ runHi ]  ,    a [  ( runHi    -     1  )  ]  )  )     <     0  )  )", "runHi +  +  ;", "TimSort . reverseRange ( a ,    lo ,    runHi )  ;", "} else    {", "while    (  ( runHi    <    hi )     &  &     (  ( c . compare ( a [ runHi ]  ,    a [  ( runHi    -     1  )  ]  )  )     >  =     0  )  )", "runHi +  +  ;", "}", "return   runHi    -    lo ;", "}", "METHOD_END"], "methodName": ["countRunAndMakeAscending"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "stackSize    =     0  ;", ". rangeCheck ( a . length ,    lo ,    hi )  ;", "int   nRemaining    =    hi    -    lo ;", "if    ( nRemaining    <     2  )", "return ;", "if    ( nRemaining    <     (  . MIN _ MERGE )  )     {", "int   initRunLen    =     . countRunAndMakeAscending ( a ,    lo ,    hi ,    c )  ;", ". binarySort ( a ,    lo ,    hi ,     ( lo    +    initRunLen )  ,    c )  ;", "return ;", "}", "this . a    =    a ;", "this . c    =    c ;", "tmpCount    =     0  ;", "int   minRun    =     . minRunLength ( nRemaining )  ;", "do    {", "int   runLen    =     . countRunAndMakeAscending ( a ,    lo ,    hi ,    c )  ;", "if    ( runLen    <    minRun )     {", "int   force    =     ( nRemaining    <  =    minRun )     ?    nRemaining    :    minRun ;", ". binarySort ( a ,    lo ,     ( lo    +    force )  ,     ( lo    +    runLen )  ,    c )  ;", "runLen    =    force ;", "}", "pushRun ( lo ,    runLen )  ;", "mergeCollapse (  )  ;", "lo    +  =    runLen ;", "nRemaining    -  =    runLen ;", "}    while    ( nRemaining    !  =     0     )  ;", "if    (  . DEBUG )", "assert   lo    =  =    hi ;", "mergeForceCollapse (  )  ;", "if    (  . DEBUG )", "assert    ( stackSize )     =  =     1  ;", "this . a    =    null ;", "this . c    =    null ;", "T [  ]    tmp    =    this . tmp ;", "for    ( int   i    =     0  ,    n    =    tmpCount ;    i    <    n ;    i +  +  )", "tmp [ i ]     =    null ;", "}", "METHOD_END"], "methodName": ["doSort"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "tmpCount    =    Math . max ( tmpCount ,    minCapacity )  ;", "if    (  ( tmp . length )     <    minCapacity )     {", "int   newSize    =    minCapacity ;", "newSize    |  =    newSize    >  >     1  ;", "newSize    |  =    newSize    >  >     2  ;", "newSize    |  =    newSize    >  >     4  ;", "newSize    |  =    newSize    >  >     8  ;", "newSize    |  =    newSize    >  >     1  6  ;", "newSize +  +  ;", "if    ( newSize    <     0  )", "newSize    =    minCapacity ;", "ee", "newSize    =    Math . min ( newSize ,     (  ( a . length )     >  >  >     1  )  )  ;", "T [  ]    newArray    =     (  ( T [  ]  )     ( new   Object [ newSize ]  )  )  ;", "tmp    =    newArray ;", "}", "return   tmp ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert    (  ( len    >     0  )     &  &     ( hint    >  =     0  )  )     &  &     ( hint    <    len )  ;", "int   lastOfs    =     0  ;", "int   ofs    =     1  ;", "if    (  ( c . compare ( key ,    a [  ( base    +    hint )  ]  )  )     >     0  )     {", "int   maxOfs    =    len    -    hint ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( c . compare ( key ,    a [  (  ( base    +    hint )     +    ofs )  ]  )  )     >     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "lastOfs    +  =    hint ;", "ofs    +  =    hint ;", "} else    {", "final   int   maxOfs    =    hint    +     1  ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( c . compare ( key ,    a [  (  ( base    +    hint )     -    ofs )  ]  )  )     <  =     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "int   tmp    =    lastOfs ;", "lastOfs    =    hint    -    ofs ;", "ofs    =    hint    -    tmp ;", "}", "if    ( TimSort . DEBUG )", "assert    (  (  (  -  1  )     <  =    lastOfs )     &  &     ( lastOfs    <    ofs )  )     &  &     ( ofs    <  =    len )  ;", "lastOfs +  +  ;", "while    ( lastOfs    <    ofs )     {", "int   m    =    lastOfs    +     (  ( ofs    -    lastOfs )     >  >  >     1  )  ;", "if    (  ( c . compare ( key ,    a [  ( base    +    m )  ]  )  )     >     0  )", "lastOfs    =    m    +     1  ;", "else", "ofs    =    m ;", "}", "if    ( TimSort . DEBUG )", "assert   lastOfs    =  =    ofs ;", "return   ofs ;", "}", "METHOD_END"], "methodName": ["gallopLeft"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert    (  ( len    >     0  )     &  &     ( hint    >  =     0  )  )     &  &     ( hint    <    len )  ;", "int   ofs    =     1  ;", "int   lastOfs    =     0  ;", "if    (  ( c . compare ( key ,    a [  ( base    +    hint )  ]  )  )     <     0  )     {", "int   maxOfs    =    hint    +     1  ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( c . compare ( key ,    a [  (  ( base    +    hint )     -    ofs )  ]  )  )     <     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "int   tmp    =    lastOfs ;", "lastOfs    =    hint    -    ofs ;", "ofs    =    hint    -    tmp ;", "} else    {", "int   maxOfs    =    len    -    hint ;", "while    (  ( ofs    <    maxOfs )     &  &     (  ( c . compare ( key ,    a [  (  ( base    +    hint )     +    ofs )  ]  )  )     >  =     0  )  )     {", "lastOfs    =    ofs ;", "ofs    =     ( ofs    <  <     1  )     +     1  ;", "if    ( ofs    <  =     0  )", "ofs    =    maxOfs ;", "}", "if    ( ofs    >    maxOfs )", "ofs    =    maxOfs ;", "lastOfs    +  =    hint ;", "ofs    +  =    hint ;", "}", "if    ( TimSort . DEBUG )", "assert    (  (  (  -  1  )     <  =    lastOfs )     &  &     ( lastOfs    <    ofs )  )     &  &     ( ofs    <  =    len )  ;", "lastOfs +  +  ;", "while    ( lastOfs    <    ofs )     {", "int   m    =    lastOfs    +     (  ( ofs    -    lastOfs )     >  >  >     1  )  ;", "if    (  ( c . compare ( key ,    a [  ( base    +    m )  ]  )  )     <     0  )", "ofs    =    m ;", "else", "lastOfs    =    m    +     1  ;", "}", "if    ( TimSort . DEBUG )", "assert   lastOfs    =  =    ofs ;", "return   ofs ;", "}", "METHOD_END"], "methodName": ["gallopRight"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert    ( stackSize )     >  =     2  ;", "if    ( TimSort . DEBUG )", "assert   i    >  =     0  ;", "if    ( TimSort . DEBUG )", "assert    ( i    =  =     (  ( stackSize )     -     2  )  )     |  |     ( i    =  =     (  ( stackSize )     -     3  )  )  ;", "int   base 1     =    runBase [ i ]  ;", "int   len 1     =    runLen [ i ]  ;", "int   base 2     =    runBase [  ( i    +     1  )  ]  ;", "int   len 2     =    runLen [  ( i    +     1  )  ]  ;", "if    ( TimSort . DEBUG )", "assert    ( len 1     >     0  )     &  &     ( len 2     >     0  )  ;", "if    ( TimSort . DEBUG )", "assert    ( base 1     +    len 1  )     =  =    base 2  ;", "runLen [ i ]     =    len 1     +    len 2  ;", "if    ( i    =  =     (  ( stackSize )     -     3  )  )     {", "runBase [  ( i    +     1  )  ]     =    runBase [  ( i    +     2  )  ]  ;", "runLen [  ( i    +     1  )  ]     =    runLen [  ( i    +     2  )  ]  ;", "}", "( stackSize )  -  -  ;", "int   k    =    TimSort . gallopRight ( a [ base 2  ]  ,    a ,    base 1  ,    len 1  ,     0  ,    c )  ;", "if    ( TimSort . DEBUG )", "assert   k    >  =     0  ;", "base 1     +  =    k ;", "len 1     -  =    k ;", "if    ( len 1     =  =     0  )", "return ;", "len 2     =    TimSort . gallopLeft ( a [  (  ( base 1     +    len 1  )     -     1  )  ]  ,    a ,    base 2  ,    len 2  ,     ( len 2     -     1  )  ,    c )  ;", "if    ( TimSort . DEBUG )", "assert   len 2     >  =     0  ;", "if    ( len 2     =  =     0  )", "return ;", "if    ( len 1     <  =    len 2  )", "mergeLo ( base 1  ,    len 1  ,    base 2  ,    len 2  )  ;", "else", "mergeHi ( base 1  ,    len 1  ,    base 2  ,    len 2  )  ;", "}", "METHOD_END"], "methodName": ["mergeAt"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "while    (  ( stackSize )     >     1  )     {", "int   n    =     ( stackSize )     -     2  ;", "if    (  (  ( n    >  =     1  )     &  &     (  ( runLen [  ( n    -     1  )  ]  )     <  =     (  ( runLen [ n ]  )     +     ( runLen [  ( n    +     1  )  ]  )  )  )  )     |  |     (  ( n    >  =     2  )     &  &     (  ( runLen [  ( n    -     2  )  ]  )     <  =     (  ( runLen [ n ]  )     +     ( runLen [  ( n    -     1  )  ]  )  )  )  )  )     {", "if    (  ( runLen [  ( n    -     1  )  ]  )     <     ( runLen [  ( n    +     1  )  ]  )  )", "n -  -  ;", "} else", "if    (  ( runLen [ n ]  )     >     ( runLen [  ( n    +     1  )  ]  )  )     {", "break ;", "}", "mergeAt ( n )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeCollapse"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "while    (  ( stackSize )     >     1  )     {", "int   n    =     ( stackSize )     -     2  ;", "if    (  ( n    >     0  )     &  &     (  ( runLen [  ( n    -     1  )  ]  )     <     ( runLen [  ( n    +     1  )  ]  )  )  )", "n -  -  ;", "mergeAt ( n )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeForceCollapse"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert    (  ( len 1     >     0  )     &  &     ( len 2     >     0  )  )     &  &     (  ( base 1     +    len 1  )     =  =    base 2  )  ;", "T [  ]    a    =    this . a ;", "T [  ]    tmp    =    ensureCapacity ( len 2  )  ;", "System . arraycopy ( a ,    base 2  ,    tmp ,     0  ,    len 2  )  ;", "int   cursor 1     =     ( base 1     +    len 1  )     -     1  ;", "int   cursor 2     =    len 2     -     1  ;", "int   dest    =     ( base 2     +    len 2  )     -     1  ;", "a [  ( dest -  -  )  ]     =    a [  ( cursor 1  -  -  )  ]  ;", "if    (  (  -  - len 1  )     =  =     0  )     {", "System . arraycopy ( tmp ,     0  ,    a ,     ( dest    -     ( len 2     -     1  )  )  ,    len 2  )  ;", "return ;", "}", "if    ( len 2     =  =     1  )     {", "dest    -  =    len 1  ;", "cursor 1     -  =    len 1  ;", "System . arraycopy ( a ,     ( cursor 1     +     1  )  ,    a ,     ( dest    +     1  )  ,    len 1  )  ;", "a [ dest ]     =    tmp [ cursor 2  ]  ;", "return ;", "}", "Comparator <  ?    super   T >    c    =    this . c ;", "int   minGallop    =    this . minGallop ;", "outer    :    while    ( true )     {", "int   count 1     =     0  ;", "int   count 2     =     0  ;", "do    {", "if    ( TimSort . DEBUG )", "assert    ( len 1     >     0  )     &  &     ( len 2     >     1  )  ;", "if    (  ( c . compare ( tmp [ cursor 2  ]  ,    a [ cursor 1  ]  )  )     <     0  )     {", "a [  ( dest -  -  )  ]     =    a [  ( cursor 1  -  -  )  ]  ;", "count 1  +  +  ;", "count 2     =     0  ;", "if    (  (  -  - len 1  )     =  =     0  )", "break   outer ;", "} else    {", "a [  ( dest -  -  )  ]     =    tmp [  ( cursor 2  -  -  )  ]  ;", "count 2  +  +  ;", "count 1     =     0  ;", "if    (  (  -  - len 2  )     =  =     1  )", "break   outer ;", "}", "}    while    (  ( count 1     |    count 2  )     <    minGallop    )  ;", "do    {", "if    ( TimSort . DEBUG )", "assert    ( len 1     >     0  )     &  &     ( len 2     >     1  )  ;", "count 1     =    len 1     -     ( TimSort . gallopRight ( tmp [ cursor 2  ]  ,    a ,    base 1  ,    len 1  ,     ( len 1     -     1  )  ,    c )  )  ;", "if    ( count 1     !  =     0  )     {", "dest    -  =    count 1  ;", "cursor 1     -  =    count 1  ;", "len 1     -  =    count 1  ;", "System . arraycopy ( a ,     ( cursor 1     +     1  )  ,    a ,     ( dest    +     1  )  ,    count 1  )  ;", "if    ( len 1     =  =     0  )", "break   outer ;", "}", "a [  ( dest -  -  )  ]     =    tmp [  ( cursor 2  -  -  )  ]  ;", "if    (  (  -  - len 2  )     =  =     1  )", "break   outer ;", "count 2     =    len 2     -     ( TimSort . gallopLeft ( a [ cursor 1  ]  ,    tmp ,     0  ,    len 2  ,     ( len 2     -     1  )  ,    c )  )  ;", "if    ( count 2     !  =     0  )     {", "dest    -  =    count 2  ;", "cursor 2     -  =    count 2  ;", "len 2     -  =    count 2  ;", "System . arraycopy ( tmp ,     ( cursor 2     +     1  )  ,    a ,     ( dest    +     1  )  ,    count 2  )  ;", "if    ( len 2     <  =     1  )", "break   outer ;", "}", "a [  ( dest -  -  )  ]     =    a [  ( cursor 1  -  -  )  ]  ;", "if    (  (  -  - len 1  )     =  =     0  )", "break   outer ;", "minGallop -  -  ;", "}    while    (  ( count 1     >  =     ( TimSort . MIN _ GALLOP )  )     |     ( count 2     >  =     ( TimSort . MIN _ GALLOP )  )     )  ;", "if    ( minGallop    <     0  )", "minGallop    =     0  ;", "minGallop    +  =     2  ;", "}", "this . minGallop    =     ( minGallop    <     1  )     ?     1     :    minGallop ;", "if    ( len 2     =  =     1  )     {", "if    ( TimSort . DEBUG )", "assert   len 1     >     0  ;", "dest    -  =    len 1  ;", "cursor 1     -  =    len 1  ;", "System . arraycopy ( a ,     ( cursor 1     +     1  )  ,    a ,     ( dest    +     1  )  ,    len 1  )  ;", "a [ dest ]     =    tmp [ cursor 2  ]  ;", "} else", "if    ( len 2     =  =     0  )     {", "throw   new   IllegalArgumentException (  \" Comparison   method   violates   its   general   contract !  \"  )  ;", "} else    {", "if    ( TimSort . DEBUG )", "assert   len 1     =  =     0  ;", "if    ( TimSort . DEBUG )", "assert   len 2     >     0  ;", "System . arraycopy ( tmp ,     0  ,    a ,     ( dest    -     ( len 2     -     1  )  )  ,    len 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeHi"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert    (  ( len 1     >     0  )     &  &     ( len 2     >     0  )  )     &  &     (  ( base 1     +    len 1  )     =  =    base 2  )  ;", "T [  ]    a    =    this . a ;", "T [  ]    tmp    =    ensureCapacity ( len 1  )  ;", "System . arraycopy ( a ,    base 1  ,    tmp ,     0  ,    len 1  )  ;", "int   cursor 1     =     0  ;", "int   cursor 2     =    base 2  ;", "int   dest    =    base 1  ;", "a [  ( dest +  +  )  ]     =    a [  ( cursor 2  +  +  )  ]  ;", "if    (  (  -  - len 2  )     =  =     0  )     {", "System . arraycopy ( tmp ,    cursor 1  ,    a ,    dest ,    len 1  )  ;", "return ;", "}", "if    ( len 1     =  =     1  )     {", "System . arraycopy ( a ,    cursor 2  ,    a ,    dest ,    len 2  )  ;", "a [  ( dest    +    len 2  )  ]     =    tmp [ cursor 1  ]  ;", "return ;", "}", "Comparator <  ?    super   T >    c    =    this . c ;", "int   minGallop    =    this . minGallop ;", "outer    :    while    ( true )     {", "int   count 1     =     0  ;", "int   count 2     =     0  ;", "do    {", "if    ( TimSort . DEBUG )", "assert    ( len 1     >     1  )     &  &     ( len 2     >     0  )  ;", "if    (  ( c . compare ( a [ cursor 2  ]  ,    tmp [ cursor 1  ]  )  )     <     0  )     {", "a [  ( dest +  +  )  ]     =    a [  ( cursor 2  +  +  )  ]  ;", "count 2  +  +  ;", "count 1     =     0  ;", "if    (  (  -  - len 2  )     =  =     0  )", "break   outer ;", "} else    {", "a [  ( dest +  +  )  ]     =    tmp [  ( cursor 1  +  +  )  ]  ;", "count 1  +  +  ;", "count 2     =     0  ;", "if    (  (  -  - len 1  )     =  =     1  )", "break   outer ;", "}", "}    while    (  ( count 1     |    count 2  )     <    minGallop    )  ;", "do    {", "if    ( TimSort . DEBUG )", "assert    ( len 1     >     1  )     &  &     ( len 2     >     0  )  ;", "count 1     =    TimSort . gallopRight ( a [ cursor 2  ]  ,    tmp ,    cursor 1  ,    len 1  ,     0  ,    c )  ;", "if    ( count 1     !  =     0  )     {", "System . arraycopy ( tmp ,    cursor 1  ,    a ,    dest ,    count 1  )  ;", "dest    +  =    count 1  ;", "cursor 1     +  =    count 1  ;", "len 1     -  =    count 1  ;", "if    ( len 1     <  =     1  )", "break   outer ;", "}", "a [  ( dest +  +  )  ]     =    a [  ( cursor 2  +  +  )  ]  ;", "if    (  (  -  - len 2  )     =  =     0  )", "break   outer ;", "count 2     =    TimSort . gallopLeft ( tmp [ cursor 1  ]  ,    a ,    cursor 2  ,    len 2  ,     0  ,    c )  ;", "if    ( count 2     !  =     0  )     {", "System . arraycopy ( a ,    cursor 2  ,    a ,    dest ,    count 2  )  ;", "dest    +  =    count 2  ;", "cursor 2     +  =    count 2  ;", "len 2     -  =    count 2  ;", "if    ( len 2     =  =     0  )", "break   outer ;", "}", "a [  ( dest +  +  )  ]     =    tmp [  ( cursor 1  +  +  )  ]  ;", "if    (  (  -  - len 1  )     =  =     1  )", "break   outer ;", "minGallop -  -  ;", "}    while    (  ( count 1     >  =     ( TimSort . MIN _ GALLOP )  )     |     ( count 2     >  =     ( TimSort . MIN _ GALLOP )  )     )  ;", "if    ( minGallop    <     0  )", "minGallop    =     0  ;", "minGallop    +  =     2  ;", "}", "this . minGallop    =     ( minGallop    <     1  )     ?     1     :    minGallop ;", "if    ( len 1     =  =     1  )     {", "if    ( TimSort . DEBUG )", "assert   len 2     >     0  ;", "System . arraycopy ( a ,    cursor 2  ,    a ,    dest ,    len 2  )  ;", "a [  ( dest    +    len 2  )  ]     =    tmp [ cursor 1  ]  ;", "} else", "if    ( len 1     =  =     0  )     {", "throw   new   IllegalArgumentException (  \" Comparison   method   violates   its   general   contract !  \"  )  ;", "} else    {", "if    ( TimSort . DEBUG )", "assert   len 2     =  =     0  ;", "if    ( TimSort . DEBUG )", "assert   len 1     >     1  ;", "System . arraycopy ( tmp ,    cursor 1  ,    a ,    dest ,    len 1  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeLo"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( TimSort . DEBUG )", "assert   n    >  =     0  ;", "int   r    =     0  ;", "while    ( n    >  =     ( TimSort . MIN _ MERGE )  )     {", "r    |  =    n    &     1  ;", "n    >  >  =     1  ;", "}", "return   n    +    r ;", "}", "METHOD_END"], "methodName": ["minRunLength"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "this . runBase [ stackSize ]     =    runBase ;", "this . runLen [ stackSize ]     =    runLen ;", "( stackSize )  +  +  ;", "}", "METHOD_END"], "methodName": ["pushRun"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( fromIndex    >    toIndex )", "throw   new   IllegalArgumentException (  (  (  (  (  \" fromIndex (  \"     +    fromIndex )     +     \"  )     >    toIndex (  \"  )     +    toIndex )     +     \"  )  \"  )  )  ;", "if    ( fromIndex    <     0  )", "throw   new   ArrayIndexOutOfBoundsException ( fromIndex )  ;", "if    ( toIndex    >    arrayLen )", "throw   new   ArrayIndexOutOfBoundsException ( toIndex )  ;", "}", "METHOD_END"], "methodName": ["rangeCheck"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "hi -  -  ;", "whe    ( lo    <    hi )     {", "Object   t    =    a [ lo ]  ;", "a [  ( lo +  +  )  ]     =    a [ hi ]  ;", "a [  ( hi -  -  )  ]     =    t ;", "}", "}", "METHOD_END"], "methodName": ["reverseRange"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "if    ( c    =  =    null )     {", "Arrays . sort ( a ,    lo ,    hi )  ;", "return ;", "}", ". rangeCheck ( a . length ,    lo ,    hi )  ;", "int   nRemaining    =    hi    -    lo ;", "if    ( nRemaining    <     2  )", "return ;", "if    ( nRemaining    <     (  . MIN _ MERGE )  )     {", "int   initRunLen    =     . countRunAndMakeAscending ( a ,    lo ,    hi ,    c )  ;", ". binarySort ( a ,    lo ,    hi ,     ( lo    +    initRunLen )  ,    c )  ;", "return ;", "}", "< T >    ts    =    new    < T >  ( a ,    c )  ;", "int   minRun    =     . minRunLength ( nRemaining )  ;", "do    {", "int   runLen    =     . countRunAndMakeAscending ( a ,    lo ,    hi ,    c )  ;", "if    ( runLen    <    minRun )     {", "int   force    =     ( nRemaining    <  =    minRun )     ?    nRemaining    :    minRun ;", ". binarySort ( a ,    lo ,     ( lo    +    force )  ,     ( lo    +    runLen )  ,    c )  ;", "runLen    =    force ;", "}", "ts . pushRun ( lo ,    runLen )  ;", "ts . mergeCollapse (  )  ;", "lo    +  =    runLen ;", "nRemaining    -  =    runLen ;", "}    while    ( nRemaining    !  =     0     )  ;", "if    (  . DEBUG )", "assert   lo    =  =    hi ;", "ts . mergeForceCollapse (  )  ;", "if    (  . DEBUG )", "assert    ( ts . stackSize )     =  =     1  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "TimSort . sort ( a ,     0  ,    a . length ,    c )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.badlogic.gdx.utils.TimSort"}, {"methodBody": ["METHOD_START", "{", "return   System . currentTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["millis"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return   millis    *     ( TimeUtils . nanosPerMilli )  ;", "}", "METHOD_END"], "methodName": ["millisToNanos"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return   System . nanoTime (  )  ;", "}", "METHOD_END"], "methodName": ["nanoTime"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return   nanos    /     ( TimeUtils . nanosPerMilli )  ;", "}", "METHOD_END"], "methodName": ["nanosToMillis"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( TimeUtils . millis (  )  )     -    prevTime ;", "}", "METHOD_END"], "methodName": ["timeSinceMillis"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( TimeUtils . nanoTime (  )  )     -    prevTime ;", "}", "METHOD_END"], "methodName": ["timeSinceNanos"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    tasks . size ;    i    <    n ;    i +  +  )     {", ". Task   task    =    tasks . get ( i )  ;", "synchronized ( task )     {", "task . executeTimeMillis    =     0  ;", "task . timer    =    null ;", "}", "}", "tasks . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    tasks . size ;    i    <    n ;    i +  +  )     {", ". Task   task    =    tasks . get ( i )  ;", "synchronized ( task )     {", "task . executeTimeMillis    +  =    delayMillis ;", "}", "}", "}", "METHOD_END"], "methodName": ["delay"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized . threadLock )     {", "Thread   thread    =  . thread (  )  ;", "if    (  ( thread . instance )     =  =    null )", "thread . instance    =    new (  )  ;", "return   thread . instance ;", "}", "}", "METHOD_END"], "methodName": ["instance"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return    ( tasks . size )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . postTask ( task )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   scheduleTask ( task ,     0  ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["postTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . scheduleTask ( task ,    delaySeconds )  ;", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . scheduleTask ( task ,    delaySeconds ,    intervalSeconds )  ;", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . scheduleTask ( task ,    delaySeconds ,    intervalSeconds ,    repeatCount )  ;", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   scheduleTask ( task ,    delaySeconds ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["scheduleTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   scheduleTask ( task ,    delaySeconds ,    intervalSeconds ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["scheduleTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "synchronized ( task )     {", "if    (  ( task . timer )     !  =    null )", "throw   new   IllegalArgumentException (  \" The   same   task   may   not   be   scheduled   twice .  \"  )  ;", "task . timer    =    this ;", "task . executeTimeMillis    =     (  ( System . nanoTime (  )  )     /     1  0  0  0  0  0  0  )     +     (  ( long )     ( delaySeconds    *     1  0  0  0  )  )  ;", "task . intervalMillis    =     (  ( long )     ( intervalSeconds    *     1  0  0  0  )  )  ;", "task . repeatCount    =    repeatCount ;", "tasks . add ( task )  ;", "}", "}", "synchronized (  . threadLock )     {", ". threadLock . notifyAll (  )  ;", "}", "return   task ;", "}", "METHOD_END"], "methodName": ["scheduleTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized . threadLock )     {", "Thread   thread    =  . thread (  )  ;", "Array >    instances    =    thread . instances ;", "if    ( instances . contains ( this ,    true )  )", "return ;", "instances . add ( this )  ;", ". threadLock . notifyAll (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( Timer . threadLock )     {", "Timer . thread (  )  . instances . removeValue ( this ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized . threadLock )     {", "if    (  (  . thread )     =  =    null )     |  |     (  . thread . files )     !  =     ( Gdx . files )  )  )     {", "if    (  . thread )     !  =    null )", ". thread . dispose (  )  ;", ". thread    =    newThread (  )  ;", "}", "return . thread ;", "}", "}", "METHOD_END"], "methodName": ["thread"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    n    =    tasks . size ;    i    <    n ;    i +  +  )     {", ". Task   task    =    tasks . get ( i )  ;", "synchronized ( task )     {", "if    (  ( task . executeTimeMillis )     >    timeMillis )     {", "waitMillis    =    Math . min ( waitMillis ,     (  ( task . executeTimeMillis )     -    timeMillis )  )  ;", "continue ;", "}", "if    (  ( task . repeatCount )     =  =     0  )     {", "task . timer    =    null ;", "tasks . removeIndex ( i )  ;", "i -  -  ;", "n -  -  ;", "} else    {", "task . executeTimeMillis    =    timeMillis    +     ( task . intervalMillis )  ;", "waitMillis    =    Math . min ( waitMillis ,    task . intervalMillis )  ;", "if    (  ( task . repeatCount )     >     0  )", "( task . repeatCount )  -  -  ;", "}", "task . app . postRunnable ( task )  ;", "}", "}", "return   waitMillis ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   parse ( din ,    din . readByte (  )  )  ;", "}    finally    {", "StreamUcloseQuietly ( din )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =     '  [  '  )", "return   parseArray ( din )  ;", "else", "if    ( type    =  =     '  {  '  )", "return   parseObject ( din )  ;", "else", "if    ( type    =  =     ' Z '  )", "return   new   Value ( Value . ValueType . nullValue )  ;", "else", "if    ( type    =  =     ' T '  )", "return   new   Value ( true )  ;", "else", "if    ( type    =  =     ' F '  )", "return   new   Value ( false )  ;", "else", "if    ( type    =  =     ' B '  )", "return   new   Value (  (  ( long )     ( readUChar ( din )  )  )  )  ;", "else", "if    ( type    =  =     ' U '  )", "return   new   Value (  (  ( long )     ( readUChar ( din )  )  )  )  ;", "else", "if    ( type    =  =     ' i '  )", "return   new   Value (  ( oldFormat    ?     (  ( long )     ( din . readShort (  )  )  )     :     (  ( long )     ( din . readByte (  )  )  )  )  )  ;", "else", "if    ( type    =  =     ' I '  )", "return   new   Value (  ( oldFormat    ?     (  ( long )     ( din . readInt (  )  )  )     :     (  ( long )     ( din . readShort (  )  )  )  )  )  ;", "else", "if    ( type    =  =     ' l '  )", "return   new   Value (  (  ( long )     ( din . readInt (  )  )  )  )  ;", "else", "if    ( type    =  =     ' L '  )", "return   new   Value ( din . readLong (  )  )  ;", "else", "if    ( type    =  =     ' d '  )", "return   new   Value ( din . readFloat (  )  )  ;", "else", "if    ( type    =  =     ' D '  )", "return   new   Value ( din . readDouble (  )  )  ;", "else", "if    (  ( type    =  =     ' s '  )     |  |     ( type    =  =     ' S '  )  )", "return   new   Value ( parseString ( din ,    type )  )  ;", "else", "if    (  ( type    =  =     ' a '  )     |  |     ( type    =  =     ' A '  )  )", "return   parseData ( din ,    type )  ;", "else", "if    ( type    =  =     ' C '  )", "return   new   Value ( din . readChar (  )  )  ;", "else", "throw   new   GdxRuntimeException (  \" Unrecognized   data   type \"  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   result    =    new   JsonValue ( JsonValue . ValueType . array )  ;", "byte   type    =    din . readByte (  )  ;", "byte   valueType    =     0  ;", "if    ( type    =  =     '  $  '  )     {", "valueType    =    din . readByte (  )  ;", "type    =    din . readByte (  )  ;", "}", "long   size    =     -  1  ;", "if    ( type    =  =     '  #  '  )     {", "size    =    parseSize ( din ,    false ,     (  -  1  )  )  ;", "if    ( size    <     0  )", "throw   new   GdxRuntimeException (  \" Unrecognized   data   type \"  )  ;", "if    ( size    =  =     0  )", "return   result ;", "type    =     ( valueType    =  =     0  )     ?    din . readByte (  )     :    valueType ;", "}", "JsonValue   prev    =    null ;", "long   c    =     0  ;", "while    (  (  ( din . available (  )  )     >     0  )     &  &     ( type    !  =     '  ]  '  )  )     {", "final   JsonValue   val    =    parse ( din ,    type )  ;", "val . parent    =    result ;", "if    ( prev    !  =    null )     {", "val . prev    =    prev ;", "prev . next    =    val ;", "( result . size )  +  +  ;", "} else    {", "result . child    =    val ;", "result . size    =     1  ;", "}", "prev    =    val ;", "if    (  ( size    >     0  )     &  &     (  (  +  + c )     >  =    size )  )", "break ;", "type    =     ( valueType    =  =     0  )     ?    din . readByte (  )     :    valueType ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseArray"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "final   byte   dataType    =    din . readByte (  )  ;", "final   long   size    =     ( blockType    =  =     ' A '  )     ?    readUInt ( din )     :     (  ( long )     ( readUChar ( din )  )  )  ;", "final   Value   result    =    new   Value ( Value . ValueType . array )  ;", "Value   prev    =    null ;", "for    ( long   i    =     0  ;    i    <    size ;    i +  +  )     {", "final   Value   val    =    parse ( din ,    dataType )  ;", "val . parent    =    result ;", "if    ( prev    !  =    null )     {", "prev . next    =    val ;", "( result . size )  +  +  ;", "} else    {", "result . child    =    val ;", "result . size    =     1  ;", "}", "prev    =    val ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseData"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "JsonValue   result    =    new   JsonValue ( JsonValue . ValueType . object )  ;", "byte   type    =    din . readByte (  )  ;", "byte   valueType    =     0  ;", "if    ( type    =  =     '  $  '  )     {", "valueType    =    din . readByte (  )  ;", "type    =    din . readByte (  )  ;", "}", "long   size    =     -  1  ;", "if    ( type    =  =     '  #  '  )     {", "size    =    parseSize ( din ,    false ,     (  -  1  )  )  ;", "if    ( size    <     0  )", "throw   new   GdxRuntimeException (  \" Unrecognized   data   type \"  )  ;", "if    ( size    =  =     0  )", "return   result ;", "type    =    din . readByte (  )  ;", "}", "JsonValue   prev    =    null ;", "long   c    =     0  ;", "while    (  (  ( din . available (  )  )     >     0  )     &  &     ( type    !  =     '  }  '  )  )     {", "final   String   key    =    parseString ( din ,    true ,    type )  ;", "final   JsonValue   child    =    parse ( din ,     ( valueType    =  =     0     ?    din . readByte (  )     :    valueType )  )  ;", "child . setName ( key )  ;", "child . parent    =    result ;", "if    ( prev    !  =    null )     {", "child . prev    =    prev ;", "prev . next    =    child ;", "( result . size )  +  +  ;", "} else    {", "result . child    =    child ;", "result . size    =     1  ;", "}", "prev    =    child ;", "if    (  ( size    >     0  )     &  &     (  (  +  + c )     >  =    size )  )", "break ;", "type    =    din . readByte (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseObject"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "return   parseSize ( din ,    din . readByte (  )  ,    useIntOnError ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["parseSize"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =     ' i '  )", "return    (  ( long )     ( rUChar ( din )  )  )  ;", "if    ( type    =  =     ' I '  )", "return    (  ( long )     ( rUShort ( din )  )  )  ;", "if    ( type    =  =     ' l '  )", "return    (  ( long )     ( rUInt ( din )  )  )  ;", "if    ( type    =  =     ' L '  )", "return   din . rLong (  )  ;", "if    ( useIntOnError )     {", "long   result    =     (  ( long )     (  (  ( short )     ( type )  )     &     2  5  5  )  )     <  <     2  4  ;", "result    |  =     (  ( long )     (  (  ( short )     ( din . rByte (  )  )  )     &     2  5  5  )  )     <  <     1  6  ;", "result    |  =     (  ( long )     (  (  ( short )     ( din . rByte (  )  )  )     &     2  5  5  )  )     <  <     8  ;", "result    |  =     (  ( long )     (  (  ( short )     ( din . rByte (  )  )  )     &     2  5  5  )  )  ;", "return   result ;", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["parseSize"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "long   size    =     -  1  ;", "if    ( type    =  =     ' S '  )     {", "size    =    parseSize ( din ,    true ,     (  -  1  )  )  ;", "} else", "if    ( type    =  =     ' s '  )", "size    =     (  ( long )     ( rUChar ( din )  )  )  ;", "else", "if    ( sOptional )", "size    =    parseSize ( din ,    type ,    false ,     (  -  1  )  )  ;", "if    ( size    <     0  )", "throw   new   GdxRuntimeException (  \" Unrecognized   data   type ,    string   expected \"  )  ;", "return   size    >     0     ?    rString ( din ,    size )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["parseString"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "return   parseString ( din ,    false ,    type )  ;", "}", "METHOD_END"], "methodName": ["parseString"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "final   byte [  ]    data    =    new   byte [  (  ( int )     ( size )  )  ]  ;", "din . rFully ( data )  ;", "return   new   String ( data ,     \" UTF -  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( short )     (  (  ( short )     ( din . readByte (  )  )  )     &     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readUChar"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( long )     ( din . readInt (  )  )  )     &     -  1  ;", "}", "METHOD_END"], "methodName": ["readUInt"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( din . readShort (  )  )  )     &     6  5  5  3  5  ;", "}", "METHOD_END"], "methodName": ["readUShort"], "fileName": "com.badlogic.gdx.utils.UBJsonReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     !  =    null )     {", "if    (  !  ( current . array )  )     {", "if    (  !  ( named )  )", "throw   new   IllegalStateException (  \" Name   must   be   set .  \"  )  ;", "named    =    false ;", "}", "}", "stack . add (  ( current    =    new    . JsonObject ( true )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "name ( name )  . array (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     !  =    null )     {", "if    (  !  ( current . array )  )     {", "if    (  !  ( named )  )", "throw   new   IllegalStateExcepon (  \" Name   must   be   set .  \"  )  ;", "named    =    false ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkName"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "while    (  ( stack . size )     >     0  )", "pop (  )  ;", "out . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "out . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( current )     =  =    null )     |  |     ( current . array )  )", "throw   new   IllegalStateException (  \" Current   item   must   be   an   object .  \"  )  ;", "byte [  ]    bytes    =    name . getBytes (  \" UTF -  8  \"  )  ;", "if    (  ( bytes . length )     <  =     ( Byte . MAX _ VALUE )  )     {", "out . wByte (  ' i '  )  ;", "out . wByte ( bytes . length )  ;", "} else", "if    (  ( bytes . length )     <  =     ( Short . MAX _ VALUE )  )     {", "out . wByte (  ' I '  )  ;", "out . wShort ( bytes . length )  ;", "} else    {", "out . wByte (  ' l '  )  ;", "out . wInt ( bytes . length )  ;", "}", "out . w ( bytes )  ;", "named    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     !  =    null )     {", "if    (  !  ( current . array )  )     {", "if    (  !  ( named )  )", "throw   new   IllegalStateException (  \" Name   must   be   set .  \"  )  ;", "named    =    false ;", "}", "}", "stack . add (  ( current    =    new    . JsonObject ( false )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["object"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "name ( name )  . object (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["object"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   pop ( false )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( named )", "throw   new   IllegalStateExcepon (  \" Expected   an   object ,    array ,    or   value   since   a   name   was   set .  \"  )  ;", "if    ( silent )", "stack . pop (  )  ;", "else", "stack . pop (  )  . close (  )  ;", "current    =     (  ( stack . size )     =  =     0  )     ?    null    :    stack . peek (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value (  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "return   name ( name )  . value ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' Z '  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ( value    ?     ' T '     :     ' F '  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wByte (  ( values [ i ]     ?     ' T '     :     ' F '  )  )  ;", "}", "pop (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' i '  )  ;", "out . wByte ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' i '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wByte ( values [ i ]  )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' I '  )  ;", "out . wChar ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' C '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wChar ( values [ i ]  )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( value . isObject (  )  )     {", "if    (  ( value . name )     !  =    null )", "object ( value . name )  ;", "else", "object (  )  ;", "for    ( Value   child    =    value . child ;    child    !  =    null ;    child    =    child . next )", "value ( child )  ;", "pop (  )  ;", "} else", "if    ( value . isArray (  )  )     {", "if    (  ( value . name )     !  =    null )", "array ( value . name )  ;", "else", "array (  )  ;", "for    ( Value   child    =    value . child ;    child    !  =    null ;    child    =    child . next )", "value ( child )  ;", "pop (  )  ;", "} else", "if    ( value . isBoolean (  )  )     {", "if    (  ( value . name )     !  =    null )", "name ( value . name )  ;", "value ( value . asBoolean (  )  )  ;", "} else", "if    ( value . isDouble (  )  )     {", "if    (  ( value . name )     !  =    null )", "name ( value . name )  ;", "value ( value . asDouble (  )  )  ;", "} else", "if    ( value . isLong (  )  )     {", "if    (  ( value . name )     !  =    null )", "name ( value . name )  ;", "value ( value . asLong (  )  )  ;", "} else", "if    ( value . isString (  )  )     {", "if    (  ( value . name )     !  =    null )", "name ( value . name )  ;", "value ( value . asString (  )  )  ;", "} else", "if    ( value . isNull (  )  )     {", "if    (  ( value . name )     !  =    null )", "name ( value . name )  ;", "value (  )  ;", "} else    {", "throw   new   IOException (  \" Unhandled   Value   type \"  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' D '  )  ;", "out . wDouble ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' D '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wDouble ( values [ i ]  )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' d '  )  ;", "out . wFloat ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' d '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wFloat ( values [ i ]  )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' l '  )  ;", "out . wInt ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' l '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wInt ( values [ i ]  )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )     {", "return   value (  )  ;", "} else", "if    ( object   instanceof   Number )     {", "Number   number    =     (  ( Number )     ( object )  )  ;", "if    ( object   instanceof   Byte )", "return   value ( number . byteValue (  )  )  ;", "if    ( object   instanceof   Short )", "return   value ( number . shortValue (  )  )  ;", "if    ( object   instanceof   Integer )", "return   value ( number . intValue (  )  )  ;", "if    ( object   instanceof   Long )", "return   value ( number . longValue (  )  )  ;", "if    ( object   instanceof   Float )", "return   value ( number . floatValue (  )  )  ;", "if    ( object   instanceof   Double )", "return   value ( number . doubleValue (  )  )  ;", "} else", "if    ( object   instanceof   Charac )     {", "return   value (  (  ( Charac )     ( object )  )  . charValue (  )  )  ;", "} else", "if    ( object   instanceof   CharSequence )     {", "return   value ( object . toString (  )  )  ;", "} else", "throw   new   IOException (  \" Unknown   object   type .  \"  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "byte [  ]    bytes    =    value . getBytes (  \" UTF -  8  \"  )  ;", "out . wByte (  ' S '  )  ;", "if    (  ( bytes . length )     <  =     ( Byte . MAX _ VALUE )  )     {", "out . wByte (  ' i '  )  ;", "out . wByte ( bytes . length )  ;", "} else", "if    (  ( bytes . length )     <  =     ( Short . MAX _ VALUE )  )     {", "out . wByte (  ' I '  )  ;", "out . wShort ( bytes . length )  ;", "} else    {", "out . wByte (  ' l '  )  ;", "out . wInt ( bytes . length )  ;", "}", "out . w ( bytes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' S '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "byte [  ]    bytes    =    values [ i ]  . getBytes (  \" UTF -  8  \"  )  ;", "if    (  ( bytes . length )     <  =     ( Byte . MAX _ VALUE )  )     {", "out . wByte (  ' i '  )  ;", "out . wByte ( bytes . length )  ;", "} else", "if    (  ( bytes . length )     <  =     ( Short . MAX _ VALUE )  )     {", "out . wByte (  ' I '  )  ;", "out . wShort ( bytes . length )  ;", "} else    {", "out . wByte (  ' l '  )  ;", "out . wInt ( bytes . length )  ;", "}", "out . w ( bytes )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' L '  )  ;", "out . wLong ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' L '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wLong ( values [ i ]  )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "checkName (  )  ;", "out . wByte (  ' I '  )  ;", "out . wShort ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "array (  )  ;", "out . wByte (  '  $  '  )  ;", "out . wByte (  ' I '  )  ;", "out . wByte (  '  #  '  )  ;", "value ( values . length )  ;", "for    ( int   i    =     0  ,    n    =    values . length ;    i    <    n ;    i +  +  )     {", "out . wShort ( values [ i ]  )  ;", "}", "pop ( true )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "com.badlogic.gdx.utils.UBJsonWriter"}, {"methodBody": ["METHOD_START", "{", "current . setAttribute ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "root    =    elements . pop (  )  ;", "current    =     (  ( elements . size )     >     0  )     ?    elements . peek (  )     :    null ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" lt \"  )  )", "return    \"  <  \"  ;", "if    ( name . equals (  \" gt \"  )  )", "return    \"  >  \"  ;", "if    ( name . equals (  \" amp \"  )  )", "return    \"  &  \"  ;", "if    ( name . equals (  \" apos \"  )  )", "return    \"  '  \"  ;", "if    ( name . equals (  \" quot \"  )  )", "return    \"  \\  \"  \"  ;", "if    ( name . startsWith (  \"  # x \"  )  )", "return   Character . toString (  (  ( char )     ( Integer . parseInt ( name . substring (  2  )  ,     1  6  )  )  )  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["entity"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     1  ,     0  ,     1  ,     1  ,     1  ,     2  ,     1  ,     3  ,     1  ,     4  ,     1  ,     5  ,     1  ,     6  ,     1  ,     7  ,     2  ,     0  ,     6  ,     2  ,     1  ,     4  ,     2  ,     2  ,     4     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_actions_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   short [  ]  {     0  ,     0  ,     4  ,     9  ,     1  4  ,     2  0  ,     2  6  ,     3  0  ,     3  5  ,     3  7  ,     3  9  ,     4  4  ,     4  8  ,     5  2  ,     5  4  ,     5  6  ,     6  0  ,     6  2  ,     6  7  ,     7  2  ,     7  8  ,     8  4  ,     8  8  ,     9  3  ,     9  5  ,     9  7  ,     1  0  2  ,     1  0  6  ,     1  1  0  ,     1  1  2  ,     1  1  6  ,     1  1  8  ,     1  2  0  ,     1  2  2  ,     1  2  4  ,     1  2  7     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_index_offsets_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     2  ,     0  ,     1  ,     2  ,     1  ,     1  ,     2  ,     3  ,     5  ,     6  ,     7  ,     5  ,     4  ,     9  ,     1  0  ,     1  ,     1  1  ,     9  ,     8  ,     1  3  ,     1  ,     1  4  ,     1  ,     1  3  ,     1  2  ,     1  5  ,     1  6  ,     1  5  ,     1  ,     1  6  ,     1  7  ,     1  8  ,     1  6  ,     1  ,     2  0  ,     1  9  ,     2  2  ,     2  1  ,     9  ,     1  0  ,     1  1  ,     9  ,     1  ,     2  3  ,     2  4  ,     2  3  ,     1  ,     2  5  ,     1  1  ,     2  5  ,     1  ,     2  0  ,     2  6  ,     2  2  ,     2  7  ,     2  9  ,     3  0  ,     2  9  ,     2  8  ,     3  2  ,     3  1  ,     3  0  ,     3  4  ,     1  ,     3  0  ,     3  3  ,     3  6  ,     3  7  ,     3  8  ,     3  6  ,     3  5  ,     4  0  ,     4  1  ,     1  ,     4  2  ,     4  0  ,     3  9  ,     4  4  ,     1  ,     4  5  ,     1  ,     4  4  ,     4  3  ,     4  6  ,     4  7  ,     4  6  ,     1  ,     4  7  ,     4  8  ,     4  9  ,     4  7  ,     1  ,     5  1  ,     5  0  ,     5  3  ,     5  2  ,     4  0  ,     4  1  ,     4  2  ,     4  0  ,     1  ,     5  4  ,     5  5  ,     5  4  ,     1  ,     5  6  ,     4  2  ,     5  6  ,     1  ,     5  7  ,     1  ,     5  7  ,     3  4  ,     5  7  ,     1  ,     1  ,     5  8  ,     5  9  ,     5  8  ,     5  1  ,     6  0  ,     5  3  ,     6  1  ,     6  2  ,     6  2  ,     1  ,     1  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_indicies_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     0  ,     4  ,     9  ,     1  4  ,     2  0  ,     2  6  ,     3  0  ,     3  5  ,     3  6  ,     3  7  ,     4  2  ,     4  6  ,     5  0  ,     5  1  ,     5  2  ,     5  6  ,     5  7  ,     6  2  ,     6  7  ,     7  3  ,     7  9  ,     8  3  ,     8  8  ,     8  9  ,     9  0  ,     9  5  ,     9  9  ,     1  0  3  ,     1  0  4  ,     1  0  8  ,     1  0  9  ,     1  1  0  ,     1  1  1  ,     1  1  2  ,     1  1  5     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_key_offsets_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     0  ,     0  ,     1  ,     1  ,     1  ,     0  ,     0  ,     1  ,     0  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     0  ,     0  ,     1  ,     1  ,     1  ,     0  ,     1  ,     0  ,     0  ,     0  ,     0  ,     1  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_range_lengths_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     2  ,     3  ,     3  ,     4  ,     4  ,     2  ,     3  ,     1  ,     1  ,     3  ,     2  ,     2  ,     1  ,     1  ,     2  ,     1  ,     3  ,     3  ,     4  ,     4  ,     2  ,     3  ,     1  ,     1  ,     3  ,     2  ,     2  ,     1  ,     2  ,     1  ,     1  ,     1  ,     1  ,     1  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_single_lengths_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     0  ,     0  ,     0  ,     1  ,     0  ,     3  ,     3  ,     2  0  ,     1  ,     0  ,     0  ,     9  ,     0  ,     1  1  ,     1  1  ,     0  ,     0  ,     0  ,     0  ,     1  ,     1  7  ,     0  ,     1  3  ,     5  ,     2  3  ,     0  ,     1  ,     0  ,     1  ,     0  ,     0  ,     0  ,     1  5  ,     1  ,     0  ,     0  ,     3  ,     3  ,     2  0  ,     1  ,     0  ,     0  ,     9  ,     0  ,     1  1  ,     1  1  ,     0  ,     0  ,     0  ,     0  ,     1  ,     1  7  ,     0  ,     1  3  ,     5  ,     2  3  ,     0  ,     0  ,     0  ,     7  ,     1  ,     0  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_trans_actions_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   char [  ]  {     3  2  ,     6  0  ,     9  ,     1  3  ,     3  2  ,     4  7  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     4  7  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     4  7  ,     6  1  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     4  7  ,     6  1  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     6  1  ,     9  ,     1  3  ,     3  2  ,     3  4  ,     3  9  ,     9  ,     1  3  ,     3  4  ,     3  4  ,     3  2  ,     4  7  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     6  2  ,     9  ,     1  3  ,     3  9  ,     3  9  ,     3  2  ,     6  0  ,     9  ,     1  3  ,     6  0  ,     3  2  ,     4  7  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     4  7  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     4  7  ,     6  1  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     4  7  ,     6  1  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     6  1  ,     9  ,     1  3  ,     3  2  ,     3  4  ,     3  9  ,     9  ,     1  3  ,     3  4  ,     3  4  ,     3  2  ,     4  7  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     6  2  ,     9  ,     1  3  ,     3  2  ,     6  2  ,     9  ,     1  3  ,     6  0  ,     3  2  ,     4  7  ,     9  ,     1  3  ,     6  2  ,     6  2  ,     3  9  ,     3  9  ,     3  2  ,     9  ,     1  3  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_trans_keys_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "return   new   byte [  ]  {     1  ,     0  ,     2  ,     3  ,     3  ,     4  ,     1  1  ,     3  4  ,     5  ,     4  ,     1  1  ,     3  4  ,     5  ,     6  ,     7  ,     6  ,     7  ,     8  ,     1  3  ,     9  ,     1  0  ,     9  ,     1  0  ,     1  2  ,     3  4  ,     1  2  ,     1  4  ,     1  4  ,     1  6  ,     1  5  ,     1  7  ,     1  6  ,     1  7  ,     1  8  ,     3  0  ,     1  8  ,     1  9  ,     2  6  ,     2  8  ,     2  0  ,     1  9  ,     2  6  ,     2  8  ,     2  0  ,     2  1  ,     2  2  ,     2  1  ,     2  2  ,     2  3  ,     3  2  ,     2  4  ,     2  5  ,     2  4  ,     2  5  ,     2  7  ,     2  8  ,     2  7  ,     2  9  ,     3  1  ,     3  5  ,     3  3  ,     3  3  ,     3  4     }  ;", "}", "METHOD_END"], "methodName": ["init__xml_trans_targs_0"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "XmlReader . Element   child    =    new   XmlReader . Element ( name ,    current )  ;", "XmlReader . Element   parent    =    current ;", "if    ( parent    !  =    null )", "parent . addChild ( child )  ;", "elements . add ( child )  ;", "current    =    child ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "int   cs ;", "int   p    =    offset ;", "int   pe    =    length ;", "int   s    =     0  ;", "String   attributeName    =    null ;", "boolean   hasBody    =    false ;", "{", "cs    =     . xml _ start ;", "}", "{", "int    _ klen ;", "int    _ trans    =     0  ;", "int    _ acts ;", "int    _ nacts ;", "int    _ keys ;", "int    _ goto _ targ    =     0  ;", "_ goto    :    while    ( true )     {", "switch    (  _ goto _ targ )     {", "case    0     :", "if    ( p    =  =    pe )     {", "_ goto _ targ    =     4  ;", "continue    _ goto ;", "}", "if    ( cs    =  =     0  )     {", "_ goto _ targ    =     5  ;", "continue    _ goto ;", "}", "case    1     :", "_ match    :    do    {", "_ keys    =     .  _ xml _ key _ offsets [ cs ]  ;", "_ trans    =     .  _ xml _ index _ offsets [ cs ]  ;", "_ klen    =     .  _ xml _ single _ lengths [ cs ]  ;", "if    (  _ klen    >     0  )     {", "int    _ lower    =     _ keys ;", "int    _ mid ;", "int    _ upper    =     (  _ keys    +     _ klen )     -     1  ;", "while    ( true )     {", "if    (  _ upper    <     _ lower )", "break ;", "_ mid    =     _ lower    +     (  (  _ upper    -     _ lower )     >  >     1  )  ;", "if    (  ( data [ p ]  )     <     (  .  _ xml _ trans _ keys [  _ mid ]  )  )", "_ upper    =     _ mid    -     1  ;", "else", "if    (  ( data [ p ]  )     >     (  .  _ xml _ trans _ keys [  _ mid ]  )  )", "_ lower    =     _ mid    +     1  ;", "else    {", "_ trans    +  =     _ mid    -     _ keys ;", "break    _ match ;", "}", "}", "_ keys    +  =     _ klen ;", "_ trans    +  =     _ klen ;", "}", "_ klen    =     .  _ xml _ range _ lengths [ cs ]  ;", "if    (  _ klen    >     0  )     {", "int    _ lower    =     _ keys ;", "int    _ mid ;", "int    _ upper    =     (  _ keys    +     (  _ klen    <  <     1  )  )     -     2  ;", "while    ( true )     {", "if    (  _ upper    <     _ lower )", "break ;", "_ mid    =     _ lower    +     (  (  (  _ upper    -     _ lower )     >  >     1  )     &     (  ~  1  )  )  ;", "if    (  ( data [ p ]  )     <     (  .  _ xml _ trans _ keys [  _ mid ]  )  )", "_ upper    =     _ mid    -     2  ;", "else", "if    (  ( data [ p ]  )     >     (  .  _ xml _ trans _ keys [  (  _ mid    +     1  )  ]  )  )", "_ lower    =     _ mid    +     2  ;", "else    {", "_ trans    +  =     (  _ mid    -     _ keys )     >  >     1  ;", "break    _ match ;", "}", "}", "_ trans    +  =     _ klen ;", "}", "}    while    ( false    )  ;", "_ trans    =     .  _ xml _ indicies [  _ trans ]  ;", "cs    =     .  _ xml _ trans _ targs [  _ trans ]  ;", "if    (  (  .  _ xml _ trans _ actions [  _ trans ]  )     !  =     0  )     {", "_ acts    =     .  _ xml _ trans _ actions [  _ trans ]  ;", "_ nacts    =     (  ( int )     (  .  _ xml _ actions [  (  _ acts +  +  )  ]  )  )  ;", "while    (  (  _ nacts -  -  )     >     0  )     {", "switch    (  .  _ xml _ actions [  (  _ acts +  +  )  ]  )     {", "case    0     :", "{", "s    =    p ;", "}", "break ;", "case    1     :", "{", "char   c    =    data [ s ]  ;", "if    (  ( c    =  =     '  ?  '  )     |  |     ( c    =  =     '  !  '  )  )     {", "if    (  (  (  (  (  (  (  ( data [  ( s    +     1  )  ]  )     =  =     '  [  '  )     &  &     (  ( data [  ( s    +     2  )  ]  )     =  =     ' C '  )  )     &  &     (  ( data [  ( s    +     3  )  ]  )     =  =     ' D '  )  )     &  &     (  ( data [  ( s    +     4  )  ]  )     =  =     ' A '  )  )     &  &     (  ( data [  ( s    +     5  )  ]  )     =  =     ' T '  )  )     &  &     (  ( data [  ( s    +     6  )  ]  )     =  =     ' A '  )  )     &  &     (  ( data [  ( s    +     7  )  ]  )     =  =     '  [  '  )  )     {", "s    +  =     8  ;", "p    =    s    +     2  ;", "while    (  (  (  ( data [  ( p    -     2  )  ]  )     !  =     '  ]  '  )     |  |     (  ( data [  ( p    -     1  )  ]  )     !  =     '  ]  '  )  )     |  |     (  ( data [ p ]  )     !  =     '  >  '  )  )", "p +  +  ;", "text ( new   String ( data ,    s ,     (  ( p    -    s )     -     2  )  )  )  ;", "} else", "if    (  (  ( c    =  =     '  !  '  )     &  &     (  ( data [  ( s    +     1  )  ]  )     =  =     '  -  '  )  )     &  &     (  ( data [  ( s    +     2  )  ]  )     =  =     '  -  '  )  )     {", "p    =    s    +     3  ;", "while    (  (  (  ( data [ p ]  )     !  =     '  -  '  )     |  |     (  ( data [  ( p    +     1  )  ]  )     !  =     '  -  '  )  )     |  |     (  ( data [  ( p    +     2  )  ]  )     !  =     '  >  '  )  )", "p +  +  ;", "p    +  =     2  ;", "} else", "while    (  ( data [ p ]  )     !  =     '  >  '  )", "p +  +  ;", "{", "cs    =     1  5  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "hasBody    =    true ;", "open ( new   String ( data ,    s ,     ( p    -    s )  )  )  ;", "}", "break ;", "case    2     :", "{", "hasBody    =    false ;", "close (  )  ;", "{", "cs    =     1  5  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "break ;", "case    3     :", "{", "close (  )  ;", "{", "cs    =     1  5  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "break ;", "case    4     :", "{", "if    ( hasBody )     {", "cs    =     1  5  ;", "_ goto _ targ    =     2  ;", "if    ( true )", "continue    _ goto ;", "}", "}", "break ;", "case    5     :", "{", "attributeName    =    new   String ( data ,    s ,     ( p    -    s )  )  ;", "}", "break ;", "case    6     :", "{", "attribute ( attributeName ,    new   String ( data ,    s ,     ( p    -    s )  )  )  ;", "}", "break ;", "case    7     :", "{", "int   end    =    p ;", "while    ( end    !  =    s )     {", "switch    ( data [  ( end    -     1  )  ]  )     {", "case    '     '     :", "case    '  \\ t '     :", "case    '  \\ n '     :", "case    '  \\ r '     :", "end -  -  ;", "continue ;", "}", "break ;", "}", "int   current    =    s ;", "boolean   entityFound    =    false ;", "while    ( current    !  =    end )     {", "if    (  ( data [  ( current +  +  )  ]  )     !  =     '  &  '  )", "continue ;", "int   entityStart    =    current ;", "while    ( current    !  =    end )     {", "if    (  ( data [  ( current +  +  )  ]  )     !  =     '  ;  '  )", "continue ;", "textBuffer . append ( data ,    s ,     (  ( entityStart    -    s )     -     1  )  )  ;", "String   name    =    new   String ( data ,    entityStart ,     (  ( current    -    entityStart )     -     1  )  )  ;", "String   value    =    entity ( name )  ;", "textBuffer . append (  ( value    !  =    null    ?    value    :    name )  )  ;", "s    =    current ;", "entityFound    =    true ;", "break ;", "}", "}", "if    ( entityFound )     {", "if    ( s    <    end )", "textBuffer . append ( data ,    s ,     ( end    -    s )  )  ;", "text ( textBuffer . toString (  )  )  ;", "textBuffer . setLength (  0  )  ;", "} else", "text ( new   String ( data ,    s ,     ( end    -    s )  )  )  ;", "}", "break ;", "}", "}", "}", "case    2     :", "if    ( cs    =  =     0  )     {", "_ goto _ targ    =     5  ;", "continue    _ goto ;", "}", "if    (  (  +  + p )     !  =    pe )     {", "_ goto _ targ    =     1  ;", "continue    _ goto ;", "}", "case    4     :", "case    5     :", "}", "break ;", "}", "}", "if    ( p    <    pe )     {", "int   lineNumber    =     1  ;", "for    ( int   i    =     0  ;    i    <    p ;    i +  +  )", "if    (  ( data [ i ]  )     =  =     '  \\ n '  )", "lineNumber +  +  ;", "throw   new   SerializationException (  (  (  (  \" Error   parsing   XML   on   line    \"     +    lineNumber )     +     \"    near :     \"  )     +     ( new   String ( data ,    p ,    Math . min (  3  2  ,     ( pe    -    p )  )  )  )  )  )  ;", "} else", "if    (  ( elements . size )     !  =     0  )     {", ". Element   element    =    elements . peek (  )  ;", "elements . clear (  )  ;", "throw   new   SerializationException (  (  \" Error   parsing   XML ,    unclosed   element :     \"     +     ( element . getName (  )  )  )  )  ;", "}", ". Element   root    =    this . root ;", "this . root    =    null ;", "return   root ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   parse ( file . r (  \" UTF -  8  \"  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SerializationException (  (  \" Error   parsing   file :     \"     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   parse ( new   InputStream ( input ,     \" UTF -  8  \"  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( input )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "char [  ]    data    =    new   char [  1  0  2  4  ]  ;", "int   offset    =     0  ;", "while    ( true )     {", "int   length    =    r . read ( data ,    offset ,     (  ( data . length )     -    offset )  )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "if    ( length    =  =     0  )     {", "char [  ]    newData    =    new   char [  ( data . length )     *     2  ]  ;", "System . arraycopy ( data ,     0  ,    newData ,     0  ,    data . length )  ;", "data    =    newData ;", "} else", "offset    +  =    length ;", "}", "return   parse ( data ,     0  ,    offset )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SerializationException ( ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( r )  ;", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    data    =    xml . toCharArray (  )  ;", "return   parse ( data ,     0  ,    data . length )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "String   existing    =    current . getText (  )  ;", "current . setText (  ( existing    !  =    null    ?    existing    +    text    :    text )  )  ;", "}", "METHOD_END"], "methodName": ["text"], "fileName": "com.badlogic.gdx.utils.XmlReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentElement )     =  =    null )", "throw   new   IllegalStateException (  )  ;", "w . write (  '     '  )  ;", "w . write ( name )  ;", "w . write (  \"  =  \\  \"  \"  )  ;", "w . write (  ( value    =  =    null    ?     \" null \"     :    value . toString (  )  )  )  ;", "w . write (  '  \"  '  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "while    (  ( stack . size )     !  =     0  )", "pop (  )  ;", "w . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( startElementContent (  )  )", "w . write (  '  \\ n '  )  ;", "indent (  )  ;", "w . write (  '  <  '  )  ;", "w . write ( name )  ;", "currentElement    =    name ;", "return   this ;", "}", "METHOD_END"], "methodName": ["element"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "return   element ( name )  . text ( text )  . pop (  )  ;", "}", "METHOD_END"], "methodName": ["element"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "int   count    =    indent ;", "if    (  ( currentElement )     !  =    null )", "count +  +  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )", "w . write (  '  \\ t '  )  ;", "}", "METHOD_END"], "methodName": ["indent"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentElement )     !  =    null )     {", "w . write (  \"  /  >  \\ n \"  )  ;", "currentElement    =    null ;", "} else    {", "indent    =    Math . max (  (  ( indent )     -     1  )  ,     0  )  ;", "if    ( indentNextClose )", "indent (  )  ;", "w . write (  \"  <  /  \"  )  ;", "w . write ( stack . pop (  )  )  ;", "w . write (  \"  >  \\ n \"  )  ;", "}", "indentNextClose    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentElement )     =  =    null )", "return   false ;", "( indent )  +  +  ;", "stack . add ( currentElement )  ;", "currentElement    =    null ;", "w . write (  \"  >  \"  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["startElementContent"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "startElementContent (  )  ;", "String   string    =     ( text    =  =    null )     ?     \" null \"     :    text . toString (  )  ;", "indentNextClose    =     ( string . length (  )  )     >     6  4  ;", "if    ( indentNextClose )     {", "w . write (  '  \\ n '  )  ;", "indent (  )  ;", "}", "w . write ( string )  ;", "if    ( indentNextClose )", "w . write (  '  \\ n '  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["text"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "startElementContent (  )  ;", "w . write ( cbuf ,    off ,    len )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.utils.XmlWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( executor . isShutdown (  )  )     {", "throw   new   GdxRuntimeException (  \" Cannot   run   tasks   on   an   executor   that   has   been   shutdown    ( disposed )  \"  )  ;", "}", "return   new   AsyncResult ( executor . submit ( new   Callable < T >  (  )     {", "@ Override", "public   T   call (  )    throws   Exception    {", "return   task . call (  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["submit"], "fileName": "com.badlogic.gdx.utils.async.AsyncExecutor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   future . get (  )  ;", "}    catch    ( InterruptedException   ex )     {", "return   null ;", "}    catch    ( ExeconException   ex )     {", "throw   new   GdxRuntimeException ( ex . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.async.AsyncResult"}, {"methodBody": ["METHOD_START", "{", "return   future . isDone (  )  ;", "}", "METHOD_END"], "methodName": ["isDone"], "fileName": "com.badlogic.gdx.utils.async.AsyncResult"}, {"methodBody": ["METHOD_START", "{", "Thread . yield (  )  ;", "}", "METHOD_END"], "methodName": ["yield"], "fileName": "com.badlogic.gdx.utils.async.ThreadUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  _ value )     ^     (  -  1  )  ;", "}", "METHOD_END"], "methodName": ["GetDigest"], "fileName": "com.badlogic.gdx.utils.compression.CRC"}, {"methodBody": ["METHOD_START", "{", "_ value    =     -  1  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.CRC"}, {"methodBody": ["METHOD_START", "{", "int   size    =    data . length ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )", "_ value    =     (  . Table [  (  (  (  _ value )     ^     ( data [ i ]  )  )     &     2  5  5  )  ]  )     ^     (  (  _ value )     >  >  >     8  )  ;", "}", "METHOD_END"], "methodName": ["Update"], "fileName": "com.badlogic.gdx.utils.compression.CRC"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )", "_ value    =     (  . Table [  (  (  (  _ value )     ^     ( data [  ( offset    +    i )  ]  )  )     &     2  5  5  )  ]  )     ^     (  (  _ value )     >  >  >     8  )  ;", "}", "METHOD_END"], "methodName": ["Update"], "fileName": "com.badlogic.gdx.utils.compression.CRC"}, {"methodBody": ["METHOD_START", "{", "_ value    =     ( CRC . Table [  (  (  (  _ value )     ^    b )     &     2  5  5  )  ]  )     ^     (  (  _ value )     >  >  >     8  )  ;", "}", "METHOD_END"], "methodName": ["UpdateByte"], "fileName": "com.badlogic.gdx.utils.compression.CRC"}, {"methodBody": ["METHOD_START", "{", "Lzma . CommandLine   params    =    new   Lzma . CommandLine (  )  ;", "boolean   eos    =    false ;", "if    ( params . Eos )", "eos    =    true ;", "Encoder   encoder    =    new   Encoder (  )  ;", "if    (  !  ( encoder . SetAlgorithm ( params . Algorithm )  )  )", "throw   new   RuntimeException (  \" Incorrect      mode \"  )  ;", "if    (  !  ( encoder . SetDictionarySize ( params . DictionarySize )  )  )", "throw   new   RuntimeException (  \" Incorrect   dictionary   size \"  )  ;", "if    (  !  ( encoder . SetNumFastBytes ( params . Fb )  )  )", "throw   new   RuntimeException (  \" Incorrect    - fb   value \"  )  ;", "if    (  !  ( encoder . SetMatchFinder ( params . MatchFinder )  )  )", "throw   new   RuntimeException (  \" Incorrect    - mf   value \"  )  ;", "if    (  !  ( encoder . SetLcLpPb ( params . Lc ,    params . Lp ,    params . Pb )  )  )", "throw   new   RuntimeException (  \" Incorrect    - lc   or    - lp   or    - pb   value \"  )  ;", "encoder . SetEndMarkerMode ( eos )  ;", "encoder . WriteCoderProperties ( out )  ;", "long   fileSize ;", "if    ( eos )     {", "fileSize    =     -  1  ;", "} else    {", "if    (  ( fileSize    =    in . available (  )  )     =  =     0  )     {", "fileSize    =     -  1  ;", "}", "}", "for    ( int   i    =     0  ;    i    <     8  ;    i +  +  )     {", "out . write (  (  (  ( int )     ( fileSize    >  >  >     (  8     *    i )  )  )     &     2  5  5  )  )  ;", "}", "encoder . Code ( in ,    out ,     (  -  1  )  ,     (  -  1  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["compress"], "fileName": "com.badlogic.gdx.utils.compression.Lzma"}, {"methodBody": ["METHOD_START", "{", "int   propertiesSize    =     5  ;", "byte [  ]    properties    =    new   byte [ propertiesSize ]  ;", "if    (  ( in . read ( properties ,     0  ,    propertiesSize )  )     !  =    propertiesSize )", "throw   new   RuntimeExcept (  \" input    . lzma   file   is   too   short \"  )  ;", "Decoder   decoder    =    new   Decoder (  )  ;", "if    (  !  ( decoder . SetDecoderProperties ( properties )  )  )", "throw   new   RuntimeExcept (  \" Incorrect   stream   properties \"  )  ;", "long   outSize    =     0  ;", "for    ( int   i    =     0  ;    i    <     8  ;    i +  +  )     {", "int   v    =    in . read (  )  ;", "if    ( v    <     0  )     {", "throw   new   RuntimeExcept (  \" Can ' t   read   stream   size \"  )  ;", "}", "outSize    |  =     (  ( long )     ( v )  )     <  <     (  8     *    i )  ;", "}", "if    (  !  ( decoder . Code ( in ,    out ,    outSize )  )  )     {", "throw   new   RuntimeExcept (  \" Error   in   data   stream \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["decompress"], "fileName": "com.badlogic.gdx.utils.compression.Lzma"}, {"methodBody": ["METHOD_START", "{", "if    ( historySize    >     (  ( BinTree . kMaxValForNormalize )     -     2  5  6  )  )", "return   false ;", "_ cutValue    =     1  6     +     ( matchMaxLen    >  >     1  )  ;", "int   windowReservSize    =     (  (  (  ( historySize    +    keepAddBufferBefore )     +    matchMaxLen )     +    keepAddBufferAfter )     /     2  )     +     2  5  6  ;", "super . Create (  ( historySize    +    keepAddBufferBefore )  ,     ( matchMaxLen    +    keepAddBufferAfter )  ,    windowReservSize )  ;", "_ matchMaxLen    =    matchMaxLen ;", "int   cyclicBufferSize    =    historySize    +     1  ;", "if    (  (  _ cyclicBufferSize )     !  =    cyclicBufferSize )", "_ son    =    new   int [  (  _ cyclicBufferSize    =    cyclicBufferSize )     *     2  ]  ;", "int   hs    =    BinTree . kBT 2 HashSize ;", "if    ( HASH _ ARRAY )     {", "hs    =    historySize    -     1  ;", "hs    |  =    hs    >  >     1  ;", "hs    |  =    hs    >  >     2  ;", "hs    |  =    hs    >  >     4  ;", "hs    |  =    hs    >  >     8  ;", "hs    >  >  =     1  ;", "hs    |  =     6  5  5  3  5  ;", "if    ( hs    >     (  1     <  <     2  4  )  )", "hs    >  >  =     1  ;", "_ hashMask    =    hs ;", "hs +  +  ;", "hs    +  =    kFixHashSize ;", "}", "if    ( hs    !  =     (  _ hashSizeSum )  )", "_ hash    =    new   int [  _ hashSizeSum    =    hs ]  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["Create"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "int   lenLimit ;", "if    (  (  (  _ pos )     +     (  _ matchMaxLen )  )     <  =     (  _ streamPos )  )", "lenLimit    =     _ matchMaxLen ;", "else    {", "lenLimit    =     (  _ streamPos )     -     (  _ pos )  ;", "if    ( lenLimit    <     ( kMinMatchCheck )  )     {", "MovePos (  )  ;", "return    0  ;", "}", "}", "int   offset    =     0  ;", "int   matchMinPos    =     (  (  _ pos )     >     (  _ cyclicBufferSize )  )     ?     (  _ pos )     -     (  _ cyclicBufferSize )     :     0  ;", "int   cur    =     (  _ bufferOffset )     +     (  _ pos )  ;", "int   maxLen    =     . kStartMaxLen ;", "int   hashValue ;", "int   hash 2 Value    =     0  ;", "int   hash 3 Value    =     0  ;", "if    ( HASH _ ARRAY )     {", "int   temp    =     (  . CrcTable [  (  (  _ bufferBase [ cur ]  )     &     2  5  5  )  ]  )     ^     (  (  _ bufferBase [  ( cur    +     1  )  ]  )     &     2  5  5  )  ;", "hash 2 Value    =    temp    &     (  (  . kHash 2 Size )     -     1  )  ;", "temp    ^  =     (  ( int )     (  (  _ bufferBase [  ( cur    +     2  )  ]  )     &     2  5  5  )  )     <  <     8  ;", "hash 3 Value    =    temp    &     (  (  . kHash 3 Size )     -     1  )  ;", "hashValue    =     ( temp    ^     (  (  . CrcTable [  (  (  _ bufferBase [  ( cur    +     3  )  ]  )     &     2  5  5  )  ]  )     <  <     5  )  )     &     (  _ hashMask )  ;", "} else", "hashValue    =     (  (  _ bufferBase [ cur ]  )     &     2  5  5  )     ^     (  (  ( int )     (  (  _ bufferBase [  ( cur    +     1  )  ]  )     &     2  5  5  )  )     <  <     8  )  ;", "int   curMatch    =     _ hash [  (  ( kFixHashSize )     +    hashValue )  ]  ;", "if    ( HASH _ ARRAY )     {", "int   curMatch 2     =     _ hash [ hash 2 Value ]  ;", "int   curMatch 3     =     _ hash [  (  (  . kHash 3 Offset )     +    hash 3 Value )  ]  ;", "_ hash [ hash 2 Value ]     =     _ pos ;", "_ hash [  (  (  . kHash 3 Offset )     +    hash 3 Value )  ]     =     _ pos ;", "if    ( curMatch 2     >    matchMinPos )", "if    (  (  _ bufferBase [  (  (  _ bufferOffset )     +    curMatch 2  )  ]  )     =  =     (  _ bufferBase [ cur ]  )  )     {", "distances [  ( offset +  +  )  ]     =    maxLen    =     2  ;", "distances [  ( offset +  +  )  ]     =     (  (  _ pos )     -    curMatch 2  )     -     1  ;", "}", "if    ( curMatch 3     >    matchMinPos )", "if    (  (  _ bufferBase [  (  (  _ bufferOffset )     +    curMatch 3  )  ]  )     =  =     (  _ bufferBase [ cur ]  )  )     {", "if    ( curMatch 3     =  =    curMatch 2  )", "offset    -  =     2  ;", "distances [  ( offset +  +  )  ]     =    maxLen    =     3  ;", "distances [  ( offset +  +  )  ]     =     (  (  _ pos )     -    curMatch 3  )     -     1  ;", "curMatch 2     =    curMatch 3  ;", "}", "if    (  ( offset    !  =     0  )     &  &     ( curMatch 2     =  =    curMatch )  )     {", "offset    -  =     2  ;", "maxLen    =     . kStartMaxLen ;", "}", "}", "_ hash [  (  ( kFixHashSize )     +    hashValue )  ]     =     _ pos ;", "int   ptr 0     =     (  (  _ cyclicBufferPos )     <  <     1  )     +     1  ;", "int   ptr 1     =     (  _ cyclicBufferPos )     <  <     1  ;", "int   len 0  ;", "int   len 1  ;", "len 0     =    len 1     =    kNumHashDirectBytes ;", "if    (  ( kNumHashDirectBytes )     !  =     0  )     {", "if    ( curMatch    >    matchMinPos )     {", "if    (  (  _ bufferBase [  (  (  (  _ bufferOffset )     +    curMatch )     +     ( kNumHashDirectBytes )  )  ]  )     !  =     (  _ bufferBase [  ( cur    +     ( kNumHashDirectBytes )  )  ]  )  )     {", "distances [  ( offset +  +  )  ]     =    maxLen    =    kNumHashDirectBytes ;", "distances [  ( offset +  +  )  ]     =     (  (  _ pos )     -    curMatch )     -     1  ;", "}", "}", "}", "int   count    =     _ cutValue ;", "while    ( true )     {", "if    (  ( curMatch    <  =    matchMinPos )     |  |     (  ( count -  -  )     =  =     0  )  )     {", "_ son [ ptr 0  ]     =     _ son [ ptr 1  ]     =     . kEmptyHashValue ;", "break ;", "}", "int   delta    =     (  _ pos )     -    curMatch ;", "int   cyclicPos    =     ( delta    <  =     (  _ cyclicBufferPos )     ?     (  _ cyclicBufferPos )     -    delta    :     (  (  _ cyclicBufferPos )     -    delta )     +     (  _ cyclicBufferSize )  )     <  <     1  ;", "int   pby 1     =     (  _ bufferOffset )     +    curMatch ;", "int   len    =    Math . min ( len 0  ,    len 1  )  ;", "if    (  (  _ bufferBase [  ( pby 1     +    len )  ]  )     =  =     (  _ bufferBase [  ( cur    +    len )  ]  )  )     {", "while    (  (  +  + len )     !  =    lenLimit )", "if    (  (  _ bufferBase [  ( pby 1     +    len )  ]  )     !  =     (  _ bufferBase [  ( cur    +    len )  ]  )  )", "break ;", "if    ( maxLen    <    len )     {", "distances [  ( offset +  +  )  ]     =    maxLen    =    len ;", "distances [  ( offset +  +  )  ]     =    delta    -     1  ;", "if    ( len    =  =    lenLimit )     {", "_ son [ ptr 1  ]     =     _ son [ cyclicPos ]  ;", "_ son [ ptr 0  ]     =     _ son [  ( cyclicPos    +     1  )  ]  ;", "break ;", "}", "}", "}", "if    (  (  (  _ bufferBase [  ( pby 1     +    len )  ]  )     &     2  5  5  )     <     (  (  _ bufferBase [  ( cur    +    len )  ]  )     &     2  5  5  )  )     {", "_ son [ ptr 1  ]     =    curMatch ;", "ptr 1     =    cyclicPos    +     1  ;", "curMatch    =     _ son [ ptr 1  ]  ;", "len 1     =    len ;", "} else    {", "_ son [ ptr 0  ]     =    curMatch ;", "ptr 0     =    cyclicPos ;", "curMatch    =     _ son [ ptr 0  ]  ;", "len 0     =    len ;", "}", "}", "MovePos (  )  ;", "return   offset ;", "}", "METHOD_END"], "methodName": ["GetMatches"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "super . Init (  )  ;", "for    ( int   i    =     0  ;    i    <     (  _ hashSizeSum )  ;    i +  +  )", "_ hash [ i ]     =     . kEmptyHashValue ;", "_ cyclicBufferPos    =     0  ;", "ReduceOffsets (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "if    (  (  +  +  (  _ cyclicBufferPos )  )     >  =     (  _ cyclicBufferSize )  )", "_ cyclicBufferPos    =     0  ;", "super . MovePos (  )  ;", "if    (  (  _ pos )     =  =     (  . kMaxValForNormalize )  )", "Normalize (  )  ;", "}", "METHOD_END"], "methodName": ["MovePos"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "int   subValue    =     (  _ pos )     -     (  _ cyclicBufferSize )  ;", "NormalizeLinks (  _ son ,     (  (  _ cyclicBufferSize )     *     2  )  ,    subValue )  ;", "NormalizeLinks (  _ hash ,     _ hashSizeSum ,    subValue )  ;", "ReduceOffsets ( subValue )  ;", "}", "METHOD_END"], "methodName": ["Normalize"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    numItems ;    i +  +  )     {", "int   value    =    items [ i ]  ;", "if    ( value    <  =    subValue )", "value    =     . kEmptyHashValue ;", "else", "value    -  =    subValue ;", "items [ i ]     =    value ;", "}", "}", "METHOD_END"], "methodName": ["NormalizeLinks"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "_ cutValue    =    cutValue ;", "}", "METHOD_END"], "methodName": ["SetCutValue"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "HASH _ ARRAY    =    numHashBytes    >     2  ;", "if    ( HASH _ ARRAY )     {", "kNumHashDirectBytes    =     0  ;", "kMinMatchCheck    =     4  ;", "kFixHashSize    =     (  . kHash 2 Size )     +     (  . kHash 3 Size )  ;", "} else    {", "kNumHashDirectBytes    =     2  ;", "kMinMatchCheck    =     2     +     1  ;", "kFixHashSize    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["SetType"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "do    {", "int   lenLimit ;", "if    (  (  (  _ pos )     +     (  _ matchMaxLen )  )     <  =     (  _ streamPos )  )", "lenLimit    =     _ matchMaxLen ;", "else    {", "lenLimit    =     (  _ streamPos )     -     (  _ pos )  ;", "if    ( lenLimit    <     ( kMinMatchCheck )  )     {", "MovePos (  )  ;", "continue ;", "}", "}", "int   matchMinPos    =     (  (  _ pos )     >     (  _ cyclicBufferSize )  )     ?     (  _ pos )     -     (  _ cyclicBufferSize )     :     0  ;", "int   cur    =     (  _ bufferOffset )     +     (  _ pos )  ;", "int   hashValue ;", "if    ( HASH _ ARRAY )     {", "int   temp    =     (  . CrcTable [  (  (  _ bufferBase [ cur ]  )     &     2  5  5  )  ]  )     ^     (  (  _ bufferBase [  ( cur    +     1  )  ]  )     &     2  5  5  )  ;", "int   hash 2 Value    =    temp    &     (  (  . kHash 2 Size )     -     1  )  ;", "_ hash [ hash 2 Value ]     =     _ pos ;", "temp    ^  =     (  ( int )     (  (  _ bufferBase [  ( cur    +     2  )  ]  )     &     2  5  5  )  )     <  <     8  ;", "int   hash 3 Value    =    temp    &     (  (  . kHash 3 Size )     -     1  )  ;", "_ hash [  (  (  . kHash 3 Offset )     +    hash 3 Value )  ]     =     _ pos ;", "hashValue    =     ( temp    ^     (  (  . CrcTable [  (  (  _ bufferBase [  ( cur    +     3  )  ]  )     &     2  5  5  )  ]  )     <  <     5  )  )     &     (  _ hashMask )  ;", "} else", "hashValue    =     (  (  _ bufferBase [ cur ]  )     &     2  5  5  )     ^     (  (  ( int )     (  (  _ bufferBase [  ( cur    +     1  )  ]  )     &     2  5  5  )  )     <  <     8  )  ;", "int   curMatch    =     _ hash [  (  ( kFixHashSize )     +    hashValue )  ]  ;", "_ hash [  (  ( kFixHashSize )     +    hashValue )  ]     =     _ pos ;", "int   ptr 0     =     (  (  _ cyclicBufferPos )     <  <     1  )     +     1  ;", "int   ptr 1     =     (  _ cyclicBufferPos )     <  <     1  ;", "int   len 0  ;", "int   len 1  ;", "len 0     =    len 1     =    kNumHashDirectBytes ;", "int   count    =     _ cutValue ;", "while    ( true )     {", "if    (  ( curMatch    <  =    matchMinPos )     |  |     (  ( count -  -  )     =  =     0  )  )     {", "_ son [ ptr 0  ]     =     _ son [ ptr 1  ]     =     . kEmptyHashValue ;", "break ;", "}", "int   delta    =     (  _ pos )     -    curMatch ;", "int   cyclicPos    =     ( delta    <  =     (  _ cyclicBufferPos )     ?     (  _ cyclicBufferPos )     -    delta    :     (  (  _ cyclicBufferPos )     -    delta )     +     (  _ cyclicBufferSize )  )     <  <     1  ;", "int   pby 1     =     (  _ bufferOffset )     +    curMatch ;", "int   len    =    Math . min ( len 0  ,    len 1  )  ;", "if    (  (  _ bufferBase [  ( pby 1     +    len )  ]  )     =  =     (  _ bufferBase [  ( cur    +    len )  ]  )  )     {", "while    (  (  +  + len )     !  =    lenLimit )", "if    (  (  _ bufferBase [  ( pby 1     +    len )  ]  )     !  =     (  _ bufferBase [  ( cur    +    len )  ]  )  )", "break ;", "if    ( len    =  =    lenLimit )     {", "_ son [ ptr 1  ]     =     _ son [ cyclicPos ]  ;", "_ son [ ptr 0  ]     =     _ son [  ( cyclicPos    +     1  )  ]  ;", "break ;", "}", "}", "if    (  (  (  _ bufferBase [  ( pby 1     +    len )  ]  )     &     2  5  5  )     <     (  (  _ bufferBase [  ( cur    +    len )  ]  )     &     2  5  5  )  )     {", "_ son [ ptr 1  ]     =    curMatch ;", "ptr 1     =    cyclicPos    +     1  ;", "curMatch    =     _ son [ ptr 1  ]  ;", "len 1     =    len ;", "} else    {", "_ son [ ptr 0  ]     =    curMatch ;", "ptr 0     =    cyclicPos ;", "curMatch    =     _ son [ ptr 0  ]  ;", "len 0     =    len ;", "}", "}", "MovePos (  )  ;", "}    while    (  (  -  - num )     !  =     0     )  ;", "}", "METHOD_END"], "methodName": ["Skip"], "fileName": "com.badlogic.gdx.utils.compression.lz.BinTree"}, {"methodBody": ["METHOD_START", "{", "_ keepSizeBefore    =    keepSizeBefore ;", "_ keepSizeAfter    =    keepSizeAfter ;", "int   blockSize    =     ( keepSizeBefore    +    keepSizeAfter )     +    keepSizeReserv ;", "if    (  (  (  _ bufferBase )     =  =    null )     |  |     (  (  _ blockSize )     !  =    blockSize )  )     {", "Free (  )  ;", "_ blockSize    =    blockSize ;", "_ bufferBase    =    new   byte [  _ blockSize ]  ;", "}", "_ pointerToLastSafePosit    =     (  _ blockSize )     -    keepSizeAfter ;", "}", "METHOD_END"], "methodName": ["Create"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "_ bufferBase    =    null ;", "}", "METHOD_END"], "methodName": ["Free"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "return    _ bufferBase [  (  (  (  _ bufferOffset )     +     (  _ pos )  )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["GetIndexByte"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "if    (  _ streamEndWasReached )", "if    (  (  (  (  _ pos )     +    ex )     +    limit )     >     (  _ streamPos )  )", "limit    =     (  _ streamPos )     -     (  (  _ pos )     +    ex )  ;", "distance +  +  ;", "int   pby    =     (  (  _ bufferOffset )     +     (  _ pos )  )     +    ex ;", "int   i ;", "for    ( i    =     0  ;     ( i    <    limit )     &  &     (  (  _ bufferBase [  ( pby    +    i )  ]  )     =  =     (  _ bufferBase [  (  ( pby    +    i )     -    distance )  ]  )  )  ;    i +  +  )  ;", "return   i ;", "}", "METHOD_END"], "methodName": ["GetMatchLen"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "return    (  _ streamPos )     -     (  _ pos )  ;", "}", "METHOD_END"], "methodName": ["GetNumAvailableBytes"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "_ bufferOffset    =     0  ;", "_ pos    =     0  ;", "_ stamPos    =     0  ;", "_ stamEndWasReached    =    false ;", "ReadBlock (  )  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "int   offset    =     (  (  _ bufferOffset )     +     (  _ pos )  )     -     (  _ keepSizeBefore )  ;", "if    ( offset    >     0  )", "offset -  -  ;", "int   numBytes    =     (  (  _ bufferOffset )     +     (  _ streamPos )  )     -    offset ;", "for    ( int   i    =     0  ;    i    <    numBytes ;    i +  +  )", "_ bufferBase [ i ]     =     _ bufferBase [  ( offset    +    i )  ]  ;", "_ bufferOffset    -  =    offset ;", "}", "METHOD_END"], "methodName": ["MoveBlock"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "(  _ pos )  +  +  ;", "if    (  (  _ pos )     >     (  _ posLimit )  )     {", "int   pointerToPost    =     (  _ bufferOffset )     +     (  _ pos )  ;", "if    ( pointerToPost    >     (  _ pointerToLastSafePosit )  )", "MoveBlock (  )  ;", "ReadBlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["MovePos"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "if    (  _ streamEndWasReached )", "return ;", "while    ( true )     {", "int   size    =     (  (  0     -     (  _ bufferOffset )  )     +     (  _ blockSize )  )     -     (  _ streamPos )  ;", "if    ( size    =  =     0  )", "return ;", "int   numReadBytes    =     _ stream . read (  _ bufferBase ,     (  (  _ bufferOffset )     +     (  _ streamPos )  )  ,    size )  ;", "if    ( numReadBytes    =  =     (  -  1  )  )     {", "_ posLimit    =     _ streamPos ;", "int   pointerToPost    =     (  _ bufferOffset )     +     (  _ posLimit )  ;", "if    ( pointerToPost    >     (  _ pointerToLastSafePosit )  )", "_ posLimit    =     (  _ pointerToLastSafePosit )     -     (  _ bufferOffset )  ;", "_ streamEndWasReached    =    true ;", "return ;", "}", "_ streamPos    +  =    numReadBytes ;", "if    (  (  _ streamPos )     >  =     (  (  _ pos )     +     (  _ keepSizeAfter )  )  )", "_ posLimit    =     (  _ streamPos )     -     (  _ keepSizeAfter )  ;", "}", "}", "METHOD_END"], "methodName": ["ReadBlock"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "_ bufferOffset    +  =    subValue ;", "_ posLimit    -  =    subValue ;", "_ pos    -  =    subValue ;", "_ stamPos    -  =    subValue ;", "}", "METHOD_END"], "methodName": ["ReduceOffsets"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "_ stream    =    null ;", "}", "METHOD_END"], "methodName": ["ReleaseStream"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "_ stream    =    stream ;", "}", "METHOD_END"], "methodName": ["SetStream"], "fileName": "com.badlogic.gdx.utils.compression.lz.InWindow"}, {"methodBody": ["METHOD_START", "{", "int   pos    =     (  (  _ pos )     -    distance )     -     1  ;", "if    ( pos    <     0  )", "pos    +  =     _ wSize ;", "for    (  ;    len    !  =     0  ;    len -  -  )     {", "if    ( pos    >  =     (  _ wSize )  )", "pos    =     0  ;", "_ buffer [  (  (  _ pos )  +  +  )  ]     =     _ buffer [  ( pos +  +  )  ]  ;", "if    (  (  _ pos )     >  =     (  _ wSize )  )", "Flush (  )  ;", "}", "}", "METHOD_END"], "methodName": ["CopyBlock"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  _ buffer )     =  =    null )     |  |     (  (  _ windowSize )     !  =    windowSize )  )", "_ buffer    =    new   byte [ windowSize ]  ;", "_ windowSize    =    windowSize ;", "_ pos    =     0  ;", "_ streamPos    =     0  ;", "}", "METHOD_END"], "methodName": ["Create"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "int   size    =     (  _ pos )     -     (  _ streamPos )  ;", "if    ( size    =  =     0  )", "return ;", "_ stream . write (  _ buffer ,     _ streamPos ,    size )  ;", "if    (  (  _ pos )     >  =     (  _ wSize )  )", "_ pos    =     0  ;", "_ streamPos    =     _ pos ;", "}", "METHOD_END"], "methodName": ["Flush"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "int   pos    =     (  (  _ pos )     -    distance )     -     1  ;", "if    ( pos    <     0  )", "pos    +  =     _ wSize ;", "return    _ buffer [ pos ]  ;", "}", "METHOD_END"], "methodName": ["GetByte"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "if    (  ! solid )     {", "_ stamPos    =     0  ;", "_ pos    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "_ buffer [  (  (  _ pos )  +  +  )  ]     =    b ;", "if    (  (  _ pos )     >  =     (  _ wSize )  )", "Flush (  )  ;", "}", "METHOD_END"], "methodName": ["PutByte"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "Flush (  )  ;", "_ stam    =    null ;", "}", "METHOD_END"], "methodName": ["ReleaseStream"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "ReleaseStream (  )  ;", "_ stream    =    stream ;", "}", "METHOD_END"], "methodName": ["SetStream"], "fileName": "com.badlogic.gdx.utils.compression.lz.OutWindow"}, {"methodBody": ["METHOD_START", "{", "len    -  =    Base . kMatchMinLen ;", "if    ( len    <     ( Base . kNumLenToPosStates )  )", "return   len ;", "return    (  ( int )     (  ( Base . kNumLenToPosStates )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["GetLenToPosState"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Base"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["StateInit"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Base"}, {"methodBody": ["METHOD_START", "{", "return   index    <     7  ;", "}", "METHOD_END"], "methodName": ["StateIsCharState"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Base"}, {"methodBody": ["METHOD_START", "{", "if    ( index    <     4  )", "turn    0  ;", "if    ( index    <     1  0  )", "turn   index    -     3  ;", "turn   index    -     6  ;", "}", "METHOD_END"], "methodName": ["StateUpdateChar"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Base"}, {"methodBody": ["METHOD_START", "{", "return   index    <     7     ?     7     :     1  0  ;", "}", "METHOD_END"], "methodName": ["StateUpdateMatch"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Base"}, {"methodBody": ["METHOD_START", "{", "return   index    <     7     ?     8     :     1  1  ;", "}", "METHOD_END"], "methodName": ["StateUpdateRep"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Base"}, {"methodBody": ["METHOD_START", "{", "return   index    <     7     ?     9     :     1  1  ;", "}", "METHOD_END"], "methodName": ["StateUpdateShortRep"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Base"}, {"methodBody": ["METHOD_START", "{", "m _ Rang . SetStream ( inStream )  ;", "m _ OutWindow . SetStream ( outStream )  ;", "Init (  )  ;", "int   state    =    Base . StateInit (  )  ;", "int   rep 0     =     0  ;", "int   rep 1     =     0  ;", "int   rep 2     =     0  ;", "int   rep 3     =     0  ;", "long   nowPos 6  4     =     0  ;", "byte   prevByte    =     0  ;", "while    (  ( outSize    <     0  )     |  |     ( nowPos 6  4     <    outSize )  )     {", "int   posState    =     (  ( int )     ( nowPos 6  4  )  )     &     ( m _ PosStateMask )  ;", "if    (  ( m _ Rang . DecodeBit ( m _ IsMatcs ,     (  ( state    <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  )  )     =  =     0  )     {", ". Litera 2    decoder 2     =    m _ Litera . Ge (  (  ( int )     ( nowPos 6  4  )  )  ,    prevByte )  ;", "if    (  !  ( Base . StateIsCharState ( state )  )  )", "prevByte    =    decoder 2  . DecodeWithMatchByte ( m _ Rang ,    m _ OutWindow . GetByte ( rep 0  )  )  ;", "else", "prevByte    =    decoder 2  . DecodeNormal ( m _ Rang )  ;", "m _ OutWindow . PutByte ( prevByte )  ;", "state    =    Base . StateUpdateChar ( state )  ;", "nowPos 6  4  +  +  ;", "} else    {", "int   len ;", "if    (  ( m _ Rang . DecodeBit ( m _ IsRes ,    state )  )     =  =     1  )     {", "len    =     0  ;", "if    (  ( m _ Rang . DecodeBit ( m _ IsRepGs ,    state )  )     =  =     0  )     {", "if    (  ( m _ Rang . DecodeBit ( m _ IsRep 0 Lons ,     (  ( state    <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  )  )     =  =     0  )     {", "state    =    Base . StateUpdateShortRep ( state )  ;", "len    =     1  ;", "}", "} else    {", "int   distance ;", "if    (  ( m _ Rang . DecodeBit ( m _ IsRepGs ,    state )  )     =  =     0  )", "distance    =    rep 1  ;", "else    {", "if    (  ( m _ Rang . DecodeBit ( m _ IsRepGs ,    state )  )     =  =     0  )", "distance    =    rep 2  ;", "else    {", "distance    =    rep 3  ;", "rep 3     =    rep 2  ;", "}", "rep 2     =    rep 1  ;", "}", "rep 1     =    rep 0  ;", "rep 0     =    distance ;", "}", "if    ( len    =  =     0  )     {", "len    =     ( m _ RepLe . Decode ( m _ Rang ,    posState )  )     +     ( Base . kMatchMinLen )  ;", "state    =    Base . StateUpdateRep ( state )  ;", "}", "} else    {", "rep 3     =    rep 2  ;", "rep 2     =    rep 1  ;", "rep 1     =    rep 0  ;", "len    =     ( Base . kMatchMinLen )     +     ( m _ Le . Decode ( m _ Rang ,    posState )  )  ;", "state    =    Base . StateUpdateMatch ( state )  ;", "int   posSlot    =    m _ PosSlo [ Base . GetLenToPosState ( len )  ]  . Decode ( m _ Rang )  ;", "if    ( posSlot    >  =     ( Base . kStartPosModelIndex )  )     {", "int   numDirectBits    =     ( posSlot    >  >     1  )     -     1  ;", "rep 0     =     (  2     |     ( posSlot    &     1  )  )     <  <    numDirectBits ;", "if    ( posSlot    <     ( Base . kEndPosModelIndex )  )", "rep 0     +  =    BitTre . ReverseDecode ( m _ Pos ,     (  ( rep 0     -    posSlot )     -     1  )  ,    m _ Rang ,    numDirectBits )  ;", "else    {", "rep 0     +  =     ( m _ Rang . DecodeDirectBits (  ( numDirectBits    -     ( Base . kNumAlignBits )  )  )  )     <  <     ( Base . kNumAlignBits )  ;", "rep 0     +  =    m _ PosAlig . ReverseDecode ( m _ Rang )  ;", "if    ( rep 0     <     0  )     {", "if    ( rep 0     =  =     (  -  1  )  )", "break ;", "return   false ;", "}", "}", "} else", "rep 0     =    posSlot ;", "}", "if    (  ( rep 0     >  =    nowPos 6  4  )     |  |     ( rep 0     >  =     ( m _ DictionarySizeCheck )  )  )     {", "return   false ;", "}", "m _ OutWindow . CopyBlock ( rep 0  ,    len )  ;", "nowPos 6  4     +  =    len ;", "prevByte    =    m _ OutWindow . GetByte (  0  )  ;", "}", "}", "m _ OutWindow . Flush (  )  ;", "m _ OutWindow . ReleaseStream (  )  ;", "m _ Rang . ReleaseStream (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["Code"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Decoder"}, {"methodBody": ["METHOD_START", "{", "m _ OutWindow . Init ( false )  ;", "rangecoder . Decoder . InitBitModels ( m _ IsMatchDecoders )  ;", "rangecoder . Decoder . InitBitModels ( m _ IsRep 0 LongDecoders )  ;", "rangecoder . Decoder . InitBitModels ( m _ IsRepDecoders )  ;", "rangecoder . Decoder . InitBitModels ( m _ IsRepG 0 Decoders )  ;", "rangecoder . Decoder . InitBitModels ( m _ IsRepG 1 Decoders )  ;", "rangecoder . Decoder . InitBitModels ( m _ IsRepG 2 Decoders )  ;", "rangecoder . Decoder . InitBitModels ( m _ PosDecoders )  ;", "m _ LiteralDecoder . Init (  )  ;", "int   i ;", "for    ( i    =     0  ;    i    <     ( Base . kNumLenToPosStates )  ;    i +  +  )", "m _ PosSlotDecoder [ i ]  . Init (  )  ;", "m _ LenDecoder . Init (  )  ;", "m _ RepLenDecoder . Init (  )  ;", "m _ PosAlignDecoder . Init (  )  ;", "m _ RangeDecoder . Init (  )  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Decoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( properties . length )     <     5  )", "return   false ;", "int   val    =     ( properties [  0  ]  )     &     2  5  5  ;", "int   lc    =    val    %     9  ;", "int   remain    =    val    /     9  ;", "int   lp    =    remain    %     5  ;", "int   pb    =    remain    /     5  ;", "int   dictionarySize    =     0  ;", "for    ( int   i    =     0  ;    i    <     4  ;    i +  +  )", "dictionarySize    +  =     (  (  ( int )     ( properties [  (  1     +    i )  ]  )  )     &     2  5  5  )     <  <     ( i    *     8  )  ;", "if    (  !  ( SetLcLpPb ( lc ,    lp ,    pb )  )  )", "return   false ;", "return   SetDictionarySize ( dictionarySize )  ;", "}", "METHOD_END"], "methodName": ["SetDecoderProperties"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Decoder"}, {"methodBody": ["METHOD_START", "{", "if    ( dictionarySize    <     0  )", "return   false ;", "if    (  ( m _ DictionarySize )     !  =    dictionarySize )     {", "m _ DictionarySize    =    dictionarySize ;", "m _ DictionarySizeCheck    =    Math . max ( m _ DictionarySize ,     1  )  ;", "m _ OutWindow . Create ( Math . max ( m _ DictionarySizeCheck ,     (  1     <  <     1  2  )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["SetDictionarySize"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Decoder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( lc    >     ( Base . kNumLitContextBitsMax )  )     |  |     ( lp    >     4  )  )     |  |     ( pb    >     ( Base . kNumPosStatesBitsMax )  )  )", "return   false ;", "m _ Literal . Create ( lp ,    lc )  ;", "int   numPosStates    =     1     <  <    pb ;", "m _ Len . Create ( numPosStates )  ;", "m _ RepLen . Create ( numPosStates )  ;", "m _ PosStateMask    =    numPosStates    -     1  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["SetLcLpPb"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Decoder"}, {"methodBody": ["METHOD_START", "{", "_ optimumEndIndex    =    cur ;", "int   posMem    =     _ optimum [ cur ]  . PosPrev ;", "int   backMem    =     _ optimum [ cur ]  . BackPrev ;", "do    {", "if    (  _ optimum [ cur ]  . Prev 1 IsChar )     {", "_ optimum [ posMem ]  . MakeAsChar (  )  ;", "_ optimum [ posMem ]  . PosPrev    =    posMem    -     1  ;", "if    (  _ optimum [ cur ]  . Prev 2  )     {", "_ optimum [  ( posMem    -     1  )  ]  . Prev 1 IsChar    =    false ;", "_ optimum [  ( posMem    -     1  )  ]  . PosPrev    =     _ optimum [ cur ]  . PosPrev 2  ;", "_ optimum [  ( posMem    -     1  )  ]  . BackPrev    =     _ optimum [ cur ]  . BackPrev 2  ;", "}", "}", "int   posPrev    =    posMem ;", "int   backCur    =    backMem ;", "backMem    =     _ optimum [ posPrev ]  . BackPrev ;", "posMem    =     _ optimum [ posPrev ]  . PosPrev ;", "_ optimum [ posPrev ]  . BackPrev    =    backCur ;", "_ optimum [ posPrev ]  . PosPrev    =    cur ;", "cur    =    posPrev ;", "}    while    ( cur    >     0     )  ;", "backRes    =     _ optimum [  0  ]  . BackPrev ;", "_ optimumCurrentIndex    =     _ optimum [  0  ]  . PosPrev ;", "return    _ optimumCurrentIndex ;", "}", "METHOD_END"], "methodName": ["Backward"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ state    =    Base . StateInit (  )  ;", "_ viousByte    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( Base . kNumRepDistances )  ;    i +  +  )", "_ repDistances [ i ]     =     0  ;", "}", "METHOD_END"], "methodName": ["BaseInit"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   kDif    =     7  ;", "turn    ( smallDist    <     (  1     <  <     (  3  2     -    kDif )  )  )     &  &     ( bigDist    >  =     ( smallDist    <  <    kDif )  )  ;", "}", "METHOD_END"], "methodName": ["ChangePair"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ needReleaseMFStream    =    false ;", "try    {", "SetStreams ( inStream ,    outStream ,    inSize ,    outSize )  ;", "while    ( true )     {", "CodeOneBlock ( processedInSize ,    processedOutSize ,    finished )  ;", "if    ( finished [  0  ]  )", "return ;", "if    ( prog    !  =    null )     {", "prog . SetProg ( processedInSize [  0  ]  ,    processedOutSize [  0  ]  )  ;", "}", "}", "}    finally    {", "ReleaseStreams (  )  ;", "}", "}", "METHOD_END"], "methodName": ["Code"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "inSize [  0  ]     =     0  ;", "outSize [  0  ]     =     0  ;", "finished [  0  ]     =    true ;", "if    (  (  _ inStream )     !  =    null )     {", "_ matchFinder . SetStream (  _ inStream )  ;", "_ matchFinder . Init (  )  ;", "_ needReleaseMFStream    =    true ;", "_ inStream    =    null ;", "}", "if    (  _ finished )", "return ;", "_ finished    =    true ;", "long   progressPosValuePrev    =    nowPos 6  4  ;", "if    (  ( nowPos 6  4  )     =  =     0  )     {", "if    (  (  _ matchFinder . GetNumAvailableBytes (  )  )     =  =     0  )     {", "Flush (  (  ( int )     ( nowPos 6  4  )  )  )  ;", "return ;", "}", "ReadMatchDistances (  )  ;", "int   posState    =     (  ( int )     ( nowPos 6  4  )  )     &     (  _ posStateMask )  ;", "_ rang . Encode (  _ isMatch ,     (  (  (  _ state )     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ,     0  )  ;", "_ state    =    Base . StateUpdateChar (  _ state )  ;", "byte   curByte    =     _ matchFinder . GetIndexByte (  (  0     -     (  _ additionalOffset )  )  )  ;", "_ litera . GetSubCoder (  (  ( int )     ( nowPos 6  4  )  )  ,     _ previousByte )  . Encode (  _ rang ,    curByte )  ;", "_ previousByte    =    curByte ;", "(  _ additionalOffset )  -  -  ;", "( nowPos 6  4  )  +  +  ;", "}", "if    (  (  _ matchFinder . GetNumAvailableBytes (  )  )     =  =     0  )     {", "Flush (  (  ( int )     ( nowPos 6  4  )  )  )  ;", "return ;", "}", "while    ( true )     {", "int   len    =    GetOptimum (  (  ( int )     ( nowPos 6  4  )  )  )  ;", "int   pos    =    backRes ;", "int   posState    =     (  ( int )     ( nowPos 6  4  )  )     &     (  _ posStateMask )  ;", "int   complexState    =     (  (  _ state )     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState ;", "if    (  ( len    =  =     1  )     &  &     ( pos    =  =     (  -  1  )  )  )     {", "_ rang . Encode (  _ isMatch ,    complexState ,     0  )  ;", "byte   curByte    =     _ matchFinder . GetIndexByte (  (  ( int )     (  0     -     (  _ additionalOffset )  )  )  )  ;", ". Litera 2    subCoder    =     _ litera . GetSubCoder (  (  ( int )     ( nowPos 6  4  )  )  ,     _ previousByte )  ;", "if    (  !  ( Base . StateIsCharState (  _ state )  )  )     {", "byte   matchByte    =     _ matchFinder . GetIndexByte (  (  ( int )     (  (  (  0     -     (  _ repDistances [  0  ]  )  )     -     1  )     -     (  _ additionalOffset )  )  )  )  ;", "subCoder . EncodeMatched (  _ rang ,    matchByte ,    curByte )  ;", "} else", "subCoder . Encode (  _ rang ,    curByte )  ;", "_ previousByte    =    curByte ;", "_ state    =    Base . StateUpdateChar (  _ state )  ;", "} else    {", "_ rang . Encode (  _ isMatch ,    complexState ,     1  )  ;", "if    ( pos    <     ( Base . kNumRepDistances )  )     {", "_ rang . Encode (  _ isRep ,     _ state ,     1  )  ;", "if    ( pos    =  =     0  )     {", "_ rang . Encode (  _ isRepG 0  ,     _ state ,     0  )  ;", "if    ( len    =  =     1  )", "_ rang . Encode (  _ isRep 0 Long ,    complexState ,     0  )  ;", "else", "_ rang . Encode (  _ isRep 0 Long ,    complexState ,     1  )  ;", "} else    {", "_ rang . Encode (  _ isRepG 0  ,     _ state ,     1  )  ;", "if    ( pos    =  =     1  )", "_ rang . Encode (  _ isRepG 1  ,     _ state ,     0  )  ;", "else    {", "_ rang . Encode (  _ isRepG 1  ,     _ state ,     1  )  ;", "_ rang . Encode (  _ isRepG 2  ,     _ state ,     ( pos    -     2  )  )  ;", "}", "}", "if    ( len    =  =     1  )", "_ state    =    Base . StateUpdateShortRep (  _ state )  ;", "else    {", "_ repMatchLe . Encode (  _ rang ,     ( len    -     ( Base . kMatchMinLen )  )  ,    posState )  ;", "_ state    =    Base . StateUpdateRep (  _ state )  ;", "}", "int   distance    =     _ repDistances [ pos ]  ;", "if    ( pos    !  =     0  )     {", "for    ( int   i    =    pos ;    i    >  =     1  ;    i -  -  )", "_ repDistances [ i ]     =     _ repDistances [  ( i    -     1  )  ]  ;", "_ repDistances [  0  ]     =    distance ;", "}", "} else    {", "_ rang . Encode (  _ isRep ,     _ state ,     0  )  ;", "_ state    =    Base . StateUpdateMatch (  _ state )  ;", "_ le . Encode (  _ rang ,     ( len    -     ( Base . kMatchMinLen )  )  ,    posState )  ;", "pos    -  =    Base . kNumRepDistances ;", "int   posSlot    =  . GetPosSlot ( pos )  ;", "int   lenToPosState    =    Base . GetLenToPosState ( len )  ;", "_ posSlo [ lenToPosState ]  . Encode (  _ rang ,    posSlot )  ;", "if    ( posSlot    >  =     ( Base . kStartPosModelIndex )  )     {", "int   footerBits    =     (  ( int )     (  ( posSlot    >  >     1  )     -     1  )  )  ;", "int   baseVal    =     (  2     |     ( posSlot    &     1  )  )     <  <    footerBits ;", "int   posReduced    =    pos    -    baseVal ;", "if    ( posSlot    <     ( Base . kEndPosModelIndex )  )", "BitTre . ReverseEncode (  _ pos ,     (  ( baseVal    -    posSlot )     -     1  )  ,     _ rang ,    footerBits ,    posReduced )  ;", "else    {", "_ rang . EncodeDirectBits (  ( posReduced    >  >     ( Base . kNumAlignBits )  )  ,     ( footerBits    -     ( Base . kNumAlignBits )  )  )  ;", "_ posAlig . ReverseEncode (  _ rang ,     ( posReduced    &     ( Base . kAlignMask )  )  )  ;", "(  _ alignPriceCount )  +  +  ;", "}", "}", "int   distance    =    pos ;", "for    ( int   i    =     ( Base . kNumRepDistances )     -     1  ;    i    >  =     1  ;    i -  -  )", "_ repDistances [ i ]     =     _ repDistances [  ( i    -     1  )  ]  ;", "_ repDistances [  0  ]     =    distance ;", "(  _ matchPriceCount )  +  +  ;", "}", "_ previousByte    =     _ matchFinder . GetIndexByte (  (  ( len    -     1  )     -     (  _ additionalOffset )  )  )  ;", "}", "_ additionalOffset    -  =    len ;", "nowPos 6  4     +  =    len ;", "if    (  (  _ additionalOffset )     =  =     0  )     {", "if    (  (  _ matchPriceCount )     >  =     (  1     <  <     7  )  )", "FillDistancesPrices (  )  ;", "if    (  (  _ alignPriceCount )     >  =     ( Base . kAlignTableSize )  )", "FillAlignPrices (  )  ;", "inSize [  0  ]     =    nowPos 6  4  ;", "outSize [  0  ]     =     _ rang . GetProcessedSizeAdd (  )  ;", "if    (  (  _ matchFinder . GetNumAvailableBytes (  )  )     =  =     0  )     {", "Flush (  (  ( int )     ( nowPos 6  4  )  )  )  ;", "return ;", "}", "if    (  (  ( nowPos 6  4  )     -    progressPosValuePrev )     >  =     (  1     <  <     1  2  )  )     {", "_ finished    =    false ;", "finished [  0  ]     =    false ;", "return ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["CodeOneBlock"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  _ matchFinder )     =  =    null )     {", "BinTree   bt    =    new   BinTree (  )  ;", "int   numHashBytes    =     4  ;", "if    (  (  _ matchFinderType )     =  =     (  . EMatchFinderTypeBT 2  )  )", "numHashBytes    =     2  ;", "bt . SetType ( numHashBytes )  ;", "_ matchFinder    =    bt ;", "}", "_ literal . Create (  _ numLiteralPosStateBits ,     _ numLiteralContextBits )  ;", "if    (  (  (  _ dictionarySize )     =  =     (  _ dictionarySizePrev )  )     &  &     (  (  _ numFastBytesPrev )     =  =     (  _ numFastBytes )  )  )", "return ;", "_ matchFinder . Create (  _ dictionarySize ,     . kNumOpts ,     _ numFastBytes ,     (  ( Base . kMatchMaxLen )     +     1  )  )  ;", "_ dictionarySizePrev    =     _ dictionarySize ;", "_ numFastBytesPrev    =     _ numFastBytes ;", "}", "METHOD_END"], "methodName": ["Create"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( Base . kAlignTableSize )  ;    i +  +  )", "_ alignPrices [ i ]     =     _ posAlign . ReverseGetPrice ( i )  ;", "_ alignPriceCount    =     0  ;", "}", "METHOD_END"], "methodName": ["FillAlignPrices"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    Base . kStartPosModelIndex ;    i    <     ( Base . kNumFullDistances )  ;    i +  +  )     {", "int   posSlot    =    Encoder . GetPosSlot ( i )  ;", "int   footerBits    =     (  ( int )     (  ( posSlot    >  >     1  )     -     1  )  )  ;", "int   baseVal    =     (  2     |     ( posSlot    &     1  )  )     <  <    footerBits ;", "tempPrices [ i ]     =    BitTreeEncoder . ReverseGetPrice (  _ posEncoders ,     (  ( baseVal    -    posSlot )     -     1  )  ,    footerBits ,     ( i    -    baseVal )  )  ;", "}", "for    ( int   lenToPosState    =     0  ;    lenToPosState    <     ( Base . kNumLenToPosStates )  ;    lenToPosState +  +  )     {", "int   posSlot ;", "BitTreeEncoder   encoder    =     _ posSlotEncoder [ lenToPosState ]  ;", "int   st    =    lenToPosState    <  <     ( Base . kNumPosSlotBits )  ;", "for    ( posSlot    =     0  ;    posSlot    <     (  _ distTableSize )  ;    posSlot +  +  )", "_ posSlotPrices [  ( st    +    posSlot )  ]     =    encoder . GetPrice ( posSlot )  ;", "for    ( posSlot    =    Base . kEndPosModelIndex ;    posSlot    <     (  _ distTableSize )  ;    posSlot +  +  )", "_ posSlotPrices [  ( st    +    posSlot )  ]     +  =     (  (  ( posSlot    >  >     1  )     -     1  )     -     ( Base . kNumAlignBits )  )     <  <     ( rangecoder . Encoder . kNumBitPriceShiftBits )  ;", "int   st 2     =    lenToPosState    *     ( Base . kNumFullDistances )  ;", "int   i ;", "for    ( i    =     0  ;    i    <     ( Base . kStartPosModelIndex )  ;    i +  +  )", "_ distancesPrices [  ( st 2     +    i )  ]     =     _ posSlotPrices [  ( st    +    i )  ]  ;", "for    (  ;    i    <     ( Base . kNumFullDistances )  ;    i +  +  )", "_ distancesPrices [  ( st 2     +    i )  ]     =     (  _ posSlotPrices [  ( st    +     ( Encoder . GetPosSlot ( i )  )  )  ]  )     +     ( tempPrices [ i ]  )  ;", "}", "_ matchPriceCount    =     0  ;", "}", "METHOD_END"], "methodName": ["FillDistancesPrices"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "ReleaseMFStream (  )  ;", "WriteEndMarker (  ( nowPos    &     (  _ posStateMask )  )  )  ;", "_ range . FlushData (  )  ;", "_ range . FlushStream (  )  ;", "}", "METHOD_END"], "methodName": ["Flush"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  _ optimumEndIndex )     !  =     (  _ optimumCurrentIndex )  )     {", "int   lenRes    =     (  _ optimum [  _ optimumCurrentIndex ]  . PosPrev )     -     (  _ optimumCurrentIndex )  ;", "backRes    =     _ optimum [  _ optimumCurrentIndex ]  . BackPrev ;", "_ optimumCurrentIndex    =     _ optimum [  _ optimumCurrentIndex ]  . PosPrev ;", "return   lenRes ;", "}", "_ optimumCurrentIndex    =     _ optimumEndIndex    =     0  ;", "int   lenMain ;", "int   numDistancePairs ;", "if    (  !  (  _ longestMatchWasFound )  )     {", "lenMain    =    ReadMatchDistances (  )  ;", "} else    {", "lenMain    =     _ longestMatchLength ;", "_ longestMatchWasFound    =    false ;", "}", "numDistancePairs    =     _ numDistancePairs ;", "int   numAvailableBytes    =     (  _ matchFinder . GetNumAvailableBytes (  )  )     +     1  ;", "if    ( numAvailableBytes    <     2  )     {", "backRes    =     -  1  ;", "return    1  ;", "}", "if    ( numAvailableBytes    >     ( Base . kMatchMaxLen )  )", "numAvailableBytes    =    Base . kMatchMaxLen ;", "int   repMaxIndex    =     0  ;", "int   i ;", "for    ( i    =     0  ;    i    <     ( Base . kNumRepDistances )  ;    i +  +  )     {", "reps [ i ]     =     _ repDistances [ i ]  ;", "repLens [ i ]     =     _ matchFinder . GetMatchLen (  (  0     -     1  )  ,    reps [ i ]  ,    Base . kMatchMaxLen )  ;", "if    (  ( repLens [ i ]  )     >     ( repLens [ repMaxIndex ]  )  )", "repMaxIndex    =    i ;", "}", "if    (  ( repLens [ repMaxIndex ]  )     >  =     (  _ numFastBytes )  )     {", "backRes    =    repMaxIndex ;", "int   lenRes    =    repLens [ repMaxIndex ]  ;", "MovePos (  ( lenRes    -     1  )  )  ;", "return   lenRes ;", "}", "if    ( lenMain    >  =     (  _ numFastBytes )  )     {", "backRes    =     (  _ matchDistances [  ( numDistancePairs    -     1  )  ]  )     +     ( Base . kNumRepDistances )  ;", "MovePos (  ( lenMain    -     1  )  )  ;", "return   lenMain ;", "}", "byte   currentByte    =     _ matchFinder . GetIndexByte (  (  0     -     1  )  )  ;", "byte   matchByte    =     _ matchFinder . GetIndexByte (  (  (  (  0     -     (  _ repDistances [  0  ]  )  )     -     1  )     -     1  )  )  ;", "if    (  (  ( lenMain    <     2  )     &  &     ( currentByte    !  =    matchByte )  )     &  &     (  ( repLens [ repMaxIndex ]  )     <     2  )  )     {", "backRes    =     -  1  ;", "return    1  ;", "}", "_ optimum [  0  ]  . State    =     _ state ;", "int   posState    =    position    &     (  _ posStateMask )  ;", "_ optimum [  1  ]  . Price    =     ( rangecoder . Encoder . GetPrice 0  (  _ isMatch [  (  (  (  _ state )     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ]  )  )     +     (  _ literalEncoder . GetSubCoder ( position ,     _ previousByte )  . GetPrice (  (  !  ( Base . StateIsCharState (  _ state )  )  )  ,    matchByte ,    currentByte )  )  ;", "_ optimum [  1  ]  . MakeAsChar (  )  ;", "int   matchPrice    =    rangecoder . Encoder . GetPrice 1  (  _ isMatch [  (  (  (  _ state )     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ]  )  ;", "int   repMatchPrice    =    matchPrice    +     ( rangecoder . Encoder . GetPrice 1  (  _ isRep [  _ state ]  )  )  ;", "if    ( matchByte    =  =    currentByte )     {", "int   shortRepPrice    =    repMatchPrice    +     ( GetRepLen 1 Price (  _ state ,    posState )  )  ;", "if    ( shortRepPrice    <     (  _ optimum [  1  ]  . Price )  )     {", "_ optimum [  1  ]  . Price    =    shortRepPrice ;", "_ optimum [  1  ]  . MakeAsShortRep (  )  ;", "}", "}", "int   lenEnd    =     ( lenMain    >  =     ( repLens [ repMaxIndex ]  )  )     ?    lenMain    :    repLens [ repMaxIndex ]  ;", "if    ( lenEnd    <     2  )     {", "backRes    =     _ optimum [  1  ]  . BackPrev ;", "return    1  ;", "}", "_ optimum [  1  ]  . PosPrev    =     0  ;", "_ optimum [  0  ]  . Backs 0     =    reps [  0  ]  ;", "_ optimum [  0  ]  . Backs 1     =    reps [  1  ]  ;", "_ optimum [  0  ]  . Backs 2     =    reps [  2  ]  ;", "_ optimum [  0  ]  . Backs 3     =    reps [  3  ]  ;", "int   len    =    lenEnd ;", "do", "_ optimum [  ( len -  -  )  ]  . Price    =    Encoder . kIfinityPrice ;", "while    ( len    >  =     2     )  ;", "for    ( i    =     0  ;    i    <     ( Base . kNumRepDistances )  ;    i +  +  )     {", "int   repLen    =    repLens [ i ]  ;", "if    ( repLen    <     2  )", "continue ;", "int   price    =    repMatchPrice    +     ( GetPureRepPrice ( i ,     _ state ,    posState )  )  ;", "do    {", "int   curAndLenPrice    =    price    +     (  _ repMatchLenEncoder . GetPrice (  ( repLen    -     2  )  ,    posState )  )  ;", "Encoder . Optimal   optimum    =     _ optimum [ repLen ]  ;", "if    ( curAndLenPrice    <     ( optimum . Price )  )     {", "optimum . Price    =    curAndLenPrice ;", "optimum . PosPrev    =     0  ;", "optimum . BackPrev    =    i ;", "optimum . Prev 1 IsChar    =    false ;", "}", "}    while    (  (  -  - repLen )     >  =     2     )  ;", "}", "int   normalMatchPrice    =    matchPrice    +     ( rangecoder . Encoder . GetPrice 0  (  _ isRep [  _ state ]  )  )  ;", "len    =     (  ( repLens [  0  ]  )     >  =     2  )     ?     ( repLens [  0  ]  )     +     1     :     2  ;", "if    ( len    <  =    lenMain )     {", "int   offs    =     0  ;", "while    ( len    >     (  _ matchDistances [ offs ]  )  )", "offs    +  =     2  ;", "for    (  ;     ;    len +  +  )     {", "int   distance    =     _ matchDistances [  ( offs    +     1  )  ]  ;", "int   curAndLenPrice    =    normalMatchPrice    +     ( GetPosLenPrice ( distance ,    len ,    posState )  )  ;", "Encoder . Optimal   optimum    =     _ optimum [ len ]  ;", "if    ( curAndLenPrice    <     ( optimum . Price )  )     {", "optimum . Price    =    curAndLenPrice ;", "optimum . PosPrev    =     0  ;", "optimum . BackPrev    =    distance    +     ( Base . kNumRepDistances )  ;", "optimum . Prev 1 IsChar    =    false ;", "}", "if    ( len    =  =     (  _ matchDistances [ offs ]  )  )     {", "offs    +  =     2  ;", "if    ( offs    =  =    numDistancePairs )", "break ;", "}", "}", "}", "int   cur    =     0  ;", "while    ( true )     {", "cur +  +  ;", "if    ( cur    =  =    lenEnd )", "return   Backward ( cur )  ;", "int   newLen    =    ReadMatchDistances (  )  ;", "numDistancePairs    =     _ numDistancePairs ;", "if    ( newLen    >  =     (  _ numFastBytes )  )     {", "_ longestMatchLength    =    newLen ;", "_ longestMatchWasFound    =    true ;", "return   Backward ( cur )  ;", "}", "position +  +  ;", "int   posPrev    =     _ optimum [ cur ]  . PosPrev ;", "int   state ;", "if    (  _ optimum [ cur ]  . Prev 1 IsChar )     {", "posPrev -  -  ;", "if    (  _ optimum [ cur ]  . Prev 2  )     {", "state    =     _ optimum [  _ optimum [ cur ]  . PosPrev 2  ]  . State ;", "if    (  (  _ optimum [ cur ]  . BackPrev 2  )     <     ( Base . kNumRepDistances )  )", "state    =    Base . StateUpdateRep ( state )  ;", "else", "state    =    Base . StateUpdateMatch ( state )  ;", "} else", "state    =     _ optimum [ posPrev ]  . State ;", "state    =    Base . StateUpdateChar ( state )  ;", "} else", "state    =     _ optimum [ posPrev ]  . State ;", "if    ( posPrev    =  =     ( cur    -     1  )  )     {", "if    (  _ optimum [ cur ]  . IsShortRep (  )  )", "state    =    Base . StateUpdateShortRep ( state )  ;", "else", "state    =    Base . StateUpdateChar ( state )  ;", "} else    {", "int   pos ;", "if    (  (  _ optimum [ cur ]  . Prev 1 IsChar )     &  &     (  _ optimum [ cur ]  . Prev 2  )  )     {", "posPrev    =     _ optimum [ cur ]  . PosPrev 2  ;", "pos    =     _ optimum [ cur ]  . BackPrev 2  ;", "state    =    Base . StateUpdateRep ( state )  ;", "} else    {", "pos    =     _ optimum [ cur ]  . BackPrev ;", "if    ( pos    <     ( Base . kNumRepDistances )  )", "state    =    Base . StateUpdateRep ( state )  ;", "else", "state    =    Base . StateUpdateMatch ( state )  ;", "}", "Encoder . Optimal   opt    =     _ optimum [ posPrev ]  ;", "if    ( pos    <     ( Base . kNumRepDistances )  )     {", "if    ( pos    =  =     0  )     {", "reps [  0  ]     =    opt . Backs 0  ;", "reps [  1  ]     =    opt . Backs 1  ;", "reps [  2  ]     =    opt . Backs 2  ;", "reps [  3  ]     =    opt . Backs 3  ;", "} else", "if    ( pos    =  =     1  )     {", "reps [  0  ]     =    opt . Backs 1  ;", "reps [  1  ]     =    opt . Backs 0  ;", "reps [  2  ]     =    opt . Backs 2  ;", "reps [  3  ]     =    opt . Backs 3  ;", "} else", "if    ( pos    =  =     2  )     {", "reps [  0  ]     =    opt . Backs 2  ;", "reps [  1  ]     =    opt . Backs 0  ;", "reps [  2  ]     =    opt . Backs 1  ;", "reps [  3  ]     =    opt . Backs 3  ;", "} else    {", "reps [  0  ]     =    opt . Backs 3  ;", "reps [  1  ]     =    opt . Backs 0  ;", "reps [  2  ]     =    opt . Backs 1  ;", "reps [  3  ]     =    opt . Backs 2  ;", "}", "} else    {", "reps [  0  ]     =    pos    -     ( Base . kNumRepDistances )  ;", "reps [  1  ]     =    opt . Backs 0  ;", "reps [  2  ]     =    opt . Backs 1  ;", "reps [  3  ]     =    opt . Backs 2  ;", "}", "}", "_ optimum [ cur ]  . State    =    state ;", "_ optimum [ cur ]  . Backs 0     =    reps [  0  ]  ;", "_ optimum [ cur ]  . Backs 1     =    reps [  1  ]  ;", "_ optimum [ cur ]  . Backs 2     =    reps [  2  ]  ;", "_ optimum [ cur ]  . Backs 3     =    reps [  3  ]  ;", "int   curPrice    =     _ optimum [ cur ]  . Price ;", "currentByte    =     _ matchFinder . GetIndexByte (  (  0     -     1  )  )  ;", "matchByte    =     _ matchFinder . GetIndexByte (  (  (  (  0     -     ( reps [  0  ]  )  )     -     1  )     -     1  )  )  ;", "posState    =    position    &     (  _ posStateMask )  ;", "int   curAnd 1 Price    =     ( curPrice    +     ( rangecoder . Encoder . GetPrice 0  (  _ isMatch [  (  ( state    <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ]  )  )  )     +     (  _ literalEncoder . GetSubCoder ( position ,     _ matchFinder . GetIndexByte (  (  0     -     2  )  )  )  . GetPrice (  (  !  ( Base . StateIsCharState ( state )  )  )  ,    matchByte ,    currentByte )  )  ;", "Encoder . Optimal   nextOptimum    =     _ optimum [  ( cur    +     1  )  ]  ;", "boolean   nextIsChar    =    false ;", "if    ( curAnd 1 Price    <     ( nextOptimum . Price )  )     {", "nextOptimum . Price    =    curAnd 1 Price ;", "nextOptimum . PosPrev    =    cur ;", "nextOptimum . MakeAsChar (  )  ;", "nextIsChar    =    true ;", "}", "matchPrice    =    curPrice    +     ( rangecoder . Encoder . GetPrice 1  (  _ isMatch [  (  ( state    <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ]  )  )  ;", "repMatchPrice    =    matchPrice    +     ( rangecoder . Encoder . GetPrice 1  (  _ isRep [ state ]  )  )  ;", "if    (  ( matchByte    =  =    currentByte )     &  &     (  !  (  (  ( nextOptimum . PosPrev )     <    cur )     &  &     (  ( nextOptimum . BackPrev )     =  =     0  )  )  )  )     {", "int   shortRepPrice    =    repMatchPrice    +     ( GetRepLen 1 Price ( state ,    posState )  )  ;", "if    ( shortRepPrice    <  =     ( nextOptimum . Price )  )     {", "nextOptimum . Price    =    shortRepPrice ;", "nextOptimum . PosPrev    =    cur ;", "nextOptimum . MakeAsShortRep (  )  ;", "nextIsChar    =    true ;", "}", "}", "int   numAvailableBytesFull    =     (  _ matchFinder . GetNumAvailableBytes (  )  )     +     1  ;", "numAvailableBytesFull    =    Math . min (  (  (  ( Encoder . kNumOpts )     -     1  )     -    cur )  ,    numAvailableBytesFull )  ;", "numAvailableBytes    =    numAvailableBytesFull ;", "if    ( numAvailableBytes    <     2  )", "continue ;", "if    ( numAvailableBytes    >     (  _ numFastBytes )  )", "numAvailableBytes    =     _ numFastBytes ;", "if    (  (  ! nextIsChar )     &  &     ( matchByte    !  =    currentByte )  )     {", "int   t    =    Math . min (  ( numAvailableBytesFull    -     1  )  ,     _ numFastBytes )  ;", "int   lenTest 2     =     _ matchFinder . GetMatchLen (  0  ,    reps [  0  ]  ,    t )  ;", "if    ( lenTest 2     >  =     2  )     {", "int   state 2     =    Base . StateUpdateChar ( state )  ;", "int   posStateNext    =     ( position    +     1  )     &     (  _ posStateMask )  ;", "int   nextRepMatchPrice    =     ( curAnd 1 Price    +     ( rangecoder . Encoder . GetPrice 1  (  _ isMatch [  (  ( state 2     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posStateNext )  ]  )  )  )     +     ( rangecoder . Encoder . GetPrice 1  (  _ isRep [ state 2  ]  )  )  ;", "{", "int   offset    =     ( cur    +     1  )     +    lenTest 2  ;", "while    ( lenEnd    <    offset )", "_ optimum [  (  +  + lenEnd )  ]  . Price    =    Encoder . kIfinityPrice ;", "int   curAndLenPrice    =    nextRepMatchPrice    +     ( GetRepPrice (  0  ,    lenTest 2  ,    state 2  ,    posStateNext )  )  ;", "Encoder . Optimal   optimum    =     _ optimum [ offset ]  ;", "if    ( curAndLenPrice    <     ( optimum . Price )  )     {", "optimum . Price    =    curAndLenPrice ;", "optimum . PosPrev    =    cur    +     1  ;", "optimum . BackPrev    =     0  ;", "optimum . Prev 1 IsChar    =    true ;", "optimum . Prev 2     =    false ;", "}", "}", "}", "}", "int   startLen    =     2  ;", "for    ( int   repIndex    =     0  ;    repIndex    <     ( Base . kNumRepDistances )  ;    repIndex +  +  )     {", "int   lenTest    =     _ matchFinder . GetMatchLen (  (  0     -     1  )  ,    reps [ repIndex ]  ,    numAvailableBytes )  ;", "if    ( lenTest    <     2  )", "continue ;", "int   lenTestTemp    =    lenTest ;", "do    {", "while    ( lenEnd    <     ( cur    +    lenTest )  )", "_ optimum [  (  +  + lenEnd )  ]  . Price    =    Encoder . kIfinityPrice ;", "int   curAndLenPrice    =    repMatchPrice    +     ( GetRepPrice ( repIndex ,    lenTest ,    state ,    posState )  )  ;", "Encoder . Optimal   optimum    =     _ optimum [  ( cur    +    lenTest )  ]  ;", "if    ( curAndLenPrice    <     ( optimum . Price )  )     {", "optimum . Price    =    curAndLenPrice ;", "optimum . PosPrev    =    cur ;", "optimum . BackPrev    =    repIndex ;", "optimum . Prev 1 IsChar    =    false ;", "}", "}    while    (  (  -  - lenTest )     >  =     2     )  ;", "lenTest    =    lenTestTemp ;", "if    ( repIndex    =  =     0  )", "startLen    =    lenTest    +     1  ;", "if    ( lenTest    <    numAvailableBytesFull )     {", "int   t    =    Math . min (  (  ( numAvailableBytesFull    -     1  )     -    lenTest )  ,     _ numFastBytes )  ;", "int   lenTest 2     =     _ matchFinder . GetMatchLen ( lenTest ,    reps [ repIndex ]  ,    t )  ;", "if    ( lenTest 2     >  =     2  )     {", "int   state 2     =    Base . StateUpdateRep ( state )  ;", "int   posStateNext    =     ( position    +    lenTest )     &     (  _ posStateMask )  ;", "int   curAndLenCharPrice    =     (  ( repMatchPrice    +     ( GetRepPrice ( repIndex ,    lenTest ,    state ,    posState )  )  )     +     ( rangecoder . Encoder . GetPrice 0  (  _ isMatch [  (  ( state 2     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posStateNext )  ]  )  )  )     +     (  _ literalEncoder . GetSubCoder (  ( position    +    lenTest )  ,     _ matchFinder . GetIndexByte (  (  ( lenTest    -     1  )     -     1  )  )  )  . GetPrice ( true ,     _ matchFinder . GetIndexByte (  (  ( lenTest    -     1  )     -     (  ( reps [ repIndex ]  )     +     1  )  )  )  ,     _ matchFinder . GetIndexByte (  ( lenTest    -     1  )  )  )  )  ;", "state 2     =    Base . StateUpdateChar ( state 2  )  ;", "posStateNext    =     (  ( position    +    lenTest )     +     1  )     &     (  _ posStateMask )  ;", "int   nextMatchPrice    =    curAndLenCharPrice    +     ( rangecoder . Encoder . GetPrice 1  (  _ isMatch [  (  ( state 2     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posStateNext )  ]  )  )  ;", "int   nextRepMatchPrice    =    nextMatchPrice    +     ( rangecoder . Encoder . GetPrice 1  (  _ isRep [ state 2  ]  )  )  ;", "{", "int   offset    =     ( lenTest    +     1  )     +    lenTest 2  ;", "while    ( lenEnd    <     ( cur    +    offset )  )", "_ optimum [  (  +  + lenEnd )  ]  . Price    =    Encoder . kIfinityPrice ;", "int   curAndLenPrice    =    nextRepMatchPrice    +     ( GetRepPrice (  0  ,    lenTest 2  ,    state 2  ,    posStateNext )  )  ;", "Encoder . Optimal   optimum    =     _ optimum [  ( cur    +    offset )  ]  ;", "if    ( curAndLenPrice    <     ( optimum . Price )  )     {", "optimum . Price    =    curAndLenPrice ;", "optimum . PosPrev    =     ( cur    +    lenTest )     +     1  ;", "optimum . BackPrev    =     0  ;", "optimum . Prev 1 IsChar    =    true ;", "optimum . Prev 2     =    true ;", "optimum . PosPrev 2     =    cur ;", "optimum . BackPrev 2     =    repIndex ;", "}", "}", "}", "}", "}", "if    ( newLen    >    numAvailableBytes )     {", "newLen    =    numAvailableBytes ;", "for    ( numDistancePairs    =     0  ;    newLen    >     (  _ matchDistances [ numDistancePairs ]  )  ;    numDistancePairs    +  =     2  )  ;", "_ matchDistances [ numDistancePairs ]     =    newLen ;", "numDistancePairs    +  =     2  ;", "}", "if    ( newLen    >  =    startLen )     {", "normalMatchPrice    =    matchPrice    +     ( rangecoder . Encoder . GetPrice 0  (  _ isRep [ state ]  )  )  ;", "while    ( lenEnd    <     ( cur    +    newLen )  )", "_ optimum [  (  +  + lenEnd )  ]  . Price    =    Encoder . kIfinityPrice ;", "int   offs    =     0  ;", "while    ( startLen    >     (  _ matchDistances [ offs ]  )  )", "offs    +  =     2  ;", "for    ( int   lenTest    =    startLen ;     ;    lenTest +  +  )     {", "int   curBack    =     _ matchDistances [  ( offs    +     1  )  ]  ;", "int   curAndLenPrice    =    normalMatchPrice    +     ( GetPosLenPrice ( curBack ,    lenTest ,    posState )  )  ;", "Encoder . Optimal   optimum    =     _ optimum [  ( cur    +    lenTest )  ]  ;", "if    ( curAndLenPrice    <     ( optimum . Price )  )     {", "optimum . Price    =    curAndLenPrice ;", "optimum . PosPrev    =    cur ;", "optimum . BackPrev    =    curBack    +     ( Base . kNumRepDistances )  ;", "optimum . Prev 1 IsChar    =    false ;", "}", "if    ( lenTest    =  =     (  _ matchDistances [ offs ]  )  )     {", "if    ( lenTest    <    numAvailableBytesFull )     {", "int   t    =    Math . min (  (  ( numAvailableBytesFull    -     1  )     -    lenTest )  ,     _ numFastBytes )  ;", "int   lenTest 2     =     _ matchFinder . GetMatchLen ( lenTest ,    curBack ,    t )  ;", "if    ( lenTest 2     >  =     2  )     {", "int   state 2     =    Base . StateUpdateMatch ( state )  ;", "int   posStateNext    =     ( position    +    lenTest )     &     (  _ posStateMask )  ;", "int   curAndLenCharPrice    =     ( curAndLenPrice    +     ( rangecoder . Encoder . GetPrice 0  (  _ isMatch [  (  ( state 2     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posStateNext )  ]  )  )  )     +     (  _ literalEncoder . GetSubCoder (  ( position    +    lenTest )  ,     _ matchFinder . GetIndexByte (  (  ( lenTest    -     1  )     -     1  )  )  )  . GetPrice ( true ,     _ matchFinder . GetIndexByte (  (  ( lenTest    -     ( curBack    +     1  )  )     -     1  )  )  ,     _ matchFinder . GetIndexByte (  ( lenTest    -     1  )  )  )  )  ;", "state 2     =    Base . StateUpdateChar ( state 2  )  ;", "posStateNext    =     (  ( position    +    lenTest )     +     1  )     &     (  _ posStateMask )  ;", "int   nextMatchPrice    =    curAndLenCharPrice    +     ( rangecoder . Encoder . GetPrice 1  (  _ isMatch [  (  ( state 2     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posStateNext )  ]  )  )  ;", "int   nextRepMatchPrice    =    nextMatchPrice    +     ( rangecoder . Encoder . GetPrice 1  (  _ isRep [ state 2  ]  )  )  ;", "int   offset    =     ( lenTest    +     1  )     +    lenTest 2  ;", "while    ( lenEnd    <     ( cur    +    offset )  )", "_ optimum [  (  +  + lenEnd )  ]  . Price    =    Encoder . kIfinityPrice ;", "curAndLenPrice    =    nextRepMatchPrice    +     ( GetRepPrice (  0  ,    lenTest 2  ,    state 2  ,    posStateNext )  )  ;", "optimum    =     _ optimum [  ( cur    +    offset )  ]  ;", "if    ( curAndLenPrice    <     ( optimum . Price )  )     {", "optimum . Price    =    curAndLenPrice ;", "optimum . PosPrev    =     ( cur    +    lenTest )     +     1  ;", "optimum . BackPrev    =     0  ;", "optimum . Prev 1 IsChar    =    true ;", "optimum . Prev 2     =    true ;", "optimum . PosPrev 2     =    cur ;", "optimum . BackPrev 2     =    curBack    +     ( Base . kNumRepDistances )  ;", "}", "}", "}", "offs    +  =     2  ;", "if    ( offs    =  =    numDistancePairs )", "break ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["GetOptimum"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   price ;", "int   lenToPosState    =    Base . GetLenToPosState ( len )  ;", "if    ( pos    <     ( Base . kNumFullDistances )  )", "price    =     _ distancesPrices [  (  ( lenToPosState    *     ( Base . kNumFullDistances )  )     +    pos )  ]  ;", "else", "price    =     (  _ posSlotPrices [  (  ( lenToPosState    <  <     ( Base . kNumPosSlotBits )  )     +     (  . GetPosSlot 2  ( pos )  )  )  ]  )     +     (  _ alignPrices [  ( pos    &     ( Base . kAlignMask )  )  ]  )  ;", "return   price    +     (  _ len . GetPrice (  ( len    -     ( Base . kMatchMinLen )  )  ,    posState )  )  ;", "}", "METHOD_END"], "methodName": ["GetPosLenPrice"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    ( pos    <     (  1     <  <     1  1  )  )", "return    . g _ FastPos [ pos ]  ;", "if    ( pos    <     (  1     <  <     2  1  )  )", "return    (  . g _ FastPos [  ( pos    >  >     1  0  )  ]  )     +     2  0  ;", "return    (  . g _ FastPos [  ( pos    >  >     2  0  )  ]  )     +     4  0  ;", "}", "METHOD_END"], "methodName": ["GetPosSlot"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    ( pos    <     (  1     <  <     1  7  )  )", "return    (  . g _ FastPos [  ( pos    >  >     6  )  ]  )     +     1  2  ;", "if    ( pos    <     (  1     <  <     2  7  )  )", "return    (  . g _ FastPos [  ( pos    >  >     1  6  )  ]  )     +     3  2  ;", "return    (  . g _ FastPos [  ( pos    >  >     2  6  )  ]  )     +     5  2  ;", "}", "METHOD_END"], "methodName": ["GetPosSlot2"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   price ;", "if    ( repIndex    =  =     0  )     {", "price    =    rangecoder . Encoder . GetPrice 0  (  _ isRepG 0  [ state ]  )  ;", "price    +  =    rangecoder . Encoder . GetPrice 1  (  _ isRep 0 Long [  (  ( state    <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ]  )  ;", "} else    {", "price    =    rangecoder . Encoder . GetPrice 1  (  _ isRepG 0  [ state ]  )  ;", "if    ( repIndex    =  =     1  )", "price    +  =    rangecoder . Encoder . GetPrice 0  (  _ isRepG 1  [ state ]  )  ;", "else    {", "price    +  =    rangecoder . Encoder . GetPrice 1  (  _ isRepG 1  [ state ]  )  ;", "price    +  =    rangecoder . Encoder . GetPrice (  _ isRepG 2  [ state ]  ,     ( repIndex    -     2  )  )  ;", "}", "}", "return   price ;", "}", "METHOD_END"], "methodName": ["GetPureRepPrice"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "return    ( com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice 0  (  _ isRepG 0  [ state ]  )  )     +     ( com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice 0  (  _ isRep 0 Long [  (  ( state    <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["GetRepLen1Price"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   price    =     _ repMatchLenEncoder . GetPrice (  ( len    -     ( Base . kMatchMinLen )  )  ,    posState )  ;", "return   price    +     ( GetPureRepPrice ( repIndex ,    state ,    posState )  )  ;", "}", "METHOD_END"], "methodName": ["GetRepPrice"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "BaseInit (  )  ;", "_ rangeEncoder . Init (  )  ;", "rangecoder . Encoder . InitBitModels (  _ isMatch )  ;", "rangecoder . Encoder . InitBitModels (  _ isRep 0 Long )  ;", "rangecoder . Encoder . InitBitModels (  _ isRep )  ;", "rangecoder . Encoder . InitBitModels (  _ isRepG 0  )  ;", "rangecoder . Encoder . InitBitModels (  _ isRepG 1  )  ;", "rangecoder . Encoder . InitBitModels (  _ isRepG 2  )  ;", "rangecoder . Encoder . InitBitModels (  _ posEncoders )  ;", "_ literalEncoder . Init (  )  ;", "for    ( int   i    =     0  ;    i    <     ( Base . kNumLenToPosStates )  ;    i +  +  )", "_ posSlotEncoder [ i ]  . Init (  )  ;", "_ lenEncoder . Init (  (  1     <  <     (  _ posStateBits )  )  )  ;", "_ repMatchLenEncoder . Init (  (  1     <  <     (  _ posStateBits )  )  )  ;", "_ posAlignEncoder . Init (  )  ;", "_ longestMatchWasFound    =    false ;", "_ optimumEndIndex    =     0  ;", "_ optimumCurrentIndex    =     0  ;", "_ additionalOffset    =     0  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    ( num    >     0  )     {", "_ matchFin . Skip ( num )  ;", "_ additionalOffset    +  =    num ;", "}", "}", "METHOD_END"], "methodName": ["MovePos"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   lenRes    =     0  ;", "_ numDistancePairs    =     _ matchFin . GetMatches (  _ matchDistances )  ;", "if    (  (  _ numDistancePairs )     >     0  )     {", "lenRes    =     _ matchDistances [  (  (  _ numDistancePairs )     -     2  )  ]  ;", "if    ( lenRes    =  =     (  _ numFastBytes )  )", "lenRes    +  =     _ matchFin . GetMatchLen (  (  (  ( int )     ( lenRes )  )     -     1  )  ,     _ matchDistances [  (  (  _ numDistancePairs )     -     1  )  ]  ,     (  ( Base . kMatchMaxLen )     -    lenRes )  )  ;", "}", "(  _ additionalOffset )  +  +  ;", "return   lenRes ;", "}", "METHOD_END"], "methodName": ["ReadMatchDistances"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  _ matchFinder )     !  =    null )     &  &     (  _ needReleaseMFStream )  )     {", "_ matchFinder . ReleaseStream (  )  ;", "_ needReleaseMFStream    =    false ;", "}", "}", "METHOD_END"], "methodName": ["ReleaseMFStream"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ rangeEncoder . ReleaseStream (  )  ;", "}", "METHOD_END"], "methodName": ["ReleaseOutStream"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "ReleaseMFStream (  )  ;", "ReleaseOutStream (  )  ;", "}", "METHOD_END"], "methodName": ["ReleaseStreams"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["SetAlgorithm"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   kDicLogSizeMaxCompress    =     2  9  ;", "if    (  ( dictionarySize    <     (  1     <  <     ( Base . kDicLogSizeMin )  )  )     |  |     ( dictionarySize    >     (  1     <  <    kDicLogSizeMaxCompress )  )  )", "return   false ;", "_ dictionarySize    =    dictionarySize ;", "int   dicLogSize ;", "for    ( dicLogSize    =     0  ;    dictionarySize    >     (  1     <  <    dicLogSize )  ;    dicLogSize +  +  )  ;", "_ distTableSize    =    dicLogSize    *     2  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["SetDictionarySize"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ writeEndMark    =    endMarkerMode ;", "}", "METHOD_END"], "methodName": ["SetEndMarkerMode"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  (  ( lp    <     0  )     |  |     ( lp    >     ( Base . kNumLitPosStatesBitsEncodingMax )  )  )     |  |     ( lc    <     0  )  )     |  |     ( lc    >     ( Base . kNumLitContextBitsMax )  )  )     |  |     ( pb    <     0  )  )     |  |     ( pb    >     ( Base . kNumPosStatesBitsEncodingMax )  )  )", "return   false ;", "_ numLiteralPosStateBits    =    lp ;", "_ numLiteralContextBits    =    lc ;", "_ posStateBits    =    pb ;", "_ posStateMask    =     (  1     <  <     (  _ posStateBits )  )     -     1  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["SetLcLpPb"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( matchFinderIndex    <     0  )     |  |     ( matchFinderIndex    >     2  )  )", "return   false ;", "int   matchFinderIndexPrev    =     _ matchFinderType ;", "_ matchFinderType    =    matchFinderIndex ;", "if    (  (  (  _ matchFinder )     !  =    null )     &  &     ( matchFinderIndexPrev    !  =     (  _ matchFinderType )  )  )     {", "_ dictionarySizePrev    =     -  1  ;", "_ matchFinder    =    null ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["SetMatchFinder"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( numFastBytes    <     5  )     |  |     ( numFastBytes    >     ( Base . kMatchMaxLen )  )  )", "return   false ;", "_ numFastBytes    =    numFastBytes ;", "return   true ;", "}", "METHOD_END"], "methodName": ["SetNumFastBytes"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ rangeEncoder . SetStream ( outStream )  ;", "}", "METHOD_END"], "methodName": ["SetOutStream"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ inStream    =    inStream ;", "_ finished    =    false ;", "Create (  )  ;", "SetOutStream ( outStream )  ;", "Init (  )  ;", "{", "FillDistancesPrices (  )  ;", "FillAlignPrices (  )  ;", "}", "_ len . SetTableSize (  (  (  (  _ numFastBytes )     +     1  )     -     ( Base . kMatchMinLen )  )  )  ;", "_ len . UpdateTables (  (  1     <  <     (  _ posStateBits )  )  )  ;", "_ repMatchLen . SetTableSize (  (  (  (  _ numFastBytes )     +     1  )     -     ( Base . kMatchMinLen )  )  )  ;", "_ repMatchLen . UpdateTables (  (  1     <  <     (  _ posStateBits )  )  )  ;", "nowPos 6  4     =     0  ;", "}", "METHOD_END"], "methodName": ["SetStreams"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ writeEndMark    =    writeEndMarker ;", "}", "METHOD_END"], "methodName": ["SetWriteEndMarkerMode"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "properties [  0  ]     =     (  ( byte )     (  (  (  (  (  _ posStateBits )     *     5  )     +     (  _ numLiteralPosStateBits )  )     *     9  )     +     (  _ numLiteralContextBits )  )  )  ;", "for    ( int   i    =     0  ;    i    <     4  ;    i +  +  )", "properties [  (  1     +    i )  ]     =     (  ( byte )     (  (  _ dictionarySize )     >  >     (  8     *    i )  )  )  ;", "outStream . write ( properties ,     0  ,     . kPropSize )  ;", "}", "METHOD_END"], "methodName": ["WriteCoderProperties"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  (  _ writeEndMark )  )", "return ;", "_ rangr (  _ isMatch ,     (  (  (  _ state )     <  <     ( Base . kNumPosStatesBitsMax )  )     +    posState )  ,     1  )  ;", "_ rangr (  _ isRep ,     _ state ,     0  )  ;", "_ state    =    Base . StateUpdateMatch (  _ state )  ;", "int   len    =    Base . kMatchMinLen ;", "_ ler (  _ rangr ,     ( len    -     ( Base . kMatchMinLen )  )  ,    posState )  ;", "int   posSlot    =     (  1     <  <     ( Base . kNumPosSlotBits )  )     -     1  ;", "int   lenToPosState    =    Base . GetLenToPosState ( len )  ;", "_ posSlor [ lenToPosState ]  (  _ rangr ,    posSlot )  ;", "int   footerBits    =     3  0  ;", "int   posReduced    =     (  1     <  <    footerBits )     -     1  ;", "_ rangrDirectBits (  ( posReduced    >  >     ( Base . kNumAlignBits )  )  ,     ( footerBits    -     ( Base . kNumAlignBits )  )  )  ;", "_ posAligr . Revers (  _ rangr ,     ( posReduced    &     ( Base . kAlignMask )  )  )  ;", "}", "METHOD_END"], "methodName": ["WriteEndMarker"], "fileName": "com.badlogic.gdx.utils.compression.lzma.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   m    =     1  ;", "for    ( int   bitIndex    =    NumBitLevels ;    bitIndex    !  =     0  ;    bitIndex -  -  )", "m    =     ( m    <  <     1  )     +     ( rang . DecodeBit ( Models ,    m )  )  ;", "return   m    -     (  1     <  <     ( NumBitLevels )  )  ;", "}", "METHOD_END"], "methodName": ["Decode"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder"}, {"methodBody": ["METHOD_START", "{", "Decoder . InitBitModels ( Models )  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder"}, {"methodBody": ["METHOD_START", "{", "int   m    =     1  ;", "int   symbol    =     0  ;", "for    ( int   bitIndex    =     0  ;    bitIndex    <     ( NumBitLevels )  ;    bitIndex +  +  )     {", "int   bit    =    rang . DecodeBit ( Models ,    m )  ;", "m    <  <  =     1  ;", "m    +  =    bit ;", "symbol    |  =    bit    <  <    bitIndex ;", "}", "return   symbol ;", "}", "METHOD_END"], "methodName": ["ReverseDecode"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder"}, {"methodBody": ["METHOD_START", "{", "int   m    =     1  ;", "int   symbol    =     0  ;", "for    ( int   bitIndex    =     0  ;    bitIndex    <    NumBitLevels ;    bitIndex +  +  )     {", "int   bit    =    rang . DecodeBit ( Models ,     ( startIndex    +    m )  )  ;", "m    <  <  =     1  ;", "m    +  =    bit ;", "symbol    |  =    bit    <  <    bitIndex ;", "}", "return   symbol ;", "}", "METHOD_END"], "methodName": ["ReverseDecode"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeDecoder"}, {"methodBody": ["METHOD_START", "{", "int   m    =     1  ;", "for    ( int   bitIndex    =    NumBitLevels ;    bitIndex    !  =     0  ;  )     {", "bitIndex -  -  ;", "int   bit    =     ( symbol    >  >  >    bitIndex )     &     1  ;", "rang . Encode ( Models ,    m ,    bit )  ;", "m    =     ( m    <  <     1  )     |    bit ;", "}", "}", "METHOD_END"], "methodName": ["Encode"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder"}, {"methodBody": ["METHOD_START", "{", "int   price    =     0  ;", "int   m    =     1  ;", "for    ( int   bitIndex    =    NumBitLevels ;    bitIndex    !  =     0  ;  )     {", "bitIndex -  -  ;", "int   bit    =     ( symbol    >  >  >    bitIndex )     &     1  ;", "price    +  =     . GetPrice ( Models [ m ]  ,    bit )  ;", "m    =     ( m    <  <     1  )     +    bit ;", "}", "return   price ;", "}", "METHOD_END"], "methodName": ["GetPrice"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder"}, {"methodBody": ["METHOD_START", "{", "Decoder . InitBitModels ( Models )  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder"}, {"methodBody": ["METHOD_START", "{", "int   m    =     1  ;", "for    ( int   i    =     0  ;    i    <     ( NumBitLevels )  ;    i +  +  )     {", "int   bit    =    symbol    &     1  ;", "rang . Encode ( Models ,    m ,    bit )  ;", "m    =     ( m    <  <     1  )     |    bit ;", "symbol    >  >  =     1  ;", "}", "}", "METHOD_END"], "methodName": ["ReverseEncode"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder"}, {"methodBody": ["METHOD_START", "{", "int   m    =     1  ;", "for    ( int   i    =     0  ;    i    <    NumBitLevels ;    i +  +  )     {", "int   bit    =    symbol    &     1  ;", "rang . Encode ( Models ,     ( startIndex    +    m )  ,    bit )  ;", "m    =     ( m    <  <     1  )     |    bit ;", "symbol    >  >  =     1  ;", "}", "}", "METHOD_END"], "methodName": ["ReverseEncode"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder"}, {"methodBody": ["METHOD_START", "{", "int   price    =     0  ;", "int   m    =     1  ;", "for    ( int   i    =    NumBitLevels ;    i    !  =     0  ;    i -  -  )     {", "int   bit    =    symbol    &     1  ;", "symbol    >  >  >  =     1  ;", "price    +  =     . GetPrice ( Models [ m ]  ,    bit )  ;", "m    =     ( m    <  <     1  )     |    bit ;", "}", "return   price ;", "}", "METHOD_END"], "methodName": ["ReverseGetPrice"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder"}, {"methodBody": ["METHOD_START", "{", "int   price    =     0  ;", "int   m    =     1  ;", "for    ( int   i    =    NumBitLevels ;    i    !  =     0  ;    i -  -  )     {", "int   bit    =    symbol    &     1  ;", "symbol    >  >  >  =     1  ;", "price    +  =     . GetPrice ( Models [  ( startIndex    +    m )  ]  ,    bit )  ;", "m    =     ( m    <  <     1  )     |    bit ;", "}", "return   price ;", "}", "METHOD_END"], "methodName": ["ReverseGetPrice"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.BitTreeEncoder"}, {"methodBody": ["METHOD_START", "{", "int   prob    =    probs [ index ]  ;", "int   newBound    =     (  ( Range )     >  >  >     ( DkNumBitModelTotalBits )  )     *    prob ;", "if    (  (  ( Code )     ^     -  2  1  4  7  4  8  3  6  4  8  )     <     ( newBound    ^     -  2  1  4  7  4  8  3  6  4  8  )  )     {", "Range    =    newBound ;", "probs [ index ]     =     (  ( short )     ( prob    +     (  (  ( DkBitModelTotal )     -    prob )     >  >  >     ( DkNumMoveBits )  )  )  )  ;", "if    (  (  ( Range )     &     ( DkTopMask )  )     =  =     0  )     {", "Code    =     (  ( Code )     <  <     8  )     |     ( Stream . read (  )  )  ;", "Range    <  <  =     8  ;", "}", "return    0  ;", "} else    {", "Range    -  =    newBound ;", "Code    -  =    newBound ;", "probs [ index ]     =     (  ( short )     ( prob    -     ( prob    >  >  >     ( DkNumMoveBits )  )  )  )  ;", "if    (  (  ( Range )     &     ( DkTopMask )  )     =  =     0  )     {", "Code    =     (  ( Code )     <  <     8  )     |     ( Stream . read (  )  )  ;", "Range    <  <  =     8  ;", "}", "return    1  ;", "}", "}", "METHOD_END"], "methodName": ["DecodeBit"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Decoder"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( int   i    =    numTotalBits ;    i    !  =     0  ;    i -  -  )     {", "Range    >  >  >  =     1  ;", "int   t    =     (  ( Code )     -     ( Range )  )     >  >  >     3  1  ;", "Code    -  =     ( Range )     &     ( t    -     1  )  ;", "result    =     ( result    <  <     1  )     |     (  1     -    t )  ;", "if    (  (  ( Range )     &     (  . kTopMask )  )     =  =     0  )     {", "Code    =     (  ( Code )     <  <     8  )     |     ( Stream . read (  )  )  ;", "Range    <  <  =     8  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["DecodeDirectBits"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Decoder"}, {"methodBody": ["METHOD_START", "{", "Code    =     0  ;", "R    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )", "Code    =     (  ( Code )     <  <     8  )     |     ( Stream . read (  )  )  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Decoder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( probs . length )  ;    i +  +  )", "probs [ i ]     =     (  . kBitModelTotal )     >  >  >     1  ;", "}", "METHOD_END"], "methodName": ["InitBitModels"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Decoder"}, {"methodBody": ["METHOD_START", "{", "Stream    =    null ;", "}", "METHOD_END"], "methodName": ["ReleaseStream"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Decoder"}, {"methodBody": ["METHOD_START", "{", "Stream    =    stream ;", "}", "METHOD_END"], "methodName": ["SetStream"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Decoder"}, {"methodBody": ["METHOD_START", "{", "int   prob    =    probs [ index ]  ;", "int   newBound    =     (  ( Range )     >  >  >     (  . kNumBitModelTotalBits )  )     *    prob ;", "if    ( symbol    =  =     0  )     {", "Range    =    newBound ;", "probs [ index ]     =     (  ( short )     ( prob    +     (  (  (  . kBitModelTotal )     -    prob )     >  >  >     (  . kNumMoveBits )  )  )  )  ;", "} else    {", "Low    +  =    newBound    &     4  2  9  4  9  6  7  2  9  5 L ;", "Range    -  =    newBound ;", "probs [ index ]     =     (  ( short )     ( prob    -     ( prob    >  >  >     (  . kNumMoveBits )  )  )  )  ;", "}", "if    (  (  ( Range )     &     (  . kTopMask )  )     =  =     0  )     {", "Range    <  <  =     8  ;", "ShiftLow (  )  ;", "}", "}", "METHOD_END"], "methodName": ["Encode"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    numTotalBits    -     1  ;    i    >  =     0  ;    i -  -  )     {", "Range    >  >  >  =     1  ;", "if    (  (  ( v    >  >  >    i )     &     1  )     =  =     1  )", "Low    +  =    Range ;", "if    (  (  ( Range )     &     (  . kTopMask )  )     =  =     0  )     {", "Range    <  <  =     8  ;", "ShiftLow (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["EncodeDirectBits"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )", "ShiftLow (  )  ;", "}", "METHOD_END"], "methodName": ["FlushData"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "Stream . flush (  )  ;", "}", "METHOD_END"], "methodName": ["FlushStream"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "return   Encoder . ProbPrices [  (  (  (  ( Prob    -    symbol )     ^     (  - symbol )  )     &     (  ( Encoder . kBitModelTotal )     -     1  )  )     >  >  >     ( Encoder . kNumMoveReducingBits )  )  ]  ;", "}", "METHOD_END"], "methodName": ["GetPrice"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "return   Encoder . ProbPrices [  ( Prob    >  >  >     ( Encoder . kNumMoveReducingBits )  )  ]  ;", "}", "METHOD_END"], "methodName": ["GetPrice0"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "return   Encoder . ProbPrices [  (  (  ( Encoder . kBitModelTotal )     -    Prob )     >  >  >     ( Encoder . kNumMoveReducingBits )  )  ]  ;", "}", "METHOD_END"], "methodName": ["GetPrice1"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "return    (  (  _ cacheSize )     +     (  _ position )  )     +     4  ;", "}", "METHOD_END"], "methodName": ["GetProcessedSizeAdd"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "_ position    =     0  ;", "Low    =     0  ;", "R    =     -  1  ;", "_ cacheSize    =     1  ;", "_ cache    =     0  ;", "}", "METHOD_END"], "methodName": ["Init"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( probs . length )  ;    i +  +  )", "probs [ i ]     =     (  . kBitModelTotal )     >  >  >     1  ;", "}", "METHOD_END"], "methodName": ["InitBitModels"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "Stream    =    null ;", "}", "METHOD_END"], "methodName": ["ReleaseStream"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "Stream    =    stream ;", "}", "METHOD_END"], "methodName": ["SetStream"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "int   LowHi    =     (  ( int )     (  ( Low )     >  >  >     3  2  )  )  ;", "if    (  ( LowHi    !  =     0  )     |  |     (  ( Low )     <     4  2  7  8  1  9  0  0  8  0 L )  )     {", "_ posit    +  =     _ cacheSize ;", "int   temp    =     _ cache ;", "do    {", "Stream . write (  ( temp    +    LowHi )  )  ;", "temp    =     2  5  5  ;", "}    while    (  (  -  -  (  _ cacheSize )  )     !  =     0     )  ;", "_ cache    =     (  ( int )     ( Low )  )     >  >  >     2  4  ;", "}", "(  _ cacheSize )  +  +  ;", "Low    =     (  ( Low )     &     1  6  7  7  7  2  1  5  )     <  <     8  ;", "}", "METHOD_END"], "methodName": ["ShiftLow"], "fileName": "com.badlogic.gdx.utils.compression.rangecoder.Encoder"}, {"methodBody": ["METHOD_START", "{", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return    (  ( T )     ( annotation )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.Annotation"}, {"methodBody": ["METHOD_START", "{", "return   annotation . annotationType (  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "com.badlogic.gdx.utils.reflect.Annotation"}, {"methodBody": ["METHOD_START", "{", "return   Array . get ( array ,    index )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "return   Array . getLength ( array )  ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "return   Array . newInstance ( c ,    size )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "Array . set ( array ,    index ,    value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Class . forName ( name )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   Exception (  (  \" Class   not   found :     \"     +    name )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation   annotation    =    c . getAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )", "return   new   Annotation ( annotation )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    c . getAnnotations (  )  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . getComponentType (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Constructor ( c . getConstructor ( parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  \" Security   violation   occurred   while   getting   constructor   for   class :     '  \"     +     ( c . getName (  )  )  )     +     \"  '  .  \"  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  \" Constructor   not   found   for   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Constructor [  ]    constructors    =    c . getConstructors (  )  ;", "Constructor [  ]    result    =    new   Constructor [ constructors . length ]  ;", "for    ( int   i    =     0  ,    j    =    constructors . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Constructor ( constructors [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getConstructors"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    c . getDeclaredAnnotations (  )  ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )", "return   new   Annotation ( annotation )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    c . getDeclaredAnnotations (  )  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Constructor ( c . getDeclaredConstructor ( parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  \" Security   violation   while   getting   constructor   for   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  \" Constructor   not   found   for   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredConstructor"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Field ( c . getDeclaredField ( name )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   field :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchFieldException   e )     {", "throw   new   Exception (  (  (  (  \" Field   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredField"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Field [  ]    fields    =    c . getDeclaredFields (  )  ;", "Field [  ]    result    =    new   Field [ fields . length ]  ;", "for    ( int   i    =     0  ,    j    =    fields . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Field ( fields [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredFields"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Method ( c . getDeclaredMethod ( name ,    parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   method :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  (  (  \" Method   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredMethod"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    c . getDeclaredMethods (  )  ;", "Method [  ]    result    =    new   Method [ methods . length ]  ;", "for    ( int   i    =     0  ,    j    =    methods . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Method ( methods [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredMethods"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . getEnumConstants (  )  ;", "}", "METHOD_END"], "methodName": ["getEnumConstants"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Field ( c . getField ( name )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   field :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchFieldException   e )     {", "throw   new   Exception (  (  (  (  \" Field   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Field [  ]    fields    =    c . getFields (  )  ;", "Field [  ]    result    =    new   Field [ fields . length ]  ;", "for    ( int   i    =     0  ,    j    =    fields . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Field ( fields [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getFields"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . getInterfaces (  )  ;", "}", "METHOD_END"], "methodName": ["getInterfaces"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Method ( c . getMethod ( name ,    parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   method :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  (  (  \" Method   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    c . getMethods (  )  ;", "Method [  ]    result    =    new   Method [ methods . length ]  ;", "for    ( int   i    =     0  ,    j    =    methods . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Method ( methods [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . getSimpleName (  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isAbstract ( c . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isAbstract"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isAnnotation (  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isAnnotationPresent ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isArray (  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c 1  . isAssignableFrom ( c 2  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isEnum (  )  ;", "}", "METHOD_END"], "methodName": ["isEnum"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isInstance ( obj )  ;", "}", "METHOD_END"], "methodName": ["isInstance"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isInterface (  )  ;", "}", "METHOD_END"], "methodName": ["isInterface"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isMemberClass (  )  ;", "}", "METHOD_END"], "methodName": ["isMemberClass"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . isPrimitive (  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitive"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isStatic ( c . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isStaticClass"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   c . newInstance (  )  ;", "}    catch    ( InstantiationException   e )     {", "throw   new   Exception (  (  \" Could   not   instantiate   instance   of   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   Exception (  (  \" Could   not   instantiate   instance   of   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   constructor . getDeclaringClass (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "return   constructor . getParameterTypes (  )  ;", "}", "METHOD_END"], "methodName": ["getParameterTypes"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "return   constructor . isAccessible (  )  ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   c . newInstance ( args )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   ReflectionException (  (  \" Illegal   argument ( s )    supplied   to   c   for   class :     \"     +     ( getDeclaringClass (  )  . getName (  )  )  )  ,    e )  ;", "}    catch    ( InstantiationException   e )     {", "throw   new   ReflectionException (  (  \" Could   not   instantiate   instance   of   class :     \"     +     ( getDeclaringClass (  )  . getName (  )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   ReflectionException (  (  \" Could   not   instantiate   instance   of   class :     \"     +     ( getDeclaringClass (  )  . getName (  )  )  )  ,    e )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   new   ReflectionException (  (  \" Exception   occurred   in   c   for   class :     \"     +     ( getDeclaringClass (  )  . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "constructor . setAccessible ( accessible )  ;", "}", "METHOD_END"], "methodName": ["setAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   field . get ( obj )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   RionException (  (  \" Object   is   not   an   instance   of    \"     +     ( getDeclaringClass (  )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RionException (  (  \" Illegal   access   to   field :     \"     +     ( getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    field . getDeclaredAnnotations (  )  ;", "if    ( annotations    =  =    null )     {", "return   null ;", "}", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return   new   Annotation ( annotation )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    field . getDeclaredAnnotations (  )  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . getDeclaringClass (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Type   genericType    =    field . getGenericType (  )  ;", "if    ( genericType   instanceof   ParameterizedType )     {", "Type [  ]    actualTypes    =     (  ( ParameterizedType )     ( genericType )  )  . getActualTypeArguments (  )  ;", "if    (  (  ( actualTypes . length )     -     1  )     >  =    index )     {", "Type   actualType    =    actualTypes [ index ]  ;", "if    ( actualType   instanceof   Class )", "return    (  ( Class )     ( actualType )  )  ;", "else", "if    ( actualType   instanceof   ParameterizedType )", "return    (  ( Class )     (  (  ( ParameterizedType )     ( actualType )  )  . getRawType (  )  )  )  ;", "else", "if    ( actualType   instanceof   langGenericArrayType )     {", "Type   componentType    =     (  ( langGenericArrayType )     ( actualType )  )  . getGenericComponentType (  )  ;", "if    ( componentType   instanceof   Class )", "return   ArrayReflection . newInstance (  (  ( Class )     ( componentType )  )  ,     0  )  . getClass (  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isAccessible (  )  ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isAnnotationPresent ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( isPrivate (  )  )  )     &  &     (  !  ( isProtected (  )  )  )  )     &  &     (  !  ( isPublic (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultAccess"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isFinal ( field . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isFinal"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isPrivate ( field . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPrivate"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isProtected ( field . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isProtected"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isPublic ( field . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isStatic ( field . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isStatic"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isSynthetic (  )  ;", "}", "METHOD_END"], "methodName": ["isSynthetic"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isTransient ( field . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isTransient"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isVolatile ( field . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isVolatile"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "try    {", "field . set ( obj ,    value )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   RionException (  (  \" Argument   not   valid   for   field :     \"     +     ( getName (  )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RionException (  (  \" Illegal   access   to   field :     \"     +     ( getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "field . setAccessible ( accessible )  ;", "}", "METHOD_END"], "methodName": ["setAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    method . getDeclaredAnnotations (  )  ;", "if    ( annotations    =  =    null )     {", "return   null ;", "}", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return   new   Annotation ( annotation )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    method . getDeclaredAnnotations (  )  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . getDeclaringClass (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . getParameterTypes (  )  ;", "}", "METHOD_END"], "methodName": ["getParameterTypes"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . getReturnType (  )  ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   method . invoke ( obj ,    args )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   RionException (  (  \" Illegal   argument ( s )    supplied   to   method :     \"     +     ( getName (  )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RionException (  (  \" Illegal   access   to   method :     \"     +     ( getName (  )  )  )  ,    e )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   new   RionException (  (  \" Exception   occurred   in   method :     \"     +     ( getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isAbstract ( method . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isAbstract"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isAccessible (  )  ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isAnnotationPresent ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( isPrivate (  )  )  )     &  &     (  !  ( isProtected (  )  )  )  )     &  &     (  !  ( isPublic (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultAccess"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isFinal ( method . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isFinal"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isNative ( method . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isNative"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isPrivate ( method . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPrivate"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isProtected ( method . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isProtected"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isPublic ( method . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isStatic ( method . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isStatic"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isVarArgs (  )  ;", "}", "METHOD_END"], "methodName": ["isVarArgs"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "method . setAccessible ( accessible )  ;", "}", "METHOD_END"], "methodName": ["setAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   maxWorldHeight ;", "}", "METHOD_END"], "methodName": ["getMaxWorldHeight"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "return   maxWorldWidth ;", "}", "METHOD_END"], "methodName": ["getMaxWorldWidth"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "return   minWorldHeight ;", "}", "METHOD_END"], "methodName": ["getMinWorldHeight"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "return   minWorldWidth ;", "}", "METHOD_END"], "methodName": ["getMinWorldWidth"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "this . maxWorldHeight    =    maxWorldHeight ;", "}", "METHOD_END"], "methodName": ["setMaxWorldHeight"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "this . maxWorldWidth    =    maxWorldWidth ;", "}", "METHOD_END"], "methodName": ["setMaxWorldWidth"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "this . minWorldHeight    =    minWorldHeight ;", "}", "METHOD_END"], "methodName": ["setMinWorldHeight"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "this . minWorldWidth    =    minWorldWidth ;", "}", "METHOD_END"], "methodName": ["setMinWorldWidth"], "fileName": "com.badlogic.gdx.utils.viewport.ExtendViewport"}, {"methodBody": ["METHOD_START", "{", "return   scaling ;", "}", "METHOD_END"], "methodName": ["getScaling"], "fileName": "com.badlogic.gdx.utils.viewport.ScalingViewport"}, {"methodBody": ["METHOD_START", "{", "this . scaling    =    scaling ;", "}", "METHOD_END"], "methodName": ["setScaling"], "fileName": "com.badlogic.gdx.utils.viewport.ScalingViewport"}, {"methodBody": ["METHOD_START", "{", "return   unitsPerPixel ;", "}", "METHOD_END"], "methodName": ["getUnitsPerPixel"], "fileName": "com.badlogic.gdx.utils.viewport.ScreenViewport"}, {"methodBody": ["METHOD_START", "{", "this . unitsPerPixel    =    unitsPerPixel ;", "}", "METHOD_END"], "methodName": ["setUnitsPerPixel"], "fileName": "com.badlogic.gdx.utils.viewport.ScreenViewport"}, {"methodBody": ["METHOD_START", "{", "apply ( false )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "HdpiUtils . glViewport ( screenX ,    screenY ,    screenWidth ,    screenHeight )  ;", "cameraWidth    =    worldWidth ;", "cameraHeight    =    worldHeight ;", "if    ( centerCamera )", "camera . position . set (  (  ( worldWidth )     /     2  )  ,     (  ( worldHeight )     /     2  )  ,     0  )  ;", "camera . update (  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "ScissorStack . calculateScissors ( camera ,    screenX ,    screenY ,    screenWidth ,    screenHeight ,    batchTransform ,    area ,    scissor )  ;", "}", "METHOD_END"], "methodName": ["calculateScissors"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   screenY ;", "}", "METHOD_END"], "methodName": ["getBottomGutterHeight"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   camera ;", "}", "METHOD_END"], "methodName": ["getCamera"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   screenX ;", "}", "METHOD_END"], "methodName": ["getLeftGutterWidth"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   camera . getPickRay ( screenX ,    screenY ,    this . screenX ,    this . screenY ,    screenWidth ,    screenHeight )  ;", "}", "METHOD_END"], "methodName": ["getPickRay"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return    ( Gdx . graphics . getWidth (  )  )     -     (  ( screenX )     +     ( screenWidth )  )  ;", "}", "METHOD_END"], "methodName": ["getRightGutterWidth"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return    ( screenX )     +     ( screenWidth )  ;", "}", "METHOD_END"], "methodName": ["getRightGutterX"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   screenHeight ;", "}", "METHOD_END"], "methodName": ["getScreenHeight"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   screenWidth ;", "}", "METHOD_END"], "methodName": ["getScreenWidth"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   screenX ;", "}", "METHOD_END"], "methodName": ["getScreenX"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   screenY ;", "}", "METHOD_END"], "methodName": ["getScreenY"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return    ( Gdx . graphics . getHeight (  )  )     -     (  ( screenY )     +     ( screenHeight )  )  ;", "}", "METHOD_END"], "methodName": ["getTopGutterHeight"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return    ( screenY )     +     ( screenHeight )  ;", "}", "METHOD_END"], "methodName": ["getTopGutterY"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   worldHeight ;", "}", "METHOD_END"], "methodName": ["getWorldHeight"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "return   worldWidth ;", "}", "METHOD_END"], "methodName": ["getWorldWidth"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( worldCoords . x ,    worldCoords . y ,     1  )  ;", "camera . project ( tmp ,    screenX ,    screenY ,    screenWidth ,    screenHeight )  ;", "worldCoords . set ( tmp . x ,    tmp . y )  ;", "return   worldCoords ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "camera . project ( worldCoords ,    screenX ,    screenY ,    screenWidth ,    screenHeight )  ;", "return   worldCoords ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . camera    =    camera ;", "}", "METHOD_END"], "methodName": ["setCamera"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . screenX    =    screenX ;", "this . screenY    =    screenY ;", "this . screenWidth    =    screenWidth ;", "this . screenHeight    =    screenHeight ;", "}", "METHOD_END"], "methodName": ["setScreenBounds"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . screenHeight    =    screenHeight ;", "}", "METHOD_END"], "methodName": ["setScreenHeight"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . screenX    =    screenX ;", "this . screenY    =    screenY ;", "}", "METHOD_END"], "methodName": ["setScreenPosition"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . screenWidth    =    screenWidth ;", "this . screenHeight    =    screenHeight ;", "}", "METHOD_END"], "methodName": ["setScreenSize"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . screenWidth    =    screenWidth ;", "}", "METHOD_END"], "methodName": ["setScreenWidth"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . screenX    =    screenX ;", "}", "METHOD_END"], "methodName": ["setScreenX"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . screenY    =    screenY ;", "}", "METHOD_END"], "methodName": ["setScreenY"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . worldHeight    =    worldHeight ;", "}", "METHOD_END"], "methodName": ["setWorldHeight"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . worldWidth    =    worldWidth ;", "this . worldHeight    =    worldHeight ;", "}", "METHOD_END"], "methodName": ["setWorldSize"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "this . worldWidth    =    worldWidth ;", "}", "METHOD_END"], "methodName": ["setWorldWidth"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( worldCoords . x ,    worldCoords . y ,     0  )  ;", "tmp . mul ( transformMatrix )  ;", "camera . project ( tmp )  ;", "tmp . y    =     ( Ggraphics . getHeight (  )  )     -     ( tmp . y )  ;", "worldCoords . x    =    tmp . x ;", "worldCoords . y    =    tmp . y ;", "return   worldCoords ;", "}", "METHOD_END"], "methodName": ["toScreenCoordinates"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( screenCoords . x ,    screenCoords . y ,     1  )  ;", "camera . unproject ( tmp ,    screenX ,    screenY ,    screenWidth ,    screenHeight )  ;", "screenCoords . set ( tmp . x ,    tmp . y )  ;", "return   screenCoords ;", "}", "METHOD_END"], "methodName": ["unproject"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "camera . unproject ( screenCoords ,    screenX ,    screenY ,    screenWidth ,    screenHeight )  ;", "return   screenCoords ;", "}", "METHOD_END"], "methodName": ["unproject"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "update ( screenWidth ,    screenHeight ,    false )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}, {"methodBody": ["METHOD_START", "{", "apply ( centerCamera )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.utils.viewport.Viewport"}]