[{"methodBody": ["METHOD_START", "{", "try    {", "setGlobals (  )  ;", "graphics . initiateGL (  )  ;", "c . setVSyncEnabled ( graphics . config . vSyncEnabled )  ;", "listener . create (  )  ;", "lastWidth    =    Math . max (  1  ,    graphics . getWidth (  )  )  ;", "lastHeight    =    Math . max (  1  ,    graphics . getHeight (  )  )  ;", "listener . resize ( lastWidth ,    lastHeight )  ;", "start (  )  ;", "}    catch    ( Throwable   ex )     {", "stopped (  )  ;", "exception ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "ex . printStackTrace (  )  ;", "stop (  )  ;", "}", "METHOD_END"], "methodName": ["exception"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "nchronized ( runnable    {", "for    ( int   i    =     ( runnableze )     -     1  ;    i    >  =     0  ;    i -  -  )", "executedRunnableaddAll ( runnableget ( i )  )  ;", "runnableclear (  )  ;", "}", "if    (  ( executedRunnableze )     =  =     0  )", "return   fal ;", "do", "executedRunnablepop (  )  . run (  )  ;", "while    (  ( executedRunnableze )     >     0     )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["executeRunnables"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "return   canvas ;", "}", "METHOD_END"], "methodName": ["getCanvas"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "int   frameRate    =     ( isActive (  )  )     ?    graphics . config . foregroundFPS    :    graphics . config . backgroundFPS ;", "if    ( frameRate    =  =     (  -  1  )  )", "frameRate    =     1  0  ;", "if    ( frameRate    =  =     0  )", "frameRate    =    graphics . config . backgroundFPS ;", "if    ( frameRate    =  =     0  )", "frameRate    =     3  0  ;", "return   frameRate ;", "}", "METHOD_END"], "methodName": ["getFrameRate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "Component   root    =    SwingUtilities . getRoot ( canvas )  ;", "return   root   instanceof   Frame    ?     (  ( Frame )     ( root )  )  . isActive (  )     :    true ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   canvas . isCurrent (  )  ;", "}    catch    ( Throwable   ex )     {", "exception ( ex )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isCurrent"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "try    {", "canvas . makeCurrent (  )  ;", "setGlobals (  )  ;", "}    catch    ( Throwable   ex )     {", "exception ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["makeCurrent"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( running )  )", "return ;", "setGlobals (  )  ;", "canvas . setCursor ( cursor )  ;", "int   width    =    Math . max (  1  ,    graphics . getWidth (  )  )  ;", "int   height    =    Math . max (  1  ,    graphics . getHeight (  )  )  ;", "if    (  (  ( lastWidth )     !  =    width )     |  |     (  ( lastHeight )     !  =    height )  )     {", "lastWidth    =    width ;", "lastHeight    =    height ;", "gl . glViewport (  0  ,     0  ,    lastWidth ,    lastHeight )  ;", "resize ( width ,    height )  ;", "listener . resize ( width ,    height )  ;", "shouldRender    =    true ;", "}", "if    ( executeRunnables (  )  )", "shouldRender    =    true ;", "if    (  !  ( running )  )", "return ;", "shouldRender    |  =    graphics . shouldRender (  )  ;", "input . processEvents (  )  ;", "if    (  ( audio )     !  =    null )", "audio . update (  )  ;", "if    ( shouldRender )     {", "graphics . updateTime (  )  ;", "( graphics . frameId )  +  +  ;", "listener . render (  )  ;", "canvas . swapBuffers (  )  ;", "}", "Display . sync (  (  ( getFrameRate (  )  )     *     (  . instanceCount )  )  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "this . cursor    =    cursor ;", "}", "METHOD_END"], "methodName": ["setCursor"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "Gdx . app    =    this ;", "if    (  ( audio )     !  =    null )", "Gdx . audio    =    audio ;", "if    (  ( files )     !  =    null )", "Gdx . files    =    files ;", "if    (  ( net )     !  =    null )", "Gdx . net    =    net ;", "Gdx . graphics    =    graphics ;", "Gdx . input    =    input ;", "}", "METHOD_END"], "methodName": ["setGlobals"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( running )  )", "return ;", "running    =    false ;", "setGlobals (  )  ;", "Array < LifecycleListener >    listeners    =    lifecycleListeners ;", "if    ( canvas . isDisplayable (  )  )     {", "makeCurrent (  )  ;", "} else    {", "error ( logTag ,     \" OpenGL   context   destroyed   before   application   listener   has   had   a   chance   to   dispose   of   textures .  \"  )  ;", "}", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . pause (  )  ;", "listener . dispose (  )  ;", "}", "}", "listener . pause (  )  ;", "listener . dispose (  )  ;", "Gdx . app    =    null ;", "Gdx . graphics    =    null ;", "if    (  ( audio )     !  =    null )     {", "audio . dispose (  )  ;", "Gdx . audio    =    null ;", "}", "if    (  ( files )     !  =    null )", "Gdx . files    =    null ;", "if    (  ( net )     !  =    null )", "Gdx . net    =    null ;", "(  . instanceCount )  -  -  ;", "stopped (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTCanvas"}, {"methodBody": ["METHOD_START", "{", "return   lwjglAWTCanvas ;", "}", "METHOD_END"], "methodName": ["getLwjglAWTCanvas"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTFrame"}, {"methodBody": ["METHOD_START", "{", "if    ( halt )     {", "if    (  ( shutdownHook )     !  =    null )", "return ;", "shutdownHook    =    new   Thre (  )     {", "public   void   run (  )     {", "Runtime . getRuntime (  )  . halt (  0  )  ;", "}", "}  ;", "Runtime . getRuntime (  )  . dShutdownHook ( shutdownHook )  ;", "} else", "if    (  ( shutdownHook )     !  =    null )     {", "Runtime . getRuntime (  )  . removeShutdownHook ( shutdownHook )  ;", "shutdownHook    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setHaltOnShutdown"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTFrame"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( catched )     &  &     (  ( robot )     !  =    null )  )     &  &     ( canvas . isShowing (  )  )  )     {", "int   x    =     ( Math . max (  0  ,     (  ( Math . min ( e . getX (  )  ,    canvas . getWidth (  )  )  )     -     1  )  )  )     +     ( canvas . getLocationOnScreen (  )  . x )  ;", "int   y    =     ( Math . max (  0  ,     (  ( Math . min ( e . getY (  )  ,    canvas . getHeight (  )  )  )     -     1  )  )  )     +     ( canvas . getLocationOnScreen (  )  . y )  ;", "if    (  (  (  (  ( e . getX (  )  )     <     0  )     |  |     (  ( e . getX (  )  )     >  =     ( canvas . getWidth (  )  )  )  )     |  |     (  ( e . getY (  )  )     <     0  )  )     |  |     (  ( e . getY (  )  )     >  =     ( canvas . getHeight (  )  )  )  )     {", "robot . mouseMove ( x ,    y )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkCatched"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "Container   parent    =    component . getParent (  )  ;", "while    ( parent    !  =    null )     {", "if    ( parent   instanceof   JFrame )     {", "return    (  ( JFrame )     ( parent )  )  ;", "}", "parent    =    parent . getParent (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findJFrame"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "SwingUtilities . invokeLater ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "JPanel   panel    =    new   JPanel ( new   FlowLayout (  )  )  ;", "JPanel   textPanel    =    new   JPanel (  )     {", "public   boolean   isOptimizedDrawingEnabled (  )     {", "return   false ;", "}", "}  ;", "textPanel . setLayout ( new   OverlayLayout ( textPanel )  )  ;", "panel . add ( textPanel )  ;", "final   JTextField   textField    =    new   JTextField (  2  0  )  ;", "textField . setText ( text )  ;", "textField . setAlignmentX (  0  .  0 F )  ;", "textPanel . add ( textField )  ;", "final   JLabel   placeholderLabel    =    new   JLabel ( hint )  ;", "placeholderLabel . setForeground ( Color . GRAY )  ;", "placeholderLabel . setAlignmentX (  0  .  0 F )  ;", "textPanel . add ( placeholderLabel ,     0  )  ;", "textField . getDocument (  )  . addDocumentListener ( new   DocumentListener (  )     {", "@ Override", "public   void   removeUpdate ( DocumentEvent   arg 0  )     {", "this . updated (  )  ;", "}", "@ Override", "public   void   insertUpdate ( DocumentEvent   arg 0  )     {", "this . updated (  )  ;", "}", "@ Override", "public   void   changedUpdate ( DocumentEvent   arg 0  )     {", "this . updated (  )  ;", "}", "private   void   updated (  )     {", "if    (  ( textField . getText (  )  . length (  )  )     =  =     0  )", "placeholderLabel . setVisible ( true )  ;", "else", "placeholderLabel . setVisible ( false )  ;", "}", "}  )  ;", "JOptionPane   pane    =    new   JOptionPane ( panel ,    JOptionPane . QUESTION _ MESSAGE ,    JOptionPane . OK _ CANCEL _ OPTION ,    null ,    null ,    null )  ;", "pane . setInitialValue ( null )  ;", "pane . setComponentOrientation ( JOptionPane . getRootFrame (  )  . getComponentOrientation (  )  )  ;", "Border   border    =    textField . getBorder (  )  ;", "placeholderLabel . setBorder ( new   EmptyBorder ( border . getBorderInsets ( textField )  )  )  ;", "JDialog   dialog    =    pane . createDialog ( null ,    title )  ;", "pane . selectInitialValue (  )  ;", "dialog . addWindowFocusListener ( new   WindowFocusListener (  )     {", "@ Override", "public   void   windowLostFocus ( WindowEvent   arg 0  )     {", "}", "@ Override", "public   void   windowGainedFocus ( WindowEvent   arg 0  )     {", "textField . requestFocusInWindow (  )  ;", "}", "}  )  ;", "dialog . setVisible ( true )  ;", "dialog . dispose (  )  ;", "Object   selectedValue    =    pane . getValue (  )  ;", "if    (  (  ( selectedValue    !  =    null )     &  &     ( selectedValue   instanceof   Integer )  )     &  &     (  (  (  ( Integer )     ( selectedValue )  )  . intValue (  )  )     =  =     ( JOptionPane . OK _ OPTION )  )  )     {", "listener . i ( textField . getText (  )  )  ;", "} else    {", "listener . canceled (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getTextInput"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "justTouched    =    false ;", "if    ( keyJustPressed )     {", "keyJustPressed    =    false ;", "for    ( int   i    =     0  ;    i    <     ( justPressedKeys . length )  ;    i +  +  )     {", "justPressedKeys [ i ]     =    false ;", "}", "}", "if    (  ( processor )     !  =    null )     {", "InputProcessor   processor    =    this . processor ;", "int   len    =    keyEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". KeyEvent   e    =    keyEvents . get ( i )  ;", "currentEventTimeStamp    =    e . timeStamp ;", "switch    ( e . type )     {", "case    . KeyEvent . KEY _ DOWN    :", "processor . keyDown ( e . keyCode )  ;", "keyJustPressed    =    true ;", "justPressedKeys [ e . keyCode ]     =    true ;", "break ;", "case    . KeyEvent . KEY _ UP    :", "processor . keyUp ( e . keyCode )  ;", "break ;", "case    . KeyEvent . KEY _ TYPED    :", "processor . keyTyped ( e . keyChar )  ;", "}", "usedKeyEvents . free ( e )  ;", "}", "len    =    touchEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". TouchEvent   e    =    touchEvents . get ( i )  ;", "currentEventTimeStamp    =    e . timeStamp ;", "switch    ( e . type )     {", "case    . TouchEvent . TOUCH _ DOWN    :", "processor . touchDown ( e . x ,    e . y ,    e . pointer ,    e . button )  ;", "justTouched    =    true ;", "break ;", "case    . TouchEvent . TOUCH _ UP    :", "processor . touchUp ( e . x ,    e . y ,    e . pointer ,    e . button )  ;", "break ;", "case    . TouchEvent . TOUCH _ DRAGGED    :", "processor . touchDragged ( e . x ,    e . y ,    e . pointer )  ;", "break ;", "case    . TouchEvent . TOUCH _ MOVED    :", "processor . mouseMoved ( e . x ,    e . y )  ;", "break ;", "case    . TouchEvent . TOUCH _ SCROLLED    :", "processor . scrolled ( e . scrollAmount )  ;", "break ;", "}", "usedTouchEvents . free ( e )  ;", "}", "} else    {", "int   len    =    touchEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". TouchEvent   event    =    touchEvents . get ( i )  ;", "if    (  ( event . type )     =  =     (  . TouchEvent . TOUCH _ DOWN )  )", "justTouched    =    true ;", "usedTouchEvents . free ( event )  ;", "}", "len    =    keyEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "usedKeyEvents . free ( keyEvents . get ( i )  )  ;", "}", "}", "if    (  ( touchEvents . size (  )  )     =  =     0  )     {", "deltaX    =     0  ;", "deltaY    =     0  ;", "}", "keyEvents . clear (  )  ;", "touchEvents . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processEvents"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . canvas )     !  =    null )     {", "canvas . removeMouseListener ( this )  ;", "canvas . removeMouseMotionListener ( this )  ;", "canvas . removeMouseWheelListener ( this )  ;", "canvas . removeKeyListener ( this )  ;", "}", "canvas . addMouseListener ( this )  ;", "canvas . addMouseMotionListener ( this )  ;", "canvas . addMouseWheelListener ( this )  ;", "canvas . addKeyListener ( this )  ;", "canvas . setFocusTraversalKeysEnabled ( false )  ;", "this . canvas    =    canvas ;", "}", "METHOD_END"], "methodName": ["setListeners"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "if    (  ! visible )     {", "Toolkit   t    =    Toolkit . getDefaultToolkit (  )  ;", "Image   i    =    new   BufferedImage (  1  ,     1  ,    BufferedImage . TYPE _ INT _ ARGB )  ;", "Cursor   noCursor    =    t . createCustomCursor ( i ,    new   Point (  0  ,     0  )  ,     \" none \"  )  ;", "JFrame   frame    =     . findJFrame ( canvas )  ;", "frame . setCursor ( noCursor )  ;", "} else    {", "JFrame   frame    =     . findJFrame ( canvas )  ;", "frame . setCursor ( Cursor . getDefaultCursor (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["showCursor"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "if    ( swingButton    =  =     ( MouseEvent . BUTTON 1  )  )", "return   Buttons . LEFT ;", "if    ( swingButton    =  =     ( MouseEvent . BUTTON 2  )  )", "return   Buttons . MIDDLE ;", "if    ( swingButton    =  =     ( MouseEvent . BUTTON 3  )  )", "return   Buttons . RIGHT ;", "return   Buttons . LEFT ;", "}", "METHOD_END"], "methodName": ["toGdxButton"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "switch    ( keyCode )     {", "case   KeyEvent . VK _  0     :", "return   Keys . NUM _  0  ;", "case   KeyEvent . VK _  1     :", "return   Keys . NUM _  1  ;", "case   KeyEvent . VK _  2     :", "return   Keys . NUM _  2  ;", "case   KeyEvent . VK _  3     :", "return   Keys . NUM _  3  ;", "case   KeyEvent . VK _  4     :", "return   Keys . NUM _  4  ;", "case   KeyEvent . VK _  5     :", "return   Keys . NUM _  5  ;", "case   KeyEvent . VK _  6     :", "return   Keys . NUM _  6  ;", "case   KeyEvent . VK _  7     :", "return   Keys . NUM _  7  ;", "case   KeyEvent . VK _  8     :", "return   Keys . NUM _  8  ;", "case   KeyEvent . VK _  9     :", "return   Keys . NUM _  9  ;", "case   KeyEvent . VK _ A    :", "return   Keys . A ;", "case   KeyEvent . VK _ B    :", "return   Keys . B ;", "case   KeyEvent . VK _ C    :", "return   Keys . C ;", "case   KeyEvent . VK _ D    :", "return   Keys . D ;", "case   KeyEvent . VK _ E    :", "return   Keys . E ;", "case   KeyEvent . VK _ F    :", "return   Keys . F ;", "case   KeyEvent . VK _ G    :", "return   Keys . G ;", "case   KeyEvent . VK _ H    :", "return   Keys . H ;", "case   KeyEvent . VK _ I    :", "return   Keys . I ;", "case   KeyEvent . VK _ J    :", "return   Keys . J ;", "case   KeyEvent . VK _ K    :", "return   Keys . K ;", "case   KeyEvent . VK _ L    :", "return   Keys . L ;", "case   KeyEvent . VK _ M    :", "return   Keys . M ;", "case   KeyEvent . VK _ N    :", "return   Keys . N ;", "case   KeyEvent . VK _ O    :", "return   Keys . O ;", "case   KeyEvent . VK _ P    :", "return   Keys . P ;", "case   KeyEvent . VK _ Q    :", "return   Keys . Q ;", "case   KeyEvent . VK _ R    :", "return   Keys . R ;", "case   KeyEvent . VK _ S    :", "return   Keys . S ;", "case   KeyEvent . VK _ T    :", "return   Keys . T ;", "case   KeyEvent . VK _ U    :", "return   Keys . U ;", "case   KeyEvent . VK _ V    :", "return   Keys . V ;", "case   KeyEvent . VK _ W    :", "return   Keys . W ;", "case   KeyEvent . VK _ X    :", "return   Keys . X ;", "case   KeyEvent . VK _ Y    :", "return   Keys . Y ;", "case   KeyEvent . VK _ Z    :", "return   Keys . Z ;", "case   KeyEvent . VK _ ALT    :", "return   Keys . ALT _ LEFT ;", "case   KeyEvent . VK _ ALT _ GRAPH    :", "return   Keys . ALT _ RIGHT ;", "case   KeyEvent . VK _ BACK _ SLASH    :", "return   Keys . BACKSLASH ;", "case   KeyEvent . VK _ COMMA    :", "return   Keys . COMMA ;", "case   KeyEvent . VK _ DELETE    :", "return   Keys . FORWARD _ DEL ;", "case   KeyEvent . VK _ LEFT    :", "return   Keys . DPAD _ LEFT ;", "case   KeyEvent . VK _ RIGHT    :", "return   Keys . DPAD _ RIGHT ;", "case   KeyEvent . VK _ UP    :", "return   Keys . DPAD _ UP ;", "case   KeyEvent . VK _ DOWN    :", "return   Keys . DPAD _ DOWN ;", "case   KeyEvent . VK _ ENTER    :", "return   Keys . ENTER ;", "case   KeyEvent . VK _ HOME    :", "return   Keys . HOME ;", "case   KeyEvent . VK _ MINUS    :", "return   Keys . MINUS ;", "case   KeyEvent . VK _ PERIOD    :", "return   Keys . PERIOD ;", "case   KeyEvent . VK _ PLUS    :", "case   KeyEvent . VK _ ADD    :", "return   Keys . PLUS ;", "case   KeyEvent . VK _ SEMICOLON    :", "return   Keys . SEMICOLON ;", "case   KeyEvent . VK _ SHIFT    :", "return   Keys . SHIFT _ LEFT ;", "case   KeyEvent . VK _ SLASH    :", "return   Keys . SLASH ;", "case   KeyEvent . VK _ SPACE    :", "return   Keys . SPACE ;", "case   KeyEvent . VK _ TAB    :", "return   Keys . TAB ;", "case   KeyEvent . VK _ BACK _ SPACE    :", "return   Keys . DEL ;", "case   KeyEvent . VK _ QUOTE    :", "return   Keys . APOSTROPHE ;", "case   KeyEvent . VK _ ASTERISK    :", "case   KeyEvent . VK _ MULTIPLY    :", "return   Keys . STAR ;", "case   KeyEvent . VK _ SUBTRACT    :", "return   Keys . MINUS ;", "case   KeyEvent . VK _ CONTROL    :", "return   Keys . CONTROL _ LEFT ;", "case   KeyEvent . VK _ ESCAPE    :", "return   Keys . ESCAPE ;", "case   KeyEvent . VK _ END    :", "return   Keys . END ;", "case   KeyEvent . VK _ INSERT    :", "return   Keys . INSERT ;", "case   KeyEvent . VK _ PAGE _ UP    :", "return   Keys . PAGE _ UP ;", "case   KeyEvent . VK _ PAGE _ DOWN    :", "return   Keys . PAGE _ DOWN ;", "case   KeyEvent . VK _ F 1     :", "return   Keys . F 1  ;", "case   KeyEvent . VK _ F 2     :", "return   Keys . F 2  ;", "case   KeyEvent . VK _ F 3     :", "return   Keys . F 3  ;", "case   KeyEvent . VK _ F 4     :", "return   Keys . F 4  ;", "case   KeyEvent . VK _ F 5     :", "return   Keys . F 5  ;", "case   KeyEvent . VK _ F 6     :", "return   Keys . F 6  ;", "case   KeyEvent . VK _ F 7     :", "return   Keys . F 7  ;", "case   KeyEvent . VK _ F 8     :", "return   Keys . F 8  ;", "case   KeyEvent . VK _ F 9     :", "return   Keys . F 9  ;", "case   KeyEvent . VK _ F 1  0     :", "return   Keys . F 1  0  ;", "case   KeyEvent . VK _ F 1  1     :", "return   Keys . F 1  1  ;", "case   KeyEvent . VK _ F 1  2     :", "return   Keys . F 1  2  ;", "case   KeyEvent . VK _ COLON    :", "return   Keys . COLON ;", "case   KeyEvent . VK _ NUMPAD 0     :", "return   Keys . NUM _  0  ;", "case   KeyEvent . VK _ NUMPAD 1     :", "return   Keys . NUM _  1  ;", "case   KeyEvent . VK _ NUMPAD 2     :", "return   Keys . NUM _  2  ;", "case   KeyEvent . VK _ NUMPAD 3     :", "return   Keys . NUM _  3  ;", "case   KeyEvent . VK _ NUMPAD 4     :", "return   Keys . NUM _  4  ;", "case   KeyEvent . VK _ NUMPAD 5     :", "return   Keys . NUM _  5  ;", "case   KeyEvent . VK _ NUMPAD 6     :", "return   Keys . NUM _  6  ;", "case   KeyEvent . VK _ NUMPAD 7     :", "return   Keys . NUM _  7  ;", "case   KeyEvent . VK _ NUMPAD 8     :", "return   Keys . NUM _  8  ;", "case   KeyEvent . VK _ NUMPAD 9     :", "return   Keys . NUM _  9  ;", "}", "return   Keys . UNKNOWN ;", "}", "METHOD_END"], "methodName": ["translateKeyCode"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglAWTInput"}, {"methodBody": ["METHOD_START", "{", "remove ( canvas )  ;", "super . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplet"}, {"methodBody": ["METHOD_START", "{", "LwjglApplicationConfiguration   config    =    new   LwjglApplicationConfiguration (  )  ;", "config . title    =    title ;", "config . width    =    width ;", "config . height    =    height ;", "config . vSyncEnabled    =    true ;", "return   config ;", "}", "METHOD_END"], "methodName": ["createConfig"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplication"}, {"methodBody": ["METHOD_START", "{", "synchronized ( runnables )     {", "for    ( int   i    =     ( runnables . size )     -     1  ;    i    >  =     0  ;    i -  -  )", "executedRunnables . add ( runnables . get ( i )  )  ;", "runnables . clear (  )  ;", "}", "if    (  ( executedRunnables . size )     =  =     0  )", "return   false ;", "do", "executedRunnables . pop (  )  . run (  )  ;", "while    (  ( executedRunnables . size )     >     0     )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["executeRunnables"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplication"}, {"methodBody": ["METHOD_START", "{", "mainLoopThread    =    new   Thread (  \" LWJGL   Application \"  )     {", "@ Override", "public   void   run (  )     {", "graphics . setVSync ( graphics . config . vSyncEnabled )  ;", "try    {", "LwjglApplication . this . mainLoop (  )  ;", "}    catch    ( Throwable   t )     {", "if    (  ( audio )     !  =    null )", "audio . dispose (  )  ;", "input . setCursorCatched ( false )  ;", "if    ( t   instanceof   RuntimeException )", "throw    (  ( RuntimeException )     ( t )  )  ;", "else", "throw   new   utils . GdxRuntimeException ( t )  ;", "}", "}", "}  ;", "mainLoopThread . start (  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplication"}, {"methodBody": ["METHOD_START", "{", "SnapshotArray < LifecycleListener >    lifecycleListeners    =    this . lifecycleListeners ;", "try    {", "graphics . setupDisplay (  )  ;", "}    catch    ( LWJGLException   e )     {", "throw   new   utils . GdxRuntimeException ( e )  ;", "}", "listener . create (  )  ;", "graphics . resize    =    true ;", "int   lastWidth    =    graphics . getWidth (  )  ;", "int   lastHeight    =    graphics . getHeight (  )  ;", "graphics . lastTime    =    System . nanoTime (  )  ;", "boolean   wasActive    =    true ;", "while    ( running )     {", "Display . processMessages (  )  ;", "if    ( Display . isCloseRequested (  )  )", "exit (  )  ;", "boolean   isActive    =    Display . isActive (  )  ;", "if    ( wasActive    &  &     (  ! isActive )  )     {", "wasActive    =    false ;", "synchronized ( lifecycleListeners )     {", "LifecycleListener [  ]    listeners    =    lifecycleListeners . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    lifecycleListeners . size ;    i    <    n ;     +  + i )", "listeners [ i ]  . pause (  )  ;", "lifecycleListeners . end (  )  ;", "}", "listener . pause (  )  ;", "}", "if    (  (  ! wasActive )     &  &    isActive )     {", "wasActive    =    true ;", "synchronized ( lifecycleListeners )     {", "LifecycleListener [  ]    listeners    =    lifecycleListeners . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    lifecycleListeners . size ;    i    <    n ;     +  + i )", "listeners [ i ]  . resume (  )  ;", "lifecycleListeners . end (  )  ;", "}", "listener . resume (  )  ;", "}", "boolean   shouldRender    =    false ;", "if    (  ( graphics . canvas )     !  =    null )     {", "int   width    =    graphics . canvas . getWidth (  )  ;", "int   height    =    graphics . canvas . getHeight (  )  ;", "if    (  ( lastWidth    !  =    width )     |  |     ( lastHeight    !  =    height )  )     {", "lastWidth    =    width ;", "lastHeight    =    height ;", "gl . glViewport (  0  ,     0  ,    lastWidth ,    lastHeight )  ;", "listener . resize ( lastWidth ,    lastHeight )  ;", "shouldRender    =    true ;", "}", "} else    {", "graphics . config . x    =    Display . getX (  )  ;", "graphics . config . y    =    Display . getY (  )  ;", "if    (  (  (  ( graphics . resize )     |  |     ( Display . wasResized (  )  )  )     |  |     (  (  ( int )     (  ( Display . getWidth (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )     !  =     ( graphics . config . width )  )  )     |  |     (  (  ( int )     (  ( Display . getHeight (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )     !  =     ( graphics . config . height )  )  )     {", "graphics . resize    =    false ;", "graphics . config . width    =     (  ( int )     (  ( Display . getWidth (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  ;", "graphics . config . height    =     (  ( int )     (  ( Display . getHeight (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  ;", "gl . glViewport (  0  ,     0  ,    graphics . config . width ,    graphics . config . height )  ;", "if    (  ( listener )     !  =    null )", "listener . resize ( graphics . config . width ,    graphics . config . height )  ;", "graphics . requestRendering (  )  ;", "}", "}", "if    ( executeRunnables (  )  )", "shouldRender    =    true ;", "if    (  !  ( running )  )", "break ;", "input . update (  )  ;", "shouldRender    |  =    graphics . shouldRender (  )  ;", "input . processEvents (  )  ;", "if    (  ( audio )     !  =    null )", "audio . update (  )  ;", "if    (  (  ! isActive )     &  &     (  ( graphics . config . backgroundFPS )     =  =     (  -  1  )  )  )", "shouldRender    =    false ;", "int   frameRate    =     ( isActive )     ?    graphics . config . foregroundFPS    :    graphics . config . backgroundFPS ;", "if    ( shouldRender )     {", "graphics . updateTime (  )  ;", "( graphics . frameId )  +  +  ;", "listener . render (  )  ;", "Display . update ( false )  ;", "} else    {", "if    ( frameRate    =  =     (  -  1  )  )", "frameRate    =     1  0  ;", "if    ( frameRate    =  =     0  )", "frameRate    =    graphics . config . backgroundFPS ;", "if    ( frameRate    =  =     0  )", "frameRate    =     3  0  ;", "}", "if    ( frameRate    >     0  )", "Display . sync ( frameRate )  ;", "}", "synchronized ( lifecycleListeners )     {", "LifecycleListener [  ]    listeners    =    lifecycleListeners . begin (  )  ;", "for    ( int   i    =     0  ,    n    =    lifecycleListeners . size ;    i    <    n ;     +  + i )     {", "listeners [ i ]  . pause (  )  ;", "listeners [ i ]  . dispose (  )  ;", "}", "lifecycleListeners . end (  )  ;", "}", "listener . pause (  )  ;", "listener . dispose (  )  ;", "Display . destroy (  )  ;", "if    (  ( audio )     !  =    null )", "audio . dispose (  )  ;", "if    ( graphics . config . forceExit )", "System . exit (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["mainLoop"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplication"}, {"methodBody": ["METHOD_START", "{", "running    =    false ;", "try    {", "mainLoopThread . join (  )  ;", "}    catch    ( Excep   ex )     {", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplication"}, {"methodBody": ["METHOD_START", "{", "iconPaths . add ( path )  ;", "iconFileTypes . add ( fileType )  ;", "}", "METHOD_END"], "methodName": ["addIcon"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "GraphicsEnvironment   genv    =    GraphicsEnvironment . getLocalGraphicsEnvironment (  )  ;", "GraphicsDevice   device    =    genv . getDefaultScreenDevice (  )  ;", "DisplayMode   mode    =    device . getDisplayMode (  )  ;", "return   newDisplayMode ( mode . getWidth (  )  ,    mode . getHeight (  )  ,    mode . getRefreshRate (  )  ,    mode . getBitDepth (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDesktopDisplayMode"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "GraphicsEnvironment   genv    =    GraphicsEnvironment . getLocalGraphicsEnvironment (  )  ;", "GraphicsDevice   device    =    genv . getDefaultScreenDevice (  )  ;", "DisplayMode   desktopMode    =    device . getDisplayMode (  )  ;", "DisplayMode [  ]    displayModes    =    device . getDisplayModes (  )  ;", "ArrayList < com . badlogic . gdx . Graphics . DisplayMode >    modes    =    new   ArrayList < com . badlogic . gdx . Graphics . DisplayMode >  (  )  ;", "int   idx    =     0  ;", "for    ( DisplayMode   mode    :    displayModes )     {", "boolean   duplicate    =    false ;", "for    ( int   i    =     0  ;    i    <     ( modes . size (  )  )  ;    i +  +  )     {", "if    (  (  (  ( modes . get ( i )  . width )     =  =     ( mode . getWidth (  )  )  )     &  &     (  ( modes . get ( i )  . height )     =  =     ( mode . getHeight (  )  )  )  )     &  &     (  ( modes . get ( i )  . bitsPerPixel )     =  =     ( mode . getBitDepth (  )  )  )  )     {", "duplicate    =    true ;", "break ;", "}", "}", "if    ( duplicate )", "continue ;", "if    (  ( mode . getBitDepth (  )  )     !  =     ( desktopMode . getBitDepth (  )  )  )", "continue ;", "modes . add ( newDisplayMode ( mode . getWidth (  )  ,    mode . getHeight (  )  ,    mode . getRefreshRate (  )  ,    mode . getBitDepth (  )  )  )  ;", "}", "return   modes . toArray ( new   com . badlogic . gdx . Graphics . DisplayMode [ modes . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayModes"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . width    =    mode . width ;", "this . height    =    mode . height ;", "if    (  ( mode . bitsPerPixel )     =  =     1  6  )     {", "this . r    =     5  ;", "this . g    =     6  ;", "this . b    =     5  ;", "this . a    =     0  ;", "}", "if    (  ( mode . bitsPerPixel )     =  =     2  4  )     {", "this . r    =     8  ;", "this . g    =     8  ;", "this . b    =     8  ;", "this . a    =     0  ;", "}", "if    (  ( mode . bitsPerPixel )     =  =     3  2  )     {", "this . r    =     8  ;", "this . g    =     8  ;", "this . b    =     8  ;", "this . a    =     8  ;", "}", "this . fullscreen    =    true ;", "}", "METHOD_END"], "methodName": ["setFromDisplayMode"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration"}, {"methodBody": ["METHOD_START", "{", "try    {", "graphics . setupDisplay (  )  ;", "listener . create (  )  ;", "listener . resize ( Math . max (  1  ,    graphics . getWidth (  )  )  ,    Math . max (  1  ,    graphics . getHeight (  )  )  )  ;", "start (  )  ;", "}    catch    ( Exception   ex )     {", "stopped (  )  ;", "exception ( ex )  ;", "return ;", "}", "EventQueue . invokeLater ( new   Runnable (  )     {", "int   lastWidth    =    Math . max (  1  ,    graphics . getWidth (  )  )  ;", "int   lastHeight    =    Math . max (  1  ,    graphics . getHeight (  )  )  ;", "public   void   run (  )     {", "if    (  (  !  ( running )  )     |  |     ( Display . isCloseRequested (  )  )  )     {", "running    =    false ;", "stopped (  )  ;", "return ;", "}", "try    {", "Display . processMessages (  )  ;", "if    (  (  ( cursor )     !  =    null )     |  |     (  !  (  . isWindows )  )  )", "canvas . setCursor ( cursor )  ;", "boolean   shouldRender    =    false ;", "int   width    =    Math . max (  1  ,    graphics . getWidth (  )  )  ;", "int   height    =    Math . max (  1  ,    graphics . getHeight (  )  )  ;", "if    (  (  ( lastWidth )     !  =    width )     |  |     (  ( lastHeight )     !  =    height )  )     {", "lastWidth    =    width ;", "lastHeight    =    height ;", "gl . glViewport (  0  ,     0  ,    lastWidth ,    lastHeight )  ;", "resize ( width ,    height )  ;", "listener . resize ( width ,    height )  ;", "shouldRender    =    true ;", "}", "if    ( executeRunnables (  )  )", "shouldRender    =    true ;", "if    (  !  ( running )  )", "return ;", "input . update (  )  ;", "shouldRender    |  =    graphics . shouldRender (  )  ;", "input . processEvents (  )  ;", "if    (  ( audio )     !  =    null )", "audio . update (  )  ;", "if    ( shouldRender )     {", "graphics . updateTime (  )  ;", "( graphics . frameId )  +  +  ;", "listener . render (  )  ;", "Display . update ( false )  ;", "}", "Display . sync ( getFrameRate (  )  )  ;", "}    catch    ( Throwable   ex )     {", "exception ( ex )  ;", "}", "EventQueue . invokeLater ( this )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "ex . printStackTrace (  )  ;", "stop (  )  ;", "}", "METHOD_END"], "methodName": ["exception"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "nchronized ( runnable    {", "for    ( int   i    =     ( runnableze )     -     1  ;    i    >  =     0  ;    i -  -  )", "executedRunnableaddAll ( runnableget ( i )  )  ;", "runnableclear (  )  ;", "}", "if    (  ( executedRunnableze )     =  =     0  )", "return   fal ;", "do", "executedRunnablepop (  )  . run (  )  ;", "while    (  ( executedRunnableze )     >     0     )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["executeRunnables"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "return   canvas ;", "}", "METHOD_END"], "methodName": ["getCanvas"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "int   frameRate    =     ( Display . isActive (  )  )     ?    graphics . config . foregroundFPS    :    graphics . config . backgroundFPS ;", "if    ( frameRate    =  =     (  -  1  )  )", "frameRate    =     1  0  ;", "if    ( frameRate    =  =     0  )", "frameRate    =    graphics . config . backgroundFPS ;", "if    ( frameRate    =  =     0  )", "frameRate    =     3  0  ;", "return   frameRate ;", "}", "METHOD_END"], "methodName": ["getFrameRate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "LwjglNativesLoader . load (  )  ;", "setApplicationLogger ( new   LwjglApplicationLogger (  )  )  ;", "canvas    =    new   Canvas (  )     {", "private   final   Dimension   minSize    =    new   Dimension (  1  ,     1  )  ;", "public   final   void   addNotify (  )     {", "super . addNotify (  )  ;", "if    ( SharedLibraryLoader . isMac )     {", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "create (  )  ;", "}", "}  )  ;", "} else", "create (  )  ;", "}", "public   final   void   removeNotify (  )     {", "stop (  )  ;", "super . removeNotify (  )  ;", "}", "public   Dimension   getMinimumSize (  )     {", "return   minSize ;", "}", "}  ;", "canvas . setSize (  1  ,     1  )  ;", "canvas . setIgnoreRepaint ( true )  ;", "graphics    =    new   LwjglGraphics ( canvas ,    config )     {", "public   void   setTitle ( String   title )     {", "super . setTitle ( title )  ;", "LwjglCanvas . this . setTitle ( title )  ;", "}", "public   boolean   setWindowedMode ( int   width ,    int   height ,    boolean   fullscreen )     {", "if    (  !  ( super . setWindowedMode ( width ,    height )  )  )", "return   false ;", "if    (  ! fullscreen )", "LwjglCanvas . this . setDisplayMode ( width ,    height )  ;", "return   true ;", "}", "public   boolean   setFullscreenMode ( DisplayMode   displayMode )     {", "if    (  !  ( super . setFullscreenMode ( displayMode )  )  )", "return   false ;", "LwjglCanvas . this . setDisplayMode ( displayMode . width ,    displayMode . height )  ;", "return   true ;", "}", "}  ;", "graphics . setVSync ( config . vSyncEnabled )  ;", "if    (  !  ( LwjglApplicationConfiguration . disableAudio )  )", "audio    =    new   audio . OpenALAudio (  )  ;", "files    =    new   LwjglFiles (  )  ;", "input    =    new   LwjglInput (  )  ;", "net    =    new   LwjglNet (  )  ;", "this . listener    =    listener ;", "Gdx . app    =    this ;", "Gdx . graphics    =    graphics ;", "Gdx . audio    =    audio ;", "Gdx . files    =    files ;", "Gdx . input    =    input ;", "Gdx . net    =    net ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "this . cursor    =    cursor ;", "}", "METHOD_END"], "methodName": ["setCursor"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "if    (  !  ( running )  )", "return ;", "running    =    false ;", "Array < LifecycleListener >    listeners    =    lifecycleListeners ;", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . pause (  )  ;", "listener . dispose (  )  ;", "}", "}", "listener . pause (  )  ;", "listener . dispose (  )  ;", "try    {", "Display . destroy (  )  ;", "if    (  ( audio )     !  =    null )", "audio . dispose (  )  ;", "}    catch    ( Throwable   ignored )     {", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglCanvas"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "return   new    ( new   File ( name )  ,    type )  ;", "return   new    ( new   File ( file ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . External )  )", "return   new   File ( s . externalPath ,    file . getPath (  )  )  ;", "if    (  ( type )     =  =     ( FileType . Local )  )", "return   new   File ( s . localPath ,    file . getPath (  )  )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFileHandle"}, {"methodBody": ["METHOD_START", "{", "File   parent    =    file . getParentFile (  )  ;", "if    ( parent    =  =    null )     {", "if    (  ( type )     =  =     ( FileType . Absolute )  )", "parent    =    new   File (  \"  /  \"  )  ;", "else", "parent    =    new   File (  \"  \"  )  ;", "}", "return   new    ( parent ,    type )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" Cannot   get   the   sibling   of   the   root .  \"  )  ;", "return   new   LwjglFileHandle ( new   File ( file . getParent (  )  ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["sibling"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFileHandle"}, {"methodBody": ["METHOD_START", "{", "getContentPane (  )  . add ( lwjglCanvas . getCanvas (  )  )  ;", "}", "METHOD_END"], "methodName": ["addCanvas"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFrame"}, {"methodBody": ["METHOD_START", "{", "lwjglCanvas    =    new   LwjglCanvas ( listener ,    config )     {", "protected   void   stopped (  )     {", ". this . dispose (  )  ;", "}", "protected   void   setTitle ( String   title )     {", ". this . setTitle ( title )  ;", "}", "protected   void   setDisplayMode ( int   width ,    int   height )     {", ". this . getContentPane (  )  . setPreferredSize ( new   Dimension ( width ,    height )  )  ;", ". this . getContentPane (  )  . invalidate (  )  ;", ". this . pack (  )  ;", ". this . setLocationRelativeTo ( null )  ;", "updateSize ( width ,    height )  ;", "}", "protected   void   resize ( int   width ,    int   height )     {", "updateSize ( width ,    height )  ;", "}", "protected   void   start (  )     {", ". this . start (  )  ;", "}", "protected   void   exception ( Throwable   t )     {", ". this . exception ( t )  ;", "}", "protected   int   getFrameRate (  )     {", "int   frameRate    =     . this . getFrameRate (  )  ;", "return   frameRate    =  =     0     ?    super . getFrameRate (  )     :    frameRate ;", "}", "}  ;", "setHaltOnShutdown ( true )  ;", "setDefaultCloseOperation ( JFrame . EXIT _ ON _ CLOSE )  ;", "getContentPane (  )  . setPreferredSize ( new   Dimension ( config . width ,    config . height )  )  ;", "initialize (  )  ;", "pack (  )  ;", "Point   location    =    getLocation (  )  ;", "if    (  (  ( location . x )     =  =     0  )     &  &     (  ( location . y )     =  =     0  )  )", "setLocationRelativeTo ( null )  ;", "lwjglCanvas . getCanvas (  )  . setSize ( getSize (  )  )  ;", "EventQueue . invokeLater ( new   Runnable (  )     {", "public   void   run (  )     {", "addCanvas (  )  ;", "setVisible ( true )  ;", "lwjglCanvas . getCanvas (  )  . requestFocus (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["construct"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFrame"}, {"methodBody": ["METHOD_START", "{", "ex . printStackTrace (  )  ;", "Canvas . stop (  )  ;", "}", "METHOD_END"], "methodName": ["exception"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFrame"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getFrameRate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFrame"}, {"methodBody": ["METHOD_START", "{", "return   lwjglCanvas ;", "}", "METHOD_END"], "methodName": ["getLwjglCanvas"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFrame"}, {"methodBody": ["METHOD_START", "{", "if    ( halt )     {", "if    (  ( shutdownHook )     !  =    null )", "return ;", "shutdownHook    =    new   Thre (  )     {", "public   void   run (  )     {", "Runtime . getRuntime (  )  . halt (  0  )  ;", "}", "}  ;", "Runtime . getRuntime (  )  . dShutdownHook ( shutdownHook )  ;", "} else", "if    (  ( shutdownHook )     !  =    null )     {", "Runtime . getRuntime (  )  . removeShutdownHook ( shutdownHook )  ;", "shutdownHook    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setHaltOnShutdown"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglFrame"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( buffer )     =  =    null )     |  |     (  ( buffer . capacity (  )  )     <    numBytes )  )     {", "buffer    =    BufferUtils . newByteBuffer ( numBytes )  ;", "floatBuffer    =    buffer . asFloatBuffer (  )  ;", "intBuffer    =    buffer . asIntBuffer (  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureBufferCapacity"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  3  . glActiveTexture ( texture )  ;", "}", "METHOD_END"], "methodName": ["glActiveTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glAttachShader ( program ,    shader )  ;", "}", "METHOD_END"], "methodName": ["glAttachShader"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glBindAttribLocation ( program ,    index ,    name )  ;", "}", "METHOD_END"], "methodName": ["glBindAttribLocation"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glBindBuffer ( target ,    buffer )  ;", "}", "METHOD_END"], "methodName": ["glBindBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glBindFramebufferEXT ( target ,    framebuffer )  ;", "}", "METHOD_END"], "methodName": ["glBindFramebuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glBindRenderbufferEXT ( target ,    renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glBindRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glBindTexture ( target ,    texture )  ;", "}", "METHOD_END"], "methodName": ["glBindTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  4  . glBlendColor ( red ,    green ,    blue ,    alpha )  ;", "}", "METHOD_END"], "methodName": ["glBlendColor"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  4  . glBlendEquation ( mode )  ;", "}", "METHOD_END"], "methodName": ["glBlendEquation"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glBlendEquationSeparate ( modeRGB ,    modeAlpha )  ;", "}", "METHOD_END"], "methodName": ["glBlendEquationSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glBlendFunc ( sfactor ,    dfactor )  ;", "}", "METHOD_END"], "methodName": ["glBlendFunc"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  4  . glBlendFuncSeparate ( srcRGB ,    dstRGB ,    srcAlpha ,    dstAlpha )  ;", "}", "METHOD_END"], "methodName": ["glBlendFuncSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( data    =  =    null )", "glBufferData ( target ,    size ,    usage )  ;", "else", "if    ( data   instanceof   ByteBuffer )", "glBufferData ( target ,     (  ( ByteBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   IntBuffer )", "glBufferData ( target ,     (  ( IntBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   FloatBuffer )", "glBufferData ( target ,     (  ( FloatBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   DoubleBuffer )", "glBufferData ( target ,     (  ( DoubleBuffer )     ( data )  )  ,    usage )  ;", "else", "if    ( data   instanceof   ShortBuffer )", "glBufferData ( target ,     (  ( ShortBuffer )     ( data )  )  ,    usage )  ;", "}", "METHOD_END"], "methodName": ["glBufferData"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( data    =  =    null )", "throw   new   utils . GdxRuntimeException (  \" Using   null   for   the   data   not   possible ,    blame   LWJGL \"  )  ;", "else", "if    ( data   instanceof   ByteBuffer )", "glBufferSubData ( target ,    offset ,     (  ( ByteBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   IntBuffer )", "glBufferSubData ( target ,    offset ,     (  ( IntBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   FloatBuffer )", "glBufferSubData ( target ,    offset ,     (  ( FloatBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   DoubleBuffer )", "glBufferSubData ( target ,    offset ,     (  ( DoubleBuffer )     ( data )  )  )  ;", "else", "if    ( data   instanceof   ShortBuffer )", "glBufferSubData ( target ,    offset ,     (  ( ShortBuffer )     ( data )  )  )  ;", "}", "METHOD_END"], "methodName": ["glBufferSubData"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glCheckFramebufferStatusEXT ( target )  ;", "}", "METHOD_END"], "methodName": ["glCheckFramebufferStatus"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClear ( mask )  ;", "}", "METHOD_END"], "methodName": ["glClear"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClearColor ( red ,    green ,    blue ,    alpha )  ;", "}", "METHOD_END"], "methodName": ["glClearColor"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClearDepth ( depth )  ;", "}", "METHOD_END"], "methodName": ["glClearDepthf"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glClearStencil ( s )  ;", "}", "METHOD_END"], "methodName": ["glClearStencil"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glColorMask ( red ,    green ,    blue ,    alpha )  ;", "}", "METHOD_END"], "methodName": ["glColorMask"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glCompileShader ( shader )  ;", "}", "METHOD_END"], "methodName": ["glCompileShader"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( data   instanceof   ByteBuffer )     {", "GL 1  3  . glCpressedTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,     (  ( ByteBuffer )     ( data )  )  )  ;", "} else    {", "throw   new   GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( data . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer   instead .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["glCompressedTexImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" not   implemented \"  )  ;", "}", "METHOD_END"], "methodName": ["glCompressedTexSubImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glCopyTexImage 2 D ( target ,    level ,    internalformat ,    x ,    y ,    width ,    height ,    border )  ;", "}", "METHOD_END"], "methodName": ["glCopyTexImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glCopyTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glCopyTexSubImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glCreateProgram (  )  ;", "}", "METHOD_END"], "methodName": ["glCreateProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glCreateShader ( type )  ;", "}", "METHOD_END"], "methodName": ["glCreateShader"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glCullFace ( mode )  ;", "}", "METHOD_END"], "methodName": ["glCullFace"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glDeleteBuffers ( buffers )  ;", "}", "METHOD_END"], "methodName": ["glDeleteBuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glDeleteFramebuffersEXT ( framebuffers )  ;", "}", "METHOD_END"], "methodName": ["glDeleteFramebuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDeleteProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glDeleteProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glDeleteRenderbuffersEXT ( renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glDeleteRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glDeleteRenderbuffersEXT ( renderbuffers )  ;", "}", "METHOD_END"], "methodName": ["glDeleteRenderbuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDeleteShader ( shader )  ;", "}", "METHOD_END"], "methodName": ["glDeleteShader"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDeleteTextures ( textures )  ;", "}", "METHOD_END"], "methodName": ["glDeleteTextures"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDepthFunc ( func )  ;", "}", "METHOD_END"], "methodName": ["glDepthFunc"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDepthMask ( flag )  ;", "}", "METHOD_END"], "methodName": ["glDepthMask"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDepthRange ( zNear ,    zFar )  ;", "}", "METHOD_END"], "methodName": ["glDepthRangef"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDetachShader ( program ,    shader )  ;", "}", "METHOD_END"], "methodName": ["glDetachShader"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDisable ( cap )  ;", "}", "METHOD_END"], "methodName": ["glDisable"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glDisableVertexAttribArray ( index )  ;", "}", "METHOD_END"], "methodName": ["glDisableVertexAttribArray"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDrawArrays ( mode ,    first ,    count )  ;", "}", "METHOD_END"], "methodName": ["glDrawArrays"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glDrawElements ( mode ,    count ,    type ,    indices )  ;", "}", "METHOD_END"], "methodName": ["glDrawElements"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    (  ( indices   instanceof   ShortBuffer )     &  &     ( type    =  =    com . badlogic . gdx . graphics . GL 2  0  )  )", "glDrawElements ( mode ,     (  ( ShortBuffer )     ( indices )  )  )  ;", "else", "if    (  ( indices   instanceof   ByteBuffer )     &  &     ( type    =  =    com . badlogic . gdx . graphics . GL 2  0  )  )", "glDrawElements ( mode ,     (  ( ByteBuffer )     ( indices )  )  . asShortBuffer (  )  )  ;", "else", "if    (  ( indices   instanceof   ByteBuffer )     &  &     ( type    =  =    com . badlogic . gdx . graphics . GL 2  0  )  )", "glDrawElements ( mode ,     (  ( ByteBuffer )     ( indices )  )  )  ;", "else", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( indices . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ShortBuffer   or   ByteBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glDrawElements"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glEnable ( cap )  ;", "}", "METHOD_END"], "methodName": ["glEnable"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glEnableVertexAttribArray ( index )  ;", "}", "METHOD_END"], "methodName": ["glEnableVertexAttribArray"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glFinish (  )  ;", "}", "METHOD_END"], "methodName": ["glFinish"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glFlush (  )  ;", "}", "METHOD_END"], "methodName": ["glFlush"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glFramebufferRenderbufferEXT ( target ,    attachment ,    renderbuffertarget ,    renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glFramebufferRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glFramebufferTexture 2 DEXT ( target ,    attachment ,    textarget ,    texture ,    level )  ;", "}", "METHOD_END"], "methodName": ["glFramebufferTexture2D"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glFrontFace ( mode )  ;", "}", "METHOD_END"], "methodName": ["glFrontFace"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  5  . glGenBuffers (  )  ;", "}", "METHOD_END"], "methodName": ["glGenBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glGenBuffers ( buffers )  ;", "}", "METHOD_END"], "methodName": ["glGenBuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glGenFramebuffersEXT (  )  ;", "}", "METHOD_END"], "methodName": ["glGenFramebuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGenFramebuffersEXT ( framebuffers )  ;", "}", "METHOD_END"], "methodName": ["glGenFramebuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glGenRenderbuffersEXT (  )  ;", "}", "METHOD_END"], "methodName": ["glGenRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGenRenderbuffersEXT ( renderbuffers )  ;", "}", "METHOD_END"], "methodName": ["glGenRenderbuffers"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glGenTextures (  )  ;", "}", "METHOD_END"], "methodName": ["glGenTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGenTextures ( textures )  ;", "}", "METHOD_END"], "methodName": ["glGenTextures"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGenerateMipmapEXT ( target )  ;", "}", "METHOD_END"], "methodName": ["glGenerateMipmap"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   typeTmp    =    BufferUtils . createIntBuffer (  2  )  ;", "String   name    =     . glGetActiveAttrib ( program ,    index ,     2  5  6  ,    typeTmp )  ;", "size . put ( typeTmp . get (  0  )  )  ;", "if    ( type   instanceof   IntBuffer )", "(  ( IntBuffer )     ( type )  )  . put ( typeTmp . get (  1  )  )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["glGetActiveAttrib"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   typeTmp    =    BufferUtils . createIntBuffer (  2  )  ;", "String   name    =     . glGetActiveUniform ( program ,    index ,     2  5  6  ,    typeTmp )  ;", "size . put ( typeTmp . get (  0  )  )  ;", "if    ( type   instanceof   IntBuffer )", "(  ( IntBuffer )     ( type )  )  . put ( typeTmp . get (  1  )  )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["glGetActiveUniform"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetAttachedShaders ( program ,     (  ( IntBuffer )     ( count )  )  ,    shaders )  ;", "}", "METHOD_END"], "methodName": ["glGetAttachedShaders"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glGetAttribLocation ( program ,    name )  ;", "}", "METHOD_END"], "methodName": ["glGetAttribLocation"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetBoolean ( pname ,     (  ( ByteBuffer )     ( params )  )  )  ;", "}", "METHOD_END"], "methodName": ["glGetBooleanv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  5  . glGetBufferParameter ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetBufferParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glGetError (  )  ;", "}", "METHOD_END"], "methodName": ["glGetError"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetFloat ( pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetFloatv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGetFramebufferAttachmentParameterEXT ( target ,    attachment ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetFramebufferAttachmentParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetInteger ( pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetIntegerv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  (  1  0  2  4     *     1  0  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "ByteBuffer   tmp    =    ByteBuffer . allocateDirect (  4  )  ;", "tmp . order ( ByteOrder . nativeOrder (  )  )  ;", "IntBuffer   intBuffer    =    tmp . asIntBuffer (  )  ;", ". glGetProgramInfoLog ( program ,    intBuffer ,    buffer )  ;", "int   numBytes    =    intBuffer . get (  0  )  ;", "byte [  ]    bytes    =    new   byte [ numBytes ]  ;", "buffer . get ( bytes )  ;", "return   new   String ( bytes )  ;", "}", "METHOD_END"], "methodName": ["glGetProgramInfoLog"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetProgram ( program ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetProgramiv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glGetRenderbufferParameterEXT ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetRenderbufferParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect (  (  1  0  2  4     *     1  0  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "ByteBuffer   tmp    =    ByteBuffer . allocateDirect (  4  )  ;", "tmp . order ( ByteOrder . nativeOrder (  )  )  ;", "IntBuffer   intBuffer    =    tmp . asIntBuffer (  )  ;", ". glGetShaderInfoLog ( shader ,    intBuffer ,    buffer )  ;", "int   numBytes    =    intBuffer . get (  0  )  ;", "byte [  ]    bytes    =    new   byte [ numBytes ]  ;", "buffer . get ( bytes )  ;", "return   new   String ( bytes )  ;", "}", "METHOD_END"], "methodName": ["glGetShaderInfoLog"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" unsupported ,    won ' t   implement \"  )  ;", "}", "METHOD_END"], "methodName": ["glGetShaderPrecisionFormat"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetShader ( shader ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetShaderiv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glGetString ( name )  ;", "}", "METHOD_END"], "methodName": ["glGetString"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetTexParameter ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetTexParameterfv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glGetTexParameter ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetTexParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glGetUniformLocation ( program ,    name )  ;", "}", "METHOD_END"], "methodName": ["glGetUniformLocation"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetUniform ( program ,    location ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetUniformfv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetUniform ( program ,    location ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetUniformiv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" unsupported ,    won ' t   implement \"  )  ;", "}", "METHOD_END"], "methodName": ["glGetVertexAttribPointerv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetVertexAttrib ( index ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetVertexAttribfv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glGetVertexAttrib ( index ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glGetVertexAttribiv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glHint ( target ,    mode )  ;", "}", "METHOD_END"], "methodName": ["glHint"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  5  . glIsBuffer ( buffer )  ;", "}", "METHOD_END"], "methodName": ["glIsBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glIsEnabled ( cap )  ;", "}", "METHOD_END"], "methodName": ["glIsEnabled"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glIsFramebufferEXT ( framebuffer )  ;", "}", "METHOD_END"], "methodName": ["glIsFramebuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glIsProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glIsProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   EXTFramebufferObject . glIsRenderbufferEXT ( renderbuffer )  ;", "}", "METHOD_END"], "methodName": ["glIsRenderbuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . glIsShader ( shader )  ;", "}", "METHOD_END"], "methodName": ["glIsShader"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "return   GL 1  1  . glIsTexture ( texture )  ;", "}", "METHOD_END"], "methodName": ["glIsTexture"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glLineWidth ( width )  ;", "}", "METHOD_END"], "methodName": ["glLineWidth"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glLinkProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glLinkProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glPixelStorei ( pname ,    param )  ;", "}", "METHOD_END"], "methodName": ["glPixelStorei"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glPolygonOffset ( factor ,    units )  ;", "}", "METHOD_END"], "methodName": ["glPolygonOffset"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( pixels   instanceof   ByteBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( ByteBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   ShortBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( ShortBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   IntBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( IntBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   FloatBuffer )", "glReadPixels ( x ,    y ,    width ,    height ,    format ,    type ,     (  ( FloatBuffer )     ( pixels )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( pixels . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer ,    ShortBuffer ,    IntBuffer   or   FloatBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glReadPixels"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "EXTFramebufferObject . glRenderbufferStorageEXT ( target ,    internalformat ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glRenderbufferStorage"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  3  . glSampleCoverage ( value ,    invert )  ;", "}", "METHOD_END"], "methodName": ["glSampleCoverage"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glScissor ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glScissor"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" unsupported ,    won ' t   implement \"  )  ;", "}", "METHOD_END"], "methodName": ["glShaderBinary"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glShaderSource ( shader ,    string )  ;", "}", "METHOD_END"], "methodName": ["glShaderSource"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glStencilFunc ( func ,    ref ,    mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilFunc"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glStencilFuncSeparate ( face ,    func ,    ref ,    mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilFuncSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glStencilMask ( mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilMask"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glStencilMaskSeparate ( face ,    mask )  ;", "}", "METHOD_END"], "methodName": ["glStencilMaskSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glStencilOp ( fail ,    zfail ,    zpass )  ;", "}", "METHOD_END"], "methodName": ["glStencilOp"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glStencilOpSeparate ( face ,    fail ,    zfail ,    zpass )  ;", "}", "METHOD_END"], "methodName": ["glStencilOpSeparate"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( pixels    =  =    null )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( ByteBuffer )     ( null )  )  )  ;", "else", "if    ( pixels   instanceof   ByteBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( ByteBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   ShortBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( ShortBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   IntBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( IntBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   FloatBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( FloatBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   DoubleBuffer )", "glTexImage 2 D ( target ,    level ,    internalformat ,    width ,    height ,    border ,    format ,    type ,     (  ( DoubleBuffer )     ( pixels )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( pixels . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer ,    ShortBuffer ,    IntBuffer ,    FloatBuffer   or   DoubleBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glTexImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameterf ( target ,    pname ,    param )  ;", "}", "METHOD_END"], "methodName": ["glTexParameterf"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameter ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glTexParameterfv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameteri ( target ,    pname ,    param )  ;", "}", "METHOD_END"], "methodName": ["glTexParameteri"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glTexParameter ( target ,    pname ,    params )  ;", "}", "METHOD_END"], "methodName": ["glTexParameteriv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( pixels   instanceof   ByteBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( ByteBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   ShortBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( ShortBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   IntBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( IntBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   FloatBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( FloatBuffer )     ( pixels )  )  )  ;", "else", "if    ( pixels   instanceof   DoubleBuffer )", "glTexSubImage 2 D ( target ,    level ,    xoffset ,    yoffset ,    width ,    height ,    format ,    type ,     (  ( DoubleBuffer )     ( pixels )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( pixels . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer ,    ShortBuffer ,    IntBuffer ,    FloatBuffer   or   DoubleBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glTexSubImage2D"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1 f ( location ,    x )  ;", "}", "METHOD_END"], "methodName": ["glUniform1f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1  ( location ,    toFloatBuffer ( v ,    offset ,    count )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform1fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform1fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1 i ( location ,    x )  ;", "}", "METHOD_END"], "methodName": ["glUniform1i"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 1  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform1iv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 f ( location ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["glUniform2f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2  ( location ,    toFloatBuffer ( v ,    offset ,     ( count    <  <     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2 i ( location ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["glUniform2i"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2  ( location ,    toIntBuffer ( v ,    offset ,     ( count    <  <     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform2iv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 2  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform2iv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 f ( location ,    x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["glUniform3f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3  ( location ,    toFloatBuffer ( v ,    offset ,     ( count    *     3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3 i ( location ,    x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["glUniform3i"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3  ( location ,    toIntBuffer ( v ,    offset ,     ( count    *     3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform3iv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 3  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform3iv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 f ( location ,    x ,    y ,    z ,    w )  ;", "}", "METHOD_END"], "methodName": ["glUniform4f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4  ( location ,    toFloatBuffer ( v ,    offset ,     ( count    <  <     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4 i ( location ,    x ,    y ,    z ,    w )  ;", "}", "METHOD_END"], "methodName": ["glUniform4i"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4  ( location ,    toIntBuffer ( v ,    offset ,     ( count    <  <     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniform4iv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniform 4  ( location ,    v )  ;", "}", "METHOD_END"], "methodName": ["glUniform4iv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 2  ( location ,    transpose ,    toFloatBuffer ( value ,    offset ,     ( count    <  <     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 2  ( location ,    transpose ,    value )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 3  ( location ,    transpose ,    toFloatBuffer ( value ,    offset ,     ( count    *     9  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 3  ( location ,    transpose ,    value )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 4  ( location ,    transpose ,    toFloatBuffer ( value ,    offset ,     ( count    <  <     4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUniformMatrix 4  ( location ,    transpose ,    value )  ;", "}", "METHOD_END"], "methodName": ["glUniformMatrix4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glUseProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glUseProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glValidateProgram ( program )  ;", "}", "METHOD_END"], "methodName": ["glValidateProgram"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 1 f ( indx ,    x )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib1f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 1 f ( indx ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib1fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 2 f ( indx ,    x ,    y )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib2f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 2 f ( indx ,    values . get (  )  ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib2fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 3 f ( indx ,    x ,    y ,    z )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib3f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 3 f ( indx ,    values . get (  )  ,    values . get (  )  ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib3fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 4 f ( indx ,    x ,    y ,    z ,    w )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib4f"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttrib 4 f ( indx ,    values . get (  )  ,    values . get (  )  ,    values . get (  )  ,    values . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttrib4fv"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 2  0  . glVertexAttribPointer ( indx ,    size ,    type ,    normalized ,    stride ,    ptr )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttribPointer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( buffer   instanceof   ByteBuffer )     {", "if    ( type    =  =     ( GL _ BYTE )  )", "glVertexAttribPointer ( indx ,    size ,    false ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  )  ;", "else", "if    ( type    =  =     ( GL _ UNSIGNED _ BYTE )  )", "glVertexAttribPointer ( indx ,    size ,    true ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  )  ;", "else", "if    ( type    =  =     ( GL _ SHORT )  )", "glVertexAttribPointer ( indx ,    size ,    false ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  . asShortBuffer (  )  )  ;", "else", "if    ( type    =  =     ( GL _ UNSIGNED _ SHORT )  )", "glVertexAttribPointer ( indx ,    size ,    true ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  . asShortBuffer (  )  )  ;", "else", "if    ( type    =  =     ( GL _ FLOAT )  )", "glVertexAttribPointer ( indx ,    size ,    normalized ,    stride ,     (  ( ByteBuffer )     ( buffer )  )  . asFloatBuffer (  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Can ' t   use    \"     +     ( buffer . getClass (  )  . getName (  )  )  )     +     \"    with   type    \"  )     +    type )     +     \"    with   this   method .    Use   ByteBuffer   and   one   of   GL _ BYTE ,    GL _ UNSIGNED _ BYTE ,    GL _ SHORT ,    GL _ UNSIGNED _ SHORT   or   GL _ FLOAT   for   type .    Blame   LWJGL \"  )  )  ;", "} else", "if    ( buffer   instanceof   FloatBuffer )     {", "if    ( type    =  =     ( GL _ FLOAT )  )", "glVertexAttribPointer ( indx ,    size ,    normalized ,    stride ,     (  ( FloatBuffer )     ( buffer )  )  )  ;", "else", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Can ' t   use    \"     +     ( buffer . getClass (  )  . getName (  )  )  )     +     \"    with   type    \"  )     +    type )     +     \"    with   this   method .  \"  )  )  ;", "} else", "throw   new   utils . GdxRuntimeException (  (  (  \" Can ' t   use    \"     +     ( buffer . getClass (  )  . getName (  )  )  )     +     \"    with   this   method .    Use   ByteBuffer   instead .    Blame   LWJGL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["glVertexAttribPointer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "GL 1  1  . glViewport ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glViewport"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "ensureBufferCapacity (  ( count    <  <     2  )  )  ;", "floatBuffer . clear (  )  ;", "BufferUtils . copy ( v ,    floatBuffer ,    count ,    offset )  ;", "return   floatBuffer ;", "}", "METHOD_END"], "methodName": ["toFloatBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "ensureBufferCapacity (  ( count    <  <     2  )  )  ;", "intBuffer . clear (  )  ;", "BufferUtils . copy ( v ,    count ,    offset ,    intBuffer )  ;", "return   intBuffer ;", "}", "METHOD_END"], "methodName": ["toIntBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGL20"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( useGL 3  0  )     {", "ContextAttribs   context    =    new   ContextAttribs ( gles 3  0 ContextMajor ,    gles 3  0 ContextMinor )  . withForwardCompatible ( false )  . withProfileCore ( true )  ;", "try    {", "Display . create ( new   PixelFormat (  (  (  ( config . r )     +     ( config . g )  )     +     ( config . b )  )  ,    config . a ,    config . depth ,    config . stencil ,    config . samples )  ,    context )  ;", "}    catch    ( Exception   e )     {", "System . out . println (  (  (  (  (  \"  :    OpenGL    \"     +    gles 3  0 ContextMajor )     +     \"  .  \"  )     +    gles 3  0 ContextMinor )     +     \"  +    core   profile    ( GLES    3  .  0  )    not   supported .  \"  )  )  ;", "createDisplayPixelFormat ( false ,    gles 3  0 ContextMajor ,    gles 3  0 ContextMinor )  ;", "return ;", "}", "System . out . println (  (  (  (  (  \"  :    created   OpenGL    \"     +    gles 3  0 ContextMajor )     +     \"  .  \"  )     +    gles 3  0 ContextMinor )     +     \"  +    core   profile    ( GLES    3  .  0  )    context .    This   is   experimental !  \"  )  )  ;", "usingGL 3  0     =    true ;", "} else    {", "Display . create ( new   PixelFormat (  (  (  ( config . r )     +     ( config . g )  )     +     ( config . b )  )  ,    config . a ,    config . depth ,    config . stencil ,    config . samples )  )  ;", "usingGL 3  0     =    false ;", "}", "bufferFormat    =    new   BufferFormat ( config . r ,    config . g ,    config . b ,    config . a ,    config . depth ,    config . stencil ,    config . samples ,    false )  ;", "}    catch    ( Exception   ex )     {", "Display . destroy (  )  ;", "try    {", "Thread . sleep (  2  0  0  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "try    {", "Display . create ( new   PixelFormat (  0  ,     1  6  ,     8  )  )  ;", "if    (  ( getDisplayMode (  )  . bitsPerPixel )     =  =     1  6  )     {", "bufferFormat    =    new   BufferFormat (  5  ,     6  ,     5  ,     0  ,     1  6  ,     8  ,     0  ,    false )  ;", "}", "if    (  ( getDisplayMode (  )  . bitsPerPixel )     =  =     2  4  )     {", "bufferFormat    =    new   BufferFormat (  8  ,     8  ,     8  ,     0  ,     1  6  ,     8  ,     0  ,    false )  ;", "}", "if    (  ( getDisplayMode (  )  . bitsPerPixel )     =  =     3  2  )     {", "bufferFormat    =    new   BufferFormat (  8  ,     8  ,     8  ,     8  ,     1  6  ,     8  ,     0  ,    false )  ;", "}", "}    catch    ( Exception   ex 2  )     {", "Display . destroy (  )  ;", "try    {", "Thread . sleep (  2  0  0  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "try    {", "Display . create ( new   PixelFormat (  )  )  ;", "}    catch    ( Exception   ex 3  )     {", "if    (  (  !  ( softwareMode )  )     &  &     ( config . allowSoftwareMode )  )     {", "softwareMode    =    true ;", "System . setProperty (  \" allowSoftwareOpenGL \"  ,     \" true \"  )  ;", "createDisplayPixelFormat ( useGL 3  0  ,    gles 3  0 ContextMajor ,    gles 3  0 ContextMinor )  ;", "return ;", "}", "throw   new   GdxRuntimeException (  \" OpenGL   is   not   supported   by   the   video   driver .  \"  ,    ex 3  )  ;", "}", "if    (  ( getDisplayMode (  )  . bitsPerPixel )     =  =     1  6  )     {", "bufferFormat    =    new   BufferFormat (  5  ,     6  ,     5  ,     0  ,     8  ,     0  ,     0  ,    false )  ;", "}", "if    (  ( getDisplayMode (  )  . bitsPerPixel )     =  =     2  4  )     {", "bufferFormat    =    new   BufferFormat (  8  ,     8  ,     8  ,     0  ,     8  ,     0  ,     0  ,    false )  ;", "}", "if    (  ( getDisplayMode (  )  . bitsPerPixel )     =  =     3  2  )     {", "bufferFormat    =    new   BufferFormat (  8  ,     8  ,     8  ,     8  ,     8  ,     0  ,     0  ,    false )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["createDisplayPixelFormat"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "LwjglGraphics . extensions    =    new   com . badlogic . gdx . utils . Array < String >  (  )  ;", "if    ( LwjglGraphics . glVersion . isVersionEqualToOrHigher (  3  ,     2  )  )     {", "int   numExtensions    =    GL 1  1  . glGetInteger ( GL _ NUM _ EXTENSIONS )  ;", "for    ( int   i    =     0  ;    i    <    numExtensions ;     +  + i )", "LwjglGraphics . extensions . add ( com . badlogic . gdx . graphics . glGetStringi ( GL _ EXTENSIONS ,    i )  )  ;", "} else    {", "LwjglGraphics . extensions . addAll ( glGetString ( GL _ EXTENSIONS )  . split (  \"     \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["extractExtensions"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "String   versionString    =    glGetString ( GL _ VERSION )  ;", "String   vendorString    =    glGetString ( GL _ VENDOR )  ;", "String   rendererString    =    glGetString ( GL _ RENDERER )  ;", "LwjglGraphics . glVersion    =    new   graphics . glutils . GLVersion ( ApplicationType . Desktop ,    versionString ,    vendorString ,    rendererString )  ;", "}", "METHOD_END"], "methodName": ["extractVersion"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return    ( LwjglGraphics . glVersion . isVersionEqualToOrHigher (  4  ,     1  )  )     |  |     ( LwjglGraphics . extensions . contains (  \" GL _ ARB _ ES 2  _ compatibility \"  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["fullCompatibleWithGLES2"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   LwjglGraphics . glVersion . isVersionEqualToOrHigher (  4  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["fullCompatibleWithGLES3"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   deltaTime ;", "}", "METHOD_END"], "methodName": ["getDeltaTime"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   frameId ;", "}", "METHOD_END"], "methodName": ["getFrameId"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   fps ;", "}", "METHOD_END"], "methodName": ["getFramesPerSecond"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   gl 2  0  ;", "}", "METHOD_END"], "methodName": ["getGL20"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   LwjglGraphics . glVersion ;", "}", "METHOD_END"], "methodName": ["getGLVersion"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "if    (  ( canvas )     !  =    null )", "return   Math . max (  1  ,    canvas . getHeight (  )  )  ;", "else", "return    (  ( int )     (  ( getHeight (  )  )     *     ( getPixelScaleFactor (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   deltaTime ;", "}", "METHOD_END"], "methodName": ["getRawDeltaTime"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   GraphicsType . LWJGL ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "if    (  ( canvas )     !  =    null )", "return   Math . max (  1  ,    canvas . getWidth (  )  )  ;", "else", "return    (  ( int )     (  ( getWidth (  )  )     *     ( getPixelScaleFactor (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "LwjglGraphics . extractVersion (  )  ;", "LwjglGraphics . extractExtensions (  )  ;", "initiateGLInstances (  )  ;", "}", "METHOD_END"], "methodName": ["initiateGL"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "if    ( usingGL 3  0  )     {", "gl 3  0     =    new   LwjglGL 3  0  (  )  ;", "gl 2  0     =    gl 3  0  ;", "} else    {", "gl 2  0     =    new   LwjglGL 2  0  (  )  ;", "}", "if    (  !  ( LwjglGraphics . glVersion . isVersionEqualToOrHigher (  2  ,     0  )  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  \" OpenGL    2  .  0    or   higher   with   the   FBO   extension   is   required .    OpenGL   version :     \"     +     ( GL 1  1  . glGetString ( GL _ VERSION )  )  )     +     \"  \\ n \"  )     +     ( LwjglGraphics . glVersion . getDebugVersionString (  )  )  )  )  ;", "if    (  !  ( LwjglGraphics . supportsFBO (  )  )  )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  \" OpenGL    2  .  0    or   higher   with   the   FBO   extension   is   required .    OpenGL   version :     \"     +     ( GL 1  1  . glGetString ( GL _ VERSION )  )  )     +     \"  ,    FBO   extension :    false \\ n \"  )     +     ( LwjglGraphics . glVersion . getDebugVersionString (  )  )  )  )  ;", "}", "Gdx . gl    =    gl 2  0  ;", "Gdx . gl 2  0     =    gl 2  0  ;", "Gdx . gl 3  0     =    gl 3  0  ;", "}", "METHOD_END"], "methodName": ["initiateGLInstances"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return    ( gl 2  0  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isGL20Available"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return   softwareMode ;", "}", "METHOD_END"], "methodName": ["isSoftwareMode"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "if    ( config . useHDPI )     {", "System . setProperty (  \" enableHighDPI \"  ,     \" true \"  )  ;", "}", "if    (  ( canvas )     !  =    null )     {", "Display . setParent ( canvas )  ;", "} else    {", "boolean   displayCreated    =    false ;", "if    (  !  ( config . fullscreen )  )     {", "displayCreated    =    setWindowedMode ( config . width ,    config . height )  ;", "} else    {", "DisplayMode   bestMode    =    null ;", "for    ( DisplayMode   mode    :    getDisplayModes (  )  )     {", "if    (  (  ( mode . width )     =  =     ( config . width )  )     &  &     (  ( mode . height )     =  =     ( config . height )  )  )     {", "if    (  ( bestMode    =  =    null )     |  |     (  ( bestMode . refreshRate )     <     ( this . getDisplayMode (  )  . refreshRate )  )  )     {", "bestMode    =    mode ;", "}", "}", "}", "if    ( bestMode    =  =    null )     {", "bestMode    =    this . getDisplayMode (  )  ;", "}", "displayCreated    =    setFullscreenMode ( bestMode )  ;", "}", "if    (  ! displayCreated )     {", "if    (  ( config . setDisplayModeCallback )     !  =    null )     {", "config    =    config . setDisplayModeCallback . onFailure ( config )  ;", "if    (  ( config )     !  =    null )     {", "displayCreated    =    setWindowedMode ( config . width ,    config . height )  ;", "}", "}", "if    (  ! displayCreated )     {", "throw   new   GdxRuntimeException (  (  (  (  (  (  \" Couldn ' t   set   display   mode    \"     +     ( config . width )  )     +     \" x \"  )     +     ( config . height )  )     +     \"  ,    fullscreen :     \"  )     +     ( config . fullscreen )  )  )  ;", "}", "}", "if    (  ( config . iconPaths . size )     >     0  )     {", "ByteBuffer [  ]    icons    =    new   ByteBuffer [ config . iconPaths . size ]  ;", "for    ( int   i    =     0  ,    n    =    config . iconPaths . size ;    i    <    n ;    i +  +  )     {", "Pixmap   pixmap    =    new   Pixmap ( files . getFileHandle ( config . iconPaths . get ( i )  ,    config . iconFileTypes . get ( i )  )  )  ;", "if    (  ( pixmap . getFormat (  )  )     !  =     ( Format . RGBA 8  8  8  8  )  )     {", "Pixmap   rgba    =    new   Pixmap ( pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    Format . RGBA 8  8  8  8  )  ;", "rgba . drawPixmap ( pixmap ,     0  ,     0  )  ;", "pixmap . dispose (  )  ;", "pixmap    =    rgba ;", "}", "icons [ i ]     =    ByteBuffer . allocateDirect ( pixmap . getPixels (  )  . limit (  )  )  ;", "icons [ i ]  . put ( pixmap . getPixels (  )  )  . flip (  )  ;", "pixmap . dispose (  )  ;", "}", "Display . setIcon ( icons )  ;", "}", "}", "Display . setTitle ( config . title )  ;", "Display . setResizable ( config . resizable )  ;", "Display . setInitialBackground ( config . initialBackgroundColor . r ,    config . initialBackgroundColor . g ,    config . initialBackgroundColor . b )  ;", "Display . setLocation ( config . x ,    config . y )  ;", "createDisplayPixelFormat ( config . useGL 3  0  ,    config . gles 3  0 ContextMajorVersion ,    config . gles 3  0 ContextMinorVersion )  ;", "initiateGL (  )  ;", "}", "METHOD_END"], "methodName": ["setupDisplay"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "boolean   rq    =    requestRering ;", "requestRering    =    false ;", "return    ( rq    |  |     ( isContinuous )  )     |  |     ( Display . isDirty (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["shouldRender"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return    (  ( LwjglGraphics . glVersion . isVersionEqualToOrHigher (  3  ,     0  )  )     |  |     ( LwjglGraphics . extensions . contains (  \" GL _ EXT _ framebuffer _ object \"  ,    false )  )  )     |  |     ( LwjglGraphics . extensions . contains (  \" GL _ ARB _ framebuffer _ object \"  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["supportsFBO"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "long   time    =    System . nanoTime (  )  ;", "deltaTime    =     ( time    -     ( lastTime )  )     /     1  .  0 E 9 F ;", "lastTime    =    time ;", "if    (  ( time    -     ( frameStart )  )     >  =     1  0  0  0  0  0  0  0  0  0  )     {", "fps    =    frames ;", "frames    =     0  ;", "frameStart    =    time ;", "}", "( frames )  +  +  ;", "}", "METHOD_END"], "methodName": ["updateTime"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglGraphics"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getAccelerometerX"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getAccelerometerY"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getAccelerometerZ"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "switch    ( lwjglKeyCode )     {", "case   Keyboard . KEY _ LBRACKET    :", "return   Keys . LEFT _ BRACKET ;", "case   Keyboard . KEY _ RBRACKET    :", "return   Keys . RIGHT _ BRACKET ;", "case   Keyboard . KEY _ GRAVE    :", "return   Keys . GRAVE ;", "case   Keyboard . KEY _ MULTIPLY    :", "return   Keys . STAR ;", "case   Keyboard . KEY _ NUMLOCK    :", "return   Keys . NUM ;", "case   Keyboard . KEY _ DECIMAL    :", "return   Keys . PERIOD ;", "case   Keyboard . KEY _ DIVIDE    :", "return   Keys . SLASH ;", "case   Keyboard . KEY _ LMETA    :", "return   Keys . SYM ;", "case   Keyboard . KEY _ RMETA    :", "return   Keys . SYM ;", "case   Keyboard . KEY _ NUMPADEQUALS    :", "return   Keys . EQUALS ;", "case   Keyboard . KEY _ AT    :", "return   Keys . AT ;", "case   Keyboard . KEY _ EQUALS    :", "return   Keys . EQUALS ;", "case   Keyboard . KEY _ NUMPADCOMMA    :", "return   Keys . COMMA ;", "case   Keyboard . KEY _ NUMPADENTER    :", "return   Keys . ENTER ;", "case   Keyboard . KEY _  0     :", "return   Keys . NUM _  0  ;", "case   Keyboard . KEY _  1     :", "return   Keys . NUM _  1  ;", "case   Keyboard . KEY _  2     :", "return   Keys . NUM _  2  ;", "case   Keyboard . KEY _  3     :", "return   Keys . NUM _  3  ;", "case   Keyboard . KEY _  4     :", "return   Keys . NUM _  4  ;", "case   Keyboard . KEY _  5     :", "return   Keys . NUM _  5  ;", "case   Keyboard . KEY _  6     :", "return   Keys . NUM _  6  ;", "case   Keyboard . KEY _  7     :", "return   Keys . NUM _  7  ;", "case   Keyboard . KEY _  8     :", "return   Keys . NUM _  8  ;", "case   Keyboard . KEY _  9     :", "return   Keys . NUM _  9  ;", "case   Keyboard . KEY _ A    :", "return   Keys . A ;", "case   Keyboard . KEY _ B    :", "return   Keys . B ;", "case   Keyboard . KEY _ C    :", "return   Keys . C ;", "case   Keyboard . KEY _ D    :", "return   Keys . D ;", "case   Keyboard . KEY _ E    :", "return   Keys . E ;", "case   Keyboard . KEY _ F    :", "return   Keys . F ;", "case   Keyboard . KEY _ G    :", "return   Keys . G ;", "case   Keyboard . KEY _ H    :", "return   Keys . H ;", "case   Keyboard . KEY _ I    :", "return   Keys . I ;", "case   Keyboard . KEY _ J    :", "return   Keys . J ;", "case   Keyboard . KEY _ K    :", "return   Keys . K ;", "case   Keyboard . KEY _ L    :", "return   Keys . L ;", "case   Keyboard . KEY _ M    :", "return   Keys . M ;", "case   Keyboard . KEY _ N    :", "return   Keys . N ;", "case   Keyboard . KEY _ O    :", "return   Keys . O ;", "case   Keyboard . KEY _ P    :", "return   Keys . P ;", "case   Keyboard . KEY _ Q    :", "return   Keys . Q ;", "case   Keyboard . KEY _ R    :", "return   Keys . R ;", "case   Keyboard . KEY _ S    :", "return   Keys . S ;", "case   Keyboard . KEY _ T    :", "return   Keys . T ;", "case   Keyboard . KEY _ U    :", "return   Keys . U ;", "case   Keyboard . KEY _ V    :", "return   Keys . V ;", "case   Keyboard . KEY _ W    :", "return   Keys . W ;", "case   Keyboard . KEY _ X    :", "return   Keys . X ;", "case   Keyboard . KEY _ Y    :", "return   Keys . Y ;", "case   Keyboard . KEY _ Z    :", "return   Keys . Z ;", "case   Keyboard . KEY _ LMENU    :", "return   Keys . ALT _ LEFT ;", "case   Keyboard . KEY _ RMENU    :", "return   Keys . ALT _ RIGHT ;", "case   Keyboard . KEY _ BACKSLASH    :", "return   Keys . BACKSLASH ;", "case   Keyboard . KEY _ COMMA    :", "return   Keys . COMMA ;", "case   Keyboard . KEY _ DELETE    :", "return   Keys . FORWARD _ DEL ;", "case   Keyboard . KEY _ LEFT    :", "return   Keys . DPAD _ LEFT ;", "case   Keyboard . KEY _ RIGHT    :", "return   Keys . DPAD _ RIGHT ;", "case   Keyboard . KEY _ UP    :", "return   Keys . DPAD _ UP ;", "case   Keyboard . KEY _ DOWN    :", "return   Keys . DPAD _ DOWN ;", "case   Keyboard . KEY _ RETURN    :", "return   Keys . ENTER ;", "case   Keyboard . KEY _ HOME    :", "return   Keys . HOME ;", "case   Keyboard . KEY _ MINUS    :", "return   Keys . MINUS ;", "case   Keyboard . KEY _ PERIOD    :", "return   Keys . PERIOD ;", "case   Keyboard . KEY _ ADD    :", "return   Keys . PLUS ;", "case   Keyboard . KEY _ SEMICOLON    :", "return   Keys . SEMICOLON ;", "case   Keyboard . KEY _ LSHIFT    :", "return   Keys . SHIFT _ LEFT ;", "case   Keyboard . KEY _ RSHIFT    :", "return   Keys . SHIFT _ RIGHT ;", "case   Keyboard . KEY _ SLASH    :", "return   Keys . SLASH ;", "case   Keyboard . KEY _ SPACE    :", "return   Keys . SPACE ;", "case   Keyboard . KEY _ TAB    :", "return   Keys . TAB ;", "case   Keyboard . KEY _ LCONTROL    :", "return   Keys . CONTROL _ LEFT ;", "case   Keyboard . KEY _ RCONTROL    :", "return   Keys . CONTROL _ RIGHT ;", "case   Keyboard . KEY _ NEXT    :", "return   Keys . PAGE _ DOWN ;", "case   Keyboard . KEY _ PRIOR    :", "return   Keys . PAGE _ UP ;", "case   Keyboard . KEY _ ESCAPE    :", "return   Keys . ESCAPE ;", "case   Keyboard . KEY _ END    :", "return   Keys . END ;", "case   Keyboard . KEY _ INSERT    :", "return   Keys . INSERT ;", "case   Keyboard . KEY _ BACK    :", "return   Keys . DEL ;", "case   Keyboard . KEY _ SUBTRACT    :", "return   Keys . MINUS ;", "case   Keyboard . KEY _ APOSTROPHE    :", "return   Keys . APOSTROPHE ;", "case   Keyboard . KEY _ F 1     :", "return   Keys . F 1  ;", "case   Keyboard . KEY _ F 2     :", "return   Keys . F 2  ;", "case   Keyboard . KEY _ F 3     :", "return   Keys . F 3  ;", "case   Keyboard . KEY _ F 4     :", "return   Keys . F 4  ;", "case   Keyboard . KEY _ F 5     :", "return   Keys . F 5  ;", "case   Keyboard . KEY _ F 6     :", "return   Keys . F 6  ;", "case   Keyboard . KEY _ F 7     :", "return   Keys . F 7  ;", "case   Keyboard . KEY _ F 8     :", "return   Keys . F 8  ;", "case   Keyboard . KEY _ F 9     :", "return   Keys . F 9  ;", "case   Keyboard . KEY _ F 1  0     :", "return   Keys . F 1  0  ;", "case   Keyboard . KEY _ F 1  1     :", "return   Keys . F 1  1  ;", "case   Keyboard . KEY _ F 1  2     :", "return   Keys . F 1  2  ;", "case   Keyboard . KEY _ COLON    :", "return   Keys . COLON ;", "case   Keyboard . KEY _ NUMPAD 0     :", "return   Keys . NUMPAD _  0  ;", "case   Keyboard . KEY _ NUMPAD 1     :", "return   Keys . NUMPAD _  1  ;", "case   Keyboard . KEY _ NUMPAD 2     :", "return   Keys . NUMPAD _  2  ;", "case   Keyboard . KEY _ NUMPAD 3     :", "return   Keys . NUMPAD _  3  ;", "case   Keyboard . KEY _ NUMPAD 4     :", "return   Keys . NUMPAD _  4  ;", "case   Keyboard . KEY _ NUMPAD 5     :", "return   Keys . NUMPAD _  5  ;", "case   Keyboard . KEY _ NUMPAD 6     :", "return   Keys . NUMPAD _  6  ;", "case   Keyboard . KEY _ NUMPAD 7     :", "return   Keys . NUMPAD _  7  ;", "case   Keyboard . KEY _ NUMPAD 8     :", "return   Keys . NUMPAD _  8  ;", "case   Keyboard . KEY _ NUMPAD 9     :", "return   Keys . NUMPAD _  9  ;", "default    :", "return   Keys . UNKNOWN ;", "}", "}", "METHOD_END"], "methodName": ["getGdxKeyCode"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getGyroscopeX"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getGyroscopeY"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getGyroscopeZ"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "switch    ( gdxKeyCode )     {", "case   Keys . APOSTROPHE    :", "return   Keyboard . KEY _ APOSTROPHE ;", "case   Keys . LEFT _ BRACKET    :", "return   Keyboard . KEY _ LBRACKET ;", "case   Keys . RIGHT _ BRACKET    :", "return   Keyboard . KEY _ RBRACKET ;", "case   Keys . GRAVE    :", "return   Keyboard . KEY _ GRAVE ;", "case   Keys . STAR    :", "return   Keyboard . KEY _ MULTIPLY ;", "case   Keys . NUM    :", "return   Keyboard . KEY _ NUMLOCK ;", "case   Keys . AT    :", "return   Keyboard . KEY _ AT ;", "case   Keys . EQUALS    :", "return   Keyboard . KEY _ EQUALS ;", "case   Keys . SYM    :", "return   Keyboard . KEY _ LMETA ;", "case   Keys . NUM _  0     :", "return   Keyboard . KEY _  0  ;", "case   Keys . NUM _  1     :", "return   Keyboard . KEY _  1  ;", "case   Keys . NUM _  2     :", "return   Keyboard . KEY _  2  ;", "case   Keys . NUM _  3     :", "return   Keyboard . KEY _  3  ;", "case   Keys . NUM _  4     :", "return   Keyboard . KEY _  4  ;", "case   Keys . NUM _  5     :", "return   Keyboard . KEY _  5  ;", "case   Keys . NUM _  6     :", "return   Keyboard . KEY _  6  ;", "case   Keys . NUM _  7     :", "return   Keyboard . KEY _  7  ;", "case   Keys . NUM _  8     :", "return   Keyboard . KEY _  8  ;", "case   Keys . NUM _  9     :", "return   Keyboard . KEY _  9  ;", "case   Keys . A    :", "return   Keyboard . KEY _ A ;", "case   Keys . B    :", "return   Keyboard . KEY _ B ;", "case   Keys . C    :", "return   Keyboard . KEY _ C ;", "case   Keys . D    :", "return   Keyboard . KEY _ D ;", "case   Keys . E    :", "return   Keyboard . KEY _ E ;", "case   Keys . F    :", "return   Keyboard . KEY _ F ;", "case   Keys . G    :", "return   Keyboard . KEY _ G ;", "case   Keys . H    :", "return   Keyboard . KEY _ H ;", "case   Keys . I    :", "return   Keyboard . KEY _ I ;", "case   Keys . J    :", "return   Keyboard . KEY _ J ;", "case   Keys . K    :", "return   Keyboard . KEY _ K ;", "case   Keys . L    :", "return   Keyboard . KEY _ L ;", "case   Keys . M    :", "return   Keyboard . KEY _ M ;", "case   Keys . N    :", "return   Keyboard . KEY _ N ;", "case   Keys . O    :", "return   Keyboard . KEY _ O ;", "case   Keys . P    :", "return   Keyboard . KEY _ P ;", "case   Keys . Q    :", "return   Keyboard . KEY _ Q ;", "case   Keys . R    :", "return   Keyboard . KEY _ R ;", "case   Keys . S    :", "return   Keyboard . KEY _ S ;", "case   Keys . T    :", "return   Keyboard . KEY _ T ;", "case   Keys . U    :", "return   Keyboard . KEY _ U ;", "case   Keys . V    :", "return   Keyboard . KEY _ V ;", "case   Keys . W    :", "return   Keyboard . KEY _ W ;", "case   Keys . X    :", "return   Keyboard . KEY _ X ;", "case   Keys . Y    :", "return   Keyboard . KEY _ Y ;", "case   Keys . Z    :", "return   Keyboard . KEY _ Z ;", "case   Keys . ALT _ LEFT    :", "return   Keyboard . KEY _ LMENU ;", "case   Keys . ALT _ RIGHT    :", "return   Keyboard . KEY _ RMENU ;", "case   Keys . BACKSLASH    :", "return   Keyboard . KEY _ BACKSLASH ;", "case   Keys . COMMA    :", "return   Keyboard . KEY _ COMMA ;", "case   Keys . FORWARD _ DEL    :", "return   Keyboard . KEY _ DELETE ;", "case   Keys . DPAD _ LEFT    :", "return   Keyboard . KEY _ LEFT ;", "case   Keys . DPAD _ RIGHT    :", "return   Keyboard . KEY _ RIGHT ;", "case   Keys . DPAD _ UP    :", "return   Keyboard . KEY _ UP ;", "case   Keys . DPAD _ DOWN    :", "return   Keyboard . KEY _ DOWN ;", "case   Keys . ENTER    :", "return   Keyboard . KEY _ RETURN ;", "case   Keys . HOME    :", "return   Keyboard . KEY _ HOME ;", "case   Keys . END    :", "return   Keyboard . KEY _ END ;", "case   Keys . PAGE _ DOWN    :", "return   Keyboard . KEY _ NEXT ;", "case   Keys . PAGE _ UP    :", "return   Keyboard . KEY _ PRIOR ;", "case   Keys . INSERT    :", "return   Keyboard . KEY _ INSERT ;", "case   Keys . MINUS    :", "return   Keyboard . KEY _ MINUS ;", "case   Keys . PERIOD    :", "return   Keyboard . KEY _ PERIOD ;", "case   Keys . PLUS    :", "return   Keyboard . KEY _ ADD ;", "case   Keys . SEMICOLON    :", "return   Keyboard . KEY _ SEMICOLON ;", "case   Keys . SHIFT _ LEFT    :", "return   Keyboard . KEY _ LSHIFT ;", "case   Keys . SHIFT _ RIGHT    :", "return   Keyboard . KEY _ RSHIFT ;", "case   Keys . SLASH    :", "return   Keyboard . KEY _ SLASH ;", "case   Keys . SPACE    :", "return   Keyboard . KEY _ SPACE ;", "case   Keys . TAB    :", "return   Keyboard . KEY _ TAB ;", "case   Keys . DEL    :", "return   Keyboard . KEY _ BACK ;", "case   Keys . CONTROL _ LEFT    :", "return   Keyboard . KEY _ LCONTROL ;", "case   Keys . CONTROL _ RIGHT    :", "return   Keyboard . KEY _ RCONTROL ;", "case   Keys . ESCAPE    :", "return   Keyboard . KEY _ ESCAPE ;", "case   Keys . F 1     :", "return   Keyboard . KEY _ F 1  ;", "case   Keys . F 2     :", "return   Keyboard . KEY _ F 2  ;", "case   Keys . F 3     :", "return   Keyboard . KEY _ F 3  ;", "case   Keys . F 4     :", "return   Keyboard . KEY _ F 4  ;", "case   Keys . F 5     :", "return   Keyboard . KEY _ F 5  ;", "case   Keys . F 6     :", "return   Keyboard . KEY _ F 6  ;", "case   Keys . F 7     :", "return   Keyboard . KEY _ F 7  ;", "case   Keys . F 8     :", "return   Keyboard . KEY _ F 8  ;", "case   Keys . F 9     :", "return   Keyboard . KEY _ F 9  ;", "case   Keys . F 1  0     :", "return   Keyboard . KEY _ F 1  0  ;", "case   Keys . F 1  1     :", "return   Keyboard . KEY _ F 1  1  ;", "case   Keys . F 1  2     :", "return   Keyboard . KEY _ F 1  2  ;", "case   Keys . COLON    :", "return   Keyboard . KEY _ COLON ;", "case   Keys . NUMPAD _  0     :", "return   Keyboard . KEY _ NUMPAD 0  ;", "case   Keys . NUMPAD _  1     :", "return   Keyboard . KEY _ NUMPAD 1  ;", "case   Keys . NUMPAD _  2     :", "return   Keyboard . KEY _ NUMPAD 2  ;", "case   Keys . NUMPAD _  3     :", "return   Keyboard . KEY _ NUMPAD 3  ;", "case   Keys . NUMPAD _  4     :", "return   Keyboard . KEY _ NUMPAD 4  ;", "case   Keys . NUMPAD _  5     :", "return   Keyboard . KEY _ NUMPAD 5  ;", "case   Keys . NUMPAD _  6     :", "return   Keyboard . KEY _ NUMPAD 6  ;", "case   Keys . NUMPAD _  7     :", "return   Keyboard . KEY _ NUMPAD 7  ;", "case   Keys . NUMPAD _  8     :", "return   Keyboard . KEY _ NUMPAD 8  ;", "case   Keys . NUMPAD _  9     :", "return   Keyboard . KEY _ NUMPAD 9  ;", "default    :", "return   Keyboard . KEY _ NONE ;", "}", "}", "METHOD_END"], "methodName": ["getLwjglKeyCode"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "SwingUtilities . invokeLater ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "JPanel   panel    =    new   JPanel ( new   FlowLayout (  )  )  ;", "JPanel   textPanel    =    new   JPanel (  )     {", "public   boolean   isOptimizedDrawingEnabled (  )     {", "return   false ;", "}", "}  ;", "textPanel . setLayout ( new   OverlayLayout ( textPanel )  )  ;", "panel . add ( textPanel )  ;", "final   JTextField   textField    =    new   JTextField (  2  0  )  ;", "textField . setText ( text )  ;", "textField . setAlignmentX (  0  .  0 F )  ;", "textPanel . add ( textField )  ;", "final   JLabel   placeholderLabel    =    new   JLabel ( hint )  ;", "placeholderLabel . setForeground ( Color . GRAY )  ;", "placeholderLabel . setAlignmentX (  0  .  0 F )  ;", "textPanel . add ( placeholderLabel ,     0  )  ;", "textField . getDocument (  )  . addDocumentListener ( new   DocumentListener (  )     {", "@ Override", "public   void   removeUpdate ( DocumentEvent   arg 0  )     {", "this . updated (  )  ;", "}", "@ Override", "public   void   insertUpdate ( DocumentEvent   arg 0  )     {", "this . updated (  )  ;", "}", "@ Override", "public   void   changedUpdate ( DocumentEvent   arg 0  )     {", "this . updated (  )  ;", "}", "private   void   updated (  )     {", "if    (  ( textField . getText (  )  . length (  )  )     =  =     0  )", "placeholderLabel . setVisible ( true )  ;", "else", "placeholderLabel . setVisible ( false )  ;", "}", "}  )  ;", "JOptionPane   pane    =    new   JOptionPane ( panel ,    JOptionPane . QUESTION _ MESSAGE ,    JOptionPane . OK _ CANCEL _ OPTION ,    null ,    null ,    null )  ;", "pane . setInitialValue ( null )  ;", "pane . setComponentOrientation ( JOptionPane . getRootFrame (  )  . getComponentOrientation (  )  )  ;", "Border   border    =    textField . getBorder (  )  ;", "placeholderLabel . setBorder ( new   EmptyBorder ( border . getBorderInsets ( textField )  )  )  ;", "JDialog   dialog    =    pane . createDialog ( null ,    title )  ;", "pane . selectInitialValue (  )  ;", "dialog . addWindowFocusListener ( new   WindowFocusListener (  )     {", "@ Override", "public   void   windowLostFocus ( WindowEvent   arg 0  )     {", "}", "@ Override", "public   void   windowGainedFocus ( WindowEvent   arg 0  )     {", "textField . requestFocusInWindow (  )  ;", "}", "}  )  ;", "dialog . setVisible ( true )  ;", "dialog . dispose (  )  ;", "Object   selectedValue    =    pane . getValue (  )  ;", "if    (  (  ( selectedValue    !  =    null )     &  &     ( selectedValue   instanceof   Integer )  )     &  &     (  (  (  ( Integer )     ( selectedValue )  )  . intValue (  )  )     =  =     ( JOptionPane . OK _ OPTION )  )  )     {", "listener . i ( textField . getText (  )  )  ;", "} else    {", "listener . canceled (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getTextInput"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  ( Mouse . getX (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    >     0  )", "return    0  ;", "else", "return   getX (  )  ;", "}", "METHOD_END"], "methodName": ["getX"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return    (  ( graphics . getHeight (  )  )     -     1  )     -     (  ( int )     (  ( Mouse . getY (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    >     0  )", "return    0  ;", "else", "return   getY (  )  ;", "}", "METHOD_END"], "methodName": ["getY"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isAccelerometerAvailable"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isGyroscopeAvailable"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Keyboard . isCreated (  )  )  )", "return   false ;", "if    ( key    =  =     ( Keys . ANY _ KEY )  )", "return    ( pressedKeys )     >     0  ;", "else", "return   Keyboard . isKeyDown (  . getLwjglKeyCode ( key )  )  ;", "}", "METHOD_END"], "methodName": ["isKeyPressed"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "boolean   button    =     (  ( Mouse . isButtonDown (  0  )  )     |  |     ( Mouse . isButtonDown (  1  )  )  )     |  |     ( Mouse . isButtonDown (  2  )  )  ;", "return   button ;", "}", "METHOD_END"], "methodName": ["isTouched"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "if    ( pointer    >     0  )", "return   false ;", "else", "return   isTouched (  )  ;", "}", "METHOD_END"], "methodName": ["isTouched"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  ( processor )     !  =    null )     {", "InputProcessor   processor    =    this . processor ;", "int   len    =    keyEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". KeyEvent   e    =    keyEvents . get ( i )  ;", "currentEventTimeStamp    =    e . timeStamp ;", "switch    ( e . type )     {", "case    . KeyEvent . KEY _ DOWN    :", "processor . keyDown ( e . keyCode )  ;", "break ;", "case    . KeyEvent . KEY _ UP    :", "processor . keyUp ( e . keyCode )  ;", "break ;", "case    . KeyEvent . KEY _ TYPED    :", "processor . keyTyped ( e . keyChar )  ;", "}", "usedKeyEvents . free ( e )  ;", "}", "len    =    touchEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", ". TouchEvent   e    =    touchEvents . get ( i )  ;", "currentEventTimeStamp    =    e . timeStamp ;", "switch    ( e . type )     {", "case    . TouchEvent . TOUCH _ DOWN    :", "processor . touchDown ( e . x ,    e . y ,    e . pointer ,    e . button )  ;", "break ;", "case    . TouchEvent . TOUCH _ UP    :", "processor . touchUp ( e . x ,    e . y ,    e . pointer ,    e . button )  ;", "break ;", "case    . TouchEvent . TOUCH _ DRAGGED    :", "processor . touchDragged ( e . x ,    e . y ,    e . pointer )  ;", "break ;", "case    . TouchEvent . TOUCH _ MOVED    :", "processor . mouseMoved ( e . x ,    e . y )  ;", "break ;", "case    . TouchEvent . TOUCH _ SCROLLED    :", "processor . scrolled ( e . scrollAmount )  ;", "}", "usedTouchEvents . free ( e )  ;", "}", "} else    {", "int   len    =    touchEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "usedTouchEvents . free ( touchEvents . get ( i )  )  ;", "}", "len    =    keyEvents . size (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "usedKeyEvents . free ( keyEvents . get ( i )  )  ;", "}", "}", "keyEvents . clear (  )  ;", "touchEvents . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processEvents"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["supportsMultitouch"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "if    ( button    =  =     0  )", "return   Input . Buttons . LEFT ;", "if    ( button    =  =     1  )", "return   Input . Buttons . RIGHT ;", "if    ( button    =  =     2  )", "return   Input . Buttons . MIDDLE ;", "if    ( button    =  =     3  )", "return   Input . Buttons . BACK ;", "if    ( button    =  =     4  )", "return   Input . Buttons . FORWARD ;", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["toGdxButton"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "switch    ( button )     {", "case   Buttons . LEFT    :", "return    0  ;", "case   Buttons . RIGHT    :", "return    1  ;", "case   Buttons . MIDDLE    :", "return    2  ;", "case   Buttons . BACK    :", "return    3  ;", "case   Buttons . FORWARD    :", "return    4  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["toLwjglButton"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "updateTime (  )  ;", "updateMouse (  )  ;", "updateKeyboard (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "if    ( keyJustPressed )     {", "keyJustPressed    =    false ;", "for    ( int   i    =     0  ;    i    <     ( justPressedKeys . length )  ;    i +  +  )     {", "justPressedKeys [ i ]     =    false ;", "}", "}", "if    (  ( lastKeyCharPressed )     !  =     0  )     {", "keyRepeatTimer    -  =    deltaTime ;", "if    (  ( keyRepeatTimer )     <     0  )     {", "keyRepeatTimer    =     . keyRepeatTime ;", ". KeyEvent   event    =    usedKeyEvents . obtain (  )  ;", "event . keyCode    =     0  ;", "event . keyChar    =    lastKeyCharPressed ;", "event . type    =     . KeyEvent . KEY _ TYPED ;", "event . timeStamp    =    System . nanoTime (  )  ;", "keyEvents . add ( event )  ;", "graphics . requestRendering (  )  ;", "}", "}", "if    ( Keyboard . isCreated (  )  )     {", "while    ( Keyboard . next (  )  )     {", "int   keyCode    =     . getGdxKeyCode ( Keyboard . getEventKey (  )  )  ;", "char   keyChar    =    Keyboard . getEventCharacter (  )  ;", "if    (  ( Keyboard . getEventKeyState (  )  )     |  |     (  (  ( keyCode    =  =     0  )     &  &     ( keyChar    !  =     0  )  )     &  &     ( Character . isDefined ( keyChar )  )  )  )     {", "long   timeStamp    =    Keyboard . getEventNanoseconds (  )  ;", "switch    ( keyCode )     {", "case   Keys . DEL    :", "keyChar    =     8  ;", "break ;", "case   Keys . FORWARD _ DEL    :", "keyChar    =     1  2  7  ;", "break ;", "}", "if    ( keyCode    !  =     0  )     {", ". KeyEvent   event    =    usedKeyEvents . obtain (  )  ;", "event . keyCode    =    keyCode ;", "event . keyChar    =     0  ;", "event . type    =     . KeyEvent . KEY _ DOWN ;", "event . timeStamp    =    timeStamp ;", "keyEvents . add ( event )  ;", "( pressedKeys )  +  +  ;", "keyJustPressed    =    true ;", "justPressedKeys [ keyCode ]     =    true ;", "lastKeyCharPressed    =    keyChar ;", "keyRepeatTimer    =     . keyRepeatInitialTime ;", "}", ". KeyEvent   event    =    usedKeyEvents . obtain (  )  ;", "event . keyCode    =     0  ;", "event . keyChar    =    keyChar ;", "event . type    =     . KeyEvent . KEY _ TYPED ;", "event . timeStamp    =    timeStamp ;", "keyEvents . add ( event )  ;", "} else    {", ". KeyEvent   event    =    usedKeyEvents . obtain (  )  ;", "event . keyCode    =    keyCode ;", "event . keyChar    =     0  ;", "event . type    =     . KeyEvent . KEY _ UP ;", "event . timeStamp    =    Keyboard . getEventNanoseconds (  )  ;", "keyEvents . add ( event )  ;", "( pressedKeys )  -  -  ;", "lastKeyCharPressed    =     0  ;", "}", "graphics . requestRendering (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateKeyboard"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "justTouched    =    false ;", "if    ( Mouse . isCreated (  )  )     {", "int   events    =     0  ;", "while    ( Mouse . next (  )  )     {", "events +  +  ;", "int   x    =     (  ( int )     (  ( Mouse . getEventX (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  ;", "int   y    =     (  ( graphics . getHeight (  )  )     -     (  ( int )     (  ( Mouse . getEventY (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  )     -     1  ;", "int   button    =    Mouse . getEventButton (  )  ;", "int   gdxButton    =    toGdxButton ( button )  ;", "if    (  ( button    !  =     (  -  1  )  )     &  &     ( gdxButton    =  =     (  -  1  )  )  )", "continue ;", ". TouchEvent   event    =    usedTouchEvents . obtain (  )  ;", "event . x    =    x ;", "event . y    =    y ;", "event . button    =    gdxButton ;", "event . pointer    =     0  ;", "event . timeStamp    =    Mouse . getEventNanoseconds (  )  ;", "if    ( button    =  =     (  -  1  )  )     {", "if    (  ( Mouse . getEventDWheel (  )  )     !  =     0  )     {", "event . type    =     . TouchEvent . TOUCH _ SCROLLED ;", "event . scrollAmount    =     (  ( int )     (  -  ( Math . signum ( Mouse . getEventDWheel (  )  )  )  )  )  ;", "} else", "if    (  ( pressedButtons . size )     >     0  )     {", "event . type    =     . TouchEvent . TOUCH _ DRAGGED ;", "} else    {", "event . type    =     . TouchEvent . TOUCH _ MOVED ;", "}", "} else    {", "if    ( Mouse . getEventButtonState (  )  )     {", "event . type    =     . TouchEvent . TOUCH _ DOWN ;", "pressedButtons . add ( event . button )  ;", "justTouched    =    true ;", "} else    {", "event . type    =     . TouchEvent . TOUCH _ UP ;", "pressedButtons . remove ( event . button )  ;", "}", "}", "touchEvents . add ( event )  ;", "mouseX    =    event . x ;", "mouseY    =    event . y ;", "deltaX    =     (  ( int )     (  ( Mouse . getEventDX (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  ;", "deltaY    =     (  ( int )     (  ( Mouse . getEventDY (  )  )     *     ( Display . getPixelScaleFactor (  )  )  )  )  ;", "}", "if    ( events    =  =     0  )     {", "deltaX    =     0  ;", "deltaY    =     0  ;", "} else    {", "graphics . requestRendering (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateMouse"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "long   thisTime    =    System . nanoTime (  )  ;", "deltaTime    =     ( thisTime    -     ( lastTime )  )     /     1  .  0 E 9 F ;", "lastTime    =    thisTime ;", "}", "METHOD_END"], "methodName": ["updateTime"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglInput"}, {"methodBody": ["METHOD_START", "{", "GdxNativesLoader . load (  )  ;", "if    ( GdxNativesLoader . disableNativesLoading )", "return ;", "if    (  !  (  . load )  )", "return ;", "SharedLibraryLoader   loader    =    new   SharedLibraryLoader (  )  ;", "File   nativesDir    =    null ;", "try    {", "if    ( isWindows )     {", "nativesDir    =    loader . extractFile (  ( is 6  4 Bit    ?     \" lwjgl 6  4  . dll \"     :     \" lwjgl . dll \"  )  ,    null )  . getParentFile (  )  ;", "if    (  !  ( LwjglApplicationConfiguration . disableAudio )  )", "loader . extractFileTo (  ( is 6  4 Bit    ?     \" OpenAL 6  4  . dll \"     :     \" OpenAL 3  2  . dll \"  )  ,    nativesDir )  ;", "} else", "if    ( isMac )     {", "nativesDir    =    loader . extractFile (  \" liblwjgl . dylib \"  ,    null )  . getParentFile (  )  ;", "if    (  !  ( LwjglApplicationConfiguration . disableAudio )  )", "loader . extractFileTo (  \" openal . dylib \"  ,    nativesDir )  ;", "} else", "if    ( isLinux )     {", "nativesDir    =    loader . extractFile (  ( is 6  4 Bit    ?     \" liblwjgl 6  4  . so \"     :     \" liblwjgl . so \"  )  ,    null )  . getParentFile (  )  ;", "if    (  !  ( LwjglApplicationConfiguration . disableAudio )  )", "loader . extractFileTo (  ( is 6  4 Bit    ?     \" libopenal 6  4  . so \"     :     \" libopenal . so \"  )  ,    nativesDir )  ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   GdxRuntimeException (  \" Unable   to   extract   LWJGL   natives .  \"  ,    ex )  ;", "}", "System . setProperty (  \" librarypath \"  ,    nativesDir . getAbsolutePath (  )  )  ;", ". load    =    false ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.backends.lwjgl.LwjglNativesLoader"}, {"methodBody": ["METHOD_START", "{", "line . close (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.JavaSoundAudioRecorder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffer . length )     <     ( numSamples    *     2  )  )", "buffer    =    new   byte [ numSamples    *     2  ]  ;", "int   tad    =    numSamples    *     2  ;", "int   read    =     0  ;", "while    ( read    !  =    tad )", "read    +  =    line . read ( buffer ,    read ,     ( tad    -    read )  )  ;", "for    ( int   i    =     0  ,    j    =     0  ;    i    <     ( numSamples    *     2  )  ;    i    +  =     2     ,    j +  +  )", "samples [  ( offset    +    j )  ]     =     (  ( short )     (  (  ( buffer [  ( i    +     1  )  ]  )     <  <     8  )     |     (  ( buffer [ i ]  )     &     2  5  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.JavaSoundAudioRecorder"}, {"methodBody": ["METHOD_START", "{", "return    ( endOfStream )     &  &     (  ( readIndex )     >  =     ( outIndex )  )  ;", "}", "METHOD_END"], "methodName": ["atEnd"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   endOfStream    ?     0     :     1  ;", "}", "METHOD_END"], "methodName": ["available"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "StreamUtils . closeQuietly ( input )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   oggInfo . channels ;", "}", "METHOD_END"], "methodName": ["getChannels"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   total ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "int   index    =    syncState . buffer ( OggInputStream . BUFFER _ SIZE )  ;", "if    ( index    =  =     (  -  1  )  )", "return   false ;", "buffer    =    syncState . data ;", "if    (  ( buffer )     =  =    null )     {", "endOfStream    =    true ;", "return   false ;", "}", "try    {", "bytes    =    input . read ( buffer ,    index ,    OggInputStream . BUFFER _ SIZE )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  \" Failure   reading   Vorbis .  \"  ,    e )  ;", "}", "syncState . wrote ( bytes )  ;", "if    (  ( syncState . pageout ( page )  )     !  =     1  )     {", "if    (  ( bytes )     <     ( OggInputStream . BUFFER _ SIZE )  )", "return   false ;", "throw   new   GdxRuntimeException (  \" Input   does   not   appear   to   be   an   Ogg   bitstream .  \"  )  ;", "}", "streamState . init ( page . serialno (  )  )  ;", "oggInfo . init (  )  ;", "comment . init (  )  ;", "if    (  ( streamState . pagein ( page )  )     <     0  )     {", "throw   new   GdxRuntimeException (  \" Error   reading   first   page   of   Ogg   bitstream .  \"  )  ;", "}", "if    (  ( streamState . packetout ( packet )  )     !  =     1  )     {", "throw   new   GdxRuntimeException (  \" Error   reading   initial   header   packet .  \"  )  ;", "}", "if    (  ( oggInfo . synthesis _ headerin ( comment ,    packet )  )     <     0  )     {", "throw   new   GdxRuntimeException (  \" Ogg   bitstream   does   not   contain   Vorbis   audio   data .  \"  )  ;", "}", "int   i    =     0  ;", "while    ( i    <     2  )     {", "while    ( i    <     2  )     {", "int   result    =    syncState . pageout ( page )  ;", "if    ( result    =  =     0  )", "break ;", "if    ( result    =  =     1  )     {", "streamState . pagein ( page )  ;", "while    ( i    <     2  )     {", "result    =    streamState . packetout ( packet )  ;", "if    ( result    =  =     0  )", "break ;", "if    ( result    =  =     (  -  1  )  )     {", "throw   new   GdxRuntimeException (  \" Corrupt   secondary   header .  \"  )  ;", "}", "oggInfo . synthesis _ headerin ( comment ,    packet )  ;", "i +  +  ;", "}", "}", "}", "index    =    syncState . buffer ( OggInputStream . BUFFER _ SIZE )  ;", "if    ( index    =  =     (  -  1  )  )", "return   false ;", "buffer    =    syncState . data ;", "try    {", "bytes    =    input . read ( buffer ,    index ,    OggInputStream . BUFFER _ SIZE )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  \" Failed   to   read   Vorbis .  \"  ,    e )  ;", "}", "if    (  (  ( bytes )     =  =     0  )     &  &     ( i    <     2  )  )     {", "throw   new   GdxRuntimeException (  \" End   of   file   before   finding   all   Vorbis   headers .  \"  )  ;", "}", "syncState . wrote ( bytes )  ;", "}", "convsize    =     ( OggInputStream . BUFFER _ SIZE )     /     ( oggInfo . channels )  ;", "dspState . synthesis _ init ( oggInfo )  ;", "vorbisBlock . init ( dspState )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["getPageAndPacket"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   oggInfo . rate ;", "}", "METHOD_END"], "methodName": ["getSampleRate"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "initVorbis (  )  ;", "dPCM (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "syncState . init (  )  ;", "}", "METHOD_END"], "methodName": ["initVorbis"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( readIndex )     >  =     ( outIndex )  )     {", "outIndex    =     0  ;", "readPCM (  )  ;", "readIndex    =     0  ;", "if    (  ( outIndex )     =  =     0  )", "return    -  1  ;", "}", "int   value    =    outBuffer [ readIndex ]  ;", "if    ( value    <     0  )", "value    =     2  5  6     +    value ;", "( readIndex )  +  +  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "return   read ( b ,     0  ,    b . length )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "int   value    =    d (  )  ;", "if    ( value    >  =     0  )     {", "b [ i ]     =     (  ( byte )     ( value )  )  ;", "} else    {", "if    ( i    =  =     0  )", "return    -  1  ;", "return   i ;", "}", "}", "return   len ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "boolean   wrote    =    false ;", "while    ( true )     {", "if    ( endOfBitStream )     {", "if    (  !  ( getPageAndPacket (  )  )  )     {", "break ;", "}", "endOfBitStream    =    false ;", "}", "if    (  !  ( inited )  )     {", "inited    =    true ;", "return ;", "}", "float [  ]  [  ]  [  ]     _ pcm    =    new   float [  1  ]  [  ]  [  ]  ;", "int [  ]     _ index    =    new   int [ oggInfo . channels ]  ;", "while    (  !  ( endOfBitStream )  )     {", "while    (  !  ( endOfBitStream )  )     {", "int   result    =    syncState . pageout ( page )  ;", "if    ( result    =  =     0  )     {", "break ;", "}", "if    ( result    =  =     (  -  1  )  )     {", "app . log (  \" gdx - audio \"  ,     \" Error   reading   OGG :    Corrupt   or   missing   data   in   bitstream .  \"  )  ;", "} else    {", "streamState . pagein ( page )  ;", "while    ( true )     {", "result    =    streamState . packetout ( packet )  ;", "if    ( result    =  =     0  )", "break ;", "if    ( result    =  =     (  -  1  )  )     {", "} else    {", "int   samples ;", "if    (  ( vorbisBlock . synthesis ( packet )  )     =  =     0  )     {", "dspState . synthesis _ blockin ( vorbisBlock )  ;", "}", "while    (  ( samples    =    dspState . synthesis _ pcmout (  _ pcm ,     _ index )  )     >     0  )     {", "float [  ]  [  ]    pcm    =     _ pcm [  0  ]  ;", "int   bout    =     ( samples    <     ( convsize )  )     ?    samples    :    convsize ;", "for    ( int   i    =     0  ;    i    <     ( oggInfo . channels )  ;    i +  +  )     {", "int   ptr    =    i    *     2  ;", "int   mono    =     _ index [ i ]  ;", "for    ( int   j    =     0  ;    j    <    bout ;    j +  +  )     {", "int   val    =     (  ( int )     (  ( pcm [ i ]  [  ( mono    +    j )  ]  )     *     3  2  7  6  7  .  0  )  )  ;", "if    ( val    >     3  2  7  6  7  )     {", "val    =     3  2  7  6  7  ;", "}", "if    ( val    <     (  -  3  2  7  6  8  )  )     {", "val    =     -  3  2  7  6  8  ;", "}", "if    ( val    <     0  )", "val    =    val    |     3  2  7  6  8  ;", "if    ( bigEndian )     {", "convbuffer [ ptr ]     =     (  ( byte )     ( val    >  >  >     8  )  )  ;", "convbuffer [  ( ptr    +     1  )  ]     =     (  ( byte )     ( val )  )  ;", "} else    {", "convbuffer [ ptr ]     =     (  ( byte )     ( val )  )  ;", "convbuffer [  ( ptr    +     1  )  ]     =     (  ( byte )     ( val    >  >  >     8  )  )  ;", "}", "ptr    +  =     2     *     ( oggInfo . channels )  ;", "}", "}", "int   bytesToWrite    =     (  2     *     ( oggInfo . channels )  )     *    bout ;", "if    (  (  ( outIndex )     +    bytesToWrite )     >     ( outBuffer . length )  )     {", "throw   new   GdxRuntimeException (  (  (  (  \" Ogg   block   too   big   to   be   buffered :     \"     +    bytesToWrite )     +     \"  ,     \"  )     +     (  ( outBuffer . length )     -     ( outIndex )  )  )  )  ;", "} else    {", "System . arraycopy ( convbuffer ,     0  ,    outBuffer ,    outIndex ,    bytesToWrite )  ;", "outIndex    +  =    bytesToWrite ;", "}", "wrote    =    true ;", "dspState . synthesis _ read ( bout )  ;", "}", "}", "}", "if    (  ( page . eos (  )  )     !  =     0  )     {", "endOfBitStream    =    true ;", "}", "if    (  (  !  ( endOfBitStream )  )     &  &    wrote )     {", "return ;", "}", "}", "}", "if    (  !  ( endOfBitStream )  )     {", "bytes    =     0  ;", "int   index    =    syncState . buffer (  . BUFFER _ SIZE )  ;", "if    ( index    >  =     0  )     {", "buffer    =    syncState . data ;", "try    {", "bytes    =    input . read ( buffer ,    index ,     . BUFFER _ SIZE )  ;", "}    catch    ( Exception   e )     {", "throw   new   GdxRuntimeException (  \" Error   during   Vorbis   decoding .  \"  ,    e )  ;", "}", "} else    {", "bytes    =     0  ;", "}", "syncState . wrote ( bytes )  ;", "if    (  ( bytes )     =  =     0  )     {", "endOfBitStream    =    true ;", "}", "}", "}", "streamState . clear (  )  ;", "vorbisBlock . clear (  )  ;", "dspState . clear (  )  ;", "oggInfo . clear (  )  ;", "}", "syncState . clear (  )  ;", "endOfStream    =    true ;", "}", "METHOD_END"], "methodName": ["readPCM"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OggInputStream"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    allSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    allSources . get ( i )  ;", "int   state    =    alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  ;", "if    ( state    !  =     ( AL _ STOPPED )  )", "alSourceStop ( sourceID )  ;", "alDeleteSources ( sourceID )  ;", "}", "sourceToSoundId . clear (  )  ;", "soundIdToSource . clear (  )  ;", "AL . destroy (  )  ;", "while    ( AL . isCreated (  )  )     {", "try    {", "Thread . sleep (  1  0  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( recentSounds . length )  ;    i +  +  )     {", "if    (  ( recentSounds [ i ]  )     =  =    sound )", "recentSounds [ i ]     =    null ;", "}", "}", "METHOD_END"], "methodName": ["forget"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )     {", "if    ( sourceToSoundId . containsKey ( sourceID )  )     {", "long   soundId    =    sourceToSoundId . remove ( sourceID )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "alSourceStop ( sourceID )  ;", "alSourcei ( sourceID ,    AL _ BUFFER ,     0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["freeBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "alSourceStop ( sourceID )  ;", "alSourcei ( sourceID ,    AL _ BUFFER ,     0  )  ;", "if    ( sourceToSoundId . containsKey ( sourceID )  )     {", "long   soundId    =    sourceToSoundId . remove ( sourceID )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "idleSources . add ( sourceID )  ;", "}", "METHOD_END"], "methodName": ["freeSource"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( sourceToSoundId . containsKey ( sourceId )  )  )", "return    -  1  ;", "return   sourceToSoundId . get ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["getSoundId"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return   new   audio . AudioDevice (  )     {", "@ Override", "public   void   writeSamples ( float [  ]    samples ,    int   offset ,    int   numSamples )     {", "}", "@ Override", "public   void   writeSamples ( short [  ]    samples ,    int   offset ,    int   numSamples )     {", "}", "@ Override", "public   void   setVolume ( float   volume )     {", "}", "@ Override", "public   boolean   isMono (  )     {", "return   isMono ;", "}", "@ Override", "public   int   getLatency (  )     {", "return    0  ;", "}", "@ Override", "public   void   dispose (  )     {", "}", "}  ;", "return   new   OpenALAudioDevice ( this ,    sampleRate ,    isMono ,    deviceBufferSize ,    deviceBufferCount )  ;", "}", "METHOD_END"], "methodName": ["newAudioDevice"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return   new   audio . AudioRecorder (  )     {", "@ Override", "public   void   read ( short [  ]    samples ,    int   offset ,    int   numSamples )     {", "}", "@ Override", "public   void   dispose (  )     {", "}", "}  ;", "return   new   JavaSoundAudioRecorder ( samplingRate ,    isMono )  ;", "}", "METHOD_END"], "methodName": ["newAudioRecorder"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )", "throw   new   IllegalArgumentException (  \" file   cannot   be   null .  \"  )  ;", "Class <  ?    extends   OpenALMusic >    musicClass    =    extensionToMusicClass . get ( file . extension (  )  . toLowerCase (  )  )  ;", "if    ( musicClass    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Unknown   file   extension   for   music :     \"     +    file )  )  ;", "try    {", "return   musicClass . getConstructor ( new   Class [  ]  {    OpenALAudio . class ,    FileHandle . class    }  )  . newInstance ( this ,    file )  ;", "}    catch    ( Exception   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  \" Error   creating   music    \"     +     ( musicClass . getName (  )  )  )     +     \"    for   file :     \"  )     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newMusic"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )", "throw   new   IllegalArgumentException (  \" file   cannot   be   null .  \"  )  ;", "Class <  ?    extends   OpenALSound >    soundClass    =    extensionToSoundClass . get ( file . extension (  )  . toLowerCase (  )  )  ;", "if    ( soundClass    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  \" Unknown   file   extension   for   sound :     \"     +    file )  )  ;", "try    {", "return   soundClass . getConstructor ( new   Class [  ]  {    OpenALAudio . class ,    FileHandle . class    }  )  . newInstance ( this ,    file )  ;", "}    catch    ( Exception   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  \" Error   creating   sound    \"     +     ( soundClass . getName (  )  )  )     +     \"    for   file :     \"  )     +    file )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newSound"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return    0  ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceId    =    idleSources . get ( i )  ;", "int   state    =    alGetSourcei ( sourceId ,    AL _ SOURCE _ STATE )  ;", "if    (  ( state    !  =     ( AL _ PLAYING )  )     &  &     ( state    !  =     ( AL _ PAUSED )  )  )     {", "if    ( isMusic )     {", "idleSources . removeIndex ( i )  ;", "} else    {", "if    ( sourceToSoundId . containsKey ( sourceId )  )     {", "long   soundId    =    sourceToSoundId . get ( sourceId )  ;", "sourceToSoundId . remove ( sourceId )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "long   soundId    =     ( nextSoundId )  +  +  ;", "sourceToSoundId . put ( sourceId ,    soundId )  ;", "soundIdToSource . put ( soundId ,    sourceId )  ;", "}", "alSourceStop ( sourceId )  ;", "alSourcei ( sourceId ,    AL _ BUFFER ,     0  )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ GAIN ,     1  )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ PITCH ,     1  )  ;", "AL 1  0  . alSource 3 f ( sourceId ,    AL _ POSITION ,     0  ,     0  ,     1  .  0 F )  ;", "return   sourceId ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["obtainSource"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "alSourcePause ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["pauseSound"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )", "alSourcePause ( sourceID )  ;", "}", "}", "METHOD_END"], "methodName": ["pauseSourcesWithBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( extension    =  =    null )", "throw   new   IllegalArgumentException (  \" extension   cannot   be   null .  \"  )  ;", "if    ( musicClass    =  =    null )", "throw   new   IllegalArgumentException (  \" musicClass   cannot   be   null .  \"  )  ;", "extensionToMusicClass . put ( extension ,    musicClass )  ;", "}", "METHOD_END"], "methodName": ["registerMusic"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( extension    =  =    null )", "throw   new   IllegalArgumentException (  \" extension   cannot   be   null .  \"  )  ;", "if    ( soundClass    =  =    null )", "throw   new   IllegalArgumentException (  \" soundClass   cannot   be   null .  \"  )  ;", "extensionToSoundClass . put ( extension ,    soundClass )  ;", "}", "METHOD_END"], "methodName": ["registerSound"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "if    (  ( alGetSourcei ( sourceId ,    AL _ SOURCE _ STATE )  )     =  =     ( AL _ PAUSED )  )", "alSourcePlay ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["resumeSound"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )     {", "if    (  ( alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  )     =  =     ( AL _ PAUSED )  )", "alSourcePlay ( sourceID )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resumeSourcesWithBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "( mostRecetSound )  +  +  ;", "mostRecetSound    %  =    recentSouength ;", "if    ( stop )     {", "if    (  ( recentSounds [ mostRecetSound ]  )     !  =    null )", "recentSounds [ mostRecetSound ]  . stop (  )  ;", "}", "recentSounds [ mostRecetSound ]     =    sound ;", "}", "METHOD_END"], "methodName": ["retain"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setSoundGain"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "alSourcei ( sourceId ,    AL _ LOOPING ,     ( looping    ?    AL 1  0  . AL _ TRUE    :    AL 1  0  . AL _ FALSE )  )  ;", "}", "METHOD_END"], "methodName": ["setSoundLooping"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "AL 1  0  . alSource 3 f ( sourceId ,    AL _ POSITION ,    MathUtils . cos (  (  (  ( pan    -     1  )     *     ( MathUtils . PI )  )     /     2  )  )  ,     0  ,    MathUtils . sin (  (  (  ( pan    +     1  )     *     ( MathUtils . PI )  )     /     2  )  )  )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setSoundPan"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "AL 1  0  . alSourcef ( sourceId ,    AL _ PITCH ,    pitch )  ;", "}", "METHOD_END"], "methodName": ["setSoundPitch"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( soundIdToSource . containsKey ( soundId )  )  )", "return ;", "int   sourceId    =    soundIdToSource . get ( soundId )  ;", "alSourceStop ( sourceId )  ;", "}", "METHOD_END"], "methodName": ["stopSound"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDevice )", "return ;", "for    ( int   i    =     0  ,    n    =    idleSources . size ;    i    <    n ;    i +  +  )     {", "int   sourceID    =    idleSources . get ( i )  ;", "if    (  ( alGetSourcei ( sourceID ,    AL _ BUFFER )  )     =  =    bufferID )     {", "if    ( sourceToSoundId . containsKey ( sourceID )  )     {", "long   soundId    =    sourceToSoundId . remove ( sourceID )  ;", "soundIdToSource . remove ( soundId )  ;", "}", "alSourceStop ( sourceID )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stopSourcesWithBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    ( noDev )", "return ;", "for    ( int   i    =     0  ;    i    <     ( mussize )  ;    i +  +  )", "musitems [ i ]  . update (  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudio"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffers )     =  =    null )", "return ;", "if    (  ( sourceID )     !  =     (  -  1  )  )     {", "freeSource ( sourceID )  ;", "sourceID    =     -  1  ;", "}", "alDeleteBuffers ( buffers )  ;", "buffers    =    null ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "int   written    =    Math . min ( bufferSize ,    length )  ;", "outer    :    while    ( true )     {", "int   buffers    =    alGetSourcei ( sourceID ,    AL _ BUFFERS _ PROCESSED )  ;", "while    (  ( buffers -  -  )     >     0  )     {", "int   bufferID    =    alSourceUnqueueBuffers ( sourceID )  ;", "if    ( bufferID    =  =     ( AL _ INVALID _ VALUE )  )", "break ;", "reredSeconds    +  =    secondsPerBuffer ;", "tempBuffer . clear (  )  ;", "tempBuffer . put ( data ,    offset ,    written )  . flip (  )  ;", "alBufferData ( bufferID ,    format ,    tempBuffer ,    sampleRate )  ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "break   outer ;", "}", "try    {", "Thread . sleep (  (  ( long )     (  1  0  0  0     *     ( secondsPerBuffer )  )  )  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "}", "if    (  (  !  ( isPlaying )  )     |  |     (  ( alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  )     !  =     ( AL _ PLAYING )  )  )     {", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "return   written ;", "}", "METHOD_END"], "methodName": ["fillBuffer"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return    ( format )     =  =     ( AL _ FORMAT _ STEREO 1  6  )     ?     2     :     1  ;", "}", "METHOD_END"], "methodName": ["getChannels"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  (  ( secondsPerBuffer )     *     ( bufferCount )  )     *     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getLatency"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return    0  ;", "return    ( reredSeconds )     +     ( alGetSourcef ( sourceID ,    AL _ SEC _ OFFSET )  )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return   sampleRate ;", "}", "METHOD_END"], "methodName": ["getRate"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "return    ( channels )     =  =     1  ;", "}", "METHOD_END"], "methodName": ["isMono"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return   false ;", "return   isPlaying ;", "}", "METHOD_END"], "methodName": ["isPlaying"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "renderedSeconds    =    position ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "this . volume    =    volume ;", "if    (  ( sourceID )     !  =     (  -  1  )  )", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setVolume"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "freeSource ( sourceID )  ;", "sourceID    =     -  1  ;", "renderedSeconds    =     0  ;", "isPlaying    =    false ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    ( length    <     0  )", "throw   new   IllegalArgumentException (  \" length   cannot   be    <     0  .  \"  )  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )     {", "sourceID    =    audio . obtainSource ( true )  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "if    (  ( buffers )     =  =    null )     {", "buffers    =    BufferUtils . createIntBuffer ( bufferCount )  ;", "alGenBuffers ( buffers )  ;", "if    (  ( alGetError (  )  )     !  =     ( AL _ NO _ ERROR )  )", "throw   new   utils . GdxRuntimeException (  \" Unabe   to   allocate   audio   buffers .  \"  )  ;", "}", "alSourcei ( sourceID ,    AL _ LOOPING ,    AL _ FALSE )  ;", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "int   queuedBuffers    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "int   written    =    Math . min ( bufferSize ,    length )  ;", "tempBuffer . clear (  )  ;", "tempBuffer . put ( data ,    offset ,    written )  . flip (  )  ;", "alBufferData ( bufferID ,    format ,    tempBuffer ,    sampleRate )  ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "length    -  =    written ;", "offset    +  =    written ;", "queuedBuffers +  +  ;", "}", "tempBuffer . clear (  )  . flip (  )  ;", "for    ( int   i    =    queuedBuffers ;    i    <     ( bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "alBufferData ( bufferID ,    format ,    tempBuffer ,    sampleRate )  ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "}", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "while    ( length    >     0  )     {", "int   written    =    fillBuffer ( data ,    offset ,    length )  ;", "length    -  =    written ;", "offset    +  =    written ;", "}", "}", "METHOD_END"], "methodName": ["writeSamples"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( bytes )     =  =    null )     |  |     (  ( bytes . length )     <     ( numSamples    *     2  )  )  )", "bytes    =    new   byte [ numSamples    *     2  ]  ;", "int   end    =    Math . min (  ( offset    +    numSamples )  ,    samples . length )  ;", "for    ( int   i    =    offset ,    ii    =     0  ;    i    <    end ;    i +  +  )     {", "float   floatSample    =    samples [ i ]  ;", "floatSample    =    MathUtils . clamp ( floatSample ,     (  -  1  .  0 F )  ,     1  .  0 F )  ;", "int   intSample    =     (  ( int )     ( floatSample    *     3  2  7  6  7  )  )  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     ( intSample    &     2  5  5  )  )  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     (  ( intSample    >  >     8  )     &     2  5  5  )  )  ;", "}", "writeSamples ( bytes ,     0  ,     ( numSamples    *     2  )  )  ;", "}", "METHOD_END"], "methodName": ["writeSamples"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( bytes )     =  =    null )     |  |     (  ( bytes . length )     <     ( numSamples    *     2  )  )  )", "bytes    =    new   byte [ numSamples    *     2  ]  ;", "int   end    =    Math . min (  ( offset    +    numSamples )  ,    samples . length )  ;", "for    ( int   i    =    offset ,    ii    =     0  ;    i    <    end ;    i +  +  )     {", "short   sample    =    samples [ i ]  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     ( sample    &     2  5  5  )  )  ;", "bytes [  ( ii +  +  )  ]     =     (  ( byte )     (  ( sample    >  >     8  )     &     2  5  5  )  )  ;", "}", "writeSamples ( bytes ,     0  ,     ( numSamples    *     2  )  )  ;", "}", "METHOD_END"], "methodName": ["writeSamples"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALAudioDevice"}, {"methodBody": ["METHOD_START", "{", "stop (  )  ;", "if    ( noDevice )", "return ;", "if    (  ( buffers )     =  =    null )", "return ;", "alDeleteBuffers ( buffers )  ;", "buffers    =    null ;", "onCompletionListener    =    null ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "OpenALMusic . tempBuffer . clear (  )  ;", "int   length    =    read ( OpenALMusic . tempBytes )  ;", "if    ( length    <  =     0  )     {", "if    ( isLooping )     {", "loop (  )  ;", "length    =    read ( OpenALMusic . tempBytes )  ;", "if    ( length    <  =     0  )", "return   false ;", "if    (  ( renderedSecondsQueue . size )     >     0  )     {", "renderedSecondsQueue . set (  0  ,     0  )  ;", "}", "} else", "return   false ;", "}", "float   previousLoadedSeconds    =     (  ( renderedSecondsQueue . size )     >     0  )     ?    renderedSecondsQueue . first (  )     :     0  ;", "float   currentBufferSeconds    =     (  ( maxSecondsPerBuffer )     *     (  ( float )     ( length )  )  )     /     (  ( float )     ( OpenALMusic . bufferSize )  )  ;", "renderedSecondsQueue . insert (  0  ,     ( previousLoadedSeconds    +    currentBufferSeconds )  )  ;", "OpenALMusic . tempBuffer . put ( OpenALMusic . tempBytes ,     0  ,    length )  . flip (  )  ;", "alBufferData ( bufferID ,    format ,    OpenALMusic . tempBuffer ,    sampleRate )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return    ( format )     =  =     ( AL _ FORMAT _ STEREO 1  6  )     ?     2     :     1  ;", "}", "METHOD_END"], "methodName": ["getChannels"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return    0  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return    0  ;", "return    ( renderedSeconds )     +     ( alGetSourcef ( sourceID ,    AL _ SEC _ OFFSET )  )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   sampleRate ;", "}", "METHOD_END"], "methodName": ["getRate"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   sourceID ;", "}", "METHOD_END"], "methodName": ["getSourceId"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   this . volume ;", "}", "METHOD_END"], "methodName": ["getVolume"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "return   isLooping ;", "}", "METHOD_END"], "methodName": ["isLooping"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return   false ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return   false ;", "return   isPlaying ;", "}", "METHOD_END"], "methodName": ["isPlaying"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "reset (  )  ;", "}", "METHOD_END"], "methodName": ["loop"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     !  =     (  -  1  )  )", "alSourcePause ( sourceID )  ;", "isPlaying    =    false ;", "}", "METHOD_END"], "methodName": ["pause"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )     {", "sourceID    =    audio . obtainSource ( true )  ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "audio . music . add ( this )  ;", "if    (  ( buffers )     =  =    null )     {", "buffers    =    BufferUtils . createIntBuffer ( OpenALMusic . bufferCount )  ;", "alGenBuffers ( buffers )  ;", "int   errorCode    =    alGetError (  )  ;", "if    ( errorCode    !  =     ( AL _ NO _ ERROR )  )", "throw   new   utils . GdxRuntimeException (  (  \" Unable   to   allocate   audio   buffers .    AL   Error :     \"     +    errorCode )  )  ;", "}", "alSourcei ( sourceID ,    AL _ LOOPING ,    AL _ FALSE )  ;", "setPan ( pan ,    volume )  ;", "boolean   filled    =    false ;", "for    ( int   i    =     0  ;    i    <     ( OpenALMusic . bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "if    (  !  ( fill ( bufferID )  )  )", "break ;", "filled    =    true ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "}", "if    (  (  ! filled )     &  &     (  ( onCompletionListener )     !  =    null )  )", "onCompletionListener . onCompletion ( this )  ;", "if    (  ( alGetError (  )  )     !  =     ( AL _ NO _ ERROR )  )     {", "stop (  )  ;", "return ;", "}", "}", "if    (  !  ( isPlaying )  )     {", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . isLooping    =    isLooping ;", "}", "METHOD_END"], "methodName": ["setLooping"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "onCompletionListener    =    listener ;", "}", "METHOD_END"], "methodName": ["setOnCompletionListener"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . volume    =    volume ;", "this . pan    =    pan ;", "if    ( noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "alSource 3 f ( sourceID ,    AL _ POSITION ,    MathUtils . cos (  (  (  ( pan    -     1  )     *     ( MathUtils . PI )  )     /     2  )  )  ,     0  ,    MathUtils . sin (  (  (  ( pan    +     1  )     *     ( MathUtils . PI )  )     /     2  )  )  )  ;", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setPan"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "boolean   wasPlaying    =    isPlaying ;", "isPlaying    =    false ;", "alSourceStop ( sourceID )  ;", "alSourceUnqueueBuffers ( sourceID ,    buffers )  ;", "while    (  ( renderedSecondsQueue . size )     >     0  )     {", "renderedSeconds    =    renderedSecondsQueue . pop (  )  ;", "}", "if    ( position    <  =     ( renderedSeconds )  )     {", "reset (  )  ;", "renderedSeconds    =     0  ;", "}", "while    (  ( renderedSeconds )     <     ( position    -     ( maxSecondsPerBuffer )  )  )     {", "if    (  ( read (  . tempBytes )  )     <  =     0  )", "break ;", "renderedSeconds    +  =    maxSecondsPerBuffer ;", "}", "renderedSecondsQueue . add ( renderedSeconds )  ;", "boolean   filled    =    false ;", "for    ( int   i    =     0  ;    i    <     (  . bufferCount )  ;    i +  +  )     {", "int   bufferID    =    buffers . get ( i )  ;", "if    (  !  ( fill ( bufferID )  )  )", "break ;", "filled    =    true ;", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "}", "renderedSecondsQueue . pop (  )  ;", "if    (  ! filled )     {", "stop (  )  ;", "if    (  ( onCompletionListener )     !  =    null )", "onCompletionListener . onCompletion ( this )  ;", "}", "alSourcef ( sourceID ,    AL _ SEC _ OFFSET ,     ( position    -     ( renderedSeconds )  )  )  ;", "if    ( wasPlaying )     {", "alSourcePlay ( sourceID )  ;", "isPlaying    =    true ;", "}", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . volume    =    volume ;", "if    ( noDevice )", "return ;", "if    (  ( sourceID )     !  =     (  -  1  )  )", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "}", "METHOD_END"], "methodName": ["setVolume"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "this . format    =     ( channels    >     1  )     ?    AL _ FORMAT _ STEREO 1  6     :    AL _ FORMAT _ MONO 1  6  ;", "this . sampleRate    =    sampleRate ;", "maxSecondsPerBuffer    =     (  ( float )     (  (  . bufferSize )     -     ( bufferOverhead )  )  )     /     (  (  (  . bytesPerSample )     *    channels )     *    sampleRate )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "audio . music . removeValue ( this ,    true )  ;", "reset (  )  ;", "audio . freeSource ( sourceID )  ;", "sourceID    =     -  1  ;", "renderedSeconds    =     0  ;", "renderedSecondsQueue . clear (  )  ;", "isPlaying    =    false ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( sourceID )     =  =     (  -  1  )  )", "return ;", "boolean   end    =    false ;", "int   buffers    =    alGetSourcei ( sourceID ,    AL _ BUFFERS _ PROCESSED )  ;", "while    (  ( buffers -  -  )     >     0  )     {", "int   bufferID    =    alSourceUnqueueBuffers ( sourceID )  ;", "if    ( bufferID    =  =     ( AL _ INVALID _ VALUE )  )", "break ;", "renderedSeconds    =    renderedSecondsQueue . pop (  )  ;", "if    ( end )", "continue ;", "if    ( fill ( bufferID )  )", "alSourceQueueBuffers ( sourceID ,    bufferID )  ;", "else", "end    =    true ;", "}", "if    ( end    &  &     (  ( alGetSourcei ( sourceID ,    AL _ BUFFERS _ QUEUED )  )     =  =     0  )  )     {", "stop (  )  ;", "if    (  ( onCompletionListener )     !  =    null )", "onCompletionListener . onCompletion ( this )  ;", "}", "if    (  ( isPlaying )     &  &     (  ( alGetSourcei ( sourceID ,    AL _ SOURCE _ STATE )  )     !  =     ( AL _ PLAYING )  )  )", "alSourcePlay ( sourceID )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "if    (  ( bufferID )     =  =     (  -  1  )  )", "return ;", "audio . freeBuffer ( bufferID )  ;", "alDeleteBuffers ( bufferID )  ;", "bufferID    =     -  1  ;", "audio . forget ( this )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "return   duration ;", "}", "METHOD_END"], "methodName": ["duration"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "return   loop (  1  )  ;", "}", "METHOD_END"], "methodName": ["loop"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "return   play (  1  )  ;", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return    0  ;", "int   sourceID    =    audio . obtainSource ( false )  ;", "if    ( sourceID    =  =     (  -  1  )  )     {", "audio . retain ( this ,    true )  ;", "sourceID    =    audio . obtainSource ( false )  ;", "} else", "audio . retain ( this ,    false )  ;", "if    ( sourceID    =  =     (  -  1  )  )", "return    -  1  ;", "long   soundId    =    audio . getSoundId ( sourceID )  ;", "alSourcei ( sourceID ,    AL _ BUFFER ,    bufferID )  ;", "alSourcei ( sourceID ,    AL _ LOOPING ,    AL _ FALSE )  ;", "alSourcef ( sourceID ,    AL _ GAIN ,    volume )  ;", "alSourcePlay ( sourceID )  ;", "return   soundId ;", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "int   bytes    =     ( pcm . length )     -     (  ( pcm . length )     %     ( channels    >     1     ?     4     :     2  )  )  ;", "int   samples    =    bytes    /     (  2     *    channels )  ;", "duration    =    samples    /     (  ( float )     ( sampleRate )  )  ;", "ByteBuffer   buffer    =    ByteBuffer . allocateDirect ( bytes )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "buffer . put ( pcm ,     0  ,    bytes )  ;", "buffer . flip (  )  ;", "if    (  ( bufferID )     =  =     (  -  1  )  )     {", "bufferID    =    alGenBuffers (  )  ;", "alBufferData ( bufferID ,     ( channels    >     1     ?    AL _ FORMAT _ STEREO 1  6     :    AL _ FORMAT _ MONO 1  6  )  ,    buffer . asShortBuffer (  )  ,    sampleRate )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALSound"}, {"methodBody": ["METHOD_START", "{", "if    ( audio . noDevice )", "return ;", "audio . stopSourcesWithBuffer ( bufferID )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.backends.lwjgl.audio.OpenALSound"}]